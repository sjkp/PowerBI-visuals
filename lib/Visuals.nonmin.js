!function(modules) {
    function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) return installedModules[moduleId].exports;
        var module = installedModules[moduleId] = {
            exports: {},
            id: moduleId,
            loaded: !1
        };
        return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
        module.loaded = !0, module.exports;
    }
    var installedModules = {};
    return __webpack_require__.m = modules, __webpack_require__.c = installedModules, 
    __webpack_require__.p = "", __webpack_require__(0);
}([ function(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(116);
}, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , function(module, exports, __webpack_require__) {
    window.jsCommon, window.powerbi, window.powerbitests, window.InJs, window.debug, 
    window.jasmine, window.Microsoft;
    window.jsCommon = window.jsCommon || {}, window.powerbi = window.powerbi || {}, 
    window.debug = window.debug || {}, window.InJs = window.InJs || {}, window.Microsoft = window.Microsoft || {}, 
    __webpack_require__(117), __webpack_require__(118), __webpack_require__(119), __webpack_require__(120);
}, function(module, exports) {}, function(module, exports) {}, function(module, exports, __webpack_require__) {
    module.exports = __webpack_require__.p + "images/locationButton.svg";
}, function(module, exports, __webpack_require__) {
    window.jsCommon, window.powerbi, window.powerbitests, window.InJs, window.debug, 
    window.jasmine, window.Microsoft;
    __webpack_require__(121), __webpack_require__(122), __webpack_require__(123), __webpack_require__(124), 
    __webpack_require__(125), __webpack_require__(126), __webpack_require__(127), __webpack_require__(128), 
    __webpack_require__(129), __webpack_require__(130), __webpack_require__(131), __webpack_require__(132), 
    __webpack_require__(133), __webpack_require__(134), __webpack_require__(135), __webpack_require__(136), 
    __webpack_require__(137), __webpack_require__(138), __webpack_require__(139), __webpack_require__(140), 
    __webpack_require__(141), __webpack_require__(142), __webpack_require__(143), __webpack_require__(144), 
    __webpack_require__(145), __webpack_require__(146), __webpack_require__(147), __webpack_require__(148), 
    __webpack_require__(149), __webpack_require__(150), __webpack_require__(151), __webpack_require__(152), 
    __webpack_require__(153), __webpack_require__(154), __webpack_require__(155), __webpack_require__(156), 
    __webpack_require__(157), __webpack_require__(158), __webpack_require__(159), __webpack_require__(160), 
    __webpack_require__(161), __webpack_require__(162), __webpack_require__(163), __webpack_require__(164), 
    __webpack_require__(165), __webpack_require__(166), __webpack_require__(167), __webpack_require__(168), 
    __webpack_require__(169), __webpack_require__(170), __webpack_require__(171), __webpack_require__(172), 
    __webpack_require__(173), __webpack_require__(174), __webpack_require__(175), __webpack_require__(176), 
    __webpack_require__(177), __webpack_require__(178), __webpack_require__(179), __webpack_require__(180), 
    __webpack_require__(181), __webpack_require__(182), __webpack_require__(183), __webpack_require__(184), 
    __webpack_require__(185), __webpack_require__(186), __webpack_require__(187), __webpack_require__(188), 
    __webpack_require__(189), __webpack_require__(190), __webpack_require__(191), __webpack_require__(192), 
    __webpack_require__(193), __webpack_require__(194), __webpack_require__(195), __webpack_require__(196), 
    __webpack_require__(197), __webpack_require__(198), __webpack_require__(199), __webpack_require__(200), 
    __webpack_require__(201), __webpack_require__(202), __webpack_require__(203), __webpack_require__(204), 
    __webpack_require__(205), __webpack_require__(206), __webpack_require__(207), __webpack_require__(208), 
    __webpack_require__(209), __webpack_require__(210), __webpack_require__(211), __webpack_require__(212), 
    __webpack_require__(213), __webpack_require__(214), __webpack_require__(215), __webpack_require__(216), 
    __webpack_require__(217), __webpack_require__(218), __webpack_require__(219), __webpack_require__(220), 
    __webpack_require__(221), __webpack_require__(222), __webpack_require__(223), __webpack_require__(224), 
    __webpack_require__(225), __webpack_require__(226), __webpack_require__(227), __webpack_require__(228), 
    __webpack_require__(229), __webpack_require__(230), __webpack_require__(231), __webpack_require__(232), 
    __webpack_require__(233), __webpack_require__(234), __webpack_require__(235), __webpack_require__(236), 
    __webpack_require__(237), __webpack_require__(238), __webpack_require__(239), __webpack_require__(240), 
    __webpack_require__(241), __webpack_require__(242), __webpack_require__(243), __webpack_require__(244), 
    __webpack_require__(245), __webpack_require__(246), __webpack_require__(247), __webpack_require__(248), 
    __webpack_require__(249), __webpack_require__(250), __webpack_require__(251), __webpack_require__(252), 
    __webpack_require__(253), __webpack_require__(254), __webpack_require__(255), __webpack_require__(256), 
    __webpack_require__(257), __webpack_require__(258), __webpack_require__(259), __webpack_require__(260), 
    __webpack_require__(261), __webpack_require__(262), __webpack_require__(263), __webpack_require__(264), 
    __webpack_require__(265), __webpack_require__(266), __webpack_require__(267), __webpack_require__(268), 
    __webpack_require__(269), __webpack_require__(270), __webpack_require__(271), __webpack_require__(272), 
    __webpack_require__(273), __webpack_require__(274), __webpack_require__(275), __webpack_require__(276), 
    __webpack_require__(277), __webpack_require__(278), __webpack_require__(279), __webpack_require__(280), 
    __webpack_require__(281), __webpack_require__(282), __webpack_require__(283), __webpack_require__(284), 
    __webpack_require__(285), __webpack_require__(286), __webpack_require__(287), __webpack_require__(288), 
    __webpack_require__(289), __webpack_require__(290);
}, function(module, exports) {
    window.jsCommon, window.powerbi, window.powerbitests, window.InJs, window.debug, 
    window.jasmine, window.Microsoft;
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var Point = function() {
                function Point(x, y) {
                    this.x = x || 0, this.y = y || 0;
                }
                return Point;
            }();
            visuals.Point = Point;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var Rect = function() {
                function Rect(left, top, width, height) {
                    this.left = left || 0, this.top = top || 0, this.width = width || 0, this.height = height || 0;
                }
                return Rect;
            }();
            visuals.Rect = Rect;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var Font;
            !function(Font) {
                var FamilyInfo = function() {
                    function FamilyInfo(families) {
                        this.families = families;
                    }
                    return Object.defineProperty(FamilyInfo.prototype, "family", {
                        get: function() {
                            return this.getFamily();
                        },
                        enumerable: !0,
                        configurable: !0
                    }), FamilyInfo.prototype.getFamily = function(regex) {
                        return void 0 === regex && (regex = /^wf_/), this.families ? regex ? _.find(this.families, function(fontFamily) {
                            return regex.test(fontFamily);
                        }) : this.families[0] : null;
                    }, Object.defineProperty(FamilyInfo.prototype, "css", {
                        get: function() {
                            return this.getCSS();
                        },
                        enumerable: !0,
                        configurable: !0
                    }), FamilyInfo.prototype.getCSS = function() {
                        return this.families ? this.families.map(function(font) {
                            return font.indexOf(" ") > 0 ? "'" + font + "'" : font;
                        }).join(", ") : null;
                    }, FamilyInfo;
                }();
                Font.FamilyInfo = FamilyInfo, Font.Family = {
                    light: new FamilyInfo([ "Segoe UI Light", "wf_segoe-ui_light", "helvetica", "arial", "sans-serif" ]),
                    semilight: new FamilyInfo([ "Segoe UI Semilight", "wf_segoe-ui_semilight", "helvetica", "arial", "sans-serif" ]),
                    regular: new FamilyInfo([ "Segoe UI", "wf_segoe-ui_normal", "helvetica", "arial", "sans-serif" ]),
                    semibold: new FamilyInfo([ "Segoe UI Semibold", "wf_segoe-ui_semibold", "helvetica", "arial", "sans-serif" ]),
                    bold: new FamilyInfo([ "Segoe UI Bold", "wf_segoe-ui_bold", "helvetica", "arial", "sans-serif" ]),
                    lightSecondary: new FamilyInfo([ "wf_standard-font_light", "helvetica", "arial", "sans-serif" ]),
                    regularSecondary: new FamilyInfo([ "wf_standard-font", "helvetica", "arial", "sans-serif" ]),
                    boldSecondary: new FamilyInfo([ "wf_standard-font_bold", "helvetica", "arial", "sans-serif" ])
                };
            }(Font = visuals.Font || (visuals.Font = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            function createLegend(legendParentElement, interactive, interactivityService, isScrollable, legendPosition) {
                return void 0 === isScrollable && (isScrollable = !1), void 0 === legendPosition && (legendPosition = LegendPosition.Top), 
                interactive ? new CartesianChartInteractiveLegend(legendParentElement) : new SVGLegend(legendParentElement, legendPosition, interactivityService, isScrollable);
            }
            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, PixelConverter = jsCommon.PixelConverter;
            !function(LegendIcon) {
                LegendIcon[LegendIcon.Box = 0] = "Box", LegendIcon[LegendIcon.Circle = 1] = "Circle", 
                LegendIcon[LegendIcon.Line = 2] = "Line";
            }(visuals.LegendIcon || (visuals.LegendIcon = {}));
            visuals.LegendIcon;
            !function(LegendPosition) {
                LegendPosition[LegendPosition.Top = 0] = "Top", LegendPosition[LegendPosition.Bottom = 1] = "Bottom", 
                LegendPosition[LegendPosition.Right = 2] = "Right", LegendPosition[LegendPosition.Left = 3] = "Left", 
                LegendPosition[LegendPosition.None = 4] = "None", LegendPosition[LegendPosition.TopCenter = 5] = "TopCenter", 
                LegendPosition[LegendPosition.BottomCenter = 6] = "BottomCenter", LegendPosition[LegendPosition.RightCenter = 7] = "RightCenter", 
                LegendPosition[LegendPosition.LeftCenter = 8] = "LeftCenter";
            }(visuals.LegendPosition || (visuals.LegendPosition = {}));
            var LegendPosition = visuals.LegendPosition;
            visuals.legendProps = {
                show: "show",
                position: "position",
                titleText: "titleText",
                showTitle: "showTitle",
                labelColor: "labelColor",
                fontSize: "fontSize"
            }, visuals.createLegend = createLegend;
            var Legend;
            !function(Legend) {
                function isLeft(orientation) {
                    switch (orientation) {
                      case LegendPosition.Left:
                      case LegendPosition.LeftCenter:
                        return !0;

                      default:
                        return !1;
                    }
                }
                function isTop(orientation) {
                    switch (orientation) {
                      case LegendPosition.Top:
                      case LegendPosition.TopCenter:
                        return !0;

                      default:
                        return !1;
                    }
                }
                function positionChartArea(chartArea, legend) {
                    var legendMargins = legend.getMargins(), legendOrientation = legend.getOrientation();
                    chartArea.style({
                        "margin-left": Legend.isLeft(legendOrientation) ? legendMargins.width + "px" : null,
                        "margin-top": Legend.isTop(legendOrientation) ? legendMargins.height + "px" : null
                    });
                }
                Legend.isLeft = isLeft, Legend.isTop = isTop, Legend.positionChartArea = positionChartArea;
            }(Legend = visuals.Legend || (visuals.Legend = {}));
            var SVGLegend = function() {
                function SVGLegend(element, legendPosition, interactivityService, isScrollable) {
                    this.legendDataStartIndex = 0, this.arrowPosWindow = 1, this.lastCalculatedWidth = 0, 
                    this.visibleLegendWidth = 0, this.visibleLegendHeight = 0, this.legendFontSizeMarginDifference = 0, 
                    this.legendFontSizeMarginValue = 0, this.svg = d3.select(element.get(0)).append("svg").style("position", "absolute"), 
                    this.svg.style("display", "inherit"), this.svg.classed("legend", !0), interactivityService && (this.clearCatcher = visuals.appendClearCatcher(this.svg)), 
                    this.group = this.svg.append("g").attr("id", "legendGroup"), this.interactivityService = interactivityService, 
                    this.isScrollable = isScrollable, this.element = element, this.changeOrientation(legendPosition), 
                    this.parentViewport = {
                        height: 0,
                        width: 0
                    }, this.calculateViewport(), this.updateLayout();
                }
                return SVGLegend.prototype.updateLayout = function() {
                    var legendViewport = this.viewport, orientation = this.orientation;
                    this.svg.attr({
                        height: legendViewport.height || (orientation === LegendPosition.None ? 0 : this.parentViewport.height),
                        width: legendViewport.width || (orientation === LegendPosition.None ? 0 : this.parentViewport.width)
                    });
                    var isRight = orientation === LegendPosition.Right || orientation === LegendPosition.RightCenter, isBottom = orientation === LegendPosition.Bottom || orientation === LegendPosition.BottomCenter;
                    this.svg.style({
                        "margin-left": isRight ? this.parentViewport.width - legendViewport.width + "px" : null,
                        "margin-top": isBottom ? this.parentViewport.height - legendViewport.height + "px" : null
                    });
                }, SVGLegend.prototype.calculateViewport = function() {
                    switch (this.orientation) {
                      case LegendPosition.Top:
                      case LegendPosition.Bottom:
                      case LegendPosition.TopCenter:
                      case LegendPosition.BottomCenter:
                        var pixelHeight = PixelConverter.fromPointToPixel(this.data && this.data.fontSize ? this.data.fontSize : SVGLegend.DefaultFontSizeInPt), fontHeightSize = SVGLegend.TopLegendHeight + (pixelHeight - SVGLegend.DefaultFontSizeInPt);
                        return void (this.viewport = {
                            height: fontHeightSize,
                            width: 0
                        });

                      case LegendPosition.Right:
                      case LegendPosition.Left:
                      case LegendPosition.RightCenter:
                      case LegendPosition.LeftCenter:
                        var width = this.lastCalculatedWidth ? this.lastCalculatedWidth : this.parentViewport.width * SVGLegend.LegendMaxWidthFactor;
                        return void (this.viewport = {
                            height: 0,
                            width: width
                        });

                      case LegendPosition.None:
                        this.viewport = {
                            height: 0,
                            width: 0
                        };
                    }
                }, SVGLegend.prototype.getMargins = function() {
                    return this.viewport;
                }, SVGLegend.prototype.isVisible = function() {
                    return this.orientation !== LegendPosition.None;
                }, SVGLegend.prototype.changeOrientation = function(orientation) {
                    orientation ? this.orientation = orientation : this.orientation = LegendPosition.Top, 
                    this.svg.attr("orientation", orientation);
                }, SVGLegend.prototype.getOrientation = function() {
                    return this.orientation;
                }, SVGLegend.prototype.drawLegend = function(data, viewport) {
                    for (var clonedData = powerbi.Prototype.inherit(data), newDataPoints = [], _i = 0, _a = data.dataPoints; _i < _a.length; _i++) {
                        var dp = _a[_i];
                        newDataPoints.push(powerbi.Prototype.inherit(dp));
                    }
                    clonedData.dataPoints = newDataPoints, this.setTooltipToLegendItems(clonedData), 
                    this.drawLegendInternal(clonedData, viewport, !0);
                }, SVGLegend.prototype.drawLegendInternal = function(data, viewport, autoWidth) {
                    this.parentViewport = viewport, this.data = data, this.interactivityService && this.interactivityService.applySelectionStateToData(data.dataPoints), 
                    0 === data.dataPoints.length && this.changeOrientation(LegendPosition.None), this.getOrientation() === LegendPosition.None && (data.dataPoints = []);
                    var mapControl = this.element.children(".mapControl");
                    mapControl.length > 0 && !this.isTopOrBottom(this.orientation) && mapControl.css("display", "inline-block"), 
                    this.calculateViewport();
                    var layout = this.calculateLayout(data, autoWidth), titleLayout = layout.title, titleData = titleLayout ? [ titleLayout ] : [], hasSelection = this.interactivityService && powerbi.visuals.dataHasSelection(data.dataPoints), group = this.group;
                    if (this.isCentered(this.orientation)) {
                        var centerOffset = 0;
                        this.isTopOrBottom(this.orientation) ? (centerOffset = Math.max(0, (this.parentViewport.width - this.visibleLegendWidth) / 2), 
                        group.attr("transform", visuals.SVGUtil.translate(centerOffset, 0))) : (centerOffset = Math.max((this.parentViewport.height - this.visibleLegendHeight) / 2), 
                        group.attr("transform", visuals.SVGUtil.translate(0, centerOffset)));
                    } else group.attr("transform", null);
                    var legendTitle = group.selectAll(SVGLegend.LegendTitle.selector).data(titleData);
                    legendTitle.enter().append("text").classed(SVGLegend.LegendTitle["class"], !0), 
                    legendTitle.style({
                        fill: data.labelColor,
                        "font-size": PixelConverter.fromPoint(data.fontSize),
                        "font-family": SVGLegend.DefaultTitleFontFamily
                    }).text(function(d) {
                        return d.text;
                    }).attr({
                        x: function(d) {
                            return d.x;
                        },
                        y: function(d) {
                            return d.y;
                        }
                    }).append("title").text(data.title), legendTitle.exit().remove();
                    var virtualizedDataPoints = data.dataPoints.slice(this.legendDataStartIndex, this.legendDataStartIndex + layout.numberOfItems), iconRadius = powerbi.TextMeasurementService.estimateSvgTextHeight(SVGLegend.getTextProperties(!1, "", this.data.fontSize)) / SVGLegend.LegendIconRadiusFactor;
                    iconRadius = this.legendFontSizeMarginValue > SVGLegend.DefaultTextMargin && iconRadius > SVGLegend.LegendIconRadius ? iconRadius : SVGLegend.LegendIconRadius;
                    var legendItems = group.selectAll(SVGLegend.LegendItem.selector).data(virtualizedDataPoints, function(d) {
                        return d.identity.getKey() + (null != d.layerNumber ? d.layerNumber : "");
                    }), itemsEnter = legendItems.enter().append("g").classed(SVGLegend.LegendItem["class"], !0);
                    if (itemsEnter.append("circle").classed(SVGLegend.LegendIcon["class"], !0), itemsEnter.append("text").classed(SVGLegend.LegendText["class"], !0), 
                    itemsEnter.append("title").text(function(d) {
                        return d.tooltip;
                    }), legendItems.select(SVGLegend.LegendIcon.selector).attr({
                        cx: function(d, i) {
                            return d.glyphPosition.x;
                        },
                        cy: function(d) {
                            return d.glyphPosition.y;
                        },
                        r: iconRadius
                    }).style({
                        fill: function(d) {
                            return hasSelection && !d.selected ? visuals.LegendBehavior.dimmedLegendColor : d.color;
                        }
                    }), legendItems.select("title").text(function(d) {
                        return d.tooltip;
                    }), legendItems.select(SVGLegend.LegendText.selector).attr({
                        x: function(d) {
                            return d.textPosition.x;
                        },
                        y: function(d) {
                            return d.textPosition.y;
                        }
                    }).text(function(d) {
                        return d.label;
                    }).style({
                        fill: data.labelColor,
                        "font-size": PixelConverter.fromPoint(data.fontSize)
                    }), this.interactivityService) {
                        var iconsSelection = legendItems.select(SVGLegend.LegendIcon.selector), behaviorOptions = {
                            legendItems: legendItems,
                            legendIcons: iconsSelection,
                            clearCatcher: this.clearCatcher
                        };
                        this.interactivityService.bind(data.dataPoints, new visuals.LegendBehavior(), behaviorOptions, {
                            isLegend: !0
                        });
                    }
                    legendItems.exit().remove(), this.drawNavigationArrows(layout.navigationArrows), 
                    this.updateLayout();
                }, SVGLegend.prototype.normalizePosition = function(points) {
                    this.legendDataStartIndex >= points.length && (this.legendDataStartIndex = points.length - 1), 
                    this.legendDataStartIndex < 0 && (this.legendDataStartIndex = 0);
                }, SVGLegend.prototype.calculateTitleLayout = function(title) {
                    var width = 0, hasTitle = !_.isEmpty(title);
                    if (hasTitle) {
                        var isHorizontal = this.isTopOrBottom(this.orientation), maxMeasureLength = void 0;
                        if (isHorizontal) {
                            var fontSizeMargin = this.legendFontSizeMarginValue > SVGLegend.DefaultTextMargin ? SVGLegend.TextAndIconPadding + this.legendFontSizeMarginDifference : SVGLegend.TextAndIconPadding, fixedHorizontalIconShift = SVGLegend.TextAndIconPadding + SVGLegend.LegendIconRadius, fixedHorizontalTextShift = SVGLegend.LegendIconRadius + fontSizeMargin + fixedHorizontalIconShift;
                            maxMeasureLength = this.parentViewport.width * SVGLegend.LegendMaxWidthFactor - fixedHorizontalTextShift - SVGLegend.LegendEdgeMariginWidth;
                        } else maxMeasureLength = this.legendFontSizeMarginValue < SVGLegend.DefaultTextMargin ? SVGLegend.MaxTitleLength : SVGLegend.MaxTitleLength + SVGLegend.DefaultMaxLegendFactor * this.legendFontSizeMarginDifference;
                        var textProperties = SVGLegend.getTextProperties(!0, title, this.data.fontSize), text = title;
                        return width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties), 
                        width > maxMeasureLength && (text = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, maxMeasureLength), 
                        textProperties.text = text, width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties)), 
                        isHorizontal ? width += SVGLegend.TitlePadding : text = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, this.viewport.width), 
                        {
                            x: 0,
                            y: 0,
                            text: text,
                            width: width,
                            height: powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties)
                        };
                    }
                    return null;
                }, SVGLegend.prototype.calculateLayout = function(data, autoWidth) {
                    var dataPoints = data.dataPoints;
                    if (0 === data.dataPoints.length) return {
                        numberOfItems: 0,
                        title: null,
                        navigationArrows: []
                    };
                    this.legendFontSizeMarginValue = PixelConverter.fromPointToPixel(this.data && void 0 !== this.data.fontSize ? this.data.fontSize : SVGLegend.DefaultFontSizeInPt), 
                    this.legendFontSizeMarginDifference = this.legendFontSizeMarginValue - SVGLegend.DefaultTextMargin, 
                    this.normalizePosition(dataPoints), this.legendDataStartIndex < dataPoints.length && (dataPoints = dataPoints.slice(this.legendDataStartIndex));
                    var navArrows, numberOfItems, title = this.calculateTitleLayout(data.title);
                    return this.isTopOrBottom(this.orientation) ? (navArrows = this.isScrollable ? this.calculateHorizontalNavigationArrowsLayout(title) : [], 
                    numberOfItems = this.calculateHorizontalLayout(dataPoints, title, navArrows)) : (navArrows = this.isScrollable ? this.calculateVerticalNavigationArrowsLayout(title) : [], 
                    numberOfItems = this.calculateVerticalLayout(dataPoints, title, navArrows, autoWidth)), 
                    {
                        numberOfItems: numberOfItems,
                        title: title,
                        navigationArrows: navArrows
                    };
                }, SVGLegend.prototype.updateNavigationArrowLayout = function(navigationArrows, remainingDataLength, visibleDataLength) {
                    0 === this.legendDataStartIndex && navigationArrows.shift();
                    var lastWindow = this.arrowPosWindow;
                    this.arrowPosWindow = visibleDataLength, navigationArrows && navigationArrows.length > 0 && this.arrowPosWindow === remainingDataLength && (this.arrowPosWindow = lastWindow, 
                    navigationArrows.length = navigationArrows.length - 1);
                }, SVGLegend.prototype.calculateHorizontalNavigationArrowsLayout = function(title) {
                    var height = SVGLegend.LegendArrowHeight, width = SVGLegend.LegendArrowWidth, translateY = this.viewport.height / 2 - height / 2, data = [], rightShift = title ? title.x + title.width : 0, arrowLeft = visuals.SVGUtil.createArrow(width, height, 180), arrowRight = visuals.SVGUtil.createArrow(width, height, 0);
                    return data.push({
                        x: rightShift,
                        y: translateY,
                        path: arrowLeft.path,
                        rotateTransform: arrowLeft.transform,
                        type: 1
                    }), data.push({
                        x: this.parentViewport.width - width,
                        y: translateY,
                        path: arrowRight.path,
                        rotateTransform: arrowRight.transform,
                        type: 0
                    }), data;
                }, SVGLegend.prototype.calculateVerticalNavigationArrowsLayout = function(title) {
                    var height = SVGLegend.LegendArrowHeight, width = SVGLegend.LegendArrowWidth, verticalCenter = this.viewport.height / 2, data = [], rightShift = verticalCenter + height / 2, arrowTop = visuals.SVGUtil.createArrow(width, height, 270), arrowBottom = visuals.SVGUtil.createArrow(width, height, 90), titleHeight = title ? title.height : 0;
                    return data.push({
                        x: rightShift,
                        y: width + titleHeight,
                        path: arrowTop.path,
                        rotateTransform: arrowTop.transform,
                        type: 1
                    }), data.push({
                        x: rightShift,
                        y: this.parentViewport.height - height,
                        path: arrowBottom.path,
                        rotateTransform: arrowBottom.transform,
                        type: 0
                    }), data;
                }, SVGLegend.calculateHorizontalLegendItemsWidths = function(dataPoints, availableWidth, iconPadding, fontSize) {
                    var dataPointsLength = dataPoints.length, maxItemWidth = dataPointsLength > 0 ? availableWidth / dataPointsLength | 0 : 0, maxItemTextWidth = maxItemWidth - iconPadding;
                    maxItemTextWidth < SVGLegend.MaxTextLength && (maxItemTextWidth = SVGLegend.MaxTextLength, 
                    maxItemWidth = maxItemTextWidth + iconPadding), maxItemWidth > availableWidth && (maxItemWidth = availableWidth, 
                    maxItemTextWidth = maxItemWidth - iconPadding);
                    for (var occupiedWidth = 0, legendItems = [], _i = 0, dataPoints_1 = dataPoints; _i < dataPoints_1.length; _i++) {
                        var dataPoint = dataPoints_1[_i], textProperties = SVGLegend.getTextProperties(!1, dataPoint.label, fontSize), itemTextWidth = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties), desiredWidth = itemTextWidth + iconPadding, overMaxWidth = desiredWidth > maxItemWidth, actualWidth = overMaxWidth ? maxItemWidth : desiredWidth;
                        if (occupiedWidth += actualWidth, occupiedWidth >= availableWidth) {
                            0 === legendItems.length ? (legendItems.push({
                                dataPoint: dataPoint,
                                textProperties: textProperties,
                                desiredWidth: desiredWidth,
                                desiredOverMaxWidth: !0,
                                width: desiredWidth
                            }), occupiedWidth = availableWidth) : occupiedWidth -= actualWidth;
                            break;
                        }
                        legendItems.push({
                            dataPoint: dataPoint,
                            textProperties: textProperties,
                            desiredWidth: desiredWidth,
                            desiredOverMaxWidth: overMaxWidth,
                            width: desiredWidth
                        });
                    }
                    var itemsOverMax = _.filter(legendItems, function(li) {
                        return li.desiredOverMaxWidth;
                    }), numItemsOverMax = itemsOverMax.length;
                    if (numItemsOverMax > 0) for (var extraWidth = availableWidth - occupiedWidth, _a = 0, itemsOverMax_1 = itemsOverMax; _a < itemsOverMax_1.length; _a++) {
                        var item = itemsOverMax_1[_a], extraWidthPerItem = extraWidth / numItemsOverMax, newMaxItemWidth = maxItemWidth + extraWidthPerItem, usedExtraWidth = void 0;
                        item.desiredWidth <= newMaxItemWidth ? (item.desiredOverMaxWidth = !1, usedExtraWidth = item.desiredWidth - maxItemWidth) : (item.width = newMaxItemWidth, 
                        usedExtraWidth = newMaxItemWidth - maxItemWidth), extraWidth -= usedExtraWidth, 
                        numItemsOverMax--;
                    }
                    return legendItems;
                }, SVGLegend.prototype.calculateHorizontalLayout = function(dataPoints, title, navigationArrows) {
                    var HorizontalTextShift = 4 + SVGLegend.LegendIconRadius, fontSizeBiggerThanDefault = this.legendFontSizeMarginDifference > 0, fontSizeMargin = fontSizeBiggerThanDefault ? SVGLegend.TextAndIconPadding + this.legendFontSizeMarginDifference : SVGLegend.TextAndIconPadding, fixedTextShift = fontSizeMargin / (SVGLegend.LegendIconRadiusFactor / 2) + HorizontalTextShift, occupiedWidth = 0, iconTotalItemPadding = 2 * SVGLegend.LegendIconRadius + 1.5 * fontSizeMargin, numberOfItems = dataPoints.length, defaultTextProperties = SVGLegend.getTextProperties(!1, "", this.data.fontSize), verticalCenter = this.viewport.height / 2, textYCoordinate = verticalCenter + powerbi.TextMeasurementService.estimateSvgTextHeight(defaultTextProperties) / 2 - powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(defaultTextProperties);
                    title && (occupiedWidth += title.width, title.y = verticalCenter + title.height / 2 - powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(SVGLegend.getTextProperties(!0, title.text, this.data.fontSize))), 
                    this.legendDataStartIndex > 0 && (occupiedWidth += SVGLegend.LegendArrowOffset);
                    var dataPointsLength = dataPoints.length, availableWidth = this.parentViewport.width - occupiedWidth, legendItems = SVGLegend.calculateHorizontalLegendItemsWidths(dataPoints, availableWidth, iconTotalItemPadding, this.data.fontSize);
                    numberOfItems = legendItems.length, numberOfItems !== dataPointsLength && (availableWidth -= SVGLegend.LegendArrowOffset, 
                    legendItems = SVGLegend.calculateHorizontalLegendItemsWidths(dataPoints, availableWidth, iconTotalItemPadding, this.data.fontSize), 
                    numberOfItems = legendItems.length);
                    for (var _i = 0, legendItems_1 = legendItems; _i < legendItems_1.length; _i++) {
                        var legendItem = legendItems_1[_i], dataPoint = legendItem.dataPoint;
                        if (dataPoint.glyphPosition = {
                            x: occupiedWidth + SVGLegend.LegendIconRadius + this.legendFontSizeMarginDifference / SVGLegend.LegendIconRadiusFactor,
                            y: this.viewport.height * SVGLegend.LegendIconYRatio
                        }, dataPoint.textPosition = {
                            x: occupiedWidth + fixedTextShift,
                            y: textYCoordinate
                        }, legendItem.desiredOverMaxWidth) {
                            var textWidth = legendItem.width - iconTotalItemPadding, text = powerbi.TextMeasurementService.getTailoredTextOrDefault(legendItem.textProperties, textWidth);
                            dataPoint.label = text;
                        }
                        occupiedWidth += legendItem.width;
                    }
                    return this.visibleLegendWidth = occupiedWidth, this.updateNavigationArrowLayout(navigationArrows, dataPointsLength, numberOfItems), 
                    numberOfItems;
                }, SVGLegend.prototype.calculateVerticalLayout = function(dataPoints, title, navigationArrows, autoWidth) {
                    var _this = this, fontSizeBiggerThenDefault = this.legendFontSizeMarginDifference > 0, fontFactor = fontSizeBiggerThenDefault ? this.legendFontSizeMarginDifference : 0, verticalLegendHeight = 20 + fontFactor, spaceNeededByTitle = 15 + fontFactor, extraShiftForTextAlignmentToIcon = 4 + fontFactor, totalSpaceOccupiedThusFar = verticalLegendHeight, fixedHorizontalIconShift = SVGLegend.TextAndIconPadding + SVGLegend.LegendIconRadius + this.legendFontSizeMarginDifference / SVGLegend.LegendIconRadiusFactor, fixedHorizontalTextShift = 2 * fixedHorizontalIconShift, maxHorizontalSpaceAvaliable = autoWidth ? this.parentViewport.width * SVGLegend.LegendMaxWidthFactor - fixedHorizontalTextShift - SVGLegend.LegendEdgeMariginWidth : this.lastCalculatedWidth - fixedHorizontalTextShift - SVGLegend.LegendEdgeMariginWidth, numberOfItems = dataPoints.length, maxHorizontalSpaceUsed = 0, parentHeight = this.parentViewport.height;
                    title && (totalSpaceOccupiedThusFar += spaceNeededByTitle, title.x = SVGLegend.TextAndIconPadding, 
                    title.y = spaceNeededByTitle, maxHorizontalSpaceUsed = title.width || 0), this.legendDataStartIndex > 0 && (totalSpaceOccupiedThusFar += SVGLegend.LegendArrowOffset);
                    for (var dataPointsLength = dataPoints.length, i = 0; dataPointsLength > i; i++) {
                        var dp = dataPoints[i], textProperties = SVGLegend.getTextProperties(!1, dp.label, this.data.fontSize);
                        dp.glyphPosition = {
                            x: fixedHorizontalIconShift,
                            y: totalSpaceOccupiedThusFar + extraShiftForTextAlignmentToIcon - powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(textProperties)
                        }, dp.textPosition = {
                            x: fixedHorizontalTextShift,
                            y: totalSpaceOccupiedThusFar + extraShiftForTextAlignmentToIcon
                        };
                        var width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                        if (width > maxHorizontalSpaceUsed && (maxHorizontalSpaceUsed = width), width > maxHorizontalSpaceAvaliable) {
                            var text = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, maxHorizontalSpaceAvaliable);
                            dp.label = text;
                        }
                        if (totalSpaceOccupiedThusFar += verticalLegendHeight, totalSpaceOccupiedThusFar > parentHeight) {
                            numberOfItems = i;
                            break;
                        }
                    }
                    return autoWidth ? maxHorizontalSpaceAvaliable > maxHorizontalSpaceUsed ? this.lastCalculatedWidth = this.viewport.width = Math.ceil(maxHorizontalSpaceUsed + fixedHorizontalTextShift + SVGLegend.LegendEdgeMariginWidth) : this.lastCalculatedWidth = this.viewport.width = Math.ceil(this.parentViewport.width * SVGLegend.LegendMaxWidthFactor) : this.viewport.width = this.lastCalculatedWidth, 
                    this.visibleLegendHeight = totalSpaceOccupiedThusFar, navigationArrows.forEach(function(d) {
                        return d.x = _this.lastCalculatedWidth / 2;
                    }), this.updateNavigationArrowLayout(navigationArrows, dataPointsLength, numberOfItems), 
                    numberOfItems;
                }, SVGLegend.prototype.drawNavigationArrows = function(layout) {
                    var _this = this, arrows = this.group.selectAll(SVGLegend.NavigationArrow.selector).data(layout);
                    arrows.enter().append("g").on("click", function(d) {
                        var pos = _this.legendDataStartIndex;
                        _this.legendDataStartIndex = 0 === d.type ? pos + _this.arrowPosWindow : pos - _this.arrowPosWindow, 
                        _this.drawLegendInternal(_this.data, _this.parentViewport, !1);
                    }).classed(SVGLegend.NavigationArrow["class"], !0).append("path"), arrows.attr("transform", function(d) {
                        return visuals.SVGUtil.translate(d.x, d.y);
                    }).select("path").attr({
                        d: function(d) {
                            return d.path;
                        },
                        transform: function(d) {
                            return d.rotateTransform;
                        }
                    }), arrows.exit().remove();
                }, SVGLegend.prototype.isTopOrBottom = function(orientation) {
                    switch (orientation) {
                      case LegendPosition.Top:
                      case LegendPosition.Bottom:
                      case LegendPosition.BottomCenter:
                      case LegendPosition.TopCenter:
                        return !0;

                      default:
                        return !1;
                    }
                }, SVGLegend.prototype.isCentered = function(orientation) {
                    switch (orientation) {
                      case LegendPosition.BottomCenter:
                      case LegendPosition.LeftCenter:
                      case LegendPosition.RightCenter:
                      case LegendPosition.TopCenter:
                        return !0;

                      default:
                        return !1;
                    }
                }, SVGLegend.prototype.reset = function() {}, SVGLegend.getTextProperties = function(isTitle, text, fontSize) {
                    return {
                        text: text,
                        fontFamily: isTitle ? SVGLegend.DefaultTitleFontFamily : SVGLegend.DefaultFontFamily,
                        fontSize: PixelConverter.fromPoint(fontSize || SVGLegend.DefaultFontSizeInPt)
                    };
                }, SVGLegend.prototype.setTooltipToLegendItems = function(data) {
                    for (var _i = 0, _a = data.dataPoints; _i < _a.length; _i++) {
                        var dataPoint = _a[_i];
                        dataPoint.tooltip = dataPoint.label;
                    }
                }, SVGLegend.DefaultFontSizeInPt = 8, SVGLegend.LegendIconRadius = 5, SVGLegend.LegendIconRadiusFactor = 5, 
                SVGLegend.MaxTextLength = 60, SVGLegend.MaxTitleLength = 80, SVGLegend.TextAndIconPadding = 5, 
                SVGLegend.TitlePadding = 15, SVGLegend.LegendEdgeMariginWidth = 10, SVGLegend.LegendMaxWidthFactor = .3, 
                SVGLegend.TopLegendHeight = 24, SVGLegend.DefaultTextMargin = PixelConverter.fromPointToPixel(SVGLegend.DefaultFontSizeInPt), 
                SVGLegend.DefaultMaxLegendFactor = SVGLegend.MaxTitleLength / SVGLegend.DefaultTextMargin, 
                SVGLegend.LegendIconYRatio = .52, SVGLegend.LegendArrowOffset = 10, SVGLegend.LegendArrowHeight = 15, 
                SVGLegend.LegendArrowWidth = 7.5, SVGLegend.DefaultFontFamily = visuals.Font.Family.regular.css, 
                SVGLegend.DefaultTitleFontFamily = visuals.Font.Family.semibold.css, SVGLegend.LegendItem = createClassAndSelector("legendItem"), 
                SVGLegend.LegendText = createClassAndSelector("legendText"), SVGLegend.LegendIcon = createClassAndSelector("legendIcon"), 
                SVGLegend.LegendTitle = createClassAndSelector("legendTitle"), SVGLegend.NavigationArrow = createClassAndSelector("navArrow"), 
                SVGLegend;
            }();
            visuals.SVGLegend = SVGLegend;
            var LegendData, CartesianChartInteractiveLegend = function() {
                function CartesianChartInteractiveLegend(element) {
                    this.legendContainerParent = d3.select(element.get(0));
                }
                return CartesianChartInteractiveLegend.prototype.getMargins = function() {
                    return {
                        height: CartesianChartInteractiveLegend.LegendHeight,
                        width: 0
                    };
                }, CartesianChartInteractiveLegend.prototype.drawLegend = function(legendData) {
                    var data = legendData.dataPoints;
                    if (!(data.length < 1)) {
                        var legendContainerDiv = this.legendContainerParent.select(CartesianChartInteractiveLegend.LegendContainerSelector);
                        if (legendContainerDiv.empty()) {
                            if (!data.length) return;
                            var divToPrepend = $("<div></div>").height(this.getMargins().height).addClass(CartesianChartInteractiveLegend.LegendContainerClass);
                            $(this.legendContainerParent[0]).prepend(divToPrepend), legendContainerDiv = d3.select(divToPrepend.get(0));
                        }
                        this.legendContainerDiv = legendContainerDiv, this.drawTitle(data), this.drawLegendItems(data);
                    }
                }, CartesianChartInteractiveLegend.prototype.reset = function() {
                    this.legendContainerDiv && (this.legendContainerDiv.remove(), this.legendContainerDiv = null);
                }, CartesianChartInteractiveLegend.prototype.isVisible = function() {
                    return !0;
                }, CartesianChartInteractiveLegend.prototype.changeOrientation = function(orientation) {}, 
                CartesianChartInteractiveLegend.prototype.getOrientation = function() {
                    return LegendPosition.Top;
                }, CartesianChartInteractiveLegend.prototype.drawTitle = function(data) {
                    var titleDiv = this.legendContainerDiv.selectAll("div." + CartesianChartInteractiveLegend.LegendTitleClass), item = titleDiv.data([ data[0] ]), itemEnter = item.enter(), titleDivEnter = itemEnter.append("div").attr("class", CartesianChartInteractiveLegend.LegendTitleClass);
                    titleDivEnter.filter(function(d) {
                        return d.iconOnlyOnLabel;
                    }).append("span").attr("class", CartesianChartInteractiveLegend.legendIconClass).html(CartesianChartInteractiveLegend.legendPlaceSelector), 
                    titleDivEnter.append("span"), item.filter(function(d) {
                        return d.iconOnlyOnLabel;
                    }).select("span." + CartesianChartInteractiveLegend.legendIconClass).style(CartesianChartInteractiveLegend.legendColorCss, function(d) {
                        return d.color;
                    }), item.select("span:last-child").text(function(d) {
                        return d.category;
                    });
                }, CartesianChartInteractiveLegend.prototype.drawLegendItems = function(data) {
                    this.ensureLegendTableCreated();
                    var dataPointsMatrix = [ data ], legendItemsContainer = this.legendContainerDiv.select("tbody").selectAll("tr").data(dataPointsMatrix), legendItemsEnter = legendItemsContainer.enter(), rowEnter = legendItemsEnter.append("tr"), cellEnter = rowEnter.selectAll("td").data(function(d) {
                        return d;
                    }, function(d) {
                        return d.label;
                    }).enter().append("td").attr("class", CartesianChartInteractiveLegend.LegendItem), cellSpanEnter = cellEnter.append("span");
                    cellSpanEnter.filter(function(d) {
                        return !d.iconOnlyOnLabel;
                    }).append("span").html(CartesianChartInteractiveLegend.legendPlaceSelector).attr("class", CartesianChartInteractiveLegend.legendIconClass).attr("white-space", "nowrap").style({
                        "font-size": "20px",
                        "margin-bottom": "7px"
                    }), cellSpanEnter.append("span").attr("class", CartesianChartInteractiveLegend.legendItemNameClass), 
                    cellSpanEnter.append("span").attr("class", CartesianChartInteractiveLegend.legendItemMeasureClass);
                    var legendCells = legendItemsContainer.selectAll("td").data(function(d) {
                        return d;
                    }, function(d) {
                        return d.label;
                    });
                    legendCells.select("span." + CartesianChartInteractiveLegend.legendItemNameClass).html(function(d) {
                        return powerbi.visuals.TextUtil.removeBreakingSpaces(d.label);
                    }), legendCells.select("span." + CartesianChartInteractiveLegend.legendItemMeasureClass).html(function(d) {
                        return "&nbsp;" + d.measure;
                    }), legendCells.select("span." + CartesianChartInteractiveLegend.legendIconClass).style("color", function(d) {
                        return d.color;
                    }), legendCells.exit().remove();
                }, CartesianChartInteractiveLegend.prototype.ensureLegendTableCreated = function() {
                    if (this.legendContainerDiv.select("div table").empty()) {
                        var legendTable = this.legendContainerDiv.append("div").append("table");
                        legendTable.style("table-layout", "fixed").append("tbody"), this.setPanGestureOnLegend(legendTable);
                    }
                }, CartesianChartInteractiveLegend.prototype.setPanGestureOnLegend = function(legendTable) {
                    var viewportWidth = $(this.legendContainerParent[0]).width(), xscale = d3.scale.linear().domain([ 0, viewportWidth ]).range([ 0, viewportWidth ]), zoom = d3.behavior.zoom().scaleExtent([ 1, 1 ]).x(xscale).on("zoom", function() {
                        if ($(legendTable[0]).width() > viewportWidth) {
                            var t = zoom.translate(), tx_1 = t[0], ty = t[1];
                            tx_1 = Math.min(tx_1, 0), tx_1 = Math.max(tx_1, viewportWidth - $(legendTable[0]).width()), 
                            zoom.translate([ tx_1, ty ]), legendTable.style("-ms-transform", function() {
                                return visuals.SVGUtil.translateXWithPixels(tx_1);
                            }), legendTable.style("-webkit-transform", function() {
                                return visuals.SVGUtil.translateXWithPixels(tx_1);
                            }), legendTable.style("transform", function() {
                                return visuals.SVGUtil.translateXWithPixels(tx_1);
                            });
                        }
                    });
                    this.legendContainerDiv ? this.legendContainerDiv.call(zoom) : legendTable.call(zoom);
                }, CartesianChartInteractiveLegend.LegendHeight = 70, CartesianChartInteractiveLegend.LegendContainerClass = "interactive-legend", 
                CartesianChartInteractiveLegend.LegendContainerSelector = ".interactive-legend", 
                CartesianChartInteractiveLegend.LegendTitleClass = "title", CartesianChartInteractiveLegend.LegendItem = "item", 
                CartesianChartInteractiveLegend.legendPlaceSelector = "●", CartesianChartInteractiveLegend.legendIconClass = "icon", 
                CartesianChartInteractiveLegend.legendColorCss = "color", CartesianChartInteractiveLegend.legendItemNameClass = "itemName", 
                CartesianChartInteractiveLegend.legendItemMeasureClass = "itemMeasure", CartesianChartInteractiveLegend;
            }();
            !function(LegendData) {
                function update(legendData, legendObject) {
                    if (null == legendObject[visuals.legendProps.show] && (legendObject[visuals.legendProps.show] = !0), 
                    legendObject[visuals.legendProps.show] === !1 && (legendData.dataPoints = []), legendObject[visuals.legendProps.show] === !0 && null == legendObject[visuals.legendProps.position] && (legendObject[visuals.legendProps.position] = visuals.legendPosition.top), 
                    void 0 !== legendObject[visuals.legendProps.fontSize] && (legendData.fontSize = legendObject[visuals.legendProps.fontSize]), 
                    void 0 !== legendObject[visuals.legendProps.labelColor]) {
                        var fillColor = legendObject[visuals.legendProps.labelColor];
                        null != fillColor && (legendData.labelColor = fillColor.solid.color);
                    }
                    legendObject[visuals.legendProps.showTitle] === !1 ? legendData.title = "" : void 0 !== legendObject[visuals.legendProps.titleText] && (legendData.title = legendObject[visuals.legendProps.titleText]);
                }
                LegendData.DefaultLegendLabelFillColor = "#666666", LegendData.update = update;
            }(LegendData = visuals.LegendData || (visuals.LegendData = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var axisScale;
            !function(axisScale) {
                axisScale.linear = "linear", axisScale.log = "log", axisScale.type = powerbi.createEnumType([ {
                    value: axisScale.linear,
                    displayName: function(resources) {
                        return resources.get("Visual_Axis_Linear");
                    }
                }, {
                    value: axisScale.log,
                    displayName: function(resources) {
                        return resources.get("Visual_Axis_Log");
                    }
                } ]);
            }(axisScale = visuals.axisScale || (visuals.axisScale = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var axisStyle;
            !function(axisStyle) {
                axisStyle.showBoth = "showBoth", axisStyle.showTitleOnly = "showTitleOnly", axisStyle.showUnitOnly = "showUnitOnly", 
                axisStyle.type = powerbi.createEnumType([ {
                    value: axisStyle.showTitleOnly,
                    displayName: function(resources) {
                        return resources.get("Visual_Axis_ShowTitleOnly");
                    }
                }, {
                    value: axisStyle.showUnitOnly,
                    displayName: function(resources) {
                        return resources.get("Visual_Axis_ShowUnitOnly");
                    }
                }, {
                    value: axisStyle.showBoth,
                    displayName: function(resources) {
                        return resources.get("Visual_Axis_ShowBoth");
                    }
                } ]);
            }(axisStyle = visuals.axisStyle || (visuals.axisStyle = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var axisType;
            !function(axisType) {
                axisType.scalar = "Scalar", axisType.categorical = "Categorical", axisType.both = "Both", 
                axisType.type = powerbi.createEnumType([ {
                    value: axisType.scalar,
                    displayName: function(resources) {
                        return resources.get("Visual_Axis_Scalar");
                    }
                }, {
                    value: axisType.categorical,
                    displayName: function(resources) {
                        return resources.get("Visual_Axis_Categorical");
                    }
                } ]);
            }(axisType = visuals.axisType || (visuals.axisType = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var basicShapeType;
            !function(basicShapeType) {
                basicShapeType.rectangle = "rectangle", basicShapeType.oval = "oval", basicShapeType.line = "line", 
                basicShapeType.arrow = "arrow", basicShapeType.triangle = "triangle", basicShapeType.type = powerbi.createEnumType([ {
                    value: basicShapeType.rectangle,
                    displayName: "rectangle"
                }, {
                    value: basicShapeType.oval,
                    displayName: "oval"
                }, {
                    value: basicShapeType.line,
                    displayName: "line"
                }, {
                    value: basicShapeType.arrow,
                    displayName: "arrow"
                }, {
                    value: basicShapeType.triangle,
                    displayName: "triangle"
                } ]);
            }(basicShapeType = visuals.basicShapeType || (visuals.basicShapeType = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var confidenceBandStyle;
            !function(confidenceBandStyle) {
                confidenceBandStyle.fill = "fill", confidenceBandStyle.line = "line", confidenceBandStyle.none = "none", 
                confidenceBandStyle.type = powerbi.createEnumType([ {
                    value: confidenceBandStyle.fill,
                    displayName: function(resources) {
                        return resources.get("Visual_Confidence_Band_Style_Fill");
                    }
                }, {
                    value: confidenceBandStyle.line,
                    displayName: function(resources) {
                        return resources.get("Visual_Confidence_Band_Style_Line");
                    }
                }, {
                    value: confidenceBandStyle.none,
                    displayName: function(resources) {
                        return resources.get("Visual_Confidence_Band_Style_None");
                    }
                } ]);
            }(confidenceBandStyle = visuals.confidenceBandStyle || (visuals.confidenceBandStyle = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var imageScalingType;
            !function(imageScalingType) {
                imageScalingType.normal = "Normal", imageScalingType.fit = "Fit", imageScalingType.fill = "Fill", 
                imageScalingType.type = powerbi.createEnumType([ {
                    value: imageScalingType.normal,
                    displayName: function(resources) {
                        return resources.get("Visual_ImageScalingType_Normal");
                    }
                }, {
                    value: imageScalingType.fit,
                    displayName: function(resources) {
                        return resources.get("Visual_ImageScalingType_Fit");
                    }
                }, {
                    value: imageScalingType.fill,
                    displayName: function(resources) {
                        return resources.get("Visual_ImageScalingType_Fill");
                    }
                } ]);
            }(imageScalingType = visuals.imageScalingType || (visuals.imageScalingType = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var labelPosition;
            !function(labelPosition) {
                labelPosition.insideEnd = "InsideEnd", labelPosition.insideCenter = "InsideCenter", 
                labelPosition.outsideEnd = "OutsideEnd", labelPosition.insideBase = "InsideBase", 
                labelPosition.type = powerbi.createEnumType([ {
                    value: labelPosition.insideEnd,
                    displayName: function(resources) {
                        return resources.get("Visual_LabelPosition_InsideEnd");
                    }
                }, {
                    value: labelPosition.outsideEnd,
                    displayName: function(resources) {
                        return resources.get("Visual_LabelPosition_OutsideEnd");
                    }
                }, {
                    value: labelPosition.insideCenter,
                    displayName: function(resources) {
                        return resources.get("Visual_LabelPosition_InsideCenter");
                    }
                }, {
                    value: labelPosition.insideBase,
                    displayName: function(resources) {
                        return resources.get("Visual_LabelPosition_InsideBase");
                    }
                } ]);
            }(labelPosition = visuals.labelPosition || (visuals.labelPosition = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var labelStyle;
            !function(labelStyle) {
                labelStyle.category = "Category", labelStyle.data = "Data", labelStyle.both = "Both", 
                labelStyle.type = powerbi.createEnumType([ {
                    value: labelStyle.category,
                    displayName: function(resources) {
                        return resources.get("Visual_LabelStyle_Category");
                    }
                }, {
                    value: labelStyle.data,
                    displayName: function(resources) {
                        return resources.get("Visual_LabelStyle_DataValue");
                    }
                }, {
                    value: labelStyle.both,
                    displayName: function(resources) {
                        return resources.get("Visual_LabelStyle_Both");
                    }
                } ]);
            }(labelStyle = visuals.labelStyle || (visuals.labelStyle = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var legendPosition;
            !function(legendPosition) {
                legendPosition.top = "Top", legendPosition.bottom = "Bottom", legendPosition.left = "Left", 
                legendPosition.right = "Right", legendPosition.topCenter = "TopCenter", legendPosition.bottomCenter = "BottomCenter", 
                legendPosition.leftCenter = "LeftCenter", legendPosition.rightCenter = "RightCenter", 
                legendPosition.type = powerbi.createEnumType([ {
                    value: legendPosition.top,
                    displayName: function(resources) {
                        return resources.get("Visual_LegendPosition_Top");
                    }
                }, {
                    value: legendPosition.bottom,
                    displayName: function(resources) {
                        return resources.get("Visual_LegendPosition_Bottom");
                    }
                }, {
                    value: legendPosition.left,
                    displayName: function(resources) {
                        return resources.get("Visual_LegendPosition_Left");
                    }
                }, {
                    value: legendPosition.right,
                    displayName: function(resources) {
                        return resources.get("Visual_LegendPosition_Right");
                    }
                }, {
                    value: legendPosition.topCenter,
                    displayName: function(resources) {
                        return resources.get("Visual_LegendPosition_TopCenter");
                    }
                }, {
                    value: legendPosition.bottomCenter,
                    displayName: function(resources) {
                        return resources.get("Visual_LegendPosition_BottomCenter");
                    }
                }, {
                    value: legendPosition.leftCenter,
                    displayName: function(resources) {
                        return resources.get("Visual_LegendPosition_LeftCenter");
                    }
                }, {
                    value: legendPosition.rightCenter,
                    displayName: function(resources) {
                        return resources.get("Visual_LegendPosition_RightCenter");
                    }
                } ]);
            }(legendPosition = visuals.legendPosition || (visuals.legendPosition = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var kpiDirection;
            !function(kpiDirection) {
                kpiDirection.positive = "Positive", kpiDirection.negative = "Negative", kpiDirection.type = powerbi.createEnumType([ {
                    value: kpiDirection.positive,
                    displayName: function(resources) {
                        return resources.get("Visual_KPI_Direction_Positive");
                    }
                }, {
                    value: kpiDirection.negative,
                    displayName: function(resources) {
                        return resources.get("Visual_KPI_Direction_Negative");
                    }
                } ]);
            }(kpiDirection = visuals.kpiDirection || (visuals.kpiDirection = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var lineStyle;
            !function(lineStyle) {
                lineStyle.dashed = "dashed", lineStyle.solid = "solid", lineStyle.dotted = "dotted", 
                lineStyle.type = powerbi.createEnumType([ {
                    value: lineStyle.dashed,
                    displayName: function(resources) {
                        return resources.get("Visual_LineStyle_Dashed");
                    }
                }, {
                    value: lineStyle.solid,
                    displayName: function(resources) {
                        return resources.get("Visual_LineStyle_Solid");
                    }
                }, {
                    value: lineStyle.dotted,
                    displayName: function(resources) {
                        return resources.get("Visual_LineStyle_Dotted");
                    }
                } ]);
            }(lineStyle = visuals.lineStyle || (visuals.lineStyle = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var outline;
            !function(outline_1) {
                function showTop(outline) {
                    return [ outline_1.topOnly, outline_1.topBottom, outline_1.frame ].some(function(o) {
                        return o === outline;
                    });
                }
                function showRight(outline) {
                    return [ outline_1.rightOnly, outline_1.leftRight, outline_1.frame ].some(function(o) {
                        return o === outline;
                    });
                }
                function showBottom(outline) {
                    return [ outline_1.bottomOnly, outline_1.topBottom, outline_1.frame ].some(function(o) {
                        return o === outline;
                    });
                }
                function showLeft(outline) {
                    return [ outline_1.leftOnly, outline_1.leftRight, outline_1.frame ].some(function(o) {
                        return o === outline;
                    });
                }
                outline_1.none = "None", outline_1.bottomOnly = "BottomOnly", outline_1.topOnly = "TopOnly", 
                outline_1.leftOnly = "LeftOnly", outline_1.rightOnly = "RightOnly", outline_1.topBottom = "TopBottom", 
                outline_1.leftRight = "LeftRight", outline_1.frame = "Frame", outline_1.showTop = showTop, 
                outline_1.showRight = showRight, outline_1.showBottom = showBottom, outline_1.showLeft = showLeft, 
                outline_1.type = powerbi.createEnumType([ {
                    value: outline_1.none,
                    displayName: function(resources) {
                        return resources.get("Visual_Outline_none");
                    }
                }, {
                    value: outline_1.bottomOnly,
                    displayName: function(resources) {
                        return resources.get("Visual_Outline_bottom_only");
                    }
                }, {
                    value: outline_1.topOnly,
                    displayName: function(resources) {
                        return resources.get("Visual_Outline_top_only");
                    }
                }, {
                    value: outline_1.leftOnly,
                    displayName: function(resources) {
                        return resources.get("Visual_Outline_LeftOnly");
                    }
                }, {
                    value: outline_1.rightOnly,
                    displayName: function(resources) {
                        return resources.get("Visual_Outline_RightOnly");
                    }
                }, {
                    value: outline_1.topBottom,
                    displayName: function(resources) {
                        return resources.get("Visual_Outline_top_Bottom");
                    }
                }, {
                    value: outline_1.leftRight,
                    displayName: function(resources) {
                        return resources.get("Visual_Outline_leftRight");
                    }
                }, {
                    value: outline_1.frame,
                    displayName: function(resources) {
                        return resources.get("Visual_Outline_frame");
                    }
                } ]);
            }(outline = visuals.outline || (visuals.outline = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var referenceLinePosition;
            !function(referenceLinePosition) {
                referenceLinePosition.back = "back", referenceLinePosition.front = "front", referenceLinePosition.type = powerbi.createEnumType([ {
                    value: referenceLinePosition.back,
                    displayName: function(resources) {
                        return resources.get("Visual_Reference_Line_Behind");
                    }
                }, {
                    value: referenceLinePosition.front,
                    displayName: function(resources) {
                        return resources.get("Visual_Reference_Line_InFront");
                    }
                } ]);
            }(referenceLinePosition = visuals.referenceLinePosition || (visuals.referenceLinePosition = {}));
            var referenceLineDataLabelHorizontalPosition;
            !function(referenceLineDataLabelHorizontalPosition) {
                referenceLineDataLabelHorizontalPosition.left = "left", referenceLineDataLabelHorizontalPosition.right = "right", 
                referenceLineDataLabelHorizontalPosition.type = powerbi.createEnumType([ {
                    value: referenceLineDataLabelHorizontalPosition.left,
                    displayName: function(resources) {
                        return resources.get("Visual_Reference_Line_Data_Label_Left");
                    }
                }, {
                    value: referenceLineDataLabelHorizontalPosition.right,
                    displayName: function(resources) {
                        return resources.get("Visual_Reference_Line_Data_Label_Right");
                    }
                } ]);
            }(referenceLineDataLabelHorizontalPosition = visuals.referenceLineDataLabelHorizontalPosition || (visuals.referenceLineDataLabelHorizontalPosition = {}));
            var referenceLineDataLabelVerticalPosition;
            !function(referenceLineDataLabelVerticalPosition) {
                referenceLineDataLabelVerticalPosition.above = "above", referenceLineDataLabelVerticalPosition.under = "under", 
                referenceLineDataLabelVerticalPosition.type = powerbi.createEnumType([ {
                    value: referenceLineDataLabelVerticalPosition.above,
                    displayName: function(resources) {
                        return resources.get("Visual_Reference_Line_Data_Label_Above");
                    }
                }, {
                    value: referenceLineDataLabelVerticalPosition.under,
                    displayName: function(resources) {
                        return resources.get("Visual_Reference_Line_Data_Label_Under");
                    }
                } ]);
            }(referenceLineDataLabelVerticalPosition = visuals.referenceLineDataLabelVerticalPosition || (visuals.referenceLineDataLabelVerticalPosition = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var slicerOrientation;
            !function(slicerOrientation) {
                slicerOrientation.type = powerbi.createEnumType([ {
                    value: 0,
                    displayName: function(resources) {
                        return resources.get("Slicer_Orientation_Vertical");
                    }
                }, {
                    value: 1,
                    displayName: function(resources) {
                        return resources.get("Slicer_Orientation_Horizontal");
                    }
                } ]);
            }(slicerOrientation = visuals.slicerOrientation || (visuals.slicerOrientation = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var yAxisPosition;
            !function(yAxisPosition) {
                yAxisPosition.left = "Left", yAxisPosition.right = "Right", yAxisPosition.type = powerbi.createEnumType([ {
                    value: yAxisPosition.left,
                    displayName: function(resources) {
                        return resources.get("Visual_yAxis_Left");
                    }
                }, {
                    value: yAxisPosition.right,
                    displayName: function(resources) {
                        return resources.get("Visual_yAxis_Right");
                    }
                } ]);
            }(yAxisPosition = visuals.yAxisPosition || (visuals.yAxisPosition = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var sliderMode;
            !function(sliderMode) {
                sliderMode.before = "Before", sliderMode.after = "After", sliderMode.between = "Between", 
                sliderMode.type = powerbi.createEnumType([ {
                    value: sliderMode.between,
                    displayName: function(resources) {
                        return resources.get("Visual_SliderMode_Between");
                    }
                }, {
                    value: sliderMode.before,
                    displayName: function(resources) {
                        return resources.get("Visual_SliderMode_Before");
                    }
                }, {
                    value: sliderMode.after,
                    displayName: function(resources) {
                        return resources.get("Visual_SliderMode_After");
                    }
                } ]);
            }(sliderMode = visuals.sliderMode || (visuals.sliderMode = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var AnimatorCommon;
            !function(AnimatorCommon) {
                function GetAnimationDuration(animator, suppressAnimations) {
                    return suppressAnimations || !animator ? 0 : animator.getDuration();
                }
                AnimatorCommon.MinervaAnimationDuration = 250, AnimatorCommon.MaxDataPointsToAnimate = 1e3, 
                AnimatorCommon.GetAnimationDuration = GetAnimationDuration;
            }(AnimatorCommon = visuals.AnimatorCommon || (visuals.AnimatorCommon = {}));
            var BaseAnimator = function() {
                function BaseAnimator(options) {
                    options && options.duration && (this.animationDuration = options.duration), this.animationDuration = this.animationDuration >= 0 ? this.animationDuration : AnimatorCommon.MinervaAnimationDuration;
                }
                return BaseAnimator.prototype.getDuration = function() {
                    return this.animationDuration;
                }, BaseAnimator.prototype.animate = function(options) {
                    return null;
                }, BaseAnimator.prototype.getEasing = function() {
                    return "cubic-in-out";
                }, BaseAnimator;
            }();
            visuals.BaseAnimator = BaseAnimator;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi), __extends = (window.powerbitests, 
    window.InJs, window.debug, window.jasmine, window.Microsoft, this && this.__extends || function(d, b) {
        function __() {
            this.constructor = d;
        }
        for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
    });
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var WebColumnChartAnimator = function(_super) {
                function WebColumnChartAnimator(options) {
                    _super.call(this, options);
                }
                return __extends(WebColumnChartAnimator, _super), WebColumnChartAnimator.prototype.animate = function(options) {
                    var result = {
                        failed: !0,
                        shapes: null
                    }, viewModel = options.viewModel, previousViewModel = this.previousViewModel, dataPointCount = viewModel.categories.length * viewModel.series.length;
                    return dataPointCount > visuals.AnimatorCommon.MaxDataPointsToAnimate ? result : (previousViewModel && (viewModel.hasHighlights && !previousViewModel.hasHighlights ? result = this.animateNormalToHighlighted(options) : viewModel.hasHighlights && previousViewModel.hasHighlights ? result = this.animateHighlightedToHighlighted(options) : !viewModel.hasHighlights && previousViewModel.hasHighlights && (result = this.animateHighlightedToNormal(options))), 
                    this.previousViewModel = viewModel, result);
                }, WebColumnChartAnimator.prototype.animateNormalToHighlighted = function(options) {
                    var data = options.viewModel, itemCS = options.itemCS, shapeSelection = options.series.selectAll(itemCS.selector), shapes = shapeSelection.data(function(d) {
                        return d.data;
                    }, function(d) {
                        return d.key;
                    }), hasHighlights = data.hasHighlights;
                    return shapes.enter().append("rect").attr("class", function(d) {
                        return itemCS["class"].concat(d.highlight ? " highlight" : "");
                    }).attr(options.layout.shapeLayoutWithoutHighlights), shapes.style("fill", function(d) {
                        return d.color;
                    }).style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !1, hasHighlights);
                    }).transition().duration(this.animationDuration).attr(options.layout.shapeLayout), 
                    shapes.exit().remove(), {
                        failed: !1,
                        shapes: shapes
                    };
                }, WebColumnChartAnimator.prototype.animateHighlightedToHighlighted = function(options) {
                    var shapes = this.animateDefaultShapes(options.viewModel, options.series, options.layout, options.itemCS);
                    return {
                        failed: !1,
                        shapes: shapes
                    };
                }, WebColumnChartAnimator.prototype.animateHighlightedToNormal = function(options) {
                    var itemCS = options.itemCS, shapeSelection = options.series.selectAll(itemCS.selector), shapes = shapeSelection.data(function(d) {
                        return d.data;
                    }, function(d) {
                        return d.key;
                    }), hasSelection = options.interactivityService && options.interactivityService.hasSelection();
                    return shapes.enter().append("rect").attr("class", function(d) {
                        return itemCS["class"].concat(d.highlight ? " highlight" : "");
                    }), shapes.style("fill", function(d) {
                        return d.color;
                    }).style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, d.selected, !d.selected);
                    }).transition().duration(this.animationDuration).attr(options.layout.shapeLayout).transition().duration(0).delay(this.animationDuration).style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, !1);
                    }), shapes.exit().transition().duration(this.animationDuration).attr(hasSelection ? options.layout.zeroShapeLayout : options.layout.shapeLayoutWithoutHighlights).remove(), 
                    {
                        failed: !1,
                        shapes: shapes
                    };
                }, WebColumnChartAnimator.prototype.animateDefaultShapes = function(data, series, layout, itemCS) {
                    var shapeSelection = series.selectAll(itemCS.selector), shapes = shapeSelection.data(function(d) {
                        return d.data;
                    }, function(d) {
                        return d.key;
                    });
                    return shapes.enter().append("rect").attr("class", function(d) {
                        return itemCS["class"].concat(d.highlight ? " highlight" : "");
                    }), shapes.style("fill", function(d) {
                        return d.color;
                    }).style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !1, data.hasHighlights);
                    }).transition().duration(this.animationDuration).attr(layout.shapeLayout), shapes.exit().remove(), 
                    shapes;
                }, WebColumnChartAnimator;
            }(visuals.BaseAnimator);
            visuals.WebColumnChartAnimator = WebColumnChartAnimator;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi), __extends = (window.powerbitests, 
    window.InJs, window.debug, window.jasmine, window.Microsoft, this && this.__extends || function(d, b) {
        function __() {
            this.constructor = d;
        }
        for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
    });
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var WebDonutChartAnimator = function(_super) {
                function WebDonutChartAnimator(options) {
                    _super.call(this, options);
                }
                return __extends(WebDonutChartAnimator, _super), WebDonutChartAnimator.prototype.animate = function(options) {
                    var result = {
                        failed: !0,
                        shapes: null,
                        highlightShapes: null
                    }, viewModel = options.viewModel, previousViewModel = this.previousViewModel;
                    if (viewModel.highlightsOverflow || previousViewModel && previousViewModel.highlightsOverflow) return this.previousViewModel = viewModel, 
                    result;
                    var previousHasHighlights = previousViewModel && previousViewModel.hasHighlights, currentHasHighlights = viewModel.hasHighlights;
                    return previousViewModel && (currentHasHighlights && !previousHasHighlights ? result = this.animateNormalToHighlighted(options) : currentHasHighlights && previousHasHighlights ? result = this.animateHighlightedToHighlighted(options) : !currentHasHighlights && previousHasHighlights && (result = this.animateHighlightedToNormal(options))), 
                    this.previousViewModel = viewModel, result;
                }, WebDonutChartAnimator.prototype.animateNormalToHighlighted = function(options) {
                    var shapes = this.animateDefaultShapes(options), highlightShapes = options.graphicsContext.select(".slices").selectAll("path.slice-highlight").data(options.viewModel.dataPoints.filter(function(value) {
                        return null != value.data.highlightRatio;
                    }), function(d) {
                        return d.data.identity.getKey();
                    });
                    return highlightShapes.enter().insert("path").classed("slice-highlight", !0).each(function(d) {
                        this._current = d;
                    }), visuals.DonutChart.isSingleColor(options.viewModel.dataPoints.filter(function(value) {
                        return null != value.data.highlightRatio;
                    })), highlightShapes.style("fill", function(d) {
                        return d.data.color ? d.data.color : options.colors.getNewColorScale().getColor(d.data.identity.getKey()).value;
                    }).style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.data.selected, !0, !1, options.viewModel.hasHighlights);
                    }).style("stroke-dasharray", function(d) {
                        return visuals.DonutChart.drawStrokeForDonutChart(options.radius, options.innerArcRadiusRatio, d, options.sliceWidthRatio, d.data.highlightRatio);
                    }).style("stroke-width", function(d) {
                        return d.data.strokeWidth;
                    }).attr(options.layout.shapeLayout).transition().duration(this.animationDuration).attr(options.layout.highlightShapeLayout), 
                    highlightShapes.exit().remove(), visuals.NewDataLabelUtils.drawDefaultLabels(options.labelGraphicsContext, options.labels, !1, !0, !0), 
                    visuals.NewDataLabelUtils.drawLabelLeaderLines(options.labelGraphicsContext, options.labels), 
                    {
                        failed: !1,
                        shapes: shapes,
                        highlightShapes: highlightShapes
                    };
                }, WebDonutChartAnimator.prototype.animateHighlightedToHighlighted = function(options) {
                    var shapes = this.animateDefaultShapes(options), highlightShapes = this.animateDefaultHighlightShapes(options);
                    return visuals.NewDataLabelUtils.drawDefaultLabels(options.labelGraphicsContext, options.labels, !1, !0, !0), 
                    visuals.NewDataLabelUtils.drawLabelLeaderLines(options.labelGraphicsContext, options.labels), 
                    {
                        failed: !1,
                        shapes: shapes,
                        highlightShapes: highlightShapes
                    };
                }, WebDonutChartAnimator.prototype.animateHighlightedToNormal = function(options) {
                    var hasSelection = options.interactivityService && options.interactivityService.hasSelection(), duration = this.animationDuration, shapes = options.graphicsContext.select(".slices").selectAll("path.slice").data(options.viewModel.dataPoints, function(d) {
                        return d.data.identity.getKey();
                    });
                    shapes.enter().insert("path").classed("slice", !0).each(function(d) {
                        this._current = d;
                    }), visuals.DonutChart.isSingleColor(options.viewModel.dataPoints), shapes.style("fill", function(d) {
                        return d.data.color ? d.data.color : options.colors.getNewColorScale().getColor(d.data.identity.getKey()).value;
                    }).style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.data.selected, !1, d.data.selected, !d.data.selected);
                    }).style("stroke-dasharray", function(d) {
                        return visuals.DonutChart.drawStrokeForDonutChart(options.radius, options.innerArcRadiusRatio, d, options.sliceWidthRatio);
                    }).style("stroke-width", function(d) {
                        return d.data.strokeWidth;
                    }).transition().duration(duration).attr(options.layout.shapeLayout).transition().duration(0).delay(duration).style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.data.selected, !1, hasSelection, !1);
                    }), shapes.exit().remove();
                    var highlightShapes = options.graphicsContext.select(".slices").selectAll("path.slice-highlight").data(options.viewModel.dataPoints.filter(function(value) {
                        return null != value.data.highlightRatio;
                    }), function(d) {
                        return d.data.identity.getKey();
                    });
                    return highlightShapes.enter().insert("path").classed("slice-highlight", !0).each(function(d) {
                        this._current = d;
                    }), visuals.DonutChart.isSingleColor(options.viewModel.dataPoints.filter(function(value) {
                        return null != value.data.highlightRatio;
                    })), highlightShapes.style("fill", function(d) {
                        return d.data.color ? d.data.color : options.colors.getNewColorScale().getColor(d.data.identity.getKey()).value;
                    }).style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(!1, !0, !1, !0);
                    }).style("stroke-dasharray", function(d) {
                        return visuals.DonutChart.drawStrokeForDonutChart(options.radius, options.innerArcRadiusRatio, d, options.sliceWidthRatio, d.data.highlightRatio);
                    }).style("stroke-width", function(d) {
                        return d.data.strokeWidth;
                    }).transition().duration(duration).attr(hasSelection ? options.layout.zeroShapeLayout : options.layout.shapeLayout).remove(), 
                    highlightShapes.exit().remove(), visuals.NewDataLabelUtils.drawDefaultLabels(options.labelGraphicsContext, options.labels, !1, !0, !0), 
                    visuals.NewDataLabelUtils.drawLabelLeaderLines(options.labelGraphicsContext, options.labels), 
                    {
                        failed: !1,
                        shapes: shapes,
                        highlightShapes: highlightShapes
                    };
                }, WebDonutChartAnimator.prototype.animateDefaultShapes = function(options) {
                    var shapes = options.graphicsContext.select(".slices").selectAll("path.slice").data(options.viewModel.dataPoints, function(d) {
                        return d.data.identity.getKey();
                    });
                    return shapes.enter().insert("path").classed("slice", !0).each(function(d) {
                        this._current = d;
                    }), visuals.DonutChart.isSingleColor(options.viewModel.dataPoints), shapes.style("fill", function(d) {
                        return d.data.color ? d.data.color : options.colors.getNewColorScale().getColor(d.data.identity.getKey()).value;
                    }).style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.data.selected, !1, !1, options.viewModel.hasHighlights);
                    }).style("stroke-dasharray", function(d) {
                        return visuals.DonutChart.drawStrokeForDonutChart(options.radius, options.innerArcRadiusRatio, d, options.sliceWidthRatio);
                    }).style("stroke-width", function(d) {
                        return d.data.strokeWidth;
                    }).transition().duration(this.animationDuration).attr(options.layout.shapeLayout), 
                    shapes.exit().remove(), shapes;
                }, WebDonutChartAnimator.prototype.animateDefaultHighlightShapes = function(options) {
                    var highlightShapes = options.graphicsContext.select(".slices").selectAll("path.slice-highlight").data(options.viewModel.dataPoints.filter(function(value) {
                        return null != value.data.highlightRatio;
                    }), function(d) {
                        return d.data.identity.getKey();
                    });
                    return highlightShapes.enter().insert("path").classed("slice-highlight", !0).each(function(d) {
                        this._current = d;
                    }), visuals.DonutChart.isSingleColor(options.viewModel.dataPoints.filter(function(value) {
                        return null != value.data.highlightRatio;
                    })), highlightShapes.style("fill", function(d) {
                        return d.data.color ? d.data.color : options.colors.getNewColorScale().getColor(d.data.identity.getKey()).value;
                    }).style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.data.selected, !0, !1, options.viewModel.hasHighlights);
                    }).style("stroke-dasharray", function(d) {
                        return visuals.DonutChart.drawStrokeForDonutChart(options.radius, options.innerArcRadiusRatio, d, options.sliceWidthRatio, d.data.highlightRatio);
                    }).style("stroke-width", function(d) {
                        return d.data.strokeWidth;
                    }).transition().duration(this.animationDuration).attr(options.layout.highlightShapeLayout), 
                    highlightShapes.exit().remove(), highlightShapes;
                }, WebDonutChartAnimator;
            }(visuals.BaseAnimator);
            visuals.WebDonutChartAnimator = WebDonutChartAnimator;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi), __extends = (window.powerbitests, 
    window.InJs, window.debug, window.jasmine, window.Microsoft, this && this.__extends || function(d, b) {
        function __() {
            this.constructor = d;
        }
        for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
    });
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var WebFunnelAnimator = function(_super) {
                function WebFunnelAnimator(options) {
                    _super.call(this, options);
                }
                return __extends(WebFunnelAnimator, _super), WebFunnelAnimator.prototype.animate = function(options) {
                    var result = {
                        failed: !0,
                        shapes: null,
                        dataLabels: null
                    }, viewModel = options.viewModel, previousViewModel = this.previousViewModel;
                    return previousViewModel && (viewModel.hasHighlights && !previousViewModel.hasHighlights ? result = this.animateNormalToHighlighted(options) : viewModel.hasHighlights && previousViewModel.hasHighlights ? result = this.animateHighlightedToHighlighted(options) : !viewModel.hasHighlights && previousViewModel.hasHighlights && (result = this.animateHighlightedToNormal(options))), 
                    this.previousViewModel = viewModel, result;
                }, WebFunnelAnimator.prototype.animateNormalToHighlighted = function(options) {
                    var data = options.viewModel, layout = options.layout, hasHighlights = !0, hasSelection = !1;
                    this.animateDefaultAxis(options.axisGraphicsContext, options.axisOptions, options.isHidingPercentBars);
                    var shapes = options.shapeGraphicsContext.selectAll(visuals.FunnelChart.Selectors.funnel.bars.selector).data(data.dataPoints, function(d) {
                        return d.key;
                    });
                    shapes.enter().append("rect").attr("class", function(d) {
                        return d.highlight ? visuals.FunnelChart.FunnelBarHighlightClass : visuals.FunnelChart.Selectors.funnel.bars["class"];
                    }).attr(layout.shapeLayoutWithoutHighlights), shapes.style("fill", function(d) {
                        return d.color;
                    }).style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, hasHighlights);
                    }).transition().duration(this.animationDuration).attr(layout.shapeLayout), shapes.exit().remove(), 
                    this.animatePercentBars(options);
                    var dataLabels = visuals.NewDataLabelUtils.animateDefaultLabels(options.labelGraphicsContext, options.labelLayout, this.animationDuration);
                    return {
                        failed: !1,
                        shapes: shapes,
                        dataLabels: dataLabels
                    };
                }, WebFunnelAnimator.prototype.animateHighlightedToHighlighted = function(options) {
                    var data = options.viewModel, layout = options.layout;
                    this.animateDefaultAxis(options.axisGraphicsContext, options.axisOptions, options.isHidingPercentBars);
                    var shapes = this.animateDefaultShapes(data, data.dataPoints, options.shapeGraphicsContext, layout);
                    this.animatePercentBars(options);
                    var dataLabels = visuals.NewDataLabelUtils.animateDefaultLabels(options.labelGraphicsContext, options.labelLayout, this.animationDuration);
                    return {
                        failed: !1,
                        shapes: shapes,
                        dataLabels: dataLabels
                    };
                }, WebFunnelAnimator.prototype.animateHighlightedToNormal = function(options) {
                    var data = options.viewModel, layout = options.layout, hasSelection = options.interactivityService ? options.interactivityService.hasSelection() : !1;
                    this.animateDefaultAxis(options.axisGraphicsContext, options.axisOptions, options.isHidingPercentBars);
                    var shapes = options.shapeGraphicsContext.selectAll(visuals.FunnelChart.Selectors.funnel.bars.selector).data(data.dataPoints, function(d) {
                        return d.key;
                    });
                    shapes.enter().append("rect").attr("class", function(d) {
                        return d.highlight ? visuals.FunnelChart.FunnelBarHighlightClass : visuals.FunnelChart.Selectors.funnel.bars["class"];
                    }), shapes.style("fill", function(d) {
                        return d.color;
                    }).style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, !d.selected);
                    }).transition().duration(this.animationDuration).attr(layout.shapeLayoutWithoutHighlights).transition().duration(0).delay(this.animationDuration).style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, !1);
                    });
                    var exitShapes = shapes.exit();
                    exitShapes.transition().duration(this.animationDuration).attr(hasSelection ? layout.zeroShapeLayout : layout.shapeLayoutWithoutHighlights).remove(), 
                    this.animatePercentBars(options);
                    var dataLabels = visuals.NewDataLabelUtils.animateDefaultLabels(options.labelGraphicsContext, options.labelLayout, this.animationDuration);
                    return {
                        failed: !1,
                        shapes: shapes,
                        dataLabels: dataLabels
                    };
                }, WebFunnelAnimator.prototype.animateDefaultAxis = function(graphicsContext, axisOptions, isHidingPercentBars) {
                    var xScaleForAxis = d3.scale.ordinal().domain(axisOptions.categoryLabels).rangeBands([ axisOptions.rangeStart, axisOptions.rangeEnd ], axisOptions.barToSpaceRatio, isHidingPercentBars ? axisOptions.barToSpaceRatio : visuals.FunnelChart.PercentBarToBarRatio), xAxis = d3.svg.axis().scale(xScaleForAxis).orient("right").tickPadding(visuals.FunnelChart.TickPadding).innerTickSize(visuals.FunnelChart.InnerTickSize);
                    graphicsContext.classed("axis", !0).transition().duration(this.animationDuration).attr("transform", visuals.SVGUtil.translate(0, axisOptions.margin.top)).call(xAxis);
                }, WebFunnelAnimator.prototype.animateDefaultShapes = function(data, dataPoints, graphicsContext, layout) {
                    var hasHighlights = data.hasHighlights, shapes = graphicsContext.selectAll(visuals.FunnelChart.Selectors.funnel.bars.selector).data(dataPoints, function(d) {
                        return d.key;
                    });
                    return shapes.enter().append("rect").attr("class", function(d) {
                        return d.highlight ? visuals.FunnelChart.FunnelBarHighlightClass : visuals.FunnelChart.Selectors.funnel.bars["class"];
                    }), shapes.style("fill", function(d) {
                        return d.color;
                    }).style("fill-opacity", function(d) {
                        return function(d) {
                            return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !1, hasHighlights);
                        };
                    }).transition().duration(this.animationDuration).attr(layout.shapeLayout), shapes.exit().remove(), 
                    shapes;
                }, WebFunnelAnimator.prototype.animatePercentBars = function(options) {
                    var data = options.viewModel, isHidingPercentBars = options.isHidingPercentBars;
                    if (isHidingPercentBars || !data.dataPoints || (data.hasHighlights ? data.dataPoints.length / 2 : data.dataPoints.length) < 2) return void this.animatePercentBarComponents([], options);
                    var dataPoints = [ data.dataPoints[data.hasHighlights ? 1 : 0], data.dataPoints[data.dataPoints.length - 1] ], baseline = visuals.FunnelChart.getValueFromDataPoint(dataPoints[0]);
                    if (0 >= baseline) return void this.animatePercentBarComponents([], options);
                    var percentData = dataPoints.map(function(dataPoint, i) {
                        return {
                            value: visuals.FunnelChart.getValueFromDataPoint(dataPoint),
                            percent: 0 === i ? 1 : visuals.FunnelChart.getValueFromDataPoint(dataPoint) / baseline,
                            isTop: 0 === i
                        };
                    });
                    this.animatePercentBarComponents(percentData, options);
                }, WebFunnelAnimator.prototype.animateToFunnelPercent = function(context, targetData, layout) {
                    return context.data(targetData).transition().duration(this.animationDuration).attr(layout);
                }, WebFunnelAnimator.prototype.animatePercentBarComponents = function(data, options) {
                    var graphicsContext = options.percentGraphicsContext, layout = options.layout, zeroData = [ {
                        percent: 0,
                        value: 0,
                        isTop: !0
                    }, {
                        percent: 0,
                        value: 0,
                        isTop: !1
                    } ], mainLine = graphicsContext.selectAll(visuals.FunnelChart.Selectors.percentBar.mainLine.selector).data(data);
                    this.animateToFunnelPercent(mainLine.exit(), zeroData, layout.percentBarLayout.mainLine).remove(), 
                    mainLine.enter().append("line").classed(visuals.FunnelChart.Selectors.percentBar.mainLine["class"], !0).data(zeroData).attr(layout.percentBarLayout.mainLine), 
                    this.animateToFunnelPercent(mainLine, data, layout.percentBarLayout.mainLine);
                    var leftTick = graphicsContext.selectAll(visuals.FunnelChart.Selectors.percentBar.leftTick.selector).data(data);
                    this.animateToFunnelPercent(leftTick.exit(), zeroData, layout.percentBarLayout.leftTick).remove(), 
                    leftTick.enter().append("line").classed(visuals.FunnelChart.Selectors.percentBar.leftTick["class"], !0).data(zeroData).attr(layout.percentBarLayout.leftTick), 
                    this.animateToFunnelPercent(leftTick, data, layout.percentBarLayout.leftTick);
                    var rightTick = graphicsContext.selectAll(visuals.FunnelChart.Selectors.percentBar.rightTick.selector).data(data);
                    this.animateToFunnelPercent(rightTick.exit(), zeroData, layout.percentBarLayout.rightTick).remove(), 
                    rightTick.enter().append("line").classed(visuals.FunnelChart.Selectors.percentBar.rightTick["class"], !0).data(zeroData).attr(layout.percentBarLayout.rightTick), 
                    this.animateToFunnelPercent(rightTick, data, layout.percentBarLayout.rightTick);
                    var text = graphicsContext.selectAll(visuals.FunnelChart.Selectors.percentBar.text.selector).data(data);
                    this.animateToFunnelPercent(text.exit(), zeroData, layout.percentBarLayout.text).remove(), 
                    text.enter().append("text").classed(visuals.FunnelChart.Selectors.percentBar.text["class"], !0).data(zeroData).attr(layout.percentBarLayout.text), 
                    this.animateToFunnelPercent(text, data, layout.percentBarLayout.text).text(function(fp) {
                        return powerbi.formattingService.formatValue(fp.percent, visuals.valueFormatter.getLocalizedString("Percentage1"));
                    }), visuals.SVGUtil.flushAllD3TransitionsIfNeeded(options.visualInitOptions);
                }, WebFunnelAnimator;
            }(visuals.BaseAnimator);
            visuals.WebFunnelAnimator = WebFunnelAnimator;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi), __extends = (window.powerbitests, 
    window.InJs, window.debug, window.jasmine, window.Microsoft, this && this.__extends || function(d, b) {
        function __() {
            this.constructor = d;
        }
        for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
    });
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var WebTreemapAnimator = function(_super) {
                function WebTreemapAnimator(options) {
                    _super.call(this, options);
                }
                return __extends(WebTreemapAnimator, _super), WebTreemapAnimator.prototype.animate = function(options) {
                    var result = {
                        failed: !0,
                        shapes: null,
                        highlightShapes: null,
                        majorLabels: null,
                        minorLabels: null
                    }, viewModel = options.viewModel, previousViewModel = this.previousViewModel;
                    return previousViewModel && (viewModel.hasHighlights && !previousViewModel.hasHighlights ? result = this.animateNormalToHighlighted(options) : viewModel.hasHighlights && previousViewModel.hasHighlights ? result = this.animateHighlightedToHighlighted(options) : !viewModel.hasHighlights && previousViewModel.hasHighlights && (result = this.animateHighlightedToNormal(options))), 
                    this.previousViewModel = viewModel, result;
                }, WebTreemapAnimator.prototype.animateNormalToHighlighted = function(options) {
                    var hasSelection = !1, hasHighlights = !0, shapes = this.animateDefaultShapes(options.shapeGraphicsContext, options.nodes, hasSelection, hasHighlights, options.layout), highlightShapes = options.shapeGraphicsContext.selectAll("." + visuals.Treemap.HighlightNodeClassName).data(options.highlightNodes, function(d) {
                        return d.key + "highlight";
                    });
                    highlightShapes.enter().append("rect").attr("class", options.layout.highlightShapeClass).attr(options.layout.shapeLayout), 
                    highlightShapes.style("fill", function(d) {
                        return visuals.Treemap.getFill(d, !0);
                    }).style("fill-opacity", function(d) {
                        return visuals.Treemap.getFillOpacity(d, hasSelection, hasHighlights, !0);
                    }).transition().duration(this.animationDuration).attr(options.layout.highlightShapeLayout), 
                    highlightShapes.exit().remove();
                    var majorLabels = this.animateDefaultMajorLabels(options.labelGraphicsContext, options.majorLabeledNodes, options.labelSettings, options.layout), minorLabels = this.animateDefaultMinorLabels(options.labelGraphicsContext, options.minorLabeledNodes, options.labelSettings, options.layout);
                    return {
                        failed: !1,
                        shapes: shapes,
                        highlightShapes: highlightShapes,
                        majorLabels: majorLabels,
                        minorLabels: minorLabels
                    };
                }, WebTreemapAnimator.prototype.animateHighlightedToHighlighted = function(options) {
                    var hasSelection = !1, hasHighlights = !0, shapes = this.animateDefaultShapes(options.shapeGraphicsContext, options.nodes, hasSelection, hasHighlights, options.layout);
                    options.shapeGraphicsContext.selectAll("." + visuals.Treemap.HighlightNodeClassName).data(options.highlightNodes, function(d) {
                        return d.key + "highlight";
                    });
                    var highlightShapes = this.animateDefaultHighlightShapes(options.shapeGraphicsContext, options.highlightNodes, hasSelection, hasHighlights, options.layout), majorLabels = this.animateDefaultMajorLabels(options.labelGraphicsContext, options.majorLabeledNodes, options.labelSettings, options.layout), minorLabels = this.animateDefaultMinorLabels(options.labelGraphicsContext, options.minorLabeledNodes, options.labelSettings, options.layout);
                    return {
                        failed: !1,
                        shapes: shapes,
                        highlightShapes: highlightShapes,
                        majorLabels: majorLabels,
                        minorLabels: minorLabels
                    };
                }, WebTreemapAnimator.prototype.animateHighlightedToNormal = function(options) {
                    var hasSelection = options.interactivityService ? options.interactivityService.hasSelection() : !1, shapes = options.shapeGraphicsContext.selectAll("." + visuals.Treemap.TreemapNodeClassName).data(options.nodes, function(d) {
                        return d.key;
                    });
                    shapes.enter().append("rect").attr("class", options.layout.shapeClass), shapes.transition().duration(this.animationDuration).style("fill", function(d) {
                        return visuals.Treemap.getFill(d, !1);
                    }).style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.selected, !1, d.selected, !d.selected);
                    }).attr(options.layout.shapeLayout).transition().duration(0).delay(this.animationDuration).style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.selected, !1, hasSelection, !1);
                    }), shapes.exit().remove();
                    var highlightShapes = options.shapeGraphicsContext.selectAll("." + visuals.Treemap.HighlightNodeClassName).data(options.nodes, function(d) {
                        return d.key + "highlight";
                    });
                    highlightShapes.enter().append("rect").attr("class", options.layout.highlightShapeClass), 
                    highlightShapes.style("fill", function(d) {
                        return visuals.Treemap.getFill(d, !0);
                    }).style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.selected, !0, d.selected, !d.selected);
                    }).transition().duration(this.animationDuration).attr(hasSelection ? options.layout.zeroShapeLayout : options.layout.shapeLayout).remove(), 
                    highlightShapes.exit().remove();
                    var majorLabels = this.animateDefaultMajorLabels(options.labelGraphicsContext, options.majorLabeledNodes, options.labelSettings, options.layout), minorLabels = this.animateDefaultMinorLabels(options.labelGraphicsContext, options.minorLabeledNodes, options.labelSettings, options.layout);
                    return {
                        failed: !1,
                        shapes: shapes,
                        highlightShapes: highlightShapes,
                        majorLabels: majorLabels,
                        minorLabels: minorLabels
                    };
                }, WebTreemapAnimator.prototype.animateDefaultShapes = function(context, nodes, hasSelection, hasHighlights, layout) {
                    var isHighlightShape = !1, shapes = context.selectAll("." + visuals.Treemap.TreemapNodeClassName).data(nodes, function(d) {
                        return d.key;
                    });
                    return shapes.enter().append("rect").attr("class", layout.shapeClass), shapes.transition().duration(this.animationDuration).style("fill", function(d) {
                        return visuals.Treemap.getFill(d, isHighlightShape);
                    }).style("fill-opacity", function(d) {
                        return visuals.Treemap.getFillOpacity(d, hasSelection, hasHighlights, isHighlightShape);
                    }).attr(layout.shapeLayout), shapes.exit().remove(), shapes;
                }, WebTreemapAnimator.prototype.animateDefaultHighlightShapes = function(context, nodes, hasSelection, hasHighlights, layout) {
                    var isHighlightShape = !0, highlightShapes = context.selectAll("." + visuals.Treemap.HighlightNodeClassName).data(nodes, function(d) {
                        return d.key + "highlight";
                    });
                    return highlightShapes.enter().append("rect").attr("class", layout.highlightShapeClass), 
                    highlightShapes.transition().duration(this.animationDuration).style("fill", function(d) {
                        return visuals.Treemap.getFill(d, isHighlightShape);
                    }).style("fill-opacity", function(d) {
                        return visuals.Treemap.getFillOpacity(d, hasSelection, hasHighlights, isHighlightShape);
                    }).attr(layout.highlightShapeLayout), highlightShapes.exit().remove(), highlightShapes;
                }, WebTreemapAnimator.prototype.animateDefaultMajorLabels = function(context, nodes, labelSettings, layout) {
                    var labels = context.selectAll("." + visuals.Treemap.MajorLabelClassName).data(nodes, function(d) {
                        return d.key;
                    });
                    return labels.enter().append("text").attr("class", layout.majorLabelClass), labels.text(layout.majorLabelText).style("fill", function() {
                        return labelSettings.labelColor;
                    }).transition().duration(this.animationDuration).attr(layout.majorLabelLayout), 
                    labels.exit().remove(), labels;
                }, WebTreemapAnimator.prototype.animateDefaultMinorLabels = function(context, nodes, labelSettings, layout) {
                    var labels = context.selectAll("." + visuals.Treemap.MinorLabelClassName).data(nodes, function(d) {
                        return d.key;
                    });
                    return labels.enter().append("text").attr("class", layout.minorLabelClass), labels.text(layout.minorLabelText).style("fill", function() {
                        return labelSettings.labelColor;
                    }).transition().duration(this.animationDuration).attr(layout.minorLabelLayout), 
                    labels.exit().remove(), labels;
                }, WebTreemapAnimator;
            }(visuals.BaseAnimator);
            visuals.WebTreemapAnimator = WebTreemapAnimator;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            visuals.StandardObjectProperties = {
                axisEnd: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_End"),
                    description: powerbi.data.createDisplayNameGetter("Visual_Axis_EndDescription"),
                    placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                    type: {
                        numeric: !0
                    },
                    suppressFormatPainterCopy: !0
                },
                axisScale: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Scale"),
                    type: {
                        enumeration: visuals.axisScale.type
                    }
                },
                axisStart: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Start"),
                    description: powerbi.data.createDisplayNameGetter("Visual_Axis_StartDescription"),
                    placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                    type: {
                        numeric: !0
                    },
                    suppressFormatPainterCopy: !0
                },
                axisStyle: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Style"),
                    type: {
                        enumeration: visuals.axisStyle.type
                    }
                },
                axisType: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Type"),
                    type: {
                        enumeration: visuals.axisType.type
                    }
                },
                backColor: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_BackColor"),
                    description: powerbi.data.createDisplayNameGetter("Visual_Tablix_BackColor_Desc"),
                    type: {
                        fill: {
                            solid: {
                                color: !0
                            }
                        }
                    }
                },
                dataColor: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                    description: powerbi.data.createDisplayNameGetter("Visual_LabelsFillDescription"),
                    type: {
                        fill: {
                            solid: {
                                color: !0
                            }
                        }
                    }
                },
                dataLabelColor: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Color"),
                    description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Color_Description"),
                    type: {
                        fill: {
                            solid: {
                                color: !0
                            }
                        }
                    }
                },
                dataLabelDecimalPoints: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Decimal_Points"),
                    placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                    type: {
                        numeric: !0
                    }
                },
                dataLabelDisplayUnits: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                    description: powerbi.data.createDisplayNameGetter("Visual_DisplayUnitsDescription"),
                    type: {
                        formatting: {
                            labelDisplayUnits: !0
                        }
                    },
                    suppressFormatPainterCopy: !0
                },
                dataLabelHorizontalPosition: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Horizontal_Position"),
                    description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Horizontal_Position_Description"),
                    type: {
                        enumeration: visuals.referenceLineDataLabelHorizontalPosition.type
                    }
                },
                dataLabelShow: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label"),
                    description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Show_Description"),
                    type: {
                        bool: !0
                    }
                },
                dataLabelVerticalPosition: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Vertical_Position"),
                    description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Vertical_Position_Description"),
                    type: {
                        enumeration: visuals.referenceLineDataLabelVerticalPosition.type
                    }
                },
                defaultColor: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DefaultColor"),
                    type: {
                        fill: {
                            solid: {
                                color: !0
                            }
                        }
                    }
                },
                fill: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                    type: {
                        fill: {
                            solid: {
                                color: !0
                            }
                        }
                    }
                },
                fontColor: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_FontColor"),
                    description: powerbi.data.createDisplayNameGetter("Visual_Tablix_FontColor_Desc"),
                    type: {
                        fill: {
                            solid: {
                                color: !0
                            }
                        }
                    }
                },
                fontSize: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                    type: {
                        formatting: {
                            fontSize: !0
                        }
                    }
                },
                formatString: {
                    type: {
                        formatting: {
                            formatString: !0
                        }
                    }
                },
                image: {
                    type: {
                        image: {}
                    }
                },
                labelColor: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_LegendTitleColor"),
                    type: {
                        fill: {
                            solid: {
                                color: !0
                            }
                        }
                    }
                },
                labelDisplayUnits: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                    description: powerbi.data.createDisplayNameGetter("Visual_DisplayUnitsDescription"),
                    type: {
                        formatting: {
                            labelDisplayUnits: !0
                        }
                    }
                },
                labelPrecision: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                    description: powerbi.data.createDisplayNameGetter("Visual_PrecisionDescription"),
                    placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                    type: {
                        numeric: !0
                    }
                },
                legendPosition: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_LegendPosition"),
                    description: powerbi.data.createDisplayNameGetter("Visual_LegendPositionDescription"),
                    type: {
                        enumeration: visuals.legendPosition.type
                    }
                },
                legendTitle: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_LegendName"),
                    description: powerbi.data.createDisplayNameGetter("Visual_LegendNameDescription"),
                    type: {
                        text: !0
                    }
                },
                lineColor: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Color"),
                    description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Color_Description"),
                    type: {
                        fill: {
                            solid: {
                                color: !0
                            }
                        }
                    }
                },
                outline: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Outline"),
                    type: {
                        enumeration: visuals.outline.type
                    }
                },
                outlineColor: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_OutlineColor"),
                    description: powerbi.data.createDisplayNameGetter("Visual_OutlineColor_Desc"),
                    type: {
                        fill: {
                            solid: {
                                color: !0
                            }
                        }
                    }
                },
                outlineWeight: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_OutlineWeight"),
                    description: powerbi.data.createDisplayNameGetter("Visual_OutlineWeight_Desc"),
                    type: {
                        numeric: !0
                    }
                },
                show: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                    type: {
                        bool: !0
                    }
                },
                showAllDataPoints: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint_Show_All"),
                    type: {
                        bool: !0
                    }
                },
                showLegendTitle: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitle"),
                    description: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitleDescription"),
                    type: {
                        bool: !0
                    }
                },
                referenceLinePosition: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Arrange"),
                    description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Arrange_Description"),
                    type: {
                        enumeration: visuals.referenceLinePosition.type
                    }
                },
                referenceLineStyle: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Style"),
                    description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Style_Description"),
                    type: {
                        enumeration: visuals.lineStyle.type
                    }
                },
                transparency: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_Background_Transparency"),
                    description: powerbi.data.createDisplayNameGetter("Visual_Background_TransparencyDescription"),
                    type: {
                        numeric: !0
                    }
                },
                yAxisPosition: {
                    displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis_Position"),
                    description: powerbi.data.createDisplayNameGetter("Visual_YAxis_PositionDescription"),
                    type: {
                        enumeration: visuals.yAxisPosition.type
                    }
                }
            };
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            visuals.animatedTextObjectDescs = {
                general: {
                    properties: {
                        formatString: visuals.StandardObjectProperties.formatString
                    }
                }
            }, visuals.animatedNumberCapabilities = {
                objects: visuals.animatedTextObjectDescs,
                dataViewMappings: [ {
                    single: {
                        role: "Values"
                    }
                } ],
                supportsSelection: !1
            };
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            visuals.basicShapeCapabilities = {
                objects: {
                    line: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_BasicShape_Line"),
                        properties: {
                            lineColor: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_BasicShape_LineColor"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            },
                            transparency: visuals.StandardObjectProperties.transparency,
                            weight: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_BasicShape_Weight"),
                                type: {
                                    numeric: !0
                                }
                            },
                            roundEdge: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_BasicShape_RoundEdges"),
                                type: {
                                    numeric: !0
                                }
                            }
                        }
                    },
                    fill: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            fillColor: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_BasicShape_FillColor"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            },
                            transparency: visuals.StandardObjectProperties.transparency
                        }
                    },
                    rotation: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_BasicShape_Rotate"),
                        properties: {
                            angle: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_BasicShape_Rotate"),
                                type: {
                                    numeric: !0
                                }
                            }
                        }
                    },
                    general: {
                        properties: {
                            shapeType: {
                                type: {
                                    text: !0
                                },
                                suppressFormatPainterCopy: !0
                            }
                        }
                    }
                },
                suppressDefaultTitle: !0,
                suppressDefaultPadding: !0,
                canRotate: !1,
                supportsSelection: !1
            }, visuals.basicShapeProps = {
                general: {
                    shapeType: {
                        objectName: "general",
                        propertyName: "shapeType"
                    }
                },
                line: {
                    transparency: {
                        objectName: "line",
                        propertyName: "transparency"
                    },
                    weight: {
                        objectName: "line",
                        propertyName: "weight"
                    },
                    roundEdge: {
                        objectName: "line",
                        propertyName: "roundEdge"
                    },
                    lineColor: {
                        objectName: "line",
                        propertyName: "lineColor"
                    }
                },
                fill: {
                    transparency: {
                        objectName: "fill",
                        propertyName: "transparency"
                    },
                    fillColor: {
                        objectName: "fill",
                        propertyName: "fillColor"
                    },
                    show: {
                        objectName: "fill",
                        propertyName: "show"
                    }
                },
                rotation: {
                    angle: {
                        objectName: "rotation",
                        propertyName: "angle"
                    }
                }
            };
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            function getColumnChartCapabilities(transposeAxes) {
                return void 0 === transposeAxes && (transposeAxes = !1), {
                    dataRoles: [ {
                        name: "Category",
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Axis"),
                        description: powerbi.data.createDisplayNameGetter("Role_DisplayName_AxisDescription"),
                        cartesianKind: 0
                    }, {
                        name: "Series",
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Legend"),
                        description: powerbi.data.createDisplayNameGetter("Role_DisplayName_LegendDescription")
                    }, {
                        name: "Y",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Value"),
                        requiredTypes: [ {
                            numeric: !0
                        }, {
                            integer: !0
                        } ],
                        cartesianKind: 1
                    }, {
                        name: "Gradient",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Gradient"),
                        description: powerbi.data.createDisplayNameGetter("Role_DisplayName_GradientDescription"),
                        requiredTypes: [ {
                            numeric: !0
                        }, {
                            integer: !0
                        } ],
                        joinPredicate: 0
                    } ],
                    objects: {
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                            properties: {
                                formatString: visuals.StandardObjectProperties.formatString
                            }
                        },
                        legend: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                            description: powerbi.data.createDisplayNameGetter("Visual_LegendDescription"),
                            properties: {
                                show: visuals.StandardObjectProperties.show,
                                position: visuals.StandardObjectProperties.legendPosition,
                                showTitle: visuals.StandardObjectProperties.showLegendTitle,
                                titleText: $.extend({}, visuals.StandardObjectProperties.legendTitle, {
                                    suppressFormatPainterCopy: !0
                                }),
                                labelColor: visuals.StandardObjectProperties.labelColor,
                                fontSize: visuals.StandardObjectProperties.fontSize
                            }
                        },
                        categoryAxis: {
                            displayName: transposeAxes ? powerbi.data.createDisplayNameGetter("Visual_YAxis") : powerbi.data.createDisplayNameGetter("Visual_XAxis"),
                            properties: {
                                show: visuals.StandardObjectProperties.show,
                                position: visuals.StandardObjectProperties.yAxisPosition,
                                axisScale: visuals.StandardObjectProperties.axisScale,
                                start: visuals.StandardObjectProperties.axisStart,
                                end: visuals.StandardObjectProperties.axisEnd,
                                axisType: visuals.StandardObjectProperties.axisType,
                                showAxisTitle: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                                    description: transposeAxes ? powerbi.data.createDisplayNameGetter("Visual_Axis_YTitleDescription") : powerbi.data.createDisplayNameGetter("Visual_Axis_XTitleDescription"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                axisStyle: visuals.StandardObjectProperties.axisStyle,
                                labelColor: visuals.StandardObjectProperties.labelColor,
                                labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
                                labelPrecision: visuals.StandardObjectProperties.labelPrecision
                            }
                        },
                        valueAxis: {
                            displayName: transposeAxes ? powerbi.data.createDisplayNameGetter("Visual_XAxis") : powerbi.data.createDisplayNameGetter("Visual_YAxis"),
                            properties: {
                                show: visuals.StandardObjectProperties.show,
                                position: visuals.StandardObjectProperties.yAxisPosition,
                                axisScale: visuals.StandardObjectProperties.axisScale,
                                start: visuals.StandardObjectProperties.axisStart,
                                end: visuals.StandardObjectProperties.axisEnd,
                                intersection: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Intersection"),
                                    type: {
                                        numeric: !0
                                    },
                                    placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto")
                                },
                                showAxisTitle: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                                    description: transposeAxes ? powerbi.data.createDisplayNameGetter("Visual_Axis_YTitleDescription") : powerbi.data.createDisplayNameGetter("Visual_Axis_XTitleDescription"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                axisStyle: visuals.StandardObjectProperties.axisStyle,
                                labelColor: visuals.StandardObjectProperties.labelColor,
                                labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
                                labelPrecision: visuals.StandardObjectProperties.labelPrecision
                            }
                        },
                        y1AxisReferenceLine: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Description"),
                            properties: {
                                show: visuals.StandardObjectProperties.show,
                                displayName: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_DisplayName"),
                                    description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_DisplayName_Description"),
                                    type: {
                                        text: !0
                                    }
                                },
                                value: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Value"),
                                    description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Value_Description"),
                                    type: {
                                        numeric: !0
                                    }
                                },
                                lineColor: visuals.StandardObjectProperties.lineColor,
                                transparency: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Transparency"),
                                    description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Transparency_Description"),
                                    type: {
                                        numeric: !0
                                    }
                                },
                                style: visuals.StandardObjectProperties.referenceLineStyle,
                                position: visuals.StandardObjectProperties.referenceLinePosition,
                                dataLabelShow: visuals.StandardObjectProperties.dataLabelShow,
                                dataLabelColor: visuals.StandardObjectProperties.dataLabelColor,
                                dataLabelDecimalPoints: visuals.StandardObjectProperties.dataLabelDecimalPoints,
                                dataLabelHorizontalPosition: visuals.StandardObjectProperties.dataLabelHorizontalPosition,
                                dataLabelVerticalPosition: visuals.StandardObjectProperties.dataLabelVerticalPosition,
                                dataLabelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits
                            }
                        },
                        referenceLine: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line"),
                            description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Description"),
                            properties: {
                                show: visuals.StandardObjectProperties.show,
                                displayName: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_DisplayName"),
                                    description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_DisplayName_Description"),
                                    type: {
                                        text: !0
                                    }
                                },
                                value: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Value"),
                                    description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Value_Description"),
                                    type: {
                                        numeric: !0
                                    }
                                },
                                lineColor: visuals.StandardObjectProperties.lineColor,
                                transparency: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Transparency"),
                                    description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Transparency_Description"),
                                    type: {
                                        numeric: !0
                                    }
                                },
                                style: visuals.StandardObjectProperties.referenceLineStyle,
                                position: visuals.StandardObjectProperties.referenceLinePosition,
                                dataLabelShow: visuals.StandardObjectProperties.dataLabelShow,
                                dataLabelColor: visuals.StandardObjectProperties.dataLabelColor,
                                dataLabelDecimalPoints: visuals.StandardObjectProperties.dataLabelDecimalPoints,
                                dataLabelHorizontalPosition: visuals.StandardObjectProperties.dataLabelHorizontalPosition,
                                dataLabelVerticalPosition: visuals.StandardObjectProperties.dataLabelVerticalPosition,
                                dataLabelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits
                            }
                        },
                        dataPoint: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                            description: powerbi.data.createDisplayNameGetter("Visual_DataPointDescription"),
                            properties: {
                                defaultColor: visuals.StandardObjectProperties.defaultColor,
                                showAllDataPoints: visuals.StandardObjectProperties.showAllDataPoints,
                                fill: visuals.StandardObjectProperties.fill,
                                fillRule: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Gradient"),
                                    type: {
                                        fillRule: {}
                                    },
                                    rule: {
                                        inputRole: "Gradient",
                                        output: {
                                            property: "fill",
                                            selector: [ "Category" ]
                                        }
                                    }
                                }
                            }
                        },
                        trend: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Trend_Line"),
                            properties: {
                                show: {
                                    type: {
                                        bool: !0
                                    }
                                },
                                displayName: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_DisplayName"),
                                    description: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_DisplayName_Description"),
                                    type: {
                                        text: !0
                                    }
                                },
                                lineColor: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Color"),
                                    description: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Color_Description"),
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                transparency: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Transparency"),
                                    description: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Transparency_Description"),
                                    type: {
                                        numeric: !0
                                    }
                                },
                                style: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Style"),
                                    description: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Style_Description"),
                                    type: {
                                        enumeration: visuals.lineStyle.type
                                    }
                                },
                                combineSeries: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Combine_Series"),
                                    description: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Combine_Series_Description"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                useHighlightValues: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_UseHighlightValues"),
                                    description: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_UseHighlightValues_Description"),
                                    type: {
                                        bool: !0
                                    }
                                }
                            }
                        },
                        labels: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                            description: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabelsDescription"),
                            properties: {
                                show: visuals.StandardObjectProperties.show,
                                showSeries: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                color: visuals.StandardObjectProperties.dataColor,
                                labelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits,
                                labelPrecision: $.extend({}, visuals.StandardObjectProperties.labelPrecision, {
                                    suppressFormatPainterCopy: !0
                                }),
                                showAll: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_LabelSeriesShowAll"),
                                    type: {
                                        bool: !0
                                    }
                                },
                                fontSize: visuals.StandardObjectProperties.fontSize
                            }
                        },
                        plotArea: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Plot"),
                            properties: {
                                transparency: visuals.StandardObjectProperties.transparency,
                                image: visuals.StandardObjectProperties.image
                            }
                        }
                    },
                    dataViewMappings: [ {
                        conditions: [ {
                            Category: {
                                max: 1
                            },
                            Series: {
                                max: 0
                            },
                            Gradient: {
                                max: 0
                            }
                        }, {
                            Category: {
                                max: 1
                            },
                            Series: {
                                min: 1,
                                max: 1
                            },
                            Y: {
                                max: 1
                            },
                            Gradient: {
                                max: 0
                            }
                        }, {
                            Category: {
                                max: 1
                            },
                            Series: {
                                max: 0
                            },
                            Y: {
                                min: 0,
                                max: 1
                            },
                            Gradient: {
                                max: 1
                            }
                        } ],
                        categorical: {
                            categories: {
                                "for": {
                                    "in": "Category"
                                },
                                dataReductionAlgorithm: {
                                    window: {
                                        count: 100
                                    }
                                }
                            },
                            values: {
                                group: {
                                    by: "Series",
                                    select: [ {
                                        "for": {
                                            "in": "Y"
                                        }
                                    }, {
                                        bind: {
                                            to: "Gradient"
                                        }
                                    } ],
                                    dataReductionAlgorithm: {
                                        top: {
                                            count: 60
                                        }
                                    }
                                }
                            },
                            rowCount: {
                                preferred: {
                                    min: 2
                                },
                                supported: {
                                    min: 0
                                }
                            }
                        }
                    }, {
                        conditions: [ {
                            Category: {
                                max: 1
                            },
                            Series: {
                                max: 0
                            },
                            Gradient: {
                                max: 0
                            }
                        }, {
                            Category: {
                                max: 1
                            },
                            Series: {
                                min: 1,
                                max: 1
                            },
                            Y: {
                                max: 1
                            },
                            Gradient: {
                                max: 0
                            }
                        }, {
                            Category: {
                                max: 1
                            },
                            Series: {
                                max: 0
                            },
                            Y: {
                                min: 0,
                                max: 1
                            },
                            Gradient: {
                                max: 1
                            }
                        } ],
                        requiredProperties: [ {
                            objectName: "trend",
                            propertyName: "show"
                        } ],
                        usage: {
                            regression: {
                                combineSeries: {
                                    objectName: "trend",
                                    propertyName: "combineSeries"
                                }
                            }
                        },
                        categorical: {
                            categories: {
                                "for": {
                                    "in": "regression.X"
                                }
                            },
                            values: {
                                group: {
                                    by: "regression.Series",
                                    select: [ {
                                        "for": {
                                            "in": "regression.Y"
                                        }
                                    } ]
                                }
                            }
                        }
                    } ],
                    supportsHighlight: !0,
                    sorting: {
                        "default": {}
                    },
                    drilldown: {
                        roles: [ "Category" ]
                    }
                };
            }
            visuals.getColumnChartCapabilities = getColumnChartCapabilities, visuals.columnChartProps = {
                dataPoint: {
                    defaultColor: {
                        objectName: "dataPoint",
                        propertyName: "defaultColor"
                    },
                    fill: {
                        objectName: "dataPoint",
                        propertyName: "fill"
                    },
                    showAllDataPoints: {
                        objectName: "dataPoint",
                        propertyName: "showAllDataPoints"
                    }
                },
                general: {
                    formatString: {
                        objectName: "general",
                        propertyName: "formatString"
                    }
                },
                categoryAxis: {
                    axisType: {
                        objectName: "categoryAxis",
                        propertyName: "axisType"
                    }
                },
                legend: {
                    labelColor: {
                        objectName: "legend",
                        propertyName: "labelColor"
                    }
                },
                plotArea: {
                    image: {
                        objectName: "plotArea",
                        propertyName: "image"
                    },
                    transparency: {
                        objectName: "plotArea",
                        propertyName: "transparency"
                    }
                }
            };
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            visuals.comboChartCapabilities = {
                dataRoles: [ {
                    name: "Category",
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter("Role_ComboChart_Category"),
                    description: powerbi.data.createDisplayNameGetter("Role_ComboChart_CategoryDescription"),
                    cartesianKind: 0
                }, {
                    name: "Series",
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter("Role_ComboChart_Series")
                }, {
                    name: "Y",
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter("Role_ComboChart_Y"),
                    description: powerbi.data.createDisplayNameGetter("Role_ComboChart_YDescription"),
                    requiredTypes: [ {
                        numeric: !0
                    }, {
                        integer: !0
                    } ],
                    cartesianKind: 1
                }, {
                    name: "Y2",
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter("Role_ComboChart_Y2"),
                    description: powerbi.data.createDisplayNameGetter("Role_ComboChart_Y2Description"),
                    requiredTypes: [ {
                        numeric: !0
                    }, {
                        integer: !0
                    } ],
                    cartesianKind: 1
                } ],
                objects: {
                    general: {
                        properties: {
                            formatString: visuals.StandardObjectProperties.formatString,
                            visualType1: {
                                type: {
                                    text: !0
                                }
                            },
                            visualType2: {
                                type: {
                                    text: !0
                                }
                            }
                        }
                    },
                    legend: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                        description: powerbi.data.createDisplayNameGetter("Visual_LegendDescription"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            position: visuals.StandardObjectProperties.legendPosition,
                            showTitle: visuals.StandardObjectProperties.showLegendTitle,
                            titleText: $.extend({}, visuals.StandardObjectProperties.legendTitle, {
                                suppressFormatPainterCopy: !0
                            }),
                            labelColor: visuals.StandardObjectProperties.labelColor,
                            fontSize: visuals.StandardObjectProperties.fontSize
                        }
                    },
                    categoryAxis: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_XAxis"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            axisScale: visuals.StandardObjectProperties.axisScale,
                            start: visuals.StandardObjectProperties.axisStart,
                            end: visuals.StandardObjectProperties.axisEnd,
                            axisType: visuals.StandardObjectProperties.axisType,
                            showAxisTitle: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Axis_XTitleDescription"),
                                type: {
                                    bool: !0
                                }
                            },
                            axisStyle: visuals.StandardObjectProperties.axisStyle,
                            labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
                            labelPrecision: visuals.StandardObjectProperties.labelPrecision
                        }
                    },
                    valueAxis: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            axisLabel: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis_ColumnTitle"),
                                type: {
                                    none: !0
                                }
                            },
                            position: visuals.StandardObjectProperties.yAxisPosition,
                            axisScale: visuals.StandardObjectProperties.axisScale,
                            start: visuals.StandardObjectProperties.axisStart,
                            end: visuals.StandardObjectProperties.axisEnd,
                            showAxisTitle: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Axis_YTitleDescription"),
                                type: {
                                    bool: !0
                                }
                            },
                            axisStyle: visuals.StandardObjectProperties.axisStyle,
                            labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
                            labelPrecision: visuals.StandardObjectProperties.labelPrecision,
                            secShow: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis_ShowSecondary"),
                                type: {
                                    bool: !0
                                }
                            },
                            secAxisLabel: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis_LineTitle"),
                                type: {
                                    none: !0
                                }
                            },
                            secPosition: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis_Position"),
                                type: {
                                    enumeration: visuals.yAxisPosition.type
                                }
                            },
                            secAxisScale: visuals.StandardObjectProperties.axisScale,
                            secStart: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Start"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Axis_StartDescription"),
                                type: {
                                    numeric: !0
                                }
                            },
                            secEnd: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_End"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Axis_EndDescription"),
                                type: {
                                    numeric: !0
                                }
                            },
                            secShowAxisTitle: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Axis_YTitleDescription"),
                                type: {
                                    bool: !0
                                }
                            },
                            secAxisStyle: visuals.StandardObjectProperties.axisStyle,
                            secLabelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
                            secLabelPrecision: visuals.StandardObjectProperties.labelPrecision
                        }
                    },
                    dataPoint: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                        description: powerbi.data.createDisplayNameGetter("Visual_DataPointDescription"),
                        properties: {
                            defaultColor: $.extend({}, visuals.StandardObjectProperties.defaultColor, {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_DefaultColumnColor")
                            }),
                            showAllDataPoints: visuals.StandardObjectProperties.showAllDataPoints,
                            fill: visuals.StandardObjectProperties.fill,
                            fillRule: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Gradient"),
                                type: {
                                    fillRule: {}
                                },
                                rule: {
                                    inputRole: "Gradient",
                                    output: {
                                        property: "fill",
                                        selector: [ "Category" ]
                                    }
                                }
                            }
                        }
                    },
                    labels: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                        description: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabelsDescription"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            color: visuals.StandardObjectProperties.dataColor,
                            labelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits,
                            labelPrecision: $.extend({}, visuals.StandardObjectProperties.labelPrecision, {
                                suppressFormatPainterCopy: !0
                            }),
                            fontSize: visuals.StandardObjectProperties.fontSize,
                            labelDensity: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_LabelDensity"),
                                type: {
                                    formatting: {
                                        labelDensity: !0
                                    }
                                }
                            }
                        }
                    },
                    plotArea: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Plot"),
                        properties: {
                            transparency: visuals.StandardObjectProperties.transparency,
                            image: visuals.StandardObjectProperties.image
                        }
                    },
                    trend: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Trend_Line"),
                        properties: {
                            show: {
                                type: {
                                    bool: !0
                                }
                            },
                            displayName: {
                                type: {
                                    text: !0
                                }
                            },
                            lineColor: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Color"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Color_Description"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            },
                            transparency: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Transparency"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Transparency_Description"),
                                type: {
                                    numeric: !0
                                }
                            },
                            style: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Style"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Style_Description"),
                                type: {
                                    enumeration: visuals.lineStyle.type
                                }
                            },
                            combineSeries: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Combine_Series"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Combine_Series_Description"),
                                type: {
                                    bool: !0
                                }
                            },
                            useHighlightValues: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_UseHighlightValues"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_UseHighlightValues_Description"),
                                type: {
                                    bool: !0
                                }
                            }
                        }
                    }
                },
                dataViewMappings: [ {
                    conditions: [ {
                        Category: {
                            max: 1
                        },
                        Series: {
                            max: 0
                        }
                    }, {
                        Category: {
                            max: 1
                        },
                        Series: {
                            min: 1,
                            max: 1
                        },
                        Y: {
                            max: 1
                        }
                    } ],
                    categorical: {
                        categories: {
                            "for": {
                                "in": "Category"
                            },
                            dataReductionAlgorithm: {
                                window: {
                                    count: 100
                                }
                            }
                        },
                        values: {
                            group: {
                                by: "Series",
                                select: [ {
                                    "for": {
                                        "in": "Y"
                                    }
                                } ],
                                dataReductionAlgorithm: {
                                    top: {
                                        count: 60
                                    }
                                }
                            }
                        },
                        rowCount: {
                            preferred: {
                                min: 2
                            },
                            supported: {
                                min: 0
                            }
                        }
                    }
                }, {
                    conditions: [ {
                        Category: {
                            max: 1
                        },
                        Series: {
                            max: 0
                        },
                        Y2: {
                            min: 1
                        }
                    }, {
                        Category: {
                            max: 1
                        },
                        Series: {
                            min: 1,
                            max: 1
                        },
                        Y: {
                            max: 1
                        },
                        Y2: {
                            min: 1
                        }
                    } ],
                    categorical: {
                        categories: {
                            "for": {
                                "in": "Category"
                            },
                            dataReductionAlgorithm: {
                                window: {
                                    count: 100
                                }
                            }
                        },
                        values: {
                            select: [ {
                                "for": {
                                    "in": "Y2"
                                }
                            } ]
                        },
                        rowCount: {
                            preferred: {
                                min: 2
                            },
                            supported: {
                                min: 0
                            }
                        }
                    }
                }, {
                    conditions: [ {
                        Category: {
                            max: 1
                        },
                        Series: {
                            max: 0
                        }
                    }, {
                        Category: {
                            max: 1
                        },
                        Series: {
                            min: 1,
                            max: 1
                        },
                        Y: {
                            max: 1
                        }
                    } ],
                    requiredProperties: [ {
                        objectName: "trend",
                        propertyName: "show"
                    } ],
                    usage: {
                        regression: {
                            combineSeries: {
                                objectName: "trend",
                                propertyName: "combineSeries"
                            }
                        }
                    },
                    categorical: {
                        categories: {
                            "for": {
                                "in": "regression.X"
                            }
                        },
                        values: {
                            group: {
                                by: "regression.Series",
                                select: [ {
                                    "for": {
                                        "in": "regression.Y"
                                    }
                                } ]
                            }
                        }
                    }
                } ],
                supportsHighlight: !0,
                sorting: {
                    "default": {}
                },
                drilldown: {
                    roles: [ "Category" ]
                }
            }, visuals.comboChartProps = {
                general: {
                    formatString: {
                        objectName: "general",
                        propertyName: "formatString"
                    }
                },
                valueAxis: {
                    secShow: {
                        objectName: "valueAxis",
                        propertyName: "secShow"
                    }
                },
                legend: {
                    labelColor: {
                        objectName: "legend",
                        propertyName: "labelColor"
                    }
                },
                dataPoint: {
                    showAllDataPoints: {
                        objectName: "dataPoint",
                        propertyName: "showAllDataPoints"
                    }
                }
            };
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            visuals.donutChartCapabilities = {
                dataRoles: [ {
                    name: "Category",
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Legend"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_LegendDescription")
                }, {
                    name: "Series",
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Details"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_DetailsDonutChartDescription")
                }, {
                    name: "Y",
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_ValuesDescription"),
                    requiredTypes: [ {
                        numeric: !0
                    }, {
                        integer: !0
                    } ]
                } ],
                objects: {
                    general: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                        properties: {
                            formatString: visuals.StandardObjectProperties.formatString
                        }
                    },
                    legend: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                        description: powerbi.data.createDisplayNameGetter("Visual_LegendDescription"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            position: visuals.StandardObjectProperties.legendPosition,
                            showTitle: visuals.StandardObjectProperties.showLegendTitle,
                            titleText: $.extend({}, visuals.StandardObjectProperties.legendTitle, {
                                suppressFormatPainterCopy: !0
                            }),
                            labelColor: visuals.StandardObjectProperties.labelColor,
                            fontSize: visuals.StandardObjectProperties.fontSize
                        }
                    },
                    dataPoint: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                        description: powerbi.data.createDisplayNameGetter("Visual_DataPointDescription"),
                        properties: {
                            defaultColor: visuals.StandardObjectProperties.defaultColor,
                            fill: visuals.StandardObjectProperties.fill
                        }
                    },
                    labels: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_DetailLabels"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            color: visuals.StandardObjectProperties.dataColor,
                            labelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits,
                            labelPrecision: $.extend({}, visuals.StandardObjectProperties.labelPrecision, {
                                suppressFormatPainterCopy: !0
                            }),
                            fontSize: $.extend({}, visuals.StandardObjectProperties.fontSize, {
                                suppressFormatPainterCopy: !0
                            }),
                            labelStyle: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_LabelStyle"),
                                type: {
                                    enumeration: visuals.labelStyle.type
                                }
                            }
                        }
                    }
                },
                dataViewMappings: [ {
                    conditions: [ {
                        Category: {
                            max: 1
                        },
                        Series: {
                            max: 0
                        }
                    }, {
                        Category: {
                            max: 1
                        },
                        Series: {
                            min: 1,
                            max: 1
                        },
                        Y: {
                            max: 1
                        }
                    } ],
                    categorical: {
                        categories: {
                            "for": {
                                "in": "Category"
                            },
                            dataReductionAlgorithm: {
                                top: {}
                            }
                        },
                        values: {
                            group: {
                                by: "Series",
                                select: [ {
                                    bind: {
                                        to: "Y"
                                    }
                                } ],
                                dataReductionAlgorithm: {
                                    top: {}
                                }
                            }
                        },
                        rowCount: {
                            preferred: {
                                min: 2
                            },
                            supported: {
                                min: 1
                            }
                        }
                    }
                } ],
                sorting: {
                    "default": {}
                },
                supportsHighlight: !0,
                drilldown: {
                    roles: [ "Category" ]
                }
            }, visuals.donutChartProps = {
                general: {
                    formatString: {
                        objectName: "general",
                        propertyName: "formatString"
                    }
                },
                dataPoint: {
                    defaultColor: {
                        objectName: "dataPoint",
                        propertyName: "defaultColor"
                    },
                    fill: {
                        objectName: "dataPoint",
                        propertyName: "fill"
                    }
                },
                legend: {
                    show: {
                        objectName: "legend",
                        propertyName: "show"
                    },
                    position: {
                        objectName: "legend",
                        propertyName: "position"
                    },
                    showTitle: {
                        objectName: "legend",
                        propertyName: "showTitle"
                    },
                    titleText: {
                        objectName: "legend",
                        propertyName: "titleText"
                    },
                    labelColor: {
                        objectName: "legend",
                        propertyName: "labelColor"
                    }
                }
            };
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            visuals.dataDotChartCapabilities = {
                dataRoles: [ {
                    name: "Category",
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Axis"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_AxisDescription")
                }, {
                    name: "Y",
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Value"),
                    requiredTypes: [ {
                        numeric: !0
                    }, {
                        integer: !0
                    } ]
                } ],
                objects: {
                    general: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                        properties: {
                            formatString: visuals.StandardObjectProperties.formatString
                        }
                    }
                },
                dataViewMappings: [ {
                    conditions: [ {
                        Category: {
                            max: 1
                        },
                        Y: {
                            max: 1
                        }
                    } ],
                    categorical: {
                        categories: {
                            "for": {
                                "in": "Category"
                            },
                            dataReductionAlgorithm: {
                                top: {}
                            }
                        },
                        values: {
                            select: [ {
                                "for": {
                                    "in": "Y"
                                }
                            } ]
                        }
                    }
                } ]
            };
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            visuals.filledMapCapabilities = {
                dataRoles: [ {
                    name: "Category",
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Location"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_LocationFilledMapDescription"),
                    preferredTypes: [ {
                        geography: {
                            address: !0
                        }
                    }, {
                        geography: {
                            city: !0
                        }
                    }, {
                        geography: {
                            continent: !0
                        }
                    }, {
                        geography: {
                            country: !0
                        }
                    }, {
                        geography: {
                            county: !0
                        }
                    }, {
                        geography: {
                            place: !0
                        }
                    }, {
                        geography: {
                            postalCode: !0
                        }
                    }, {
                        geography: {
                            region: !0
                        }
                    }, {
                        geography: {
                            stateOrProvince: !0
                        }
                    } ]
                }, {
                    name: "Series",
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Legend"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_LegendDescription")
                }, {
                    name: "Y",
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Latitude"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_LatitudeFilledMapDescription"),
                    preferredTypes: [ {
                        geography: {
                            latitude: !0
                        }
                    } ]
                }, {
                    name: "X",
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Longitude"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_LongitudeFilledMapDescription"),
                    preferredTypes: [ {
                        geography: {
                            longitude: !0
                        }
                    } ]
                }, {
                    name: "Size",
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Gradient"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_GradientDescription"),
                    requiredTypes: [ {
                        numeric: !0
                    }, {
                        integer: !0
                    } ]
                } ],
                objects: {
                    general: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                        properties: {
                            formatString: visuals.StandardObjectProperties.formatString
                        }
                    },
                    legend: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                        description: powerbi.data.createDisplayNameGetter("Visual_LegendDescription"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            position: visuals.StandardObjectProperties.legendPosition,
                            showTitle: visuals.StandardObjectProperties.showLegendTitle,
                            titleText: visuals.StandardObjectProperties.legendTitle,
                            fontSize: visuals.StandardObjectProperties.fontSize
                        }
                    },
                    dataPoint: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                        description: powerbi.data.createDisplayNameGetter("Visual_DataPointDescription"),
                        properties: {
                            defaultColor: visuals.StandardObjectProperties.defaultColor,
                            showAllDataPoints: visuals.StandardObjectProperties.showAllDataPoints,
                            fill: visuals.StandardObjectProperties.fill,
                            fillRule: {
                                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values"),
                                description: powerbi.data.createDisplayNameGetter("Role_DisplayName_ValuesDescription"),
                                type: {
                                    fillRule: {}
                                },
                                rule: {
                                    inputRole: "Size",
                                    output: {
                                        property: "fill",
                                        selector: [ "Category" ]
                                    }
                                }
                            }
                        }
                    },
                    labels: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            color: visuals.StandardObjectProperties.dataColor,
                            labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
                            labelPrecision: visuals.StandardObjectProperties.labelPrecision
                        }
                    },
                    categoryLabels: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_CategoryLabels"),
                        properties: {
                            show: visuals.StandardObjectProperties.show
                        }
                    }
                },
                dataViewMappings: [ {
                    conditions: [ {
                        Category: {
                            max: 1
                        },
                        Series: {
                            max: 1
                        },
                        X: {
                            max: 1
                        },
                        Y: {
                            max: 1
                        },
                        Size: {
                            max: 1
                        }
                    }, {
                        Category: {
                            max: 1
                        },
                        Series: {
                            max: 0
                        },
                        X: {
                            max: 1
                        },
                        Y: {
                            max: 1
                        },
                        Size: {
                            max: 1
                        }
                    } ],
                    categorical: {
                        categories: {
                            "for": {
                                "in": "Category"
                            },
                            dataReductionAlgorithm: {
                                top: {}
                            }
                        },
                        values: {
                            group: {
                                by: "Series",
                                select: [ {
                                    bind: {
                                        to: "X"
                                    }
                                }, {
                                    bind: {
                                        to: "Y"
                                    }
                                }, {
                                    bind: {
                                        to: "Size"
                                    }
                                } ],
                                dataReductionAlgorithm: {
                                    top: {}
                                }
                            }
                        },
                        rowCount: {
                            preferred: {
                                min: 2
                            }
                        },
                        dataVolume: 4
                    }
                } ],
                sorting: {
                    custom: {},
                    implicit: {
                        clauses: [ {
                            role: "Size",
                            direction: 2
                        } ]
                    }
                },
                drilldown: {
                    roles: [ "Category" ]
                }
            }, visuals.filledMapProps = {
                general: {
                    formatString: {
                        objectName: "general",
                        propertyName: "formatString"
                    }
                },
                dataPoint: {
                    defaultColor: {
                        objectName: "dataPoint",
                        propertyName: "defaultColor"
                    },
                    fill: {
                        objectName: "dataPoint",
                        propertyName: "fill"
                    },
                    showAllDataPoints: {
                        objectName: "dataPoint",
                        propertyName: "showAllDataPoints"
                    }
                },
                legend: {
                    show: {
                        objectName: "legend",
                        propertyName: "show"
                    },
                    position: {
                        objectName: "legend",
                        propertyName: "position"
                    },
                    showTitle: {
                        objectName: "legend",
                        propertyName: "showTitle"
                    },
                    titleText: {
                        objectName: "legend",
                        propertyName: "titleText"
                    }
                },
                labels: {
                    show: {
                        objectName: "labels",
                        propertyName: "show"
                    },
                    color: {
                        objectName: "labels",
                        propertyName: "color"
                    },
                    labelDisplayUnits: {
                        objectName: "labels",
                        propertyName: "labelDisplayUnits"
                    },
                    labelPrecision: {
                        objectName: "labels",
                        propertyName: "labelPrecision"
                    }
                },
                categoryLabels: {
                    show: {
                        objectName: "categoryLabels",
                        propertyName: "show"
                    }
                }
            };
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            visuals.funnelChartCapabilities = {
                dataRoles: [ {
                    name: "Category",
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Group"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_GroupFunnelDescription")
                }, {
                    name: "Y",
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_ValuesDescription"),
                    requiredTypes: [ {
                        numeric: !0
                    }, {
                        integer: !0
                    } ]
                }, {
                    name: "Gradient",
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Gradient"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_GradientDescription"),
                    requiredTypes: [ {
                        numeric: !0
                    }, {
                        integer: !0
                    } ],
                    joinPredicate: 0
                } ],
                dataViewMappings: [ {
                    conditions: [ {
                        Category: {
                            max: 0
                        },
                        Gradient: {
                            max: 0
                        }
                    }, {
                        Category: {
                            max: 1
                        },
                        Y: {
                            max: 1
                        },
                        Gradient: {
                            max: 1
                        }
                    } ],
                    categorical: {
                        categories: {
                            "for": {
                                "in": "Category"
                            },
                            dataReductionAlgorithm: {
                                top: {}
                            }
                        },
                        values: {
                            select: [ {
                                "for": {
                                    "in": "Y"
                                }
                            }, {
                                bind: {
                                    to: "Gradient"
                                }
                            } ]
                        },
                        rowCount: {
                            preferred: {
                                min: 1
                            }
                        }
                    }
                } ],
                objects: {
                    general: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                        properties: {
                            formatString: visuals.StandardObjectProperties.formatString
                        }
                    },
                    dataPoint: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                        description: powerbi.data.createDisplayNameGetter("Visual_DataPointDescription"),
                        properties: {
                            defaultColor: visuals.StandardObjectProperties.defaultColor,
                            fill: visuals.StandardObjectProperties.fill,
                            fillRule: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Gradient"),
                                type: {
                                    fillRule: {}
                                },
                                rule: {
                                    inputRole: "Gradient",
                                    output: {
                                        property: "fill",
                                        selector: [ "Category" ]
                                    }
                                }
                            }
                        }
                    },
                    labels: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                        description: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabelsDescription"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            color: visuals.StandardObjectProperties.dataColor,
                            labelPosition: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Position"),
                                type: {
                                    enumeration: visuals.labelPosition.type
                                },
                                suppressFormatPainterCopy: !0
                            },
                            labelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits,
                            labelPrecision: $.extend({}, visuals.StandardObjectProperties.labelPrecision, {
                                suppressFormatPainterCopy: !0
                            }),
                            fontSize: visuals.StandardObjectProperties.fontSize
                        }
                    },
                    percentBarLabel: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_PercentBarLabel"),
                        description: powerbi.data.createDisplayNameGetter("Visual_PercentBarLabelDescription"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            color: visuals.StandardObjectProperties.dataColor,
                            fontSize: visuals.StandardObjectProperties.fontSize
                        }
                    }
                },
                supportsHighlight: !0,
                sorting: {
                    "default": {}
                },
                drilldown: {
                    roles: [ "Category" ]
                }
            }, visuals.funnelChartProps = {
                general: {
                    formatString: {
                        objectName: "general",
                        propertyName: "formatString"
                    }
                },
                dataPoint: {
                    defaultColor: {
                        objectName: "dataPoint",
                        propertyName: "defaultColor"
                    },
                    fill: {
                        objectName: "dataPoint",
                        propertyName: "fill"
                    }
                }
            };
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            visuals.gaugeRoleNames = {
                y: "Y",
                minValue: "MinValue",
                maxValue: "MaxValue",
                targetValue: "TargetValue"
            }, visuals.gaugeCapabilities = {
                dataRoles: [ {
                    name: visuals.gaugeRoleNames.y,
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Value"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_ValueDescription"),
                    requiredTypes: [ {
                        numeric: !0
                    }, {
                        integer: !0
                    } ]
                }, {
                    name: visuals.gaugeRoleNames.minValue,
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_MinValue"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_MinValueDescription"),
                    requiredTypes: [ {
                        numeric: !0
                    }, {
                        integer: !0
                    } ]
                }, {
                    name: visuals.gaugeRoleNames.maxValue,
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_MaxValue"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_MaxValueDescription"),
                    requiredTypes: [ {
                        numeric: !0
                    }, {
                        integer: !0
                    } ]
                }, {
                    name: visuals.gaugeRoleNames.targetValue,
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_TargetValue"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_TargetValueDescription"),
                    requiredTypes: [ {
                        numeric: !0
                    }, {
                        integer: !0
                    } ]
                } ],
                objects: {
                    general: {
                        properties: {
                            formatString: visuals.StandardObjectProperties.formatString
                        }
                    },
                    axis: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Gauge_Axis"),
                        properties: {
                            min: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Gauge_Axis_Min"),
                                type: {
                                    numeric: !0
                                }
                            },
                            max: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Gauge_Axis_Max"),
                                type: {
                                    numeric: !0
                                }
                            },
                            target: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Gauge_Axis_Target"),
                                type: {
                                    numeric: !0
                                }
                            }
                        }
                    },
                    labels: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            color: visuals.StandardObjectProperties.dataColor,
                            labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
                            labelPrecision: visuals.StandardObjectProperties.labelPrecision,
                            fontSize: visuals.StandardObjectProperties.fontSize
                        }
                    },
                    calloutValue: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Gauge_CalloutValue"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            color: visuals.StandardObjectProperties.dataColor,
                            labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
                            labelPrecision: visuals.StandardObjectProperties.labelPrecision
                        }
                    },
                    dataPoint: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                        properties: {
                            fill: visuals.StandardObjectProperties.fill,
                            target: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Gauge_Axis_Target"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            }
                        }
                    }
                },
                dataViewMappings: [ {
                    conditions: [ {
                        Y: {
                            max: 1
                        },
                        MinValue: {
                            max: 1
                        },
                        MaxValue: {
                            max: 1
                        },
                        TargetValue: {
                            max: 1
                        }
                    } ],
                    categorical: {
                        values: {
                            select: [ {
                                bind: {
                                    to: "Y"
                                }
                            }, {
                                bind: {
                                    to: "MinValue"
                                }
                            }, {
                                bind: {
                                    to: "MaxValue"
                                }
                            }, {
                                bind: {
                                    to: "TargetValue"
                                }
                            } ]
                        }
                    }
                } ],
                supportsSelection: !1
            }, visuals.gaugeProps = {
                dataPoint: {
                    fill: {
                        objectName: "dataPoint",
                        propertyName: "fill"
                    },
                    target: {
                        objectName: "dataPoint",
                        propertyName: "target"
                    }
                }
            };
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            visuals.imageVisualCapabilities = {
                objects: {
                    general: {
                        properties: {
                            imageUrl: {
                                type: {
                                    misc: {
                                        imageUrl: !0
                                    }
                                },
                                suppressFormatPainterCopy: !0
                            }
                        }
                    },
                    imageScaling: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Image_Scaling_Type"),
                        properties: {
                            imageScalingType: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Image_Scaling_Type"),
                                type: {
                                    enumeration: visuals.imageScalingType.type
                                }
                            }
                        }
                    }
                },
                suppressDefaultTitle: !0,
                supportsSelection: !1
            };
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            visuals.scriptVisualCapabilities = {
                dataRoles: [ {
                    name: "Values",
                    kind: powerbi.VisualDataRoleKind.GroupingOrMeasure,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values")
                } ],
                dataViewMappings: [ {
                    scriptResult: {
                        dataInput: {
                            table: {
                                rows: {
                                    "for": {
                                        "in": "Values"
                                    },
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                }
                            }
                        },
                        script: {
                            source: {
                                objectName: "script",
                                propertyName: "source"
                            },
                            provider: {
                                objectName: "script",
                                propertyName: "provider"
                            }
                        }
                    }
                } ],
                objects: {
                    script: {
                        properties: {
                            provider: {
                                type: {
                                    text: !0
                                }
                            },
                            source: {
                                type: {
                                    scripting: {
                                        source: !0
                                    }
                                }
                            }
                        }
                    }
                }
            };
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                samples.consoleWriterCapabilities = {
                    dataRoles: [ {
                        name: "Category",
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Axis"),
                        description: powerbi.data.createDisplayNameGetter("Role_DisplayName_AxisDescription")
                    }, {
                        name: "Y",
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Y"),
                        description: powerbi.data.createDisplayNameGetter("Role_DisplayName_YDescription")
                    } ],
                    dataViewMappings: [ {
                        categorical: {
                            categories: {
                                "for": {
                                    "in": "Category"
                                }
                            }
                        }
                    } ]
                };
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var ConsoleWriter = function() {
                    function ConsoleWriter() {}
                    return ConsoleWriter.converter = function(dataView) {
                        return window.console.log("converter"), window.console.log(dataView), {};
                    }, ConsoleWriter.prototype.init = function(options) {
                        var div = d3.select(options.element.get(0)).append("div");
                        div.append("h1").text("ConsoleWriter"), div.append("p").text("This IVisual writes messages passed to it to the javscript console output. Check your console for the actual messages passed. For more information, click below");
                        var anchor = div.append("a");
                        anchor.attr("href", "http://microsoft.github.io/PowerBI-visuals/modules/powerbi.html").text("Online help"), 
                        window.console.log("init"), window.console.log(options);
                    }, ConsoleWriter.prototype.onResizing = function(viewport) {}, ConsoleWriter.prototype.update = function(options) {
                        window.console.log("update"), window.console.log(options);
                    }, ConsoleWriter;
                }();
                samples.ConsoleWriter = ConsoleWriter;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            visuals.lineChartCapabilities = {
                dataRoles: [ {
                    name: "Category",
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Axis"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_AxisDescription"),
                    cartesianKind: 0
                }, {
                    name: "Series",
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Legend"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_LegendDescription")
                }, {
                    name: "Y",
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_ValuesDescription"),
                    requiredTypes: [ {
                        numeric: !0
                    }, {
                        integer: !0
                    } ],
                    cartesianKind: 1
                } ],
                objects: {
                    general: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                        properties: {
                            formatString: visuals.StandardObjectProperties.formatString
                        }
                    },
                    legend: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                        description: powerbi.data.createDisplayNameGetter("Visual_LegendDescription"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            position: visuals.StandardObjectProperties.legendPosition,
                            showTitle: visuals.StandardObjectProperties.showLegendTitle,
                            titleText: $.extend({}, visuals.StandardObjectProperties.legendTitle, {
                                suppressFormatPainterCopy: !0
                            }),
                            labelColor: visuals.StandardObjectProperties.labelColor,
                            fontSize: visuals.StandardObjectProperties.fontSize
                        }
                    },
                    dataPoint: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                        description: powerbi.data.createDisplayNameGetter("Visual_DataPointDescription"),
                        properties: {
                            defaultColor: visuals.StandardObjectProperties.defaultColor,
                            fill: visuals.StandardObjectProperties.fill
                        }
                    },
                    trend: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Trend_Line"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            displayName: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_DisplayName"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_DisplayName_Description"),
                                type: {
                                    text: !0
                                }
                            },
                            lineColor: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Color"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Color_Description"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            },
                            transparency: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Transparency"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Transparency_Description"),
                                type: {
                                    numeric: !0
                                }
                            },
                            style: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Style"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Style_Description"),
                                type: {
                                    enumeration: visuals.lineStyle.type
                                }
                            },
                            combineSeries: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Combine_Series"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Combine_Series_Description"),
                                type: {
                                    bool: !0
                                }
                            },
                            useHighlightValues: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_UseHighlightValues"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_UseHighlightValues_Description"),
                                type: {
                                    bool: !0
                                }
                            }
                        }
                    },
                    scalarKey: {
                        properties: {
                            min: {
                                type: {
                                    dateTime: !0
                                }
                            }
                        }
                    },
                    forecast: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Forecast"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            confidenceBandStyle: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Forecast_Confidence_Band_Style"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Forecast_Confidence_Band_Style_Description"),
                                type: {
                                    enumeration: visuals.confidenceBandStyle.type
                                }
                            },
                            lineColor: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Forecast_Line_Color"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Forecast_Line_Color_Description"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            },
                            transparency: visuals.StandardObjectProperties.transparency,
                            style: visuals.StandardObjectProperties.referenceLineStyle
                        }
                    },
                    categoryAxis: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_XAxis"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            axisScale: visuals.StandardObjectProperties.axisScale,
                            start: visuals.StandardObjectProperties.axisStart,
                            end: visuals.StandardObjectProperties.axisEnd,
                            axisType: visuals.StandardObjectProperties.axisType,
                            showAxisTitle: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Axis_XTitleDescription"),
                                type: {
                                    bool: !0
                                }
                            },
                            axisStyle: visuals.StandardObjectProperties.axisStyle,
                            labelColor: visuals.StandardObjectProperties.labelColor,
                            labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
                            labelPrecision: visuals.StandardObjectProperties.labelPrecision
                        }
                    },
                    valueAxis: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            position: visuals.StandardObjectProperties.yAxisPosition,
                            axisScale: visuals.StandardObjectProperties.axisScale,
                            start: visuals.StandardObjectProperties.axisStart,
                            end: visuals.StandardObjectProperties.axisEnd,
                            showAxisTitle: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Axis_YTitleDescription"),
                                type: {
                                    bool: !0
                                }
                            },
                            axisStyle: visuals.StandardObjectProperties.axisStyle,
                            labelColor: visuals.StandardObjectProperties.labelColor,
                            labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
                            labelPrecision: visuals.StandardObjectProperties.labelPrecision
                        }
                    },
                    y1AxisReferenceLine: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line"),
                        description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Description"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            displayName: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_DisplayName"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_DisplayName_Description"),
                                type: {
                                    text: !0
                                }
                            },
                            value: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Value"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Value_Description"),
                                type: {
                                    numeric: !0
                                }
                            },
                            lineColor: visuals.StandardObjectProperties.lineColor,
                            transparency: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Transparency"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Transparency_Description"),
                                type: {
                                    numeric: !0
                                }
                            },
                            style: visuals.StandardObjectProperties.referenceLineStyle,
                            position: visuals.StandardObjectProperties.referenceLinePosition,
                            dataLabelShow: visuals.StandardObjectProperties.dataLabelShow,
                            dataLabelColor: visuals.StandardObjectProperties.dataLabelColor,
                            dataLabelDecimalPoints: visuals.StandardObjectProperties.dataLabelDecimalPoints,
                            dataLabelHorizontalPosition: visuals.StandardObjectProperties.dataLabelHorizontalPosition,
                            dataLabelVerticalPosition: visuals.StandardObjectProperties.dataLabelVerticalPosition,
                            dataLabelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits
                        }
                    },
                    referenceLine: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line"),
                        description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Description"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            displayName: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_DisplayName"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_DisplayName_Description"),
                                type: {
                                    text: !0
                                }
                            },
                            value: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Value"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Value_Description"),
                                type: {
                                    numeric: !0
                                }
                            },
                            lineColor: visuals.StandardObjectProperties.lineColor,
                            transparency: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Transparency"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Transparency_Description"),
                                type: {
                                    numeric: !0
                                }
                            },
                            style: visuals.StandardObjectProperties.referenceLineStyle,
                            position: visuals.StandardObjectProperties.referenceLinePosition,
                            dataLabelShow: visuals.StandardObjectProperties.dataLabelShow,
                            dataLabelColor: visuals.StandardObjectProperties.dataLabelColor,
                            dataLabelDecimalPoints: visuals.StandardObjectProperties.dataLabelDecimalPoints,
                            dataLabelHorizontalPosition: visuals.StandardObjectProperties.dataLabelHorizontalPosition,
                            dataLabelVerticalPosition: visuals.StandardObjectProperties.dataLabelVerticalPosition,
                            dataLabelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits
                        }
                    },
                    labels: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                        description: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabelsDescription"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            showSeries: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                type: {
                                    bool: !0
                                }
                            },
                            color: visuals.StandardObjectProperties.dataColor,
                            labelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits,
                            labelPrecision: $.extend({}, visuals.StandardObjectProperties.labelPrecision, {
                                suppressFormatPainterCopy: !0
                            }),
                            showAll: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_LabelSeriesShowAll"),
                                type: {
                                    bool: !0
                                }
                            },
                            fontSize: visuals.StandardObjectProperties.fontSize,
                            labelDensity: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_LabelDensity"),
                                type: {
                                    formatting: {
                                        labelDensity: !0
                                    }
                                }
                            }
                        }
                    },
                    plotArea: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Plot"),
                        properties: {
                            transparency: visuals.StandardObjectProperties.transparency,
                            image: visuals.StandardObjectProperties.image
                        }
                    }
                },
                dataViewMappings: [ {
                    conditions: [ {
                        Category: {
                            max: 1
                        },
                        Series: {
                            max: 0
                        }
                    }, {
                        Category: {
                            max: 1
                        },
                        Series: {
                            min: 1,
                            max: 1
                        },
                        Y: {
                            max: 1
                        }
                    } ],
                    categorical: {
                        categories: {
                            "for": {
                                "in": "Category"
                            },
                            dataReductionAlgorithm: {
                                window: {
                                    count: 100
                                }
                            }
                        },
                        values: {
                            group: {
                                by: "Series",
                                select: [ {
                                    "for": {
                                        "in": "Y"
                                    }
                                } ],
                                dataReductionAlgorithm: {
                                    top: {
                                        count: 60
                                    }
                                }
                            }
                        }
                    }
                }, {
                    conditions: [ {
                        Category: {
                            max: 1
                        },
                        Series: {
                            max: 0
                        }
                    }, {
                        Category: {
                            max: 1
                        },
                        Series: {
                            min: 1,
                            max: 1
                        },
                        Y: {
                            max: 1
                        }
                    } ],
                    requiredProperties: [ {
                        objectName: "trend",
                        propertyName: "show"
                    } ],
                    usage: {
                        regression: {
                            combineSeries: {
                                objectName: "trend",
                                propertyName: "combineSeries"
                            }
                        }
                    },
                    categorical: {
                        categories: {
                            "for": {
                                "in": "regression.X"
                            }
                        },
                        values: {
                            group: {
                                by: "regression.Series",
                                select: [ {
                                    "for": {
                                        "in": "regression.Y"
                                    }
                                } ]
                            }
                        }
                    }
                }, {
                    conditions: [ {
                        Category: {
                            max: 1
                        },
                        Series: {
                            max: 0
                        },
                        Y: {
                            max: 1
                        }
                    } ],
                    requiredProperties: [ {
                        objectName: "forecast",
                        propertyName: "show"
                    } ],
                    usage: {
                        forecast: {}
                    },
                    categorical: {
                        categories: {
                            "for": {
                                "in": "Category"
                            }
                        },
                        values: {
                            group: {
                                by: "Series",
                                select: [ {
                                    "for": {
                                        "in": "forecast.ForecastValue"
                                    }
                                }, {
                                    "for": {
                                        "in": "forecast.ConfidenceHighBound"
                                    }
                                }, {
                                    "for": {
                                        "in": "forecast.ConfidenceLowBound"
                                    }
                                } ]
                            }
                        }
                    }
                } ],
                sorting: {
                    "default": {}
                }
            }, visuals.lineChartProps = {
                general: {
                    formatString: {
                        objectName: "general",
                        propertyName: "formatString"
                    }
                },
                dataPoint: {
                    defaultColor: {
                        objectName: "dataPoint",
                        propertyName: "defaultColor"
                    },
                    fill: {
                        objectName: "dataPoint",
                        propertyName: "fill"
                    }
                },
                trend: {
                    show: {
                        objectName: "trend",
                        propertyName: "show"
                    }
                },
                scalarKey: {
                    scalarKeyMin: {
                        objectName: "scalarKey",
                        propertyName: "min"
                    }
                },
                forecast: {
                    show: {
                        objectName: "forecast",
                        propertyName: "show"
                    }
                },
                categoryAxis: {
                    axisType: {
                        objectName: "categoryAxis",
                        propertyName: "axisType"
                    }
                },
                legend: {
                    labelColor: {
                        objectName: "legend",
                        propertyName: "labelColor"
                    }
                },
                labels: {
                    labelDensity: {
                        objectName: "labels",
                        propertyName: "labelDensity"
                    }
                },
                plotArea: {
                    image: {
                        objectName: "plotArea",
                        propertyName: "image"
                    },
                    transparency: {
                        objectName: "plotArea",
                        propertyName: "transparency"
                    }
                }
            };
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            visuals.mapCapabilities = {
                dataRoles: [ {
                    name: "Category",
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Location"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_LocationMapDescription"),
                    preferredTypes: [ {
                        geography: {
                            address: !0
                        }
                    }, {
                        geography: {
                            city: !0
                        }
                    }, {
                        geography: {
                            continent: !0
                        }
                    }, {
                        geography: {
                            country: !0
                        }
                    }, {
                        geography: {
                            county: !0
                        }
                    }, {
                        geography: {
                            place: !0
                        }
                    }, {
                        geography: {
                            postalCode: !0
                        }
                    }, {
                        geography: {
                            region: !0
                        }
                    }, {
                        geography: {
                            stateOrProvince: !0
                        }
                    } ]
                }, {
                    name: "Series",
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Legend"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_LegendDescription")
                }, {
                    name: "Y",
                    kind: powerbi.VisualDataRoleKind.GroupingOrMeasure,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Latitude"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_LatitudeMapDescription"),
                    preferredTypes: [ {
                        geography: {
                            latitude: !0
                        }
                    } ]
                }, {
                    name: "X",
                    kind: powerbi.VisualDataRoleKind.GroupingOrMeasure,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Longitude"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_LongitudeMapDescription"),
                    preferredTypes: [ {
                        geography: {
                            longitude: !0
                        }
                    } ]
                }, {
                    name: "Size",
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Size"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_SizeDescription"),
                    requiredTypes: [ {
                        numeric: !0
                    }, {
                        integer: !0
                    } ]
                }, {
                    name: "Gradient",
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Gradient"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_GradientDescription"),
                    requiredTypes: [ {
                        numeric: !0
                    }, {
                        integer: !0
                    } ],
                    joinPredicate: 0
                } ],
                objects: {
                    general: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                        properties: {
                            formatString: visuals.StandardObjectProperties.formatString
                        }
                    },
                    legend: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                        description: powerbi.data.createDisplayNameGetter("Visual_LegendDescription"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            position: visuals.StandardObjectProperties.legendPosition,
                            showTitle: visuals.StandardObjectProperties.showLegendTitle,
                            titleText: visuals.StandardObjectProperties.legendTitle,
                            fontSize: visuals.StandardObjectProperties.fontSize
                        }
                    },
                    dataPoint: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                        description: powerbi.data.createDisplayNameGetter("Visual_DataPointDescription"),
                        properties: {
                            defaultColor: visuals.StandardObjectProperties.defaultColor,
                            showAllDataPoints: visuals.StandardObjectProperties.showAllDataPoints,
                            fill: visuals.StandardObjectProperties.fill,
                            fillRule: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Gradient"),
                                type: {
                                    fillRule: {}
                                },
                                rule: {
                                    inputRole: "Gradient",
                                    output: {
                                        property: "fill",
                                        selector: [ "Category", "X", "Y" ]
                                    }
                                }
                            }
                        }
                    },
                    categoryLabels: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_CategoryLabels"),
                        description: powerbi.data.createDisplayNameGetter("Visual_CategoryLabelsDescription"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            color: visuals.StandardObjectProperties.dataColor,
                            fontSize: visuals.StandardObjectProperties.fontSize
                        }
                    }
                },
                dataViewMappings: [ {
                    conditions: [ {
                        Category: {
                            min: 1,
                            max: 1
                        },
                        Series: {
                            max: 1
                        },
                        X: {
                            max: 1,
                            kind: powerbi.VisualDataRoleKind.Measure
                        },
                        Y: {
                            max: 1,
                            kind: powerbi.VisualDataRoleKind.Measure
                        },
                        Size: {
                            max: 1
                        },
                        Gradient: {
                            max: 0
                        }
                    }, {
                        Category: {
                            min: 1,
                            max: 1
                        },
                        Series: {
                            max: 0
                        },
                        X: {
                            max: 1,
                            kind: powerbi.VisualDataRoleKind.Measure
                        },
                        Y: {
                            max: 1,
                            kind: powerbi.VisualDataRoleKind.Measure
                        },
                        Size: {
                            max: 1
                        },
                        Gradient: {
                            max: 1
                        }
                    } ],
                    categorical: {
                        categories: {
                            "for": {
                                "in": "Category"
                            },
                            dataReductionAlgorithm: {
                                top: {}
                            }
                        },
                        values: {
                            group: {
                                by: "Series",
                                select: [ {
                                    bind: {
                                        to: "X"
                                    }
                                }, {
                                    bind: {
                                        to: "Y"
                                    }
                                }, {
                                    bind: {
                                        to: "Size"
                                    }
                                }, {
                                    bind: {
                                        to: "Gradient"
                                    }
                                } ],
                                dataReductionAlgorithm: {
                                    top: {}
                                }
                            }
                        },
                        rowCount: {
                            preferred: {
                                min: 2
                            }
                        },
                        dataVolume: 4
                    }
                }, {
                    conditions: [ {
                        Category: {
                            max: 0
                        },
                        Series: {
                            max: 1
                        },
                        X: {
                            max: 1,
                            kind: powerbi.VisualDataRoleKind.Grouping
                        },
                        Y: {
                            max: 1,
                            kind: powerbi.VisualDataRoleKind.Grouping
                        },
                        Size: {
                            max: 1
                        },
                        Gradient: {
                            max: 0
                        }
                    }, {
                        Category: {
                            max: 0
                        },
                        Series: {
                            max: 0
                        },
                        X: {
                            max: 1,
                            kind: powerbi.VisualDataRoleKind.Grouping
                        },
                        Y: {
                            max: 1,
                            kind: powerbi.VisualDataRoleKind.Grouping
                        },
                        Size: {
                            max: 1
                        },
                        Gradient: {
                            max: 1
                        }
                    } ],
                    categorical: {
                        categories: {
                            select: [ {
                                bind: {
                                    to: "X"
                                }
                            }, {
                                bind: {
                                    to: "Y"
                                }
                            } ],
                            dataReductionAlgorithm: {
                                top: {}
                            }
                        },
                        values: {
                            group: {
                                by: "Series",
                                select: [ {
                                    bind: {
                                        to: "Size"
                                    }
                                }, {
                                    bind: {
                                        to: "Gradient"
                                    }
                                } ],
                                dataReductionAlgorithm: {
                                    top: {}
                                }
                            }
                        },
                        rowCount: {
                            preferred: {
                                min: 2
                            }
                        },
                        dataVolume: 4
                    }
                } ],
                sorting: {
                    custom: {},
                    implicit: {
                        clauses: [ {
                            role: "Size",
                            direction: 2
                        } ]
                    }
                },
                drilldown: {
                    roles: [ "Category" ]
                }
            }, visuals.mapProps = {
                general: {
                    formatString: {
                        objectName: "general",
                        propertyName: "formatString"
                    }
                },
                dataPoint: {
                    defaultColor: {
                        objectName: "dataPoint",
                        propertyName: "defaultColor"
                    },
                    fill: {
                        objectName: "dataPoint",
                        propertyName: "fill"
                    },
                    showAllDataPoints: {
                        objectName: "dataPoint",
                        propertyName: "showAllDataPoints"
                    }
                },
                legend: {
                    show: {
                        objectName: "legend",
                        propertyName: "show"
                    },
                    position: {
                        objectName: "legend",
                        propertyName: "position"
                    },
                    showTitle: {
                        objectName: "legend",
                        propertyName: "showTitle"
                    },
                    titleText: {
                        objectName: "legend",
                        propertyName: "titleText"
                    }
                }
            };
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            visuals.multiRowCardCapabilities = {
                dataRoles: [ {
                    name: "Values",
                    kind: powerbi.VisualDataRoleKind.GroupingOrMeasure,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Fields"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_FieldsDescription")
                } ],
                objects: {
                    general: {
                        properties: {
                            formatString: visuals.StandardObjectProperties.formatString
                        }
                    },
                    cardTitle: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_CardTitle"),
                        description: powerbi.data.createDisplayNameGetter("Visual_CardTitleDescription"),
                        properties: {
                            color: visuals.StandardObjectProperties.dataColor,
                            fontSize: visuals.StandardObjectProperties.fontSize
                        }
                    },
                    dataLabels: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                        description: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabelsDescription"),
                        properties: {
                            color: visuals.StandardObjectProperties.dataColor,
                            fontSize: visuals.StandardObjectProperties.fontSize
                        }
                    },
                    categoryLabels: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_CategoryLabels"),
                        description: powerbi.data.createDisplayNameGetter("Visual_CategoryLabelsDescription"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            color: visuals.StandardObjectProperties.dataColor,
                            fontSize: visuals.StandardObjectProperties.fontSize
                        }
                    },
                    card: {
                        displayName: powerbi.data.createDisplayNameGetter("Card_ToolTip"),
                        properties: {
                            outline: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Outline"),
                                type: {
                                    enumeration: visuals.outline.type
                                }
                            },
                            outlineColor: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_OutlineColor"),
                                description: powerbi.data.createDisplayNameGetter("Visual_OutlineColor_Desc"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            },
                            outlineWeight: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_OutlineWeight"),
                                description: powerbi.data.createDisplayNameGetter("Visual_OutlineWeight_Desc"),
                                type: {
                                    numeric: !0
                                }
                            },
                            barShow: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_MultiRowCard_BarShow"),
                                description: powerbi.data.createDisplayNameGetter("Visual_MultiRowCard_BarShow_Desc"),
                                type: {
                                    bool: !0
                                }
                            },
                            barColor: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_MultiRowCard_BarColor"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            },
                            barWeight: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_MultiRowCard_BarWeight"),
                                description: powerbi.data.createDisplayNameGetter("Visual_MultiRowCard_BarWeight_Desc"),
                                type: {
                                    numeric: !0
                                }
                            },
                            cardPadding: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_MultiRowCard_CardPadding"),
                                description: powerbi.data.createDisplayNameGetter("Visual_MultiRowCard_CardBackground"),
                                type: {
                                    numeric: !0
                                }
                            },
                            cardBackground: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Background"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            }
                        }
                    }
                },
                dataViewMappings: [ {
                    table: {
                        rows: {
                            "for": {
                                "in": "Values"
                            },
                            dataReductionAlgorithm: {
                                window: {}
                            }
                        },
                        rowCount: {
                            preferred: {
                                min: 1
                            }
                        }
                    }
                } ],
                sorting: {
                    "default": {}
                },
                suppressDefaultTitle: !0,
                supportsSelection: !1,
                disableVisualDetails: !0
            }, visuals.multiRowCardProps = {
                card: {
                    outline: {
                        objectName: "card",
                        propertyName: "outline"
                    },
                    outlineColor: {
                        objectName: "card",
                        propertyName: "outlineColor"
                    },
                    outlineWeight: {
                        objectName: "card",
                        propertyName: "outlineWeight"
                    },
                    barShow: {
                        objectName: "card",
                        propertyName: "barShow"
                    },
                    barColor: {
                        objectName: "card",
                        propertyName: "barColor"
                    },
                    barWeight: {
                        objectName: "card",
                        propertyName: "barWeight"
                    },
                    cardPadding: {
                        objectName: "card",
                        propertyName: "cardPadding"
                    },
                    cardBackground: {
                        objectName: "card",
                        propertyName: "cardBackground"
                    }
                }
            };
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            visuals.textboxCapabilities = {
                objects: {
                    general: {
                        properties: {
                            paragraphs: {
                                type: {
                                    paragraphs: {}
                                },
                                suppressFormatPainterCopy: !0
                            }
                        }
                    }
                },
                suppressDefaultTitle: !0,
                supportsSelection: !1
            };
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            visuals.cheerMeterCapabilities = {
                dataRoles: [ {
                    name: "Category",
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Axis"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_AxisDescription")
                }, {
                    name: "Y",
                    kind: powerbi.VisualDataRoleKind.Measure,
                    requiredTypes: [ {
                        numeric: !0
                    }, {
                        integer: !0
                    } ],
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Y"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_YDescription")
                } ],
                dataViewMappings: [ {
                    categorical: {
                        categories: {
                            "for": {
                                "in": "Category"
                            }
                        }
                    }
                } ],
                objects: {
                    dataPoint: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                        description: powerbi.data.createDisplayNameGetter("Visual_DataPointDescription"),
                        properties: {
                            fill: visuals.StandardObjectProperties.fill
                        }
                    }
                }
            };
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            visuals.scatterChartCapabilities = {
                dataRoles: [ {
                    name: "Category",
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Details"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_DetailsScatterChartDescription")
                }, {
                    name: "Series",
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Legend"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_LegendDescription")
                }, {
                    name: "X",
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_X"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_XScatterChartDescription"),
                    requiredTypes: [ {
                        numeric: !0
                    }, {
                        integer: !0
                    } ],
                    cartesianKind: 0
                }, {
                    name: "Y",
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Y"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_YScatterChartDescription"),
                    requiredTypes: [ {
                        numeric: !0
                    }, {
                        integer: !0
                    } ],
                    cartesianKind: 1
                }, {
                    name: "Size",
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Size"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_SizeDescription"),
                    requiredTypes: [ {
                        numeric: !0
                    }, {
                        integer: !0
                    } ]
                }, {
                    name: "Gradient",
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Gradient"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_GradientDescription"),
                    requiredTypes: [ {
                        numeric: !0
                    }, {
                        integer: !0
                    } ],
                    joinPredicate: 0
                }, {
                    name: "Play",
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Play")
                } ],
                objects: {
                    dataPoint: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                        description: powerbi.data.createDisplayNameGetter("Visual_DataPointDescription"),
                        properties: {
                            defaultColor: visuals.StandardObjectProperties.defaultColor,
                            showAllDataPoints: visuals.StandardObjectProperties.showAllDataPoints,
                            fill: visuals.StandardObjectProperties.fill,
                            fillRule: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Gradient"),
                                type: {
                                    fillRule: {}
                                },
                                rule: {
                                    inputRole: "Gradient",
                                    output: {
                                        property: "fill",
                                        selector: [ "Category" ]
                                    }
                                }
                            }
                        }
                    },
                    general: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                        properties: {
                            formatString: visuals.StandardObjectProperties.formatString
                        }
                    },
                    trend: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Trend_Line"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            displayName: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_DisplayName"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_DisplayName_Description"),
                                type: {
                                    text: !0
                                }
                            },
                            lineColor: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Color"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Color_Description"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            },
                            transparency: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Transparency"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Transparency_Description"),
                                type: {
                                    numeric: !0
                                }
                            },
                            style: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Style"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Style_Description"),
                                type: {
                                    enumeration: visuals.lineStyle.type
                                }
                            },
                            combineSeries: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Combine_Series"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Trend_Line_Combine_Series_Description"),
                                type: {
                                    bool: !0
                                }
                            }
                        }
                    },
                    categoryAxis: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_XAxis"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            axisScale: visuals.StandardObjectProperties.axisScale,
                            start: visuals.StandardObjectProperties.axisStart,
                            end: visuals.StandardObjectProperties.axisEnd,
                            showAxisTitle: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Axis_XTitleDescription"),
                                type: {
                                    bool: !0
                                }
                            },
                            axisStyle: visuals.StandardObjectProperties.axisStyle,
                            labelColor: visuals.StandardObjectProperties.labelColor,
                            labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
                            labelPrecision: visuals.StandardObjectProperties.labelPrecision
                        }
                    },
                    valueAxis: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            position: visuals.StandardObjectProperties.yAxisPosition,
                            axisScale: visuals.StandardObjectProperties.axisScale,
                            start: visuals.StandardObjectProperties.axisStart,
                            end: visuals.StandardObjectProperties.axisEnd,
                            showAxisTitle: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Axis_YTitleDescription"),
                                type: {
                                    bool: !0
                                }
                            },
                            axisStyle: visuals.StandardObjectProperties.axisStyle,
                            labelColor: visuals.StandardObjectProperties.labelColor,
                            labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
                            labelPrecision: visuals.StandardObjectProperties.labelPrecision
                        }
                    },
                    xAxisReferenceLine: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_X"),
                        description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Description"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            displayName: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_DisplayName"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_DisplayName_Description"),
                                type: {
                                    text: !0
                                }
                            },
                            value: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Value"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Value_Description"),
                                type: {
                                    numeric: !0
                                }
                            },
                            lineColor: visuals.StandardObjectProperties.lineColor,
                            transparency: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Transparency"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Transparency_Description"),
                                type: {
                                    numeric: !0
                                }
                            },
                            style: visuals.StandardObjectProperties.referenceLineStyle,
                            position: visuals.StandardObjectProperties.referenceLinePosition,
                            dataLabelShow: visuals.StandardObjectProperties.dataLabelShow,
                            dataLabelColor: visuals.StandardObjectProperties.dataLabelColor,
                            dataLabelDecimalPoints: visuals.StandardObjectProperties.dataLabelDecimalPoints,
                            dataLabelHorizontalPosition: visuals.StandardObjectProperties.dataLabelHorizontalPosition,
                            dataLabelVerticalPosition: visuals.StandardObjectProperties.dataLabelVerticalPosition,
                            dataLabelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits
                        }
                    },
                    y1AxisReferenceLine: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Y"),
                        description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Description"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            displayName: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_DisplayName"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_DisplayName_Description"),
                                type: {
                                    text: !0
                                }
                            },
                            value: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Value"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Value_Description"),
                                type: {
                                    numeric: !0
                                }
                            },
                            lineColor: visuals.StandardObjectProperties.lineColor,
                            transparency: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Transparency"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Transparency_Description"),
                                type: {
                                    numeric: !0
                                }
                            },
                            style: visuals.StandardObjectProperties.referenceLineStyle,
                            position: visuals.StandardObjectProperties.referenceLinePosition,
                            dataLabelShow: visuals.StandardObjectProperties.dataLabelShow,
                            dataLabelColor: visuals.StandardObjectProperties.dataLabelColor,
                            dataLabelDecimalPoints: visuals.StandardObjectProperties.dataLabelDecimalPoints,
                            dataLabelHorizontalPosition: visuals.StandardObjectProperties.dataLabelHorizontalPosition,
                            dataLabelVerticalPosition: visuals.StandardObjectProperties.dataLabelVerticalPosition,
                            dataLabelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits
                        }
                    },
                    referenceLine: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line"),
                        description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Description"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            displayName: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_DisplayName"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_DisplayName_Description"),
                                type: {
                                    text: !0
                                }
                            },
                            value: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Value"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Value_Description"),
                                type: {
                                    numeric: !0
                                }
                            },
                            lineColor: visuals.StandardObjectProperties.lineColor,
                            transparency: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Transparency"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Transparency_Description"),
                                type: {
                                    numeric: !0
                                }
                            },
                            style: visuals.StandardObjectProperties.referenceLineStyle,
                            position: visuals.StandardObjectProperties.referenceLinePosition,
                            dataLabelShow: visuals.StandardObjectProperties.dataLabelShow,
                            dataLabelColor: visuals.StandardObjectProperties.dataLabelColor,
                            dataLabelDecimalPoints: visuals.StandardObjectProperties.dataLabelDecimalPoints,
                            dataLabelHorizontalPosition: visuals.StandardObjectProperties.dataLabelHorizontalPosition,
                            dataLabelVerticalPosition: visuals.StandardObjectProperties.dataLabelVerticalPosition,
                            dataLabelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits
                        }
                    },
                    legend: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                        description: powerbi.data.createDisplayNameGetter("Visual_LegendDescription"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            position: visuals.StandardObjectProperties.legendPosition,
                            showTitle: visuals.StandardObjectProperties.showLegendTitle,
                            titleText: $.extend({}, visuals.StandardObjectProperties.legendTitle, {
                                suppressFormatPainterCopy: !0
                            }),
                            labelColor: visuals.StandardObjectProperties.labelColor,
                            fontSize: visuals.StandardObjectProperties.fontSize
                        }
                    },
                    categoryLabels: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_CategoryLabels"),
                        description: powerbi.data.createDisplayNameGetter("Visual_CategoryLabelsDescription"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            color: visuals.StandardObjectProperties.dataColor,
                            fontSize: visuals.StandardObjectProperties.fontSize
                        }
                    },
                    colorBorder: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_ColorBorder"),
                        properties: {
                            show: visuals.StandardObjectProperties.show
                        }
                    },
                    fillPoint: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_FillPoint"),
                        properties: {
                            show: visuals.StandardObjectProperties.show
                        }
                    },
                    colorByCategory: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_ColorByCategory"),
                        properties: {
                            show: visuals.StandardObjectProperties.show
                        }
                    },
                    currentFrameIndex: {
                        properties: {
                            index: {
                                type: {
                                    numeric: !0
                                }
                            }
                        }
                    },
                    plotArea: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Plot"),
                        properties: {
                            transparency: visuals.StandardObjectProperties.transparency,
                            image: visuals.StandardObjectProperties.image
                        }
                    }
                },
                dataViewMappings: [ {
                    conditions: [ {
                        Category: {
                            max: 1
                        },
                        Series: {
                            max: 1
                        },
                        X: {
                            max: 1
                        },
                        Y: {
                            max: 1
                        },
                        Size: {
                            max: 1
                        },
                        Gradient: {
                            max: 0
                        },
                        Play: {
                            max: 0
                        }
                    }, {
                        Category: {
                            max: 1
                        },
                        Series: {
                            max: 0
                        },
                        X: {
                            max: 1
                        },
                        Y: {
                            max: 1
                        },
                        Size: {
                            max: 1
                        },
                        Gradient: {
                            max: 1
                        },
                        Play: {
                            max: 0
                        }
                    } ],
                    categorical: {
                        categories: {
                            "for": {
                                "in": "Category"
                            }
                        },
                        values: {
                            group: {
                                by: "Series",
                                select: [ {
                                    bind: {
                                        to: "X"
                                    }
                                }, {
                                    bind: {
                                        to: "Y"
                                    }
                                }, {
                                    bind: {
                                        to: "Size"
                                    }
                                }, {
                                    bind: {
                                        to: "Gradient"
                                    }
                                } ]
                            }
                        },
                        rowCount: {
                            preferred: {
                                min: 2
                            }
                        },
                        dataReductionAlgorithm: {
                            sample: {}
                        },
                        dataVolume: 4
                    }
                }, {
                    conditions: [ {
                        Category: {
                            max: 1
                        },
                        Series: {
                            max: 1
                        },
                        X: {
                            max: 1
                        },
                        Y: {
                            max: 1
                        },
                        Size: {
                            max: 1
                        },
                        Gradient: {
                            max: 0
                        },
                        Play: {
                            min: 1,
                            max: 1
                        }
                    } ],
                    matrix: {
                        rows: {
                            select: [ {
                                bind: {
                                    to: "Play"
                                }
                            }, {
                                bind: {
                                    to: "Category"
                                }
                            } ],
                            dataReductionAlgorithm: {
                                bottom: {
                                    count: 5e3
                                }
                            }
                        },
                        columns: {
                            "for": {
                                "in": "Series"
                            },
                            dataReductionAlgorithm: {
                                top: {
                                    count: 60
                                }
                            }
                        },
                        values: {
                            select: [ {
                                bind: {
                                    to: "X"
                                }
                            }, {
                                bind: {
                                    to: "Y"
                                }
                            }, {
                                bind: {
                                    to: "Size"
                                }
                            } ]
                        }
                    }
                }, {
                    conditions: [ {
                        Category: {
                            max: 1
                        },
                        Series: {
                            max: 1
                        },
                        X: {
                            max: 1
                        },
                        Y: {
                            max: 1
                        },
                        Size: {
                            max: 0
                        },
                        Gradient: {
                            max: 0
                        },
                        Play: {
                            max: 0
                        }
                    }, {
                        Category: {
                            max: 1
                        },
                        Series: {
                            max: 0
                        },
                        X: {
                            max: 1
                        },
                        Y: {
                            max: 1
                        },
                        Size: {
                            max: 0
                        },
                        Gradient: {
                            max: 1
                        },
                        Play: {
                            max: 0
                        }
                    } ],
                    requiredProperties: [ {
                        objectName: "trend",
                        propertyName: "show"
                    } ],
                    usage: {
                        regression: {
                            combineSeries: {
                                objectName: "trend",
                                propertyName: "combineSeries"
                            }
                        }
                    },
                    categorical: {
                        categories: {
                            "for": {
                                "in": "regression.X"
                            }
                        },
                        values: {
                            group: {
                                by: "regression.Series",
                                select: [ {
                                    "for": {
                                        "in": "regression.Y"
                                    }
                                } ]
                            }
                        },
                        dataReductionAlgorithm: {
                            sample: {}
                        },
                        dataVolume: 4
                    }
                } ],
                sorting: {
                    custom: {},
                    implicit: {
                        clauses: [ {
                            role: "Play",
                            direction: 1
                        } ]
                    }
                },
                drilldown: {
                    roles: [ "Category" ]
                }
            }, visuals.scatterChartProps = {
                general: {
                    formatString: {
                        objectName: "general",
                        propertyName: "formatString"
                    }
                },
                dataPoint: {
                    defaultColor: {
                        objectName: "dataPoint",
                        propertyName: "defaultColor"
                    },
                    fill: {
                        objectName: "dataPoint",
                        propertyName: "fill"
                    }
                },
                trend: {
                    show: {
                        objectName: "trend",
                        propertyName: "show"
                    }
                },
                colorBorder: {
                    show: {
                        objectName: "colorBorder",
                        propertyName: "show"
                    }
                },
                fillPoint: {
                    show: {
                        objectName: "fillPoint",
                        propertyName: "show"
                    }
                },
                colorByCategory: {
                    show: {
                        objectName: "colorByCategory",
                        propertyName: "show"
                    }
                },
                currentFrameIndex: {
                    index: {
                        objectName: "currentFrameIndex",
                        propertyName: "index"
                    }
                },
                legend: {
                    labelColor: {
                        objectName: "legend",
                        propertyName: "labelColor"
                    }
                },
                plotArea: {
                    image: {
                        objectName: "plotArea",
                        propertyName: "image"
                    },
                    transparency: {
                        objectName: "plotArea",
                        propertyName: "transparency"
                    }
                }
            };
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            visuals.slicerCapabilities = {
                dataRoles: [ {
                    name: "Values",
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Field"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_FieldDescription")
                } ],
                objects: {
                    general: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                        properties: {
                            filter: {
                                type: {
                                    filter: {}
                                }
                            },
                            selfFilter: {
                                type: {
                                    filter: {
                                        selfFilter: !0
                                    }
                                }
                            },
                            defaultValue: {
                                type: {
                                    expression: {
                                        defaultValue: !0
                                    }
                                }
                            },
                            formatString: visuals.StandardObjectProperties.formatString,
                            outlineColor: visuals.StandardObjectProperties.outlineColor,
                            outlineWeight: visuals.StandardObjectProperties.outlineWeight,
                            orientation: {
                                displayName: powerbi.data.createDisplayNameGetter("Slicer_Orientation"),
                                type: {
                                    enumeration: visuals.slicerOrientation.type
                                }
                            },
                            count: {
                                type: {
                                    integer: !0
                                }
                            },
                            selfFilterEnabled: {
                                type: {
                                    operations: {
                                        searchEnabled: !0
                                    }
                                }
                            }
                        }
                    },
                    selection: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_SelectionControls"),
                        properties: {
                            selectAllCheckboxEnabled: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_SelectAll"),
                                type: {
                                    bool: !0
                                }
                            },
                            singleSelect: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_SingleSelect"),
                                type: {
                                    bool: !0
                                }
                            }
                        }
                    },
                    header: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Header"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            fontColor: visuals.StandardObjectProperties.fontColor,
                            background: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Background"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            },
                            outline: visuals.StandardObjectProperties.outline,
                            textSize: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                type: {
                                    numeric: !0
                                }
                            }
                        }
                    },
                    items: {
                        displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Items"),
                        properties: {
                            fontColor: visuals.StandardObjectProperties.fontColor,
                            background: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Background"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            },
                            outline: visuals.StandardObjectProperties.outline,
                            textSize: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                type: {
                                    numeric: !0
                                }
                            }
                        }
                    }
                },
                dataViewMappings: [ {
                    conditions: [ {
                        Values: {
                            max: 1
                        }
                    } ],
                    categorical: {
                        categories: {
                            "for": {
                                "in": "Values"
                            },
                            dataReductionAlgorithm: {
                                window: {}
                            }
                        },
                        includeEmptyGroups: !0
                    }
                } ],
                sorting: {
                    "default": {}
                },
                suppressDefaultTitle: !0,
                disableVisualDetails: !0
            }, visuals.slicerProps = {
                general: {
                    outlineColor: {
                        objectName: "general",
                        propertyName: "outlineColor"
                    },
                    outlineWeight: {
                        objectName: "general",
                        propertyName: "outlineWeight"
                    },
                    orientation: {
                        objectName: "general",
                        propertyName: "orientation"
                    },
                    count: {
                        objectName: "general",
                        propertyName: "count"
                    },
                    selfFilterEnabled: {
                        objectName: "general",
                        propertyName: "selfFilterEnabled"
                    }
                },
                selection: {
                    selectAllCheckboxEnabled: {
                        objectName: "selection",
                        propertyName: "selectAllCheckboxEnabled"
                    },
                    singleSelect: {
                        objectName: "selection",
                        propertyName: "singleSelect"
                    }
                },
                header: {
                    show: {
                        objectName: "header",
                        propertyName: "show"
                    },
                    fontColor: {
                        objectName: "header",
                        propertyName: "fontColor"
                    },
                    background: {
                        objectName: "header",
                        propertyName: "background"
                    },
                    outline: {
                        objectName: "header",
                        propertyName: "outline"
                    },
                    textSize: {
                        objectName: "header",
                        propertyName: "textSize"
                    }
                },
                items: {
                    fontColor: {
                        objectName: "items",
                        propertyName: "fontColor"
                    },
                    background: {
                        objectName: "items",
                        propertyName: "background"
                    },
                    outline: {
                        objectName: "items",
                        propertyName: "outline"
                    },
                    textSize: {
                        objectName: "items",
                        propertyName: "textSize"
                    }
                },
                filterPropertyIdentifier: {
                    objectName: "general",
                    propertyName: "filter"
                },
                selfFilterPropertyIdentifier: {
                    objectName: "general",
                    propertyName: "selfFilter"
                },
                formatString: {
                    objectName: "general",
                    propertyName: "formatString"
                },
                defaultValue: {
                    objectName: "general",
                    propertyName: "defaultValue"
                }
            };
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            visuals.tableCapabilities = {
                dataRoles: [ {
                    name: "Values",
                    kind: powerbi.VisualDataRoleKind.GroupingOrMeasure,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values")
                } ],
                objects: {
                    general: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                        properties: {
                            formatString: visuals.StandardObjectProperties.formatString,
                            columnWidth: {
                                type: {
                                    numeric: !0
                                }
                            },
                            totals: {
                                type: {
                                    bool: !0
                                },
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Totals"),
                                suppressFormatPainterCopy: !0
                            },
                            autoSizeColumnWidth: {
                                type: {
                                    bool: !0
                                },
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Adjust_Column_Width"),
                                suppressFormatPainterCopy: !0
                            },
                            textSize: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                type: {
                                    numeric: !0
                                }
                            }
                        }
                    },
                    grid: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Grid"),
                        properties: {
                            outlineColor: visuals.StandardObjectProperties.outlineColor,
                            outlineWeight: visuals.StandardObjectProperties.outlineWeight,
                            gridVertical: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_GridVertical"),
                                description: powerbi.data.createDisplayNameGetter("Visual_GridVertical_Desc"),
                                type: {
                                    bool: !0
                                }
                            },
                            gridVerticalColor: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_GridVertical_Color"),
                                description: powerbi.data.createDisplayNameGetter("Visual_GridVertical_Color_Desc"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            },
                            gridVerticalWeight: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_GridVertical_Weight"),
                                description: powerbi.data.createDisplayNameGetter("Visual_GridVertical_Weight_Desc"),
                                type: {
                                    numeric: !0
                                }
                            },
                            gridHorizontal: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_GridHorizontal"),
                                description: powerbi.data.createDisplayNameGetter("Visual_GridHorizontal_Desc"),
                                type: {
                                    bool: !0
                                }
                            },
                            gridHorizontalColor: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_GridHorizontal_Color"),
                                description: powerbi.data.createDisplayNameGetter("Visual_GridHorizontal_Color_Desc"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            },
                            gridHorizontalWeight: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_GridHorizontal_Weight"),
                                description: powerbi.data.createDisplayNameGetter("Visual_GridHorizontal_Weight_Desc"),
                                type: {
                                    numeric: !0
                                }
                            },
                            rowPadding: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_RowPadding"),
                                description: powerbi.data.createDisplayNameGetter("Visual_RowPadding_Desc"),
                                type: {
                                    numeric: !0
                                }
                            },
                            imageHeight: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_ImageHeight"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Tablix_ImageHeight_Desc"),
                                type: {
                                    numeric: !0
                                }
                            }
                        }
                    },
                    columnHeaders: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_ColumnHeaders"),
                        properties: {
                            outline: visuals.StandardObjectProperties.outline,
                            fontColor: visuals.StandardObjectProperties.fontColor,
                            backColor: visuals.StandardObjectProperties.backColor
                        }
                    },
                    values: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_Values"),
                        properties: {
                            outline: visuals.StandardObjectProperties.outline,
                            backColor: {
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            },
                            fontColorPrimary: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_FontColorPrimary"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Tablix_FontColorPrimary_Desc"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            },
                            backColorPrimary: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_BackColorPrimary"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Tablix_BackColorPrimary_Desc"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            },
                            fontColorSecondary: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_FontColorSecondary"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Tablix_FontColorSecondary_Desc"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            },
                            backColorSecondary: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_BackColorSecondary"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Tablix_BackColorSecondary_Desc"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            },
                            urlIcon: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_UrlIcon"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Tablix_UrlIcon_Desc"),
                                type: {
                                    bool: !0
                                }
                            }
                        }
                    },
                    total: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_TotalGrand"),
                        properties: {
                            outline: visuals.StandardObjectProperties.outline,
                            fontColor: visuals.StandardObjectProperties.fontColor,
                            backColor: visuals.StandardObjectProperties.backColor
                        }
                    }
                },
                dataViewMappings: [ {
                    table: {
                        rows: {
                            "for": {
                                "in": "Values"
                            },
                            dataReductionAlgorithm: {
                                window: {
                                    count: 500
                                }
                            }
                        },
                        rowCount: {
                            preferred: {
                                min: 1
                            }
                        }
                    }
                } ],
                sorting: {
                    custom: {}
                },
                suppressDefaultTitle: !0,
                supportsSelection: !1,
                disableVisualDetails: !0
            };
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            visuals.matrixRoleNames = {
                rows: "Rows",
                columns: "Columns",
                values: "Values"
            }, visuals.matrixCapabilities = {
                dataRoles: [ {
                    name: visuals.matrixRoleNames.rows,
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Rows"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_RowsDescription")
                }, {
                    name: visuals.matrixRoleNames.columns,
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Columns"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_ColumnsDescription")
                }, {
                    name: visuals.matrixRoleNames.values,
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values")
                } ],
                objects: {
                    general: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                        properties: {
                            formatString: visuals.StandardObjectProperties.formatString,
                            columnWidth: {
                                type: {
                                    numeric: !0
                                }
                            },
                            rowSubtotals: {
                                type: {
                                    bool: !0
                                },
                                displayName: powerbi.data.createDisplayNameGetter("Visual_TotalRow"),
                                suppressFormatPainterCopy: !0
                            },
                            columnSubtotals: {
                                type: {
                                    bool: !0
                                },
                                displayName: powerbi.data.createDisplayNameGetter("Visual_TotalColumn"),
                                suppressFormatPainterCopy: !0
                            },
                            autoSizeColumnWidth: {
                                type: {
                                    bool: !0
                                },
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Adjust_Column_Width"),
                                suppressFormatPainterCopy: !0
                            },
                            textSize: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                type: {
                                    numeric: !0
                                }
                            }
                        }
                    },
                    grid: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Grid"),
                        properties: {
                            outlineColor: visuals.StandardObjectProperties.outlineColor,
                            outlineWeight: visuals.StandardObjectProperties.outlineWeight,
                            gridVertical: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_GridVertical"),
                                description: powerbi.data.createDisplayNameGetter("Visual_GridVertical_Desc"),
                                type: {
                                    bool: !0
                                }
                            },
                            gridVerticalColor: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_GridVertical_Color"),
                                description: powerbi.data.createDisplayNameGetter("Visual_GridVertical_Color_Desc"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            },
                            gridVerticalWeight: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_GridVertical_Weight"),
                                description: powerbi.data.createDisplayNameGetter("Visual_GridVertical_Weight_Desc"),
                                type: {
                                    numeric: !0
                                }
                            },
                            gridHorizontal: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_GridHorizontal"),
                                description: powerbi.data.createDisplayNameGetter("Visual_GridHorizontal_Desc"),
                                type: {
                                    bool: !0
                                }
                            },
                            gridHorizontalColor: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_GridHorizontal_Color"),
                                description: powerbi.data.createDisplayNameGetter("Visual_GridHorizontal_Color_Desc"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            },
                            gridHorizontalWeight: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_GridHorizontal_Weight"),
                                description: powerbi.data.createDisplayNameGetter("Visual_GridHorizontal_Weight_Desc"),
                                type: {
                                    numeric: !0
                                }
                            },
                            rowPadding: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_RowPadding"),
                                description: powerbi.data.createDisplayNameGetter("Visual_RowPadding_Desc"),
                                type: {
                                    numeric: !0
                                }
                            },
                            imageHeight: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_ImageHeight"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Tablix_ImageHeight_Desc"),
                                type: {
                                    numeric: !0
                                }
                            }
                        }
                    },
                    columnHeaders: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_ColumnHeaders"),
                        properties: {
                            outline: visuals.StandardObjectProperties.outline,
                            fontColor: visuals.StandardObjectProperties.fontColor,
                            backColor: visuals.StandardObjectProperties.backColor
                        }
                    },
                    rowHeaders: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_RowHeaders"),
                        properties: {
                            outline: visuals.StandardObjectProperties.outline,
                            fontColor: visuals.StandardObjectProperties.fontColor,
                            backColor: visuals.StandardObjectProperties.backColor
                        }
                    },
                    values: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_Values"),
                        properties: {
                            outline: visuals.StandardObjectProperties.outline,
                            fontColorPrimary: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_FontColorPrimary"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Tablix_FontColorPrimary_Desc"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            },
                            backColorPrimary: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_BackColorPrimary"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Tablix_BackColorPrimary_Desc"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            },
                            fontColorSecondary: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_FontColorSecondary"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Tablix_FontColorSecondary_Desc"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            },
                            backColorSecondary: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_BackColorSecondary"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Tablix_BackColorSecondary_Desc"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            }
                        }
                    },
                    subTotals: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Tablix_TotalSub"),
                        properties: {
                            outline: visuals.StandardObjectProperties.outline,
                            fontColor: visuals.StandardObjectProperties.fontColor,
                            backColor: visuals.StandardObjectProperties.backColor
                        }
                    }
                },
                dataViewMappings: [ {
                    conditions: [ {
                        Rows: {
                            max: 0
                        },
                        Columns: {
                            max: 0
                        },
                        Values: {
                            min: 1
                        }
                    }, {
                        Rows: {
                            min: 1
                        },
                        Columns: {
                            min: 0
                        },
                        Values: {
                            min: 0
                        }
                    }, {
                        Rows: {
                            min: 0
                        },
                        Columns: {
                            min: 1
                        },
                        Values: {
                            min: 0
                        }
                    } ],
                    matrix: {
                        rows: {
                            "for": {
                                "in": "Rows"
                            },
                            dataReductionAlgorithm: {
                                window: {
                                    count: 500
                                }
                            }
                        },
                        columns: {
                            "for": {
                                "in": "Columns"
                            },
                            dataReductionAlgorithm: {
                                top: {
                                    count: 100
                                }
                            }
                        },
                        values: {
                            "for": {
                                "in": "Values"
                            }
                        }
                    }
                } ],
                filterMappings: {
                    measureFilter: {
                        targetRoles: [ visuals.matrixRoleNames.rows ]
                    }
                },
                sorting: {
                    custom: {}
                },
                suppressDefaultTitle: !0,
                supportsSelection: !1,
                disableVisualDetails: !0
            };
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            visuals.treemapRoles = {
                group: "Group",
                details: "Details",
                values: "Values",
                gradient: "Gradient"
            }, visuals.treemapCapabilities = {
                dataRoles: [ {
                    name: "Group",
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Group"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_GroupTreemapDescription")
                }, {
                    name: "Details",
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Details")
                }, {
                    name: "Values",
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_ValuesDescription"),
                    requiredTypes: [ {
                        numeric: !0
                    }, {
                        integer: !0
                    } ]
                }, {
                    name: "Gradient",
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Gradient"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_GradientDescription"),
                    requiredTypes: [ {
                        numeric: !0
                    }, {
                        integer: !0
                    } ],
                    joinPredicate: 0
                } ],
                objects: {
                    general: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                        properties: {
                            formatString: visuals.StandardObjectProperties.formatString
                        }
                    },
                    legend: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                        description: powerbi.data.createDisplayNameGetter("Visual_LegendDescription"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            position: visuals.StandardObjectProperties.legendPosition,
                            showTitle: visuals.StandardObjectProperties.showLegendTitle,
                            titleText: visuals.StandardObjectProperties.legendTitle,
                            labelColor: visuals.StandardObjectProperties.labelColor,
                            fontSize: visuals.StandardObjectProperties.fontSize
                        }
                    },
                    dataPoint: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                        description: powerbi.data.createDisplayNameGetter("Visual_DataPointDescription"),
                        properties: {
                            fill: {
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            },
                            fillRule: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Gradient"),
                                type: {
                                    fillRule: {}
                                },
                                rule: {
                                    inputRole: "Gradient",
                                    output: {
                                        property: "fill",
                                        selector: [ "Group" ]
                                    }
                                }
                            }
                        }
                    },
                    labels: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                        description: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabelsDescription"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            color: visuals.StandardObjectProperties.dataColor,
                            labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
                            labelPrecision: visuals.StandardObjectProperties.labelPrecision
                        }
                    },
                    categoryLabels: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_CategoryLabels"),
                        description: powerbi.data.createDisplayNameGetter("Visual_CategoryLabelsDescription"),
                        properties: {
                            show: visuals.StandardObjectProperties.show
                        }
                    }
                },
                dataViewMappings: [ {
                    conditions: [ {
                        Group: {
                            max: 1
                        },
                        Details: {
                            max: 0
                        },
                        Gradient: {
                            max: 1
                        }
                    }, {
                        Group: {
                            max: 1
                        },
                        Details: {
                            min: 1,
                            max: 1
                        },
                        Values: {
                            max: 1
                        },
                        Gradient: {
                            max: 0
                        }
                    } ],
                    categorical: {
                        categories: {
                            "for": {
                                "in": "Group"
                            },
                            dataReductionAlgorithm: {
                                top: {}
                            }
                        },
                        values: {
                            group: {
                                by: "Details",
                                select: [ {
                                    bind: {
                                        to: "Values"
                                    }
                                }, {
                                    bind: {
                                        to: "Gradient"
                                    }
                                } ],
                                dataReductionAlgorithm: {
                                    top: {}
                                }
                            }
                        },
                        rowCount: {
                            preferred: {
                                min: 2
                            }
                        }
                    }
                } ],
                supportsHighlight: !0,
                sorting: {
                    custom: {},
                    implicit: {
                        clauses: [ {
                            role: "Values",
                            direction: 2
                        } ]
                    }
                },
                drilldown: {
                    roles: [ "Group" ]
                }
            }, visuals.treemapProps = {
                general: {
                    formatString: {
                        objectName: "general",
                        propertyName: "formatString"
                    }
                },
                dataPoint: {
                    fill: {
                        objectName: "dataPoint",
                        propertyName: "fill"
                    }
                },
                legend: {
                    show: {
                        objectName: "legend",
                        propertyName: "show"
                    },
                    position: {
                        objectName: "legend",
                        propertyName: "position"
                    },
                    showTitle: {
                        objectName: "legend",
                        propertyName: "showTitle"
                    },
                    titleText: {
                        objectName: "legend",
                        propertyName: "titleText"
                    },
                    labelColor: {
                        objectName: "legend",
                        propertyName: "labelColor"
                    }
                },
                labels: {
                    show: {
                        objectName: "labels",
                        propertyName: "show"
                    },
                    color: {
                        objectName: "labels",
                        propertyName: "color"
                    },
                    labelDisplayUnits: {
                        objectName: "labels",
                        propertyName: "labelDisplayUnits"
                    },
                    labelPrecision: {
                        objectName: "labels",
                        propertyName: "labelPrecision"
                    }
                },
                categoryLabels: {
                    show: {
                        objectName: "categoryLabels",
                        propertyName: "show"
                    }
                }
            };
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            visuals.cardCapabilities = {
                dataRoles: [ {
                    name: "Values",
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Fields"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_FieldsDescription")
                } ],
                objects: {
                    general: {
                        properties: {
                            formatString: visuals.StandardObjectProperties.formatString
                        }
                    },
                    labels: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointLabel"),
                        properties: {
                            color: visuals.StandardObjectProperties.dataColor,
                            labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
                            labelPrecision: visuals.StandardObjectProperties.labelPrecision,
                            fontSize: visuals.StandardObjectProperties.fontSize
                        }
                    },
                    categoryLabels: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_CategoryLabel"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            color: visuals.StandardObjectProperties.dataColor,
                            fontSize: visuals.StandardObjectProperties.fontSize
                        }
                    },
                    wordWrap: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_WordWrap"),
                        properties: {
                            show: visuals.StandardObjectProperties.show
                        }
                    }
                },
                dataViewMappings: [ {
                    conditions: [ {
                        Values: {
                            max: 1
                        }
                    } ],
                    single: {
                        role: "Values"
                    }
                } ],
                suppressDefaultTitle: !0,
                supportsSelection: !1
            }, visuals.cardProps = {
                categoryLabels: {
                    show: {
                        objectName: "categoryLabels",
                        propertyName: "show"
                    },
                    color: {
                        objectName: "categoryLabels",
                        propertyName: "color"
                    },
                    fontSize: {
                        objectName: "categoryLabels",
                        propertyName: "fontSize"
                    }
                },
                labels: {
                    color: {
                        objectName: "labels",
                        propertyName: "color"
                    },
                    labelPrecision: {
                        objectName: "labels",
                        propertyName: "labelPrecision"
                    },
                    labelDisplayUnits: {
                        objectName: "labels",
                        propertyName: "labelDisplayUnits"
                    },
                    fontSize: {
                        objectName: "labels",
                        propertyName: "fontSize"
                    }
                },
                wordWrap: {
                    show: {
                        objectName: "wordWrap",
                        propertyName: "show"
                    }
                }
            };
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            visuals.waterfallChartCapabilities = {
                dataRoles: [ {
                    name: "Category",
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Category"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_CategoryWaterfallDescription")
                }, {
                    name: "Y",
                    kind: powerbi.VisualDataRoleKind.Measure,
                    requiredTypes: [ {
                        numeric: !0
                    }, {
                        integer: !0
                    } ],
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Y")
                } ],
                objects: {
                    general: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                        properties: {
                            formatString: visuals.StandardObjectProperties.formatString
                        }
                    },
                    legend: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                        description: powerbi.data.createDisplayNameGetter("Visual_LegendDescription"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            position: visuals.StandardObjectProperties.legendPosition,
                            showTitle: visuals.StandardObjectProperties.showLegendTitle,
                            titleText: $.extend({}, visuals.StandardObjectProperties.legendTitle, {
                                suppressFormatPainterCopy: !0
                            }),
                            labelColor: visuals.StandardObjectProperties.labelColor,
                            fontSize: visuals.StandardObjectProperties.fontSize
                        }
                    },
                    labels: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                        description: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabelsDescription"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            color: visuals.StandardObjectProperties.dataColor,
                            labelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits,
                            labelPrecision: $.extend({}, visuals.StandardObjectProperties.labelPrecision, {
                                suppressFormatPainterCopy: !0
                            }),
                            fontSize: visuals.StandardObjectProperties.fontSize
                        }
                    },
                    sentimentColors: {
                        displayName: powerbi.data.createDisplayNameGetter("Waterfall_SentimentColors"),
                        properties: {
                            increaseFill: {
                                displayName: powerbi.data.createDisplayNameGetter("Waterfall_IncreaseLabel"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            },
                            decreaseFill: {
                                displayName: powerbi.data.createDisplayNameGetter("Waterfall_DecreaseLabel"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            },
                            totalFill: {
                                displayName: powerbi.data.createDisplayNameGetter("Waterfall_TotalLabel"),
                                type: {
                                    fill: {
                                        solid: {
                                            color: !0
                                        }
                                    }
                                }
                            }
                        }
                    },
                    categoryAxis: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_XAxis"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            showAxisTitle: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Axis_XTitleDescription"),
                                type: {
                                    bool: !0
                                }
                            },
                            axisStyle: visuals.StandardObjectProperties.axisStyle,
                            labelColor: visuals.StandardObjectProperties.labelColor
                        }
                    },
                    valueAxis: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            position: visuals.StandardObjectProperties.yAxisPosition,
                            start: visuals.StandardObjectProperties.axisStart,
                            end: visuals.StandardObjectProperties.axisEnd,
                            showAxisTitle: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Axis_YTitleDescription"),
                                type: {
                                    bool: !0
                                }
                            },
                            axisStyle: visuals.StandardObjectProperties.axisStyle,
                            labelColor: visuals.StandardObjectProperties.labelColor,
                            labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
                            labelPrecision: visuals.StandardObjectProperties.labelPrecision
                        }
                    },
                    y1AxisReferenceLine: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line"),
                        description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Description"),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            displayName: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_DisplayName"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_DisplayName_Description"),
                                type: {
                                    text: !0
                                }
                            },
                            value: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Value"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Value_Description"),
                                type: {
                                    numeric: !0
                                }
                            },
                            lineColor: visuals.StandardObjectProperties.lineColor,
                            transparency: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Transparency"),
                                description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Transparency_Description"),
                                type: {
                                    numeric: !0
                                }
                            },
                            style: visuals.StandardObjectProperties.referenceLineStyle,
                            position: visuals.StandardObjectProperties.referenceLinePosition,
                            dataLabelShow: visuals.StandardObjectProperties.dataLabelShow,
                            dataLabelColor: visuals.StandardObjectProperties.dataLabelColor,
                            dataLabelDecimalPoints: visuals.StandardObjectProperties.dataLabelDecimalPoints,
                            dataLabelHorizontalPosition: visuals.StandardObjectProperties.dataLabelHorizontalPosition,
                            dataLabelVerticalPosition: visuals.StandardObjectProperties.dataLabelVerticalPosition,
                            dataLabelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits
                        }
                    },
                    plotArea: {
                        displayName: powerbi.data.createDisplayNameGetter("Visual_Plot"),
                        properties: {
                            transparency: visuals.StandardObjectProperties.transparency,
                            image: visuals.StandardObjectProperties.image
                        }
                    }
                },
                dataViewMappings: [ {
                    conditions: [ {
                        Category: {
                            max: 1
                        },
                        Y: {
                            max: 1
                        }
                    } ],
                    categorical: {
                        categories: {
                            "for": {
                                "in": "Category"
                            },
                            dataReductionAlgorithm: {
                                top: {}
                            }
                        },
                        values: {
                            select: [ {
                                bind: {
                                    to: "Y"
                                }
                            } ]
                        }
                    }
                } ],
                sorting: {
                    "default": {}
                },
                drilldown: {
                    roles: [ "Category" ]
                }
            }, visuals.waterfallChartProps = {
                general: {
                    formatString: {
                        objectName: "general",
                        propertyName: "formatString"
                    }
                },
                sentimentColors: {
                    increaseFill: {
                        objectName: "sentimentColors",
                        propertyName: "increaseFill"
                    },
                    decreaseFill: {
                        objectName: "sentimentColors",
                        propertyName: "decreaseFill"
                    },
                    totalFill: {
                        objectName: "sentimentColors",
                        propertyName: "totalFill"
                    }
                },
                legend: {
                    labelColor: {
                        objectName: "legend",
                        propertyName: "labelColor"
                    }
                }
            };
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            visuals.KPIStatusWithHistoryCapabilities = {
                dataRoles: [ {
                    name: "Indicator",
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_KPI_Indicator"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_KPI_IndicatorDescription")
                }, {
                    name: "TrendLine",
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_KPI_TrendLine"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_KPI_Trendline_Description")
                }, {
                    name: "Goal",
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_KPI_Goal"),
                    description: powerbi.data.createDisplayNameGetter("Role_DisplayName_KPI_GoalDescription")
                } ],
                dataViewMappings: [ {
                    conditions: [ {
                        Indicator: {
                            max: 1
                        },
                        TrendLine: {
                            max: 1
                        },
                        Goal: {
                            max: 2
                        }
                    } ],
                    categorical: {
                        categories: {
                            "for": {
                                "in": "TrendLine"
                            },
                            dataReductionAlgorithm: {
                                top: {}
                            }
                        },
                        values: {
                            select: [ {
                                bind: {
                                    to: "Indicator"
                                }
                            }, {
                                bind: {
                                    to: "Goal"
                                }
                            } ]
                        }
                    }
                } ],
                objects: {
                    general: {
                        properties: {
                            formatString: visuals.StandardObjectProperties.formatString
                        }
                    },
                    indicator: {
                        displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_KPI_Indicator"),
                        description: powerbi.data.createDisplayNameGetter("Role_DisplayName_KPI_IndicatorDescription"),
                        properties: {
                            indicatorDisplayUnits: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                                description: powerbi.data.createDisplayNameGetter("Visual_DisplayUnitsDescription"),
                                type: {
                                    formatting: {
                                        labelDisplayUnits: !0
                                    }
                                }
                            },
                            indicatorPrecision: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                                description: powerbi.data.createDisplayNameGetter("Visual_PrecisionDescription"),
                                placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                                type: {
                                    numeric: !0
                                }
                            },
                            kpiFormat: {
                                displayName: powerbi.data.createDisplayNameGetter("TaskPane_Format"),
                                type: {
                                    text: !0
                                }
                            }
                        }
                    },
                    trendline: {
                        displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_KPI_TrendLine"),
                        description: powerbi.data.createDisplayNameGetter("Role_DisplayName_KPI_Trendline_Description"),
                        properties: {
                            show: visuals.StandardObjectProperties.show
                        }
                    },
                    goals: {
                        displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_KPI_Goals"),
                        description: powerbi.data.createDisplayNameGetter("Role_DisplayName_KPI_Goals"),
                        properties: {
                            showGoal: {
                                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_KPI_Show_Goal"),
                                type: {
                                    bool: !0
                                }
                            },
                            showDistance: {
                                displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_KPI_Show_Distance"),
                                type: {
                                    bool: !0
                                }
                            }
                        }
                    },
                    status: {
                        displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_KPI_Status"),
                        description: powerbi.data.createDisplayNameGetter("Role_DisplayName_KPI_Status"),
                        properties: {
                            direction: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_KPI_Direction"),
                                type: {
                                    enumeration: visuals.kpiDirection.type
                                }
                            }
                        }
                    }
                }
            };
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var capabilities;
            !function(capabilities) {
                capabilities.animatedNumber = powerbi.visuals.animatedNumberCapabilities, capabilities.areaChart = powerbi.visuals.lineChartCapabilities, 
                capabilities.barChart = powerbi.visuals.getColumnChartCapabilities(!0), capabilities.card = powerbi.visuals.cardCapabilities, 
                capabilities.multiRowCard = powerbi.visuals.multiRowCardCapabilities, capabilities.clusteredBarChart = powerbi.visuals.getColumnChartCapabilities(!0), 
                capabilities.clusteredColumnChart = powerbi.visuals.getColumnChartCapabilities(), 
                capabilities.columnChart = powerbi.visuals.getColumnChartCapabilities(), capabilities.comboChart = powerbi.visuals.comboChartCapabilities, 
                capabilities.dataDotChart = powerbi.visuals.dataDotChartCapabilities, capabilities.dataDotClusteredColumnComboChart = powerbi.visuals.comboChartCapabilities, 
                capabilities.dataDotStackedColumnComboChart = powerbi.visuals.comboChartCapabilities, 
                capabilities.donutChart = powerbi.visuals.donutChartCapabilities, capabilities.funnel = powerbi.visuals.funnelChartCapabilities, 
                capabilities.gauge = powerbi.visuals.gaugeCapabilities, capabilities.hundredPercentStackedBarChart = powerbi.visuals.getColumnChartCapabilities(!0), 
                capabilities.hundredPercentStackedColumnChart = powerbi.visuals.getColumnChartCapabilities(), 
                capabilities.image = powerbi.visuals.imageVisualCapabilities, capabilities.lineChart = powerbi.visuals.lineChartCapabilities, 
                capabilities.lineStackedColumnComboChart = powerbi.visuals.comboChartCapabilities, 
                capabilities.lineClusteredColumnComboChart = powerbi.visuals.comboChartCapabilities, 
                capabilities.map = powerbi.visuals.mapCapabilities, capabilities.filledMap = powerbi.visuals.filledMapCapabilities, 
                capabilities.treemap = powerbi.visuals.treemapCapabilities, capabilities.pieChart = powerbi.visuals.donutChartCapabilities, 
                capabilities.scatterChart = powerbi.visuals.scatterChartCapabilities, capabilities.table = powerbi.visuals.tableCapabilities, 
                capabilities.matrix = powerbi.visuals.matrixCapabilities, capabilities.slicer = powerbi.visuals.slicerCapabilities, 
                capabilities.textbox = powerbi.visuals.textboxCapabilities, capabilities.waterfallChart = powerbi.visuals.waterfallChartCapabilities, 
                capabilities.cheerMeter = powerbi.visuals.cheerMeterCapabilities, capabilities.scriptVisual = powerbi.visuals.scriptVisualCapabilities, 
                capabilities.kpi = powerbi.visuals.KPIStatusWithHistoryCapabilities;
            }(capabilities = visuals.capabilities || (visuals.capabilities = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var ColumnChartWebBehavior = function() {
                function ColumnChartWebBehavior() {}
                return ColumnChartWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                    this.options = options;
                    var eventGroup = options.eventGroup;
                    eventGroup.on("click", function() {
                        var d = ColumnChartWebBehavior.getDatumForLastInputEvent();
                        selectionHandler.handleSelection(d, d3.event.ctrlKey);
                    }), eventGroup.on("contextmenu", function() {
                        if (!d3.event.ctrlKey) {
                            d3.event.preventDefault();
                            var d = ColumnChartWebBehavior.getDatumForLastInputEvent(), position = visuals.InteractivityUtils.getPositionOfLastInputEvent();
                            selectionHandler.handleContextMenu(d, position);
                        }
                    });
                }, ColumnChartWebBehavior.prototype.renderSelection = function(hasSelection) {
                    var options = this.options;
                    options.bars.style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && options.hasHighlights);
                    });
                }, ColumnChartWebBehavior.getDatumForLastInputEvent = function() {
                    var target = d3.event.target;
                    return d3.select(target).datum();
                }, ColumnChartWebBehavior;
            }();
            visuals.ColumnChartWebBehavior = ColumnChartWebBehavior;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var DataDotChartWebBehavior = function() {
                function DataDotChartWebBehavior() {}
                return DataDotChartWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                    var dots = this.dots = options.dots, dotLabels = options.dotLabels;
                    visuals.InteractivityUtils.registerStandardInteractivityHandlers(dots, selectionHandler), 
                    dotLabels && visuals.InteractivityUtils.registerStandardInteractivityHandlers(dotLabels, selectionHandler);
                }, DataDotChartWebBehavior.prototype.renderSelection = function(hasSelection) {
                    this.dots.style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, !1);
                    });
                }, DataDotChartWebBehavior;
            }();
            visuals.DataDotChartWebBehavior = DataDotChartWebBehavior;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var DonutChartWebBehavior = function() {
                function DonutChartWebBehavior() {}
                return DonutChartWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                    var slices = this.slices = options.slices, highlightSlices = this.highlightSlices = options.highlightSlices, clearCatcher = options.clearCatcher;
                    this.hasHighlights = options.hasHighlights;
                    var clickHandler = function(d) {
                        selectionHandler.handleSelection(d.data, d3.event.ctrlKey);
                    }, contextMenuHandler = function(d) {
                        if (!d3.event.ctrlKey) {
                            var position = visuals.InteractivityUtils.getPositionOfLastInputEvent();
                            selectionHandler.handleContextMenu(d.data, position), d3.event.preventDefault();
                        }
                    };
                    slices.on("click", clickHandler), slices.on("contextmenu", contextMenuHandler), 
                    highlightSlices.on("click", clickHandler), highlightSlices.on("contextmenu", contextMenuHandler), 
                    clearCatcher.on("click", function() {
                        selectionHandler.handleClearSelection();
                    });
                }, DonutChartWebBehavior.prototype.renderSelection = function(hasSelection) {
                    var hasHighlights = this.hasHighlights;
                    this.slices.style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.data.selected, !1, hasSelection, hasHighlights && !d.data.selected);
                    }), this.highlightSlices.style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.data.selected, !0, !1, hasHighlights);
                    });
                }, DonutChartWebBehavior;
            }();
            visuals.DonutChartWebBehavior = DonutChartWebBehavior;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var FunnelWebBehavior = function() {
                function FunnelWebBehavior() {}
                return FunnelWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                    var bars = this.bars = options.bars, interactors = this.interactors = options.interactors, clearCatcher = options.clearCatcher;
                    this.hasHighlights = options.hasHighlights, visuals.InteractivityUtils.registerStandardInteractivityHandlers(bars, selectionHandler), 
                    visuals.InteractivityUtils.registerStandardInteractivityHandlers(interactors, selectionHandler), 
                    clearCatcher.on("click", function() {
                        selectionHandler.handleClearSelection();
                    });
                }, FunnelWebBehavior.prototype.renderSelection = function(hasSelection) {
                    var hasHighlights = this.hasHighlights;
                    this.bars.style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights);
                    });
                }, FunnelWebBehavior;
            }();
            visuals.FunnelWebBehavior = FunnelWebBehavior;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    window.jsCommon, window.powerbi, window.powerbitests, window.InJs, window.debug, 
    window.jasmine, window.Microsoft;
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var LineChartWebBehavior = function() {
                function LineChartWebBehavior() {}
                return LineChartWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                    var _this = this;
                    this.lines = options.lines;
                    var interactivityLines = options.interactivityLines, dots = this.dots = options.dots, areas = this.areas = options.areas, tooltipOverlay = this.tooltipOverlay = options.tooltipOverlay, getPointX = function(rootNode) {
                        return _this.getPointX(rootNode);
                    };
                    interactivityLines.on("click", function(d, index) {
                        var categoryIndex = options.getCategoryIndex(d, getPointX(this));
                        selectionHandler.handleSelection(d.data[categoryIndex], d3.event.ctrlKey);
                    }), visuals.InteractivityUtils.registerStandardInteractivityHandlers(dots, selectionHandler), 
                    areas && visuals.InteractivityUtils.registerStandardInteractivityHandlers(areas, selectionHandler), 
                    tooltipOverlay && (options.categoryIdentities ? tooltipOverlay.on("click", function() {
                        var categoryIndex = options.getCategoryIndex(void 0, getPointX(this));
                        selectionHandler.handleSelection({
                            selected: !1,
                            identity: void 0,
                            specificIdentity: options.categoryIdentities[categoryIndex]
                        }, d3.event.ctrlKey);
                    }) : tooltipOverlay.on("click", function() {
                        return selectionHandler.handleClearSelection();
                    }));
                }, LineChartWebBehavior.prototype.renderSelection = function(hasSelection) {
                    this.lines.style("stroke-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.selected, !1, hasSelection, !1);
                    }), this.dots.style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.selected, !1, hasSelection, !1);
                    }), this.areas && this.areas.style("fill-opacity", function(d) {
                        return hasSelection && !d.selected ? visuals.LineChart.DimmedAreaFillOpacity : visuals.LineChart.AreaFillOpacity;
                    });
                }, LineChartWebBehavior.prototype.getPointX = function(rootNode) {
                    for (var s, e = d3.event; s = e.sourceEvent; ) e = s;
                    var rect = rootNode.getBoundingClientRect();
                    return e.clientX - rect.left - rootNode.clientLeft;
                }, LineChartWebBehavior;
            }();
            visuals.LineChartWebBehavior = LineChartWebBehavior;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var MapBehavior = function() {
                function MapBehavior() {
                    this.mapPointerEventsDisabled = !1, this.mapPointerTimeoutSet = !1, this.viewChangedSinceLastClearMouseDown = !1, 
                    this.receivedZoomOrPanEvent = !1;
                }
                return MapBehavior.prototype.bindEvents = function(options, selectionHandler) {
                    var _this = this, bubbles = this.bubbles = options.bubbles, slices = this.slices = options.slices, shapes = this.shapes = options.shapes, clearCatcher = options.clearCatcher, clickHandler = function() {
                        var target = d3.event.target, d = d3.select(target).datum();
                        bubbles && bubbles.style("pointer-events", "all"), shapes && shapes.style("pointer-events", "all"), 
                        selectionHandler.handleSelection(d, d3.event.ctrlKey);
                    };
                    this.mapPointerEventsDisabled || (bubbles && bubbles.style("pointer-events", "all"), 
                    slices && slices.style("pointer-events", "all"), shapes && shapes.style("pointer-events", "all")), 
                    bubbles && (options.bubbleEventGroup.on("click", clickHandler), options.bubbleEventGroup.on("mousewheel", function() {
                        _this.mapPointerEventsDisabled || bubbles.style("pointer-events", "none"), _this.mapPointerEventsDisabled = !0, 
                        _this.mapPointerTimeoutSet || (_this.mapPointerTimeoutSet = !0, setTimeout(function() {
                            bubbles && bubbles.style("pointer-events", "all"), _this.mapPointerEventsDisabled = !1, 
                            _this.mapPointerTimeoutSet = !1;
                        }, 200));
                    }), visuals.InteractivityUtils.registerGroupContextMenuHandler(options.bubbleEventGroup, selectionHandler)), 
                    slices && (options.sliceEventGroup.on("click", function() {
                        slices.style("pointer-events", "all"), _this.mapPointerEventsDisabled = !1;
                        var target = d3.event.target, d = d3.select(target).datum();
                        selectionHandler.handleSelection(d.data, d3.event.ctrlKey);
                    }), options.sliceEventGroup.on("mousewheel", function() {
                        _this.mapPointerEventsDisabled || slices.style("pointer-events", "none"), _this.mapPointerEventsDisabled = !0, 
                        _this.mapPointerTimeoutSet || (_this.mapPointerTimeoutSet = !0, setTimeout(function() {
                            slices && slices.style("pointer-events", "all"), _this.mapPointerEventsDisabled = !1, 
                            _this.mapPointerTimeoutSet = !1;
                        }, 200));
                    }), options.sliceEventGroup.on("contextmenu", function() {
                        if (!d3.event.ctrlKey) {
                            d3.event.preventDefault();
                            var position = visuals.InteractivityUtils.getPositionOfLastInputEvent(), target = d3.event.target, d = d3.select(target).datum();
                            selectionHandler.handleContextMenu(d.data, position);
                        }
                    })), shapes && (options.shapeEventGroup.on("click", clickHandler), options.shapeEventGroup.on("mousewheel", function() {
                        _this.mapPointerEventsDisabled || shapes.style("pointer-events", "none"), _this.mapPointerEventsDisabled = !0, 
                        _this.mapPointerTimeoutSet || (_this.mapPointerTimeoutSet = !0, setTimeout(function() {
                            shapes && shapes.style("pointer-events", "all"), _this.mapPointerEventsDisabled = !1, 
                            _this.mapPointerTimeoutSet = !1;
                        }, 200));
                    }), visuals.InteractivityUtils.registerGroupContextMenuHandler(options.shapeEventGroup, selectionHandler)), 
                    clearCatcher.on("mouseup", function() {
                        _this.viewChangedSinceLastClearMouseDown || (selectionHandler.handleClearSelection(), 
                        _this.receivedZoomOrPanEvent = !0);
                    }), clearCatcher.on("mousedown", function() {
                        _this.viewChangedSinceLastClearMouseDown = !1;
                    }), clearCatcher.on("mousewheel", function() {
                        _this.receivedZoomOrPanEvent = !0;
                    });
                }, MapBehavior.prototype.renderSelection = function(hasSelection) {
                    this.bubbles && this.bubbles.style({
                        "fill-opacity": function(d) {
                            return visuals.ColumnUtil.getFillOpacity(d.selected, !1, hasSelection, !1);
                        },
                        "stroke-opacity": function(d) {
                            return visuals.ColumnUtil.getFillOpacity(d.selected, !1, hasSelection, !1);
                        }
                    }), this.slices && this.slices.style({
                        "fill-opacity": function(d) {
                            return visuals.ColumnUtil.getFillOpacity(d.data.selected, !1, hasSelection, !1);
                        },
                        "stroke-opacity": function(d) {
                            return visuals.ColumnUtil.getFillOpacity(d.data.selected, !1, hasSelection, !1);
                        }
                    }), this.shapes && this.shapes.style({
                        "fill-opacity": function(d) {
                            return visuals.ColumnUtil.getFillOpacity(d.selected, !1, hasSelection, !1);
                        },
                        "stroke-opacity": function(d) {
                            return visuals.ColumnUtil.getFillOpacity(d.selected, !1, hasSelection, !1);
                        }
                    });
                }, MapBehavior.prototype.viewChanged = function() {
                    this.viewChangedSinceLastClearMouseDown = !0;
                }, MapBehavior.prototype.resetZoomPan = function() {
                    this.receivedZoomOrPanEvent = !1;
                }, MapBehavior.prototype.hasReceivedZoomOrPanEvent = function() {
                    return this.receivedZoomOrPanEvent;
                }, MapBehavior;
            }();
            visuals.MapBehavior = MapBehavior;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, ScatterChartWebBehavior = function() {
                function ScatterChartWebBehavior() {}
                return ScatterChartWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                    var bubbles = this.bubbles = options.dataPointsSelection, data = options.data, eventGroup = options.eventGroup;
                    !this.playOptions || !this.playOptions.traceLineRenderer || options.playOptions && options.playOptions.traceLineRenderer || this.playOptions.traceLineRenderer.remove(), 
                    this.playOptions = options.playOptions, this.shouldEnableFill = (!data.sizeRange || !data.sizeRange.min) && data.fillPoint, 
                    this.colorBorder = data.colorBorder, eventGroup ? visuals.InteractivityUtils.registerGroupInteractivityHandlers(eventGroup, selectionHandler) : visuals.InteractivityUtils.registerStandardInteractivityHandlers(bubbles, selectionHandler);
                }, ScatterChartWebBehavior.prototype.renderSelection = function(hasSelection) {
                    var shouldEnableFill = this.shouldEnableFill, colorBorder = this.colorBorder;
                    if (this.bubbles.style("fill-opacity", function(d) {
                        return visuals.ScatterChart.getMarkerFillOpacity(null != d.size, shouldEnableFill, hasSelection, d.selected);
                    }), this.bubbles.style("stroke-opacity", function(d) {
                        return visuals.ScatterChart.getMarkerStrokeOpacity(null != d.size, colorBorder, hasSelection, d.selected);
                    }), this.playOptions && this.bubbles) {
                        var selectedPoints = this.bubbles.filter(function(d) {
                            return d.selected;
                        }).data(), traceLineRenderer = this.playOptions.traceLineRenderer;
                        selectedPoints && selectedPoints.length > 0 && null != traceLineRenderer ? traceLineRenderer.render(selectedPoints, !0) : traceLineRenderer.remove();
                    }
                }, ScatterChartWebBehavior;
            }();
            visuals.ScatterChartWebBehavior = ScatterChartWebBehavior;
            var ScatterChartMobileBehavior = function() {
                function ScatterChartMobileBehavior() {}
                return ScatterChartMobileBehavior.prototype.bindEvents = function(options, selectionHandler) {
                    this.setOptions(options), options.visualInitOptions && options.visualInitOptions.interactivity.isInteractiveLegend && (this.makeDataPointsSelectable(options.dataPointsSelection), 
                    this.makeRootSelectable(options.root), this.makeDragable(options.root), this.disableDefaultTouchInteractions(options.root), 
                    this.selectRoot());
                }, ScatterChartMobileBehavior.prototype.renderSelection = function(HasSelection) {}, 
                ScatterChartMobileBehavior.prototype.setSelectionHandler = function(selectionHandler) {}, 
                ScatterChartMobileBehavior.prototype.makeDataPointsSelectable = function() {
                    for (var _this = this, selection = [], _i = 0; _i < arguments.length; _i++) selection[_i - 0] = arguments[_i];
                    for (var i = 0, len = selection.length; len > i; i++) {
                        var sel = selection[i];
                        sel.on("click", function(d, i) {
                            _this.select(i);
                        });
                    }
                }, ScatterChartMobileBehavior.prototype.makeRootSelectable = function(selection) {
                    var _this = this;
                    selection.on("click", function(d, i) {
                        _this.selectRoot();
                    });
                }, ScatterChartMobileBehavior.prototype.makeDragable = function() {
                    for (var _this = this, selection = [], _i = 0; _i < arguments.length; _i++) selection[_i - 0] = arguments[_i];
                    for (var i = 0, len = selection.length; len > i; i++) {
                        var sel = selection[i], drag = d3.behavior.drag().on("drag", function(d) {
                            _this.drag(0);
                        }).on("dragend", function(d) {
                            _this.drag(1);
                        });
                        sel.call(drag);
                    }
                }, ScatterChartMobileBehavior.prototype.disableDefaultTouchInteractions = function(selection) {
                    selection.style("touch-action", "none");
                }, ScatterChartMobileBehavior.prototype.setOptions = function(options) {
                    this.data = options.data, this.mainGraphicsContext = options.plotContext, this.xAxisProperties = options.xAxisProperties, 
                    this.yAxisProperties = options.yAxisProperties, this.host = options.host;
                }, ScatterChartMobileBehavior.prototype.select = function(index) {
                    this.selectDotByIndex(index);
                }, ScatterChartMobileBehavior.prototype.selectRoot = function() {
                    var marker = jsCommon.PerformanceUtil.create("selectRoot");
                    this.onClick(), marker.end();
                }, ScatterChartMobileBehavior.prototype.drag = function(t) {
                    switch (t) {
                      case 0:
                        this.onDrag();
                        break;

                      case 1:
                        this.onClick();
                    }
                }, ScatterChartMobileBehavior.prototype.onDrag = function() {
                    var xy = this.getMouseCoordinates();
                    this.moveCrosshairToXY(xy.x, xy.y);
                    var selectedIndex = this.findClosestDotIndex(xy.x, xy.y);
                    this.selectDot(selectedIndex), this.updateLegend(selectedIndex);
                }, ScatterChartMobileBehavior.prototype.onClick = function() {
                    var xy = this.getMouseCoordinates(), selectedIndex = this.findClosestDotIndex(xy.x, xy.y);
                    -1 !== selectedIndex && this.selectDotByIndex(selectedIndex);
                }, ScatterChartMobileBehavior.prototype.getMouseCoordinates = function() {
                    var mainGfxContext = this.mainGraphicsContext, x = 0, y = parseInt(mainGfxContext.attr("height"), 10);
                    y = y || 0;
                    try {
                        var mouse = d3.mouse(mainGfxContext.node());
                        x = mouse[0], y = mouse[1];
                    } catch (e) {}
                    return {
                        x: x,
                        y: y
                    };
                }, ScatterChartMobileBehavior.prototype.selectDotByIndex = function(index) {
                    this.selectDot(index), this.moveCrosshairToIndexDot(index), this.updateLegend(index);
                }, ScatterChartMobileBehavior.prototype.selectDot = function(dotIndex) {
                    var _this = this, root = this.mainGraphicsContext;
                    root.selectAll(ScatterChartMobileBehavior.ScatterChartCircleTagName + ScatterChartMobileBehavior.DotClassSelector).classed({
                        selected: !1,
                        notSelected: !0
                    }), root.selectAll(ScatterChartMobileBehavior.ScatterChartCircleTagName + ScatterChartMobileBehavior.DotClassSelector).filter(function(d, i) {
                        var dataPoints = _this.data.dataPoints, currentPoint = dataPoints[dotIndex];
                        return d.x === currentPoint.x && d.y === currentPoint.y;
                    }).classed({
                        selected: !0,
                        notSelected: !1
                    });
                }, ScatterChartMobileBehavior.prototype.moveCrosshairToIndexDot = function(index) {
                    var dataPoints = this.data.dataPoints, root = this.mainGraphicsContext, x = this.xAxisProperties.scale(dataPoints[index].x), y = this.yAxisProperties.scale(dataPoints[index].y);
                    if (null == this.crosshair) {
                        var width = +root.attr("width"), height = +root.attr("height");
                        this.crosshair = this.drawCrosshair(root, x, y, width, height), this.crosshairHorizontal = this.crosshair.select(ScatterChartMobileBehavior.Horizontal.selector), 
                        this.crosshairVertical = this.crosshair.select(ScatterChartMobileBehavior.Vertical.selector);
                    } else this.moveCrosshairToXY(x, y);
                }, ScatterChartMobileBehavior.prototype.moveCrosshairToXY = function(x, y) {
                    this.crosshairHorizontal.attr({
                        y1: y,
                        y2: y
                    }), this.crosshairVertical.attr({
                        x1: x,
                        x2: x
                    });
                }, ScatterChartMobileBehavior.prototype.drawCrosshair = function(addTo, x, y, width, height) {
                    var crosshair = addTo.append("g");
                    return crosshair.classed(ScatterChartMobileBehavior.CrosshairClassName, !0), crosshair.append("line").classed(ScatterChartMobileBehavior.Horizontal["class"], !0).attr({
                        x1: 0,
                        x2: width,
                        y1: y,
                        y2: y
                    }), crosshair.append("line").classed(ScatterChartMobileBehavior.Vertical["class"], !0).attr({
                        x1: x,
                        x2: x,
                        y1: height,
                        y2: 0
                    }), crosshair;
                }, ScatterChartMobileBehavior.prototype.findClosestDotIndex = function(x, y) {
                    var selectedIndex = -1, minDistance = Number.MAX_VALUE, dataPoints = this.data.dataPoints, xAxisPropertiesScale = this.xAxisProperties.scale, yAxisPropertiesScale = this.yAxisProperties.scale;
                    for (var i in dataPoints) {
                        var currentPoint = dataPoints[i], circleX = xAxisPropertiesScale(currentPoint.x), circleY = yAxisPropertiesScale(currentPoint.y), horizontalDistance = circleX - x, verticalDistance = circleY - y, distanceSqrd = horizontalDistance * horizontalDistance + verticalDistance * verticalDistance;
                        minDistance === Number.MAX_VALUE ? (selectedIndex = i, minDistance = distanceSqrd) : minDistance && minDistance > distanceSqrd && (selectedIndex = i, 
                        minDistance = distanceSqrd);
                    }
                    return selectedIndex;
                }, ScatterChartMobileBehavior.prototype.updateLegend = function(dotIndex) {
                    if (null == this.lastDotIndex || this.lastDotIndex !== dotIndex) {
                        var legendItems = this.createLegendDataPoints(dotIndex);
                        this.host.updateLegend(legendItems), this.lastDotIndex = dotIndex;
                    }
                }, ScatterChartMobileBehavior.prototype.createLegendDataPoints = function(dotIndex) {
                    var formatStringProp = visuals.scatterChartProps.general.formatString, legendItems = [], data = this.data, point = data.dataPoints[dotIndex], blank = visuals.valueFormatter.format(null), title = blank, legendData = data.legendData, legendDataPoints = legendData.dataPoints, category = point.formattedCategory.getValue();
                    return category !== blank ? (title = category, null != point && null != point.radius && null != point.radius.sizeMeasure && (title += "; " + visuals.valueFormatter.format(point.radius.sizeMeasure.source.groupName))) : null != point.radius.sizeMeasure ? title = visuals.valueFormatter.format(point.radius.sizeMeasure.source.groupName) : legendDataPoints.length >= dotIndex && legendDataPoints[dotIndex].label !== blank && (title = legendDataPoints[dotIndex].label), 
                    null != data.xCol && legendItems.push({
                        category: title,
                        color: point.fill,
                        identity: visuals.SelectionIdBuilder.builder().withMeasure(data.xCol.queryName).createSelectionId(),
                        selected: point.selected,
                        icon: visuals.LegendIcon.Box,
                        label: visuals.valueFormatter.format(this.data.axesLabels.x),
                        measure: visuals.valueFormatter.format(point.x, visuals.valueFormatter.getFormatString(data.xCol, formatStringProp)),
                        iconOnlyOnLabel: !0
                    }), null != data.yCol && legendItems.push({
                        category: title,
                        color: point.fill,
                        identity: visuals.SelectionIdBuilder.builder().withMeasure(data.yCol.queryName).createSelectionId(),
                        selected: point.selected,
                        icon: visuals.LegendIcon.Box,
                        label: visuals.valueFormatter.format(data.axesLabels.y),
                        measure: visuals.valueFormatter.format(point.y, visuals.valueFormatter.getFormatString(data.yCol, formatStringProp)),
                        iconOnlyOnLabel: !0
                    }), null != data.size && legendItems.push({
                        category: title,
                        color: point.fill,
                        identity: visuals.SelectionIdBuilder.builder().withMeasure(data.size.queryName).createSelectionId(),
                        selected: point.selected,
                        icon: visuals.LegendIcon.Box,
                        label: visuals.valueFormatter.format(data.size.displayName),
                        measure: visuals.valueFormatter.format(point.radius.sizeMeasure.values[point.radius.index], visuals.valueFormatter.getFormatString(data.size, formatStringProp)),
                        iconOnlyOnLabel: !0
                    }), {
                        dataPoints: legendItems
                    };
                }, ScatterChartMobileBehavior.CrosshairClassName = "crosshair", ScatterChartMobileBehavior.ScatterChartCircleTagName = "circle", 
                ScatterChartMobileBehavior.DotClassName = "dot", ScatterChartMobileBehavior.DotClassSelector = "." + ScatterChartMobileBehavior.DotClassName, 
                ScatterChartMobileBehavior.Horizontal = createClassAndSelector("horizontal"), ScatterChartMobileBehavior.Vertical = createClassAndSelector("vertical"), 
                ScatterChartMobileBehavior;
            }();
            visuals.ScatterChartMobileBehavior = ScatterChartMobileBehavior;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var HorizontalSlicerWebBehavior = function() {
                function HorizontalSlicerWebBehavior() {}
                return HorizontalSlicerWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                    this.itemLabels = options.itemLabels, this.dataPoints = options.dataPoints, this.interactivityService = options.interactivityService, 
                    this.slicerSettings = options.settings, visuals.SlicerWebBehavior.bindSlicerEvents(options, this.itemLabels, selectionHandler, this.slicerSettings, this.interactivityService);
                }, HorizontalSlicerWebBehavior.prototype.renderSelection = function(hasSelection) {
                    visuals.SlicerWebBehavior.setSelectionOnSlicerItems(this.itemLabels, this.itemLabels, hasSelection, this.interactivityService, this.slicerSettings);
                }, HorizontalSlicerWebBehavior;
            }();
            visuals.HorizontalSlicerWebBehavior = HorizontalSlicerWebBehavior;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var VerticalSlicerWebBehavior = function() {
                function VerticalSlicerWebBehavior() {}
                return VerticalSlicerWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                    var slicers = options.itemContainers;
                    this.itemLabels = options.itemLabels, this.itemInputs = options.itemInputs, this.dataPoints = options.dataPoints, 
                    this.interactivityService = options.interactivityService, this.settings = options.settings, 
                    visuals.SlicerWebBehavior.bindSlicerEvents(options, slicers, selectionHandler, this.settings, this.interactivityService);
                }, VerticalSlicerWebBehavior.prototype.renderSelection = function(hasSelection) {
                    visuals.SlicerWebBehavior.setSelectionOnSlicerItems(this.itemInputs, this.itemLabels, hasSelection, this.interactivityService, this.settings);
                }, VerticalSlicerWebBehavior;
            }();
            visuals.VerticalSlicerWebBehavior = VerticalSlicerWebBehavior;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var DOMConstants = jsCommon.DOMConstants, KeyUtils = jsCommon.KeyUtils, SlicerWebBehavior = function() {
                function SlicerWebBehavior() {}
                return SlicerWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                    this.behavior = this.createWebBehavior(options), this.behavior.bindEvents(options.behaviorOptions, selectionHandler);
                }, SlicerWebBehavior.prototype.renderSelection = function(hasSelection) {
                    this.behavior.renderSelection(hasSelection);
                }, SlicerWebBehavior.bindSlicerEvents = function(behaviorOptions, slicers, selectionHandler, slicerSettings, interactivityService) {
                    SlicerWebBehavior.bindSlicerItemSelectionEvent(slicers, selectionHandler, slicerSettings, interactivityService), 
                    SlicerWebBehavior.bindSlicerClearEvent(behaviorOptions.clear, selectionHandler), 
                    behaviorOptions.searchInput && SlicerWebBehavior.bindSlicerSearchEvent(behaviorOptions.searchInput, selectionHandler, behaviorOptions.slicerValueHandler), 
                    SlicerWebBehavior.styleSlicerContainer(behaviorOptions.slicerContainer, interactivityService);
                }, SlicerWebBehavior.setSelectionOnSlicerItems = function(selectableItems, itemLabel, hasSelection, interactivityService, slicerSettings) {
                    if (hasSelection || interactivityService.isSelectionModeInverted()) SlicerWebBehavior.styleSlicerItems(selectableItems, hasSelection, interactivityService.isSelectionModeInverted()); else {
                        selectableItems.filter(".selected").classed("selected", !1), selectableItems.filter(".partiallySelected").classed("partiallySelected", !1);
                        var input = selectableItems.selectAll("input");
                        input && input.property("checked", !1), itemLabel.style("color", slicerSettings.slicerText.color);
                    }
                }, SlicerWebBehavior.styleSlicerItems = function(slicerItems, hasSelection, isSelectionInverted) {
                    slicerItems.each(function(d) {
                        var slicerItem = this, shouldCheck = !1;
                        d.isSelectAllDataPoint ? hasSelection ? (slicerItem.classList.add("partiallySelected"), 
                        shouldCheck = !1) : (slicerItem.classList.remove("partiallySelected"), shouldCheck = isSelectionInverted) : shouldCheck = jsCommon.LogicExtensions.XOR(d.selected, isSelectionInverted), 
                        shouldCheck ? slicerItem.classList.add("selected") : slicerItem.classList.remove("selected");
                        var input = slicerItem.getElementsByTagName("input")[0];
                        input && (input.checked = shouldCheck);
                    });
                }, SlicerWebBehavior.bindSlicerItemSelectionEvent = function(slicers, selectionHandler, slicerSettings, interactivityService) {
                    slicers.on("click", function(d) {
                        d3.event.preventDefault(), d.isSelectAllDataPoint ? selectionHandler.toggleSelectionModeInversion() : selectionHandler.handleSelection(d, SlicerWebBehavior.isMultiSelect(d3.event, slicerSettings, interactivityService)), 
                        selectionHandler.persistSelectionFilter(visuals.slicerProps.filterPropertyIdentifier);
                    });
                }, SlicerWebBehavior.bindSlicerClearEvent = function(slicerClear, selectionHandler) {
                    slicerClear && slicerClear.on("click", function() {
                        selectionHandler.handleClearSelection(), selectionHandler.persistSelectionFilter(visuals.slicerProps.filterPropertyIdentifier);
                    });
                }, SlicerWebBehavior.bindSlicerSearchEvent = function(slicerSearch, selectionHandler, slicerValueHandler) {
                    slicerSearch.empty() || slicerSearch.on(DOMConstants.keyDownEventName, function() {
                        d3.event.ctrlKey && KeyUtils.isCtrlDefaultKey(d3.event.keyCode) ? d3.event.stopPropagation() : KeyUtils.isArrowKey(d3.event.keyCode) || d3.event.keyCode === DOMConstants.deleteKeyCode ? d3.event.stopPropagation() : d3.event.keyCode === DOMConstants.escKeyCode ? (selectionHandler.persistSelfFilter(visuals.slicerProps.selfFilterPropertyIdentifier, null), 
                        d3.event.stopPropagation()) : d3.event.keyCode === DOMConstants.enterKeyCode && (SlicerWebBehavior.startSearch(slicerSearch, selectionHandler, slicerValueHandler), 
                        d3.event.stopPropagation());
                    }).on(DOMConstants.keyUpEventName, _.debounce(function() {
                        SlicerWebBehavior.startSearch(slicerSearch, selectionHandler, slicerValueHandler);
                    }, SlicerWebBehavior.searchInputTimeoutDuration));
                }, SlicerWebBehavior.startSearch = function(slicerSearch, selectionHandler, slicerValueHandler) {
                    var element = slicerSearch.node(), searchKey = element && element.value;
                    if (searchKey = _.trim(searchKey), _.isEmpty(searchKey)) return void selectionHandler.persistSelfFilter(visuals.slicerProps.selfFilterPropertyIdentifier, null);
                    var updatedFilter = slicerValueHandler.getUpdatedSelfFilter(searchKey);
                    updatedFilter && selectionHandler.persistSelfFilter(visuals.slicerProps.selfFilterPropertyIdentifier, updatedFilter);
                }, SlicerWebBehavior.styleSlicerContainer = function(slicerContainer, interactivityService) {
                    var hasSelection = interactivityService.hasSelection() && void 0 === interactivityService.isDefaultValueEnabled() || interactivityService.isDefaultValueEnabled() === !1;
                    slicerContainer.classed("hasSelection", hasSelection);
                }, SlicerWebBehavior.isMultiSelect = function(event, settings, interactivityService) {
                    return interactivityService.isSelectionModeInverted() || !settings.selection.singleSelect || event.ctrlKey;
                }, SlicerWebBehavior.prototype.createWebBehavior = function(options) {
                    var behavior, orientation = options.orientation;
                    switch (orientation) {
                      case 1:
                        behavior = new visuals.HorizontalSlicerWebBehavior();
                        break;

                      case 0:
                      default:
                        behavior = new visuals.VerticalSlicerWebBehavior();
                    }
                    return behavior;
                }, SlicerWebBehavior.searchInputTimeoutDuration = 500, SlicerWebBehavior;
            }();
            visuals.SlicerWebBehavior = SlicerWebBehavior;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var LegendBehavior = function() {
                function LegendBehavior() {}
                return LegendBehavior.prototype.bindEvents = function(options, selectionHandler) {
                    var legendItems = options.legendItems;
                    this.legendIcons = options.legendIcons;
                    var clearCatcher = options.clearCatcher;
                    visuals.InteractivityUtils.registerStandardSelectionHandler(legendItems, selectionHandler), 
                    clearCatcher.on("click", function() {
                        selectionHandler.handleClearSelection();
                    });
                }, LegendBehavior.prototype.renderSelection = function(hasSelection) {
                    hasSelection ? this.legendIcons.style({
                        fill: function(d) {
                            return d.selected ? d.color : LegendBehavior.dimmedLegendColor;
                        }
                    }) : this.legendIcons.style({
                        fill: function(d) {
                            return d.color;
                        }
                    });
                }, LegendBehavior.dimmedLegendColor = "#A6A6A6", LegendBehavior;
            }();
            visuals.LegendBehavior = LegendBehavior;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var TreemapWebBehavior = function() {
                function TreemapWebBehavior() {}
                return TreemapWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                    var shapes = this.shapes = options.shapes, highlightShapes = this.highlightShapes = options.highlightShapes, majorLabels = options.majorLabels, minorLabels = options.minorLabels;
                    this.hasHighlights = options.hasHighlights, visuals.InteractivityUtils.registerStandardInteractivityHandlers(shapes, selectionHandler), 
                    visuals.InteractivityUtils.registerStandardInteractivityHandlers(highlightShapes, selectionHandler), 
                    majorLabels && visuals.InteractivityUtils.registerStandardInteractivityHandlers(majorLabels, selectionHandler), 
                    minorLabels && visuals.InteractivityUtils.registerStandardInteractivityHandlers(minorLabels, selectionHandler);
                }, TreemapWebBehavior.prototype.renderSelection = function(hasSelection) {
                    var hasHighlights = this.hasHighlights;
                    this.shapes.style("fill", function(d) {
                        return visuals.Treemap.getFill(d, !1);
                    }).style("fill-opacity", function(d) {
                        return visuals.Treemap.getFillOpacity(d, hasSelection, !d.selected && hasHighlights, !1);
                    }), this.highlightShapes.style("fill", function(d) {
                        return visuals.Treemap.getFill(d, !0);
                    }).style("fill-opacity", function(d) {
                        return visuals.Treemap.getFillOpacity(d, hasSelection, !d.selected && hasHighlights, !0);
                    });
                }, TreemapWebBehavior;
            }();
            visuals.TreemapWebBehavior = TreemapWebBehavior;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var WaterfallChartWebBehavior = function() {
                function WaterfallChartWebBehavior() {}
                return WaterfallChartWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                    var bars = this.bars = options.bars;
                    bars.on("click", function(d) {
                        d.isTotal || selectionHandler.handleSelection(d, d3.event.ctrlKey);
                    }), bars.on("contextmenu", function(d) {
                        if (!d3.event.ctrlKey && (d3.event.preventDefault(), !d.isTotal)) {
                            var position = visuals.InteractivityUtils.getPositionOfLastInputEvent();
                            selectionHandler.handleContextMenu(d, position);
                        }
                    });
                }, WaterfallChartWebBehavior.prototype.renderSelection = function(hasSelection) {
                    this.bars.style("fill-opacity", function(d) {
                        return d.isTotal ? visuals.ColumnUtil.DefaultOpacity : visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, !1);
                    });
                }, WaterfallChartWebBehavior;
            }();
            visuals.WaterfallChartWebBehavior = WaterfallChartWebBehavior;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var LabelsBehavior = function() {
                function LabelsBehavior() {}
                return LabelsBehavior.prototype.bindEvents = function(options, selectionHandler) {
                    this.labelItems = options.labelItems, visuals.InteractivityUtils.registerStandardSelectionHandler(this.labelItems, selectionHandler);
                }, LabelsBehavior.prototype.renderSelection = function(hasSelection) {
                    hasSelection ? this.labelItems.style({
                        opacity: function(d) {
                            return d.selected ? LabelsBehavior.DefaultLabelOpacity : LabelsBehavior.DimmedLabelOpacity;
                        }
                    }) : this.labelItems.style({
                        opacity: LabelsBehavior.DefaultLabelOpacity
                    });
                }, LabelsBehavior.DefaultLabelOpacity = 1, LabelsBehavior.DimmedLabelOpacity = .6, 
                LabelsBehavior;
            }();
            visuals.LabelsBehavior = LabelsBehavior;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var CartesianChartBehavior = function() {
                function CartesianChartBehavior(behaviors) {
                    this.behaviors = behaviors;
                }
                return CartesianChartBehavior.prototype.bindEvents = function(options, selectionHandler) {
                    for (var behaviors = this.behaviors, i = 0, ilen = behaviors.length; ilen > i; i++) behaviors[i].bindEvents(options.layerOptions[i], selectionHandler);
                    options.clearCatcher.on("click", function() {
                        selectionHandler.handleClearSelection();
                    });
                }, CartesianChartBehavior.prototype.renderSelection = function(hasSelection) {
                    for (var _i = 0, _a = this.behaviors; _i < _a.length; _i++) {
                        var behavior = _a[_i];
                        behavior.renderSelection(hasSelection);
                    }
                }, CartesianChartBehavior;
            }();
            visuals.CartesianChartBehavior = CartesianChartBehavior;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    window.jsCommon, window.powerbi, window.powerbitests, window.InJs, window.debug, 
    window.jasmine, window.Microsoft;
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            visuals.emptyDomain = [ 0, 0 ];
            var AxisHelper;
            !function(AxisHelper) {
                function getRecommendedNumberOfTicksForXAxis(availableWidth) {
                    return 300 > availableWidth ? 3 : 500 > availableWidth ? 5 : 8;
                }
                function getRecommendedNumberOfTicksForYAxis(availableWidth) {
                    return 150 > availableWidth ? 3 : 300 > availableWidth ? 5 : 8;
                }
                function getBestNumberOfTicks(min, max, valuesMetadata, maxTickCount, isDateTime) {
                    return isNaN(min) || isNaN(max) ? DefaultBestTickCount : 1 >= maxTickCount || 1 >= max && min >= -1 ? maxTickCount : min === max ? isDateTime ? 1 : DefaultBestTickCount : hasNonIntegerData(valuesMetadata) ? maxTickCount : Math.min(max - min + 1, maxTickCount);
                }
                function hasNonIntegerData(valuesMetadata) {
                    for (var i = 0, len = valuesMetadata.length; len > i; i++) {
                        var currentMetadata = valuesMetadata[i];
                        if (currentMetadata && currentMetadata.type && !currentMetadata.type.integer) return !0;
                    }
                    return !1;
                }
                function getRecommendedTickValues(maxTicks, scale, axisType, isScalar, minTickInterval) {
                    return !isScalar || isOrdinalScale(scale) ? getRecommendedTickValuesForAnOrdinalRange(maxTicks, scale.domain()) : isDateTime(axisType) ? getRecommendedTickValuesForADateTimeRange(maxTicks, scale.domain()) : getRecommendedTickValuesForAQuantitativeRange(maxTicks, scale, minTickInterval);
                }
                function getRecommendedTickValuesForAnOrdinalRange(maxTicks, labels) {
                    var tickLabels = [];
                    if (0 >= maxTicks) return tickLabels;
                    var len = labels.length;
                    if (maxTicks > len) return labels;
                    for (var i = 0, step = Math.ceil(len / maxTicks); len > i; i += step) tickLabels.push(labels[i]);
                    return tickLabels;
                }
                function getRecommendedTickValuesForAQuantitativeRange(maxTicks, scale, minInterval) {
                    var tickLabels = [];
                    if (0 === maxTicks) return tickLabels;
                    var quantitiveScale = scale;
                    if (quantitiveScale.ticks) {
                        if (tickLabels = quantitiveScale.ticks(maxTicks), tickLabels.length > maxTicks && maxTicks > 1 && (tickLabels = quantitiveScale.ticks(maxTicks - 1)), 
                        tickLabels.length < MinTickCount && (tickLabels = quantitiveScale.ticks(maxTicks + 1)), 
                        tickLabels = createTrueZeroTickLabel(tickLabels), minInterval && tickLabels.length > 1) {
                            for (var tickInterval = tickLabels[1] - tickLabels[0]; tickInterval > 0 && minInterval > tickInterval; ) {
                                for (var i = 1; i < tickLabels.length; i++) tickLabels.splice(i, 1);
                                tickInterval = 2 * tickInterval;
                            }
                            1 === tickLabels.length && tickLabels.push(tickLabels[0] + minInterval);
                        }
                        return tickLabels;
                    }
                    return tickLabels;
                }
                function createTrueZeroTickLabel(ticks, epsilon) {
                    if (void 0 === epsilon && (epsilon = 1e-5), !ticks || ticks.length < 2) return ticks;
                    var closeZero = epsilon * Math.abs(ticks[1] - ticks[0]);
                    return ticks.map(function(tick) {
                        return Math.abs(tick) <= closeZero ? 0 : tick;
                    });
                }
                function getRecommendedTickValuesForADateTimeRange(maxTicks, dataDomain) {
                    var tickLabels = [];
                    if (0 === dataDomain[0] && 0 === dataDomain[1]) return [];
                    var dateTimeTickLabels = powerbi.DateTimeSequence.calculate(new Date(dataDomain[0]), new Date(dataDomain[1]), maxTicks).sequence;
                    return tickLabels = dateTimeTickLabels.map(function(d) {
                        return d.getTime();
                    }), tickLabels = ensureValuesInRange(tickLabels, dataDomain[0], dataDomain[1]);
                }
                function normalizeLinearDomain(domain) {
                    return isNaN(domain.min) || isNaN(domain.max) ? (domain.min = visuals.emptyDomain[0], 
                    domain.max = visuals.emptyDomain[1]) : domain.min === domain.max ? (domain.min = domain.min < 0 ? 1.2 * domain.min : .8 * domain.min, 
                    domain.max = domain.max < 0 ? .8 * domain.max : 1.2 * domain.max) : Math.abs(domain.min) < 1e-4 && domain.min / (domain.max - domain.min) < 1e-4 && (domain.min = 0), 
                    domain;
                }
                function getMargin(availableWidth, availableHeight, xMargin, yMargin) {
                    return 0 === getRecommendedNumberOfTicksForXAxis(availableWidth - xMargin) || 0 === getRecommendedNumberOfTicksForYAxis(availableHeight - yMargin) ? {
                        top: 0,
                        right: xMargin,
                        bottom: yMargin,
                        left: 0
                    } : {
                        top: 20,
                        right: 30,
                        bottom: 40,
                        left: 30
                    };
                }
                function getTickLabelMargins(viewport, yMarginLimit, textWidthMeasurer, textHeightMeasurer, axes, bottomMarginLimit, properties, scrollbarVisible, showOnRight, renderXAxis, renderY1Axis, renderY2Axis) {
                    var xAxisProperties = axes.x, y1AxisProperties = axes.y1, y2AxisProperties = axes.y2, xLabels = xAxisProperties.values, y1Labels = y1AxisProperties.values, leftOverflow = 0, rightOverflow = 0, maxWidthY1 = 0, maxWidthY2 = 0, xMax = 0, ordinalLabelOffset = xAxisProperties.categoryThickness ? xAxisProperties.categoryThickness / 2 : 0, scaleIsOrdinal = isOrdinalScale(xAxisProperties.scale), xLabelOuterPadding = 0;
                    if (void 0 !== xAxisProperties.outerPadding ? xLabelOuterPadding = xAxisProperties.outerPadding : void 0 !== xAxisProperties.xLabelMaxWidth && (xLabelOuterPadding = Math.max(0, (viewport.width - xAxisProperties.xLabelMaxWidth * xLabels.length) / 2)), 
                    0 !== getRecommendedNumberOfTicksForXAxis(viewport.width) || 0 !== getRecommendedNumberOfTicksForYAxis(viewport.height)) {
                        var rotation = void 0;
                        if (rotation = scrollbarVisible ? LabelLayoutStrategy.DefaultRotationWithScrollbar : LabelLayoutStrategy.DefaultRotation, 
                        renderY1Axis) for (var i = 0, len = y1Labels.length; len > i; i++) properties.text = y1Labels[i], 
                        maxWidthY1 = Math.max(maxWidthY1, textWidthMeasurer(properties));
                        if (y2AxisProperties && renderY2Axis) for (var y2Labels = y2AxisProperties.values, i = 0, len = y2Labels.length; len > i; i++) properties.text = y2Labels[i], 
                        maxWidthY2 = Math.max(maxWidthY2, textWidthMeasurer(properties));
                        var textHeight = textHeightMeasurer(properties), maxNumLines = Math.floor(bottomMarginLimit / textHeight), xScale = xAxisProperties.scale, xDomain = xScale.domain();
                        if (renderXAxis && xLabels.length > 0) {
                            for (var i = 0, len = xLabels.length; len > i; i++) {
                                var height = void 0;
                                properties.text = xLabels[i];
                                var width = textWidthMeasurer(properties);
                                if (xAxisProperties.willLabelsWordBreak) {
                                    var wordBreaks = jsCommon.WordBreaker.splitByWidth(properties.text, properties, textWidthMeasurer, xAxisProperties.xLabelMaxWidth, maxNumLines);
                                    height = wordBreaks.length * textHeight, width = xAxisProperties.xLabelMaxWidth;
                                } else !xAxisProperties.willLabelsFit && scaleIsOrdinal ? (height = width * rotation.sine, 
                                width *= rotation.cosine) : height = TextHeightConstant;
                                if (0 === i) {
                                    if (scaleIsOrdinal) leftOverflow = xAxisProperties.willLabelsFit ? width / 2 - ordinalLabelOffset - xLabelOuterPadding : width - ordinalLabelOffset - xLabelOuterPadding, 
                                    leftOverflow = Math.max(leftOverflow, 0); else if (xDomain.length > 1) {
                                        var xPos = xScale(xDomain[0]);
                                        leftOverflow = width / 2 - xPos, leftOverflow = Math.max(leftOverflow, 0);
                                    }
                                } else if (i === len - 1) if (scaleIsOrdinal) (xAxisProperties.willLabelsFit || xAxisProperties.willLabelsWordBreak) && (rightOverflow = width / 2 - ordinalLabelOffset - xLabelOuterPadding, 
                                rightOverflow = Math.max(rightOverflow, 0)); else if (xDomain.length > 1) {
                                    var xPos = xScale(xDomain[1]);
                                    rightOverflow = width / 2 - (viewport.width - xPos), rightOverflow = Math.max(rightOverflow, 0);
                                }
                                xMax = Math.max(xMax, height);
                            }
                            leftOverflow = Math.min(leftOverflow, XLabelMaxAllowedOverflow), rightOverflow = Math.min(rightOverflow, XLabelMaxAllowedOverflow);
                        }
                    }
                    var rightMargin = 0, leftMargin = 0, bottomMargin = Math.min(Math.ceil(xMax), bottomMarginLimit);
                    return showOnRight ? (leftMargin = Math.min(Math.max(leftOverflow, maxWidthY2), yMarginLimit), 
                    rightMargin = Math.min(Math.max(rightOverflow, maxWidthY1), yMarginLimit)) : (leftMargin = Math.min(Math.max(leftOverflow, maxWidthY1), yMarginLimit), 
                    rightMargin = Math.min(Math.max(rightOverflow, maxWidthY2), yMarginLimit)), {
                        xMax: Math.ceil(bottomMargin),
                        yLeft: Math.ceil(leftMargin),
                        yRight: Math.ceil(rightMargin)
                    };
                }
                function columnDataTypeHasValue(dataType) {
                    return dataType && (dataType.bool || dataType.numeric || dataType.text || dataType.dateTime);
                }
                function createOrdinalType() {
                    return powerbi.ValueType.fromDescriptor({
                        text: !0
                    });
                }
                function isOrdinal(type) {
                    return !(!type || !(type.text || type.bool || type.misc && type.misc.barcode || type.geography && type.geography.postalCode));
                }
                function isOrdinalScale(scale) {
                    return "undefined" == typeof scale.invert;
                }
                function isDateTime(type) {
                    return !(!type || !type.dateTime);
                }
                function invertScale(scale, x) {
                    return isOrdinalScale(scale) ? invertOrdinalScale(scale, x) : scale.invert(x);
                }
                function extent(scale) {
                    return isOrdinalScale(scale) ? scale.rangeExtent() : scale.range();
                }
                function invertOrdinalScale(scale, x) {
                    var leftEdges = scale.range();
                    if (leftEdges.length < 2) return 0;
                    var j, width = scale.rangeBand(), halfInnerPadding = (leftEdges[1] - leftEdges[0] - width) / 2;
                    for (j = 0; x > leftEdges[j] + width + halfInnerPadding && j < leftEdges.length - 1; j++) ;
                    return scale.domain()[j];
                }
                function findClosestXAxisIndex(categoryValue, categoryAxisValues) {
                    var closestValueIndex = -1, minDistance = Number.MAX_VALUE;
                    for (var i in categoryAxisValues) {
                        var distance = Math.abs(categoryValue - categoryAxisValues[i].categoryValue);
                        minDistance > distance && (minDistance = distance, closestValueIndex = parseInt(i, 10));
                    }
                    return closestValueIndex;
                }
                function lookupOrdinalIndex(scale, pixelValue) {
                    var closestValueIndex = -1, minDistance = Number.MAX_VALUE, domain = scale.domain();
                    if (domain.length < 2) return 0;
                    var halfWidth = (scale(1) - scale(0)) / 2;
                    for (var idx in domain) {
                        var leftEdgeInPixels = scale(idx), midPoint = leftEdgeInPixels + halfWidth, distance = Math.abs(pixelValue - midPoint);
                        minDistance > distance && (minDistance = distance, closestValueIndex = parseInt(idx, 10));
                    }
                    return closestValueIndex;
                }
                function diffScaled(scale, value1, value2) {
                    var value = scale(value1) - scale(value2);
                    return 0 === value ? 0 : 0 > value ? Math.min(value, -1) : Math.max(value, 1);
                }
                function createDomain(data, axisType, isScalar, forcedScalarDomain, ensureDomain) {
                    if (isScalar && !isOrdinal(axisType)) {
                        var userMin = void 0, userMax = void 0;
                        return forcedScalarDomain && 2 === forcedScalarDomain.length && (userMin = forcedScalarDomain[0], 
                        userMax = forcedScalarDomain[1]), createScalarDomain(data, userMin, userMax, axisType, ensureDomain);
                    }
                    return createOrdinalDomain(data);
                }
                function ensureValuesInRange(values, min, max) {
                    var filteredValues = values.filter(function(v) {
                        return v >= min && max >= v;
                    });
                    return filteredValues.length < 2 && (filteredValues = [ min, max ]), filteredValues;
                }
                function getCategoryValueType(metadataColumn, isScalar) {
                    return metadataColumn && columnDataTypeHasValue(metadataColumn.type) ? metadataColumn.type : isScalar ? powerbi.ValueType.fromDescriptor({
                        numeric: !0
                    }) : powerbi.ValueType.fromDescriptor({
                        text: !0
                    });
                }
                function createAxis(options) {
                    var pixelSpan = options.pixelSpan, dataDomain = options.dataDomain, metaDataColumn = options.metaDataColumn, formatString = options.formatString, outerPadding = options.outerPadding || 0, isCategoryAxis = !!options.isCategoryAxis, isScalar = !!options.isScalar, isVertical = !!options.isVertical, useTickIntervalForDisplayUnits = !!options.useTickIntervalForDisplayUnits, getValueFn = options.getValueFn, categoryThickness = options.categoryThickness, axisDisplayUnits = options.axisDisplayUnits, axisPrecision = options.axisPrecision, is100Pct = !!options.is100Pct, dataType = AxisHelper.getCategoryValueType(metaDataColumn, isScalar), scaleResult = AxisHelper.createScale(options), scale = scaleResult.scale, bestTickCount = scaleResult.bestTickCount, scaleDomain = scale.domain(), isLogScaleAllowed = AxisHelper.isLogScalePossible(dataDomain, dataType);
                    if (categoryThickness && isScalar && dataDomain && 2 === dataDomain.length) {
                        var oldSpan = dataDomain[1] - dataDomain[0], newSpan = scaleDomain[1] - scaleDomain[0];
                        oldSpan > 0 && newSpan > 0 && (categoryThickness = categoryThickness * oldSpan / newSpan);
                    }
                    var tickValues;
                    if (isScalar && 1 === bestTickCount) tickValues = [ dataDomain[0] ]; else {
                        var minTickInterval = isScalar ? getMinTickValueInterval(formatString, dataType, is100Pct) : void 0;
                        tickValues = getRecommendedTickValues(bestTickCount, scale, dataType, isScalar, minTickInterval);
                    }
                    options.scaleType && options.scaleType === visuals.axisScale.log && isLogScaleAllowed && (tickValues = tickValues.filter(function(d) {
                        return AxisHelper.powerOfTen(d);
                    }));
                    var formatter = createFormatter(scaleDomain, dataDomain, dataType, isScalar, formatString, bestTickCount, tickValues, getValueFn, useTickIntervalForDisplayUnits, axisDisplayUnits, axisPrecision), axis = d3.svg.axis().scale(scale).tickSize(6, 0).orient(isVertical ? "left" : "bottom").ticks(bestTickCount).tickValues(tickValues), formattedTickValues = [];
                    metaDataColumn && (formattedTickValues = formatAxisTickValues(axis, tickValues, formatter, dataType, getValueFn));
                    var xLabelMaxWidth;
                    return !isScalar && categoryThickness ? xLabelMaxWidth = Math.max(1, categoryThickness - 2 * visuals.CartesianChart.TickLabelPadding) : (xLabelMaxWidth = tickValues.length > 1 ? getScalarLabelMaxWidth(scale, tickValues) : pixelSpan, 
                    xLabelMaxWidth -= 2 * ScalarTickLabelPadding), {
                        scale: scale,
                        axis: axis,
                        formatter: formatter,
                        values: formattedTickValues,
                        axisType: dataType,
                        axisLabel: null,
                        isCategoryAxis: isCategoryAxis,
                        xLabelMaxWidth: xLabelMaxWidth,
                        categoryThickness: categoryThickness,
                        outerPadding: outerPadding,
                        usingDefaultDomain: scaleResult.usingDefaultDomain,
                        isLogScaleAllowed: isLogScaleAllowed,
                        dataDomain: dataDomain
                    };
                }
                function getScalarLabelMaxWidth(scale, tickValues) {
                    return scale && !_.isEmpty(tickValues) ? Math.abs(scale(tickValues[1]) - scale(tickValues[0])) : 1;
                }
                function createScale(options) {
                    var pixelSpan = options.pixelSpan, dataDomain = options.dataDomain, metaDataColumn = options.metaDataColumn, outerPadding = options.outerPadding || 0, isScalar = !!options.isScalar, isVertical = !!options.isVertical, forcedTickCount = options.forcedTickCount, categoryThickness = options.categoryThickness, shouldClamp = !!options.shouldClamp, maxTickCount = options.maxTickCount, dataType = AxisHelper.getCategoryValueType(metaDataColumn, isScalar), maxTicks = isVertical ? getRecommendedNumberOfTicksForYAxis(pixelSpan) : getRecommendedNumberOfTicksForXAxis(pixelSpan);
                    maxTickCount && maxTicks > maxTickCount && (maxTicks = maxTickCount);
                    var scale, scalarDomain = dataDomain ? dataDomain.slice() : null, bestTickCount = maxTicks, usingDefaultDomain = !1;
                    if (null == dataDomain || 2 === dataDomain.length && null == dataDomain[0] && null == dataDomain[1] || 2 !== dataDomain.length && isScalar) usingDefaultDomain = !0, 
                    dataDomain = dataType.dateTime || !isOrdinal(dataType) ? visuals.emptyDomain : [], 
                    scale = isOrdinal(dataType) ? createOrdinalScale(pixelSpan, dataDomain, categoryThickness ? outerPadding / categoryThickness : 0) : createNumericalScale(options.scaleType, pixelSpan, dataDomain, dataType, outerPadding, bestTickCount); else {
                        if (isScalar && dataDomain.length > 0) {
                            bestTickCount = void 0 !== forcedTickCount ? 0 !== maxTicks ? forcedTickCount : 0 : AxisHelper.getBestNumberOfTicks(dataDomain[0], dataDomain[dataDomain.length - 1], [ metaDataColumn ], maxTicks, dataType.dateTime);
                            var normalizedRange = normalizeLinearDomain({
                                min: dataDomain[0],
                                max: dataDomain[dataDomain.length - 1]
                            });
                            scalarDomain = [ normalizedRange.min, normalizedRange.max ];
                        }
                        isScalar && dataType.numeric && !dataType.dateTime ? scale = createNumericalScale(options.scaleType, pixelSpan, scalarDomain, dataType, outerPadding, bestTickCount, shouldClamp) : isScalar && dataType.dateTime ? scale = createLinearScale(pixelSpan, scalarDomain, outerPadding, null, shouldClamp) : (dataType.text || dataType.dateTime || dataType.numeric || dataType.bool) && (scale = createOrdinalScale(pixelSpan, scalarDomain, categoryThickness ? outerPadding / categoryThickness : 0), 
                        bestTickCount = 0 === maxTicks ? 0 : Math.min(scalarDomain.length, (pixelSpan - 2 * outerPadding) / visuals.CartesianChart.MinOrdinalRectThickness));
                    }
                    return isVertical && isScalar && scale.range(scale.range().reverse()), visuals.ColumnUtil.normalizeInfinityInScale(scale), 
                    {
                        scale: scale,
                        bestTickCount: bestTickCount,
                        usingDefaultDomain: usingDefaultDomain
                    };
                }
                function createFormatter(scaleDomain, dataDomain, dataType, isScalar, formatString, bestTickCount, tickValues, getValueFn, useTickIntervalForDisplayUnits, axisDisplayUnits, axisPrecision) {
                    void 0 === useTickIntervalForDisplayUnits && (useTickIntervalForDisplayUnits = !1);
                    var formatter;
                    if (dataType.dateTime) if (isScalar) {
                        var value = new Date(scaleDomain[0]), value2 = new Date(scaleDomain[1]);
                        1 === bestTickCount && (value = value2 = new Date(dataDomain[0])), formatter = visuals.valueFormatter.create({
                            format: formatString,
                            value: value,
                            value2: value2,
                            tickCount: bestTickCount
                        });
                    } else formatter = visuals.valueFormatter.createDefaultFormatter(formatString, !0); else if (useTickIntervalForDisplayUnits && isScalar && tickValues.length > 1) {
                        var value1 = axisDisplayUnits ? axisDisplayUnits : tickValues[1] - tickValues[0], options = {
                            format: formatString,
                            value: value1,
                            value2: 0,
                            allowFormatBeautification: !0
                        };
                        axisPrecision ? options.precision = axisPrecision : options.detectAxisPrecision = !0, 
                        formatter = visuals.valueFormatter.create(options);
                    } else formatter = visuals.valueFormatter.createDefaultFormatter(formatString, !0);
                    return formatter;
                }
                function formatAxisTickValues(axis, tickValues, formatter, dataType, getValueFn) {
                    var formattedTickValues = [];
                    return getValueFn || (getValueFn = function(data) {
                        return data;
                    }), formatter ? (axis.tickFormat(function(d) {
                        return formatter.format(getValueFn(d, dataType));
                    }), formattedTickValues = tickValues.map(function(d) {
                        return formatter.format(getValueFn(d, dataType));
                    })) : formattedTickValues = tickValues.map(function(d) {
                        return getValueFn(d, dataType);
                    }), formattedTickValues;
                }
                function getMinTickValueInterval(formatString, columnType, is100Pct) {
                    var isCustomFormat = formatString && !powerbi.NumberFormat.isStandardFormat(formatString);
                    if (isCustomFormat) {
                        var precision = powerbi.NumberFormat.getCustomFormatMetadata(formatString, !0).precision;
                        return formatString.indexOf("%") > -1 && (precision += 2), Math.pow(10, -precision);
                    }
                    return is100Pct ? .01 : columnType.integer ? 1 : 0;
                }
                function createScalarDomain(data, userMin, userMax, axisType, ensureDomain) {
                    if (0 === data.length) return null;
                    var defaultMinX = d3.min(data, function(kv) {
                        return d3.min(kv.data, function(d) {
                            return d.categoryValue;
                        });
                    }), defaultMaxX = d3.max(data, function(kv) {
                        return d3.max(kv.data, function(d) {
                            return d.categoryValue;
                        });
                    });
                    return combineDomain([ userMin, userMax ], [ defaultMinX, defaultMaxX ], ensureDomain);
                }
                function createValueDomain(data, includeZero) {
                    if (0 === data.length) return null;
                    var minY = d3.min(data, function(kv) {
                        return d3.min(kv.data, function(d) {
                            return d.value;
                        });
                    }), maxY = d3.max(data, function(kv) {
                        return d3.max(kv.data, function(d) {
                            return d.value;
                        });
                    });
                    return includeZero ? [ Math.min(minY, 0), Math.max(maxY, 0) ] : [ minY, maxY ];
                }
                function createOrdinalDomain(data) {
                    if (_.isEmpty(data)) return [];
                    for (var domain = [], firstSeries = data[0], _i = 0, _a = firstSeries.data; _i < _a.length; _i++) {
                        var dp = _a[_i];
                        dp.highlight || domain.push(dp.categoryIndex);
                    }
                    return domain;
                }
                function createOrdinalScale(pixelSpan, dataDomain, outerPaddingRatio) {
                    void 0 === outerPaddingRatio && (outerPaddingRatio = 0);
                    var scale = d3.scale.ordinal().rangeBands([ 0, pixelSpan ], visuals.CartesianChart.InnerPaddingRatio, outerPaddingRatio).domain(dataDomain);
                    return scale;
                }
                function isLogScalePossible(domain, axisType) {
                    return null == domain ? !1 : isDateTime(axisType) ? !1 : domain[0] > 0 && domain[1] > 0 || domain[0] < 0 && domain[1] < 0;
                }
                function createNumericalScale(axisScaleType, pixelSpan, dataDomain, dataType, outerPadding, niceCount, shouldClamp) {
                    return void 0 === outerPadding && (outerPadding = 0), axisScaleType === visuals.axisScale.log && isLogScalePossible(dataDomain, dataType) ? createLogScale(pixelSpan, dataDomain, outerPadding, niceCount) : createLinearScale(pixelSpan, dataDomain, outerPadding, niceCount, shouldClamp);
                }
                function createLogScale(pixelSpan, dataDomain, outerPadding, niceCount) {
                    void 0 === outerPadding && (outerPadding = 0);
                    var scale = d3.scale.log().range([ outerPadding, pixelSpan - outerPadding ]).domain([ dataDomain[0], dataDomain[1] ]).clamp(!0);
                    return niceCount && scale.nice(niceCount), scale;
                }
                function createLinearScale(pixelSpan, dataDomain, outerPadding, niceCount, shouldClamp) {
                    void 0 === outerPadding && (outerPadding = 0);
                    var scale = d3.scale.linear().range([ outerPadding, pixelSpan - outerPadding ]).domain([ dataDomain[0], dataDomain[1] ]).clamp(shouldClamp);
                    return niceCount && scale.nice(niceCount), scale;
                }
                function getRangeForColumn(sizeColumn) {
                    var result = {};
                    return sizeColumn && (result.min = null == sizeColumn.min ? null == sizeColumn.minLocal ? d3.min(sizeColumn.values) : sizeColumn.minLocal : sizeColumn.min, 
                    result.max = null == sizeColumn.max ? null == sizeColumn.maxLocal ? d3.max(sizeColumn.values) : sizeColumn.maxLocal : sizeColumn.max), 
                    result;
                }
                function applyCustomizedDomain(customizedDomain, forcedDomain) {
                    var domain = [ void 0, void 0 ];
                    return forcedDomain && 2 === forcedDomain.length && (domain = [ forcedDomain[0], forcedDomain[1] ]), 
                    customizedDomain && 2 === customizedDomain.length && (null != customizedDomain[0] && (domain[0] = customizedDomain[0]), 
                    null != customizedDomain[1] && (domain[1] = customizedDomain[1])), null == domain[0] && null == domain[1] ? forcedDomain : null != domain[0] && null != domain[1] && domain[0] > domain[1] ? forcedDomain : domain;
                }
                function combineDomain(forcedDomain, domain, ensureDomain) {
                    var combinedDomain = domain ? [ domain[0], domain[1] ] : [];
                    ensureDomain && ((null == combinedDomain[0] || ensureDomain.min < combinedDomain[0]) && (combinedDomain[0] = ensureDomain.min), 
                    (null == combinedDomain[1] || ensureDomain.max > combinedDomain[1]) && (combinedDomain[1] = ensureDomain.max));
                    var domainBeforeForced = [ combinedDomain[0], combinedDomain[1] ];
                    return forcedDomain && 2 === forcedDomain.length && (null != forcedDomain[0] && (combinedDomain[0] = forcedDomain[0]), 
                    null != forcedDomain[1] && (combinedDomain[1] = forcedDomain[1]), combinedDomain[0] > combinedDomain[1] && (combinedDomain = domainBeforeForced)), 
                    combinedDomain;
                }
                function createAxisLabel(properties, label, unitType, y2) {
                    void 0 === y2 && (y2 = !1);
                    var propertyName = y2 ? "secAxisStyle" : "axisStyle";
                    if (!properties || !properties[propertyName]) return label;
                    var modifiedLabel;
                    return modifiedLabel = properties[propertyName] === visuals.axisStyle.showBoth ? label + " (" + unitType + ")" : properties[propertyName] === visuals.axisStyle.showUnitOnly ? unitType : label;
                }
                function scaleShouldClamp(combinedDomain, domain) {
                    return !combinedDomain || !domain || combinedDomain.length < 2 || domain.length < 2 ? !1 : combinedDomain[0] !== domain[0] || combinedDomain[1] !== domain[1];
                }
                function normalizeNonFiniteNumber(value) {
                    return isNaN(value) ? null : value === Number.POSITIVE_INFINITY ? Number.MAX_VALUE : value === Number.NEGATIVE_INFINITY ? -Number.MAX_VALUE : value;
                }
                function powerOfTen(d) {
                    var value = Math.abs(d), log10 = Math.log(value) / Math.LN10;
                    return log10 = Math.ceil(log10 - 1e-12), value / Math.pow(10, log10) === 1;
                }
                var XLabelMaxAllowedOverflow = 35, TextHeightConstant = 10, MinTickCount = 2, DefaultBestTickCount = 3, LeftPadding = 10, ScalarTickLabelPadding = 3;
                AxisHelper.getRecommendedNumberOfTicksForXAxis = getRecommendedNumberOfTicksForXAxis, 
                AxisHelper.getRecommendedNumberOfTicksForYAxis = getRecommendedNumberOfTicksForYAxis, 
                AxisHelper.getBestNumberOfTicks = getBestNumberOfTicks, AxisHelper.hasNonIntegerData = hasNonIntegerData, 
                AxisHelper.getRecommendedTickValues = getRecommendedTickValues, AxisHelper.getRecommendedTickValuesForAnOrdinalRange = getRecommendedTickValuesForAnOrdinalRange, 
                AxisHelper.getRecommendedTickValuesForAQuantitativeRange = getRecommendedTickValuesForAQuantitativeRange, 
                AxisHelper.getMargin = getMargin, AxisHelper.getTickLabelMargins = getTickLabelMargins, 
                AxisHelper.columnDataTypeHasValue = columnDataTypeHasValue, AxisHelper.createOrdinalType = createOrdinalType, 
                AxisHelper.isOrdinal = isOrdinal, AxisHelper.isOrdinalScale = isOrdinalScale, AxisHelper.isDateTime = isDateTime, 
                AxisHelper.invertScale = invertScale, AxisHelper.extent = extent, AxisHelper.invertOrdinalScale = invertOrdinalScale, 
                AxisHelper.findClosestXAxisIndex = findClosestXAxisIndex, AxisHelper.lookupOrdinalIndex = lookupOrdinalIndex, 
                AxisHelper.diffScaled = diffScaled, AxisHelper.createDomain = createDomain, AxisHelper.ensureValuesInRange = ensureValuesInRange, 
                AxisHelper.getCategoryValueType = getCategoryValueType, AxisHelper.createAxis = createAxis, 
                AxisHelper.createScale = createScale, AxisHelper.createFormatter = createFormatter, 
                AxisHelper.getMinTickValueInterval = getMinTickValueInterval, AxisHelper.createValueDomain = createValueDomain;
                var LabelLayoutStrategy;
                !function(LabelLayoutStrategy) {
                    function willLabelsFit(axisProperties, availableWidth, textMeasurer, properties) {
                        var labels = axisProperties.values;
                        if (0 === labels.length) return !1;
                        var labelMaxWidth = void 0 !== axisProperties.xLabelMaxWidth ? axisProperties.xLabelMaxWidth : availableWidth / labels.length;
                        return !labels.some(function(d) {
                            return properties.text = d, textMeasurer(properties) > labelMaxWidth;
                        });
                    }
                    function willLabelsWordBreak(axisProperties, margin, availableWidth, textWidthMeasurer, textHeightMeasurer, textTruncator, properties) {
                        var labels = axisProperties.values, labelMaxWidth = void 0 !== axisProperties.xLabelMaxWidth ? axisProperties.xLabelMaxWidth : availableWidth / labels.length, maxRotatedLength = margin.bottom / LabelLayoutStrategy.DefaultRotation.sine, height = textHeightMeasurer(properties), maxNumLines = Math.max(1, Math.floor(margin.bottom / height));
                        if (0 === labels.length) return !1;
                        var mustRotate = labels.some(function(label) {
                            return properties.text = label, !jsCommon.WordBreaker.hasBreakers(label) && textWidthMeasurer(properties) > labelMaxWidth;
                        });
                        if (mustRotate) return !1;
                        var moreWordBreakChars = labels.filter(function(label, index) {
                            var allowedLengthProjectedOnXAxis = margin.left + axisProperties.outerPadding + axisProperties.categoryThickness * (index + .5) - LeftPadding, allowedLength = allowedLengthProjectedOnXAxis / LabelLayoutStrategy.DefaultRotation.cosine, rotatedLength = Math.min(allowedLength, maxRotatedLength), wordBreakChars = jsCommon.WordBreaker.splitByWidth(label, properties, textWidthMeasurer, labelMaxWidth, maxNumLines, textTruncator).join(" ");
                            properties.text = label;
                            var rotateChars = textTruncator(properties, rotatedLength);
                            return visuals.TextUtil.removeEllipses(wordBreakChars).length >= visuals.TextUtil.removeEllipses(rotateChars).length;
                        });
                        return moreWordBreakChars.length >= Math.floor(labels.length / 2);
                    }
                    function rotate(labelSelection, maxBottomMargin, textTruncator, textProperties, needRotate, needEllipsis, axisProperties, margin, scrollbarVisible) {
                        var rotatedLength, defaultRotation;
                        defaultRotation = scrollbarVisible ? LabelLayoutStrategy.DefaultRotationWithScrollbar : LabelLayoutStrategy.DefaultRotation, 
                        needRotate && (rotatedLength = maxBottomMargin / defaultRotation.sine), labelSelection.each(function() {
                            var axisLabel = d3.select(this), labelText = axisLabel.text();
                            if (textProperties.text = labelText, needRotate) {
                                var textContentIndex = axisProperties.values.indexOf(this.textContent), allowedLengthProjectedOnXAxis = margin.left + axisProperties.outerPadding + axisProperties.categoryThickness * (textContentIndex + .5);
                                scrollbarVisible || (allowedLengthProjectedOnXAxis -= LeftPadding);
                                var allowedLength = allowedLengthProjectedOnXAxis / defaultRotation.cosine;
                                (scrollbarVisible || needEllipsis || rotatedLength > allowedLength) && (labelText = textTruncator(textProperties, Math.min(allowedLength, rotatedLength)), 
                                axisLabel.text(labelText)), axisLabel.style("text-anchor", "end").attr({
                                    dx: "-0.5em",
                                    dy: defaultRotation.dy,
                                    transform: defaultRotation.transform
                                });
                            } else {
                                var newLabelText = textTruncator(textProperties, axisProperties.xLabelMaxWidth);
                                newLabelText !== labelText && axisLabel.text(newLabelText), axisLabel.style("text-anchor", "middle").attr({
                                    dx: "0em",
                                    dy: "1em",
                                    transform: "rotate(0)"
                                });
                            }
                        });
                    }
                    function wordBreak(text, axisProperties, maxHeight) {
                        var allowedLength = axisProperties.xLabelMaxWidth;
                        text.each(function() {
                            var node = d3.select(this);
                            node.style("text-anchor", "middle").attr({
                                dx: "0em",
                                dy: "1em",
                                transform: "rotate(0)"
                            }), powerbi.TextMeasurementService.wordBreak(this, allowedLength, maxHeight);
                        });
                    }
                    function clip(text, availableWidth, svgEllipsis) {
                        0 !== text.size() && text.each(function() {
                            var text = d3.select(this);
                            svgEllipsis(text[0][0], availableWidth);
                        });
                    }
                    LabelLayoutStrategy.willLabelsFit = willLabelsFit, LabelLayoutStrategy.willLabelsWordBreak = willLabelsWordBreak, 
                    LabelLayoutStrategy.DefaultRotation = {
                        sine: Math.sin(Math.PI * (35 / 180)),
                        cosine: Math.cos(Math.PI * (35 / 180)),
                        tangent: Math.tan(Math.PI * (35 / 180)),
                        transform: "rotate(-35)",
                        dy: "-0.5em"
                    }, LabelLayoutStrategy.DefaultRotationWithScrollbar = {
                        sine: Math.sin(.5 * Math.PI),
                        cosine: Math.cos(.5 * Math.PI),
                        tangent: Math.tan(.5 * Math.PI),
                        transform: "rotate(-90)",
                        dy: "-0.8em"
                    }, LabelLayoutStrategy.rotate = rotate, LabelLayoutStrategy.wordBreak = wordBreak, 
                    LabelLayoutStrategy.clip = clip;
                }(LabelLayoutStrategy = AxisHelper.LabelLayoutStrategy || (AxisHelper.LabelLayoutStrategy = {})), 
                AxisHelper.createOrdinalScale = createOrdinalScale, AxisHelper.isLogScalePossible = isLogScalePossible, 
                AxisHelper.createNumericalScale = createNumericalScale, AxisHelper.createLinearScale = createLinearScale, 
                AxisHelper.getRangeForColumn = getRangeForColumn, AxisHelper.applyCustomizedDomain = applyCustomizedDomain, 
                AxisHelper.combineDomain = combineDomain, AxisHelper.createAxisLabel = createAxisLabel, 
                AxisHelper.scaleShouldClamp = scaleShouldClamp, AxisHelper.normalizeNonFiniteNumber = normalizeNonFiniteNumber, 
                AxisHelper.powerOfTen = powerOfTen;
            }(AxisHelper = visuals.AxisHelper || (visuals.AxisHelper = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var ShapeFactory;
            !function(ShapeFactory) {
                function createRectangle(data, viewportHeight, viewportWidth, selectedElement, degrees) {
                    var x = viewportWidth * ShapeFactoryConsts.PaddingConstRatio + data.lineWeight / 2, y = viewportHeight * ShapeFactoryConsts.PaddingConstRatio + data.lineWeight / 2, width = viewportWidth * ShapeFactoryConsts.ShapeConstRatio - data.lineWeight, height = viewportHeight * ShapeFactoryConsts.ShapeConstRatio - data.lineWeight, attrs = {
                        x: x,
                        y: y,
                        width: width,
                        height: height,
                        rx: data.roundEdge,
                        ry: data.roundEdge
                    }, scale = getScale(width, height, degrees);
                    createShape(data, viewportHeight, viewportWidth, selectedElement, degrees, scale, "rect", attrs);
                }
                function createOval(data, viewportHeight, viewportWidth, selectedElement, degrees) {
                    var widthForCircle = (viewportWidth / ShapeFactoryConsts.OvalRadiusConst).toString(), heightForCircle = (viewportHeight / ShapeFactoryConsts.OvalRadiusConst).toString(), radiusXForCircle = viewportWidth / (ShapeFactoryConsts.OvalRadiusConst + ShapeFactoryConsts.OvalRadiusConstPadding) - data.lineWeight, radiusYForCircle = viewportHeight / (ShapeFactoryConsts.OvalRadiusConst + ShapeFactoryConsts.OvalRadiusConstPadding) - data.lineWeight, attrs = {
                        cx: widthForCircle,
                        cy: heightForCircle,
                        rx: radiusXForCircle,
                        ry: radiusYForCircle
                    }, scale = getScale(viewportWidth, viewportHeight, degrees);
                    createShape(data, viewportHeight, viewportWidth, selectedElement, degrees, scale, "ellipse", attrs);
                }
                function createLine(data, viewportHeight, viewportWidth, selectedElement, degrees) {
                    var x1, y1, x2, y2, ratio, width = viewportWidth - ShapeFactoryConsts.SmallPaddingConstValue - ShapeFactoryConsts.SmallPaddingConstValue, height = viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue - ShapeFactoryConsts.SmallPaddingConstValue;
                    45 >= degrees ? (ratio = degrees / 90, x1 = viewportWidth / 2 + width * ratio, y1 = ShapeFactoryConsts.SmallPaddingConstValue, 
                    x2 = viewportWidth / 2 - width * ratio, y2 = viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue) : 135 >= degrees ? (ratio = (degrees - 45) / 90, 
                    x1 = viewportWidth - ShapeFactoryConsts.SmallPaddingConstValue, y1 = ShapeFactoryConsts.SmallPaddingConstValue + height * ratio, 
                    x2 = ShapeFactoryConsts.SmallPaddingConstValue, y2 = viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue - height * ratio) : 225 >= degrees ? (ratio = (degrees - 135) / 90, 
                    x1 = viewportWidth - ShapeFactoryConsts.SmallPaddingConstValue - width * ratio, 
                    y1 = viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue, x2 = ShapeFactoryConsts.SmallPaddingConstValue + width * ratio, 
                    y2 = ShapeFactoryConsts.SmallPaddingConstValue) : 315 >= degrees ? (ratio = (degrees - 225) / 90, 
                    x1 = ShapeFactoryConsts.SmallPaddingConstValue, y1 = viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue - height * ratio, 
                    x2 = viewportWidth - ShapeFactoryConsts.SmallPaddingConstValue, y2 = ShapeFactoryConsts.SmallPaddingConstValue + height * ratio) : 360 >= degrees && (ratio = (degrees - 315) / 90, 
                    x1 = ShapeFactoryConsts.SmallPaddingConstValue + width * ratio, y1 = ShapeFactoryConsts.SmallPaddingConstValue, 
                    x2 = viewportWidth - ShapeFactoryConsts.SmallPaddingConstValue - width * ratio, 
                    y2 = viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue), selectedElement.append("svg").attr({
                        width: viewportWidth,
                        height: viewportHeight
                    }).append("line").attr({
                        x1: x1,
                        y1: y1,
                        x2: x2,
                        y2: y2
                    }).style({
                        "vector-effect": "non-scaling-stroke",
                        "stroke-width": data.lineWeight + "px",
                        "stroke-opacity": (100 - data.lineTransparency) / 100,
                        stroke: data.lineColor
                    });
                }
                function createUpArrow(data, viewportHeight, viewportWidth, selectedElement, degrees) {
                    var lineWeight = data.lineWeight, viewportHeightWeight = viewportHeight - lineWeight, viewportWidthWeight = viewportWidth - lineWeight, arrowPoints = [ {
                        x: (viewportWidthWeight * ShapeFactoryConsts.ArrowLeftHeadPoint.x).toString(),
                        y: (viewportHeightWeight * ShapeFactoryConsts.ArrowLeftHeadPoint.y).toString()
                    }, {
                        x: (viewportWidthWeight * ShapeFactoryConsts.ArrowMiddleHeadPoint.x).toString(),
                        y: (viewportHeightWeight * ShapeFactoryConsts.ArrowMiddleHeadPoint.y).toString()
                    }, {
                        x: (viewportWidthWeight * ShapeFactoryConsts.ArrowRightHeadPoint.x).toString(),
                        y: (viewportHeightWeight * ShapeFactoryConsts.ArrowRightHeadPoint.y).toString()
                    }, {
                        x: (viewportWidthWeight * ShapeFactoryConsts.ArrowRightMiddleHeadPoint.x).toString(),
                        y: (viewportHeightWeight * ShapeFactoryConsts.ArrowRightMiddleHeadPoint.y).toString()
                    }, {
                        x: (viewportWidthWeight * ShapeFactoryConsts.ArrowBottomRightPoint.x).toString(),
                        y: (viewportHeightWeight * ShapeFactoryConsts.ArrowBottomRightPoint.y).toString()
                    }, {
                        x: (viewportWidthWeight * ShapeFactoryConsts.ArrowBottomLeftPoint.x).toString(),
                        y: (viewportHeightWeight * ShapeFactoryConsts.ArrowBottomLeftPoint.y).toString()
                    }, {
                        x: (viewportWidthWeight * ShapeFactoryConsts.ArrowLeftMiddleHeadPoint.x).toString(),
                        y: (viewportHeightWeight * ShapeFactoryConsts.ArrowLeftMiddleHeadPoint.y).toString()
                    } ];
                    createPathFromArray(data, arrowPoints, selectedElement, viewportHeight, viewportWidth, degrees);
                }
                function createTriangle(data, viewportHeight, viewportWidth, selectedElement, degrees) {
                    var lineWeight = data.lineWeight;
                    lineWeight > 3 && (lineWeight -= 3);
                    var firstPointX = (viewportWidth + lineWeight) * ShapeFactoryConsts.TrianglePaddingConstRatio, firstPointY = viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue - lineWeight < 0 ? viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue : viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue - lineWeight, secondPointY = (viewportHeight + lineWeight) * ShapeFactoryConsts.TrianglePaddingConstRatio, thirdPointX = (viewportWidth - lineWeight) * ShapeFactoryConsts.TriangleEndPaddingConstRatio < 0 ? viewportWidth * ShapeFactoryConsts.TriangleEndPaddingConstRatio : (viewportWidth - lineWeight) * ShapeFactoryConsts.TriangleEndPaddingConstRatio, thirdPointY = viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue - lineWeight < 0 ? viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue : viewportHeight - lineWeight - ShapeFactoryConsts.SmallPaddingConstValue, secondPointX = (firstPointX + thirdPointX) / 2;
                    10 > firstPointX && (firstPointX = ShapeFactoryConsts.SmallPaddingConstValue), 10 > secondPointY && (secondPointY = ShapeFactoryConsts.SmallPaddingConstValue);
                    var trianglePoints = [ {
                        x: firstPointX,
                        y: firstPointY
                    }, {
                        x: secondPointX,
                        y: secondPointY
                    }, {
                        x: thirdPointX,
                        y: thirdPointY
                    } ];
                    createPathFromArray(data, trianglePoints, selectedElement, viewportHeight, viewportWidth, degrees);
                }
                function createPathFromArray(data, points, selectedElement, viewportHeight, viewportWidth, degrees) {
                    var lineFunction = d3.svg.line().x(function(d) {
                        return d.x;
                    }).y(function(d) {
                        return d.y;
                    }).interpolate("linear"), attrs = {
                        d: lineFunction(points) + " Z"
                    }, scale = getScale(viewportWidth, viewportHeight, degrees);
                    createShape(data, viewportHeight, viewportWidth, selectedElement, degrees, scale, "path", attrs);
                }
                function createShape(data, viewportHeight, viewportWidth, selectedElement, degrees, scale, shapeType, shapeAttrs) {
                    selectedElement.append("div").style({
                        transform: "rotate(" + degrees + "deg) scale(" + scale + ")",
                        "transform-origin": "center",
                        "-webkit-transform": "rotate(" + degrees + "deg) scale(" + scale + ")",
                        "-webkit-transform-origin": "center",
                        width: viewportWidth + "px",
                        height: viewportHeight + "px"
                    }).append("svg").attr({
                        width: viewportWidth,
                        height: viewportHeight
                    }).append(shapeType).attr(shapeAttrs).style({
                        "vector-effect": "non-scaling-stroke",
                        "stroke-width": data.lineWeight + "px",
                        stroke: data.lineColor,
                        "stroke-opacity": (100 - data.lineTransparency) / 100,
                        fill: data.fillColor,
                        "fill-opacity": data.showFill === !0 ? (100 - data.shapeTransparency) / 100 : 0
                    });
                }
                function getScale(width, height, degrees) {
                    var originalWidth = width, originalHeight = height, offsetAngle = Math.atan2(height, width), originalFactor = Math.sqrt(Math.pow(height, 2) + Math.pow(width, 2)), radians = degrees / 180 * Math.PI;
                    return width >= height ? (90 > degrees ? radians += offsetAngle : 180 > degrees ? radians -= offsetAngle : 270 > degrees ? radians += offsetAngle : radians -= offsetAngle, 
                    originalHeight / Math.abs(Math.sin(radians)) / originalFactor) : (90 > degrees ? radians -= offsetAngle : 180 > degrees ? radians += offsetAngle : 270 > degrees ? radians -= offsetAngle : radians += offsetAngle, 
                    originalWidth / Math.abs(Math.cos(radians)) / originalFactor);
                }
                var ShapeFactoryConsts;
                !function(ShapeFactoryConsts) {
                    ShapeFactoryConsts.PaddingConstRatio = .01, ShapeFactoryConsts.TrianglePaddingConstRatio = .15, 
                    ShapeFactoryConsts.TriangleEndPaddingConstRatio = .85, ShapeFactoryConsts.ShapeConstRatio = 1 - 2 * ShapeFactoryConsts.PaddingConstRatio, 
                    ShapeFactoryConsts.SmallPaddingConstValue = 10, ShapeFactoryConsts.OvalRadiusConst = 2, 
                    ShapeFactoryConsts.OvalRadiusConstPadding = .2, ShapeFactoryConsts.ArrowLeftHeadPoint = {
                        x: .05,
                        y: .42
                    }, ShapeFactoryConsts.ArrowMiddleHeadPoint = {
                        x: .5,
                        y: .016
                    }, ShapeFactoryConsts.ArrowRightHeadPoint = {
                        x: .95,
                        y: .42
                    }, ShapeFactoryConsts.ArrowRightMiddleHeadPoint = {
                        x: .764,
                        y: .42
                    }, ShapeFactoryConsts.ArrowBottomRightPoint = {
                        x: .764,
                        y: .993
                    }, ShapeFactoryConsts.ArrowBottomLeftPoint = {
                        x: .246,
                        y: .993
                    }, ShapeFactoryConsts.ArrowLeftMiddleHeadPoint = {
                        x: .246,
                        y: .42
                    };
                }(ShapeFactoryConsts = ShapeFactory.ShapeFactoryConsts || (ShapeFactory.ShapeFactoryConsts = {})), 
                ShapeFactory.createRectangle = createRectangle, ShapeFactory.createOval = createOval, 
                ShapeFactory.createLine = createLine, ShapeFactory.createUpArrow = createUpArrow, 
                ShapeFactory.createTriangle = createTriangle;
            }(ShapeFactory = visuals.ShapeFactory || (visuals.ShapeFactory = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var CartesianHelper;
            !function(CartesianHelper) {
                function getCategoryAxisProperties(dataViewMetadata, axisTitleOnByDefault) {
                    var toReturn = {};
                    if (!dataViewMetadata) return toReturn;
                    var objects = dataViewMetadata.objects;
                    if (objects) {
                        var categoryAxisObject = objects.categoryAxis;
                        categoryAxisObject && (toReturn = {
                            show: categoryAxisObject.show,
                            axisType: categoryAxisObject.axisType,
                            axisScale: categoryAxisObject.axisScale,
                            start: categoryAxisObject.start,
                            end: categoryAxisObject.end,
                            showAxisTitle: null == categoryAxisObject.showAxisTitle ? axisTitleOnByDefault : categoryAxisObject.showAxisTitle,
                            axisStyle: categoryAxisObject.axisStyle,
                            labelColor: categoryAxisObject.labelColor,
                            labelDisplayUnits: categoryAxisObject.labelDisplayUnits,
                            labelPrecision: categoryAxisObject.labelPrecision,
                            duration: categoryAxisObject.duration
                        });
                    }
                    return toReturn;
                }
                function getValueAxisProperties(dataViewMetadata, axisTitleOnByDefault) {
                    var toReturn = {};
                    if (!dataViewMetadata) return toReturn;
                    var objects = dataViewMetadata.objects;
                    if (objects) {
                        var valueAxisObject = objects.valueAxis;
                        valueAxisObject && (toReturn = {
                            show: valueAxisObject.show,
                            position: valueAxisObject.position,
                            axisScale: valueAxisObject.axisScale,
                            start: valueAxisObject.start,
                            end: valueAxisObject.end,
                            showAxisTitle: null == valueAxisObject.showAxisTitle ? axisTitleOnByDefault : valueAxisObject.showAxisTitle,
                            axisStyle: valueAxisObject.axisStyle,
                            labelColor: valueAxisObject.labelColor,
                            labelDisplayUnits: valueAxisObject.labelDisplayUnits,
                            labelPrecision: valueAxisObject.labelPrecision,
                            secShow: valueAxisObject.secShow,
                            secPosition: valueAxisObject.secPosition,
                            secAxisScale: valueAxisObject.secAxisScale,
                            secStart: valueAxisObject.secStart,
                            secEnd: valueAxisObject.secEnd,
                            secShowAxisTitle: valueAxisObject.secShowAxisTitle,
                            secAxisStyle: valueAxisObject.secAxisStyle,
                            secLabelColor: valueAxisObject.secLabelColor,
                            secLabelDisplayUnits: valueAxisObject.secLabelDisplayUnits,
                            secLabelPrecision: valueAxisObject.secLabelPrecision
                        });
                    }
                    return toReturn;
                }
                function isScalar(isScalar, xAxisCardProperties) {
                    return isScalar && (isScalar = xAxisCardProperties && xAxisCardProperties.axisType ? xAxisCardProperties.axisType === visuals.axisType.scalar : !0), 
                    isScalar;
                }
                function getPrecision(precision) {
                    return null != precision ? 0 > precision ? 0 : precision : null;
                }
                function lookupXValue(data, index, type, isScalar) {
                    var isDateTime = visuals.AxisHelper.isDateTime(type);
                    if (isScalar) return isDateTime ? new Date(index) : index;
                    if (type.text) return data.categories[index];
                    if (data && data.series && data.series.length > 0) {
                        var firstSeries = data.series[0];
                        if (firstSeries) {
                            var seriesValues = firstSeries.data;
                            if (seriesValues) {
                                data.hasHighlights && (index = 2 * index);
                                var dataAtIndex = seriesValues[index];
                                if (dataAtIndex) return isDateTime && null != dataAtIndex.categoryValue ? new Date(dataAtIndex.categoryValue) : dataAtIndex.categoryValue;
                            }
                        }
                    }
                    return index;
                }
                function findMaxCategoryIndex(series) {
                    if (_.isEmpty(series)) return 0;
                    for (var maxCategoryIndex = 0, _i = 0, series_1 = series; _i < series_1.length; _i++) {
                        var singleSeries = series_1[_i];
                        if (!_.isEmpty(singleSeries.data)) {
                            var lastIndex = singleSeries.data[singleSeries.data.length - 1].categoryIndex;
                            maxCategoryIndex = Math.max(lastIndex, maxCategoryIndex);
                        }
                    }
                    return maxCategoryIndex;
                }
                CartesianHelper.getCategoryAxisProperties = getCategoryAxisProperties, CartesianHelper.getValueAxisProperties = getValueAxisProperties, 
                CartesianHelper.isScalar = isScalar, CartesianHelper.getPrecision = getPrecision, 
                CartesianHelper.lookupXValue = lookupXValue, CartesianHelper.findMaxCategoryIndex = findMaxCategoryIndex;
            }(CartesianHelper = visuals.CartesianHelper || (visuals.CartesianHelper = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var SQExprShortSerializer = powerbi.data.SQExprShortSerializer, ColorHelper = function() {
                function ColorHelper(colors, fillProp, defaultDataPointColor) {
                    this.colors = colors, this.fillProp = fillProp, this.defaultDataPointColor = defaultDataPointColor, 
                    this.defaultColorScale = colors.getNewColorScale();
                }
                return ColorHelper.prototype.getColorForSeriesValue = function(objects, fieldIds, value) {
                    return this.fillProp && powerbi.DataViewObjects.getFillColor(objects, this.fillProp) || this.defaultDataPointColor || this.getColorScaleForSeries(fieldIds).getColor(value).value;
                }, ColorHelper.prototype.getColorScaleForSeries = function(fieldIds) {
                    return this.colors.getColorScaleByKey(SQExprShortSerializer.serializeArray(fieldIds || []));
                }, ColorHelper.prototype.getColorForMeasure = function(objects, measureKey) {
                    var scaleColor = this.defaultColorScale.getColor(measureKey).value;
                    return this.fillProp && powerbi.DataViewObjects.getFillColor(objects, this.fillProp) || this.defaultDataPointColor || scaleColor;
                }, ColorHelper.normalizeSelector = function(selector, isSingleSeries) {
                    return selector && (isSingleSeries || selector.data) ? {
                        data: selector.data
                    } : selector;
                }, ColorHelper;
            }();
            visuals.ColorHelper = ColorHelper;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var ColumnUtil, rectName = "rect";
            !function(ColumnUtil) {
                function applyUserMinMax(isScalar, dataView, xAxisCardProperties) {
                    if (isScalar) {
                        var min = xAxisCardProperties.start, max = xAxisCardProperties.end;
                        return ColumnUtil.transformDomain(dataView, min, max);
                    }
                    return dataView;
                }
                function transformDomain(dataView, min, max) {
                    if (!dataView.categories || !dataView.values || 0 === dataView.categories.length || 0 === dataView.values.length) return dataView;
                    if ("number" != typeof min && "number" != typeof max) return dataView;
                    var category = dataView.categories[0], categoryType = category ? category.source.type : null;
                    if (!visuals.AxisHelper.isOrdinal(categoryType)) {
                        var categoryValues = category.values, categoryObjects = category.objects;
                        if (!categoryValues || !categoryObjects) return dataView;
                        var newcategoryValues = [], newValues = [], newObjects = [];
                        if ("number" != typeof min && (min = categoryValues[0]), "number" != typeof max && (max = categoryValues[categoryValues.length - 1]), 
                        min > max) return dataView;
                        for (var j = 0, len = dataView.values.length; len > j; j++) newValues.push([]);
                        for (var t = 0, len = categoryValues.length; len > t; t++) if (categoryValues[t] >= min && categoryValues[t] <= max && (newcategoryValues.push(categoryValues[t]), 
                        categoryObjects && newObjects.push(categoryObjects[t]), dataView.values)) for (var k = 0; k < dataView.values.length; k++) newValues[k].push(dataView.values[k].values[t]);
                        var resultDataView = powerbi.Prototype.inherit(dataView), resultDataViewValues = resultDataView.values = powerbi.Prototype.inherit(resultDataView.values), resultDataViewCategories = resultDataView.categories = powerbi.Prototype.inherit(dataView.categories), resultDataViewCategories0 = resultDataView.categories[0] = powerbi.Prototype.inherit(resultDataViewCategories[0]);
                        resultDataViewCategories0.values = newcategoryValues, resultDataViewCategories0.objects && (resultDataViewCategories0.objects = newObjects);
                        for (var t = 0, len = dataView.values.length; len > t; t++) {
                            var measureArray = resultDataViewValues[t] = powerbi.Prototype.inherit(resultDataViewValues[t]);
                            measureArray.values = newValues[t];
                        }
                        return resultDataView;
                    }
                }
                function getCategoryAxis(data, size, layout, isVertical, forcedXMin, forcedXMax, axisScaleType, axisDisplayUnits, axisPrecision, ensureXDomain) {
                    var categoryThickness = layout.categoryThickness, isScalar = layout.isScalar, outerPaddingRatio = layout.outerPaddingRatio, domain = visuals.AxisHelper.createDomain(data.series, data.categoryMetadata ? data.categoryMetadata.type : powerbi.ValueType.fromDescriptor({
                        text: !0
                    }), isScalar, [ forcedXMin, forcedXMax ], ensureXDomain), axisProperties = visuals.AxisHelper.createAxis({
                        pixelSpan: size,
                        dataDomain: domain,
                        metaDataColumn: data.categoryMetadata,
                        formatString: visuals.valueFormatter.getFormatString(data.categoryMetadata, visuals.columnChartProps.general.formatString),
                        outerPadding: categoryThickness * outerPaddingRatio,
                        isCategoryAxis: !0,
                        isScalar: isScalar,
                        isVertical: isVertical,
                        categoryThickness: categoryThickness,
                        useTickIntervalForDisplayUnits: !0,
                        getValueFn: function(index, type) {
                            return visuals.CartesianHelper.lookupXValue(data, index, type, isScalar);
                        },
                        scaleType: axisScaleType,
                        axisDisplayUnits: axisDisplayUnits,
                        axisPrecision: axisPrecision
                    });
                    return layout.categoryThickness = axisProperties.categoryThickness, axisProperties;
                }
                function applyInteractivity(columns, onDragStart) {
                    onDragStart && columns.attr("draggable", "true").on("dragstart", onDragStart);
                }
                function getFillOpacity(selected, highlight, hasSelection, hasPartialHighlights) {
                    return hasPartialHighlights && !highlight || hasSelection && !selected ? ColumnUtil.DimmedOpacity : ColumnUtil.DefaultOpacity;
                }
                function getClosestColumnIndex(coordinate, columnsCenters) {
                    for (var currentIndex = 0, distance = Number.MAX_VALUE, i = 0, ilen = columnsCenters.length; ilen > i; i++) {
                        var currentDistance = Math.abs(coordinate - columnsCenters[i]);
                        distance > currentDistance && (distance = currentDistance, currentIndex = i);
                    }
                    return currentIndex;
                }
                function setChosenColumnOpacity(mainGraphicsContext, columnGroupSelector, selectedColumnIndex, lastColumnIndex) {
                    var series = mainGraphicsContext.selectAll(visuals.ColumnChart.SeriesClasses.selector), lastColumnUndefined = "undefined" == typeof lastColumnIndex;
                    series.selectAll(rectName + columnGroupSelector).filter(function(d) {
                        return d.categoryIndex !== selectedColumnIndex && (lastColumnUndefined || d.categoryIndex === lastColumnIndex);
                    }).transition().style("fill-opacity", ColumnUtil.DimmedOpacity), series.selectAll(rectName + columnGroupSelector).filter(function(d) {
                        return d.categoryIndex === selectedColumnIndex;
                    }).style("fill-opacity", ColumnUtil.DefaultOpacity);
                }
                function drawSeries(data, graphicsContext, axisOptions) {
                    var colGroupSelection = graphicsContext.selectAll(visuals.ColumnChart.SeriesClasses.selector), series = colGroupSelection.data(data.series, function(d) {
                        return d.key;
                    });
                    return series.enter().append("g").classed(visuals.ColumnChart.SeriesClasses["class"], !0), 
                    series.style({
                        fill: function(d) {
                            return d.color;
                        }
                    }), series.exit().remove(), series;
                }
                function drawDefaultShapes(data, series, layout, itemCS, filterZeros, hasSelection) {
                    var dataSelector;
                    dataSelector = filterZeros ? function(d) {
                        var filteredData = _.filter(d.data, function(datapoint) {
                            return !!datapoint.value;
                        });
                        return filteredData;
                    } : function(d) {
                        return d.data;
                    };
                    var shapeSelection = series.selectAll(itemCS.selector), shapes = shapeSelection.data(dataSelector, function(d) {
                        return d.key;
                    });
                    return shapes.enter().append(rectName).attr("class", function(d) {
                        return itemCS["class"].concat(d.highlight ? " highlight" : "");
                    }), shapes.style("fill-opacity", function(d) {
                        return ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, data.hasHighlights);
                    }).style("fill", function(d) {
                        return d.color !== data.series[d.seriesIndex].color ? d.color : null;
                    }).attr(layout.shapeLayout), shapes.exit().remove(), shapes;
                }
                function drawDefaultLabels(series, context, layout, viewPort, isAnimator, animationDuration) {
                    if (void 0 === isAnimator && (isAnimator = !1), series) {
                        for (var seriesData = series.data(), dataPoints = [], i = 0, len = seriesData.length; len > i; i++) Array.prototype.push.apply(dataPoints, seriesData[i].data);
                        return visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPoints, context, layout, viewPort, isAnimator, animationDuration);
                    }
                    visuals.dataLabelUtils.cleanDataLabels(context);
                }
                function normalizeInfinityInScale(scale) {
                    for (var scaledDomain = scale.domain(), i = 0, len = scaledDomain.length; len > i; ++i) scaledDomain[i] === Number.POSITIVE_INFINITY ? scaledDomain[i] = Number.MAX_VALUE : scaledDomain[i] === Number.NEGATIVE_INFINITY && (scaledDomain[i] = -Number.MAX_VALUE);
                    scale.domain(scaledDomain);
                }
                function calculatePosition(d, axisOptions) {
                    var xScale = axisOptions.xScale, yScale = axisOptions.yScale, scaledY0 = yScale(0), scaledX0 = xScale(0);
                    switch (d.chartType) {
                      case visuals.ColumnChartType.stackedBar:
                      case visuals.ColumnChartType.hundredPercentStackedBar:
                        return scaledX0 + Math.abs(visuals.AxisHelper.diffScaled(xScale, 0, d.valueAbsolute)) + visuals.AxisHelper.diffScaled(xScale, d.position - d.valueAbsolute, 0) + visuals.dataLabelUtils.defaultColumnLabelMargin;

                      case visuals.ColumnChartType.clusteredBar:
                        return scaledX0 + visuals.AxisHelper.diffScaled(xScale, Math.max(0, d.value), 0) + visuals.dataLabelUtils.defaultColumnLabelMargin;

                      case visuals.ColumnChartType.stackedColumn:
                      case visuals.ColumnChartType.hundredPercentStackedColumn:
                        return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0) - visuals.dataLabelUtils.defaultColumnLabelMargin;

                      case visuals.ColumnChartType.clusteredColumn:
                        return scaledY0 + visuals.AxisHelper.diffScaled(yScale, Math.max(0, d.value), 0) - visuals.dataLabelUtils.defaultColumnLabelMargin;
                    }
                }
                ColumnUtil.DimmedOpacity = .4, ColumnUtil.DefaultOpacity = 1, ColumnUtil.applyUserMinMax = applyUserMinMax, 
                ColumnUtil.transformDomain = transformDomain, ColumnUtil.getCategoryAxis = getCategoryAxis, 
                ColumnUtil.applyInteractivity = applyInteractivity, ColumnUtil.getFillOpacity = getFillOpacity, 
                ColumnUtil.getClosestColumnIndex = getClosestColumnIndex, ColumnUtil.setChosenColumnOpacity = setChosenColumnOpacity, 
                ColumnUtil.drawSeries = drawSeries, ColumnUtil.drawDefaultShapes = drawDefaultShapes, 
                ColumnUtil.drawDefaultLabels = drawDefaultLabels, ColumnUtil.normalizeInfinityInScale = normalizeInfinityInScale, 
                ColumnUtil.calculatePosition = calculatePosition;
            }(ColumnUtil = visuals.ColumnUtil || (visuals.ColumnUtil = {}));
            var ClusteredUtil;
            !function(ClusteredUtil) {
                function clearColumns(mainGraphicsContext, itemCS) {
                    var cols = mainGraphicsContext.selectAll(itemCS.selector).data([]);
                    cols.exit().remove();
                }
                ClusteredUtil.clearColumns = clearColumns;
            }(ClusteredUtil = visuals.ClusteredUtil || (visuals.ClusteredUtil = {}));
            var StackedUtil;
            !function(StackedUtil) {
                function getSize(scale, size, zeroVal) {
                    return void 0 === zeroVal && (zeroVal = 0), visuals.AxisHelper.diffScaled(scale, zeroVal, size);
                }
                function calcValueDomain(data, is100pct) {
                    var defaultNumberRange = {
                        min: 0,
                        max: 10
                    };
                    if (0 === data.length) return defaultNumberRange;
                    var min = d3.min(data, function(d) {
                        return d3.min(d.data, function(e) {
                            return e.position - e.valueAbsolute;
                        });
                    }), max = d3.max(data, function(d) {
                        return d3.max(d.data, function(e) {
                            return e.position;
                        });
                    });
                    return is100pct && (min = powerbi.Double.roundToPrecision(min, PctRoundingError), 
                    max = powerbi.Double.roundToPrecision(max, PctRoundingError)), {
                        min: min,
                        max: max
                    };
                }
                function getStackedMultiplier(dataView, rowIdx, seriesCount, categoryCount, converterStrategy) {
                    for (var pos = 0, neg = 0, i = 0; seriesCount > i; i++) {
                        var value = converterStrategy.getValueBySeriesAndCategory(i, rowIdx);
                        value = visuals.AxisHelper.normalizeNonFiniteNumber(value), value > 0 ? pos += value : 0 > value && (neg -= value);
                    }
                    var absTotal = pos + neg;
                    return {
                        pos: pos ? pos / absTotal / pos : 1,
                        neg: neg ? neg / absTotal / neg : 1
                    };
                }
                function clearColumns(mainGraphicsContext, itemCS) {
                    var bars = mainGraphicsContext.selectAll(itemCS.selector).data([]);
                    bars.exit().remove();
                }
                var PctRoundingError = 1e-4;
                StackedUtil.getSize = getSize, StackedUtil.calcValueDomain = calcValueDomain, StackedUtil.getStackedMultiplier = getStackedMultiplier, 
                StackedUtil.clearColumns = clearColumns;
            }(StackedUtil = visuals.StackedUtil || (visuals.StackedUtil = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var converterHelper, DataRoleHelper = powerbi.data.DataRoleHelper;
            !function(converterHelper) {
                function categoryIsAlsoSeriesRole(dataView, seriesRoleName, categoryRoleName) {
                    if (dataView.categories && dataView.categories.length > 0) {
                        var category = dataView.categories[0];
                        return category.source && DataRoleHelper.hasRole(category.source, seriesRoleName) && DataRoleHelper.hasRole(category.source, categoryRoleName);
                    }
                    return !1;
                }
                function getPivotedCategories(dataView, formatStringProp) {
                    if (dataView.categories && dataView.categories.length > 0) {
                        var category = dataView.categories[0], categoryValues = category.values;
                        return category.values.length > 0 ? {
                            categories: categoryValues,
                            categoryFormatter: visuals.valueFormatter.create({
                                format: visuals.valueFormatter.getFormatString(category.source, formatStringProp),
                                value: categoryValues[0],
                                value2: categoryValues[categoryValues.length - 1],
                                displayUnitSystemType: powerbi.DisplayUnitSystemType.Verbose
                            }),
                            categoryIdentities: category.identity,
                            categoryObjects: category.objects
                        } : {
                            categories: [],
                            categoryFormatter: {
                                format: visuals.valueFormatter.format
                            }
                        };
                    }
                    return defaultCategories();
                }
                function getSeriesName(source) {
                    return void 0 !== source.groupName ? source.groupName : source.queryName;
                }
                function getFormattedLegendLabel(source, values, formatStringProp) {
                    var sourceForFormat = source, nameForFormat = source.displayName;
                    return void 0 !== source.groupName && (sourceForFormat = values.source, nameForFormat = source.groupName), 
                    visuals.valueFormatter.format(nameForFormat, visuals.valueFormatter.getFormatString(sourceForFormat, formatStringProp));
                }
                function defaultCategories() {
                    return {
                        categories: [ null ],
                        categoryFormatter: {
                            format: visuals.valueFormatter.format
                        }
                    };
                }
                function createAxesLabels(categoryAxisProperties, valueAxisProperties, category, values) {
                    var xAxisLabel = null, yAxisLabel = null;
                    if (categoryAxisProperties && category && category.displayName && (xAxisLabel = category.displayName), 
                    valueAxisProperties) {
                        var valuesNames = [];
                        values && (valuesNames = values.map(function(v) {
                            return v ? v.displayName : "";
                        }).filter(function(value, index, self) {
                            return "" !== value && self.indexOf(value) === index;
                        }), yAxisLabel = visuals.valueFormatter.formatListAnd(valuesNames));
                    }
                    return {
                        xAxisLabel: xAxisLabel,
                        yAxisLabel: yAxisLabel
                    };
                }
                function isImageUrlColumn(column) {
                    var misc = getMiscellaneousTypeDescriptor(column);
                    return null != misc && misc.imageUrl === !0;
                }
                function isWebUrlColumn(column) {
                    var misc = getMiscellaneousTypeDescriptor(column);
                    return null != misc && misc.webUrl === !0;
                }
                function getMiscellaneousTypeDescriptor(column) {
                    return column && column.type && column.type.misc;
                }
                function hasImageUrlColumn(dataView) {
                    return dataView && dataView.metadata && !_.isEmpty(dataView.metadata.columns) ? _.any(dataView.metadata.columns, function(column) {
                        return isImageUrlColumn(column) === !0;
                    }) : !1;
                }
                function formatFromMetadataColumn(value, column, formatStringProp) {
                    var formatString = visuals.valueFormatter.getFormatString(column, formatStringProp, !0);
                    return !formatString && column && (formatString = column.format), visuals.valueFormatter.format(value, formatString);
                }
                converterHelper.categoryIsAlsoSeriesRole = categoryIsAlsoSeriesRole, converterHelper.getPivotedCategories = getPivotedCategories, 
                converterHelper.getSeriesName = getSeriesName, converterHelper.getFormattedLegendLabel = getFormattedLegendLabel, 
                converterHelper.createAxesLabels = createAxesLabels, converterHelper.isImageUrlColumn = isImageUrlColumn, 
                converterHelper.isWebUrlColumn = isWebUrlColumn, converterHelper.hasImageUrlColumn = hasImageUrlColumn, 
                converterHelper.formatFromMetadataColumn = formatFromMetadataColumn;
            }(converterHelper = visuals.converterHelper || (visuals.converterHelper = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var dataLabelUtils, createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, PixelConverter = jsCommon.PixelConverter, LabelStyle = visuals.labelStyle;
            !function(dataLabelUtils) {
                function updateLabelSettingsFromLabelsObject(labelsObj, labelSettings) {
                    labelsObj && (void 0 !== labelsObj.show && (labelSettings.show = labelsObj.show), 
                    void 0 !== labelsObj.showSeries && (labelSettings.show = labelsObj.showSeries), 
                    void 0 !== labelsObj.color && (labelSettings.labelColor = labelsObj.color.solid.color), 
                    void 0 !== labelsObj.labelDisplayUnits && (labelSettings.displayUnits = labelsObj.labelDisplayUnits), 
                    void 0 !== labelsObj.labelPrecision && (labelSettings.precision = labelsObj.labelPrecision >= 0 ? labelsObj.labelPrecision : dataLabelUtils.defaultLabelPrecision), 
                    void 0 !== labelsObj.fontSize && (labelSettings.fontSize = labelsObj.fontSize), 
                    void 0 !== labelsObj.showAll && (labelSettings.showLabelPerSeries = labelsObj.showAll), 
                    void 0 !== labelsObj.labelStyle && (labelSettings.labelStyle = labelsObj.labelStyle), 
                    labelsObj.labelPosition && (labelSettings.position = labelsObj.labelPosition));
                }
                function updateLineChartLabelSettingsFromLabelsObject(labelsObj, labelSettings) {
                    updateLabelSettingsFromLabelsObject(labelsObj, labelSettings), labelsObj && void 0 !== labelsObj.labelDensity && (labelSettings.labelDensity = labelsObj.labelDensity);
                }
                function getDefaultLabelSettings(show, labelColor, fontSize) {
                    return void 0 === show && (show = !1), {
                        show: show,
                        position: 0,
                        displayUnits: 0,
                        precision: dataLabelUtils.defaultLabelPrecision,
                        labelColor: labelColor || dataLabelUtils.defaultLabelColor,
                        fontSize: fontSize || dataLabelUtils.DefaultFontSizeInPt
                    };
                }
                function getDefaultCardLabelSettings(labelColor, categoryLabelColor, fontSize) {
                    var labelSettings = getDefaultLabelSettings(!0, labelColor, fontSize);
                    return labelSettings.showCategory = !0, labelSettings.categoryLabelColor = categoryLabelColor, 
                    labelSettings;
                }
                function getDefaultTreemapLabelSettings() {
                    return {
                        show: !1,
                        displayUnits: 0,
                        precision: dataLabelUtils.defaultLabelPrecision,
                        labelColor: dataLabelUtils.defaultInsideLabelColor,
                        showCategory: !0
                    };
                }
                function getDefaultSunburstLabelSettings() {
                    return {
                        show: !1,
                        labelColor: dataLabelUtils.defaultInsideLabelColor,
                        fontSize: dataLabelUtils.DefaultFontSizeInPt,
                        displayUnits: 0,
                        precision: dataLabelUtils.defaultLabelPrecision,
                        showCategory: !0
                    };
                }
                function getDefaultColumnLabelSettings(isLabelPositionInside) {
                    var labelSettings = getDefaultLabelSettings(!1, void 0);
                    return labelSettings.position = null, labelSettings.labelColor = void 0, labelSettings;
                }
                function getDefaultPointLabelSettings() {
                    return {
                        show: !1,
                        position: 0,
                        displayUnits: 0,
                        precision: dataLabelUtils.defaultLabelPrecision,
                        labelColor: dataLabelUtils.defaultLabelColor,
                        fontSize: dataLabelUtils.DefaultFontSizeInPt
                    };
                }
                function getDefaultLineChartLabelSettings(isComboChart) {
                    return {
                        show: !1,
                        position: 0,
                        displayUnits: 0,
                        precision: dataLabelUtils.defaultLabelPrecision,
                        labelColor: dataLabelUtils.defaultLabelColor,
                        fontSize: dataLabelUtils.DefaultFontSizeInPt,
                        labelDensity: dataLabelUtils.defaultLabelDensity
                    };
                }
                function getDefaultMapLabelSettings() {
                    return {
                        show: !1,
                        showCategory: !1,
                        position: 0,
                        displayUnits: 0,
                        precision: dataLabelUtils.defaultLabelPrecision,
                        labelColor: dataLabelUtils.defaultInsideLabelColor,
                        fontSize: dataLabelUtils.DefaultFontSizeInPt
                    };
                }
                function getDefaultDonutLabelSettings() {
                    var labelSettings = dataLabelUtils.getDefaultLabelSettings(!0, dataLabelUtils.defaultLabelColor, dataLabelUtils.DefaultFontSizeInPt);
                    return labelSettings.labelStyle = LabelStyle.category, labelSettings;
                }
                function getDefaultGaugeLabelSettings() {
                    return {
                        show: !0,
                        displayUnits: 0,
                        precision: dataLabelUtils.defaultLabelPrecision,
                        labelColor: null,
                        position: null,
                        fontSize: dataLabelUtils.minLabelFontSize
                    };
                }
                function getDefaultKpiLabelSettings() {
                    return {
                        show: !1,
                        displayUnits: 0,
                        precision: dataLabelUtils.defaultLabelPrecision,
                        labelColor: dataLabelUtils.defaultLabelColor,
                        position: null,
                        showCategory: !0
                    };
                }
                function getLabelPrecision(precision, format) {
                    if (precision !== dataLabelUtils.defaultLabelPrecision) return precision;
                    if ("g" !== format && "G" !== format) {
                        if (format) {
                            var positiveFormat = powerbi.NumberFormat.getComponents(format).positive, formatMetadata = powerbi.NumberFormat.getCustomFormatMetadata(positiveFormat, !0);
                            if (formatMetadata.hasDots) return formatMetadata.precision;
                        }
                        return defaultCountLabelPrecision;
                    }
                }
                function drawDefaultLabelsForDataPointChart(data, context, layout, viewport, isAnimator, animationDuration, hasSelection) {
                    void 0 === isAnimator && (isAnimator = !1);
                    var dataLabelManager = new powerbi.DataLabelManager(), filteredData = dataLabelManager.hideCollidedLabels(viewport, data, layout), hasAnimation = isAnimator && !!animationDuration, labels = selectLabels(filteredData, context, !1, hasAnimation);
                    return labels ? (hasAnimation ? (labels.text(function(d) {
                        return d.labeltext;
                    }).transition().duration(animationDuration).style(layout.style).style("opacity", hasSelection ? function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.selected, !1, hasSelection, !1);
                    } : 1).attr({
                        x: function(d) {
                            return d.labelX;
                        },
                        y: function(d) {
                            return d.labelY;
                        }
                    }), labels.exit().transition().duration(animationDuration).style("opacity", 0).remove()) : (labels.attr({
                        x: function(d) {
                            return d.labelX;
                        },
                        y: function(d) {
                            return d.labelY;
                        }
                    }).text(function(d) {
                        return d.labeltext;
                    }).style(layout.style), labels.exit().remove()), labels) : void 0;
                }
                function selectLabels(filteredData, context, isDonut, forAnimation) {
                    if (void 0 === isDonut && (isDonut = !1), void 0 === forAnimation && (forAnimation = !1), 
                    0 === filteredData.length) return cleanDataLabels(context, !0), null;
                    context.select(labelGraphicsContextClass.selector).empty() && context.append("g").classed(labelGraphicsContextClass["class"], !0);
                    var hasKey = null != filteredData[0].key, hasDataPointIdentity = null != filteredData[0].identity, getIdentifier = hasKey ? function(d) {
                        return d.key;
                    } : hasDataPointIdentity ? function(d) {
                        return d.identity.getKey();
                    } : void 0, labels = isDonut ? context.select(labelGraphicsContextClass.selector).selectAll(labelsClass.selector).data(filteredData, function(d) {
                        return d.data.identity.getKey();
                    }) : null != getIdentifier ? context.select(labelGraphicsContextClass.selector).selectAll(labelsClass.selector).data(filteredData, getIdentifier) : context.select(labelGraphicsContextClass.selector).selectAll(labelsClass.selector).data(filteredData), newLabels = labels.enter().append("text").classed(labelsClass["class"], !0);
                    return forAnimation && newLabels.style("opacity", 0), labels;
                }
                function cleanDataLabels(context, removeLines) {
                    void 0 === removeLines && (removeLines = !1);
                    var empty = [], labels = context.selectAll(labelsClass.selector).data(empty);
                    if (labels.exit().remove(), context.selectAll(labelGraphicsContextClass.selector).remove(), 
                    removeLines) {
                        var lines = context.selectAll(lineClass.selector).data(empty);
                        lines.exit().remove(), context.selectAll(linesGraphicsContextClass.selector).remove();
                    }
                }
                function setHighlightedLabelsOpacity(context, hasSelection, hasHighlights) {
                    context.selectAll(labelsClass.selector).style("fill-opacity", function(d) {
                        var labelOpacity = visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights) < 1 ? 0 : 1;
                        return labelOpacity;
                    });
                }
                function getLabelFormattedText(options) {
                    var properties = {
                        text: options.formatter ? options.formatter.format(options.label) : powerbi.formattingService.formatValue(options.label, options.format),
                        fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
                        fontSize: PixelConverter.fromPoint(options.fontSize),
                        fontWeight: dataLabelUtils.LabelTextProperties.fontWeight
                    };
                    return powerbi.TextMeasurementService.getTailoredTextOrDefault(properties, options.maxWidth ? options.maxWidth : dataLabelUtils.maxLabelWidth);
                }
                function getLabelLayoutXYForWaterfall(xAxisProperties, categoryWidth, yAxisProperties, dataDomain) {
                    return {
                        x: function(d) {
                            return xAxisProperties.scale(d.categoryIndex) + categoryWidth / 2;
                        },
                        y: function(d) {
                            return getWaterfallLabelYPosition(yAxisProperties.scale, d, dataDomain);
                        }
                    };
                }
                function getWaterfallLabelYPosition(scale, d, dataDomain) {
                    var yValue = scale(0) - scale(Math.abs(d.value)), yPos = scale(d.position), scaleMinDomain = scale(dataDomain[0]), endPosition = scale(d.position + d.value);
                    if (d.value < 0) {
                        var properties = {
                            text: d.labeltext,
                            fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
                            fontSize: dataLabelUtils.LabelTextProperties.fontSize,
                            fontWeight: dataLabelUtils.LabelTextProperties.fontWeight
                        }, outsideBelowPosition = yPos + yValue + powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
                        if (scaleMinDomain > outsideBelowPosition) return outsideBelowPosition;
                    } else {
                        var outsideAbovePosition = yPos - yValue - dataLabelUtils.labelMargin;
                        if (outsideAbovePosition > 0) return outsideAbovePosition;
                    }
                    return d.isLabelInside = !0, getWaterfallInsideLabelYPosition(yPos, endPosition, scaleMinDomain);
                }
                function getWaterfallInsideLabelYPosition(startPosition, endPosition, scaleMinDomain) {
                    return startPosition = 0 > startPosition ? 0 : startPosition, startPosition = startPosition > scaleMinDomain ? scaleMinDomain : startPosition, 
                    endPosition = 0 > endPosition ? 0 : endPosition, endPosition = endPosition > scaleMinDomain ? scaleMinDomain : endPosition, 
                    Math.abs(endPosition - startPosition) / 2 + Math.min(startPosition, endPosition);
                }
                function doesDataLabelFitInShape(d, yAxisProperties, layout) {
                    if (null == d || null === d.value) return !1;
                    var properties = {
                        text: layout.labelText(d),
                        fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
                        fontSize: dataLabelUtils.LabelTextProperties.fontSize,
                        fontWeight: dataLabelUtils.LabelTextProperties.fontWeight
                    }, outsidePosition = visuals.WaterfallChart.getRectTop(yAxisProperties.scale, d.position, d.value) - dataLabelUtils.labelMargin;
                    if (outsidePosition > 0) return !0;
                    var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties), textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties), shapeWidth = layout.categoryWidth, shapeHeight = Math.abs(visuals.AxisHelper.diffScaled(yAxisProperties.scale, Math.max(0, Math.abs(d.value)), 0));
                    return !(textWidth > shapeWidth || textHeight > shapeHeight);
                }
                function getMapLabelLayout(labelSettings) {
                    return {
                        labelText: function(d) {
                            return getLabelFormattedText({
                                label: d.labeltext,
                                fontSize: labelSettings.fontSize
                            });
                        },
                        labelLayout: {
                            x: function(d) {
                                return d.x;
                            },
                            y: function(d) {
                                var margin = d.radius + dataLabelUtils.labelMargin;
                                return 0 === labelSettings.position ? d.y - margin : d.y + margin;
                            }
                        },
                        filter: function(d) {
                            return null != d && null != d.labeltext;
                        },
                        style: {
                            fill: function(d) {
                                return d.labelFill;
                            },
                            "font-size": PixelConverter.fromPoint(labelSettings.fontSize)
                        }
                    };
                }
                function getColumnChartLabelLayout(data, labelLayoutXY, isColumn, isHundredPercent, axisFormatter, axisOptions, interactivityService, visualWidth) {
                    var formatOverride = isHundredPercent ? dataLabelUtils.hundredPercentFormat : null, formattersCache = createColumnFormatterCacheManager(), hasSelection = interactivityService ? interactivityService.hasSelection() : !1;
                    return {
                        labelText: function(d) {
                            var formatString = null != formatOverride ? formatOverride : d.labelFormatString, value2 = getDisplayUnitValueFromAxisFormatter(axisFormatter, d.labelSettings), formatter = formattersCache.getOrCreate(formatString, d.labelSettings, value2);
                            return getLabelFormattedText({
                                label: formatter.format(d.value),
                                maxWidth: dataLabelUtils.maxLabelWidth
                            });
                        },
                        labelLayout: labelLayoutXY,
                        filter: function(d) {
                            return dataLabelUtils.getColumnChartLabelFilter(d, hasSelection, data.hasHighlights, axisOptions, visualWidth);
                        },
                        style: {
                            fill: function(d) {
                                return d.labelFill;
                            },
                            "text-anchor": isColumn ? "middle" : "start"
                        }
                    };
                }
                function validateLabelsSize(d, axisOptions, visualWidth) {
                    var shapeWidth, shapeHeight, xScale = axisOptions.xScale, yScale = axisOptions.yScale, columnWidth = axisOptions.columnWidth, properties = {
                        text: d.labeltext,
                        fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
                        fontSize: dataLabelUtils.LabelTextProperties.fontSize,
                        fontWeight: dataLabelUtils.LabelTextProperties.fontWeight
                    }, textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties), textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties), inside = !1, outsidePosition = visuals.ColumnUtil.calculatePosition(d, axisOptions);
                    switch (d.chartType) {
                      case visuals.ColumnChartType.stackedBar:
                      case visuals.ColumnChartType.hundredPercentStackedBar:
                        (!d.lastSeries || outsidePosition + textWidth > visualWidth || d.chartType === visuals.ColumnChartType.hundredPercentStackedBar) && (shapeWidth = -visuals.StackedUtil.getSize(xScale, d.valueAbsolute), 
                        shapeHeight = columnWidth, inside = !0);
                        break;

                      case visuals.ColumnChartType.clusteredBar:
                        outsidePosition + textWidth > visualWidth && (shapeWidth = Math.abs(visuals.AxisHelper.diffScaled(xScale, 0, d.value)), 
                        shapeHeight = columnWidth, inside = !0);
                        break;

                      case visuals.ColumnChartType.stackedColumn:
                      case visuals.ColumnChartType.hundredPercentStackedColumn:
                        (!d.lastSeries || 0 >= outsidePosition || d.chartType === visuals.ColumnChartType.hundredPercentStackedColumn) && (shapeWidth = columnWidth, 
                        shapeHeight = visuals.StackedUtil.getSize(yScale, d.valueAbsolute), inside = !0);
                        break;

                      case visuals.ColumnChartType.clusteredColumn:
                        0 >= outsidePosition && (shapeWidth = columnWidth, shapeHeight = Math.abs(visuals.AxisHelper.diffScaled(yScale, 0, d.value)), 
                        inside = !0);
                        break;

                      default:
                        return !0;
                    }
                    return !inside || !(textWidth > shapeWidth || textHeight > shapeHeight);
                }
                function getColumnChartLabelFilter(d, hasSelection, hasHighlights, axisOptions, visualWidth) {
                    var shapesOpacity = hasSelection ? visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights) : visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, hasHighlights);
                    return null != d && null != d.value && validateLabelsSize(d, axisOptions, visualWidth) && 1 === shapesOpacity;
                }
                function getScatterChartLabelLayout(xScale, yScale, labelSettings, viewport, sizeRange) {
                    return {
                        labelText: function(d) {
                            return getLabelFormattedText({
                                label: d.formattedCategory.getValue(),
                                maxWidth: 2 * dataLabelUtils.maxLabelWidth
                            });
                        },
                        labelLayout: {
                            x: function(d) {
                                return xScale(d.x);
                            },
                            y: function(d) {
                                var margin = visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, viewport) + dataLabelUtils.labelMargin;
                                return 0 === labelSettings.position ? yScale(d.y) - margin : yScale(d.y) + margin;
                            }
                        },
                        filter: function(d) {
                            return null != d && null != d.formattedCategory.getValue();
                        },
                        style: {
                            fill: function(d) {
                                return d.labelFill;
                            }
                        }
                    };
                }
                function getLineChartLabelLayout(xScale, yScale, labelSettings, isScalar, axisFormatter) {
                    var formattersCache = createColumnFormatterCacheManager();
                    return {
                        labelText: function(d) {
                            var value2 = getDisplayUnitValueFromAxisFormatter(axisFormatter, d.labelSettings), formatter = formattersCache.getOrCreate(d.labelFormatString, d.labelSettings, value2);
                            return getLabelFormattedText({
                                label: formatter.format(d.value)
                            });
                        },
                        labelLayout: {
                            x: function(d) {
                                return xScale(isScalar ? d.categoryValue : d.categoryIndex);
                            },
                            y: function(d) {
                                return 0 === labelSettings.position ? yScale(d.value) - dataLabelUtils.labelMargin : yScale(d.value) + dataLabelUtils.labelMargin;
                            }
                        },
                        filter: function(d) {
                            return null != d && null != d.value;
                        },
                        style: {
                            fill: function(d) {
                                return d.labelFill;
                            },
                            "font-size": function(d) {
                                return PixelConverter.fromPoint(d.labelSettings.fontSize);
                            }
                        }
                    };
                }
                function enumerateDataLabels(options) {
                    if (options.dataLabelsSettings) {
                        var instance = {
                            objectName: "labels",
                            selector: options.selector,
                            properties: {}
                        };
                        if (options.show && options.selector ? instance.properties.showSeries = options.dataLabelsSettings.show : options.show && (instance.properties.show = options.dataLabelsSettings.show), 
                        instance.properties.color = options.dataLabelsSettings.labelColor || dataLabelUtils.defaultLabelColor, 
                        options.displayUnits && (instance.properties.labelDisplayUnits = options.dataLabelsSettings.displayUnits), 
                        options.precision) {
                            var precision = options.dataLabelsSettings.precision;
                            instance.properties.labelPrecision = precision === dataLabelUtils.defaultLabelPrecision ? null : precision;
                        }
                        if (options.position && (instance.properties.labelPosition = options.dataLabelsSettings.position, 
                        options.positionObject && (instance.validValues = {
                            labelPosition: options.positionObject
                        })), options.labelStyle && (instance.properties.labelStyle = options.dataLabelsSettings.labelStyle), 
                        options.fontSize && (instance.properties.fontSize = options.dataLabelsSettings.fontSize), 
                        options.labelDensity) {
                            var lineChartSettings = options.dataLabelsSettings;
                            lineChartSettings && (instance.properties.labelDensity = lineChartSettings.labelDensity);
                        }
                        return options.showAll && (instance.properties.showAll = options.dataLabelsSettings.showLabelPerSeries), 
                        options.enumeration.pushInstance(instance);
                    }
                }
                function enumerateCategoryLabels(enumeration, dataLabelsSettings, withFill, isShowCategory, fontSize) {
                    void 0 === isShowCategory && (isShowCategory = !1);
                    var labelSettings = dataLabelsSettings ? dataLabelsSettings : getDefaultPointLabelSettings(), instance = {
                        objectName: "categoryLabels",
                        selector: null,
                        properties: {
                            show: isShowCategory ? labelSettings.showCategory : labelSettings.show,
                            fontSize: dataLabelsSettings ? dataLabelsSettings.fontSize : dataLabelUtils.DefaultFontSizeInPt
                        }
                    };
                    withFill && (instance.properties.color = labelSettings.categoryLabelColor ? labelSettings.categoryLabelColor : labelSettings.labelColor), 
                    fontSize && (instance.properties.fontSize = fontSize), enumeration.pushInstance(instance);
                }
                function getDisplayUnitValueFromAxisFormatter(axisFormatter, labelSettings) {
                    return axisFormatter && axisFormatter.displayUnit && 0 === labelSettings.displayUnits ? axisFormatter.displayUnit.value : null;
                }
                function createColumnFormatterCacheManager() {
                    return {
                        cache: {
                            defaultFormatter: null
                        },
                        getOrCreate: function(formatString, labelSetting, value2) {
                            if (formatString) {
                                var cacheKeyObject = {
                                    formatString: formatString,
                                    displayUnits: labelSetting.displayUnits,
                                    precision: getLabelPrecision(labelSetting.precision, formatString),
                                    value2: value2
                                }, cacheKey = JSON.stringify(cacheKeyObject);
                                return this.cache[cacheKey] || (this.cache[cacheKey] = visuals.valueFormatter.create(getOptionsForLabelFormatter(labelSetting, formatString, value2, cacheKeyObject.precision))), 
                                this.cache[cacheKey];
                            }
                            return this.cache.defaultFormatter || (this.cache.defaultFormatter = visuals.valueFormatter.create(getOptionsForLabelFormatter(labelSetting, formatString, value2, labelSetting.precision))), 
                            this.cache.defaultFormatter;
                        }
                    };
                }
                function getOptionsForLabelFormatter(labelSetting, formatString, value2, precision) {
                    return {
                        displayUnitSystemType: powerbi.DisplayUnitSystemType.DataLabels,
                        format: formatString,
                        precision: precision,
                        value: labelSetting.displayUnits,
                        value2: value2,
                        allowFormatBeautification: !0
                    };
                }
                function isTextWidthOverflows(textWidth, maxTextWidth) {
                    return textWidth > maxTextWidth;
                }
                function isTextHeightOverflows(textHeight, innerChordLength) {
                    return textHeight > innerChordLength;
                }
                dataLabelUtils.minLabelFontSize = 8, dataLabelUtils.labelMargin = 8, dataLabelUtils.maxLabelWidth = 50, 
                dataLabelUtils.defaultColumnLabelMargin = 5, dataLabelUtils.defaultColumnHalfLabelHeight = 4, 
                dataLabelUtils.defaultLabelDensity = "50", dataLabelUtils.DefaultDy = "-0.15em", 
                dataLabelUtils.DefaultFontSizeInPt = 9, dataLabelUtils.StandardFontFamily = visuals.Font.Family.regular.css, 
                dataLabelUtils.LabelTextProperties = {
                    fontFamily: visuals.Font.Family.regularSecondary.css,
                    fontSize: PixelConverter.fromPoint(dataLabelUtils.DefaultFontSizeInPt),
                    fontWeight: "normal"
                }, dataLabelUtils.defaultLabelColor = "#777777", dataLabelUtils.defaultInsideLabelColor = "#ffffff", 
                dataLabelUtils.hundredPercentFormat = "0.00 %;-0.00 %;0.00 %", dataLabelUtils.defaultLabelPrecision = void 0;
                var defaultCountLabelPrecision = 0, labelGraphicsContextClass = createClassAndSelector("labels"), linesGraphicsContextClass = createClassAndSelector("lines"), labelsClass = createClassAndSelector("data-labels"), lineClass = createClassAndSelector("line-label");
                dataLabelUtils.updateLabelSettingsFromLabelsObject = updateLabelSettingsFromLabelsObject, 
                dataLabelUtils.updateLineChartLabelSettingsFromLabelsObject = updateLineChartLabelSettingsFromLabelsObject, 
                dataLabelUtils.getDefaultLabelSettings = getDefaultLabelSettings, dataLabelUtils.getDefaultCardLabelSettings = getDefaultCardLabelSettings, 
                dataLabelUtils.getDefaultTreemapLabelSettings = getDefaultTreemapLabelSettings, 
                dataLabelUtils.getDefaultSunburstLabelSettings = getDefaultSunburstLabelSettings, 
                dataLabelUtils.getDefaultColumnLabelSettings = getDefaultColumnLabelSettings, dataLabelUtils.getDefaultPointLabelSettings = getDefaultPointLabelSettings, 
                dataLabelUtils.getDefaultLineChartLabelSettings = getDefaultLineChartLabelSettings, 
                dataLabelUtils.getDefaultMapLabelSettings = getDefaultMapLabelSettings, dataLabelUtils.getDefaultDonutLabelSettings = getDefaultDonutLabelSettings, 
                dataLabelUtils.getDefaultGaugeLabelSettings = getDefaultGaugeLabelSettings, dataLabelUtils.getDefaultKpiLabelSettings = getDefaultKpiLabelSettings, 
                dataLabelUtils.getLabelPrecision = getLabelPrecision, dataLabelUtils.drawDefaultLabelsForDataPointChart = drawDefaultLabelsForDataPointChart, 
                dataLabelUtils.cleanDataLabels = cleanDataLabels, dataLabelUtils.setHighlightedLabelsOpacity = setHighlightedLabelsOpacity, 
                dataLabelUtils.getLabelFormattedText = getLabelFormattedText, dataLabelUtils.getLabelLayoutXYForWaterfall = getLabelLayoutXYForWaterfall, 
                dataLabelUtils.doesDataLabelFitInShape = doesDataLabelFitInShape, dataLabelUtils.getMapLabelLayout = getMapLabelLayout, 
                dataLabelUtils.getColumnChartLabelLayout = getColumnChartLabelLayout, dataLabelUtils.getColumnChartLabelFilter = getColumnChartLabelFilter, 
                dataLabelUtils.getScatterChartLabelLayout = getScatterChartLabelLayout, dataLabelUtils.getLineChartLabelLayout = getLineChartLabelLayout, 
                dataLabelUtils.enumerateDataLabels = enumerateDataLabels, dataLabelUtils.enumerateCategoryLabels = enumerateCategoryLabels, 
                dataLabelUtils.createColumnFormatterCacheManager = createColumnFormatterCacheManager, 
                dataLabelUtils.getOptionsForLabelFormatter = getOptionsForLabelFormatter, dataLabelUtils.isTextWidthOverflows = isTextWidthOverflows, 
                dataLabelUtils.isTextHeightOverflows = isTextHeightOverflows;
            }(dataLabelUtils = visuals.dataLabelUtils || (visuals.dataLabelUtils = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var DonutLabelUtils;
            !function(DonutLabelUtils) {
                function getLabelLeaderLineForDonutChart(donutArcDescriptor, donutProperties, parentPoint, sliceArc) {
                    void 0 === sliceArc && (sliceArc = 0);
                    var textPoint, midPoint, chartPoint, innerLinePointMultiplier = 2.05;
                    if (sliceArc) {
                        var arc = sliceArc, outerRadius = donutProperties.radius * donutProperties.outerArcRadiusRatio, innerRadius = donutProperties.radius / 2 * donutProperties.innerArcRadiusRatio;
                        midPoint = [ Math.cos(arc) * outerRadius, Math.sin(arc) * outerRadius ], chartPoint = [ Math.cos(arc) * innerRadius, Math.sin(arc) * innerRadius ];
                    } else midPoint = donutProperties.outerArc.centroid(donutArcDescriptor), chartPoint = donutProperties.arc.centroid(donutArcDescriptor);
                    var textPointX = parentPoint.x, lineMargin = visuals.NewDataLabelUtils.maxLabelOffset / 2;
                    return textPointX += 0 > textPointX ? -lineMargin : lineMargin, textPoint = [ textPointX, parentPoint.y ], 
                    chartPoint[0] *= innerLinePointMultiplier, chartPoint[1] *= innerLinePointMultiplier, 
                    [ chartPoint, midPoint, textPoint ];
                }
                function getLabelLeaderLinesSizeForDonutChart(leaderLinePoints) {
                    if (leaderLinePoints && leaderLinePoints.length > 2) {
                        var diagonalLineSize = {
                            width: Math.abs(leaderLinePoints[1][0] - leaderLinePoints[0][0]),
                            height: Math.abs(leaderLinePoints[1][1] - leaderLinePoints[0][1])
                        }, horizontalLineSize = {
                            width: Math.abs(leaderLinePoints[2][0] - leaderLinePoints[1][0]),
                            height: DonutLabelUtils.LineStrokeWidth
                        };
                        return [ diagonalLineSize, horizontalLineSize ];
                    }
                    return null;
                }
                function getXPositionForDonutLabel(textPointX) {
                    var margin = 0 > textPointX ? -visuals.NewDataLabelUtils.maxLabelOffset : visuals.NewDataLabelUtils.maxLabelOffset;
                    return textPointX += margin;
                }
                function getSpaceAvailableForDonutLabels(labelXPos, viewport) {
                    return viewport.width / 2 - Math.abs(labelXPos) - visuals.NewDataLabelUtils.maxLabelOffset;
                }
                DonutLabelUtils.LineStrokeWidth = 1, DonutLabelUtils.DiagonalLineIndex = 0, DonutLabelUtils.HorizontalLineIndex = 1, 
                DonutLabelUtils.getLabelLeaderLineForDonutChart = getLabelLeaderLineForDonutChart, 
                DonutLabelUtils.getLabelLeaderLinesSizeForDonutChart = getLabelLeaderLinesSizeForDonutChart, 
                DonutLabelUtils.getXPositionForDonutLabel = getXPositionForDonutLabel, DonutLabelUtils.getSpaceAvailableForDonutLabels = getSpaceAvailableForDonutLabels;
            }(DonutLabelUtils = visuals.DonutLabelUtils || (visuals.DonutLabelUtils = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var NewDataLabelUtils, createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, PixelConverter = jsCommon.PixelConverter;
            !function(NewDataLabelUtils) {
                function drawDefaultLabels(context, dataLabels, numeric, twoRows, hasTooltip) {
                    void 0 === numeric && (numeric = !1), void 0 === twoRows && (twoRows = !1), void 0 === hasTooltip && (hasTooltip = !1);
                    var filteredDataLabels = _.filter(dataLabels, function(d) {
                        return d.isVisible;
                    }), labels = context.selectAll(labelsClass.selector).data(filteredDataLabels, labelKeyFunction);
                    labels.enter().append("text").classed(labelsClass["class"], !0);
                    var labelAttr = {
                        x: function(d) {
                            return d.boundingBox.left + d.boundingBox.width / 2;
                        },
                        y: function(d) {
                            return d.hasBackground ? d.boundingBox.top + d.boundingBox.height - NewDataLabelUtils.verticalLabelBackgroundPadding : d.boundingBox.top + d.boundingBox.height;
                        },
                        dy: "-0.15em"
                    };
                    numeric && (labelAttr.dy = void 0), labels.interrupt().text(function(d) {
                        return d.text;
                    }).attr(labelAttr).style({
                        fill: function(d) {
                            return d.fill;
                        },
                        "font-size": function(d) {
                            return PixelConverter.fromPoint(d.fontSize || NewDataLabelUtils.DefaultLabelFontSizeInPt);
                        },
                        "text-anchor": function(d) {
                            return d.textAnchor;
                        }
                    }), labels.exit().remove();
                    var filteredCategoryLabels = _.filter(twoRows ? dataLabels : [], function(d) {
                        return d.isVisible && !_.isEmpty(d.secondRowText);
                    }), secondLineLabels = context.selectAll(secondLineLabelClass.selector).data(filteredCategoryLabels, function(d, index) {
                        return d.identity ? d.identity.getKeyWithoutHighlight() : index;
                    });
                    return secondLineLabels.enter().append("text").classed(secondLineLabelClass["class"], !0), 
                    labelAttr = {
                        x: function(d) {
                            return d.boundingBox.left + d.boundingBox.width / 2;
                        },
                        y: function(d) {
                            var boundingBoxHeight = void 0 !== d.text ? d.boundingBox.height / 2 : d.boundingBox.height;
                            return d.hasBackground ? d.boundingBox.top + boundingBoxHeight - NewDataLabelUtils.verticalLabelBackgroundPadding : d.boundingBox.top + boundingBoxHeight;
                        },
                        dy: "-0.15em"
                    }, numeric && (labelAttr.dy = void 0), secondLineLabels.interrupt().text(function(d) {
                        return d.secondRowText;
                    }).attr(labelAttr).style({
                        fill: function(d) {
                            return d.fill;
                        },
                        "font-size": function(d) {
                            return PixelConverter.fromPoint(d.fontSize || NewDataLabelUtils.DefaultLabelFontSizeInPt);
                        },
                        "text-anchor": function(d) {
                            return d.textAnchor;
                        }
                    }), secondLineLabels.exit().remove(), hasTooltip && (labels.append("title").text(function(d) {
                        return d.tooltip;
                    }), secondLineLabels.append("title").text(function(d) {
                        return d.tooltip;
                    }), labels.style("pointer-events", "all"), secondLineLabels.style("pointer-events", "all")), 
                    labels;
                }
                function animateDefaultLabels(context, dataLabels, duration, numeric, easeType) {
                    void 0 === numeric && (numeric = !1), void 0 === easeType && (easeType = "cubic-in-out");
                    var labels = context.selectAll(labelsClass.selector).data(_.filter(dataLabels, function(d) {
                        return d.isVisible;
                    }), labelKeyFunction);
                    labels.enter().append("text").classed(labelsClass["class"], !0).style("opacity", 0);
                    var labelAttr = {
                        x: function(d) {
                            return d.boundingBox.left + d.boundingBox.width / 2;
                        },
                        y: function(d) {
                            return d.boundingBox.top + d.boundingBox.height;
                        },
                        dy: "-0.15em"
                    };
                    return numeric && (labelAttr.dy = void 0), labels.text(function(d) {
                        return d.text;
                    }).style({
                        fill: function(d) {
                            return d.fill;
                        },
                        "font-size": function(d) {
                            return PixelConverter.fromPoint(d.fontSize || NewDataLabelUtils.DefaultLabelFontSizeInPt);
                        }
                    }).transition().ease(easeType).duration(duration).attr(labelAttr).style("opacity", 1), 
                    labels.exit().transition().duration(duration).style("opacity", 0).remove(), labels;
                }
                function drawLabelBackground(context, dataLabels, fill, fillOpacity) {
                    var labelRects = context.selectAll("rect").data(_.filter(dataLabels, function(d) {
                        return d.isVisible;
                    }), labelKeyFunction);
                    return labelRects.enter().append("rect"), labelRects.attr({
                        x: function(d) {
                            return d.boundingBox.left - NewDataLabelUtils.horizontalLabelBackgroundPadding;
                        },
                        y: function(d) {
                            return d.boundingBox.top - NewDataLabelUtils.verticalLabelBackgroundPadding;
                        },
                        rx: labelBackgroundRounding,
                        ry: labelBackgroundRounding,
                        width: function(d) {
                            return d.boundingBox.width + 2 * NewDataLabelUtils.horizontalLabelBackgroundPadding;
                        },
                        height: function(d) {
                            return void 0 === d.text && void 0 === d.secondRowText ? 0 : d.boundingBox.height + 2 * NewDataLabelUtils.verticalLabelBackgroundPadding;
                        }
                    }).style("fill", fill ? fill : "#000000").style("fill-opacity", null != fillOpacity ? fillOpacity : 1), 
                    labelRects.exit().remove(), labelRects;
                }
                function drawLabelLeaderLines(context, filteredDataLabels, key, leaderLineColor) {
                    context.select(linesGraphicsContextClass.selector).empty() && context.append("g").classed(linesGraphicsContextClass["class"], !0);
                    var lines = context.select(linesGraphicsContextClass.selector).selectAll("polyline").data(filteredDataLabels, key);
                    lines.enter().append("polyline").classed(lineClass["class"], !0), lines.attr("points", function(d) {
                        return d.leaderLinePoints;
                    }).style({
                        stroke: function(d) {
                            return leaderLineColor ? leaderLineColor : d.fill;
                        },
                        "stroke-width": visuals.DonutLabelUtils.LineStrokeWidth
                    }), lines.exit().remove();
                }
                function getLabelFormattedText(label, format, formatter) {
                    return formatter ? formatter.format(label) : powerbi.formattingService.formatValue(label, format);
                }
                function getDisplayUnitValueFromAxisFormatter(axisFormatter, labelSettings) {
                    return axisFormatter && axisFormatter.displayUnit && 0 === labelSettings.displayUnits ? axisFormatter.displayUnit.value : null;
                }
                function getLabelPrecision(precision, format) {
                    if (precision !== defaultLabelPrecision) return precision;
                    if (format) {
                        var positiveFormat = format.split(";")[0], formatMetadata = powerbi.NumberFormat.getCustomFormatMetadata(positiveFormat, !0);
                        if (formatMetadata.hasDots) return formatMetadata.precision;
                    }
                    return defaultCountLabelPrecision;
                }
                function createColumnFormatterCacheManager() {
                    return {
                        cache: {
                            defaultFormatter: null
                        },
                        getOrCreate: function(formatString, labelSetting, value2) {
                            if (formatString) {
                                var cacheKeyObject = {
                                    formatString: formatString,
                                    displayUnits: labelSetting.displayUnits,
                                    precision: getLabelPrecision(labelSetting.precision, formatString),
                                    value2: value2
                                }, cacheKey = JSON.stringify(cacheKeyObject);
                                return this.cache[cacheKey] || (this.cache[cacheKey] = visuals.valueFormatter.create(getOptionsForLabelFormatter(labelSetting, formatString, value2, cacheKeyObject.precision))), 
                                this.cache[cacheKey];
                            }
                            return this.cache.defaultFormatter || (this.cache.defaultFormatter = visuals.valueFormatter.create(getOptionsForLabelFormatter(labelSetting, formatString, value2, labelSetting.precision))), 
                            this.cache.defaultFormatter;
                        }
                    };
                }
                function getOptionsForLabelFormatter(labelSetting, formatString, value2, precision) {
                    return {
                        displayUnitSystemType: powerbi.DisplayUnitSystemType.DataLabels,
                        format: formatString,
                        precision: precision,
                        value: labelSetting.displayUnits,
                        value2: value2,
                        allowFormatBeautification: !0
                    };
                }
                function removeDuplicates(labelDataPoints) {
                    for (var uniqueLabelDataPoints = [], labelDataPointMap = {}, sameParentIsInArray = function(newValue, array, parentIsRect) {
                        return array.some(function(arrayValue) {
                            return parentIsRect ? visuals.shapes.Rect.equals(newValue.parentShape.rect, arrayValue.rect) : visuals.shapes.Point.equals(newValue.parentShape.point, arrayValue.point);
                        });
                    }, _i = 0, labelDataPoints_1 = labelDataPoints; _i < labelDataPoints_1.length; _i++) {
                        var dataPoint = labelDataPoints_1[_i], parentIsRect = 1 === dataPoint.parentType, resultsFromMap = labelDataPointMap[dataPoint.text];
                        resultsFromMap ? sameParentIsInArray(dataPoint, resultsFromMap, parentIsRect) || (uniqueLabelDataPoints.push(dataPoint), 
                        resultsFromMap.push(dataPoint.parentShape)) : (uniqueLabelDataPoints.push(dataPoint), 
                        labelDataPointMap[dataPoint.text] = [ dataPoint.parentShape ]);
                    }
                    return uniqueLabelDataPoints;
                }
                function getDataLabelLayoutOptions(type) {
                    switch (type) {
                      case 9:
                        return {
                            maximumOffset: visuals.ScatterChart.dataLabelLayoutMaximumOffset,
                            startingOffset: visuals.ScatterChart.dataLabelLayoutStartingOffset,
                            offsetIterationDelta: visuals.ScatterChart.dataLabelLayoutOffsetIterationDelta,
                            allowLeaderLines: !0,
                            attemptToMoveLabelsIntoViewport: !0
                        };

                      default:
                        return {
                            maximumOffset: NewDataLabelUtils.maxLabelOffset,
                            startingOffset: NewDataLabelUtils.startingLabelOffset,
                            attemptToMoveLabelsIntoViewport: !0
                        };
                    }
                }
                function getTextSize(text, fontSize) {
                    var labelTextProperties = NewDataLabelUtils.LabelTextProperties, properties = {
                        text: text,
                        fontFamily: labelTextProperties.fontFamily,
                        fontSize: jsCommon.PixelConverter.fromPoint(fontSize),
                        fontWeight: labelTextProperties.fontWeight
                    };
                    return {
                        width: powerbi.TextMeasurementService.measureSvgTextWidth(properties),
                        height: powerbi.TextMeasurementService.estimateSvgTextHeight(properties)
                    };
                }
                function labelKeyFunction(label, index) {
                    return label.key ? label.key : label.identity ? label.identity.getKeyWithoutHighlight() : index;
                }
                NewDataLabelUtils.DefaultLabelFontSizeInPt = 9, NewDataLabelUtils.MapPolylineOpacity = .5, 
                NewDataLabelUtils.LabelDensityBufferFactor = 3, NewDataLabelUtils.LabelDensityPadding = 6, 
                NewDataLabelUtils.startingLabelOffset = 8, NewDataLabelUtils.maxLabelOffset = 8, 
                NewDataLabelUtils.maxLabelWidth = 50, NewDataLabelUtils.hundredPercentFormat = "0.00 %;-0.00 %;0.00 %", 
                NewDataLabelUtils.LabelTextProperties = {
                    fontFamily: visuals.Font.Family.regularSecondary.css,
                    fontSize: PixelConverter.fromPoint(NewDataLabelUtils.DefaultLabelFontSizeInPt),
                    fontWeight: "normal"
                }, NewDataLabelUtils.defaultLabelColor = "#777777", NewDataLabelUtils.defaultInsideLabelColor = "#ffffff", 
                NewDataLabelUtils.horizontalLabelBackgroundPadding = 4, NewDataLabelUtils.verticalLabelBackgroundPadding = 2;
                var labelBackgroundRounding = 4, defaultLabelPrecision = void 0, defaultCountLabelPrecision = 0;
                NewDataLabelUtils.labelGraphicsContextClass = createClassAndSelector("labelGraphicsContext"), 
                NewDataLabelUtils.labelBackgroundGraphicsContextClass = createClassAndSelector("labelBackgroundGraphicsContext");
                var labelsClass = createClassAndSelector("label"), secondLineLabelClass = createClassAndSelector("label-second-line"), linesGraphicsContextClass = createClassAndSelector("leader-lines"), lineClass = createClassAndSelector("line-label");
                NewDataLabelUtils.drawDefaultLabels = drawDefaultLabels, NewDataLabelUtils.animateDefaultLabels = animateDefaultLabels, 
                NewDataLabelUtils.drawLabelBackground = drawLabelBackground, NewDataLabelUtils.drawLabelLeaderLines = drawLabelLeaderLines, 
                NewDataLabelUtils.getLabelFormattedText = getLabelFormattedText, NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter = getDisplayUnitValueFromAxisFormatter, 
                NewDataLabelUtils.createColumnFormatterCacheManager = createColumnFormatterCacheManager, 
                NewDataLabelUtils.removeDuplicates = removeDuplicates, NewDataLabelUtils.getDataLabelLayoutOptions = getDataLabelLayoutOptions, 
                NewDataLabelUtils.getTextSize = getTextSize;
            }(NewDataLabelUtils = visuals.NewDataLabelUtils || (visuals.NewDataLabelUtils = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var KpiUtil;
            !function(KpiUtil) {
                function getKpiIcon(kpi, value) {
                    var numValue = parseFloat(value);
                    if (kpi) {
                        var statusGraphicFormat = statusGraphicFormatStrings[kpi.graphic.toUpperCase()];
                        if (statusGraphicFormat && !isNaN(numValue)) {
                            var statusValues = statusGraphicFormat.statusValues;
                            kpi.normalizedFiveStateKpiRange && 5 === statusValues.length && (numValue = 2 * numValue);
                            var num = numValue + Math.floor(statusValues.length / 2);
                            return [ statusGraphicFormat.kpiIconClass, statusValues[num] ].join(" ").trim();
                        }
                    }
                }
                function getKpiIconClassName(kpiIcon, kpiImageSize) {
                    return kpiIcon ? 1 === kpiImageSize ? [ KPIImageClassName, BigImageClassName, kpiIcon ].join(" ") : [ KPIImageClassName, kpiIcon ].join(" ") : void 0;
                }
                function getClassForKpi(kpi, value, kpiImageSize) {
                    var kpiIcon = getKpiIcon(kpi, value);
                    return getKpiIconClassName(kpiIcon, kpiImageSize);
                }
                function getKpiImageMetadata(metaDataColumn, value, kpiImageSize) {
                    var kpi = metaDataColumn && metaDataColumn.kpi;
                    if (kpi) {
                        var kpiIcon = getKpiIcon(kpi, value);
                        if (kpiIcon) return {
                            caption: kpiIcon,
                            statusGraphic: kpi.graphic,
                            "class": getKpiIconClassName(kpiIcon, kpiImageSize)
                        };
                    }
                }
                var KPIImageClassName = "powervisuals-glyph", BigImageClassName = "big-kpi", RYGStatusIconClassNames = [ "kpi-red", "kpi-yellow", "kpi-green" ], threeLights = {
                    kpiIconClass: "circle",
                    statusValues: RYGStatusIconClassNames
                }, roadSigns = {
                    kpiIconClass: "",
                    statusValues: [ "circle-x kpi-red", "circle-exclamation kpi-yellow", "circle-checkmark kpi-green" ]
                }, trafficLight = {
                    kpiIconClass: "traffic-light",
                    statusValues: RYGStatusIconClassNames
                }, shapes = {
                    kpiIconClass: "",
                    statusValues: [ "rhombus kpi-red", "triangle kpi-yellow", "circle kpi-green" ]
                }, gauge = {
                    kpiIconClass: "",
                    statusValues: [ "circle-empty", "circle-one-quarter", "circle-half", "circle-three-quarters", "circle-full" ]
                }, statusGraphicFormatStrings = {
                    "THREE CIRCLES COLORED": threeLights,
                    "TRAFFIC LIGHT - SINGLE": threeLights,
                    "THREE FLAGS COLORED": {
                        kpiIconClass: "flag",
                        statusValues: RYGStatusIconClassNames
                    },
                    "ROAD SIGNS": roadSigns,
                    "THREE SYMBOLS CIRCLED COLORED": roadSigns,
                    "TRAFFIC LIGHT": trafficLight,
                    "THREE TRAFFIC LIGHTS RIMMED COLORED": trafficLight,
                    "THREE SYMBOLS UNCIRCLED COLORED": {
                        kpiIconClass: "",
                        statusValues: [ "x kpi-red", "exclamation kpi-yellow", "checkmark kpi-green" ]
                    },
                    SHAPES: shapes,
                    "SMILEY FACE": shapes,
                    THERMOMETER: shapes,
                    CYLINDER: shapes,
                    "THREE SIGNS COLORED": shapes,
                    "THREE STARS COLORED": {
                        kpiIconClass: "star-stacked",
                        statusValues: [ "star-empty", "star-half-full", "star-full" ]
                    },
                    "FIVE BARS COLORED": {
                        kpiIconClass: "bars-stacked",
                        statusValues: [ "bars-zero", "bars-one", "bars-two", "bars-three", "bars-four" ]
                    },
                    "FIVE BOXES COLORED": {
                        kpiIconClass: "boxes-stacked",
                        statusValues: [ "boxes-zero", "boxes-one", "boxes-two", "boxes-three", "boxes-four" ]
                    },
                    "FIVE QUARTERS COLORED": gauge,
                    "GAUGE - ASCENDING": gauge,
                    "GAUGE - DESCENDING": {
                        kpiIconClass: "",
                        statusValues: [ "circle-full", "circle-three-quarters", "circle-half", "circle-one-quarter", "circle-empty" ]
                    },
                    "STANDARD ARROW": {
                        kpiIconClass: "",
                        statusValues: [ "arrow-down", "arrow-right-down", "arrow-right", "arrow-right-up", "arrow-up" ]
                    },
                    "VARIANCE ARROW": {
                        kpiIconClass: "",
                        statusValues: [ "arrow-down kpi-red", "arrow-right kpi-yellow", "arrow-up kpi-green" ]
                    },
                    "STATUS ARROW - ASCENDING": {
                        kpiIconClass: "",
                        statusValues: [ "arrow-down kpi-red", "arrow-right-down kpi-yellow", "arrow-right kpi-yellow", "arrow-right-up kpi-yellow", "arrow-up kpi-green" ]
                    },
                    "STATUS ARROW - DESCENDING": {
                        kpiIconClass: "",
                        statusValues: [ "arrow-up kpi-green", "arrow-right-up kpi-yellow", "arrow-right kpi-yellow", "arrow-right-down kpi-yellow", "arrow-down kpi-red" ]
                    }
                };
                KpiUtil.getClassForKpi = getClassForKpi, KpiUtil.getKpiImageMetadata = getKpiImageMetadata;
            }(KpiUtil = visuals.KpiUtil || (visuals.KpiUtil = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var DateUtil;
            !function(DateUtil) {
                function isEqual(date1, date2) {
                    return null == date1 && null == date2 ? !0 : null == date1 || null == date2 ? !1 : date1.getTime() === date2.getTime();
                }
                DateUtil.isEqual = isEqual;
            }(DateUtil = visuals.DateUtil || (visuals.DateUtil = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var MinMaxType;
            !function(MinMaxType) {
                MinMaxType[MinMaxType.Minimum = 0] = "Minimum", MinMaxType[MinMaxType.Maximum = 1] = "Maximum", 
                MinMaxType[MinMaxType.Neither = 2] = "Neither";
            }(MinMaxType || (MinMaxType = {}));
            var MinMaxLabelDataPointSorter = function() {
                function MinMaxLabelDataPointSorter(options) {
                    this.unsortedLabelDataPointGroups = options.unsortedLabelDataPointGroups, this.series = options.series, 
                    this.yScale = options.yAxisProperties.scale, this.viewport = options.viewport;
                }
                return MinMaxLabelDataPointSorter.prototype.getSortedDataLabels = function() {
                    for (var unsortedLabelDataPointGroups = this.unsortedLabelDataPointGroups, sortedLabelDataPointGroups = [], seriesIndex = 0, seriesCount = unsortedLabelDataPointGroups.length; seriesCount > seriesIndex; seriesIndex++) {
                        var unsortedLabelDataPointGroup = unsortedLabelDataPointGroups[seriesIndex], numberOfLabelsToSort = MinMaxLabelDataPointSorter.maxNumberToSortFactor * unsortedLabelDataPointGroup.maxNumberOfLabels;
                        if (!_.isEmpty(unsortedLabelDataPointGroup.labelDataPoints)) {
                            var unsortedLabelDataPoints = unsortedLabelDataPointGroup.labelDataPoints, sortedLabelDataPoints = [], data_1 = _.filter(this.series[seriesIndex].data, function(dataPoint) {
                                return null != dataPoint.value;
                            }), globalMinMaxInRange = MinMaxLabelDataPointSorter.getMinMaxInRange(0, data_1.length - 1, data_1), numberOfLabelsAdded = this.addFirstLastMaxMin(unsortedLabelDataPoints, sortedLabelDataPoints, globalMinMaxInRange.maxIndex, globalMinMaxInRange.minIndex), unsortedWeightedLabelDataPoints = void 0;
                            if (!(numberOfLabelsAdded >= numberOfLabelsToSort)) {
                                unsortedWeightedLabelDataPoints = this.calculateWeights(unsortedLabelDataPoints, data_1, numberOfLabelsToSort, globalMinMaxInRange);
                                var maximumnMinMaxesToAdd = Math.max(numberOfLabelsToSort - numberOfLabelsAdded, 0);
                                numberOfLabelsAdded += this.addLocalMinMaxes(unsortedWeightedLabelDataPoints, sortedLabelDataPoints, globalMinMaxInRange.maxIndex, globalMinMaxInRange.minIndex, maximumnMinMaxesToAdd);
                            }
                            if (!(numberOfLabelsAdded >= numberOfLabelsToSort)) {
                                var maximumNonMinMaxesToAdd = Math.max(numberOfLabelsToSort - numberOfLabelsAdded, 0);
                                this.addNonMinMaxes(unsortedWeightedLabelDataPoints, sortedLabelDataPoints, maximumNonMinMaxesToAdd);
                            }
                            sortedLabelDataPointGroups.push({
                                labelDataPoints: sortedLabelDataPoints,
                                maxNumberOfLabels: unsortedLabelDataPointGroup.maxNumberOfLabels
                            });
                        }
                    }
                    return sortedLabelDataPointGroups;
                }, MinMaxLabelDataPointSorter.prototype.calculateWeights = function(labelDataPoints, data, numberOfLabelsToSort, globalMinMax) {
                    for (var previousMinMaxPoint, currentMinMaxPoint, categoryCount = data.length, yScale = this.yScale, minMaxPoints = this.findMinMaxesBasedOnSmoothedValues(labelDataPoints, data), totalValueDifference = Math.abs(yScale(globalMinMax.maxValue) - yScale(globalMinMax.minValue)), minMaxIndex = 0, minMaxCount = minMaxPoints.length; minMaxCount > minMaxIndex; minMaxIndex++) {
                        currentMinMaxPoint = minMaxPoints[minMaxIndex];
                        var weight = void 0;
                        if (previousMinMaxPoint) {
                            var valueWeight = Math.abs((yScale(previousMinMaxPoint.value) - yScale(currentMinMaxPoint.value)) / totalValueDifference), indexWeight = Math.abs(previousMinMaxPoint.index - currentMinMaxPoint.index) / (categoryCount - 1);
                            weight = (valueWeight + indexWeight) / 2;
                        }
                        if (null != weight && previousMinMaxPoint) {
                            var previousLabelDataPoint = labelDataPoints[previousMinMaxPoint.index];
                            null != previousLabelDataPoint.weight ? previousLabelDataPoint.weight = (previousLabelDataPoint.weight + weight) / 2 : previousLabelDataPoint.weight = weight, 
                            labelDataPoints[currentMinMaxPoint.index].weight = weight;
                        }
                        previousMinMaxPoint = currentMinMaxPoint;
                    }
                    for (var _i = 0, labelDataPoints_1 = labelDataPoints; _i < labelDataPoints_1.length; _i++) {
                        var labelDataPoint = labelDataPoints_1[_i];
                        labelDataPoint.weight < MinMaxLabelDataPointSorter.minimumWeightToConsiderMinMax && (labelDataPoint.weight = void 0);
                    }
                    return labelDataPoints;
                }, MinMaxLabelDataPointSorter.prototype.findMinMaxesBasedOnSmoothedValues = function(labelDataPoints, data) {
                    for (var minMaxPoints = [], windowSize = this.getWindowSize(data), halfWindowSize = Math.floor(windowSize / 2), scaledSmoothedValues = this.calculateSmoothedValues(data, windowSize), categoryIndex = 0, categoryCount = labelDataPoints.length; categoryCount > categoryIndex; categoryIndex++) {
                        var minMaxType = this.getMinMaxType(categoryIndex, scaledSmoothedValues);
                        if (minMaxType !== MinMaxType.Neither) {
                            var currentMinMaxPoint = {
                                index: categoryIndex,
                                type: minMaxType,
                                value: data[categoryIndex].value
                            };
                            minMaxPoints.push(currentMinMaxPoint);
                        }
                    }
                    for (var previousMinMax, currentMinMax, nextMinMax, minMaxIndex = 0, minMaxCount = minMaxPoints.length; minMaxCount > minMaxIndex; minMaxIndex++) if (previousMinMax = minMaxPoints[minMaxIndex - 1], 
                    currentMinMax = minMaxPoints[minMaxIndex], nextMinMax = minMaxPoints[minMaxIndex + 1], 
                    previousMinMax && nextMinMax) {
                        var actualMinMaxInRange = MinMaxLabelDataPointSorter.getMinMaxInRange(Math.max(previousMinMax.index, currentMinMax.index - halfWindowSize), Math.min(nextMinMax.index, currentMinMax.index + halfWindowSize), data);
                        if (currentMinMax.type === MinMaxType.Maximum) {
                            var actualIndex = actualMinMaxInRange.maxIndex;
                            currentMinMax.index = actualIndex, currentMinMax.value = data[actualIndex].value;
                        } else {
                            var actualIndex = actualMinMaxInRange.minIndex;
                            currentMinMax.index = actualIndex, currentMinMax.value = data[actualIndex].value;
                        }
                    }
                    return minMaxPoints;
                }, MinMaxLabelDataPointSorter.getMinMaxInRange = function(startIndex, endIndex, data) {
                    for (var minValue, maxValue, minIndex, maxIndex, categoryIndex = startIndex, dataLength = data.length; endIndex >= categoryIndex && dataLength > categoryIndex; categoryIndex++) {
                        var value = data[categoryIndex].value;
                        null != value && ((void 0 === minValue || minValue > value) && (minValue = value, 
                        minIndex = categoryIndex), (void 0 === maxValue || value > maxValue) && (maxValue = value, 
                        maxIndex = categoryIndex));
                    }
                    return {
                        minIndex: minIndex,
                        minValue: minValue,
                        maxIndex: maxIndex,
                        maxValue: maxValue
                    };
                }, MinMaxLabelDataPointSorter.prototype.getWindowSize = function(data) {
                    var idealSize = data.length / this.viewport.width * MinMaxLabelDataPointSorter.estimatedLabelWidth, actualsize = 2 * Math.floor(idealSize / 2) + 1;
                    return actualsize;
                }, MinMaxLabelDataPointSorter.prototype.calculateSmoothedValues = function(data, windowSize) {
                    for (var gaussianValues = MinMaxLabelDataPointSorter.getGaussianDistribution(windowSize), scaledAndSmoothedValues = [], categoryIndex = 0, categoryCount = data.length; categoryCount > categoryIndex; categoryIndex++) if (1 === windowSize) scaledAndSmoothedValues.push(data[categoryIndex].value); else {
                        var scaledValue = this.getSmoothedValue(data, categoryIndex, windowSize, gaussianValues);
                        scaledAndSmoothedValues.push(scaledValue);
                    }
                    return scaledAndSmoothedValues;
                }, MinMaxLabelDataPointSorter.getGaussianDistribution = function(windowSize) {
                    for (var gaussianDistribution = [], halfWayIndex = Math.floor(windowSize / 2), height = 1, maxPosition = halfWayIndex, standardDeviation = halfWayIndex / 2, i = 0; halfWayIndex > i; i++) {
                        var gaussianValue = height * Math.pow(Math.E, -1 * ((i - maxPosition) * (i - maxPosition)) / (2 * standardDeviation * standardDeviation));
                        gaussianDistribution.push(gaussianValue);
                    }
                    gaussianDistribution.push(1);
                    for (var i = halfWayIndex - 1; i >= 0; i--) gaussianDistribution.push(gaussianDistribution[i]);
                    return gaussianDistribution;
                }, MinMaxLabelDataPointSorter.prototype.getSmoothedValue = function(data, categoryIndex, windowSize, gaussianValues) {
                    if (null == data[categoryIndex].value) return data[categoryIndex].value;
                    for (var halfWindowSize = Math.floor(windowSize / 2), startingIndex = categoryIndex - halfWindowSize, endingIndex = categoryIndex + halfWindowSize, totalValue = 0, totalValueCount = 0, lastDataIndex = data.length - 1, currentIndex = startingIndex, gaussianIndex = 0; endingIndex >= currentIndex; currentIndex++, 
                    gaussianIndex++) {
                        var valueIndex = Math.max(0, Math.min(currentIndex, lastDataIndex)), value = data[valueIndex].value;
                        null != value && (totalValue += value * gaussianValues[gaussianIndex], totalValueCount++);
                    }
                    return totalValue / totalValueCount;
                }, MinMaxLabelDataPointSorter.prototype.addFirstLastMaxMin = function(unsorted, sorted, maxIndex, minIndex) {
                    var labelsAdded = 0;
                    if (_.isEmpty(unsorted)) return labelsAdded;
                    sorted.push(unsorted[0]), labelsAdded++;
                    var lastIndex = unsorted.length - 1;
                    return 0 !== lastIndex && (sorted.push(unsorted[lastIndex]), labelsAdded++), 0 !== maxIndex && maxIndex !== lastIndex && (sorted.push(unsorted[maxIndex]), 
                    labelsAdded++), 0 !== minIndex && minIndex !== lastIndex && (sorted.push(unsorted[minIndex]), 
                    labelsAdded++), labelsAdded;
                }, MinMaxLabelDataPointSorter.prototype.addLocalMinMaxes = function(unsorted, sorted, maxIndex, minIndex, maxNumberOfLabels) {
                    for (var lastIndex = unsorted.length - 1, localMinMaxes = _.filter(unsorted, function(labelDataPoint, index) {
                        return 0 === index || index === lastIndex || index === maxIndex || index === minIndex ? !1 : null != labelDataPoint.weight;
                    }), sortedMinMaxes = _.sortBy(localMinMaxes, function(weighedLabelDataPoint) {
                        return -weighedLabelDataPoint.weight;
                    }), labelsAdded = 0, i = 0, ilen = Math.min(sortedMinMaxes.length, maxNumberOfLabels); ilen > i; i++) sorted.push(sortedMinMaxes[i]), 
                    labelsAdded++;
                    return labelsAdded;
                }, MinMaxLabelDataPointSorter.prototype.addNonMinMaxes = function(unsorted, sorted, maxNumberOfLabels) {
                    for (var currentNonMinMaxSet, nonMinMaxSets = [], categoryIndex = 0, categoryCount = unsorted.length; categoryCount > categoryIndex; categoryIndex++) null == unsorted[categoryIndex].weight ? currentNonMinMaxSet ? currentNonMinMaxSet.count++ : currentNonMinMaxSet = {
                        startingIndex: categoryIndex,
                        count: 1
                    } : currentNonMinMaxSet && currentNonMinMaxSet.count > 0 && (nonMinMaxSets.push(currentNonMinMaxSet), 
                    currentNonMinMaxSet = null);
                    for (var numberOfLabelsAdded = 0; nonMinMaxSets.length > 0 && maxNumberOfLabels > numberOfLabelsAdded; ) {
                        for (var currentMaxCount = 0, maxIndex = 0, i = 0, ilen = nonMinMaxSets.length; ilen > i; i++) {
                            var currentCount = nonMinMaxSets[i].count;
                            currentCount > currentMaxCount && (currentMaxCount = currentCount, maxIndex = i);
                        }
                        var setToSplit = nonMinMaxSets.splice(maxIndex, 1)[0];
                        if (1 === setToSplit.count) sorted.push(unsorted[setToSplit.startingIndex]); else {
                            var splitIndex = Math.floor(setToSplit.count / 2) + setToSplit.startingIndex;
                            sorted.push(unsorted[splitIndex]);
                            var leftCount = splitIndex - setToSplit.startingIndex;
                            leftCount > 0 && nonMinMaxSets.push({
                                startingIndex: setToSplit.startingIndex,
                                count: leftCount
                            });
                            var rightCount = setToSplit.startingIndex + setToSplit.count - splitIndex - 1;
                            rightCount > 0 && nonMinMaxSets.push({
                                startingIndex: splitIndex + 1,
                                count: rightCount
                            });
                        }
                        numberOfLabelsAdded++;
                    }
                }, MinMaxLabelDataPointSorter.prototype.getMinMaxType = function(index, scaledDataPoints) {
                    var currentValue = scaledDataPoints[index];
                    if (null == scaledDataPoints[index]) return MinMaxType.Neither;
                    if (scaledDataPoints.length < 2) return MinMaxType.Neither;
                    if (null == scaledDataPoints[index - 1]) return scaledDataPoints[index + 1] > currentValue ? MinMaxType.Minimum : MinMaxType.Maximum;
                    if (null == scaledDataPoints[index + 1]) return scaledDataPoints[index - 1] > currentValue ? MinMaxType.Minimum : MinMaxType.Maximum;
                    var prevValue = scaledDataPoints[index - 1], nextValue = scaledDataPoints[index + 1];
                    return null == prevValue && null == nextValue ? MinMaxType.Neither : null == prevValue ? nextValue > currentValue ? MinMaxType.Minimum : MinMaxType.Maximum : null == nextValue ? prevValue > currentValue ? MinMaxType.Minimum : MinMaxType.Maximum : prevValue > currentValue && nextValue > currentValue ? MinMaxType.Minimum : currentValue > prevValue && currentValue > nextValue ? MinMaxType.Maximum : MinMaxType.Neither;
                }, MinMaxLabelDataPointSorter.estimatedLabelWidth = 40, MinMaxLabelDataPointSorter.minimumWeightToConsiderMinMax = .015, 
                MinMaxLabelDataPointSorter.maxNumberToSortFactor = 2, MinMaxLabelDataPointSorter;
            }();
            visuals.MinMaxLabelDataPointSorter = MinMaxLabelDataPointSorter;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var ReferenceLineHelper;
            !function(ReferenceLineHelper) {
                function enumerateObjectInstances(enumeration, referenceLines, defaultColor, objectName) {
                    if (_.isEmpty(referenceLines)) {
                        var instance = {
                            selector: {
                                id: "0"
                            },
                            properties: {
                                show: !1,
                                value: "",
                                lineColor: {
                                    solid: {
                                        color: defaultColor
                                    }
                                },
                                transparency: 50,
                                style: visuals.lineStyle.dashed,
                                position: visuals.referenceLinePosition.back,
                                dataLabelShow: !1
                            },
                            objectName: objectName
                        };
                        return void enumeration.pushInstance(instance);
                    }
                    for (var _i = 0, referenceLines_1 = referenceLines; _i < referenceLines_1.length; _i++) {
                        var referenceLine = referenceLines_1[_i], referenceLineProperties = referenceLine.object, show = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.show, !1), displayName = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.displayName), value = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.value), lineColor = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.lineColor, {
                            solid: {
                                color: defaultColor
                            }
                        }), transparency = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.transparency, 50), style = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.style, visuals.lineStyle.dashed), position = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.position, visuals.referenceLinePosition.back), dataLabelShow = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelShow, !1), instance = {
                            selector: {
                                id: referenceLine.id
                            },
                            properties: {
                                show: show,
                                displayName: displayName,
                                value: value,
                                lineColor: lineColor,
                                transparency: transparency,
                                style: style,
                                position: position,
                                dataLabelShow: dataLabelShow
                            },
                            objectName: objectName
                        };
                        if (dataLabelShow) {
                            var dataLabelColor = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelColor, {
                                solid: {
                                    color: defaultColor
                                }
                            }), dataLabelHorizontalPosition = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelHorizontalPosition, visuals.referenceLineDataLabelHorizontalPosition.left), dataLabelVerticalPosition = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelVerticalPosition, visuals.referenceLineDataLabelVerticalPosition.above), dataLabelDecimalPoints = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelDecimalPoints, void 0) < 0 ? void 0 : powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelDecimalPoints, void 0), dataLabelDisplayUnits = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelDisplayUnits, 0);
                            instance.properties[ReferenceLineHelper.referenceLineProps.dataLabelColor] = dataLabelColor, 
                            instance.properties[ReferenceLineHelper.referenceLineProps.dataLabelHorizontalPosition] = dataLabelHorizontalPosition, 
                            instance.properties[ReferenceLineHelper.referenceLineProps.dataLabelVerticalPosition] = dataLabelVerticalPosition, 
                            instance.properties[ReferenceLineHelper.referenceLineProps.dataLabelDisplayUnits] = dataLabelDisplayUnits, 
                            instance.properties[ReferenceLineHelper.referenceLineProps.dataLabelDecimalPoints] = dataLabelDecimalPoints;
                        }
                        enumeration.pushInstance(instance);
                    }
                }
                function render(options) {
                    var graphicContext = options.graphicContext, axes = options.axes, referenceLineProperties = options.referenceLineProperties, isHorizontal = options.isHorizontal, viewport = options.viewport, classAndSelector = options.classAndSelector, xScale = axes.x.scale, yScale = axes.y1.scale, refValue = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.value, 0), lineColor = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.lineColor, {
                        solid: {
                            color: options.defaultColor
                        }
                    }), transparency = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.transparency), style = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.style, visuals.lineStyle.dashed), position = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.position, visuals.referenceLinePosition.back), refLine = graphicContext.select(classAndSelector.selector), index = $(refLine[0]).index(), isRefLineExists = -1 !== index, isPositionChanged = !0;
                    if (isRefLineExists) {
                        var lastIndex = $(refLine[0]).siblings().length;
                        position === visuals.referenceLinePosition.back && 0 === index ? isPositionChanged = !1 : position === visuals.referenceLinePosition.front && index === lastIndex && (isPositionChanged = !1);
                    }
                    isRefLineExists && isPositionChanged && refLine.remove(), isRefLineExists && !isPositionChanged || (refLine = position === visuals.referenceLinePosition.back ? graphicContext.insert("line", ":first-child") : graphicContext.append("line"));
                    var refLineX1 = isHorizontal ? 0 : xScale(refValue), refLineY1 = isHorizontal ? yScale(refValue) : 0, refLineX2 = isHorizontal ? viewport.width : xScale(refValue), refLineY2 = isHorizontal ? yScale(refValue) : viewport.height;
                    refLine.attr({
                        "class": classAndSelector["class"],
                        x1: refLineX1,
                        y1: refLineY1,
                        x2: refLineX2,
                        y2: refLineY2
                    }).style({
                        stroke: lineColor.solid.color
                    }), null != transparency && refLine.style("stroke-opacity", (100 - transparency) / 100), 
                    style === visuals.lineStyle.dashed ? refLine.style("stroke-dasharray", "5, 5") : style === visuals.lineStyle.dotted ? refLine.style({
                        "stroke-dasharray": "1, 5",
                        "stroke-linecap": "round"
                    }) : style === visuals.lineStyle.solid && refLine.style({
                        "stroke-dasharray": null,
                        "stroke-linecap": null
                    });
                }
                function createLabelDataPoint(options) {
                    var offsetRefLine = 5, axes = options.axes, referenceLineProperties = options.referenceLineProperties, isHorizontal = options.isHorizontal, viewport = options.viewport, xScale = axes.x.scale, yScale = axes.y1.scale, refValue = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.value, 0), color = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelColor, {
                        solid: {
                            color: options.defaultColor
                        }
                    }), decimalPoints = referenceLineProperties[ReferenceLineHelper.referenceLineProps.dataLabelDecimalPoints] < 0 ? void 0 : referenceLineProperties[ReferenceLineHelper.referenceLineProps.dataLabelDecimalPoints], horizontalPosition = referenceLineProperties[ReferenceLineHelper.referenceLineProps.dataLabelHorizontalPosition] || visuals.referenceLineDataLabelHorizontalPosition.left, verticalPosition = referenceLineProperties[ReferenceLineHelper.referenceLineProps.dataLabelVerticalPosition] || visuals.referenceLineDataLabelVerticalPosition.above, displayUnits = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelDisplayUnits, 0), axisFormatter = isHorizontal ? axes.y1.formatter : axes.x.formatter, formatterForReferenceLineDataLabel = axisFormatter;
                    if (null != axisFormatter.options) {
                        var formatterOptions = powerbi.Prototype.inherit(axisFormatter.options);
                        formatterOptions.precision = decimalPoints, formatterOptions.value = displayUnits, 
                        formatterOptions.detectAxisPrecision = !1, formatterForReferenceLineDataLabel = visuals.valueFormatter.create(formatterOptions);
                    }
                    var dataLabelX, dataLabelY, text = visuals.NewDataLabelUtils.getLabelFormattedText(formatterForReferenceLineDataLabel.format(refValue)), properties = {
                        text: text,
                        fontFamily: visuals.dataLabelUtils.LabelTextProperties.fontFamily,
                        fontSize: visuals.dataLabelUtils.LabelTextProperties.fontSize,
                        fontWeight: visuals.dataLabelUtils.LabelTextProperties.fontWeight
                    }, rectWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties), rectHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties), x1 = isHorizontal ? 0 : xScale(refValue), y1 = isHorizontal ? yScale(refValue) : 0, x2 = isHorizontal ? viewport.width : xScale(refValue), y2 = isHorizontal ? yScale(refValue) : viewport.height, validPositions = [ 1 ];
                    isHorizontal ? (dataLabelX = horizontalPosition === visuals.referenceLineDataLabelHorizontalPosition.left ? x1 + offsetRefLine : x2 - rectWidth / 2 - offsetRefLine, 
                    dataLabelY = y1, validPositions = verticalPosition === visuals.referenceLineDataLabelVerticalPosition.above ? [ 1 ] : [ 2 ]) : (dataLabelX = x1, 
                    dataLabelY = verticalPosition === visuals.referenceLineDataLabelVerticalPosition.above ? y1 + rectHeight / 2 + offsetRefLine : y2 - rectHeight / 2 - offsetRefLine, 
                    validPositions = horizontalPosition === visuals.referenceLineDataLabelHorizontalPosition.left ? [ 4 ] : [ 8 ]);
                    var parentShape, textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties), textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, !0);
                    return parentShape = {
                        point: {
                            x: dataLabelX,
                            y: dataLabelY
                        },
                        radius: 0,
                        validPositions: validPositions
                    }, {
                        isPreferred: !0,
                        text: text,
                        textSize: {
                            width: textWidth,
                            height: textHeight
                        },
                        outsideFill: color.solid.color,
                        insideFill: null,
                        parentShape: parentShape,
                        parentType: 0,
                        fontSize: 9,
                        identity: null,
                        secondRowText: null,
                        key: options.key
                    };
                }
                function extractReferenceLineValue(referenceLineProperties) {
                    var referenceLineValue = null;
                    return referenceLineProperties && powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.show, !1) && (referenceLineValue = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.value, null)), 
                    referenceLineValue;
                }
                ReferenceLineHelper.referenceLineProps = {
                    show: "show",
                    displayName: "displayName",
                    lineColor: "lineColor",
                    transparency: "transparency",
                    value: "value",
                    style: "style",
                    position: "position",
                    dataLabelShow: "dataLabelShow",
                    dataLabelColor: "dataLabelColor",
                    dataLabelDecimalPoints: "dataLabelDecimalPoints",
                    dataLabelHorizontalPosition: "dataLabelHorizontalPosition",
                    dataLabelVerticalPosition: "dataLabelVerticalPosition",
                    dataLabelDisplayUnits: "dataLabelDisplayUnits"
                }, ReferenceLineHelper.enumerateObjectInstances = enumerateObjectInstances, ReferenceLineHelper.render = render, 
                ReferenceLineHelper.createLabelDataPoint = createLabelDataPoint, ReferenceLineHelper.extractReferenceLineValue = extractReferenceLineValue;
            }(ReferenceLineHelper = visuals.ReferenceLineHelper || (visuals.ReferenceLineHelper = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var InteractivityUtils;
            !function(InteractivityUtils) {
                function getPositionOfLastInputEvent() {
                    return {
                        x: d3.event.clientX,
                        y: d3.event.clientY
                    };
                }
                function registerStandardInteractivityHandlers(selection, selectionHandler) {
                    registerStandardSelectionHandler(selection, selectionHandler), registerStandardContextMenuHandler(selection, selectionHandler);
                }
                function registerStandardSelectionHandler(selection, selectionHandler) {
                    selection.on("click", function(d) {
                        return handleSelection(d, selectionHandler);
                    });
                }
                function registerStandardContextMenuHandler(selection, selectionHandler) {
                    selection.on("contextmenu", function(d) {
                        return handleContextMenu(d, selectionHandler);
                    });
                }
                function registerGroupInteractivityHandlers(group, selectionHandler) {
                    registerGroupSelectionHandler(group, selectionHandler), registerGroupContextMenuHandler(group, selectionHandler);
                }
                function registerGroupSelectionHandler(group, selectionHandler) {
                    group.on("click", function() {
                        var target = d3.event.target, d = d3.select(target).datum();
                        handleSelection(d, selectionHandler);
                    });
                }
                function registerGroupContextMenuHandler(group, selectionHandler) {
                    group.on("contextmenu", function() {
                        var target = d3.event.target, d = d3.select(target).datum();
                        handleContextMenu(d, selectionHandler);
                    });
                }
                function handleContextMenu(d, selectionHandler) {
                    if (!d3.event.ctrlKey) {
                        d3.event.preventDefault();
                        var position = InteractivityUtils.getPositionOfLastInputEvent();
                        selectionHandler.handleContextMenu(d, position);
                    }
                }
                function handleSelection(d, selectionHandler) {
                    selectionHandler.handleSelection(d, d3.event.ctrlKey);
                }
                InteractivityUtils.getPositionOfLastInputEvent = getPositionOfLastInputEvent, InteractivityUtils.registerStandardInteractivityHandlers = registerStandardInteractivityHandlers, 
                InteractivityUtils.registerStandardSelectionHandler = registerStandardSelectionHandler, 
                InteractivityUtils.registerStandardContextMenuHandler = registerStandardContextMenuHandler, 
                InteractivityUtils.registerGroupInteractivityHandlers = registerGroupInteractivityHandlers, 
                InteractivityUtils.registerGroupSelectionHandler = registerGroupSelectionHandler, 
                InteractivityUtils.registerGroupContextMenuHandler = registerGroupContextMenuHandler;
            }(InteractivityUtils = visuals.InteractivityUtils || (visuals.InteractivityUtils = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            function getInvalidValueWarnings(dataViews, supportsNaN, supportsNegativeInfinity, supportsPositiveInfinity) {
                var checker = new InvalidDataValuesChecker(supportsNaN, supportsNegativeInfinity, supportsPositiveInfinity);
                return checker.getWarningMessages(dataViews);
            }
            visuals.getInvalidValueWarnings = getInvalidValueWarnings;
            var InvalidDataValuesChecker = function() {
                function InvalidDataValuesChecker(supportsNaN, supportsNegativeInfinity, supportsPositiveInfinity) {
                    this.supportsNaN = supportsNaN, this.supportsNegativeInfinity = supportsNegativeInfinity, 
                    this.supportsPositiveInfinity = supportsPositiveInfinity;
                }
                return InvalidDataValuesChecker.prototype.getWarningMessages = function(dataViews) {
                    this.loadWarningStatus(dataViews);
                    var warnings = [];
                    return this.hasNaN && !this.supportsNaN && warnings.push(new visuals.NaNNotSupportedWarning()), 
                    (this.hasNegativeInfinity && !this.supportsNegativeInfinity || this.hasPositiveInfinity && !this.supportsPositiveInfinity) && warnings.push(new visuals.InfinityValuesNotSupportedWarning()), 
                    this.hasOutOfRange && warnings.push(new visuals.ValuesOutOfRangeWarning()), warnings;
                }, InvalidDataValuesChecker.prototype.loadWarningStatus = function(dataViews) {
                    this.hasNaN = !1, this.hasNegativeInfinity = !1, this.hasOutOfRange = !1, this.hasPositiveInfinity = !1;
                    for (var k = 0; k < dataViews.length; k++) {
                        var dataView = dataViews[k], values = dataView && dataView.categorical && dataView.categorical.values ? dataView.categorical.values : null;
                        if (!values) return;
                        for (var valueLength = values.length, i = 0; valueLength > i; i++) {
                            var value = values[i];
                            if (value.values) for (var valueValueLength = value.values.length, j = 0; valueValueLength > j; j++) {
                                var v = value.values[j];
                                isNaN(v) ? this.hasNaN = !0 : v === Number.POSITIVE_INFINITY ? this.hasPositiveInfinity = !0 : v === Number.NEGATIVE_INFINITY ? this.hasNegativeInfinity = !0 : (-1e300 > v || v > 1e300) && (this.hasOutOfRange = !0);
                            }
                        }
                    }
                }, InvalidDataValuesChecker;
            }();
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var ListViewFactory;
            !function(ListViewFactory) {
                function createListView(options) {
                    return new ListView(options);
                }
                ListViewFactory.createListView = createListView;
            }(ListViewFactory = visuals.ListViewFactory || (visuals.ListViewFactory = {}));
            var ListView = function() {
                function ListView(options) {
                    var _this = this;
                    this.options = $.extend(!0, {}, options), this.scrollbarInner = options.baseContainer.append("div").classed("scrollbar-inner", !0).on("scroll", function() {
                        return _this.renderImpl(_this.options.rowHeight);
                    }), this.scrollContainer = this.scrollbarInner.append("div").classed("scrollRegion", !0).on("touchstart", function() {
                        return _this.stopTouchPropagation();
                    }).on("touchmove", function() {
                        return _this.stopTouchPropagation();
                    }), this.visibleGroupContainer = this.scrollContainer.append("div").classed("visibleGroup", !0), 
                    $(options.baseContainer.node()).find(".scroll-element").attr("drag-resize-disabled", "true"), 
                    ListView.SetDefaultOptions(options);
                }
                return ListView.SetDefaultOptions = function(options) {
                    options.rowHeight = options.rowHeight || ListView.defaultRowHeight;
                }, ListView.prototype.rowHeight = function(rowHeight) {
                    return this.options.rowHeight = Math.ceil(rowHeight), this;
                }, ListView.prototype.data = function(data, getDatumIndex, dataReset) {
                    return void 0 === dataReset && (dataReset = !1), this._data = data, this.getDatumIndex = getDatumIndex, 
                    this.setTotalRows(), dataReset && $(this.scrollbarInner.node()).scrollTop(0), this.render(), 
                    this;
                }, ListView.prototype.viewport = function(viewport) {
                    return this.options.viewport = viewport, this.render(), this;
                }, ListView.prototype.empty = function() {
                    this._data = [], this.render();
                }, ListView.prototype.render = function() {
                    var _this = this;
                    this.renderTimeoutId && window.clearTimeout(this.renderTimeoutId), this.renderTimeoutId = window.setTimeout(function() {
                        _this.getRowHeight().then(function(rowHeight) {
                            _this.renderImpl(rowHeight);
                        }), _this.renderTimeoutId = void 0;
                    }, 0);
                }, ListView.prototype.renderImpl = function(rowHeight) {
                    var totalHeight = this.options.scrollEnabled ? Math.max(0, this._totalRows * rowHeight) : this.options.viewport.height;
                    this.scrollContainer.style("height", totalHeight + "px").attr("height", totalHeight), 
                    this.scrollToFrame(!0);
                }, ListView.prototype.stopTouchPropagation = function() {
                    if (this.options.isReadMode()) {
                        if ("touchstart" === d3.event.type) {
                            var event_1 = d3.event;
                            event_1.touches && 1 === event_1.touches.length && d3.event.stopPropagation();
                        }
                        "touchmove" === d3.event.type && d3.event.stopPropagation();
                    }
                }, ListView.prototype.scrollToFrame = function(loadMoreData) {
                    var options = this.options, visibleGroupContainer = this.visibleGroupContainer, totalRows = this._totalRows, rowHeight = options.rowHeight || ListView.defaultRowHeight, visibleRows = this.getVisibleRows(), scrollTop = this.scrollbarInner.node().scrollTop, scrollPosition = 0 === scrollTop ? 0 : Math.floor(scrollTop / rowHeight), transformAttr = visuals.SVGUtil.translateWithPixels(0, scrollPosition * rowHeight);
                    visibleGroupContainer.style({
                        transform: function(d) {
                            return transformAttr;
                        },
                        "-webkit-transform": transformAttr
                    });
                    var position0 = Math.max(0, Math.min(scrollPosition, totalRows - visibleRows + 1)), position1 = position0 + visibleRows, rowSelection = visibleGroupContainer.selectAll(".row").data(this._data.slice(position0, Math.min(position1, totalRows)), this.getDatumIndex);
                    rowSelection.enter().append("div").classed("row", !0).call(function(d) {
                        return options.enter(d);
                    }), rowSelection.order();
                    var rowUpdateSelection = visibleGroupContainer.selectAll(".row:not(.transitioning)");
                    rowUpdateSelection.call(function(d) {
                        return options.update(d);
                    }), rowSelection.exit().call(function(d) {
                        return options.exit(d);
                    }).remove(), loadMoreData && visibleRows !== totalRows && position1 >= totalRows * ListView.loadMoreDataThreshold && options.loadMoreData();
                }, ListView.prototype.setTotalRows = function() {
                    var data = this._data;
                    this._totalRows = data ? data.length : 0;
                }, ListView.prototype.getVisibleRows = function() {
                    var minimumVisibleRows = 1, options = this.options, rowHeight = options.rowHeight, viewportHeight = options.viewport.height;
                    if (!rowHeight || 1 > rowHeight) return minimumVisibleRows;
                    var viewportRowCount = viewportHeight / rowHeight;
                    return this.options.scrollEnabled ? Math.min(Math.ceil(viewportRowCount) + 1, this._totalRows) || minimumVisibleRows : Math.min(Math.floor(viewportRowCount), this._totalRows) || minimumVisibleRows;
                }, ListView.prototype.getRowHeight = function() {
                    var deferred = $.Deferred(), listView = this, options = listView.options;
                    if (this.cancelMeasurePass && this.cancelMeasurePass(), !(this._data && this._data.length && options)) return listView.rowHeight(ListView.defaultRowHeight), 
                    deferred.resolve(options.rowHeight).promise();
                    this.scrollToFrame(!1);
                    var requestAnimationFrameId = window.requestAnimationFrame(function() {
                        var rows = listView.visibleGroupContainer.select(".row");
                        if (!rows.empty()) {
                            var firstRow = rows.node(), rowHeight = Math.max($(firstRow).outerHeight(!0), $(firstRow).children().first().outerHeight(!0));
                            listView.rowHeight(rowHeight), deferred.resolve(rowHeight);
                        }
                        listView.cancelMeasurePass = void 0, window.cancelAnimationFrame(requestAnimationFrameId);
                    });
                    return this.cancelMeasurePass = function() {
                        window.cancelAnimationFrame(requestAnimationFrameId), deferred.reject();
                    }, deferred.promise();
                }, ListView.loadMoreDataThreshold = .8, ListView.defaultRowHeight = 1, ListView;
            }();
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi), Microsoft = (window.powerbitests, 
    window.InJs, window.debug, window.jasmine, window.Microsoft);
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var MapUtil, defaultLevelOfDetail = 11;
            !function(MapUtil) {
                function clip(n, minValue, maxValue) {
                    return Math.min(Math.max(n, minValue), maxValue);
                }
                function getMapSize(levelOfDetail) {
                    return 23 === levelOfDetail ? 2147483648 : Math.floor(levelOfDetail) === levelOfDetail ? 256 << levelOfDetail : 256 * Math.pow(2, levelOfDetail);
                }
                function latLongToPixelXYArray(latLongArray, levelOfDetail, buildString) {
                    void 0 === buildString && (buildString = !1);
                    for (var helperArray = [], result = {
                        array: new Float64Array(latLongArray.length),
                        arrayString: ""
                    }, i = 0; i < latLongArray.length; i += 2) {
                        var latitude = clip(latLongArray[i], MapUtil.MinAllowedLatitude, MapUtil.MaxAllowedLatitude), longitude = clip(latLongArray[i + 1], MapUtil.MinAllowedLongitude, MapUtil.MaxAllowedLongitude), x = (longitude + 180) / 360, sinLatitude = Math.sin(latitude * Math.PI / 180), y = .5 - Math.log((1 + sinLatitude) / (1 - sinLatitude)) / (4 * Math.PI), mapSize = getMapSize(levelOfDetail);
                        result.array[i] = clip(x * mapSize + .5, 0, mapSize - 1), result.array[i + 1] = clip(y * mapSize + .5, 0, mapSize - 1), 
                        buildString && (helperArray.push(result.array[i], result.array[i + 1]), helperArray.length >= pointArrayChunkLength && (result.arrayString += helperArray.join(" ") + " ", 
                        helperArray = []));
                    }
                    return buildString && (result.arrayString += helperArray.join(" ") + " "), result;
                }
                function getLocationBoundaries(latLongArray) {
                    for (var northWest = {
                        latitude: -90,
                        longitude: 180
                    }, southEast = {
                        latitude: 90,
                        longitude: -180
                    }, i = 0; i < latLongArray.length; i += 2) northWest.latitude = Math.max(latLongArray[i], northWest.latitude), 
                    northWest.longitude = Math.min(latLongArray[i + 1], northWest.longitude), southEast.latitude = Math.min(latLongArray[i], southEast.latitude), 
                    southEast.longitude = Math.max(latLongArray[i + 1], southEast.longitude);
                    return northWest.longitude = clip(northWest.longitude, -180, 180), southEast.longitude = clip(southEast.longitude, -180, 180), 
                    Microsoft.Maps.LocationRect.fromCorners(new Microsoft.Maps.Location(northWest.latitude, northWest.longitude), new Microsoft.Maps.Location(southEast.latitude, southEast.longitude));
                }
                function parseEncodedSpatialValueArray(value) {
                    for (var list = [], index = 0, xsum = 0, ysum = 0, max = 4294967296; index < value.length; ) {
                        for (var n = 0, k = 0; ;) {
                            if (index >= value.length) return null;
                            var b = safeCharacters.indexOf(value.charAt(index++));
                            if (-1 === b) return null;
                            var tmp = (31 & b) * Math.pow(2, k), ht = tmp / max, lt = tmp % max, hn = n / max, ln = n % max, nl = (lt | ln) >>> 0;
                            if (n = (ht | hn) * max + nl, k += 5, 32 > b) break;
                        }
                        var diagonal = Math.floor((Math.sqrt(8 * n + 5) - 1) / 2);
                        n -= diagonal * (diagonal + 1) / 2;
                        var ny = Math.floor(n), nx = diagonal - ny;
                        nx = nx >> 1 ^ -(1 & nx), ny = ny >> 1 ^ -(1 & ny), xsum += nx, ysum += ny;
                        var lat = 1e-5 * ysum, lon = 1e-5 * xsum;
                        list.push(lat), list.push(lon);
                    }
                    return new Float64Array(list);
                }
                function calcGeoData(data) {
                    for (var locations = data.locations, i = 0; i < locations.length; i++) {
                        var location_1 = locations[i];
                        location_1.geographic || (location_1.geographic = MapUtil.parseEncodedSpatialValueArray(location_1.nativeBing));
                        var polygon = location_1.geographic;
                        if (polygon && !location_1.absolute) {
                            var result = MapUtil.latLongToPixelXYArray(polygon, MapUtil.DefaultLevelOfDetail, !0);
                            location_1.absolute = result.array, location_1.absoluteString = result.arrayString;
                            var geographicBounds = MapUtil.getLocationBoundaries(polygon);
                            location_1.absoluteBounds = MapUtil.locationRectToRectXY(geographicBounds, MapUtil.DefaultLevelOfDetail);
                        }
                    }
                }
                function locationToPixelXY(location, levelOfDetail) {
                    return latLongToPixelXY(location.latitude, location.longitude, levelOfDetail);
                }
                function locationRectToRectXY(locationRect, levelOfDetail) {
                    var topleft = locationToPixelXY(locationRect.getNorthwest(), levelOfDetail), bottomRight = locationToPixelXY(locationRect.getSoutheast(), levelOfDetail);
                    return new powerbi.visuals.Rect(topleft.x, topleft.y, bottomRight.x - topleft.x, bottomRight.y - topleft.y);
                }
                function latLongToPixelXY(latitude, longitude, levelOfDetail) {
                    var array = latLongToPixelXYArray(new Float64Array([ latitude, longitude ]), levelOfDetail).array;
                    return new powerbi.visuals.Point(array[0], array[1]);
                }
                function pixelXYToLocation(pixelX, pixelY, levelOfDetail) {
                    var mapSize = getMapSize(levelOfDetail), x = clip(pixelX, 0, mapSize - 1) / mapSize - .5, y = .5 - clip(pixelY, 0, mapSize - 1) / mapSize, latitude = 90 - 360 * Math.atan(Math.exp(2 * -y * Math.PI)) / Math.PI, longitude = 360 * x;
                    return new Microsoft.Maps.Location(latitude, longitude);
                }
                MapUtil.Settings = {
                    MaxBingRequest: 6,
                    MaxCacheSize: 3e3,
                    MaxCacheSizeOverflow: 100,
                    BingKey: "insert your key",
                    BingUrl: "https://dev.virtualearth.net/REST/v1/Locations",
                    BingUrlGeodata: "https://platform.bing.com/geo/spatial/v1/public/Geodata?",
                    UseDoubleArrayGeodataResult: !0,
                    UseDoubleArrayDequeueTimeout: 0
                }, MapUtil.MinAllowedLatitude = -85.05112878, MapUtil.MaxAllowedLatitude = 85.05112878, 
                MapUtil.MinAllowedLongitude = -180, MapUtil.MaxAllowedLongitude = 180, MapUtil.TileSize = 256, 
                MapUtil.MaxLevelOfDetail = 23, MapUtil.MinLevelOfDetail = 1, MapUtil.MaxAutoZoomLevel = 5, 
                MapUtil.DefaultLevelOfDetail = 11, MapUtil.WorkerErrorName = "___error___", MapUtil.CategoryTypes = {
                    Address: "Address",
                    City: "City",
                    Continent: "Continent",
                    CountryRegion: "Country",
                    County: "County",
                    Longitude: "Longitude",
                    Latitude: "Latitude",
                    Place: "Place",
                    PostalCode: "PostalCode",
                    StateOrProvince: "StateOrProvince"
                };
                var safeCharacters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";
                MapUtil.clip = clip, MapUtil.getMapSize = getMapSize;
                var pointArrayChunkLength = 15e3;
                MapUtil.latLongToPixelXYArray = latLongToPixelXYArray, MapUtil.getLocationBoundaries = getLocationBoundaries, 
                MapUtil.parseEncodedSpatialValueArray = parseEncodedSpatialValueArray, MapUtil.calcGeoData = calcGeoData, 
                MapUtil.locationToPixelXY = locationToPixelXY, MapUtil.locationRectToRectXY = locationRectToRectXY, 
                MapUtil.latLongToPixelXY = latLongToPixelXY, MapUtil.pixelXYToLocation = pixelXYToLocation;
                var CurrentLocation;
                !function(CurrentLocation) {
                    function createPushpin(location) {
                        var template = '<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><circle fill="#FF5F00" cx="12" cy="12" r="6"/><circle fill="none" stroke="#FF5F00" stroke-width="2" cx="12" cy="12" r="10"/></svg>', options = {
                            draggable: !1,
                            htmlContent: template,
                            height: 24,
                            width: 24
                        };
                        return new Microsoft.Maps.Pushpin(location, options);
                    }
                    CurrentLocation.createPushpin = createPushpin;
                }(CurrentLocation = MapUtil.CurrentLocation || (MapUtil.CurrentLocation = {}));
            }(MapUtil = visuals.MapUtil || (visuals.MapUtil = {}));
            var MapPolygonInfo = function() {
                function MapPolygonInfo() {
                    this._locationRect = new Microsoft.Maps.LocationRect(new Microsoft.Maps.Location(30, -30), 60, 60);
                }
                return MapPolygonInfo.prototype.reCalc = function(mapControl, width, height) {
                    var baseLocations = [ this._locationRect.getNorthwest(), this._locationRect.getSoutheast() ];
                    if (width /= 2, height /= 2, !this._baseRect) {
                        var l0 = MapUtil.locationToPixelXY(this._locationRect.getNorthwest(), defaultLevelOfDetail), l1 = MapUtil.locationToPixelXY(this._locationRect.getSoutheast(), defaultLevelOfDetail);
                        this._baseRect = new visuals.Rect(l0.x, l0.y, l1.x - l0.x, l1.y - l0.y);
                    }
                    var l = mapControl.tryLocationToPixel(baseLocations);
                    this._currentRect = new visuals.Rect(l[0].x + width, l[0].y + height, l[1].x - l[0].x, l[1].y - l[0].y);
                }, Object.defineProperty(MapPolygonInfo.prototype, "scale", {
                    get: function() {
                        return this._baseRect ? this._currentRect.width / this._baseRect.width : 1;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(MapPolygonInfo.prototype, "transform", {
                    get: function() {
                        var base = this._baseRect, current = this._currentRect, transform = new visuals.Transform();
                        return transform.translate(current.left, current.top), transform.scale(current.width / base.width, current.height / base.height), 
                        transform.translate(-base.left, -base.top), transform;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(MapPolygonInfo.prototype, "outherTransform", {
                    get: function() {
                        var base = this._baseRect, current = this._currentRect, transform = new visuals.Transform();
                        transform.translate(current.left, current.top);
                        var scale = Math.sqrt(current.width / base.width);
                        return transform.scale(scale, scale), transform;
                    },
                    enumerable: !0,
                    configurable: !0
                }), MapPolygonInfo.prototype.setViewBox = function(svg) {
                    var rect = svg.getBoundingClientRect(), current = this._currentRect;
                    svg.setAttribute("viewBox", [ -current.left, -current.top, rect.width, rect.height ].join(" "));
                }, Object.defineProperty(MapPolygonInfo.prototype, "innerTransform", {
                    get: function() {
                        var base = this._baseRect, current = this._currentRect, transform = new visuals.Transform(), scale = current.width / base.width;
                        return transform.scale(scale, scale), transform.translate(-base.left, -base.top), 
                        transform;
                    },
                    enumerable: !0,
                    configurable: !0
                }), MapPolygonInfo.prototype.transformToString = function(transform) {
                    var m = transform.matrix;
                    return "matrix(" + m.m00 + " " + m.m10 + " " + m.m01 + " " + m.m11 + " " + m.m02 + " " + m.m12 + ")";
                }, MapPolygonInfo;
            }();
            visuals.MapPolygonInfo = MapPolygonInfo;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var utility;
            !function(utility) {
                var SelectionManager = function() {
                    function SelectionManager(options) {
                        this.dataPointObjectName = "dataPoint", this.hostServices = options.hostServices, 
                        this.selectedIds = [];
                    }
                    return SelectionManager.prototype.select = function(selectionId, multiSelect) {
                        void 0 === multiSelect && (multiSelect = !1);
                        var deferred = $.Deferred();
                        return this.hostServices.shouldRetainSelection() ? this.sendSelectionToHost([ selectionId ]) : (this.selectInternal(selectionId, multiSelect), 
                        this.sendSelectionToHost(this.selectedIds)), deferred.resolve(this.selectedIds), 
                        deferred;
                    }, SelectionManager.prototype.showContextMenu = function(selectionId, position) {
                        var deferred = $.Deferred();
                        return position = position || visuals.InteractivityUtils.getPositionOfLastInputEvent(), 
                        this.sendContextMenuToHost(selectionId, position), deferred.resolve(), deferred;
                    }, SelectionManager.prototype.hasSelection = function() {
                        return this.selectedIds.length > 0;
                    }, SelectionManager.prototype.clear = function() {
                        var deferred = $.Deferred();
                        return this.selectedIds = [], this.sendSelectionToHost([]), deferred.resolve(), 
                        deferred;
                    }, SelectionManager.prototype.getSelectionIds = function() {
                        return this.selectedIds;
                    }, SelectionManager.prototype.sendSelectionToHost = function(ids) {
                        var dataPointObjectName = this.dataPointObjectName, selectArgs = {
                            visualObjects: _.chain(ids).filter(function(value) {
                                return value.hasIdentity();
                            }).map(function(value) {
                                return {
                                    objectName: dataPointObjectName,
                                    selectorsByColumn: value.getSelectorsByColumn()
                                };
                            }).value(),
                            selectors: void 0
                        }, shouldInsertSelectors = !1;
                        _.isEmpty(ids) || (shouldInsertSelectors = ids[0].getSelector() && !ids[0].getSelectorsByColumn()), 
                        shouldInsertSelectors && (selectArgs.selectors = _.chain(ids).filter(function(value) {
                            return value.hasIdentity();
                        }).map(function(value) {
                            return value.getSelector();
                        }).value()), this.hostServices.onSelect(selectArgs);
                    }, SelectionManager.prototype.sendContextMenuToHost = function(selectionId, position) {
                        var selectors = this.getSelectorsByColumn([ selectionId ]);
                        if (!_.isEmpty(selectors)) {
                            var args = {
                                data: selectors,
                                position: position
                            };
                            this.hostServices.onContextMenu(args);
                        }
                    }, SelectionManager.prototype.getSelectorsByColumn = function(selectionIds) {
                        return _(selectionIds).filter(function(value) {
                            return value.hasIdentity;
                        }).map(function(value) {
                            return value.getSelectorsByColumn();
                        }).compact().value();
                    }, SelectionManager.prototype.selectInternal = function(selectionId, multiSelect) {
                        SelectionManager.containsSelection(this.selectedIds, selectionId) ? this.selectedIds = multiSelect ? this.selectedIds.filter(function(d) {
                            return !powerbi.data.Selector.equals(d, selectionId);
                        }) : this.selectedIds.length > 1 ? [ selectionId ] : [] : multiSelect ? this.selectedIds.push(selectionId) : this.selectedIds = [ selectionId ];
                    }, SelectionManager.containsSelection = function(list, id) {
                        return list.some(function(d) {
                            return powerbi.data.Selector.equals(d.getSelector(), id.getSelector());
                        });
                    }, SelectionManager;
                }();
                utility.SelectionManager = SelectionManager;
            }(utility = visuals.utility || (visuals.utility = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            "use strict";
            var shapes;
            !function(shapes) {
                var Utility = jsCommon.Utility, Polygon = function() {
                    function Polygon(absolutePoints) {
                        this.polygonPoints = this.convertArrayPathToPoints(absolutePoints);
                    }
                    return Polygon.prototype.absoluteCentroid = function() {
                        return null == this._absoluteCentroid && (this._absoluteCentroid = this.calculatePolygonCentroid()), 
                        this._absoluteCentroid;
                    }, Polygon.prototype.absoluteBoundingRect = function() {
                        return null == this._absoluteBoundingRect && (this._absoluteBoundingRect = this.calculateBoundingRect()), 
                        this._absoluteBoundingRect;
                    }, Polygon.prototype.contains = function(rect) {
                        var topLeft = {
                            x: rect.left,
                            y: rect.top
                        }, topRight = {
                            x: rect.left + rect.width,
                            y: rect.top
                        }, bottomLeft = {
                            x: rect.left,
                            y: rect.top + rect.height
                        }, bottomRight = {
                            x: rect.left + rect.width,
                            y: rect.top + rect.height
                        };
                        return this.inside(topLeft) && this.inside(topRight) && this.inside(bottomLeft) && this.inside(bottomRight);
                    }, Polygon.prototype.conflicts = function(rect) {
                        if (!this.isConflictWithBoundingBox(rect)) return !1;
                        var topLeft = {
                            x: rect.left,
                            y: rect.top
                        }, topCenter = {
                            x: rect.left + rect.width / 2,
                            y: rect.top
                        }, topRight = {
                            x: rect.left + rect.width,
                            y: rect.top
                        }, bottomLeft = {
                            x: rect.left,
                            y: rect.top + rect.height
                        }, bottomCenter = {
                            x: rect.left + rect.width / 2,
                            y: rect.top + rect.height
                        }, bottomRight = {
                            x: rect.left + rect.width,
                            y: rect.top + rect.height
                        }, middleLeft = {
                            x: rect.left,
                            y: rect.top + rect.height / 2
                        }, middleRight = {
                            x: rect.left + rect.width,
                            y: rect.top + rect.height / 2
                        };
                        return this.inside(topLeft) || this.inside(topCenter) || this.inside(topRight) || this.inside(bottomLeft) || this.inside(bottomCenter) || this.inside(bottomRight) || this.inside(middleLeft) || this.inside(middleRight);
                    }, Polygon.prototype.lineIntersectionPoint = function(p0, p1) {
                        for (var i = 0; i < this.polygonPoints.length; i++) {
                            var p2 = this.polygonPoints[i], p3 = i === this.polygonPoints.length - 1 ? this.polygonPoints[0] : this.polygonPoints[i + 1], intersection = this.getLineIntersection(p0, p1, p2, p3);
                            if (null !== intersection) return intersection;
                        }
                        return null;
                    }, Polygon.calculateAbsolutePolygonArea = function(polygonPoints) {
                        var i, j = 1, area = 0;
                        for (i = 0; i < polygonPoints.length; i++) area += polygonPoints[i].x * polygonPoints[j].y - polygonPoints[j].x * polygonPoints[i].y, 
                        j = (j + 1) % polygonPoints.length;
                        return area *= .5;
                    }, Polygon.prototype.isConflictWithBoundingBox = function(rect) {
                        return Rect.isIntersecting(this.absoluteBoundingRect(), rect);
                    }, Polygon.prototype.calculatePolygonCentroid = function() {
                        var area, tempPoint, cx, cy, i, j;
                        for (area = Polygon.calculateAbsolutePolygonArea(this.polygonPoints), cx = cy = 0, 
                        j = 1, i = 0; i < this.polygonPoints.length; i++) tempPoint = this.polygonPoints[i].x * this.polygonPoints[j].y - this.polygonPoints[j].x * this.polygonPoints[i].y, 
                        cx += (this.polygonPoints[i].x + this.polygonPoints[j].x) * tempPoint, cy += (this.polygonPoints[i].y + this.polygonPoints[j].y) * tempPoint, 
                        j = (j + 1) % this.polygonPoints.length;
                        return cx /= 6 * area, cy /= 6 * area, {
                            x: cx,
                            y: cy
                        };
                    }, Polygon.prototype.calculateBoundingRect = function() {
                        for (var minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY, i = 0; i < this.polygonPoints.length; i++) this.polygonPoints[i].x < minX ? minX = this.polygonPoints[i].x : this.polygonPoints[i].x > maxX && (maxX = this.polygonPoints[i].x), 
                        this.polygonPoints[i].y < minY ? minY = this.polygonPoints[i].y : this.polygonPoints[i].y > maxY && (maxY = this.polygonPoints[i].y);
                        return {
                            left: minX,
                            top: minY,
                            width: maxX - minX,
                            height: maxY - minY
                        };
                    }, Polygon.prototype.inside = function(point) {
                        for (var x = point.x, y = point.y, insideVar = !1, i = 0, j = this.polygonPoints.length - 1; i < this.polygonPoints.length; j = i++) {
                            var xi = this.polygonPoints[i].x, yi = this.polygonPoints[i].y, xj = this.polygonPoints[j].x, yj = this.polygonPoints[j].y, intersect = yi > y != yj > y && (xj - xi) * (y - yi) / (yj - yi) + xi > x;
                            intersect && (insideVar = !insideVar);
                        }
                        return insideVar;
                    }, Polygon.prototype.getLineIntersection = function(line0p1, line0p2, line1p1, line1p2) {
                        var p0_x = line0p1.x, p0_y = line0p1.y, p1_x = line0p2.x, p1_y = line0p2.y, p2_x = line1p1.x, p2_y = line1p1.y, p3_x = line1p2.x, p3_y = line1p2.y, s1_x = p1_x - p0_x, s1_y = p1_y - p0_y, s2_x = p3_x - p2_x, s2_y = p3_y - p2_y, s = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / (-s2_x * s1_y + s1_x * s2_y), t = (s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / (-s2_x * s1_y + s1_x * s2_y);
                        return s >= 0 && 1 >= s && t >= 0 && 1 >= t ? {
                            x: p0_x + t * s1_x,
                            y: p0_y + t * s1_y
                        } : null;
                    }, Polygon.prototype.convertArrayPathToPoints = function(path) {
                        for (var pointsRes = [], i = 0; i < path.length; i += 2) {
                            var x = path[i], y = path[i + 1], newPoint = {
                                x: x,
                                y: y
                            };
                            pointsRes.push(newPoint);
                        }
                        return pointsRes;
                    }, Polygon;
                }();
                shapes.Polygon = Polygon;
                var Point;
                !function(Point) {
                    function offset(point, offsetX, offsetY) {
                        var newPointX = point.x + offsetX >= 0 ? point.x + offsetX : 0, newPointY = point.y + offsetY >= 0 ? point.y + offsetY : 0;
                        return {
                            x: newPointX,
                            y: newPointY
                        };
                    }
                    function equals(point, other) {
                        return void 0 !== point && null !== point && void 0 !== other && null !== other && point.x === other.x && point.y === other.y;
                    }
                    function clone(point) {
                        return null !== point ? {
                            x: point.x,
                            y: point.y
                        } : null;
                    }
                    function toString(point) {
                        return "{x:" + point.x + ", y:" + point.y + "}";
                    }
                    function serialize(point) {
                        return point.x + "," + point.y;
                    }
                    function getDistance(point, other) {
                        if (null === point || null === other) return null;
                        var diffX = other.x - point.x, diffY = other.y - point.y;
                        return Math.sqrt(diffX * diffX + diffY * diffY);
                    }
                    function equalWithPrecision(point1, point2) {
                        return point1 === point2 || void 0 !== point1 && void 0 !== point2 && powerbi.Double.equalWithPrecision(point1.x, point2.x) && powerbi.Double.equalWithPrecision(point1.y, point2.y);
                    }
                    function parsePoint(value, defaultValue) {
                        if (null === value) return void 0 === defaultValue ? null : defaultValue;
                        if (void 0 === value) return void 0 === defaultValue ? null : defaultValue;
                        if (2 === value.length) return {
                            x: Utility.parseNumber(value[0]),
                            y: Utility.parseNumber(value[1])
                        };
                        if ("string" == typeof value) {
                            var parts = value.split(",");
                            return 2 !== parts.length ? void 0 === defaultValue ? null : defaultValue : {
                                x: Utility.parseNumber(parts[0]),
                                y: Utility.parseNumber(parts[1])
                            };
                        }
                        return 2 !== value.length && "string" != typeof value ? void 0 === defaultValue ? null : defaultValue : {
                            x: Utility.parseNumber(value.x),
                            y: Utility.parseNumber(value.y)
                        };
                    }
                    Point.offset = offset, Point.equals = equals, Point.clone = clone, Point.toString = toString, 
                    Point.serialize = serialize, Point.getDistance = getDistance, Point.equalWithPrecision = equalWithPrecision, 
                    Point.parsePoint = parsePoint;
                }(Point = shapes.Point || (shapes.Point = {}));
                var Size;
                !function(Size) {
                    function isEmpty(size) {
                        return 0 === size.width && 0 === size.height;
                    }
                    function equals(size, other) {
                        return void 0 !== size && null !== size && void 0 !== other && null !== other && size.width === other.width && size.height === other.height;
                    }
                    function clone(size) {
                        return null !== size ? {
                            width: size.width,
                            height: size.height
                        } : null;
                    }
                    function inflate(size, padding) {
                        var result = clone(size);
                        return padding && (result.width += padding.left + padding.right, result.height += padding.top + padding.bottom), 
                        result;
                    }
                    function deflate(size, padding) {
                        var result = clone(size);
                        return padding && (result.width = result.width - padding.left - padding.right, result.width < 0 && (result.width = 0), 
                        result.height = result.height - padding.top - padding.bottom, result.height < 0 && (result.height = 0)), 
                        result;
                    }
                    function combine(size, other) {
                        return other && (size.width = Math.max(size.width, other.width), size.height = Math.max(size.height, other.height)), 
                        size;
                    }
                    function toRect(size) {
                        return {
                            left: 0,
                            top: 0,
                            width: size.width,
                            height: size.height
                        };
                    }
                    function toString(size) {
                        return "{width:" + size.width + ", height:" + size.height + "}";
                    }
                    function equal(size1, size2) {
                        return size1 === size2 || void 0 !== size1 && void 0 !== size2 && size1.width === size2.width && size1.height === size2.height;
                    }
                    function equalWithPrecision(size1, size2) {
                        return size1 === size2 || void 0 !== size1 && void 0 !== size2 && powerbi.Double.equalWithPrecision(size1.width, size2.width) && powerbi.Double.equalWithPrecision(size1.height, size2.height);
                    }
                    function parseSize(value, defaultValue) {
                        if (null === value) return void 0 === defaultValue ? null : defaultValue;
                        if (void 0 === value) return void 0 === defaultValue ? null : defaultValue;
                        if (2 === value.length) return {
                            width: Utility.parseNumber(value[0]),
                            height: Utility.parseNumber(value[1])
                        };
                        if ("string" == typeof value) {
                            var parts = value.split(",");
                            return 2 !== parts.length ? void 0 === defaultValue ? null : defaultValue : {
                                width: Utility.parseNumber(parts[0]),
                                height: Utility.parseNumber(parts[1])
                            };
                        }
                        return 2 !== value.length && "string" != typeof value ? void 0 === defaultValue ? null : defaultValue : {
                            width: Utility.parseNumber(value.width),
                            height: Utility.parseNumber(value.height)
                        };
                    }
                    Size.isEmpty = isEmpty, Size.equals = equals, Size.clone = clone, Size.inflate = inflate, 
                    Size.deflate = deflate, Size.combine = combine, Size.toRect = toRect, Size.toString = toString, 
                    Size.equal = equal, Size.equalWithPrecision = equalWithPrecision, Size.parseSize = parseSize;
                }(Size = shapes.Size || (shapes.Size = {}));
                var Rect;
                !function(Rect) {
                    function getOffset(rect) {
                        return {
                            x: rect.left,
                            y: rect.top
                        };
                    }
                    function getSize(rect) {
                        return {
                            width: rect.width,
                            height: rect.height
                        };
                    }
                    function setSize(rect, value) {
                        rect.width = value.width, rect.height = value.height;
                    }
                    function right(rect) {
                        return rect.left + rect.width;
                    }
                    function bottom(rect) {
                        return rect.top + rect.height;
                    }
                    function topLeft(rect) {
                        return {
                            x: rect.left,
                            y: rect.top
                        };
                    }
                    function topRight(rect) {
                        return {
                            x: rect.left + rect.width,
                            y: rect.top
                        };
                    }
                    function bottomLeft(rect) {
                        return {
                            x: rect.left,
                            y: rect.top + rect.height
                        };
                    }
                    function bottomRight(rect) {
                        return {
                            x: rect.left + rect.width,
                            y: rect.top + rect.height
                        };
                    }
                    function equals(rect, other) {
                        return void 0 !== other && null !== other && rect.left === other.left && rect.top === other.top && rect.width === other.width && rect.height === other.height;
                    }
                    function clone(rect) {
                        return null !== rect ? {
                            left: rect.left,
                            top: rect.top,
                            width: rect.width,
                            height: rect.height
                        } : null;
                    }
                    function toString(rect) {
                        return "{left:" + rect.left + ", top:" + rect.top + ", width:" + rect.width + ", height:" + rect.height + "}";
                    }
                    function offset(rect, offsetX, offsetY) {
                        var newLeft = rect.left + offsetX >= 0 ? rect.left + offsetX : 0, newTop = rect.top + offsetY >= 0 ? rect.top + offsetY : 0;
                        return {
                            left: newLeft,
                            top: newTop,
                            width: rect.width,
                            height: rect.height
                        };
                    }
                    function inflate(rect, padding) {
                        var result = clone(rect);
                        return padding && (result.left -= padding.left, result.top -= padding.top, result.width += padding.left + padding.right, 
                        result.height += padding.top + padding.bottom), result;
                    }
                    function deflate(rect, padding) {
                        var result = clone(rect);
                        return padding && (result.left += padding.left, result.top += padding.top, result.width -= padding.left + padding.right, 
                        result.height -= padding.top + padding.bottom), result;
                    }
                    function inflateBy(rect, padding) {
                        return {
                            left: rect.left - padding,
                            top: rect.top - padding,
                            width: rect.width + padding + padding,
                            height: rect.height + padding + padding
                        };
                    }
                    function deflateBy(rect, padding) {
                        return {
                            left: rect.left + padding,
                            top: rect.top + padding,
                            width: rect.width - padding - padding,
                            height: rect.height - padding - padding
                        };
                    }
                    function getClosestPoint(rect, x, y) {
                        return {
                            x: Math.min(Math.max(rect.left, x), rect.left + rect.width),
                            y: Math.min(Math.max(rect.top, y), rect.top + rect.height)
                        };
                    }
                    function equal(rect1, rect2) {
                        return rect1 === rect2 || void 0 !== rect1 && void 0 !== rect2 && rect1.left === rect2.left && rect1.top === rect2.top && rect1.width === rect2.width && rect1.height === rect2.height;
                    }
                    function equalWithPrecision(rect1, rect2) {
                        return rect1 === rect2 || void 0 !== rect1 && void 0 !== rect2 && powerbi.Double.equalWithPrecision(rect1.left, rect2.left) && powerbi.Double.equalWithPrecision(rect1.top, rect2.top) && powerbi.Double.equalWithPrecision(rect1.width, rect2.width) && powerbi.Double.equalWithPrecision(rect1.height, rect2.height);
                    }
                    function isEmpty(rect) {
                        return void 0 === rect || null === rect || 0 === rect.width && 0 === rect.height;
                    }
                    function containsPoint(rect, point) {
                        return null === rect || null === point ? !1 : powerbi.Double.lessOrEqualWithPrecision(rect.left, point.x) && powerbi.Double.lessOrEqualWithPrecision(point.x, rect.left + rect.width) && powerbi.Double.lessOrEqualWithPrecision(rect.top, point.y) && powerbi.Double.lessOrEqualWithPrecision(point.y, rect.top + rect.height);
                    }
                    function isIntersecting(rect1, rect2) {
                        if (!rect1 || !rect2) return !1;
                        var left = Math.max(rect1.left, rect2.left), right = Math.min(rect1.left + rect1.width, rect2.left + rect2.width);
                        if (left > right) return !1;
                        var top = Math.max(rect1.top, rect2.top), bottom = Math.min(rect1.top + rect1.height, rect2.top + rect2.height);
                        return bottom >= top;
                    }
                    function intersect(rect1, rect2) {
                        if (!rect1) return rect2;
                        if (!rect2) return rect1;
                        var left = Math.max(rect1.left, rect2.left), top = Math.max(rect1.top, rect2.top), right = Math.min(rect1.left + rect1.width, rect2.left + rect2.width), bottom = Math.min(rect1.top + rect1.height, rect2.top + rect2.height);
                        return right >= left && bottom >= top ? {
                            left: left,
                            top: top,
                            width: right - left,
                            height: bottom - top
                        } : {
                            left: 0,
                            top: 0,
                            width: 0,
                            height: 0
                        };
                    }
                    function combine(rect1, rect2) {
                        if (!rect1) return rect2;
                        if (!rect2) return rect1;
                        var left = Math.min(rect1.left, rect2.left), top = Math.min(rect1.top, rect2.top), right = Math.max(rect1.left + rect1.width, rect2.left + rect2.width), bottom = Math.max(rect1.top + rect1.height, rect2.top + rect2.height);
                        return {
                            left: left,
                            top: top,
                            width: right - left,
                            height: bottom - top
                        };
                    }
                    function parseRect(value, defaultValue) {
                        if (null === value) return void 0 === defaultValue ? null : defaultValue;
                        if (void 0 === value) return void 0 === defaultValue ? null : defaultValue;
                        if (4 === value.length) return {
                            left: Utility.parseNumber(value[0]),
                            top: Utility.parseNumber(value[1]),
                            width: Utility.parseNumber(value[2]),
                            height: Utility.parseNumber(value[3])
                        };
                        if ("string" == typeof value) {
                            var parts = value.split(",");
                            return 4 !== parts.length ? void 0 === defaultValue ? null : defaultValue : {
                                left: Utility.parseNumber(parts[0]),
                                top: Utility.parseNumber(parts[1]),
                                width: Utility.parseNumber(parts[2]),
                                height: Utility.parseNumber(parts[3])
                            };
                        }
                        return 4 !== value.length && "string" != typeof value ? void 0 === defaultValue ? null : defaultValue : {
                            left: Utility.parseNumber(value.left),
                            top: Utility.parseNumber(value.top),
                            width: Utility.parseNumber(value.width),
                            height: Utility.parseNumber(value.height)
                        };
                    }
                    function getCentroid(rect) {
                        return {
                            x: rect.left + rect.width / 2,
                            y: rect.top + rect.height / 2
                        };
                    }
                    Rect.getOffset = getOffset, Rect.getSize = getSize, Rect.setSize = setSize, Rect.right = right, 
                    Rect.bottom = bottom, Rect.topLeft = topLeft, Rect.topRight = topRight, Rect.bottomLeft = bottomLeft, 
                    Rect.bottomRight = bottomRight, Rect.equals = equals, Rect.clone = clone, Rect.toString = toString, 
                    Rect.offset = offset, Rect.inflate = inflate, Rect.deflate = deflate, Rect.inflateBy = inflateBy, 
                    Rect.deflateBy = deflateBy, Rect.getClosestPoint = getClosestPoint, Rect.equal = equal, 
                    Rect.equalWithPrecision = equalWithPrecision, Rect.isEmpty = isEmpty, Rect.containsPoint = containsPoint, 
                    Rect.isIntersecting = isIntersecting, Rect.intersect = intersect, Rect.combine = combine, 
                    Rect.parseRect = parseRect, Rect.getCentroid = getCentroid;
                }(Rect = shapes.Rect || (shapes.Rect = {}));
                var Thickness;
                !function(Thickness) {
                    function inflate(thickness, other) {
                        var result = clone(thickness);
                        return other && (result.left = thickness.left + other.left, result.right = thickness.right + other.right, 
                        result.bottom = thickness.bottom + other.bottom, result.top = thickness.top + other.top), 
                        result;
                    }
                    function getWidth(thickness) {
                        return thickness.left + thickness.right;
                    }
                    function getHeight(thickness) {
                        return thickness.top + thickness.bottom;
                    }
                    function clone(thickness) {
                        return null !== thickness ? {
                            left: thickness.left,
                            top: thickness.top,
                            right: thickness.right,
                            bottom: thickness.bottom
                        } : null;
                    }
                    function equals(thickness, other) {
                        return void 0 !== thickness && null !== thickness && void 0 !== other && null !== other && thickness.left === other.left && thickness.bottom === other.bottom && thickness.right === other.right && thickness.top === other.top;
                    }
                    function flipHorizontal(thickness) {
                        var temp = thickness.right;
                        thickness.right = thickness.left, thickness.left = temp;
                    }
                    function flipVertical(thickness) {
                        var top = thickness.top;
                        thickness.top = thickness.bottom, thickness.bottom = top;
                    }
                    function toString(thickness) {
                        return "{top:" + thickness.top + ", left:" + thickness.left + ", right:" + thickness.right + ", bottom:" + thickness.bottom + "}";
                    }
                    function toCssString(thickness) {
                        return thickness.top + "px " + thickness.right + "px " + thickness.bottom + "px " + thickness.left + "px";
                    }
                    function isEmpty(thickness) {
                        return 0 === thickness.left && 0 === thickness.top && 0 === thickness.right && 0 === thickness.bottom;
                    }
                    function equal(thickness1, thickness2) {
                        return thickness1 === thickness2 || void 0 !== thickness1 && void 0 !== thickness2 && thickness1.left === thickness2.left && thickness1.top === thickness2.top && thickness1.right === thickness2.right && thickness1.bottom === thickness2.bottom;
                    }
                    function equalWithPrecision(thickness1, thickness2) {
                        return thickness1 === thickness2 || void 0 !== thickness1 && void 0 !== thickness2 && powerbi.Double.equalWithPrecision(thickness1.left, thickness2.left) && powerbi.Double.equalWithPrecision(thickness1.top, thickness2.top) && powerbi.Double.equalWithPrecision(thickness1.right, thickness2.right) && powerbi.Double.equalWithPrecision(thickness1.bottom, thickness2.bottom);
                    }
                    function parseThickness(value, defaultValue, resetValue) {
                        if (null === value) return void 0 === defaultValue ? null : defaultValue;
                        if (void 0 === value) return void 0 === defaultValue ? null : defaultValue;
                        if (4 === value.length) return {
                            left: Utility.parseNumber(value[0]),
                            top: Utility.parseNumber(value[1]),
                            right: Utility.parseNumber(value[2]),
                            bottom: Utility.parseNumber(value[3])
                        };
                        if ("string" == typeof value) {
                            var parts = value.split(",");
                            return 4 !== parts.length ? void 0 === defaultValue ? null : defaultValue : {
                                left: Utility.parseNumber(parts[0]),
                                top: Utility.parseNumber(parts[1]),
                                right: Utility.parseNumber(parts[2]),
                                bottom: Utility.parseNumber(parts[3])
                            };
                        }
                        return 4 !== value.length && "string" != typeof value ? void 0 === defaultValue ? null : defaultValue : {
                            left: Utility.parseNumber(value.left),
                            top: Utility.parseNumber(value.top),
                            right: Utility.parseNumber(value.right),
                            bottom: Utility.parseNumber(value.bottom)
                        };
                    }
                    Thickness.inflate = inflate, Thickness.getWidth = getWidth, Thickness.getHeight = getHeight, 
                    Thickness.clone = clone, Thickness.equals = equals, Thickness.flipHorizontal = flipHorizontal, 
                    Thickness.flipVertical = flipVertical, Thickness.toString = toString, Thickness.toCssString = toCssString, 
                    Thickness.isEmpty = isEmpty, Thickness.equal = equal, Thickness.equalWithPrecision = equalWithPrecision, 
                    Thickness.parseThickness = parseThickness;
                }(Thickness = shapes.Thickness || (shapes.Thickness = {}));
                var Vector;
                !function(Vector) {
                    function isEmpty(vector) {
                        return 0 === vector.x && 0 === vector.y;
                    }
                    function equals(vector, other) {
                        return void 0 !== vector && null !== vector && void 0 !== other && null !== other && vector.x === other.x && vector.y === other.y;
                    }
                    function clone(vector) {
                        return null !== vector ? {
                            x: vector.x,
                            y: vector.y
                        } : null;
                    }
                    function toString(vector) {
                        return "{x:" + vector.x + ", y:" + vector.y + "}";
                    }
                    function getLength(vector) {
                        return Math.sqrt(vector.x * vector.x + vector.y * vector.y);
                    }
                    function getLengthSqr(vector) {
                        return vector.x * vector.x + vector.y * vector.y;
                    }
                    function scale(vector, scalar) {
                        return {
                            x: vector.x * scalar,
                            y: vector.y * scalar
                        };
                    }
                    function normalize(vector) {
                        return isEmpty(vector) ? vector : scale(vector, 1 / getLength(vector));
                    }
                    function rotate90DegCW(vector) {
                        return {
                            x: vector.y,
                            y: -vector.x
                        };
                    }
                    function rotate90DegCCW(vector) {
                        return {
                            x: -vector.y,
                            y: vector.x
                        };
                    }
                    function rotate(vector, angle) {
                        var newX = vector.x * Math.cos(angle) - vector.y * Math.sin(angle), newY = vector.x * Math.sin(angle) + vector.y * Math.cos(angle);
                        return {
                            x: newX,
                            y: newY
                        };
                    }
                    function equal(vector1, vector2) {
                        return vector1 === vector2 || void 0 !== vector1 && void 0 !== vector2 && vector1.x === vector2.x && vector1.y === vector2.y;
                    }
                    function equalWithPrecision(vector1, vector2) {
                        return vector1 === vector2 || void 0 !== vector1 && void 0 !== vector2 && powerbi.Double.equalWithPrecision(vector1.x, vector2.x) && powerbi.Double.equalWithPrecision(vector1.y, vector2.y);
                    }
                    function add(vect1, vect2) {
                        return vect1 && vect2 ? {
                            x: vect1.x + vect2.x,
                            y: vect1.y + vect2.y
                        } : void 0;
                    }
                    function subtract(vect1, vect2) {
                        return vect1 && vect2 ? {
                            x: vect1.x - vect2.x,
                            y: vect1.y - vect2.y
                        } : void 0;
                    }
                    function dotProduct(vect1, vect2) {
                        return vect1 && vect2 ? vect1.x * vect2.x + vect1.y * vect2.y : void 0;
                    }
                    function getDeltaVector(p0, p1) {
                        return p0 && p1 ? {
                            x: p1.x - p0.x,
                            y: p1.y - p0.y
                        } : void 0;
                    }
                    Vector.isEmpty = isEmpty, Vector.equals = equals, Vector.clone = clone, Vector.toString = toString, 
                    Vector.getLength = getLength, Vector.getLengthSqr = getLengthSqr, Vector.scale = scale, 
                    Vector.normalize = normalize, Vector.rotate90DegCW = rotate90DegCW, Vector.rotate90DegCCW = rotate90DegCCW, 
                    Vector.rotate = rotate, Vector.equal = equal, Vector.equalWithPrecision = equalWithPrecision, 
                    Vector.add = add, Vector.subtract = subtract, Vector.dotProduct = dotProduct, Vector.getDeltaVector = getDeltaVector;
                }(Vector = shapes.Vector || (shapes.Vector = {}));
            }(shapes = visuals.shapes || (visuals.shapes = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var SlicerUtil, Color = jsCommon.Color, PixelConverter = jsCommon.PixelConverter, SQExprBuilder = powerbi.data.SQExprBuilder, SemanticFilter = powerbi.data.SemanticFilter;
            !function(SlicerUtil) {
                function getContainsFilter(expr, containsText) {
                    var containsTextExpr = SQExprBuilder.text(containsText), filterExpr = SQExprBuilder.contains(expr, containsTextExpr);
                    return SemanticFilter.fromSQExpr(filterExpr);
                }
                function tryRemoveValueFromRetainedList(value, selectedScopeIds, caseInsensitive) {
                    if (!value || _.isEmpty(selectedScopeIds)) return !1;
                    for (var i = 0, len = selectedScopeIds.length; len > i; i++) {
                        var retainedValueScopeId = selectedScopeIds[i];
                        if (powerbi.DataViewScopeIdentity.equals(value, retainedValueScopeId, caseInsensitive)) return selectedScopeIds.splice(i, 1), 
                        !0;
                    }
                    return !1;
                }
                function getUpdatedSelfFilter(searchKey, metaData) {
                    if (metaData && !_.isEmpty(searchKey)) {
                        var column = _.first(metaData.columns);
                        return column && column.expr ? SlicerUtil.getContainsFilter(column.expr, searchKey) : void 0;
                    }
                }
                var Selectors;
                !function(Selectors) {
                    var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
                    Selectors.HeaderContainer = createClassAndSelector("headerContainer"), Selectors.Header = createClassAndSelector("slicerHeader"), 
                    Selectors.TitleHeader = createClassAndSelector("titleHeader"), Selectors.HeaderText = createClassAndSelector("headerText"), 
                    Selectors.Body = createClassAndSelector("slicerBody"), Selectors.Label = createClassAndSelector("slicerLabel"), 
                    Selectors.LabelText = createClassAndSelector("slicerText"), Selectors.LabelImage = createClassAndSelector("slicerImage"), 
                    Selectors.CountText = createClassAndSelector("slicerCountText"), Selectors.Clear = createClassAndSelector("clear"), 
                    Selectors.SearchHeader = createClassAndSelector("searchHeader"), Selectors.SearchInput = createClassAndSelector("searchInput"), 
                    Selectors.SearchHeaderCollapsed = createClassAndSelector("collapsed"), Selectors.SearchHeaderShow = createClassAndSelector("show"), 
                    Selectors.MultiSelectEnabled = createClassAndSelector("isMultiSelectEnabled");
                }(Selectors = SlicerUtil.Selectors || (SlicerUtil.Selectors = {}));
                var DisplayNameKeys;
                !function(DisplayNameKeys) {
                    DisplayNameKeys.Clear = "Slicer_Clear", DisplayNameKeys.SelectAll = "Slicer_SelectAll", 
                    DisplayNameKeys.Search = "SearchBox_Text";
                }(DisplayNameKeys = SlicerUtil.DisplayNameKeys || (SlicerUtil.DisplayNameKeys = {}));
                var SettingsHelper;
                !function(SettingsHelper) {
                    function areSettingsDefined(data) {
                        return null != data && null != data.slicerSettings;
                    }
                    SettingsHelper.areSettingsDefined = areSettingsDefined;
                }(SettingsHelper = SlicerUtil.SettingsHelper || (SlicerUtil.SettingsHelper = {}));
                var DefaultValueHandler;
                !function(DefaultValueHandler) {
                    function getIdentityFields(dataView) {
                        if (dataView) {
                            var dataViewCategorical = dataView.categorical;
                            if (dataViewCategorical && !_.isEmpty(dataViewCategorical.categories)) return dataViewCategorical.categories[0].identityFields;
                        }
                    }
                    DefaultValueHandler.getIdentityFields = getIdentityFields;
                }(DefaultValueHandler = SlicerUtil.DefaultValueHandler || (SlicerUtil.DefaultValueHandler = {})), 
                SlicerUtil.getContainsFilter = getContainsFilter, SlicerUtil.tryRemoveValueFromRetainedList = tryRemoveValueFromRetainedList, 
                SlicerUtil.getUpdatedSelfFilter = getUpdatedSelfFilter;
                var DOMHelper = function() {
                    function DOMHelper() {}
                    return DOMHelper.prototype.createSlicerHeader = function(hostServices) {
                        var slicerHeaderDiv = document.createElement("div");
                        slicerHeaderDiv.className = Selectors.Header["class"];
                        var slicerHeader = d3.select(slicerHeaderDiv), slicerTitle = slicerHeader.append("h2").classed(Selectors.TitleHeader["class"], !0);
                        slicerTitle.append("span").classed(Selectors.Clear["class"], !0).attr("title", hostServices.getLocalizedString(DisplayNameKeys.Clear)), 
                        slicerTitle.append("div").classed(Selectors.HeaderText["class"], !0);
                        var slicerSearch = slicerHeader.append("div").classed(Selectors.SearchHeader["class"], !0).classed(Selectors.SearchHeaderCollapsed["class"], !0);
                        return slicerSearch.append("span").classed("powervisuals-glyph search", !0).attr("title", hostServices.getLocalizedString(DisplayNameKeys.Search)), 
                        slicerSearch.append("input").attr("type", "text").classed(Selectors.SearchInput["class"], !0).attr("drag-resize-disabled", "true"), 
                        slicerHeaderDiv;
                    }, DOMHelper.prototype.getHeaderTextProperties = function(settings) {
                        var headerTextProperties = {
                            fontFamily: visuals.Font.Family.regular.css,
                            fontSize: "10px"
                        };
                        return settings.header.show && (headerTextProperties.fontSize = PixelConverter.fromPoint(settings.header.textSize)), 
                        headerTextProperties;
                    }, DOMHelper.prototype.getSlicerBodyViewport = function(currentViewport, settings, headerTextProperties) {
                        var headerHeight = settings.header.show ? this.getHeaderHeight(settings, headerTextProperties) : 0, searchHeaderHight = settings.search.enabled ? DOMHelper.SearchInputHeight : 0, slicerBodyHeight = currentViewport.height - (headerHeight + settings.header.borderBottomWidth + searchHeaderHight);
                        return {
                            height: slicerBodyHeight,
                            width: currentViewport.width
                        };
                    }, DOMHelper.prototype.updateSlicerBodyDimensions = function(currentViewport, slicerBody, settings) {
                        var slicerViewport = this.getSlicerBodyViewport(currentViewport, settings, this.getHeaderTextProperties(settings));
                        slicerBody.style({
                            height: PixelConverter.toString(slicerViewport.height),
                            width: PixelConverter.toString(slicerViewport.width)
                        });
                    }, DOMHelper.prototype.getHeaderHeight = function(settings, textProperties) {
                        return powerbi.TextMeasurementService.estimateSvgTextHeight(this.getTextProperties(settings.header.textSize, textProperties)) + settings.general.outlineWeight;
                    }, DOMHelper.prototype.getRowHeight = function(settings, textProperties) {
                        return powerbi.TextMeasurementService.estimateSvgTextHeight(this.getTextProperties(settings.slicerText.textSize, textProperties)) + this.getRowsOutlineWidth(settings.slicerText.outline, settings.general.outlineWeight);
                    }, DOMHelper.prototype.styleSlicerHeader = function(slicerHeader, settings, headerText) {
                        var titleHeader = slicerHeader.select(SlicerUtil.Selectors.TitleHeader.selector), searchHeader = slicerHeader.select(SlicerUtil.Selectors.SearchHeader.selector);
                        if (settings.header.show) {
                            titleHeader.style("display", "block");
                            var headerTextElement = slicerHeader.select(Selectors.HeaderText.selector).text(headerText);
                            this.setSlicerHeaderTextStyle(titleHeader, headerTextElement, settings, settings.search.enabled);
                        } else titleHeader.style("display", "none");
                        settings.search.enabled ? (searchHeader.classed(Selectors.SearchHeaderShow["class"], !0), 
                        searchHeader.classed(Selectors.SearchHeaderCollapsed["class"], !1)) : (searchHeader.classed(Selectors.SearchHeaderShow["class"], !1), 
                        searchHeader.classed(Selectors.SearchHeaderCollapsed["class"], !0));
                    }, DOMHelper.prototype.setSlicerTextStyle = function(slicerText, settings) {
                        slicerText.style({
                            color: settings.slicerText.color,
                            "background-color": settings.slicerText.background,
                            "border-style": "solid",
                            "border-color": settings.general.outlineColor,
                            "border-width": visuals.VisualBorderUtil.getBorderWidth(settings.slicerText.outline, settings.general.outlineWeight),
                            "font-size": PixelConverter.fromPoint(settings.slicerText.textSize),
                            "line-height": Math.floor(1.79 * settings.slicerText.textSize) + "px"
                        });
                        var color = this.calculateSlicerTextHighlightColor(settings.slicerText.color);
                        slicerText.on("mouseover", function(d) {
                            d3.select(this).style({
                                color: color
                            });
                        }), slicerText.on("mouseout", function(d) {
                            d3.select(this).style({
                                color: settings.slicerText.color
                            });
                        });
                    }, DOMHelper.prototype.getRowsOutlineWidth = function(outlineElement, outlineWeight) {
                        switch (outlineElement) {
                          case visuals.outline.none:
                          case visuals.outline.leftRight:
                            return 0;

                          case visuals.outline.bottomOnly:
                          case visuals.outline.topOnly:
                            return outlineWeight;

                          case visuals.outline.topBottom:
                          case visuals.outline.frame:
                            return 2 * outlineWeight;

                          default:
                            return 0;
                        }
                    }, DOMHelper.prototype.setSlicerHeaderTextStyle = function(slicerHeader, headerTextElement, settings, searchEnabled) {
                        var hideOutline = !1;
                        if (searchEnabled) {
                            var defaultSetting = visuals.Slicer.DefaultStyleProperties();
                            hideOutline = settings.header.outline === defaultSetting.header.outline && settings.general.outlineWeight === defaultSetting.general.outlineWeight && settings.general.outlineColor === defaultSetting.general.outlineColor;
                        }
                        slicerHeader.style({
                            "border-style": hideOutline ? "none" : "solid",
                            "border-color": settings.general.outlineColor,
                            "border-width": visuals.VisualBorderUtil.getBorderWidth(settings.header.outline, settings.general.outlineWeight)
                        }), headerTextElement.style({
                            color: settings.header.fontColor,
                            "background-color": settings.header.background,
                            "font-size": PixelConverter.fromPoint(settings.header.textSize)
                        });
                    }, DOMHelper.prototype.calculateSlicerTextHighlightColor = function(color) {
                        var rgbColor = Color.parseColorString(color);
                        return 255 === rgbColor.R && 255 === rgbColor.G && 255 === rgbColor.B ? "#C8C8C8" : Color.calculateHighlightColor(rgbColor, .8, .2);
                    }, DOMHelper.prototype.getTextProperties = function(textSize, textProperties) {
                        return textProperties.fontSize = PixelConverter.fromPoint(textSize), textProperties;
                    }, DOMHelper.SearchInputHeight = 20, DOMHelper;
                }();
                SlicerUtil.DOMHelper = DOMHelper;
            }(SlicerUtil = visuals.SlicerUtil || (visuals.SlicerUtil = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var tooltipUtils;
            !function(tooltipUtils) {
                function tooltipUpdate(selection, tooltips) {
                    if (0 !== tooltips.length) {
                        var titles = selection.selectAll("title"), titlesUpdate = titles.data(function(d, i) {
                            return [ tooltips[i] ];
                        });
                        titlesUpdate.enter().append("title"), titlesUpdate.exit().remove(), titlesUpdate.text(function(d) {
                            return d;
                        });
                    }
                }
                tooltipUtils.tooltipUpdate = tooltipUpdate;
            }(tooltipUtils = visuals.tooltipUtils || (visuals.tooltipUtils = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var SVGUtil;
            !function(SVGUtil) {
                function translate(x, y) {
                    return "translate(" + x + "," + y + ")";
                }
                function translateXWithPixels(x) {
                    return "translateX(" + x + "px)";
                }
                function translateWithPixels(x, y) {
                    return "translate(" + x + "px," + y + "px)";
                }
                function translateAndRotate(x, y, px, py, angle) {
                    return "translate(" + x + "," + y + ") rotate(" + angle + "," + px + "," + py + ")";
                }
                function scale(scale) {
                    return "scale(" + scale + ")";
                }
                function translateAndScale(x, y, ratio) {
                    return "translate(" + x + "," + y + ") scale(" + ratio + ")";
                }
                function transformOrigin(xOffset, yOffset) {
                    return xOffset + " " + yOffset;
                }
                function flushAllD3Transitions() {
                    var now = Date.now;
                    Date.now = function() {
                        return 1 / 0;
                    }, d3.timer.flush(), Date.now = now;
                }
                function flushAllD3TransitionsIfNeeded(options) {
                    if (options) {
                        var animationOptions = options, asVisualInitOptions = options;
                        asVisualInitOptions.animation && (animationOptions = asVisualInitOptions.animation), 
                        animationOptions && animationOptions.transitionImmediate && flushAllD3Transitions();
                    }
                }
                function ensureDAttribute(pathElement) {
                    pathElement.getAttribute("d") || pathElement.setAttribute("d", "");
                }
                function ensureValidSVGPoint(point) {
                    isNaN(point.x) && (point.x = 0), isNaN(point.y) && (point.y = 0);
                }
                function parseTranslateTransform(input) {
                    if (!input || 0 === input.length) return {
                        x: "0",
                        y: "0"
                    };
                    var xValue, translateCoordinates = input.split(/[\s,]+/), yValue = "0", xCoord = translateCoordinates[0];
                    if (1 === translateCoordinates.length) xValue = xCoord.substring(10, xCoord.length - 1); else {
                        var yCoord = translateCoordinates[1];
                        yValue = yCoord.substring(0, yCoord.length - 1), xValue = xCoord.substring(10, xCoord.length);
                    }
                    return {
                        x: xValue,
                        y: yValue
                    };
                }
                function createArrow(width, height, rotate) {
                    var transform = "rotate(" + rotate + " " + width / 2 + " " + height / 2 + ")", path = "M0 0";
                    return path += "L0 " + height, path += "L" + width + " " + height / 2 + " Z", {
                        path: path,
                        transform: transform
                    };
                }
                function getTransformScaleRatios(svgElement) {
                    if (null != svgElement) {
                        var scaledRect = svgElement.getBoundingClientRect(), domRect = svgElement.getBBox();
                        if (domRect.height > 0 && domRect.width > 0) return {
                            x: scaledRect.width / domRect.width,
                            y: scaledRect.height / domRect.height
                        };
                    }
                    return {
                        x: 1,
                        y: 1
                    };
                }
                SVGUtil.AlmostZero = 1e-6, SVGUtil.translate = translate, SVGUtil.translateXWithPixels = translateXWithPixels, 
                SVGUtil.translateWithPixels = translateWithPixels, SVGUtil.translateAndRotate = translateAndRotate, 
                SVGUtil.scale = scale, SVGUtil.translateAndScale = translateAndScale, SVGUtil.transformOrigin = transformOrigin, 
                SVGUtil.flushAllD3Transitions = flushAllD3Transitions, SVGUtil.flushAllD3TransitionsIfNeeded = flushAllD3TransitionsIfNeeded, 
                SVGUtil.ensureDAttribute = ensureDAttribute, SVGUtil.ensureValidSVGPoint = ensureValidSVGPoint, 
                SVGUtil.parseTranslateTransform = parseTranslateTransform, SVGUtil.createArrow = createArrow, 
                SVGUtil.getTransformScaleRatios = getTransformScaleRatios;
            }(SVGUtil = visuals.SVGUtil || (visuals.SVGUtil = {}));
            var SVGScaleDetector = function() {
                function SVGScaleDetector(svgElement) {
                    this.scaleDetectorElement = svgElement.append("rect").classed("scale-detector", !0).attr({
                        width: 1,
                        height: 1,
                        "stroke-width": "0px",
                        fill: "none"
                    }).node();
                }
                return SVGScaleDetector.prototype.getScale = function() {
                    var scaledRect = this.scaleDetectorElement.getBoundingClientRect(), domRect = this.scaleDetectorElement.getBBox();
                    return domRect.height > 0 && domRect.width > 0 ? {
                        x: scaledRect.width / domRect.width,
                        y: scaledRect.height / domRect.height
                    } : {
                        x: 1,
                        y: 1
                    };
                }, SVGScaleDetector;
            }();
            visuals.SVGScaleDetector = SVGScaleDetector;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var TextUtil;
            !function(TextUtil) {
                function removeBreakingSpaces(str) {
                    return str.toString().replace(new RegExp(" ", "g"), "&nbsp");
                }
                function removeEllipses(str) {
                    return str.replace(/…/g, "");
                }
                function replaceSpaceWithNBSP(txt) {
                    return null != txt ? txt.replace(/ /g, " ") : void 0;
                }
                TextUtil.removeBreakingSpaces = removeBreakingSpaces, TextUtil.removeEllipses = removeEllipses, 
                TextUtil.replaceSpaceWithNBSP = replaceSpaceWithNBSP;
            }(TextUtil = visuals.TextUtil || (visuals.TextUtil = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var GradientUtils, DataRoleHelper = powerbi.data.DataRoleHelper;
            !function(GradientUtils) {
                function getFillRuleRole(objectDescs) {
                    if (objectDescs) for (var objectName in objectDescs) {
                        var objectDesc = objectDescs[objectName];
                        for (var propertyName in objectDesc.properties) {
                            var propertyDesc = objectDesc.properties[propertyName];
                            if (propertyDesc.type && propertyDesc.type[FillRulePropertyIdentifier]) return propertyDesc.rule.inputRole;
                        }
                    }
                }
                function shouldShowGradient(visualConfig) {
                    var isShowGradienCard = !!(visualConfig && visualConfig.query && visualConfig.query.projections && visualConfig.query.projections.Gradient);
                    return isShowGradienCard;
                }
                function getUpdatedGradientSettings(gradientObject) {
                    var gradientSettings;
                    if (gradientObject && !$.isEmptyObject(gradientObject)) {
                        gradientSettings = getDefaultGradientSettings();
                        for (var propertyName in gradientSettings) {
                            var hasProperty = gradientObject.hasOwnProperty(propertyName);
                            if (hasProperty) {
                                var value = gradientObject[propertyName];
                                value && value.solid && value.solid.color && (value = value.solid.color), gradientSettings[propertyName] = value;
                            }
                        }
                    }
                    return gradientSettings;
                }
                function getGradientMeasureIndex(dataViewCategorical) {
                    if (dataViewCategorical && dataViewCategorical.values && dataViewCategorical.values.grouped) {
                        var grouped = dataViewCategorical.values.grouped();
                        return DataRoleHelper.getMeasureIndexOfRole(grouped, "Gradient");
                    }
                    return -1;
                }
                function getGradientValueColumn(dataViewCategorical) {
                    if (null == dataViewCategorical) return null;
                    var gradientMeasureIndex = GradientUtils.getGradientMeasureIndex(dataViewCategorical), gradientValueColumn = -1 === gradientMeasureIndex ? null : dataViewCategorical.values[gradientMeasureIndex];
                    return gradientValueColumn;
                }
                function hasGradientRole(dataViewCategorical) {
                    var gradientMeasureIndex = getGradientMeasureIndex(dataViewCategorical);
                    return gradientMeasureIndex >= 0;
                }
                function getDefaultGradientSettings() {
                    var colors = getDefaultColors(), gradientSettings = {
                        diverging: !1,
                        minColor: colors.minColor,
                        midColor: DefaultMidColor,
                        maxColor: colors.maxColor,
                        minValue: void 0,
                        midValue: void 0,
                        maxValue: void 0
                    };
                    return gradientSettings;
                }
                function getDefaultFillRuleDefinition() {
                    return getLinearGradien2FillRuleDefinition();
                }
                function updateFillRule(propertyName, propertyValue, definitions) {
                    var numericValueExpr, colorValueExpr, dataPointObjectDefinition = powerbi.data.DataViewObjectDefinitions.ensure(definitions, DataPointPropertyIdentifier, null), fillRule = getFillRule(definitions);
                    fillRule && ($.isNumeric(propertyValue) && (numericValueExpr = void 0 !== propertyValue ? SQExprBuilder["double"](+propertyValue) : void 0), 
                    "minColor" !== propertyName && "midColor" !== propertyName && "maxColor" !== propertyName || (colorValueExpr = getColorExpressionValue(fillRule, propertyName, propertyValue)), 
                    "minColor" === propertyName ? updateMinColor(fillRule, colorValueExpr) : "midColor" === propertyName ? updateMidColor(fillRule, colorValueExpr) : "maxColor" === propertyName ? updateMaxColor(fillRule, colorValueExpr) : "minValue" === propertyName ? updateMinValue(fillRule, numericValueExpr) : "midValue" === propertyName ? updateMidValue(fillRule, numericValueExpr) : "maxValue" === propertyName ? updateMaxValue(fillRule, numericValueExpr) : "diverging" === propertyName ? (fillRule = propertyValue ? getLinearGradien3FillRuleDefinition(fillRule) : getLinearGradien2FillRuleDefinition(fillRule), 
                    dataPointObjectDefinition.properties[FillRulePropertyIdentifier] = fillRule) : "revertToDefault" === propertyName && (fillRule = this.getDefaultFillRuleDefinition(), 
                    dataPointObjectDefinition.properties[FillRulePropertyIdentifier] = fillRule));
                }
                function getGradientSettings(baseFillRule) {
                    return baseFillRule ? getGradientSettingsFromRule(baseFillRule) : getDefaultGradientSettings();
                }
                function getFillRule(objectDefinitions) {
                    var fillRuleDefinition = powerbi.data.DataViewObjectDefinitions.getValue(objectDefinitions, {
                        objectName: DataPointPropertyIdentifier,
                        propertyName: FillRulePropertyIdentifier
                    }, null);
                    return fillRuleDefinition;
                }
                function getDefaultColors() {
                    var dataColors = new powerbi.visuals.DataColorPalette(), maxColorInfo = dataColors.getColorByIndex(0), colors = d3.scale.linear().domain([ 0, 100 ]).range([ "#ffffff", maxColorInfo.value ]), maxColor = maxColorInfo.value, minColor = colors(20), midColor = DefaultMidColor;
                    return {
                        minColor: minColor,
                        midColor: midColor,
                        maxColor: maxColor
                    };
                }
                function getGradientSettingsFromRule(fillRule) {
                    var maxColor, minColor, maxValue, midValue, minValue, midColor = DefaultMidColor, diverging = void 0 !== fillRule.linearGradient3;
                    if (fillRule.linearGradient2) {
                        var maxColorExpr = fillRule.linearGradient2.max.color, minColorExpr = fillRule.linearGradient2.min.color, maxValueExpr = fillRule.linearGradient2.max.value, minValueExpr = fillRule.linearGradient2.min.value;
                        maxColor = maxColorExpr.value, minColor = minColorExpr.value, maxValueExpr && (maxValue = maxValueExpr.value), 
                        minValueExpr && (minValue = minValueExpr.value);
                    } else if (fillRule.linearGradient3) {
                        var maxColorExpr = fillRule.linearGradient3.max.color, midColorExpr = fillRule.linearGradient3.mid.color, minColorExpr = fillRule.linearGradient3.min.color, maxValueExpr = fillRule.linearGradient3.max.value, midValueExpr = fillRule.linearGradient3.mid.value, minValueExpr = fillRule.linearGradient3.min.value;
                        maxColor = maxColorExpr.value, midColor = midColorExpr.value, minColor = minColorExpr.value, 
                        maxValueExpr && (maxValue = maxValueExpr.value), midValueExpr && (midValue = midValueExpr.value), 
                        minValueExpr && (minValue = minValueExpr.value);
                    }
                    return {
                        diverging: diverging,
                        minColor: minColor,
                        midColor: midColor,
                        maxColor: maxColor,
                        minValue: minValue,
                        midValue: midValue,
                        maxValue: maxValue
                    };
                }
                function getGradientBarColors(gradientSettings) {
                    var colors = [];
                    return gradientSettings.minColor = gradientSettings.minColor || DefaultColor, colors.push(gradientSettings.minColor), 
                    gradientSettings.diverging && (gradientSettings.midColor = gradientSettings.midColor || DefaultColor, 
                    colors.push(gradientSettings.midColor || DefaultColor)), gradientSettings.maxColor = gradientSettings.maxColor || DefaultColor, 
                    colors.push(gradientSettings.maxColor || DefaultColor), colors.join(",");
                }
                function getLinearGradien2FillRuleDefinition(baseFillRule) {
                    var gradientSettings = getGradientSettings(baseFillRule), fillRuleDefinition = {
                        linearGradient2: {
                            max: {
                                color: SQExprBuilder.text(gradientSettings.maxColor)
                            },
                            min: {
                                color: SQExprBuilder.text(gradientSettings.minColor)
                            }
                        }
                    };
                    return fillRuleDefinition;
                }
                function getLinearGradien3FillRuleDefinition(baseFillRule) {
                    var gradientSettings = getGradientSettings(baseFillRule), fillRuleDefinition = {
                        linearGradient3: {
                            max: {
                                color: SQExprBuilder.text(gradientSettings.maxColor)
                            },
                            mid: {
                                color: SQExprBuilder.text(gradientSettings.midColor)
                            },
                            min: {
                                color: SQExprBuilder.text(gradientSettings.minColor)
                            }
                        }
                    };
                    return fillRuleDefinition;
                }
                function getDefaultColorExpression(fillRule, propertyName) {
                    var defaultColor, defaultFillRule;
                    return fillRule.linearGradient3 ? (defaultFillRule = getLinearGradien3FillRuleDefinition(), 
                    "minColor" === propertyName ? defaultColor = defaultFillRule.linearGradient3.min.color : "midColor" === propertyName ? defaultColor = defaultFillRule.linearGradient3.mid.color : "maxColor" === propertyName && (defaultColor = defaultFillRule.linearGradient3.max.color)) : fillRule.linearGradient2 && (defaultFillRule = getLinearGradien2FillRuleDefinition(), 
                    "minColor" === propertyName ? defaultColor = defaultFillRule.linearGradient2.min.color : "maxColor" === propertyName && (defaultColor = defaultFillRule.linearGradient2.max.color)), 
                    defaultColor;
                }
                function getColorExpressionValue(fillRule, propertyName, propertyValue) {
                    var colorExpressionValue;
                    return colorExpressionValue = propertyValue ? SQExprBuilder.text(propertyValue) : getDefaultColorExpression(fillRule, propertyName);
                }
                function updateMinColor(fillRule, colorExpressionValue) {
                    fillRule.linearGradient2 ? fillRule.linearGradient2.min.color = colorExpressionValue : fillRule.linearGradient3 && (fillRule.linearGradient3.min.color = colorExpressionValue);
                }
                function updateMidColor(fillRule, colorExpressionValue) {
                    fillRule.linearGradient3 && (fillRule.linearGradient3.mid.color = colorExpressionValue);
                }
                function updateMaxColor(fillRule, colorExpressionValue) {
                    fillRule.linearGradient2 ? fillRule.linearGradient2.max.color = colorExpressionValue : fillRule.linearGradient3 && (fillRule.linearGradient3.max.color = colorExpressionValue);
                }
                function updateMinValue(fillRule, value) {
                    fillRule.linearGradient2 ? fillRule.linearGradient2.min.value = value : fillRule.linearGradient3 && (fillRule.linearGradient3.min.value = value);
                }
                function updateMidValue(fillRule, value) {
                    fillRule.linearGradient3 && (fillRule.linearGradient3.mid.value = value);
                }
                function updateMaxValue(fillRule, value) {
                    fillRule.linearGradient2 ? fillRule.linearGradient2.max.value = value : fillRule.linearGradient3 && (fillRule.linearGradient3.max.value = value);
                }
                var SQExprBuilder = powerbi.data.SQExprBuilder, DefaultMidColor = "#ffffff", DefaultColor = DefaultMidColor, DataPointPropertyIdentifier = "dataPoint", FillRulePropertyIdentifier = "fillRule";
                GradientUtils.getFillRuleRole = getFillRuleRole, GradientUtils.shouldShowGradient = shouldShowGradient, 
                GradientUtils.getUpdatedGradientSettings = getUpdatedGradientSettings, GradientUtils.getGradientMeasureIndex = getGradientMeasureIndex, 
                GradientUtils.getGradientValueColumn = getGradientValueColumn, GradientUtils.hasGradientRole = hasGradientRole, 
                GradientUtils.getDefaultGradientSettings = getDefaultGradientSettings, GradientUtils.getDefaultFillRuleDefinition = getDefaultFillRuleDefinition, 
                GradientUtils.updateFillRule = updateFillRule, GradientUtils.getGradientSettings = getGradientSettings, 
                GradientUtils.getFillRule = getFillRule, GradientUtils.getGradientSettingsFromRule = getGradientSettingsFromRule, 
                GradientUtils.getGradientBarColors = getGradientBarColors;
            }(GradientUtils = visuals.GradientUtils || (visuals.GradientUtils = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var visualBackgroundHelper;
            !function(visualBackgroundHelper) {
                function getDefaultColor() {
                    return "#FFF";
                }
                function getDefaultTransparency() {
                    return 50;
                }
                function getDefaultShow() {
                    return !1;
                }
                function getDefaultValues() {
                    return {
                        color: getDefaultColor(),
                        transparency: getDefaultTransparency(),
                        show: getDefaultShow()
                    };
                }
                function enumeratePlot(enumeration, background) {
                    var transparency = background && background.transparency;
                    null == transparency && (transparency = getDefaultTransparency());
                    var backgroundObject = {
                        selector: null,
                        properties: {
                            transparency: transparency,
                            image: background && background.image
                        },
                        objectName: "plotArea"
                    };
                    enumeration.pushInstance(backgroundObject);
                }
                function renderBackgroundImage(background, visualElement, layout) {
                    var image = background && background.image, imageUrl = image && image.url, imageFit = image && image.scaling, imageTransparency = background && background.transparency, backgroundImage = visualElement.children(".background-image");
                    if (!imageUrl) return void (0 !== backgroundImage.length && backgroundImage.remove());
                    switch (0 === backgroundImage.length && (visualElement.prepend('<div class="background-image"></div>'), 
                    backgroundImage = visualElement.children(".background-image"), backgroundImage.css("position", "absolute")), 
                    backgroundImage.css({
                        width: layout.width,
                        height: layout.height,
                        "margin-left": layout.left,
                        "margin-top": layout.top
                    }), backgroundImage.css({
                        "background-image": "url(" + imageUrl + ")",
                        "background-repeat": "no-repeat",
                        opacity: (100 - imageTransparency) / 100
                    }), imageFit) {
                      case visuals.imageScalingType.normal:
                        backgroundImage.css({
                            "background-size": "",
                            "background-position": "50% 50%"
                        });
                        break;

                      case visuals.imageScalingType.fit:
                        backgroundImage.css({
                            "background-size": "100% 100%",
                            "background-position": ""
                        });
                        break;

                      case visuals.imageScalingType.fill:
                        backgroundImage.css({
                            "background-size": "100%",
                            "background-position": "50% 50%"
                        });
                        break;

                      default:
                        backgroundImage.css({
                            "background-size": "",
                            "background-position": "50% 50%"
                        });
                    }
                }
                visualBackgroundHelper.getDefaultColor = getDefaultColor, visualBackgroundHelper.getDefaultTransparency = getDefaultTransparency, 
                visualBackgroundHelper.getDefaultShow = getDefaultShow, visualBackgroundHelper.getDefaultValues = getDefaultValues, 
                visualBackgroundHelper.enumeratePlot = enumeratePlot, visualBackgroundHelper.renderBackgroundImage = renderBackgroundImage;
            }(visualBackgroundHelper = visuals.visualBackgroundHelper || (visuals.visualBackgroundHelper = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var Selector = powerbi.data.Selector, ObjectEnumerationBuilder = function() {
                function ObjectEnumerationBuilder() {}
                return ObjectEnumerationBuilder.prototype.pushInstance = function(instance) {
                    var instances = this.instances;
                    instances || (instances = this.instances = []);
                    var containerIdx = this.containerIdx;
                    null != containerIdx && (instance.containerIdx = containerIdx);
                    for (var _i = 0, instances_1 = instances; _i < instances_1.length; _i++) {
                        var existingInstance = instances_1[_i];
                        if (this.canMerge(existingInstance, instance)) return this.extend(existingInstance, instance, "properties"), 
                        this.extend(existingInstance, instance, "validValues"), this;
                    }
                    return instances.push(instance), this;
                }, ObjectEnumerationBuilder.prototype.pushContainer = function(container) {
                    var containers = this.containers;
                    containers || (containers = this.containers = []);
                    var updatedLen = containers.push(container);
                    return this.containerIdx = updatedLen - 1, this;
                }, ObjectEnumerationBuilder.prototype.popContainer = function() {
                    return this.containerIdx = void 0, this;
                }, ObjectEnumerationBuilder.prototype.complete = function() {
                    if (this.instances) {
                        var result = {
                            instances: this.instances
                        }, containers = this.containers;
                        return containers && (result.containers = containers), result;
                    }
                }, ObjectEnumerationBuilder.prototype.canMerge = function(x, y) {
                    return x.objectName === y.objectName && x.containerIdx === y.containerIdx && Selector.equals(x.selector, y.selector);
                }, ObjectEnumerationBuilder.prototype.extend = function(target, source, propertyName) {
                    var sourceValues = source[propertyName];
                    if (sourceValues) {
                        var targetValues = target[propertyName];
                        targetValues || (targetValues = target[propertyName] = {});
                        for (var valuePropertyName in sourceValues) targetValues[valuePropertyName] || (targetValues[valuePropertyName] = sourceValues[valuePropertyName]);
                    }
                }, ObjectEnumerationBuilder.merge = function(x, y) {
                    var xNormalized = ObjectEnumerationBuilder.normalize(x), yNormalized = ObjectEnumerationBuilder.normalize(y);
                    if (!xNormalized || !yNormalized) return xNormalized || yNormalized;
                    for (var xCategoryCount = xNormalized.containers ? xNormalized.containers.length : 0, _i = 0, _a = yNormalized.instances; _i < _a.length; _i++) {
                        var yInstance = _a[_i];
                        xNormalized.instances.push(yInstance), null != yInstance.containerIdx && (yInstance.containerIdx += xCategoryCount);
                    }
                    var yContainers = yNormalized.containers;
                    return _.isEmpty(yContainers) || (xNormalized.containers ? Array.prototype.push.apply(xNormalized.containers, yContainers) : xNormalized.containers = yContainers), 
                    xNormalized;
                }, ObjectEnumerationBuilder.normalize = function(x) {
                    return _.isArray(x) ? {
                        instances: x
                    } : x;
                }, ObjectEnumerationBuilder.getContainerForInstance = function(enumeration, instance) {
                    return enumeration.containers[instance.containerIdx];
                }, ObjectEnumerationBuilder;
            }();
            visuals.ObjectEnumerationBuilder = ObjectEnumerationBuilder;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var VisualBorderUtil;
            !function(VisualBorderUtil) {
                function getBorderWidth(outlineType, outlineWeight) {
                    switch (outlineType) {
                      case visuals.outline.none:
                        return "0px";

                      case visuals.outline.bottomOnly:
                        return "0px 0px " + outlineWeight + "px 0px";

                      case visuals.outline.topOnly:
                        return outlineWeight + "px 0px 0px 0px";

                      case visuals.outline.leftOnly:
                        return "0px 0px 0px " + outlineWeight + "px";

                      case visuals.outline.rightOnly:
                        return "0px " + outlineWeight + "px 0px 0px";

                      case visuals.outline.topBottom:
                        return outlineWeight + "px 0px";

                      case visuals.outline.leftRight:
                        return "0px " + outlineWeight + "px";

                      case visuals.outline.frame:
                        return outlineWeight + "px";

                      default:
                        return "0px";
                    }
                }
                VisualBorderUtil.getBorderWidth = getBorderWidth;
            }(VisualBorderUtil = visuals.VisualBorderUtil || (visuals.VisualBorderUtil = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            function createTranslateMatrix(xOffset, yOffset) {
                return {
                    m00: 1,
                    m01: 0,
                    m02: xOffset,
                    m10: 0,
                    m11: 1,
                    m12: yOffset
                };
            }
            function createScaleMatrix(xScale, yScale) {
                return {
                    m00: xScale,
                    m01: 0,
                    m02: 0,
                    m10: 0,
                    m11: yScale,
                    m12: 0
                };
            }
            function createRotationMatrix(angleInRads) {
                var a = angleInRads, sinA = Math.sin(a), cosA = Math.cos(a);
                return {
                    m00: cosA,
                    m01: -sinA,
                    m02: 0,
                    m10: sinA,
                    m11: cosA,
                    m12: 0
                };
            }
            function createInverseMatrix(m) {
                var determinant = m.m00 * m.m11 - m.m01 * m.m10, invdet = 1 / determinant;
                return {
                    m00: m.m11 * invdet,
                    m01: -m.m01 * invdet,
                    m02: (m.m01 * m.m12 - m.m02 * m.m11) * invdet,
                    m10: -m.m10 * invdet,
                    m11: m.m00 * invdet,
                    m12: -(m.m00 * m.m12 - m.m10 * m.m02) * invdet
                };
            }
            function multiplyMatrices(a, b) {
                return {
                    m00: a.m00 * b.m00 + a.m01 * b.m10,
                    m01: a.m00 * b.m01 + a.m01 * b.m11,
                    m02: a.m00 * b.m02 + a.m01 * b.m12 + a.m02,
                    m10: a.m10 * b.m00 + a.m11 * b.m10,
                    m11: a.m10 * b.m01 + a.m11 * b.m11,
                    m12: a.m10 * b.m02 + a.m11 * b.m12 + a.m12
                };
            }
            var Transform = function() {
                function Transform(m) {
                    this.matrix = m || {
                        m00: 1,
                        m01: 0,
                        m02: 0,
                        m10: 0,
                        m11: 1,
                        m12: 0
                    };
                }
                return Transform.prototype.applyToPoint = function(point) {
                    if (!point) return point;
                    var m = this.matrix;
                    return {
                        x: m.m00 * point.x + m.m01 * point.y + m.m02,
                        y: m.m10 * point.x + m.m11 * point.y + m.m12
                    };
                }, Transform.prototype.applyToRect = function(rect) {
                    if (!rect) return rect;
                    var x0 = rect.left, y0 = rect.top, m = this.matrix, isScaled = 1 !== m.m00 || 1 !== m.m11, isRotated = 0 !== m.m01 || 0 !== m.m10;
                    if (!isRotated && !isScaled) return {
                        left: x0 + m.m02,
                        top: y0 + m.m12,
                        width: rect.width,
                        height: rect.height
                    };
                    var minX, maxX, minY, maxY, x1 = rect.left + rect.width, y1 = rect.top + rect.height;
                    if (isRotated) {
                        var p0x = m.m00 * x0 + m.m01 * y0 + m.m02, p0y = m.m10 * x0 + m.m11 * y0 + m.m12, p1x = m.m00 * x0 + m.m01 * y1 + m.m02, p1y = m.m10 * x0 + m.m11 * y1 + m.m12, p2x = m.m00 * x1 + m.m01 * y0 + m.m02, p2y = m.m10 * x1 + m.m11 * y0 + m.m12, p3x = m.m00 * x1 + m.m01 * y1 + m.m02, p3y = m.m10 * x1 + m.m11 * y1 + m.m12;
                        minX = Math.min(p0x, p1x, p2x, p3x), maxX = Math.max(p0x, p1x, p2x, p3x), minY = Math.min(p0y, p1y, p2y, p3y), 
                        maxY = Math.max(p0y, p1y, p2y, p3y);
                    } else {
                        var p0x = m.m00 * x0 + m.m02, p0y = m.m11 * y0 + m.m12, p3x = m.m00 * x1 + m.m02, p3y = m.m11 * y1 + m.m12;
                        minX = Math.min(p0x, p3x), maxX = Math.max(p0x, p3x), minY = Math.min(p0y, p3y), 
                        maxY = Math.max(p0y, p3y);
                    }
                    return {
                        left: minX,
                        top: minY,
                        width: maxX - minX,
                        height: maxY - minY
                    };
                }, Transform.prototype.translate = function(xOffset, yOffset) {
                    if (0 !== xOffset || 0 !== yOffset) {
                        var m = createTranslateMatrix(xOffset, yOffset);
                        this.matrix = multiplyMatrices(this.matrix, m), this._inverse = null;
                    }
                }, Transform.prototype.scale = function(xScale, yScale) {
                    if (1 !== xScale || 1 !== yScale) {
                        var m = createScaleMatrix(xScale, yScale);
                        this.matrix = multiplyMatrices(this.matrix, m), this._inverse = null;
                    }
                }, Transform.prototype.rotate = function(angleInRadians) {
                    if (0 !== angleInRadians) {
                        var m = createRotationMatrix(angleInRadians);
                        this.matrix = multiplyMatrices(this.matrix, m), this._inverse = null;
                    }
                }, Transform.prototype.add = function(other) {
                    other && (this.matrix = multiplyMatrices(this.matrix, other.matrix), this._inverse = null);
                }, Transform.prototype.getInverse = function() {
                    return this._inverse || (this._inverse = new Transform(createInverseMatrix(this.matrix))), 
                    this._inverse;
                }, Transform;
            }();
            visuals.Transform = Transform, visuals.createTranslateMatrix = createTranslateMatrix, 
            visuals.createScaleMatrix = createScaleMatrix, visuals.createRotationMatrix = createRotationMatrix, 
            visuals.createInverseMatrix = createInverseMatrix;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var TrendLineHelper, Color = jsCommon.Color, DataRoleHelper = powerbi.data.DataRoleHelper;
            !function(TrendLineHelper) {
                function enumerateObjectInstances(enumeration, trendLines) {
                    if (_.isEmpty(trendLines)) return void enumeration.pushInstance({
                        selector: null,
                        properties: {
                            show: !1,
                            lineColor: TrendLineHelper.defaults.lineColor,
                            transparency: TrendLineHelper.defaults.transparency,
                            style: TrendLineHelper.defaults.lineStyle,
                            combineSeries: TrendLineHelper.defaults.combineSeries
                        },
                        objectName: trendObjectName
                    });
                    var trendLine = trendLines[0], properties = {};
                    properties.show = trendLine.show, properties.displayName = trendLine.displayName, 
                    trendLine.combineSeries && (properties.lineColor = trendLine.lineColor), properties.transparency = trendLine.transparency, 
                    properties.style = trendLine.style, properties.combineSeries = trendLine.combineSeries, 
                    properties.useHighlightValues = trendLine.useHighlightValues, enumeration.pushInstance({
                        selector: null,
                        properties: properties,
                        objectName: trendObjectName
                    });
                }
                function isDataViewForRegression(dataView) {
                    return DataRoleHelper.hasRoleInDataView(dataView, "regression.X");
                }
                function readDataView(dataView, sourceDataView, y2, colors) {
                    if (dataView && dataView.categorical) {
                        var categorical = dataView.categorical;
                        if (!_.isEmpty(categorical.categories) && !_.isEmpty(categorical.values)) {
                            var categories = categorical.categories[0].values, groups = categorical.values.grouped();
                            if (categories && groups) {
                                var trendProperties = powerbi.DataViewObjects.getObject(dataView.metadata.objects, trendObjectName, {}), show = powerbi.DataViewObject.getValue(trendProperties, TrendLinePropertyNames.show, !1), displayName = powerbi.DataViewObject.getValue(trendProperties, TrendLinePropertyNames.displayName), lineColor = powerbi.DataViewObject.getValue(trendProperties, TrendLinePropertyNames.lineColor), transparency = powerbi.DataViewObject.getValue(trendProperties, TrendLinePropertyNames.transparency, TrendLineHelper.defaults.transparency), style = powerbi.DataViewObject.getValue(trendProperties, TrendLinePropertyNames.style, TrendLineHelper.defaults.lineStyle), combineSeries = powerbi.DataViewObject.getValue(trendProperties, TrendLinePropertyNames.combineSeries, TrendLineHelper.defaults.combineSeries), useHighlightValues = powerbi.DataViewObject.getValue(trendProperties, TrendLinePropertyNames.useHighlightValues, TrendLineHelper.defaults.useHighlightValues), legacyColor = powerbi.DataViewObjects.getValue(categorical.values[0].source.objects, visuals.lineChartProps.dataPoint.fill);
                                legacyColor && (lineColor = legacyColor);
                                for (var objects = sourceDataView.metadata.objects, defaultColor = powerbi.DataViewObjects.getFillColor(objects, {
                                    objectName: "dataPoint",
                                    propertyName: "defaultColor"
                                }), colorHelper = new visuals.ColorHelper(colors, {
                                    objectName: "dataPoint",
                                    propertyName: "fill"
                                }, defaultColor), trendLines = [], groupIndex = 0; groupIndex < groups.length; groupIndex++) {
                                    for (var group = groups[groupIndex], points = [], i = 0; i < categories.length; i++) {
                                        var x = visuals.AxisHelper.normalizeNonFiniteNumber(categories[i]), valueColumn = group.values[0], values = void 0;
                                        values = useHighlightValues && valueColumn.highlights ? valueColumn.highlights : valueColumn.values;
                                        var y = visuals.AxisHelper.normalizeNonFiniteNumber(values[i]);
                                        null != x && null != y && points.push({
                                            x: x,
                                            y: y
                                        });
                                    }
                                    var seriesLineColor = void 0;
                                    if (combineSeries) seriesLineColor = lineColor || TrendLineHelper.defaults.lineColor; else if (sourceDataView.categorical.values.source) {
                                        var sourceGroups = sourceDataView.categorical.values.grouped(), color = colorHelper.getColorForSeriesValue(sourceGroups[groupIndex].objects, sourceDataView.categorical.values.identityFields, group.name);
                                        color = darkenTrendLineColor(color), seriesLineColor = {
                                            solid: {
                                                color: color
                                            }
                                        };
                                    } else {
                                        var matchingMeasure = sourceDataView.categorical.values[groupIndex], color = colorHelper.getColorForMeasure(matchingMeasure.source.objects, group.name);
                                        color = darkenTrendLineColor(color), seriesLineColor = {
                                            solid: {
                                                color: color
                                            }
                                        };
                                    }
                                    trendLines.push({
                                        points: points,
                                        show: show,
                                        displayName: displayName,
                                        lineColor: seriesLineColor,
                                        transparency: transparency,
                                        style: style,
                                        combineSeries: combineSeries,
                                        useHighlightValues: useHighlightValues,
                                        y2Axis: y2
                                    });
                                }
                                return trendLines;
                            }
                        }
                    }
                }
                function darkenTrendLineColor(color) {
                    var rgb = Color.parseColorString(color);
                    return rgb = Color.darken(rgb, 20), Color.rgbString(rgb);
                }
                function render(trendLines, graphicsContext, axes, viewport) {
                    var layer = graphicsContext.select(TrendLineLayerClassSelector.selector);
                    layer.empty() && (layer = graphicsContext.append("svg").classed(TrendLineLayerClassSelector["class"], !0)), 
                    layer.attr({
                        height: viewport.height,
                        width: viewport.width
                    });
                    var lines = layer.selectAll(TrendLineClassSelector.selector).data(trendLines || []);
                    lines.enter().append("path").classed(TrendLineClassSelector["class"], !0), lines.attr("d", function(d) {
                        var xScale = axes.x.scale, yScale = d.y2Axis && axes.y2 ? axes.y2.scale : axes.y1.scale, pathGen = d3.svg.line().x(function(point) {
                            return xScale(point.x);
                        }).y(function(point) {
                            return yScale(point.y);
                        });
                        return pathGen(_.filter(d.points, function(point) {
                            return null != point.x && null != point.y;
                        }));
                    }), lines.each(function(d) {
                        var line = d3.select(this), style = {};
                        style.stroke = d.lineColor.solid.color, null != d.transparency && (style["stroke-opacity"] = (100 - d.transparency) / 100), 
                        d.style === visuals.lineStyle.dashed ? style["stroke-dasharray"] = "5, 5" : d.style === visuals.lineStyle.dotted ? (style["stroke-dasharray"] = "1, 5", 
                        style["stroke-linecap"] = "round") : d.style === visuals.lineStyle.solid && (style["stroke-dasharray"] = null, 
                        style["stroke-linecap"] = null), line.style(style);
                    }), lines.exit().remove();
                }
                var TrendLinePropertyNames;
                !function(TrendLinePropertyNames) {
                    TrendLinePropertyNames.show = "show", TrendLinePropertyNames.displayName = "displayName", 
                    TrendLinePropertyNames.lineColor = "lineColor", TrendLinePropertyNames.transparency = "transparency", 
                    TrendLinePropertyNames.style = "style", TrendLinePropertyNames.combineSeries = "combineSeries", 
                    TrendLinePropertyNames.useHighlightValues = "useHighlightValues";
                }(TrendLinePropertyNames || (TrendLinePropertyNames = {}));
                var trendObjectName = "trend";
                TrendLineHelper.defaults = {
                    lineColor: {
                        solid: {
                            color: "#000"
                        }
                    },
                    lineStyle: visuals.lineStyle.dashed,
                    transparency: 0,
                    combineSeries: !0,
                    useHighlightValues: !0
                };
                var TrendLineClassSelector = jsCommon.CssConstants.createClassAndSelector("trend-line"), TrendLineLayerClassSelector = jsCommon.CssConstants.createClassAndSelector("trend-line-layer");
                TrendLineHelper.enumerateObjectInstances = enumerateObjectInstances, TrendLineHelper.isDataViewForRegression = isDataViewForRegression, 
                TrendLineHelper.readDataView = readDataView, TrendLineHelper.darkenTrendLineColor = darkenTrendLineColor, 
                TrendLineHelper.render = render;
            }(TrendLineHelper = visuals.TrendLineHelper || (visuals.TrendLineHelper = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var visibilityHelper;
            !function(visibilityHelper) {
                function partiallyVisible(element) {
                    return element.is(":visible");
                }
                visibilityHelper.partiallyVisible = partiallyVisible;
            }(visibilityHelper = visuals.visibilityHelper || (visuals.visibilityHelper = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var VisualObjectRepetition, Selector = powerbi.data.Selector;
        !function(VisualObjectRepetition) {
            function equals(x, y) {
                return x = x || null, y = y || null, x === y ? !0 : !x != !y ? !1 : Selector.equals(x.selector, y.selector) ? _.isEqual(x.objects, y.objects) : !1;
            }
            VisualObjectRepetition.equals = equals;
        }(VisualObjectRepetition = powerbi.VisualObjectRepetition || (powerbi.VisualObjectRepetition = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var ForecastHelper, createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, DataRoleHelper = powerbi.data.DataRoleHelper;
            !function(ForecastHelper) {
                function enumerateObjectInstances(enumeration, forecast) {
                    if (!forecast) return void enumeration.pushInstance({
                        selector: {
                            id: "0"
                        },
                        properties: {
                            show: !1,
                            lineColor: ForecastHelper.defaults.lineColor,
                            confidenceBandStyle: ForecastHelper.defaults.confidenceBandStyle,
                            transparency: ForecastHelper.defaults.transparency,
                            style: ForecastHelper.defaults.style
                        },
                        objectName: forecastObjectName
                    });
                    var properties = (_a = {}, _a[ForecastPropertyNames.show] = forecast.show, _a[ForecastPropertyNames.lineColor] = forecast.lineColor, 
                    _a[ForecastPropertyNames.confidenceBandStyle] = forecast.confidenceBandStyle, _a[ForecastPropertyNames.transparency] = forecast.transparency, 
                    _a[ForecastPropertyNames.style] = forecast.style, _a);
                    enumeration.pushInstance({
                        selector: {
                            id: forecast.id
                        },
                        properties: properties,
                        objectName: forecastObjectName
                    });
                    var _a;
                }
                function isDataViewForForecast(dataView) {
                    if (!dataView || !dataView.categorical || !dataView.categorical.values) return !1;
                    for (var grouped = dataView.categorical.values.grouped(), _i = 0, grouped_1 = grouped; _i < grouped_1.length; _i++) {
                        var group = grouped_1[_i], hasRole = _.any(group.values, function(value) {
                            return DataRoleHelper.hasRoleInValueColumn(value, "forecast.ForecastValue");
                        });
                        if (hasRole) return !0;
                    }
                    return !1;
                }
                function readDataView(dataView, sourceDataView, colors) {
                    if (dataView && dataView.categorical && sourceDataView && sourceDataView.categorical) {
                        var categorical = dataView.categorical;
                        if (!_.isEmpty(categorical.categories) && !_.isEmpty(categorical.values)) {
                            var categories = categorical.categories[0].values, groups = categorical.values.grouped();
                            if (categories && groups) {
                                for (var valueColumnIndex = DataRoleHelper.getMeasureIndexOfRole(groups, forecastValueRole), upperBoundColumnIndex = DataRoleHelper.getMeasureIndexOfRole(groups, forecastConfidenceHighBoundRole), lowerBoundColumnIndex = DataRoleHelper.getMeasureIndexOfRole(groups, forecastConfidenceLowBoundRole), forecastLines = [], forecastProperties = powerbi.DataViewObjects.getUserDefinedObjects(dataView.metadata.objects, forecastObjectName), groupIndex = 0, _i = 0, forecastProperties_1 = forecastProperties; _i < forecastProperties_1.length; _i++) {
                                    for (var forecastProperty = forecastProperties_1[_i], forecastObjects = forecastProperty.object, show = powerbi.DataViewObject.getValue(forecastObjects, ForecastPropertyNames.show, !1), lineColor = powerbi.DataViewObject.getValue(forecastObjects, ForecastPropertyNames.lineColor, ForecastHelper.defaults.lineColor), confidenceBandStyle_1 = powerbi.DataViewObject.getValue(forecastObjects, ForecastPropertyNames.confidenceBandStyle, ForecastHelper.defaults.confidenceBandStyle), transparency = powerbi.DataViewObject.getValue(forecastObjects, ForecastPropertyNames.transparency, ForecastHelper.defaults.transparency), style = powerbi.DataViewObject.getValue(forecastObjects, ForecastPropertyNames.style, ForecastHelper.defaults.style), colorHelper = new visuals.ColorHelper(colors, {
                                        objectName: "dataPoint",
                                        propertyName: "fill"
                                    }, ForecastHelper.defaults.lineColor.solid.color), group = groups[groupIndex], points = [], values = group.values[valueColumnIndex].highlights ? group.values[valueColumnIndex].highlights : group.values[valueColumnIndex].values, upperBoundValues = group.values[upperBoundColumnIndex].highlights ? group.values[upperBoundColumnIndex].highlights : group.values[upperBoundColumnIndex].values, lowerBoundValues = group.values[lowerBoundColumnIndex].highlights ? group.values[lowerBoundColumnIndex].highlights : group.values[lowerBoundColumnIndex].values, i = 0; i < categories.length; i++) {
                                        var x = visuals.AxisHelper.normalizeNonFiniteNumber(categories[i]), y = visuals.AxisHelper.normalizeNonFiniteNumber(values[i]);
                                        if (null != x && null != y) {
                                            var upperBoundY = visuals.AxisHelper.normalizeNonFiniteNumber(upperBoundValues[i]), lowerBoundY = visuals.AxisHelper.normalizeNonFiniteNumber(lowerBoundValues[i]);
                                            points.push({
                                                point: {
                                                    x: x,
                                                    y: y
                                                },
                                                upperBound: {
                                                    x: x,
                                                    y: upperBoundY
                                                },
                                                lowerBound: {
                                                    x: x,
                                                    y: lowerBoundY
                                                }
                                            });
                                        }
                                    }
                                    var seriesLineColor = void 0;
                                    if (lineColor) seriesLineColor = lineColor; else if (sourceDataView.categorical.values.source) {
                                        var sourceGroups = sourceDataView.categorical.values.grouped(), color = colorHelper.getColorForSeriesValue(sourceGroups[groupIndex].objects, sourceDataView.categorical.values.identityFields, group.name);
                                        seriesLineColor = {
                                            solid: {
                                                color: color
                                            }
                                        };
                                    } else {
                                        var matchingMeasure = sourceDataView.categorical.values[groupIndex], color = colorHelper.getColorForMeasure(matchingMeasure.source.objects, group.name);
                                        seriesLineColor = {
                                            solid: {
                                                color: color
                                            }
                                        };
                                    }
                                    forecastLines.push({
                                        id: forecastProperty.id,
                                        points: points,
                                        show: show,
                                        lineColor: seriesLineColor,
                                        confidenceBandStyle: confidenceBandStyle_1,
                                        transparency: transparency,
                                        style: style
                                    }), groupIndex++;
                                }
                                return forecastLines[0];
                            }
                        }
                    }
                }
                function render(forecastLine, graphicsContext, axes, viewport, animator, suppressAnimations) {
                    var duration = visuals.AnimatorCommon.GetAnimationDuration(animator, suppressAnimations), layer = graphicsContext.select(ForecastLayerClassSelector.selector);
                    layer.empty() && (layer = graphicsContext.insert("svg", ":first-child").classed(ForecastLayerClassSelector["class"], !0)), 
                    layer.attr({
                        height: viewport.height,
                        width: viewport.width
                    });
                    var errorRange = layer.selectAll(ForecastErrorRangeClassSelector.selector).data(forecastLine ? [ forecastLine ] : []);
                    errorRange.enter().insert("path", ":first-child").classed(ForecastErrorRangeClassSelector["class"], !0), 
                    errorRange.transition().ease("linear").duration(duration).attr("d", function(d) {
                        var xScale = axes.x.scale, yScale = axes.y1.scale, pathGen = d3.svg.area().x(function(point) {
                            return xScale(point.upperBound.x);
                        }).y0(function(point) {
                            return yScale(point.upperBound.y);
                        }).y1(function(point) {
                            return yScale(point.lowerBound.y);
                        });
                        return pathGen(d.points);
                    }), errorRange.each(function(d) {
                        var errorRangeArea = d3.select(this), style = {}, opacity = (100 - d.transparency) / 100;
                        style["fill-opacity"] = opacity, style["stroke-opacity"] = opacity, d.confidenceBandStyle === visuals.confidenceBandStyle.fill ? (style.stroke = "transparent", 
                        style.fill = d.lineColor.solid.color) : d.confidenceBandStyle === visuals.confidenceBandStyle.line ? (style.stroke = d.lineColor.solid.color, 
                        style.fill = "transparent") : d.confidenceBandStyle === visuals.confidenceBandStyle.none && (style.stroke = "transparent", 
                        style.fill = "transparent"), errorRangeArea.style(style);
                    }), errorRange.exit().remove();
                    var lines = layer.selectAll(ForecastClassSelector.selector).data(forecastLine ? [ forecastLine ] : []);
                    lines.enter().append("path").classed(ForecastClassSelector["class"], !0), lines.transition().ease("linear").duration(duration).attr("d", function(d) {
                        var xScale = axes.x.scale, yScale = axes.y1.scale, pathGen = d3.svg.line().x(function(point) {
                            return xScale(point.point.x);
                        }).y(function(point) {
                            return yScale(point.point.y);
                        });
                        return pathGen(_.filter(d.points, function(point) {
                            return null != point.point.x && null != point.point.y;
                        }));
                    }), lines.each(function(d) {
                        var line = d3.select(this), style = {};
                        style.stroke = d.lineColor.solid.color, style.fill = "transparent", d.style === visuals.lineStyle.dashed ? style["stroke-dasharray"] = "5, 5" : d.style === visuals.lineStyle.dotted ? (style["stroke-dasharray"] = "1, 5", 
                        style["stroke-linecap"] = "round") : d.style === visuals.lineStyle.solid && (style["stroke-dasharray"] = null, 
                        style["stroke-linecap"] = null), line.style(style);
                    }), lines.exit().remove();
                }
                var ForecastPropertyNames;
                !function(ForecastPropertyNames) {
                    ForecastPropertyNames.show = "show", ForecastPropertyNames.lineColor = "lineColor", 
                    ForecastPropertyNames.confidenceBandStyle = "confidenceBandStyle", ForecastPropertyNames.transparency = "transparency", 
                    ForecastPropertyNames.style = "style";
                }(ForecastPropertyNames || (ForecastPropertyNames = {}));
                var forecastObjectName = "forecast", forecastValueRole = "forecast.ForecastValue", forecastConfidenceHighBoundRole = "forecast.ConfidenceHighBound", forecastConfidenceLowBoundRole = "forecast.ConfidenceLowBound";
                ForecastHelper.defaults = {
                    lineColor: {
                        solid: {
                            color: "#000"
                        }
                    },
                    confidenceBandStyle: visuals.confidenceBandStyle.fill,
                    transparency: 80,
                    style: visuals.lineStyle.solid
                };
                var ForecastClassSelector = createClassAndSelector("forecast-line"), ForecastErrorRangeClassSelector = createClassAndSelector("forecast-error-range"), ForecastLayerClassSelector = createClassAndSelector("forecast-line-layer");
                ForecastHelper.enumerateObjectInstances = enumerateObjectInstances, ForecastHelper.isDataViewForForecast = isDataViewForForecast, 
                ForecastHelper.readDataView = readDataView, ForecastHelper.render = render;
            }(ForecastHelper = visuals.ForecastHelper || (visuals.ForecastHelper = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi, __extends = (window.powerbitests, 
    window.InJs, window.debug, window.jasmine, window.Microsoft, this && this.__extends || function(d, b) {
        function __() {
            this.constructor = d;
        }
        for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
    });
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var DataConversion, DefaultSQExprVisitor = powerbi.data.DefaultSQExprVisitor, SemanticFilter = powerbi.data.SemanticFilter, UrlUtils = jsCommon.UrlUtils;
            !function(DataConversion) {
                function convert(dataView, localizedSelectAllText, interactivityService, hostServices) {
                    if (dataView && dataView.categorical && !_.isEmpty(dataView.categorical.categories)) {
                        var identityFields = dataView.categorical.categories[0].identityFields;
                        if (identityFields) {
                            var filter = dataView.metadata && dataView.metadata.objects && powerbi.DataViewObjects.getValue(dataView.metadata.objects, visuals.slicerProps.filterPropertyIdentifier), analyzer = hostServices.analyzeFilter({
                                dataView: dataView,
                                defaultValuePropertyId: visuals.slicerProps.defaultValue,
                                filter: filter,
                                fieldSQExprs: identityFields
                            });
                            if (analyzer) {
                                var analyzedSemanticFilter = analyzer.filter;
                                if (analyzedSemanticFilter && !SemanticFilter.isSameFilter(analyzedSemanticFilter, filter)) {
                                    interactivityService.handleClearSelection();
                                    var filterPropertyIdentifier = visuals.slicerProps.filterPropertyIdentifier, properties = {};
                                    properties[filterPropertyIdentifier.propertyName] = analyzer.filter;
                                    var instance = {
                                        objectName: filterPropertyIdentifier.objectName,
                                        selector: void 0,
                                        properties: properties
                                    }, changes = {
                                        merge: [ instance ]
                                    };
                                    hostServices.persistProperties(changes);
                                }
                                var slicerData = getSlicerData(analyzer, dataView.metadata, dataView.categorical, localizedSelectAllText, interactivityService, hostServices);
                                return slicerData;
                            }
                        }
                    }
                }
                function getSlicerData(analyzer, dataViewMetadata, categorical, localizedSelectAllText, interactivityService, hostServices) {
                    var isInvertedSelectionMode = interactivityService && interactivityService.isSelectionModeInverted(), selectedScopeIds = analyzer.selectedIdentities, hasSelectionOverride = !_.isEmpty(selectedScopeIds) || isInvertedSelectionMode === !0;
                    !isInvertedSelectionMode && analyzer.filter && (isInvertedSelectionMode = analyzer.isNotFilter), 
                    interactivityService && (interactivityService.setSelectionModeInverted(isInvertedSelectionMode), 
                    interactivityService.setDefaultValueMode(SemanticFilter.isDefaultFilter(analyzer.filter)));
                    var category = categorical.categories[0], categoryValuesLen = category && category.values ? category.values.length : 0, slicerDataPoints = [], formatString = visuals.valueFormatter.getFormatString(category.source, visuals.slicerProps.formatString), numOfSelected = 0, valueCounts = categorical.values && categorical.values[0] && categorical.values[0].values;
                    valueCounts && _.isEmpty(valueCounts) && (valueCounts = void 0);
                    for (var isImageData = dataViewMetadata && !_.isEmpty(dataViewMetadata.columns) && visuals.converterHelper.isImageUrlColumn(dataViewMetadata.columns[0]), displayNameIdentityPairs = [], i = 0; categoryValuesLen > i; i++) {
                        var scopeId = category.identity && category.identity[i], value = category.values && category.values[i], count = valueCounts && valueCounts[i], isRetained = hasSelectionOverride ? visuals.SlicerUtil.tryRemoveValueFromRetainedList(scopeId, selectedScopeIds) : !1, label = visuals.valueFormatter.format(value, formatString), isImage = isImageData === !0 && UrlUtils.isValidImageUrl(label), slicerData_1 = {
                            value: label,
                            tooltip: label,
                            identity: visuals.SelectionIdBuilder.builder().withCategory(category, i).createSelectionId(),
                            selected: isRetained,
                            count: count,
                            isImage: isImage
                        };
                        if (isRetained) {
                            var displayNameIdentityPair = {
                                displayName: label,
                                identity: scopeId
                            };
                            displayNameIdentityPairs.push(displayNameIdentityPair);
                        }
                        slicerDataPoints.push(slicerData_1), slicerData_1.selected && numOfSelected++;
                    }
                    if (_.isEmpty(displayNameIdentityPairs) || hostServices.setIdentityDisplayNames(displayNameIdentityPairs), 
                    hasSelectionOverride && !_.isEmpty(selectedScopeIds)) {
                        var displayNamesIdentityPairs = hostServices.getIdentityDisplayNames(selectedScopeIds);
                        if (!_.isEmpty(displayNamesIdentityPairs)) for (var _i = 0, displayNamesIdentityPairs_1 = displayNamesIdentityPairs; _i < displayNamesIdentityPairs_1.length; _i++) {
                            var pair = displayNamesIdentityPairs_1[_i], slicerData_2 = {
                                value: pair.displayName,
                                tooltip: pair.displayName,
                                identity: visuals.SelectionIdBuilder.builder().withCategoryIdentity(category, pair.identity).createSelectionId(),
                                selected: !0,
                                count: null != valueCounts ? 0 : void 0
                            };
                            slicerDataPoints.push(slicerData_2), numOfSelected++;
                        }
                    }
                    var searchKey = getSearchKey(dataViewMetadata), defaultSettings = createDefaultSettings(dataViewMetadata);
                    defaultSettings.selection.selectAllCheckboxEnabled && _.isEmpty(searchKey) && slicerDataPoints.unshift({
                        value: localizedSelectAllText,
                        tooltip: localizedSelectAllText,
                        identity: visuals.SelectionId.createWithMeasure(localizedSelectAllText),
                        selected: !!isInvertedSelectionMode && 0 === numOfSelected,
                        isSelectAllDataPoint: !0,
                        count: void 0
                    });
                    var slicerData = {
                        categorySourceName: category.source.displayName,
                        slicerSettings: defaultSettings,
                        slicerDataPoints: slicerDataPoints,
                        hasSelectionOverride: hasSelectionOverride,
                        defaultValue: analyzer.defaultValue,
                        searchKey: searchKey
                    };
                    return slicerData;
                }
                function getSearchKey(dataViewMetadata) {
                    var selfFilter = powerbi.DataViewObjects.getValue(dataViewMetadata.objects, visuals.slicerProps.selfFilterPropertyIdentifier, void 0);
                    if (!selfFilter) return "";
                    var filterItems = selfFilter.conditions(), containsFilter = filterItems[0];
                    if (containsFilter) {
                        var containsValueVisitor = new ConditionsFilterValueVisitor();
                        return containsFilter.accept(containsValueVisitor), containsValueVisitor.getValueForField();
                    }
                }
                function createDefaultSettings(dataViewMetadata) {
                    var defaultSettings = visuals.Slicer.DefaultStyleProperties(), objects = dataViewMetadata.objects, forceSingleSelect = dataViewMetadata.columns && _.some(dataViewMetadata.columns, function(column) {
                        return column.discourageAggregationAcrossGroups;
                    });
                    if (objects) {
                        defaultSettings.general.outlineColor = powerbi.DataViewObjects.getFillColor(objects, visuals.slicerProps.general.outlineColor, defaultSettings.general.outlineColor), 
                        defaultSettings.general.outlineWeight = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.general.outlineWeight, defaultSettings.general.outlineWeight), 
                        defaultSettings.general.orientation = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.general.orientation, defaultSettings.general.orientation), 
                        defaultSettings.header.show = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.header.show, defaultSettings.header.show), 
                        defaultSettings.header.fontColor = powerbi.DataViewObjects.getFillColor(objects, visuals.slicerProps.header.fontColor, defaultSettings.header.fontColor);
                        var headerBackground = powerbi.DataViewObjects.getFillColor(objects, visuals.slicerProps.header.background);
                        headerBackground && (defaultSettings.header.background = headerBackground), defaultSettings.header.outline = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.header.outline, defaultSettings.header.outline), 
                        defaultSettings.header.textSize = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.header.textSize, defaultSettings.header.textSize), 
                        defaultSettings.slicerText.color = powerbi.DataViewObjects.getFillColor(objects, visuals.slicerProps.items.fontColor, defaultSettings.slicerText.color);
                        var textBackground = powerbi.DataViewObjects.getFillColor(objects, visuals.slicerProps.items.background);
                        textBackground && (defaultSettings.slicerText.background = textBackground), defaultSettings.slicerText.outline = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.items.outline, defaultSettings.slicerText.outline), 
                        defaultSettings.slicerText.textSize = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.items.textSize, defaultSettings.slicerText.textSize), 
                        defaultSettings.selection.selectAllCheckboxEnabled = !forceSingleSelect && powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.selection.selectAllCheckboxEnabled, defaultSettings.selection.selectAllCheckboxEnabled), 
                        defaultSettings.selection.singleSelect = forceSingleSelect || powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.selection.singleSelect, defaultSettings.selection.singleSelect), 
                        defaultSettings.search.enabled = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.general.selfFilterEnabled, defaultSettings.search.enabled);
                    }
                    return defaultSettings;
                }
                DataConversion.convert = convert;
                var ConditionsFilterValueVisitor = function(_super) {
                    function ConditionsFilterValueVisitor() {
                        _super.apply(this, arguments);
                    }
                    return __extends(ConditionsFilterValueVisitor, _super), ConditionsFilterValueVisitor.prototype.visitConstant = function(expr) {
                        expr.type && expr.type.text && (this.value = expr.value);
                    }, ConditionsFilterValueVisitor.prototype.visitContains = function(expr) {
                        expr.left.accept(this), expr.right.accept(this);
                    }, ConditionsFilterValueVisitor.prototype.visitColumnRef = function(expr) {
                        this.fieldExpr = expr;
                    }, ConditionsFilterValueVisitor.prototype.visitDefault = function(expr) {
                        this.value = void 0, this.fieldExpr = void 0;
                    }, ConditionsFilterValueVisitor.prototype.getValueForField = function() {
                        return this.fieldExpr && this.value;
                    }, ConditionsFilterValueVisitor;
                }(DefaultSQExprVisitor);
            }(DataConversion = visuals.DataConversion || (visuals.DataConversion = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var shapes = powerbi.visuals.shapes;
        !function(RectOrientation) {
            RectOrientation[RectOrientation.None = 0] = "None", RectOrientation[RectOrientation.VerticalBottomTop = 1] = "VerticalBottomTop", 
            RectOrientation[RectOrientation.VerticalTopBottom = 2] = "VerticalTopBottom", RectOrientation[RectOrientation.HorizontalLeftRight = 3] = "HorizontalLeftRight", 
            RectOrientation[RectOrientation.HorizontalRightLeft = 4] = "HorizontalRightLeft";
        }(powerbi.RectOrientation || (powerbi.RectOrientation = {}));
        var RectOrientation = powerbi.RectOrientation;
        !function(OutsidePlacement) {
            OutsidePlacement[OutsidePlacement.Allowed = 0] = "Allowed", OutsidePlacement[OutsidePlacement.Disallowed = 1] = "Disallowed", 
            OutsidePlacement[OutsidePlacement.Partial = 2] = "Partial";
        }(powerbi.OutsidePlacement || (powerbi.OutsidePlacement = {}));
        var OutsidePlacement = powerbi.OutsidePlacement, DataLabelManager = function() {
            function DataLabelManager() {
                this.movingStep = 3, this.hideOverlapped = !0, this.defaultDataLabelSettings = {
                    anchorMargin: DataLabelManager.DefaultAnchorMargin,
                    anchorRectOrientation: RectOrientation.None,
                    contentPosition: 128,
                    outsidePlacement: OutsidePlacement.Disallowed,
                    maximumMovingDistance: DataLabelManager.DefaultMaximumMovingDistance,
                    minimumMovingDistance: DataLabelManager.DefaultMinimumMovingDistance,
                    validContentPositions: 128,
                    opacity: 1
                };
            }
            return Object.defineProperty(DataLabelManager.prototype, "defaultSettings", {
                get: function() {
                    return this.defaultDataLabelSettings;
                },
                enumerable: !0,
                configurable: !0
            }), DataLabelManager.prototype.hideCollidedLabels = function(viewport, data, layout, addTransform) {
                void 0 === addTransform && (addTransform = !1);
                var arrangeGrid = new DataLabelArrangeGrid(viewport, data, layout), filteredData = [], transform = {
                    x: 0,
                    y: 0
                };
                addTransform && (transform.x = viewport.width / 2, transform.y = viewport.height / 2);
                for (var i = 0, len = data.length; len > i; i++) if (layout.filter(data[i])) {
                    var info = this.getLabelInfo(data[i]);
                    info.anchorPoint = {
                        x: layout.labelLayout.x(data[i]) + transform.x,
                        y: layout.labelLayout.y(data[i]) + transform.y
                    };
                    var position = this.calculateContentPosition(info, info.contentPosition, data[i].size, info.anchorMargin);
                    DataLabelManager.isValid(position) && !this.hasCollisions(arrangeGrid, info, position, viewport) && (data[i].labelX = position.left - transform.x, 
                    data[i].labelY = position.top - transform.y, arrangeGrid.add(info, position), filteredData.push(data[i]));
                }
                return filteredData;
            }, DataLabelManager.prototype.getLabelInfo = function(source) {
                var settings = this.defaultDataLabelSettings;
                return source.anchorMargin = void 0 !== source.anchorMargin ? source.anchorMargin : settings.anchorMargin, 
                source.anchorRectOrientation = void 0 !== source.anchorRectOrientation ? source.anchorRectOrientation : settings.anchorRectOrientation, 
                source.contentPosition = void 0 !== source.contentPosition ? source.contentPosition : settings.contentPosition, 
                source.maximumMovingDistance = void 0 !== source.maximumMovingDistance ? source.maximumMovingDistance : settings.maximumMovingDistance, 
                source.minimumMovingDistance = void 0 !== source.minimumMovingDistance ? source.minimumMovingDistance : settings.minimumMovingDistance, 
                source.outsidePlacement = void 0 !== source.outsidePlacement ? source.outsidePlacement : settings.outsidePlacement, 
                source.validContentPositions = void 0 !== source.validContentPositions ? source.validContentPositions : settings.validContentPositions, 
                source.opacity = void 0 !== source.opacity ? source.opacity : settings.opacity, 
                source.maximumMovingDistance += source.anchorMargin, source;
            }, DataLabelManager.prototype.calculateContentPositionFromPoint = function(anchorPoint, contentPosition, contentSize, offset) {
                var position = {
                    x: 0,
                    y: 0
                };
                if (anchorPoint) {
                    if (void 0 !== anchorPoint.x && isFinite(anchorPoint.x)) switch (position.x = anchorPoint.x, 
                    contentPosition) {
                      case 1:
                      case 8:
                      case 64:
                        position.x -= contentSize.width / 2;
                        break;

                      case 4:
                      case 32:
                      case 256:
                        position.x += contentSize.width / 2;
                    }
                    if (void 0 !== anchorPoint.y && isFinite(anchorPoint.y)) switch (position.y = anchorPoint.y, 
                    contentPosition) {
                      case 8:
                      case 16:
                      case 32:
                        position.y -= contentSize.height / 2;
                        break;

                      case 4:
                      case 1:
                      case 2:
                        position.y -= contentSize.height;
                    }
                    if (void 0 !== offset && isFinite(offset)) switch (contentPosition) {
                      case 1:
                        position.x -= offset, position.y -= offset;
                        break;

                      case 8:
                        position.x -= offset;
                        break;

                      case 64:
                        position.x -= offset, position.y += offset;
                        break;

                      case 2:
                        position.y -= offset;
                        break;

                      case 16:
                        break;

                      case 128:
                        position.y += offset;
                        break;

                      case 4:
                        position.x += offset, position.y -= offset;
                        break;

                      case 32:
                        position.x += offset;
                        break;

                      case 256:
                        position.x += offset, position.y += offset;
                    }
                }
                return {
                    left: position.x,
                    top: position.y,
                    width: contentSize.width,
                    height: contentSize.height
                };
            }, DataLabelManager.prototype.calculateContentPositionFromRect = function(anchorRect, anchorRectOrientation, contentPosition, contentSize, offset) {
                switch (contentPosition) {
                  case 512:
                    return this.handleInsideCenterPosition(anchorRectOrientation, contentSize, anchorRect, offset);

                  case 2048:
                    return this.handleInsideEndPosition(anchorRectOrientation, contentSize, anchorRect, offset);

                  case 1024:
                    return this.handleInsideBasePosition(anchorRectOrientation, contentSize, anchorRect, offset);

                  case 8192:
                    return this.handleOutsideEndPosition(anchorRectOrientation, contentSize, anchorRect, offset);

                  case 4096:
                    return this.handleOutsideBasePosition(anchorRectOrientation, contentSize, anchorRect, offset);
                }
                return {
                    left: 0,
                    top: 0,
                    width: -1,
                    height: -1
                };
            }, DataLabelManager.prototype.handleInsideCenterPosition = function(anchorRectOrientation, contentSize, anchorRect, offset) {
                switch (anchorRectOrientation) {
                  case RectOrientation.VerticalBottomTop:
                  case RectOrientation.VerticalTopBottom:
                    return LocationConverter.middleVertical(contentSize, anchorRect, offset);

                  case RectOrientation.HorizontalLeftRight:
                  case RectOrientation.HorizontalRightLeft:
                  default:
                    return LocationConverter.middleHorizontal(contentSize, anchorRect, offset);
                }
            }, DataLabelManager.prototype.handleInsideEndPosition = function(anchorRectOrientation, contentSize, anchorRect, offset) {
                switch (anchorRectOrientation) {
                  case RectOrientation.VerticalBottomTop:
                    return LocationConverter.topInside(contentSize, anchorRect, offset);

                  case RectOrientation.VerticalTopBottom:
                    return LocationConverter.bottomInside(contentSize, anchorRect, offset);

                  case RectOrientation.HorizontalRightLeft:
                    return LocationConverter.leftInside(contentSize, anchorRect, offset);

                  case RectOrientation.HorizontalLeftRight:
                  default:
                    return LocationConverter.rightInside(contentSize, anchorRect, offset);
                }
            }, DataLabelManager.prototype.handleInsideBasePosition = function(anchorRectOrientation, contentSize, anchorRect, offset) {
                switch (anchorRectOrientation) {
                  case RectOrientation.VerticalBottomTop:
                    return LocationConverter.bottomInside(contentSize, anchorRect, offset);

                  case RectOrientation.VerticalTopBottom:
                    return LocationConverter.topInside(contentSize, anchorRect, offset);

                  case RectOrientation.HorizontalRightLeft:
                    return LocationConverter.rightInside(contentSize, anchorRect, offset);

                  case RectOrientation.HorizontalLeftRight:
                  default:
                    return LocationConverter.leftInside(contentSize, anchorRect, offset);
                }
            }, DataLabelManager.prototype.handleOutsideEndPosition = function(anchorRectOrientation, contentSize, anchorRect, offset) {
                switch (anchorRectOrientation) {
                  case RectOrientation.VerticalBottomTop:
                    return LocationConverter.topOutside(contentSize, anchorRect, offset);

                  case RectOrientation.VerticalTopBottom:
                    return LocationConverter.bottomOutside(contentSize, anchorRect, offset);

                  case RectOrientation.HorizontalRightLeft:
                    return LocationConverter.leftOutside(contentSize, anchorRect, offset);

                  case RectOrientation.HorizontalLeftRight:
                  default:
                    return LocationConverter.rightOutside(contentSize, anchorRect, offset);
                }
            }, DataLabelManager.prototype.handleOutsideBasePosition = function(anchorRectOrientation, contentSize, anchorRect, offset) {
                switch (anchorRectOrientation) {
                  case RectOrientation.VerticalBottomTop:
                    return LocationConverter.bottomOutside(contentSize, anchorRect, offset);

                  case RectOrientation.VerticalTopBottom:
                    return LocationConverter.topOutside(contentSize, anchorRect, offset);

                  case RectOrientation.HorizontalRightLeft:
                    return LocationConverter.rightOutside(contentSize, anchorRect, offset);

                  case RectOrientation.HorizontalLeftRight:
                  default:
                    return LocationConverter.leftOutside(contentSize, anchorRect, offset);
                }
            }, DataLabelManager.prototype.calculateContentPosition = function(anchoredElementInfo, contentPosition, contentSize, offset) {
                return 2048 !== contentPosition && 512 !== contentPosition && 1024 !== contentPosition && 4096 !== contentPosition && 8192 !== contentPosition ? this.calculateContentPositionFromPoint(anchoredElementInfo.anchorPoint, contentPosition, contentSize, offset) : this.calculateContentPositionFromRect(anchoredElementInfo.anchorRect, anchoredElementInfo.anchorRectOrientation, contentPosition, contentSize, offset);
            }, DataLabelManager.prototype.hasCollisions = function(arrangeGrid, info, position, size) {
                var rect = shapes.Rect;
                if (arrangeGrid.hasConflict(position)) return !0;
                var intersection = {
                    left: 0,
                    top: position.height / 2,
                    width: size.width,
                    height: size.height
                };
                if (intersection = rect.inflate(intersection, {
                    left: DataLabelManager.InflateAmount,
                    top: 0,
                    right: DataLabelManager.InflateAmount,
                    bottom: 0
                }), intersection = rect.intersect(intersection, position), rect.isEmpty(intersection)) return !0;
                var lessWithPrecision = powerbi.Double.lessWithPrecision;
                switch (info.outsidePlacement) {
                  case OutsidePlacement.Disallowed:
                    return lessWithPrecision(intersection.width, position.width) || lessWithPrecision(intersection.height, position.height / 2);

                  case OutsidePlacement.Partial:
                    return lessWithPrecision(intersection.width, position.width / 2) || lessWithPrecision(intersection.height, position.height / 4);
                }
                return !1;
            }, DataLabelManager.isValid = function(rect) {
                return !shapes.Rect.isEmpty(rect) && rect.width > 0 && rect.height > 0;
            }, DataLabelManager.DefaultAnchorMargin = 0, DataLabelManager.DefaultMaximumMovingDistance = 12, 
            DataLabelManager.DefaultMinimumMovingDistance = 3, DataLabelManager.InflateAmount = 5, 
            DataLabelManager;
        }();
        powerbi.DataLabelManager = DataLabelManager;
        var DataLabelArrangeGrid = function() {
            function DataLabelArrangeGrid(size, elements, layout) {
                this.grid = [], 0 !== size.width && 0 !== size.height || (this.cellSize = size, 
                this.rowCount = this.colCount = 0);
                var baseProperties = {
                    fontFamily: powerbi.visuals.dataLabelUtils.LabelTextProperties.fontFamily,
                    fontSize: powerbi.visuals.dataLabelUtils.LabelTextProperties.fontSize,
                    fontWeight: powerbi.visuals.dataLabelUtils.LabelTextProperties.fontWeight
                };
                this.cellSize = {
                    width: 0,
                    height: 0
                };
                for (var i = 0, len = elements.length; len > i; i++) {
                    var child = elements[i];
                    child.labeltext = layout.labelText(child);
                    var properties = powerbi.Prototype.inherit(baseProperties);
                    properties.text = child.labeltext, properties.fontSize = child.data ? child.data.labelFontSize : child.labelFontSize ? child.labelFontSize : powerbi.visuals.dataLabelUtils.LabelTextProperties.fontSize, 
                    child.size = {
                        width: powerbi.TextMeasurementService.measureSvgTextWidth(properties),
                        height: powerbi.TextMeasurementService.estimateSvgTextHeight(properties)
                    };
                    var w = 2 * child.size.width, h = 2 * child.size.height;
                    w > this.cellSize.width && (this.cellSize.width = w), h > this.cellSize.height && (this.cellSize.height = h);
                }
                0 === this.cellSize.width && (this.cellSize.width = size.width), 0 === this.cellSize.height && (this.cellSize.height = size.height), 
                this.colCount = this.getGridRowColCount(this.cellSize.width, size.width, DataLabelArrangeGrid.ARRANGEGRID_MIN_COUNT, DataLabelArrangeGrid.ARRANGEGRID_MAX_COUNT), 
                this.rowCount = this.getGridRowColCount(this.cellSize.height, size.height, DataLabelArrangeGrid.ARRANGEGRID_MIN_COUNT, DataLabelArrangeGrid.ARRANGEGRID_MAX_COUNT), 
                this.cellSize.width = size.width / this.colCount, this.cellSize.height = size.height / this.rowCount;
                for (var grid = this.grid, x = 0; x < this.colCount; x++) {
                    grid[x] = [];
                    for (var y = 0; y < this.rowCount; y++) grid[x][y] = [];
                }
            }
            return DataLabelArrangeGrid.prototype.add = function(element, rect) {
                for (var indexRect = this.getGridIndexRect(rect), grid = this.grid, x = indexRect.left; x < indexRect.right; x++) for (var y = indexRect.top; y < indexRect.bottom; y++) grid[x][y].push({
                    element: element,
                    rect: rect
                });
            }, DataLabelArrangeGrid.prototype.hasConflict = function(rect) {
                for (var indexRect = this.getGridIndexRect(rect), grid = this.grid, isIntersecting = shapes.Rect.isIntersecting, x = indexRect.left; x < indexRect.right; x++) for (var y = indexRect.top; y < indexRect.bottom; y++) for (var z = 0; z < grid[x][y].length; z++) {
                    var item = grid[x][y][z];
                    if (isIntersecting(item.rect, rect)) return !0;
                }
                return !1;
            }, DataLabelArrangeGrid.prototype.getGridRowColCount = function(step, length, minCount, maxCount) {
                return Math.min(Math.max(Math.ceil(length / step), minCount), maxCount);
            }, DataLabelArrangeGrid.prototype.getGridIndexRect = function(rect) {
                var restrict = function(n, min, max) {
                    return Math.min(Math.max(n, min), max);
                };
                return {
                    left: restrict(Math.floor(rect.left / this.cellSize.width), 0, this.colCount),
                    top: restrict(Math.floor(rect.top / this.cellSize.height), 0, this.rowCount),
                    right: restrict(Math.ceil((rect.left + rect.width) / this.cellSize.width), 0, this.colCount),
                    bottom: restrict(Math.ceil((rect.top + rect.height) / this.cellSize.height), 0, this.rowCount)
                };
            }, DataLabelArrangeGrid.ARRANGEGRID_MIN_COUNT = 1, DataLabelArrangeGrid.ARRANGEGRID_MAX_COUNT = 100, 
            DataLabelArrangeGrid;
        }();
        powerbi.DataLabelArrangeGrid = DataLabelArrangeGrid;
        var LocationConverter;
        !function(LocationConverter) {
            function topInside(size, rect, offset) {
                return {
                    left: rect.left + rect.width / 2 - size.width / 2,
                    top: rect.top + offset,
                    width: size.width,
                    height: size.height
                };
            }
            function bottomInside(size, rect, offset) {
                return {
                    left: rect.left + rect.width / 2 - size.width / 2,
                    top: rect.top + rect.height - size.height - offset,
                    width: size.width,
                    height: size.height
                };
            }
            function rightInside(size, rect, offset) {
                return {
                    left: rect.left + rect.width - size.width - offset,
                    top: rect.top + rect.height / 2 - size.height / 2,
                    width: size.width,
                    height: size.height
                };
            }
            function leftInside(size, rect, offset) {
                return {
                    left: rect.left + offset,
                    top: rect.top + rect.height / 2 - size.height / 2,
                    width: size.width,
                    height: size.height
                };
            }
            function topOutside(size, rect, offset) {
                return {
                    left: rect.left + rect.width / 2 - size.width / 2,
                    top: rect.top - size.height - offset,
                    width: size.width,
                    height: size.height
                };
            }
            function bottomOutside(size, rect, offset) {
                return {
                    left: rect.left + rect.width / 2 - size.width / 2,
                    top: rect.top + rect.height + offset,
                    width: size.width,
                    height: size.height
                };
            }
            function rightOutside(size, rect, offset) {
                return {
                    left: rect.left + rect.width + offset,
                    top: rect.top + rect.height / 2 - size.height / 2,
                    width: size.width,
                    height: size.height
                };
            }
            function leftOutside(size, rect, offset) {
                return {
                    left: rect.left - size.width - offset,
                    top: rect.top + rect.height / 2 - size.height / 2,
                    width: size.width,
                    height: size.height
                };
            }
            function middleHorizontal(size, rect, offset) {
                return {
                    left: rect.left + rect.width / 2 - size.width / 2 + offset,
                    top: rect.top + rect.height / 2 - size.height / 2,
                    width: size.width,
                    height: size.height
                };
            }
            function middleVertical(size, rect, offset) {
                return {
                    left: rect.left + rect.width / 2 - size.width / 2,
                    top: rect.top + rect.height / 2 - size.height / 2 + offset,
                    width: size.width,
                    height: size.height
                };
            }
            LocationConverter.topInside = topInside, LocationConverter.bottomInside = bottomInside, 
            LocationConverter.rightInside = rightInside, LocationConverter.leftInside = leftInside, 
            LocationConverter.topOutside = topOutside, LocationConverter.bottomOutside = bottomOutside, 
            LocationConverter.rightOutside = rightOutside, LocationConverter.leftOutside = leftOutside, 
            LocationConverter.middleHorizontal = middleHorizontal, LocationConverter.middleVertical = middleVertical;
        }(LocationConverter || (LocationConverter = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var shapes = powerbi.visuals.shapes, Rect = powerbi.visuals.shapes.Rect, NewDataLabelUtils = powerbi.visuals.NewDataLabelUtils, LabelArrangeGrid = function() {
            function LabelArrangeGrid(labelDataPointsGroups, viewport) {
                this.viewport = viewport;
                for (var maxLabelWidth = 0, maxLabelHeight = 0, _i = 0, labelDataPointsGroups_1 = labelDataPointsGroups; _i < labelDataPointsGroups_1.length; _i++) for (var labelDataPointsGroup = labelDataPointsGroups_1[_i], _a = 0, _b = labelDataPointsGroup.labelDataPoints; _a < _b.length; _a++) {
                    var labelDataPoint = _b[_a];
                    if (labelDataPoint.isPreferred) {
                        var dataLabelSize = labelDataPoint.labelSize;
                        dataLabelSize.width > maxLabelWidth && (maxLabelWidth = dataLabelSize.width), dataLabelSize.height > maxLabelHeight && (maxLabelHeight = dataLabelSize.height);
                    }
                }
                0 === maxLabelWidth && (maxLabelWidth = viewport.width), 0 === maxLabelHeight && (maxLabelHeight = viewport.height);
                var cellSize = this.cellSize = {
                    width: maxLabelWidth * LabelArrangeGrid.cellSizeMultiplier,
                    height: maxLabelHeight * LabelArrangeGrid.cellSizeMultiplier
                };
                this.columnCount = LabelArrangeGrid.getCellCount(cellSize.width, viewport.width, 1, 100), 
                this.rowCount = LabelArrangeGrid.getCellCount(cellSize.height, viewport.height, 1, 100);
                for (var grid = [], i = 0, ilen = this.columnCount; ilen > i; i++) {
                    grid[i] = [];
                    for (var j = 0, jlen = this.rowCount; jlen > j; j++) grid[i][j] = [];
                }
                this.grid = grid;
            }
            return LabelArrangeGrid.prototype.add = function(rect) {
                for (var containingIndexRect = this.getContainingGridSubsection(rect), x = containingIndexRect.xMin; x < containingIndexRect.xMax; x++) for (var y = containingIndexRect.yMin; y < containingIndexRect.yMax; y++) this.grid[x][y].push(rect);
            }, LabelArrangeGrid.prototype.hasConflict = function(rect) {
                return this.isWithinGridViewport(rect) ? this.hasCollision(rect) : !0;
            }, LabelArrangeGrid.prototype.tryPositionInViewport = function(rect) {
                return this.isCloseToGridViewport(rect) ? (this.isWithinGridViewport(rect) || (rect = this.tryMoveInsideViewport(rect)), 
                rect && !this.hasCollision(rect) ? rect : void 0) : void 0;
            }, LabelArrangeGrid.prototype.hasCollision = function(rect) {
                for (var containingIndexRect = this.getContainingGridSubsection(rect), grid = this.grid, isIntersecting = shapes.Rect.isIntersecting, x = containingIndexRect.xMin; x < containingIndexRect.xMax; x++) for (var y = containingIndexRect.yMin; y < containingIndexRect.yMax; y++) for (var _i = 0, _a = grid[x][y]; _i < _a.length; _i++) {
                    var currentGridRect = _a[_i];
                    if (isIntersecting(currentGridRect, rect)) return !0;
                }
                return !1;
            }, LabelArrangeGrid.prototype.isWithinGridViewport = function(rect) {
                return rect.left >= 0 && rect.top >= 0 && rect.left + rect.width <= this.viewport.width && rect.top + rect.height <= this.viewport.height;
            }, LabelArrangeGrid.prototype.isCloseToGridViewport = function(rect) {
                return rect.left + rect.width >= 0 - rect.width && rect.top + rect.height >= -rect.height && rect.left <= this.viewport.width + rect.width && rect.top <= this.viewport.height + rect.height;
            }, LabelArrangeGrid.prototype.tryMoveInsideViewport = function(rect) {
                var result = Rect.clone(rect), viewport = this.viewport;
                return rect.width > viewport.width || rect.height > viewport.height ? void 0 : (rect.left < 0 ? result.left = 0 : rect.left + rect.width > viewport.width && (result.left -= rect.left + rect.width - viewport.width), 
                rect.top < 0 ? result.top = 0 : rect.top + rect.height > viewport.height && (result.top -= rect.top + rect.height - viewport.height), 
                result);
            }, LabelArrangeGrid.prototype.getContainingGridSubsection = function(rect) {
                return {
                    xMin: LabelArrangeGrid.bound(Math.floor(rect.left / this.cellSize.width), 0, this.columnCount),
                    xMax: LabelArrangeGrid.bound(Math.ceil((rect.left + rect.width) / this.cellSize.width), 0, this.columnCount),
                    yMin: LabelArrangeGrid.bound(Math.floor(rect.top / this.cellSize.height), 0, this.rowCount),
                    yMax: LabelArrangeGrid.bound(Math.ceil((rect.top + rect.height) / this.cellSize.height), 0, this.rowCount)
                };
            }, LabelArrangeGrid.getCellCount = function(step, length, minCount, maxCount) {
                return LabelArrangeGrid.bound(Math.ceil(length / step), minCount, maxCount);
            }, LabelArrangeGrid.bound = function(value, min, max) {
                return Math.max(Math.min(value, max), min);
            }, LabelArrangeGrid.cellSizeMultiplier = 2, LabelArrangeGrid;
        }();
        powerbi.LabelArrangeGrid = LabelArrangeGrid;
        var LabelLayout = function() {
            function LabelLayout(options) {
                this.startingOffset = options.startingOffset, this.maximumOffset = options.maximumOffset, 
                null != options.offsetIterationDelta ? this.offsetIterationDelta = options.offsetIterationDelta : this.offsetIterationDelta = LabelLayout.defaultOffsetIterationDelta, 
                null != options.horizontalPadding ? this.horizontalPadding = options.horizontalPadding : this.horizontalPadding = LabelLayout.defaultHorizontalPadding, 
                null != options.verticalPadding ? this.verticalPadding = options.verticalPadding : this.verticalPadding = LabelLayout.defaultVerticalPadding, 
                this.allowLeaderLines = !!options.allowLeaderLines, this.attemptToMoveLabelsIntoViewport = !!options.attemptToMoveLabelsIntoViewport;
            }
            return LabelLayout.prototype.layout = function(labelDataPointsGroups, viewport) {
                for (var _i = 0, labelDataPointsGroups_2 = labelDataPointsGroups; _i < labelDataPointsGroups_2.length; _i++) for (var labelDataPointsGroup = labelDataPointsGroups_2[_i], _a = 0, _b = labelDataPointsGroup.labelDataPoints; _a < _b.length; _a++) {
                    var labelPoint = _b[_a];
                    labelPoint.hasBeenRendered = !1, labelPoint.hasBackground ? labelPoint.labelSize = {
                        width: labelPoint.textSize.width + 2 * NewDataLabelUtils.horizontalLabelBackgroundPadding,
                        height: labelPoint.textSize.height + 2 * NewDataLabelUtils.verticalLabelBackgroundPadding
                    } : labelPoint.labelSize = labelPoint.textSize;
                }
                for (var resultingDataLabels = [], grid = new LabelArrangeGrid(labelDataPointsGroups, viewport), _c = 0, labelDataPointsGroups_3 = labelDataPointsGroups; _c < labelDataPointsGroups_3.length; _c++) {
                    for (var labelDataPointsGroup = labelDataPointsGroups_3[_c], maxLabelsToRender = labelDataPointsGroup.maxNumberOfLabels, labelDataPoints = _.clone(labelDataPointsGroup.labelDataPoints), preferredLabels = [], j = labelDataPoints.length - 1, localMax = maxLabelsToRender; j >= 0 && localMax > 0; j--) {
                        var labelPoint = labelDataPoints[j];
                        labelPoint.isPreferred && (preferredLabels.unshift(labelDataPoints.splice(j, 1)[0]), 
                        localMax--);
                    }
                    if (preferredLabels.length > 0) {
                        var positionedLabels = this.positionDataLabels(preferredLabels, viewport, grid, maxLabelsToRender);
                        maxLabelsToRender -= positionedLabels.length, resultingDataLabels = resultingDataLabels.concat(positionedLabels);
                    }
                    if (labelDataPoints.length > 0) {
                        var labels = this.positionDataLabels(labelDataPoints, viewport, grid, maxLabelsToRender);
                        resultingDataLabels = resultingDataLabels.concat(labels);
                    }
                }
                return resultingDataLabels;
            }, LabelLayout.prototype.positionDataLabels = function(labelDataPoints, viewport, grid, maxLabelsToRender) {
                for (var drawLeaderLinesOnIteration, resultingDataLabels = [], offsetDelta = this.offsetIterationDelta, currentOffset = this.startingOffset, currentCenteredOffset = 0, labelsRendered = 0; currentOffset <= this.maximumOffset && maxLabelsToRender > labelsRendered; ) {
                    drawLeaderLinesOnIteration = this.allowLeaderLines && currentOffset > this.startingOffset;
                    for (var _i = 0, labelDataPoints_1 = labelDataPoints; _i < labelDataPoints_1.length; _i++) {
                        var labelPoint = labelDataPoints_1[_i];
                        if (!labelPoint.hasBeenRendered) {
                            var dataLabel = void 0;
                            if (dataLabel = 1 === labelPoint.parentType ? this.tryPositionForRectPositions(labelPoint, grid, currentOffset, currentCenteredOffset) : this.tryPositionForPointPositions(labelPoint, grid, currentOffset, drawLeaderLinesOnIteration), 
                            dataLabel && (resultingDataLabels.push(dataLabel), labelsRendered++), !(maxLabelsToRender > labelsRendered)) break;
                        }
                    }
                    currentOffset += offsetDelta, currentCenteredOffset += offsetDelta;
                }
                return resultingDataLabels;
            }, LabelLayout.prototype.tryPositionForRectPositions = function(labelPoint, grid, currentLabelOffset, currentCenteredLabelOffset) {
                for (var _this = this, tryPosition = function(position, adjustForViewport) {
                    var isPositionInside = 7 & position;
                    if (!isPositionInside || DataLabelRectPositioner.canFitWithinParent(labelPoint, _this.horizontalPadding, _this.verticalPadding)) {
                        var resultingBoundingBox = LabelLayout.tryPositionRect(grid, position, labelPoint, currentLabelOffset, currentCenteredLabelOffset, adjustForViewport);
                        if (resultingBoundingBox) {
                            if (isPositionInside && !DataLabelRectPositioner.isLabelWithinParent(resultingBoundingBox, labelPoint, _this.horizontalPadding, _this.verticalPadding)) return;
                            return grid.add(resultingBoundingBox), labelPoint.hasBeenRendered = !0, {
                                boundingBox: resultingBoundingBox,
                                text: labelPoint.text,
                                tooltip: labelPoint.tooltip,
                                isVisible: !0,
                                fill: isPositionInside ? labelPoint.insideFill : labelPoint.outsideFill,
                                identity: labelPoint.identity,
                                key: labelPoint.key,
                                fontSize: labelPoint.fontSize,
                                selected: !1,
                                hasBackground: !!labelPoint.hasBackground
                            };
                        }
                    }
                }, _i = 0, _a = labelPoint.parentShape.validPositions; _i < _a.length; _i++) {
                    var position = _a[_i], label = tryPosition(position, !1);
                    if (label) return label;
                }
                if (this.attemptToMoveLabelsIntoViewport) for (var _b = 0, _c = labelPoint.parentShape.validPositions; _b < _c.length; _b++) {
                    var position = _c[_b], label = tryPosition(position, !0);
                    if (label) return label;
                }
                return null;
            }, LabelLayout.tryPositionRect = function(grid, position, labelDataPoint, offset, centerOffset, adjustForViewport) {
                var offsetForPosition = offset;
                1 & position && (offsetForPosition = centerOffset);
                var labelRect = DataLabelRectPositioner.getLabelRect(labelDataPoint, position, offsetForPosition);
                if (1 !== position || 0 === labelDataPoint.parentShape.orientation) {
                    if (!grid.hasConflict(labelRect)) return labelRect;
                    if (adjustForViewport) return grid.tryPositionInViewport(labelRect);
                } else {
                    if (!grid.hasConflict(labelRect)) return labelRect;
                    if (labelRect = DataLabelRectPositioner.getLabelRect(labelDataPoint, position, -offsetForPosition), 
                    !grid.hasConflict(labelRect)) return labelRect;
                }
                return null;
            }, LabelLayout.prototype.tryPositionForPointPositions = function(labelPoint, grid, currentLabelOffset, drawLeaderLines) {
                for (var tryPosition = function(position, parentShape, adjustForViewport) {
                    var resultingBoundingBox = LabelLayout.tryPositionPoint(grid, position, labelPoint, currentLabelOffset, adjustForViewport);
                    return resultingBoundingBox ? (grid.add(resultingBoundingBox), labelPoint.hasBeenRendered = !0, 
                    {
                        boundingBox: resultingBoundingBox,
                        text: labelPoint.text,
                        tooltip: labelPoint.tooltip,
                        isVisible: !0,
                        fill: 256 === position ? labelPoint.insideFill : labelPoint.outsideFill,
                        isInsideParent: 256 === position,
                        identity: labelPoint.identity,
                        key: labelPoint.key,
                        fontSize: labelPoint.fontSize,
                        selected: !1,
                        leaderLinePoints: drawLeaderLines ? DataLabelPointPositioner.getLabelLeaderLineEndingPoint(resultingBoundingBox, position, parentShape) : null,
                        hasBackground: !!labelPoint.hasBackground
                    }) : void 0;
                }, parentShape = labelPoint.parentShape, validPositions = parentShape.validPositions, _i = 0, validPositions_1 = validPositions; _i < validPositions_1.length; _i++) {
                    var position = validPositions_1[_i], label = tryPosition(position, parentShape, !1);
                    if (label) return label;
                }
                if (this.attemptToMoveLabelsIntoViewport && !_.isEmpty(validPositions)) {
                    var label = tryPosition(validPositions[0], parentShape, !0);
                    if (label) return label;
                }
                return null;
            }, LabelLayout.tryPositionPoint = function(grid, position, labelDataPoint, offset, adjustForViewport) {
                var labelRect = DataLabelPointPositioner.getLabelRect(labelDataPoint.labelSize, labelDataPoint.parentShape, position, offset);
                return grid.hasConflict(labelRect) ? adjustForViewport ? grid.tryPositionInViewport(labelRect) : null : labelRect;
            }, LabelLayout.defaultOffsetIterationDelta = 2, LabelLayout.defaultHorizontalPadding = 2, 
            LabelLayout.defaultVerticalPadding = 2, LabelLayout;
        }();
        powerbi.LabelLayout = LabelLayout;
        var DataLabelRectPositioner;
        !function(DataLabelRectPositioner) {
            function getLabelRect(labelDataPoint, position, offset) {
                var parentRect = labelDataPoint.parentShape;
                if (null != parentRect) switch (position) {
                  case 1:
                    switch (parentRect.orientation) {
                      case 1:
                      case 2:
                        return DataLabelRectPositioner.middleVertical(labelDataPoint.labelSize, parentRect.rect, offset);

                      case 3:
                      case 4:
                        return DataLabelRectPositioner.middleHorizontal(labelDataPoint.labelSize, parentRect.rect, offset);

                      case 0:                    }

                  case 2:
                    switch (parentRect.orientation) {
                      case 1:
                        return DataLabelRectPositioner.bottomInside(labelDataPoint.labelSize, parentRect.rect, offset);

                      case 2:
                        return DataLabelRectPositioner.topInside(labelDataPoint.labelSize, parentRect.rect, offset);

                      case 3:
                        return DataLabelRectPositioner.leftInside(labelDataPoint.labelSize, parentRect.rect, offset);

                      case 4:
                        return DataLabelRectPositioner.rightInside(labelDataPoint.labelSize, parentRect.rect, offset);

                      case 0:                    }

                  case 4:
                    switch (parentRect.orientation) {
                      case 1:
                        return DataLabelRectPositioner.topInside(labelDataPoint.labelSize, parentRect.rect, offset);

                      case 2:
                        return DataLabelRectPositioner.bottomInside(labelDataPoint.labelSize, parentRect.rect, offset);

                      case 3:
                        return DataLabelRectPositioner.rightInside(labelDataPoint.labelSize, parentRect.rect, offset);

                      case 4:
                        return DataLabelRectPositioner.leftInside(labelDataPoint.labelSize, parentRect.rect, offset);

                      case 0:                    }

                  case 8:
                    switch (parentRect.orientation) {
                      case 1:
                        return DataLabelRectPositioner.bottomOutside(labelDataPoint.labelSize, parentRect.rect, offset);

                      case 2:
                        return DataLabelRectPositioner.topOutside(labelDataPoint.labelSize, parentRect.rect, offset);

                      case 3:
                        return DataLabelRectPositioner.leftOutside(labelDataPoint.labelSize, parentRect.rect, offset);

                      case 4:
                        return DataLabelRectPositioner.rightOutside(labelDataPoint.labelSize, parentRect.rect, offset);

                      case 0:                    }

                  case 16:
                    switch (parentRect.orientation) {
                      case 1:
                        return DataLabelRectPositioner.topOutside(labelDataPoint.labelSize, parentRect.rect, offset);

                      case 2:
                        return DataLabelRectPositioner.bottomOutside(labelDataPoint.labelSize, parentRect.rect, offset);

                      case 3:
                        return DataLabelRectPositioner.rightOutside(labelDataPoint.labelSize, parentRect.rect, offset);

                      case 4:
                        return DataLabelRectPositioner.leftOutside(labelDataPoint.labelSize, parentRect.rect, offset);

                      case 0:                    }
                }
                return null;
            }
            function canFitWithinParent(labelDataPoint, horizontalPadding, verticalPadding) {
                return labelDataPoint.labelSize.width + 2 * horizontalPadding < labelDataPoint.parentShape.rect.width || labelDataPoint.labelSize.height + 2 * verticalPadding < labelDataPoint.parentShape.rect.height;
            }
            function isLabelWithinParent(labelRect, labelPoint, horizontalPadding, verticalPadding) {
                var parentRect = labelPoint.parentShape.rect, labelRectWithPadding = shapes.Rect.inflate(labelRect, {
                    left: horizontalPadding,
                    right: horizontalPadding,
                    top: verticalPadding,
                    bottom: verticalPadding
                });
                return shapes.Rect.containsPoint(parentRect, {
                    x: labelRectWithPadding.left,
                    y: labelRectWithPadding.top
                }) && shapes.Rect.containsPoint(parentRect, {
                    x: labelRectWithPadding.left + labelRectWithPadding.width,
                    y: labelRectWithPadding.top + labelRectWithPadding.height
                });
            }
            function topInside(labelSize, parentRect, offset) {
                return {
                    left: parentRect.left + parentRect.width / 2 - labelSize.width / 2,
                    top: parentRect.top + offset,
                    width: labelSize.width,
                    height: labelSize.height
                };
            }
            function bottomInside(labelSize, parentRect, offset) {
                return {
                    left: parentRect.left + parentRect.width / 2 - labelSize.width / 2,
                    top: parentRect.top + parentRect.height - offset - labelSize.height,
                    width: labelSize.width,
                    height: labelSize.height
                };
            }
            function rightInside(labelSize, parentRect, offset) {
                return {
                    left: parentRect.left + parentRect.width - labelSize.width - offset,
                    top: parentRect.top + parentRect.height / 2 - labelSize.height / 2,
                    width: labelSize.width,
                    height: labelSize.height
                };
            }
            function leftInside(labelSize, parentRect, offset) {
                return {
                    left: parentRect.left + offset,
                    top: parentRect.top + parentRect.height / 2 - labelSize.height / 2,
                    width: labelSize.width,
                    height: labelSize.height
                };
            }
            function topOutside(labelSize, parentRect, offset) {
                return {
                    left: parentRect.left + parentRect.width / 2 - labelSize.width / 2,
                    top: parentRect.top - labelSize.height - offset,
                    width: labelSize.width,
                    height: labelSize.height
                };
            }
            function bottomOutside(labelSize, parentRect, offset) {
                return {
                    left: parentRect.left + parentRect.width / 2 - labelSize.width / 2,
                    top: parentRect.top + parentRect.height + offset,
                    width: labelSize.width,
                    height: labelSize.height
                };
            }
            function rightOutside(labelSize, parentRect, offset) {
                return {
                    left: parentRect.left + parentRect.width + offset,
                    top: parentRect.top + parentRect.height / 2 - labelSize.height / 2,
                    width: labelSize.width,
                    height: labelSize.height
                };
            }
            function leftOutside(labelSize, parentRect, offset) {
                return {
                    left: parentRect.left - labelSize.width - offset,
                    top: parentRect.top + parentRect.height / 2 - labelSize.height / 2,
                    width: labelSize.width,
                    height: labelSize.height
                };
            }
            function middleHorizontal(labelSize, parentRect, offset) {
                return {
                    left: parentRect.left + parentRect.width / 2 - labelSize.width / 2 + offset,
                    top: parentRect.top + parentRect.height / 2 - labelSize.height / 2,
                    width: labelSize.width,
                    height: labelSize.height
                };
            }
            function middleVertical(labelSize, parentRect, offset) {
                return {
                    left: parentRect.left + parentRect.width / 2 - labelSize.width / 2,
                    top: parentRect.top + parentRect.height / 2 - labelSize.height / 2 + offset,
                    width: labelSize.width,
                    height: labelSize.height
                };
            }
            DataLabelRectPositioner.getLabelRect = getLabelRect, DataLabelRectPositioner.canFitWithinParent = canFitWithinParent, 
            DataLabelRectPositioner.isLabelWithinParent = isLabelWithinParent, DataLabelRectPositioner.topInside = topInside, 
            DataLabelRectPositioner.bottomInside = bottomInside, DataLabelRectPositioner.rightInside = rightInside, 
            DataLabelRectPositioner.leftInside = leftInside, DataLabelRectPositioner.topOutside = topOutside, 
            DataLabelRectPositioner.bottomOutside = bottomOutside, DataLabelRectPositioner.rightOutside = rightOutside, 
            DataLabelRectPositioner.leftOutside = leftOutside, DataLabelRectPositioner.middleHorizontal = middleHorizontal, 
            DataLabelRectPositioner.middleVertical = middleVertical;
        }(DataLabelRectPositioner = powerbi.DataLabelRectPositioner || (powerbi.DataLabelRectPositioner = {}));
        var DataLabelPointPositioner;
        !function(DataLabelPointPositioner) {
            function getLabelRect(labelSize, parentPoint, position, offset) {
                switch (position) {
                  case 1:
                    return DataLabelPointPositioner.above(labelSize, parentPoint.point, parentPoint.radius + offset);

                  case 2:
                    return DataLabelPointPositioner.below(labelSize, parentPoint.point, parentPoint.radius + offset);

                  case 4:
                    return DataLabelPointPositioner.left(labelSize, parentPoint.point, parentPoint.radius + offset);

                  case 8:
                    return DataLabelPointPositioner.right(labelSize, parentPoint.point, parentPoint.radius + offset);

                  case 32:
                    return DataLabelPointPositioner.belowLeft(labelSize, parentPoint.point, parentPoint.radius + offset);

                  case 16:
                    return DataLabelPointPositioner.belowRight(labelSize, parentPoint.point, parentPoint.radius + offset);

                  case 128:
                    return DataLabelPointPositioner.aboveLeft(labelSize, parentPoint.point, parentPoint.radius + offset);

                  case 64:
                    return DataLabelPointPositioner.aboveRight(labelSize, parentPoint.point, parentPoint.radius + offset);

                  case 256:
                    return DataLabelPointPositioner.center(labelSize, parentPoint.point);
                }
                return null;
            }
            function above(labelSize, parentPoint, offset) {
                return {
                    left: parentPoint.x - labelSize.width / 2,
                    top: parentPoint.y - offset - labelSize.height,
                    width: labelSize.width,
                    height: labelSize.height
                };
            }
            function below(labelSize, parentPoint, offset) {
                return {
                    left: parentPoint.x - labelSize.width / 2,
                    top: parentPoint.y + offset,
                    width: labelSize.width,
                    height: labelSize.height
                };
            }
            function left(labelSize, parentPoint, offset) {
                return {
                    left: parentPoint.x - offset - labelSize.width,
                    top: parentPoint.y - labelSize.height / 2,
                    width: labelSize.width,
                    height: labelSize.height
                };
            }
            function right(labelSize, parentPoint, offset) {
                return {
                    left: parentPoint.x + offset,
                    top: parentPoint.y - labelSize.height / 2,
                    width: labelSize.width,
                    height: labelSize.height
                };
            }
            function belowLeft(labelSize, parentPoint, offset) {
                return {
                    left: parentPoint.x - DataLabelPointPositioner.sin45 * offset - labelSize.width,
                    top: parentPoint.y + DataLabelPointPositioner.cos45 * offset,
                    width: labelSize.width,
                    height: labelSize.height
                };
            }
            function belowRight(labelSize, parentPoint, offset) {
                return {
                    left: parentPoint.x + DataLabelPointPositioner.sin45 * offset,
                    top: parentPoint.y + DataLabelPointPositioner.cos45 * offset,
                    width: labelSize.width,
                    height: labelSize.height
                };
            }
            function aboveLeft(labelSize, parentPoint, offset) {
                return {
                    left: parentPoint.x - DataLabelPointPositioner.sin45 * offset - labelSize.width,
                    top: parentPoint.y - DataLabelPointPositioner.cos45 * offset - labelSize.height,
                    width: labelSize.width,
                    height: labelSize.height
                };
            }
            function aboveRight(labelSize, parentPoint, offset) {
                return {
                    left: parentPoint.x + DataLabelPointPositioner.sin45 * offset,
                    top: parentPoint.y - DataLabelPointPositioner.cos45 * offset - labelSize.height,
                    width: labelSize.width,
                    height: labelSize.height
                };
            }
            function center(labelSize, parentPoint) {
                return {
                    left: parentPoint.x - labelSize.width / 2,
                    top: parentPoint.y - labelSize.height / 2,
                    width: labelSize.width,
                    height: labelSize.height
                };
            }
            function getLabelLeaderLineEndingPoint(boundingBox, position, parentShape) {
                var x = boundingBox.left, y = boundingBox.top;
                switch (position) {
                  case 1:
                    x += boundingBox.width / 2, y += boundingBox.height;
                    break;

                  case 2:
                    x += boundingBox.width / 2;
                    break;

                  case 4:
                    x += boundingBox.width, y += 2 * boundingBox.height / 3;
                    break;

                  case 8:
                    y += 2 * boundingBox.height / 3;
                    break;

                  case 32:
                    x += boundingBox.width, y += boundingBox.height / 2;
                    break;

                  case 16:
                    y += boundingBox.height / 2;
                    break;

                  case 128:
                    x += boundingBox.width, y += boundingBox.height;
                    break;

                  case 64:
                    y += boundingBox.height;
                }
                return [ [ parentShape.point.x, parentShape.point.y ], [ x, y ] ];
            }
            DataLabelPointPositioner.cos45 = Math.cos(45), DataLabelPointPositioner.sin45 = Math.sin(45), 
            DataLabelPointPositioner.getLabelRect = getLabelRect, DataLabelPointPositioner.above = above, 
            DataLabelPointPositioner.below = below, DataLabelPointPositioner.left = left, DataLabelPointPositioner.right = right, 
            DataLabelPointPositioner.belowLeft = belowLeft, DataLabelPointPositioner.belowRight = belowRight, 
            DataLabelPointPositioner.aboveLeft = aboveLeft, DataLabelPointPositioner.aboveRight = aboveRight, 
            DataLabelPointPositioner.center = center, DataLabelPointPositioner.getLabelLeaderLineEndingPoint = getLabelLeaderLineEndingPoint;
        }(DataLabelPointPositioner = powerbi.DataLabelPointPositioner || (powerbi.DataLabelPointPositioner = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var NewDataLabelUtils = powerbi.visuals.NewDataLabelUtils, labelStyle = powerbi.visuals.labelStyle, DonutLabelUtils = powerbi.visuals.DonutLabelUtils, DonutLabelLayout = function() {
            function DonutLabelLayout(options, donutChartProperties) {
                this.startingOffset = options.startingOffset, this.maximumOffset = options.maximumOffset, 
                null != options.offsetIterationDelta && (this.offsetIterationDelta = options.offsetIterationDelta), 
                this.donutChartProperties = donutChartProperties, this.center = {
                    x: donutChartProperties.viewport.width / 2,
                    y: donutChartProperties.viewport.height / 2
                }, this.outerRadius = this.donutChartProperties.radius * this.donutChartProperties.outerArcRadiusRatio, 
                this.innerRadius = this.donutChartProperties.radius / 2 * this.donutChartProperties.innerArcRadiusRatio, 
                this.additionalCharsWidth = powerbi.TextMeasurementService.measureSvgTextWidth({
                    text: " ()",
                    fontFamily: NewDataLabelUtils.LabelTextProperties.fontFamily,
                    fontSize: jsCommon.PixelConverter.fromPoint(donutChartProperties.dataLabelsSettings.fontSize),
                    fontWeight: NewDataLabelUtils.LabelTextProperties.fontWeight
                });
            }
            return DonutLabelLayout.prototype.layout = function(labelDataPoints) {
                for (var _i = 0, labelDataPoints_1 = labelDataPoints; _i < labelDataPoints_1.length; _i++) {
                    var donutLabel = labelDataPoints_1[_i];
                    donutLabel.hasBeenRendered = !1, donutLabel.labelSize = donutLabel.textSize;
                }
                for (var resultingLabels = [], preferredLabels = [], viewport = this.donutChartProperties.viewport, labelDataPointsGroup = {
                    labelDataPoints: labelDataPoints,
                    maxNumberOfLabels: labelDataPoints.length
                }, grid = new powerbi.LabelArrangeGrid([ labelDataPointsGroup ], viewport), i = labelDataPoints.length - 1; i >= 0; i--) {
                    var labelPoint = labelDataPoints[i];
                    if (labelPoint.isPreferred) {
                        var label = labelDataPoints.splice(i, 1);
                        preferredLabels = label.concat(preferredLabels);
                    }
                }
                if (preferredLabels.length > 0 && (resultingLabels = this.positionLabels(preferredLabels, grid)), 
                labelDataPoints.length > 0) {
                    var labels = this.positionLabels(labelDataPoints, grid);
                    resultingLabels = resultingLabels.concat(labels);
                }
                return resultingLabels;
            }, DonutLabelLayout.prototype.positionLabels = function(labelDataPoints, grid) {
                for (var resultingLabels = [], offsetDelta = this.offsetIterationDelta, currentOffset = this.startingOffset, currentCenteredOffset = 0; currentOffset <= this.maximumOffset; ) {
                    for (var _i = 0, labelDataPoints_2 = labelDataPoints; _i < labelDataPoints_2.length; _i++) {
                        var labelPoint = labelDataPoints_2[_i];
                        if (!labelPoint.hasBeenRendered) {
                            var label = this.tryPositionForDonut(labelPoint, grid, currentOffset);
                            label && resultingLabels.push(label);
                        }
                    }
                    currentOffset += offsetDelta, currentCenteredOffset += offsetDelta;
                }
                return resultingLabels;
            }, DonutLabelLayout.prototype.tryPositionForDonut = function(labelPoint, grid, currentLabelOffset) {
                var parentShape = labelPoint.parentShape;
                if (!_.isEmpty(parentShape.validPositions) && 0 !== parentShape.validPositions[0]) {
                    var defaultPosition = parentShape.validPositions[0], bestCandidate = this.tryAllPositions(labelPoint, grid, defaultPosition, currentLabelOffset);
                    if (bestCandidate && 0 === bestCandidate.score) return this.buildLabel(bestCandidate, grid);
                    if (this.donutChartProperties.dataLabelsSettings.labelStyle === labelStyle.both) {
                        var splitLabelDataPoint = this.splitDonutDataPoint(labelPoint), bestSplitCandidate = this.tryAllPositions(splitLabelDataPoint, grid, defaultPosition, currentLabelOffset);
                        if (bestSplitCandidate && (!bestCandidate || bestSplitCandidate.score < bestCandidate.score)) return this.buildLabel(bestSplitCandidate, grid);
                    }
                    return bestCandidate ? this.buildLabel(bestCandidate, grid) : void 0;
                }
            }, DonutLabelLayout.prototype.generateCandidate = function(labelDataPoint, candidatePosition, grid, currentLabelOffset) {
                var angle = this.generateCandidateAngleForPosition(labelDataPoint.donutArcDescriptor, candidatePosition), parentShape = this.getPointPositionForAngle(angle), parentPoint = parentShape.point, score = this.score(labelDataPoint, parentPoint), leaderLinePoints = DonutLabelUtils.getLabelLeaderLineForDonutChart(labelDataPoint.donutArcDescriptor, this.donutChartProperties, parentPoint, angle), leaderLinesSize = DonutLabelUtils.getLabelLeaderLinesSizeForDonutChart(leaderLinePoints), newLabelDataPoint = _.clone(labelDataPoint);
                newLabelDataPoint.angle = angle, newLabelDataPoint.parentShape = parentShape, newLabelDataPoint.leaderLinePoints = leaderLinePoints, 
                newLabelDataPoint.linesSize = leaderLinesSize;
                var boundingBoxs = DonutLabelLayout.tryPositionPoint(grid, parentShape.validPositions[0], newLabelDataPoint, currentLabelOffset, this.center, this.donutChartProperties.viewport);
                return {
                    angle: angle,
                    point: parentShape,
                    score: score,
                    labelRects: boundingBoxs,
                    labelDataPoint: newLabelDataPoint
                };
            }, DonutLabelLayout.prototype.tryAllPositions = function(labelDataPoint, grid, defaultPosition, currentLabelOffset) {
                var boundingBoxs = DonutLabelLayout.tryPositionPoint(grid, defaultPosition, labelDataPoint, currentLabelOffset, this.center, this.donutChartProperties.viewport), originalPoint = labelDataPoint.parentShape, originalCandidate = {
                    point: originalPoint,
                    angle: labelDataPoint.angle,
                    score: this.score(labelDataPoint, originalPoint.point),
                    labelRects: boundingBoxs,
                    labelDataPoint: labelDataPoint
                };
                if (boundingBoxs && boundingBoxs.textRect && 0 === originalCandidate.score) return originalCandidate;
                var bestCandidate, positions = [];
                boundingBoxs && boundingBoxs.textRect ? (positions = this.getLabelPointPositions(labelDataPoint, !0), 
                bestCandidate = originalCandidate) : positions = this.getLabelPointPositions(labelDataPoint, !1);
                for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
                    var position = positions_1[_i], candidate = this.generateCandidate(labelDataPoint, position, grid, currentLabelOffset);
                    if (candidate.labelRects && candidate.labelRects.textRect && (null == bestCandidate || candidate.score < bestCandidate.score) && (bestCandidate = candidate, 
                    0 === bestCandidate.score)) return bestCandidate;
                }
                return bestCandidate;
            }, DonutLabelLayout.prototype.buildLabel = function(labelLayout, grid) {
                var resultingBoundingBox = labelLayout.labelRects.textRect, labelPoint = labelLayout.labelDataPoint;
                grid.add(resultingBoundingBox), grid.add(labelLayout.labelRects.horizontalLineRect), 
                grid.add(labelLayout.labelRects.diagonalLineRect), labelPoint.hasBeenRendered = !0;
                var left = resultingBoundingBox.left - this.center.x;
                0 > left ? left += resultingBoundingBox.width / 2 : left -= resultingBoundingBox.width / 2;
                var formattedDataLabel, formattedCategoryLabel, text, textAnchor = 8 === labelPoint.parentShape.validPositions[0] ? "start" : "end", boundingBox = {
                    left: left,
                    top: resultingBoundingBox.top - this.center.y,
                    height: resultingBoundingBox.height,
                    width: resultingBoundingBox.width
                }, labelSettingsStyle = this.donutChartProperties.dataLabelsSettings.labelStyle, spaceAvailableForLabels = DonutLabelUtils.getSpaceAvailableForDonutLabels(labelPoint.parentShape.point.x, this.donutChartProperties.viewport), getLabelFormattedText = powerbi.visuals.dataLabelUtils.getLabelFormattedText, fontSize = labelPoint.fontSize, hasOneLabelRow = labelSettingsStyle === labelStyle.both && null == labelPoint.secondRowText;
                switch (hasOneLabelRow && (labelPoint.dataLabel = " (" + labelPoint.dataLabel + ")", 
                spaceAvailableForLabels /= 2), labelSettingsStyle !== labelStyle.both && labelSettingsStyle !== labelStyle.data || (formattedDataLabel = getLabelFormattedText({
                    label: labelPoint.dataLabel,
                    maxWidth: spaceAvailableForLabels,
                    fontSize: fontSize
                })), labelSettingsStyle !== labelStyle.both && labelSettingsStyle !== labelStyle.category || (formattedCategoryLabel = getLabelFormattedText({
                    label: labelPoint.categoryLabel,
                    maxWidth: spaceAvailableForLabels,
                    fontSize: fontSize
                })), labelSettingsStyle) {
                  case labelStyle.both:
                    null == labelPoint.secondRowText ? text = formattedCategoryLabel + formattedDataLabel : (text = formattedDataLabel, 
                    labelPoint.secondRowText = formattedCategoryLabel);
                    break;

                  case labelStyle.data:
                    text = formattedDataLabel;
                    break;

                  case labelStyle.category:
                    text = formattedCategoryLabel;
                }
                return labelPoint.textSize.width = Math.min(labelPoint.textSize.width, hasOneLabelRow ? 2 * spaceAvailableForLabels : spaceAvailableForLabels), 
                {
                    boundingBox: boundingBox,
                    text: text,
                    tooltip: labelPoint.tooltip,
                    isVisible: !0,
                    fill: labelPoint.outsideFill,
                    identity: labelPoint.identity,
                    fontSize: fontSize,
                    selected: !1,
                    textAnchor: textAnchor,
                    leaderLinePoints: labelPoint.leaderLinePoints,
                    hasBackground: !1,
                    secondRowText: labelPoint.secondRowText
                };
            }, DonutLabelLayout.tryPositionPoint = function(grid, position, labelDataPoint, offset, center, viewport) {
                var parentPoint = labelDataPoint.parentShape, textSize = _.clone(labelDataPoint.textSize);
                textSize.width = Math.min(textSize.width, DonutLabelUtils.getSpaceAvailableForDonutLabels(parentPoint.point.x, viewport));
                var labelRect = powerbi.DataLabelPointPositioner.getLabelRect(textSize, parentPoint, position, offset), diagonalLineParentPoint = {
                    point: {
                        x: labelDataPoint.leaderLinePoints[0][0],
                        y: labelDataPoint.leaderLinePoints[0][1] < 0 ? labelDataPoint.leaderLinePoints[1][1] : labelDataPoint.leaderLinePoints[0][1]
                    },
                    radius: 0,
                    validPositions: null
                }, diagonalLineRect = powerbi.DataLabelPointPositioner.getLabelRect(labelDataPoint.linesSize[DonutLabelUtils.DiagonalLineIndex], diagonalLineParentPoint, position, offset), horizontalLineParentPoint = {
                    point: {
                        x: labelDataPoint.leaderLinePoints[1][0],
                        y: labelDataPoint.leaderLinePoints[1][1]
                    },
                    radius: 0,
                    validPositions: null
                }, horizontalLineRect = powerbi.DataLabelPointPositioner.getLabelRect(labelDataPoint.linesSize[DonutLabelUtils.HorizontalLineIndex], horizontalLineParentPoint, position, offset);
                if (labelRect && diagonalLineRect && horizontalLineRect) {
                    labelRect.left += center.x, labelRect.top += center.y;
                    var centerForLinesWidth = center.x - labelRect.width / 2;
                    return diagonalLineRect.left += centerForLinesWidth, diagonalLineRect.top += center.y, 
                    horizontalLineRect.left += centerForLinesWidth, horizontalLineRect.top += center.y, 
                    grid.hasConflict(labelRect) || grid.hasConflict(diagonalLineRect) || grid.hasConflict(horizontalLineRect) ? void 0 : {
                        textRect: labelRect,
                        diagonalLineRect: diagonalLineRect,
                        horizontalLineRect: horizontalLineRect
                    };
                }
            }, DonutLabelLayout.prototype.getLabelPointPositions = function(labelPoint, isTruncated) {
                var parentShape = labelPoint.parentShape, position = parentShape.validPositions[0];
                return isTruncated ? parentShape.point.y < 0 ? 8 === position ? [ 64 ] : [ 128 ] : 8 === position ? [ 16 ] : [ 32 ] : 4 === position ? [ 128, 32 ] : [ 16, 64 ];
            }, DonutLabelLayout.prototype.splitDonutDataPoint = function(labelPoint) {
                var textSize = {
                    width: Math.max(labelPoint.categoryLabelSize.width, labelPoint.dataLabelSize.width),
                    height: 2 * labelPoint.dataLabelSize.height
                }, newLabelPoint = _.clone(labelPoint);
                return newLabelPoint.textSize = textSize, newLabelPoint.secondRowText = labelPoint.categoryLabel, 
                newLabelPoint;
            }, DonutLabelLayout.prototype.generateCandidateAngleForPosition = function(d, position) {
                var midAngle = d.startAngle + (d.endAngle - d.startAngle) / 2;
                switch (position) {
                  case 64:
                  case 32:
                    return (d.startAngle + midAngle - Math.PI) / 2;

                  case 128:
                  case 16:
                    return (midAngle + d.endAngle - Math.PI) / 2;
                }
            }, DonutLabelLayout.prototype.getPointPositionForAngle = function(angle) {
                var labelX = DonutLabelUtils.getXPositionForDonutLabel(Math.cos(angle) * this.outerRadius), labelY = Math.sin(angle) * this.outerRadius, newPosition = 0 > labelX ? 4 : 8, pointPosition = {
                    point: {
                        x: labelX,
                        y: labelY
                    },
                    validPositions: [ newPosition ],
                    radius: 0
                };
                return pointPosition;
            }, DonutLabelLayout.prototype.score = function(labelPoint, point) {
                var textWidth, spaceAvailableForLabels = DonutLabelUtils.getSpaceAvailableForDonutLabels(point.x, this.donutChartProperties.viewport);
                return this.donutChartProperties.dataLabelsSettings.labelStyle === labelStyle.both && null == labelPoint.secondRowText ? (textWidth = Math.max(labelPoint.categoryLabelSize.width, labelPoint.dataLabelSize.width + this.additionalCharsWidth), 
                spaceAvailableForLabels /= 2) : textWidth = labelPoint.textSize.width, Math.max(textWidth - spaceAvailableForLabels, 0);
            }, DonutLabelLayout;
        }();
        powerbi.DonutLabelLayout = DonutLabelLayout;
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var NewDataLabelUtils = powerbi.visuals.NewDataLabelUtils, DefaultCentroidOffset = 5, OffsetDelta = 10, MaximumOffset = 60, stemExtension = 5, FilledMapLabelLayout = function() {
            function FilledMapLabelLayout() {}
            return FilledMapLabelLayout.prototype.layout = function(labelDataPoints, viewport, polygonInfoTransform, redrawDataLabels) {
                if (redrawDataLabels || void 0 === this.labels) {
                    for (var labelDataPointsGroup = {
                        labelDataPoints: labelDataPoints,
                        maxNumberOfLabels: labelDataPoints.length
                    }, _i = 0, labelDataPoints_1 = labelDataPoints; _i < labelDataPoints_1.length; _i++) {
                        var labelPoint = labelDataPoints_1[_i];
                        labelPoint.labelSize = {
                            width: labelPoint.textSize.width + 2 * NewDataLabelUtils.horizontalLabelBackgroundPadding,
                            height: labelPoint.textSize.height + 2 * NewDataLabelUtils.verticalLabelBackgroundPadding
                        };
                    }
                    for (var grid = new powerbi.LabelArrangeGrid([ labelDataPointsGroup ], viewport), resultingDataLabels = [], allPolygons = [], _a = 0, labelDataPoints_2 = labelDataPoints; _a < labelDataPoints_2.length; _a++) {
                        var labelPoint = labelDataPoints_2[_a], polygon = labelPoint.parentShape.polygon;
                        allPolygons.push(polygon), polygon.pixelBoundingRect = polygonInfoTransform.applyToRect(polygon.absoluteBoundingRect());
                    }
                    for (var shapesgrid = new LabelPolygonArrangeGrid(allPolygons, viewport), _b = 0, labelDataPoints_3 = labelDataPoints; _b < labelDataPoints_3.length; _b++) {
                        var labelPoint = labelDataPoints_3[_b], dataLabel = this.getLabelByPolygonPositions(labelPoint, polygonInfoTransform, grid, shapesgrid);
                        null != dataLabel && resultingDataLabels.push(dataLabel);
                    }
                    this.labels = resultingDataLabels;
                } else this.updateLabelOffsets(polygonInfoTransform);
                return this.labels;
            }, FilledMapLabelLayout.prototype.getLabelPolygon = function(mapDataPoint, position, pointPosition, offset) {
                var dataPointSize = {
                    width: mapDataPoint.textSize.width,
                    height: mapDataPoint.textSize.height
                };
                return this.getLabelBoundingBox(dataPointSize, position, pointPosition, offset);
            }, FilledMapLabelLayout.prototype.getLabelBoundingBox = function(dataPointSize, position, pointPosition, offset) {
                switch (position) {
                  case 1:
                    return powerbi.DataLabelPointPositioner.above(dataPointSize, pointPosition, offset);

                  case 2:
                    return powerbi.DataLabelPointPositioner.below(dataPointSize, pointPosition, offset);

                  case 4:
                    return powerbi.DataLabelPointPositioner.left(dataPointSize, pointPosition, offset);

                  case 8:
                    return powerbi.DataLabelPointPositioner.right(dataPointSize, pointPosition, offset);

                  case 128:
                    return powerbi.DataLabelPointPositioner.aboveLeft(dataPointSize, pointPosition, offset);

                  case 64:
                    return powerbi.DataLabelPointPositioner.aboveRight(dataPointSize, pointPosition, offset);

                  case 32:
                    return powerbi.DataLabelPointPositioner.belowLeft(dataPointSize, pointPosition, offset);

                  case 16:
                    return powerbi.DataLabelPointPositioner.belowRight(dataPointSize, pointPosition, offset);

                  case 256:
                    return powerbi.DataLabelPointPositioner.center(dataPointSize, pointPosition);
                }
                return null;
            }, FilledMapLabelLayout.prototype.getLabelByPolygonPositions = function(labelPoint, polygonInfoTransform, grid, shapesGrid) {
                for (var offset = 0, inverseTransorm = polygonInfoTransform.getInverse(), i = 0; 2 > i; i++) {
                    1 === i && (offset = DefaultCentroidOffset);
                    for (var _i = 0, _a = labelPoint.parentShape.validPositions; _i < _a.length; _i++) {
                        var position = _a[_i], resultingAbsoluteBoundingBox = this.tryPositionForPolygonPosition(position, labelPoint, polygonInfoTransform, offset, inverseTransorm);
                        if ((256 !== position || 0 === i) && resultingAbsoluteBoundingBox) {
                            var resultingBoundingBox = polygonInfoTransform.applyToRect(resultingAbsoluteBoundingBox), dataLabel = {
                                text: labelPoint.text,
                                secondRowText: labelPoint.secondRowText,
                                boundingBox: resultingBoundingBox,
                                isVisible: !0,
                                fill: labelPoint.insideFill,
                                identity: null,
                                selected: !1,
                                hasBackground: !0,
                                textAnchor: "middle",
                                originalPixelOffset: offset,
                                isPlacedInsidePolygon: !0,
                                absoluteBoundingBoxCenter: {
                                    x: resultingAbsoluteBoundingBox.left + resultingAbsoluteBoundingBox.width / 2,
                                    y: resultingAbsoluteBoundingBox.top + resultingAbsoluteBoundingBox.height / 2
                                }
                            };
                            return dataLabel;
                        }
                    }
                }
                for (var currentOffset = 6; MaximumOffset >= currentOffset; ) {
                    for (var _b = 0, _c = labelPoint.parentShape.validPositions; _b < _c.length; _b++) {
                        var position = _c[_b];
                        if (256 !== position) {
                            var polygon = labelPoint.parentShape.polygon, pixelCentroid = polygonInfoTransform.applyToPoint(polygon.absoluteCentroid()), resultingAbsolutBoundingBox = this.tryPlaceLabelOutsidePolygon(grid, position, labelPoint, currentOffset, pixelCentroid, shapesGrid, inverseTransorm);
                            if (resultingAbsolutBoundingBox) {
                                var resultingBoundingBox = polygonInfoTransform.applyToRect(resultingAbsolutBoundingBox), dataLabel = {
                                    text: labelPoint.text,
                                    secondRowText: labelPoint.secondRowText,
                                    boundingBox: resultingBoundingBox,
                                    isVisible: !0,
                                    fill: labelPoint.insideFill,
                                    identity: null,
                                    selected: !1,
                                    hasBackground: !0,
                                    isPlacedInsidePolygon: !1,
                                    textAnchor: "middle",
                                    originalPixelOffset: currentOffset,
                                    originalPosition: position,
                                    originalAbsoluteCentroid: polygon.absoluteCentroid(),
                                    absoluteBoundingBoxCenter: {
                                        x: resultingAbsolutBoundingBox.left + resultingAbsolutBoundingBox.width / 2,
                                        y: resultingAbsolutBoundingBox.top + resultingAbsolutBoundingBox.height / 2
                                    }
                                }, pixelStemSource = this.calculateStemSource(polygonInfoTransform, inverseTransorm, polygon, resultingBoundingBox, position, pixelCentroid);
                                return dataLabel.leaderLinePoints = this.setLeaderLinePoints(pixelStemSource, this.calculateStemDestination(resultingBoundingBox, position)), 
                                dataLabel.absoluteStemSource = inverseTransorm.applyToPoint(pixelStemSource), grid.add(resultingBoundingBox), 
                                dataLabel;
                            }
                        }
                    }
                    currentOffset += OffsetDelta;
                }
                return null;
            }, FilledMapLabelLayout.prototype.setLeaderLinePoints = function(stemSource, stemDestination) {
                return [ [ stemSource.x, stemSource.y ], [ stemDestination.x, stemDestination.y ] ];
            }, FilledMapLabelLayout.prototype.calculateStemSource = function(polygonInfoTransform, inverseTransorm, polygon, labelBoundingBox, position, pixelCentroid) {
                var absoluteStemSource = polygon.lineIntersectionPoint(polygon.absoluteCentroid(), inverseTransorm.applyToPoint({
                    x: labelBoundingBox.left + labelBoundingBox.width / 2,
                    y: labelBoundingBox.top + labelBoundingBox.height / 2
                }));
                if (null == absoluteStemSource) return pixelCentroid;
                var stemSource = polygonInfoTransform.applyToPoint(absoluteStemSource);
                switch (position) {
                  case 1:
                    stemSource.y += stemExtension;
                    break;

                  case 2:
                    stemSource.y -= stemExtension;
                    break;

                  case 4:
                    stemSource.x += stemExtension;
                    break;

                  case 8:
                    stemSource.x -= stemExtension;
                    break;

                  case 128:
                    stemSource.x += stemExtension / powerbi.DataLabelPointPositioner.cos45, stemSource.y += stemExtension / powerbi.DataLabelPointPositioner.sin45;
                    break;

                  case 64:
                    stemSource.x -= stemExtension / powerbi.DataLabelPointPositioner.cos45, stemSource.y += stemExtension / powerbi.DataLabelPointPositioner.sin45;
                    break;

                  case 32:
                    stemSource.x += stemExtension / powerbi.DataLabelPointPositioner.cos45, stemSource.y -= stemExtension / powerbi.DataLabelPointPositioner.sin45;
                    break;

                  case 16:
                    stemSource.x -= stemExtension / powerbi.DataLabelPointPositioner.cos45, stemSource.y -= stemExtension / powerbi.DataLabelPointPositioner.sin45;
                    break;

                  case 256:                }
                return stemSource;
            }, FilledMapLabelLayout.prototype.calculateStemDestination = function(labelBoundingBox, position) {
                var x, y;
                switch (position) {
                  case 1:
                    x = labelBoundingBox.left + labelBoundingBox.width / 2, y = labelBoundingBox.top + labelBoundingBox.height;
                    break;

                  case 2:
                    x = labelBoundingBox.left + labelBoundingBox.width / 2, y = labelBoundingBox.top;
                    break;

                  case 4:
                    x = labelBoundingBox.left + labelBoundingBox.width, y = labelBoundingBox.top + labelBoundingBox.height / 2;
                    break;

                  case 8:
                    x = labelBoundingBox.left, y = labelBoundingBox.top + labelBoundingBox.height / 2;
                    break;

                  case 128:
                    x = labelBoundingBox.left + labelBoundingBox.width, y = labelBoundingBox.top + labelBoundingBox.height;
                    break;

                  case 64:
                    x = labelBoundingBox.left, y = labelBoundingBox.top + labelBoundingBox.height;
                    break;

                  case 32:
                    x = labelBoundingBox.left + labelBoundingBox.width, y = labelBoundingBox.top;
                    break;

                  case 16:
                    x = labelBoundingBox.left, y = labelBoundingBox.top;
                    break;

                  case 256:                }
                return {
                    x: x,
                    y: y
                };
            }, FilledMapLabelLayout.prototype.tryPositionForPolygonPosition = function(position, labelDataPoint, polygonInfoTransform, offset, inverseTransorm) {
                var polygon = labelDataPoint.parentShape.polygon, pixelCentroid = polygonInfoTransform.applyToPoint(polygon.absoluteCentroid()), labelRect = this.getLabelPolygon(labelDataPoint, position, pixelCentroid, offset), absoluteLabelRect = this.getAbsoluteRectangle(inverseTransorm, labelRect);
                return polygon.contains(absoluteLabelRect) ? absoluteLabelRect : null;
            }, FilledMapLabelLayout.prototype.tryPlaceLabelOutsidePolygon = function(grid, position, labelDataPoint, offset, pixelCentroid, shapesGrid, inverseTransform) {
                var offsetForPosition = offset, labelRect = this.getLabelPolygon(labelDataPoint, position, pixelCentroid, offsetForPosition), otherLabelsConflict = grid.hasConflict(labelRect);
                if (!otherLabelsConflict) {
                    var absoluteLabelRect = this.getAbsoluteRectangle(inverseTransform, labelRect);
                    if (!shapesGrid.hasConflict(absoluteLabelRect, labelRect)) return absoluteLabelRect;
                }
                return null;
            }, FilledMapLabelLayout.prototype.updateLabelOffsets = function(polygonInfoTransform) {
                for (var _i = 0, _a = this.labels; _i < _a.length; _i++) {
                    var label = _a[_i];
                    if (label.isVisible) if (label.isPlacedInsidePolygon) {
                        var newOffset = polygonInfoTransform.applyToPoint(label.absoluteBoundingBoxCenter), xDelta = label.boundingBox.left + label.boundingBox.width / 2 - newOffset.x, yDelta = label.boundingBox.top + label.boundingBox.height / 2 - newOffset.y;
                        label.boundingBox.top -= yDelta, label.boundingBox.left -= xDelta;
                    } else {
                        var stemSourcePoint = polygonInfoTransform.applyToPoint(label.absoluteStemSource), pixelCentroid = polygonInfoTransform.applyToPoint(label.originalAbsoluteCentroid);
                        label.boundingBox = this.getLabelBoundingBox({
                            width: label.boundingBox.width,
                            height: label.boundingBox.height
                        }, label.originalPosition, pixelCentroid, label.originalPixelOffset), void 0 !== label.leaderLinePoints && (label.leaderLinePoints = this.setLeaderLinePoints(stemSourcePoint, this.calculateStemDestination(label.boundingBox, label.originalPosition)));
                    }
                }
            }, FilledMapLabelLayout.prototype.getAbsoluteRectangle = function(inverseTransorm, rect) {
                return inverseTransorm.applyToRect(rect);
            }, FilledMapLabelLayout;
        }();
        powerbi.FilledMapLabelLayout = FilledMapLabelLayout;
        var LabelPolygonArrangeGrid = function() {
            function LabelPolygonArrangeGrid(polygons, viewport) {
                this.viewport = viewport;
                for (var maxPolygonWidth = 0, maxPolygonHeight = 0, _i = 0, polygons_1 = polygons; _i < polygons_1.length; _i++) {
                    var polygon = polygons_1[_i], polygonSize = polygon.pixelBoundingRect;
                    polygonSize.width > maxPolygonWidth && (maxPolygonWidth = polygonSize.width), polygonSize.height > maxPolygonHeight && (maxPolygonHeight = polygonSize.height);
                }
                0 === maxPolygonWidth && (maxPolygonWidth = viewport.width), 0 === maxPolygonHeight && (maxPolygonHeight = viewport.height);
                var cellSize = this.cellSize = {
                    width: maxPolygonWidth * LabelPolygonArrangeGrid.cellSizeMultiplier,
                    height: maxPolygonHeight * LabelPolygonArrangeGrid.cellSizeMultiplier
                };
                this.columnCount = LabelPolygonArrangeGrid.getCellCount(cellSize.width, viewport.width, 1, 100), 
                this.rowCount = LabelPolygonArrangeGrid.getCellCount(cellSize.height, viewport.height, 1, 100);
                for (var grid = [], i = 0, ilen = this.columnCount; ilen > i; i++) {
                    grid[i] = [];
                    for (var j = 0, jlen = this.rowCount; jlen > j; j++) grid[i][j] = [];
                }
                this.grid = grid;
                for (var _a = 0, polygons_2 = polygons; _a < polygons_2.length; _a++) {
                    var polygon = polygons_2[_a];
                    this.add(polygon);
                }
            }
            return LabelPolygonArrangeGrid.prototype.hasConflict = function(absolutLabelRect, pixelLabelRect) {
                for (var containingIndexRect = this.getContainingGridSubsection(pixelLabelRect), grid = this.grid, x = containingIndexRect.xMin; x < containingIndexRect.xMax; x++) for (var y = containingIndexRect.yMin; y < containingIndexRect.yMax; y++) for (var _i = 0, _a = grid[x][y]; _i < _a.length; _i++) {
                    var currentPolygon = _a[_i];
                    if (currentPolygon.conflicts(absolutLabelRect)) return !0;
                }
                return !1;
            }, LabelPolygonArrangeGrid.prototype.add = function(polygon) {
                for (var containingIndexRect = this.getContainingGridSubsection(polygon.pixelBoundingRect), x = containingIndexRect.xMin; x < containingIndexRect.xMax; x++) for (var y = containingIndexRect.yMin; y < containingIndexRect.yMax; y++) this.grid[x][y].push(polygon);
            }, LabelPolygonArrangeGrid.prototype.getContainingGridSubsection = function(rect) {
                return {
                    xMin: LabelPolygonArrangeGrid.bound(Math.floor(rect.left / this.cellSize.width), 0, this.columnCount),
                    xMax: LabelPolygonArrangeGrid.bound(Math.ceil((rect.left + rect.width) / this.cellSize.width), 0, this.columnCount),
                    yMin: LabelPolygonArrangeGrid.bound(Math.floor(rect.top / this.cellSize.height), 0, this.rowCount),
                    yMax: LabelPolygonArrangeGrid.bound(Math.ceil((rect.top + rect.height) / this.cellSize.height), 0, this.rowCount)
                };
            }, LabelPolygonArrangeGrid.getCellCount = function(step, length, minCount, maxCount) {
                return LabelPolygonArrangeGrid.bound(Math.ceil(length / step), minCount, maxCount);
            }, LabelPolygonArrangeGrid.bound = function(value, min, max) {
                return Math.max(Math.min(value, max), min);
            }, LabelPolygonArrangeGrid.cellSizeMultiplier = 2, LabelPolygonArrangeGrid;
        }();
        powerbi.LabelPolygonArrangeGrid = LabelPolygonArrangeGrid;
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            function createColorAllocatorFactory() {
                return new ColorAllocatorFactory();
            }
            visuals.createColorAllocatorFactory = createColorAllocatorFactory;
            var ColorAllocatorFactory = function() {
                function ColorAllocatorFactory() {}
                return ColorAllocatorFactory.prototype.linearGradient2 = function(options) {
                    return new LinearGradient2Allocator(options);
                }, ColorAllocatorFactory.prototype.linearGradient3 = function(options, splitScales) {
                    return splitScales ? new LinearGradient3AllocatorWithSplittedScales(options) : new LinearGradient3Allocator(options);
                }, ColorAllocatorFactory;
            }(), LinearGradient2Allocator = function() {
                function LinearGradient2Allocator(options) {
                    this.options = options;
                    var min = options.min, max = options.max;
                    this.scale = d3.scale.linear().domain([ min.value, max.value ]).range([ min.color, max.color ]).clamp(!0);
                }
                return LinearGradient2Allocator.prototype.color = function(value) {
                    var min = this.options.min, max = this.options.max;
                    return min.value === max.value ? value >= max.value ? max.color : min.color : this.scale(value);
                }, LinearGradient2Allocator;
            }(), LinearGradient3Allocator = function() {
                function LinearGradient3Allocator(options) {
                    this.options = options;
                    var min = options.min, mid = options.mid, max = options.max;
                    this.scale = d3.scale.linear().domain([ min.value, mid.value, max.value ]).range([ min.color, mid.color, max.color ]).clamp(!0);
                }
                return LinearGradient3Allocator.prototype.color = function(value) {
                    var min = this.options.min, mid = this.options.mid, max = this.options.max;
                    return max.value === mid.value || mid.value === min.value || max.value === mid.value && max.value === min.value ? value >= max.value ? max.color : value >= mid.value ? mid.color : min.color : this.scale(value);
                }, LinearGradient3Allocator;
            }(), LinearGradient3AllocatorWithSplittedScales = function() {
                function LinearGradient3AllocatorWithSplittedScales(options) {
                    this.options = options;
                    var min = options.min, mid = options.mid, max = options.max;
                    this.scale1 = d3.scale.linear().domain([ min.value, mid.value ]).range([ min.color, mid.color ]).clamp(!0), 
                    this.scale2 = d3.scale.linear().domain([ mid.value, max.value ]).range([ mid.color, max.color ]).clamp(!0);
                }
                return LinearGradient3AllocatorWithSplittedScales.prototype.color = function(value) {
                    var min = this.options.min, mid = this.options.mid, max = this.options.max;
                    return max.value === mid.value || mid.value === min.value || max.value === mid.value && max.value === min.value ? value >= max.value ? max.color : value >= mid.value ? mid.color : min.color : value <= mid.value ? this.scale1(value) : this.scale2(value);
                }, LinearGradient3AllocatorWithSplittedScales;
            }();
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var BeautifiedFormat = {
                "0.00 %;-0.00 %;0.00 %": "Percentage",
                "0.0 %;-0.0 %;0.0 %": "Percentage1"
            }, defaultLocalizedStrings = {
                NullValue: "(Blank)",
                BooleanTrue: "True",
                BooleanFalse: "False",
                NaNValue: "NaN",
                InfinityValue: "+Infinity",
                NegativeInfinityValue: "-Infinity",
                Restatement_Comma: "{0}, {1}",
                Restatement_CompoundAnd: "{0} and {1}",
                DisplayUnitSystem_EAuto_Title: "Auto",
                DisplayUnitSystem_E0_Title: "None",
                DisplayUnitSystem_E3_LabelFormat: "{0}K",
                DisplayUnitSystem_E3_Title: "Thousands",
                DisplayUnitSystem_E6_LabelFormat: "{0}M",
                DisplayUnitSystem_E6_Title: "Millions",
                DisplayUnitSystem_E9_LabelFormat: "{0}bn",
                DisplayUnitSystem_E9_Title: "Billions",
                DisplayUnitSystem_E12_LabelFormat: "{0}T",
                DisplayUnitSystem_E12_Title: "Trillions",
                Percentage: "#,0.##%",
                Percentage1: "#,0.#%",
                RichTextbox_Link_DefaultText: "Link",
                TableTotalLabel: "Total",
                ListJoin_Separator: ", ",
                Tooltip_HighlightedValueDisplayName: "Highlighted",
                Funnel_PercentOfFirst: "Percent of first",
                Funnel_PercentOfPrevious: "Percent of previous",
                Funnel_PercentOfFirst_Highlight: "Percent of first (highlighted)",
                Funnel_PercentOfPrevious_Highlight: "Percent of previous (highlighted)",
                GeotaggingString_Continent: "continent",
                GeotaggingString_Continents: "continents",
                GeotaggingString_Country: "country",
                GeotaggingString_Countries: "countries",
                GeotaggingString_State: "state",
                GeotaggingString_States: "states",
                GeotaggingString_City: "city",
                GeotaggingString_Cities: "cities",
                GeotaggingString_Town: "town",
                GeotaggingString_Towns: "towns",
                GeotaggingString_Province: "province",
                GeotaggingString_Provinces: "provinces",
                GeotaggingString_County: "county",
                GeotaggingString_Counties: "counties",
                GeotaggingString_Village: "village",
                GeotaggingString_Villages: "villages",
                GeotaggingString_Post: "post",
                GeotaggingString_Zip: "zip",
                GeotaggingString_Code: "code",
                GeotaggingString_Place: "place",
                GeotaggingString_Places: "places",
                GeotaggingString_Address: "address",
                GeotaggingString_Addresses: "addresses",
                GeotaggingString_Street: "street",
                GeotaggingString_Streets: "streets",
                GeotaggingString_Longitude: "longitude",
                GeotaggingString_Longitude_Short: "lon",
                GeotaggingString_Longitude_Short2: "long",
                GeotaggingString_Latitude: "latitude",
                GeotaggingString_Latitude_Short: "lat",
                GeotaggingString_PostalCode: "postal code",
                GeotaggingString_PostalCodes: "postal codes",
                GeotaggingString_ZipCode: "zip code",
                GeotaggingString_ZipCodes: "zip codes",
                GeotaggingString_Territory: "territory",
                GeotaggingString_Territories: "territories",
                Waterfall_IncreaseLabel: "Increase",
                Waterfall_DecreaseLabel: "Decrease",
                Waterfall_TotalLabel: "Total",
                Slicer_SelectAll: "Select All"
            }, DefaultVisualHostServices = function() {
                function DefaultVisualHostServices() {}
                return DefaultVisualHostServices.initialize = function() {
                    visuals.valueFormatter.setLocaleOptions(DefaultVisualHostServices.createLocaleOptions()), 
                    visuals.TooltipManager.setLocalizedStrings(DefaultVisualHostServices.createTooltipLocaleOptions());
                }, DefaultVisualHostServices.createLocaleOptions = function() {
                    return {
                        "null": defaultLocalizedStrings.NullValue,
                        "true": defaultLocalizedStrings.BooleanTrue,
                        "false": defaultLocalizedStrings.BooleanFalse,
                        NaN: defaultLocalizedStrings.NaNValue,
                        infinity: defaultLocalizedStrings.InfinityValue,
                        negativeInfinity: defaultLocalizedStrings.NegativeInfinityValue,
                        beautify: function(format) {
                            return DefaultVisualHostServices.beautify(format);
                        },
                        describe: function(exponent) {
                            return DefaultVisualHostServices.describeUnit(exponent);
                        },
                        restatementComma: defaultLocalizedStrings.Restatement_Comma,
                        restatementCompoundAnd: defaultLocalizedStrings.Restatement_CompoundAnd,
                        restatementCompoundOr: defaultLocalizedStrings.Restatement_CompoundOr
                    };
                }, DefaultVisualHostServices.createTooltipLocaleOptions = function() {
                    return {
                        highlightedValueDisplayName: defaultLocalizedStrings.Tooltip_HighlightedValueDisplayName
                    };
                }, DefaultVisualHostServices.prototype.getLocalizedString = function(stringId) {
                    return defaultLocalizedStrings[stringId];
                }, DefaultVisualHostServices.prototype.onDragStart = function() {}, DefaultVisualHostServices.prototype.canSelect = function() {
                    return !1;
                }, DefaultVisualHostServices.prototype.onSelecting = function(args) {
                    args.action = 0;
                }, DefaultVisualHostServices.prototype.onSelect = function() {}, DefaultVisualHostServices.prototype.onContextMenu = function() {}, 
                DefaultVisualHostServices.prototype.loadMoreData = function() {}, DefaultVisualHostServices.prototype.persistProperties = function(changes) {}, 
                DefaultVisualHostServices.prototype.onCustomSort = function(args) {}, DefaultVisualHostServices.prototype.getViewMode = function() {
                    return 0;
                }, DefaultVisualHostServices.prototype.setWarnings = function(warnings) {}, DefaultVisualHostServices.prototype.setToolbar = function($toolbar) {}, 
                DefaultVisualHostServices.prototype.shouldRetainSelection = function() {
                    return !1;
                }, DefaultVisualHostServices.prototype.geocoder = function() {
                    return visuals.services.createGeocoder();
                }, DefaultVisualHostServices.prototype.geolocation = function() {
                    return visuals.services.createGeolocation();
                }, DefaultVisualHostServices.prototype.promiseFactory = function() {
                    return powerbi.createJQueryPromiseFactory();
                }, DefaultVisualHostServices.prototype.visualCapabilitiesChanged = function() {}, 
                DefaultVisualHostServices.prototype.analyzeFilter = function(options) {
                    return {
                        isNotFilter: !1,
                        selectedIdentities: [],
                        filter: void 0,
                        defaultValue: void 0
                    };
                }, DefaultVisualHostServices.prototype.getIdentityDisplayNames = function(dentities) {}, 
                DefaultVisualHostServices.prototype.setIdentityDisplayNames = function(displayNamesIdentityPairs) {}, 
                DefaultVisualHostServices.beautify = function(format) {
                    var key = BeautifiedFormat[format];
                    return key ? defaultLocalizedStrings[key] || format : format;
                }, DefaultVisualHostServices.describeUnit = function(exponent) {
                    var exponentLookup = -1 === exponent ? "Auto" : exponent.toString(), title = defaultLocalizedStrings["DisplayUnitSystem_E" + exponentLookup + "_Title"], format = 0 >= exponent ? "{0}" : defaultLocalizedStrings["DisplayUnitSystem_E" + exponentLookup + "_LabelFormat"];
                    return title || format ? {
                        title: title,
                        format: format
                    } : void 0;
                }, DefaultVisualHostServices;
            }();
            visuals.DefaultVisualHostServices = DefaultVisualHostServices, visuals.defaultVisualHostServices = new DefaultVisualHostServices();
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            function createInteractivityService(hostServices) {
                return new InteractivityService(hostServices);
            }
            function appendClearCatcher(selection) {
                return selection.append("rect").classed("clearCatcher", !0).attr({
                    width: "100%",
                    height: "100%"
                });
            }
            function isCategoryColumnSelected(propertyId, categories, idx) {
                return null != categories.objects && categories.objects[idx] && powerbi.DataViewObjects.getValue(categories.objects[idx], propertyId);
            }
            function dataHasSelection(data) {
                for (var i = 0, ilen = data.length; ilen > i; i++) if (data[i].selected) return !0;
                return !1;
            }
            var ArrayExtensions = jsCommon.ArrayExtensions, SemanticFilter = powerbi.data.SemanticFilter;
            visuals.createInteractivityService = createInteractivityService, visuals.appendClearCatcher = appendClearCatcher, 
            visuals.isCategoryColumnSelected = isCategoryColumnSelected, visuals.dataHasSelection = dataHasSelection;
            var InteractivityService = function() {
                function InteractivityService(hostServices) {
                    this.renderSelectionInVisual = _.noop, this.renderSelectionInLegend = _.noop, this.renderSelectionInLabels = _.noop, 
                    this.selectedIds = [], this.isInvertedSelectionMode = !1, this.dataPointObjectName = "dataPoint", 
                    this.hostService = hostServices;
                }
                return InteractivityService.prototype.bind = function(dataPoints, behavior, behaviorOptions, options) {
                    var _this = this;
                    options && options.overrideSelectionFromData && this.takeSelectionStateFromDataPoints(dataPoints), 
                    options ? (options.isLegend ? (this.selectableLegendDataPoints = dataPoints, this.renderSelectionInLegend = function() {
                        return behavior.renderSelection(_this.legendHasSelection());
                    }) : options.isLabels ? (this.selectableLabelsDataPoints = dataPoints, this.renderSelectionInLabels = function() {
                        return behavior.renderSelection(_this.labelsHasSelection());
                    }) : (this.selectableDataPoints = dataPoints, this.renderSelectionInVisual = function() {
                        return behavior.renderSelection(_this.hasSelection());
                    }), null != options.hasSelectionOverride && (this.hasSelectionOverride = options.hasSelectionOverride), 
                    options.slicerValueHandler && (this.slicerValueHandler = options.slicerValueHandler)) : (this.selectableDataPoints = dataPoints, 
                    this.renderSelectionInVisual = function() {
                        return behavior.renderSelection(_this.hasSelection());
                    }), this.behavior = behavior, behavior.bindEvents(behaviorOptions, this), this.syncSelectionState();
                }, InteractivityService.prototype.clearSelection = function() {
                    return this.slicerValueHandler && this.slicerValueHandler.getDefaultValue() && this.useDefaultValue ? void (this.isInvertedSelectionMode = !1) : (this.hasSelectionOverride = void 0, 
                    ArrayExtensions.clear(this.selectedIds), this.isInvertedSelectionMode = !1, this.applyToAllSelectableDataPoints(function(dataPoint) {
                        return dataPoint.selected = !1;
                    }), void this.renderAll());
                }, InteractivityService.prototype.applySelectionStateToData = function(dataPoints) {
                    for (var _i = 0, dataPoints_1 = dataPoints; _i < dataPoints_1.length; _i++) {
                        var dataPoint = dataPoints_1[_i];
                        dataPoint.selected = InteractivityService.checkDatapointAgainstSelectedIds(dataPoint, this.selectedIds);
                    }
                    return this.hasSelection();
                }, InteractivityService.prototype.hasSelection = function() {
                    return this.selectedIds.length > 0;
                }, InteractivityService.prototype.legendHasSelection = function() {
                    return this.selectableLegendDataPoints ? dataHasSelection(this.selectableLegendDataPoints) : !1;
                }, InteractivityService.prototype.labelsHasSelection = function() {
                    return this.selectableLabelsDataPoints ? dataHasSelection(this.selectableLabelsDataPoints) : !1;
                }, InteractivityService.prototype.isSelectionModeInverted = function() {
                    return this.isInvertedSelectionMode;
                }, InteractivityService.prototype.setSelectionModeInverted = function(inverted) {
                    this.isInvertedSelectionMode = inverted;
                }, InteractivityService.prototype.handleSelection = function(dataPoint, multiSelect) {
                    if (dataPoint) {
                        var selectingSelectorsByColumn;
                        dataPoint.specificIdentity ? selectingSelectorsByColumn = dataPoint.specificIdentity.getSelectorsByColumn() : dataPoint.identity && (selectingSelectorsByColumn = dataPoint.identity.getSelectorsByColumn());
                        var selectingArgs = {
                            visualObjects: [ {
                                objectName: this.dataPointObjectName,
                                selectorsByColumn: selectingSelectorsByColumn
                            } ]
                        };
                        this.hostService.onSelecting(selectingArgs), 0 !== selectingArgs.action && null != selectingArgs.action || (dataPoint.identity ? (this.useDefaultValue = !1, 
                        this.select(dataPoint, multiSelect), this.sendSelectionToHost(), this.renderAll()) : this.handleClearSelection());
                    }
                }, InteractivityService.prototype.handleContextMenu = function(dataPoint, point) {
                    this.sendContextMenuToHost(dataPoint, point);
                }, InteractivityService.prototype.handleClearSelection = function() {
                    this.useDefaultValue = !0, this.clearSelection(), this.sendSelectionToHost();
                }, InteractivityService.prototype.toggleSelectionModeInversion = function() {
                    return this.useDefaultValue = !1, this.isInvertedSelectionMode = !this.isInvertedSelectionMode, 
                    ArrayExtensions.clear(this.selectedIds), this.applyToAllSelectableDataPoints(function(dataPoint) {
                        return dataPoint.selected = !1;
                    }), this.sendSelectionToHost(), this.isInvertedSelectionMode ? this.syncSelectionStateInverted() : this.syncSelectionState(), 
                    this.renderAll(), this.isInvertedSelectionMode;
                }, InteractivityService.prototype.persistSelectionFilter = function(filterPropertyIdentifier) {
                    this.hostService.persistProperties(InteractivityService.createChangeForFilterProperty(filterPropertyIdentifier, this.getFilterFromSelectors()));
                }, InteractivityService.prototype.persistSelfFilter = function(filterPropertyIdentifier, selfFilter) {
                    this.hostService.persistProperties(InteractivityService.createChangeForFilterProperty(filterPropertyIdentifier, selfFilter));
                }, InteractivityService.prototype.setDefaultValueMode = function(useDefaultValue) {
                    this.useDefaultValue = useDefaultValue;
                }, InteractivityService.prototype.isDefaultValueEnabled = function() {
                    return this.useDefaultValue;
                }, InteractivityService.prototype.renderAll = function() {
                    this.renderSelectionInVisual(), this.renderSelectionInLegend(), this.renderSelectionInLabels();
                }, InteractivityService.prototype.select = function(d, multiSelect) {
                    if (this.isInvertedSelectionMode) return this.selectInverted(d, multiSelect);
                    d.identity && d.identity.highlight && (d = _.find(this.selectableDataPoints, function(dp) {
                        return !dp.identity.highlight && d.identity.includes(dp.identity, !0);
                    }));
                    var id = d.identity;
                    if (id) {
                        var selected = !d.selected || !multiSelect && this.selectedIds.length > 1;
                        multiSelect && (selected ? (d.selected = !0, this.selectedIds.push(id), id.hasIdentity() ? this.removeSelectionIdsWithOnlyMeasures() : this.removeSelectionIdsExceptOnlyMeasures()) : (d.selected = !1, 
                        this.removeId(id))), multiSelect && this.hostService.canSelect(this.createSelectEventArgs(this.selectedIds)) || (this.clearSelection(), 
                        selected && (d.selected = !0, this.selectedIds.push(id))), this.syncSelectionState();
                    }
                }, InteractivityService.prototype.selectInverted = function(d, multiSelect) {
                    var wasSelected = d.selected, id = d.identity;
                    d.selected = !wasSelected, wasSelected ? this.removeId(id) : (this.selectedIds.push(id), 
                    id.hasIdentity() ? this.removeSelectionIdsWithOnlyMeasures() : this.removeSelectionIdsExceptOnlyMeasures()), 
                    this.syncSelectionStateInverted();
                }, InteractivityService.prototype.removeId = function(toRemove) {
                    for (var selectedIds = this.selectedIds, i = selectedIds.length - 1; i > -1; i--) {
                        var currentId = selectedIds[i];
                        toRemove.includes(currentId) && selectedIds.splice(i, 1);
                    }
                }, InteractivityService.prototype.getFilterFromSelectors = function() {
                    var selectors = [];
                    this.selectedIds.length > 0 && (selectors = _.chain(this.selectedIds).filter(function(value) {
                        return value.hasIdentity();
                    }).map(function(value) {
                        return value.getSelector();
                    }).value());
                    var filter = powerbi.data.Selector.filterFromSelector(selectors, this.isInvertedSelectionMode);
                    return this.slicerValueHandler && this.slicerValueHandler.getDefaultValue() && (this.useDefaultValue === !0 ? filter = SemanticFilter.getDefaultValueFilter(this.slicerValueHandler.getIdentityFields()) : _.isEmpty(selectors) && (filter = SemanticFilter.getAnyValueFilter(this.slicerValueHandler.getIdentityFields()))), 
                    filter;
                }, InteractivityService.createChangeForFilterProperty = function(filterPropertyIdentifier, filter) {
                    var properties = {}, instance = {
                        objectName: filterPropertyIdentifier.objectName,
                        selector: void 0,
                        properties: properties
                    };
                    return null == filter ? (properties[filterPropertyIdentifier.propertyName] = {}, 
                    {
                        remove: [ instance ]
                    }) : (properties[filterPropertyIdentifier.propertyName] = filter, {
                        merge: [ instance ]
                    });
                }, InteractivityService.prototype.sendContextMenuToHost = function(dataPoint, position) {
                    var host = this.hostService;
                    if (host.onContextMenu) {
                        var selectors = this.getSelectorsByColumn([ dataPoint.identity ]);
                        if (!_.isEmpty(selectors)) {
                            var args = {
                                data: selectors,
                                position: position
                            };
                            host.onContextMenu(args);
                        }
                    }
                }, InteractivityService.prototype.sendSelectionToHost = function() {
                    var host = this.hostService;
                    if (host.onSelect) {
                        var selectArgs = this.createSelectEventArgs(this.selectedIds);
                        host.onSelect(selectArgs);
                    }
                }, InteractivityService.prototype.createSelectEventArgs = function(selectedIds) {
                    var shouldInsertSelectors = !1, dataPointObjectName = this.dataPointObjectName;
                    _.isEmpty(selectedIds) || (shouldInsertSelectors = selectedIds[0].getSelector() && !selectedIds[0].getSelectorsByColumn());
                    var selectedIdsWithIdentities = _.chain(selectedIds).filter(function(value) {
                        return value.hasIdentity();
                    }), selectEventArgs = {
                        visualObjects: selectedIdsWithIdentities.map(function(value) {
                            return {
                                objectName: dataPointObjectName,
                                selectorsByColumn: value.getSelectorsByColumn()
                            };
                        }).value()
                    };
                    return shouldInsertSelectors && (selectEventArgs.selectors = selectedIdsWithIdentities.map(function(value) {
                        return value.getSelector();
                    }).value()), selectEventArgs;
                }, InteractivityService.prototype.getSelectorsByColumn = function(selectionIds) {
                    return _(selectionIds).filter(function(value) {
                        return value.hasIdentity;
                    }).map(function(value) {
                        return value.getSelectorsByColumn();
                    }).compact().value();
                }, InteractivityService.prototype.takeSelectionStateFromDataPoints = function(dataPoints) {
                    var selectedIds = this.selectedIds;
                    ArrayExtensions.clear(selectedIds);
                    for (var _i = 0, dataPoints_2 = dataPoints; _i < dataPoints_2.length; _i++) {
                        var dataPoint = dataPoints_2[_i];
                        dataPoint.selected && selectedIds.push(dataPoint.identity);
                    }
                }, InteractivityService.prototype.syncSelectionState = function() {
                    if (this.isInvertedSelectionMode) return this.syncSelectionStateInverted();
                    var selectedIds = this.selectedIds, selectableDataPoints = this.selectableDataPoints, selectableLegendDataPoints = this.selectableLegendDataPoints, selectableLabelsDataPoints = this.selectableLabelsDataPoints, foundMatchingId = !1;
                    if (selectableDataPoints || selectableLegendDataPoints) {
                        if (selectableDataPoints && InteractivityService.updateSelectableDataPointsBySelectedIds(selectableDataPoints, selectedIds) && (foundMatchingId = !0), 
                        selectableLegendDataPoints && InteractivityService.updateSelectableDataPointsBySelectedIds(selectableLegendDataPoints, selectedIds) && (foundMatchingId = !0), 
                        selectableLabelsDataPoints) for (var labelsDataPoint_1, i = 0, ilen = selectableLabelsDataPoints.length; ilen > i; i++) labelsDataPoint_1 = selectableLabelsDataPoints[i], 
                        selectedIds.some(function(value) {
                            return value.includes(labelsDataPoint_1.identity);
                        }) ? labelsDataPoint_1.selected = !0 : labelsDataPoint_1.selected = !1;
                        !foundMatchingId && selectedIds.length > 0 && (this.clearSelection(), this.sendSelectionToHost());
                    }
                }, InteractivityService.prototype.syncSelectionStateInverted = function() {
                    var selectedIds = this.selectedIds, selectableDataPoints = this.selectableDataPoints;
                    if (selectableDataPoints) if (0 === selectedIds.length) for (var _i = 0, selectableDataPoints_1 = selectableDataPoints; _i < selectableDataPoints_1.length; _i++) {
                        var dataPoint_1 = selectableDataPoints_1[_i];
                        dataPoint_1.selected = !1;
                    } else for (var _a = 0, selectableDataPoints_2 = selectableDataPoints; _a < selectableDataPoints_2.length; _a++) {
                        var dataPoint = selectableDataPoints_2[_a];
                        selectedIds.some(function(value) {
                            return value.includes(dataPoint.identity);
                        }) ? dataPoint.selected = !0 : dataPoint.selected && (dataPoint.selected = !1);
                    }
                }, InteractivityService.prototype.applyToAllSelectableDataPoints = function(action) {
                    var selectableDataPoints = this.selectableDataPoints, selectableLegendDataPoints = this.selectableLegendDataPoints, selectableLabelsDataPoints = this.selectableLabelsDataPoints;
                    if (selectableDataPoints) for (var _i = 0, selectableDataPoints_3 = selectableDataPoints; _i < selectableDataPoints_3.length; _i++) {
                        var dataPoint = selectableDataPoints_3[_i];
                        action(dataPoint);
                    }
                    if (selectableLegendDataPoints) for (var _a = 0, selectableLegendDataPoints_1 = selectableLegendDataPoints; _a < selectableLegendDataPoints_1.length; _a++) {
                        var dataPoint = selectableLegendDataPoints_1[_a];
                        action(dataPoint);
                    }
                    if (selectableLabelsDataPoints) for (var _b = 0, selectableLabelsDataPoints_1 = selectableLabelsDataPoints; _b < selectableLabelsDataPoints_1.length; _b++) {
                        var dataPoint = selectableLabelsDataPoints_1[_b];
                        action(dataPoint);
                    }
                }, InteractivityService.updateSelectableDataPointsBySelectedIds = function(selectableDataPoints, selectedIds) {
                    for (var foundMatchingId = !1, _i = 0, selectableDataPoints_4 = selectableDataPoints; _i < selectableDataPoints_4.length; _i++) {
                        var datapoint = selectableDataPoints_4[_i];
                        datapoint.selected = InteractivityService.checkDatapointAgainstSelectedIds(datapoint, selectedIds), 
                        datapoint.selected && (foundMatchingId = !0);
                    }
                    return foundMatchingId;
                }, InteractivityService.checkDatapointAgainstSelectedIds = function(datapoint, selectedIds) {
                    return selectedIds.some(function(value) {
                        return value.includes(datapoint.identity);
                    });
                }, InteractivityService.prototype.removeSelectionIdsWithOnlyMeasures = function() {
                    this.selectedIds = _.filter(this.selectedIds, function(identity) {
                        return identity.hasIdentity();
                    });
                }, InteractivityService.prototype.removeSelectionIdsExceptOnlyMeasures = function() {
                    this.selectedIds = _.filter(this.selectedIds, function(identity) {
                        return !identity.hasIdentity();
                    });
                }, InteractivityService;
            }();
            visuals.InteractivityService = InteractivityService;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi), __extends = (window.powerbitests, 
    window.InJs, window.debug, window.jasmine, window.Microsoft, this && this.__extends || function(d, b) {
        function __() {
            this.constructor = d;
        }
        for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
    });
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var services;
            !function(services) {
                function createGeocoder() {
                    return {
                        geocode: geocode,
                        geocodeBoundary: geocodeBoundary,
                        geocodePoint: geocodePoint,
                        tryGeocodeImmediate: tryGeocodeImmediate,
                        tryGeocodeBoundaryImmediate: tryGeocodeBoundaryImmediate
                    };
                }
                function isCategoryType(value) {
                    return services.CategoryTypeArray.indexOf(value) > -1;
                }
                function mapLocalesForBing(locale) {
                    switch (locale.toLowerCase()) {
                      case "fr":
                        return "fr-FR";

                      default:
                        return locale;
                    }
                }
                function tryGeocodeImmediate(query, category) {
                    var result = geocodingCache ? geocodingCache.getCoordinates(new GeocodeQuery(query, category).key) : void 0;
                    return result;
                }
                function tryGeocodeBoundaryImmediate(latitude, longitude, category, levelOfDetail, maxGeoData) {
                    void 0 === maxGeoData && (maxGeoData = 3);
                    var result = geocodingCache ? geocodingCache.getCoordinates(new GeocodeBoundaryQuery(latitude, longitude, category, levelOfDetail, maxGeoData).key) : void 0;
                    return result;
                }
                function geocodeCore(geocodeQuery, options) {
                    var result = geocodingCache ? geocodingCache.getCoordinates(geocodeQuery.key) : void 0, deferred = $.Deferred();
                    if (result) deferred.resolve(result); else {
                        var item_1 = {
                            query: geocodeQuery,
                            deferred: deferred,
                            isResolved: !1
                        };
                        options && options.timeout && options.timeout["finally"](function() {
                            item_1.isResolved || (item_1.deferred.reject(), item_1.isResolved = !0);
                        }), geocodeQueue.push(item_1), dequeue();
                    }
                    return deferred;
                }
                function geocode(query, category, options) {
                    return void 0 === category && (category = ""), geocodeCore(new GeocodeQuery(query, category), options);
                }
                function geocodeBoundary(latitude, longitude, category, levelOfDetail, maxGeoData, options) {
                    return void 0 === category && (category = ""), void 0 === levelOfDetail && (levelOfDetail = 2), 
                    void 0 === maxGeoData && (maxGeoData = 3), geocodeCore(new GeocodeBoundaryQuery(latitude, longitude, category, levelOfDetail, maxGeoData), options);
                }
                function geocodePoint(latitude, longitude, entities, options) {
                    return geocodeCore(new GeocodePointQuery(latitude, longitude, entities), options);
                }
                function dequeue(decrement) {
                    for (void 0 === decrement && (decrement = 0), activeRequests -= decrement; activeRequests < Settings.MaxBingRequest && 0 !== geocodeQueue.length; ) activeRequests++, 
                    makeRequest(geocodeQueue.shift());
                }
                function makeRequest(item) {
                    if (!item.isResolved) {
                        var result = geocodingCache ? geocodingCache.getCoordinates(item.query.key) : void 0;
                        result && (item.deferred.resolve(result), item.isResolved = !0);
                    }
                    if (item.isResolved) return void setTimeout(function() {
                        return dequeue(1);
                    });
                    var config = {
                        type: "GET",
                        dataType: "jsonp",
                        jsonp: "jsonp"
                    }, url = item.query.getUrl();
                    url || completeRequest(item, new Error("Unsupported query. " + item.query.query)), 
                    services.BingAjaxCall(url, config).then(function(data) {
                        try {
                            if (item.query instanceof GeocodeBoundaryQuery) {
                                var result = data;
                                if (result && result.d && Array.isArray(result.d.results) && result.d.results.length > 0) {
                                    var entity = result.d.results[0], primitives = entity.Primitives;
                                    if (primitives && primitives.length > 0) {
                                        var coordinates = {
                                            latitude: item.query.latitude,
                                            longitude: item.query.longitude,
                                            locations: []
                                        };
                                        primitives.sort(function(a, b) {
                                            return a.Shape.length < b.Shape.length ? 1 : a.Shape.length > b.Shape.length ? -1 : 0;
                                        });
                                        for (var maxGeoData = Math.min(primitives.length, item.query.maxGeoData), i = 0; maxGeoData > i; i++) for (var ringStr = primitives[i].Shape, ringArray = ringStr.split(","), j = 1; j < ringArray.length; j++) coordinates.locations.push({
                                            nativeBing: ringArray[j]
                                        });
                                        completeRequest(item, null, coordinates);
                                    } else completeRequest(item, new Error("Geocode result is empty."));
                                } else completeRequest(item, new Error("Geocode result is empty."));
                            } else if (item.query instanceof GeocodePointQuery) {
                                var resources = data.resourceSets[0].resources;
                                if (Array.isArray(resources) && resources.length > 0) {
                                    var index = getBestResultIndex(resources, item.query), pointData = resources[index].point.coordinates, addressData = resources[index].address, name_1 = resources[index].name, coordinates = {
                                        latitude: parseFloat(pointData[0]),
                                        longitude: parseFloat(pointData[1]),
                                        addressLine: addressData.addressLine,
                                        locality: addressData.locality,
                                        neighborhood: addressData.neighborhood,
                                        adminDistrict: addressData.adminDistrict,
                                        adminDistrict2: addressData.adminDistrict2,
                                        formattedAddress: addressData.formattedAddress,
                                        postalCode: addressData.postalCode,
                                        countryRegionIso2: addressData.countryRegionIso2,
                                        countryRegion: addressData.countryRegion,
                                        landmark: addressData.landmark,
                                        name: name_1
                                    };
                                    completeRequest(item, null, coordinates);
                                } else completeRequest(item, null, null);
                            } else {
                                var resources = data.resourceSets[0].resources;
                                if (Array.isArray(resources) && resources.length > 0) {
                                    var index = getBestResultIndex(resources, item.query), pointData = resources[index].point.coordinates, coordinates = {
                                        latitude: parseFloat(pointData[0]),
                                        longitude: parseFloat(pointData[1])
                                    };
                                    completeRequest(item, null, coordinates);
                                } else completeRequest(item, new Error("Geocode result is empty."));
                            }
                        } catch (error) {
                            completeRequest(item, error);
                        }
                    }, function(error) {
                        completeRequest(item, error);
                    });
                }
                function completeRequest(item, error, coordinate) {
                    void 0 === coordinate && (coordinate = null), item.isResolved || (error ? item.deferred.reject(error) : (!geocodingCache || item.query instanceof GeocodePointQuery || geocodingCache.registerCoordinates(item.query.key, coordinate), 
                    item.deferred.resolve(coordinate)), item.isResolved = !0), dequeueTimeoutId = setTimeout(function() {
                        return dequeue(1);
                    }, Settings.UseDoubleArrayGeodataResult ? Settings.UseDoubleArrayDequeueTimeout : 0);
                }
                function getBestResultIndex(resources, query) {
                    var queryString = query.query.toLowerCase();
                    if (2 === queryString.length && query.category === CategoryTypes.CountryRegion) for (var index = 0; index < resources.length; index++) {
                        var iso2 = resources[index].address && resources[index].address.countryRegionIso2;
                        if (iso2 && queryString === iso2.toLowerCase()) return index;
                    }
                    for (var targetEntity = query.getBingEntity().toLowerCase(), index = 0; index < resources.length; index++) {
                        var resultEntity = (resources[index].entityType || "").toLowerCase();
                        if (resultEntity === targetEntity) return index;
                    }
                    return 0;
                }
                function resetStaticGeocoderState(cache) {
                    void 0 !== cache && (geocodingCache = cache), geocodeQueue = [], activeRequests = 0, 
                    categoryToBingEntity = null, clearTimeout(dequeueTimeoutId);
                }
                var CategoryTypes = visuals.MapUtil.CategoryTypes, Settings = visuals.MapUtil.Settings;
                services.createGeocoder = createGeocoder, services.safeCharacters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-", 
                services.BingAjaxCall = $.ajax, services.CategoryTypeArray = [ "Address", "City", "Continent", "Country", "County", "Longitude", "Latitude", "Place", "PostalCode", "StateOrProvince" ], 
                services.isCategoryType = isCategoryType, services.BingEntities = {
                    Continent: "Continent",
                    Sovereign: "Sovereign",
                    CountryRegion: "CountryRegion",
                    AdminDivision1: "AdminDivision1",
                    AdminDivision2: "AdminDivision2",
                    PopulatedPlace: "PopulatedPlace",
                    Postcode: "Postcode",
                    Postcode1: "Postcode1",
                    Neighborhood: "Neighborhood",
                    Address: "Address"
                };
                var geocodeQueue, activeRequests, categoryToBingEntity, categoryToBingEntityGeodata, geocodingCache, GeocodeQuery = function() {
                    function GeocodeQuery(query, category) {
                        this.query = null != query ? query : "", this.category = null != category ? category : "", 
                        this.key = (this.query + "/" + this.category).toLowerCase(), geocodingCache || (geocodingCache = services.createGeocodingCache(Settings.MaxCacheSize, Settings.MaxCacheSizeOverflow));
                    }
                    return GeocodeQuery.prototype.getBingEntity = function() {
                        var category = this.category.toLowerCase();
                        return categoryToBingEntity || (categoryToBingEntity = {}, categoryToBingEntity[CategoryTypes.Continent.toLowerCase()] = services.BingEntities.Continent, 
                        categoryToBingEntity[CategoryTypes.CountryRegion.toLowerCase()] = services.BingEntities.Sovereign, 
                        categoryToBingEntity[CategoryTypes.StateOrProvince.toLowerCase()] = services.BingEntities.AdminDivision1, 
                        categoryToBingEntity[CategoryTypes.County.toLowerCase()] = services.BingEntities.AdminDivision2, 
                        categoryToBingEntity[CategoryTypes.City.toLowerCase()] = services.BingEntities.PopulatedPlace, 
                        categoryToBingEntity[CategoryTypes.PostalCode.toLowerCase()] = services.BingEntities.Postcode, 
                        categoryToBingEntity[CategoryTypes.Address.toLowerCase()] = services.BingEntities.Address), 
                        categoryToBingEntity[category] || "";
                    }, GeocodeQuery.prototype.getUrl = function() {
                        var url = Settings.BingUrl + "?key=" + Settings.BingKey, entityType = this.getBingEntity(), queryAdded = !1;
                        if (entityType) if (entityType === services.BingEntities.Postcode) url += "&includeEntityTypes=Postcode,Postcode1,Postcode2,Postcode3,Postcode4"; else if (-1 !== this.query.indexOf(",") || entityType !== services.BingEntities.AdminDivision1 && entityType !== services.BingEntities.AdminDivision2) url += "&includeEntityTypes=" + entityType; else {
                            queryAdded = !0;
                            try {
                                url += "&adminDistrict=" + decodeURIComponent(this.query);
                            } catch (e) {
                                return null;
                            }
                        }
                        if (!queryAdded) try {
                            url += "&q=" + decodeURIComponent(this.query);
                        } catch (e) {
                            return null;
                        }
                        var cultureName = navigator.userLanguage || navigator.language;
                        return cultureName = mapLocalesForBing(cultureName), cultureName && (url += "&c=" + cultureName), 
                        url += "&maxRes=20", 2 === this.query.length && this.category === CategoryTypes.CountryRegion && (url += "&include=ciso2"), 
                        url;
                    }, GeocodeQuery;
                }();
                services.GeocodeQuery = GeocodeQuery;
                var GeocodePointQuery = function(_super) {
                    function GeocodePointQuery(latitude, longitude, entities) {
                        _super.call(this, [ latitude, longitude ].join(), "Point"), this.latitude = latitude, 
                        this.longitude = longitude, this.entities = entities;
                    }
                    return __extends(GeocodePointQuery, _super), GeocodePointQuery.prototype.getUrl = function() {
                        var url = Settings.BingUrl + "/" + [ this.latitude, this.longitude ].join() + "?key=" + Settings.BingKey + (_.isEmpty(this.entities) ? "" : "&includeEntityTypes=" + this.entities.join()) + "&include=ciso2";
                        return url;
                    }, GeocodePointQuery;
                }(GeocodeQuery);
                services.GeocodePointQuery = GeocodePointQuery;
                var GeocodeBoundaryQuery = function(_super) {
                    function GeocodeBoundaryQuery(latitude, longitude, category, levelOfDetail, maxGeoData) {
                        void 0 === maxGeoData && (maxGeoData = 3), _super.call(this, [ latitude, longitude, levelOfDetail, maxGeoData ].join(","), category), 
                        this.latitude = latitude, this.longitude = longitude, this.levelOfDetail = levelOfDetail, 
                        this.maxGeoData = maxGeoData;
                    }
                    return __extends(GeocodeBoundaryQuery, _super), GeocodeBoundaryQuery.prototype.getBingEntity = function() {
                        var category = this.category.toLowerCase();
                        return categoryToBingEntityGeodata || (categoryToBingEntityGeodata = {}, categoryToBingEntityGeodata[CategoryTypes.CountryRegion.toLowerCase()] = services.BingEntities.CountryRegion, 
                        categoryToBingEntityGeodata[CategoryTypes.StateOrProvince.toLowerCase()] = services.BingEntities.AdminDivision1, 
                        categoryToBingEntityGeodata[CategoryTypes.County.toLowerCase()] = services.BingEntities.AdminDivision2, 
                        categoryToBingEntityGeodata[CategoryTypes.City.toLowerCase()] = services.BingEntities.PopulatedPlace, 
                        categoryToBingEntityGeodata[CategoryTypes.PostalCode.toLowerCase()] = services.BingEntities.Postcode1), 
                        categoryToBingEntityGeodata[category] || "";
                    }, GeocodeBoundaryQuery.prototype.getUrl = function() {
                        var url = Settings.BingUrlGeodata + "key=" + Settings.BingKey + "&$format=json", entityType = this.getBingEntity();
                        if (!entityType) return null;
                        var cultureName = navigator.userLanguage || navigator.language;
                        cultureName = mapLocalesForBing(cultureName);
                        var cultures = cultureName.split("-"), data = [ this.latitude, this.longitude, this.levelOfDetail, "'" + entityType + "'", 1, 0, "'" + cultureName + "'" ];
                        return cultures.length > 1 && data.push("'" + cultures[1] + "'"), url + "&SpatialFilter=GetBoundary(" + data.join(", ") + ")";
                    }, GeocodeBoundaryQuery;
                }(GeocodeQuery);
                services.GeocodeBoundaryQuery = GeocodeBoundaryQuery, services.geocodeCore = geocodeCore, 
                services.geocode = geocode, services.geocodeBoundary = geocodeBoundary, services.geocodePoint = geocodePoint;
                var dequeueTimeoutId;
                services.resetStaticGeocoderState = resetStaticGeocoderState, resetStaticGeocoderState();
            }(services = visuals.services || (visuals.services = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var services;
            !function(services) {
                function createGeocodingCache(maxCacheSize, maxCacheSizeOverflow, localStorageService) {
                    return localStorageService || (localStorageService = powerbi.localStorageService), 
                    new GeocodingCache(maxCacheSize, maxCacheSizeOverflow, localStorageService);
                }
                services.createGeocodingCache = createGeocodingCache;
                var GeocodingCache = function() {
                    function GeocodingCache(maxCacheSize, maxCacheSizeOverflow, localStorageService) {
                        this.geocodeCache = {}, this.geocodeCacheCount = 0, this.maxCacheSize = maxCacheSize, 
                        this.maxCacheSizeOverflow = maxCacheSizeOverflow, this.localStorageService = localStorageService;
                    }
                    return GeocodingCache.prototype.getCoordinates = function(key) {
                        var pair = this.geocodeCache[key];
                        return pair ? (++pair.hitCount, pair.coordinate) : (pair = this.localStorageService.getData(key), 
                        pair ? (this.registerInMemory(key, pair.coordinate), pair.coordinate) : void 0);
                    }, GeocodingCache.prototype.registerCoordinates = function(key, coordinate) {
                        this.registerInMemory(key, coordinate), this.registerInStorage(key, coordinate);
                    }, GeocodingCache.prototype.registerInMemory = function(key, coordinate) {
                        var geocodeCache = this.geocodeCache, maxCacheSize = this.maxCacheSize, maxCacheCount = maxCacheSize + this.maxCacheSizeOverflow;
                        if (this.geocodeCacheCount >= maxCacheCount) {
                            var keys = Object.keys(geocodeCache), cacheSize = keys.length;
                            if (keys.sort(function(a, b) {
                                var cachedA = geocodeCache[a], cachedB = geocodeCache[b], ca = cachedA ? cachedA.hitCount : 0, cb = cachedB ? cachedB.hitCount : 0;
                                return cb > ca ? 1 : ca > cb ? -1 : 0;
                            }), 2 * maxCacheCount > cacheSize) for (var i = maxCacheSize; cacheSize > i; i++) geocodeCache[keys[i]] = void 0; else {
                                for (var newGeocodeCache = {}, i = 0; maxCacheSize > i; ++i) newGeocodeCache[keys[i]] = geocodeCache[keys[i]];
                                geocodeCache = this.geocodeCache = newGeocodeCache;
                            }
                            this.geocodeCacheCount = maxCacheSize;
                        }
                        geocodeCache[key] = {
                            coordinate: coordinate,
                            hitCount: 1
                        }, ++this.geocodeCacheCount;
                    }, GeocodingCache.prototype.registerInStorage = function(key, coordinate) {
                        this.localStorageService.setData(key, {
                            coordinate: coordinate
                        });
                    }, GeocodingCache;
                }();
            }(services = visuals.services || (visuals.services = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var services;
            !function(services) {
                function createGeolocation() {
                    return new GeolocationService();
                }
                services.createGeolocation = createGeolocation;
                var GeolocationService = function() {
                    function GeolocationService() {
                        this.webGeolocation = navigator.geolocation;
                    }
                    return GeolocationService.prototype.watchPosition = function(successCallback, errorCallback) {
                        return this.webGeolocation.watchPosition(function(position) {
                            successCallback(position);
                        }, function(error) {
                            null != errorCallback && errorCallback(error);
                        });
                    }, GeolocationService.prototype.clearWatch = function(watchId) {
                        this.webGeolocation.clearWatch(watchId);
                    }, GeolocationService.prototype.getCurrentPosition = function(successCallback, errorCallback) {
                        this.webGeolocation.getCurrentPosition(function(position) {
                            successCallback(position);
                        }, function(error) {
                            null != errorCallback && errorCallback(error);
                        });
                    }, GeolocationService;
                }();
            }(services = visuals.services || (visuals.services = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi), __extends = (window.powerbitests, 
    window.InJs, window.debug, window.jasmine, window.Microsoft, this && this.__extends || function(d, b) {
        function __() {
            this.constructor = d;
        }
        for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
    });
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var controls;
            !function(controls) {
                function fire(eventHandlers, eventArgs) {
                    if (eventHandlers) for (var i = 0; i < eventHandlers.length; i++) {
                        var h = eventHandlers[i];
                        h(eventArgs);
                    }
                }
                var UNSELECTABLE_CLASS_NAME = "unselectable";
                controls.fire = fire;
                var ScrollbarButton = function() {
                    function ScrollbarButton(owner, direction) {
                        this._owner = owner, this._direction = direction, this._timerHandle = void 0, this.createView();
                        var that = this;
                        this._element.addEventListener("mousedown", function(e) {
                            that.onMouseDown(e);
                        }), $(this._element).addClass(UNSELECTABLE_CLASS_NAME), $(this._svg).addClass(UNSELECTABLE_CLASS_NAME), 
                        $(this._polygon).addClass(UNSELECTABLE_CLASS_NAME);
                    }
                    return Object.defineProperty(ScrollbarButton.prototype, "element", {
                        get: function() {
                            return this._element;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), ScrollbarButton.prototype.createView = function() {
                        var svgns = "http://www.w3.org/2000/svg";
                        this._polygon = document.createElementNS(svgns, "polygon"), this._polygon.setAttributeNS(null, "points", "3,3 6,3 13,8 6,13 3,13 10,8"), 
                        this._polygon.setAttributeNS(null, "fill", ScrollbarButton.ARROW_COLOR), this._svg = document.createElementNS(svgns, "svg");
                        var svgStyle = this._svg.style;
                        svgStyle.position = "absolute", svgStyle.left = "0px", svgStyle.top = "0px", this._svg.appendChild(this._polygon), 
                        this._element = document.createElement("div"), this._element.className = Scrollbar.arrowClassName, 
                        this._element.appendChild(this._svg), this._owner.element.appendChild(this._element);
                    }, ScrollbarButton.prototype.onMouseDown = function(event) {
                        var that = this;
                        if (clearTimeout(this._timerHandle), !this._mouseUpWrapper) {
                            event.cancelBubble = !0;
                            var that_1 = this;
                            this._mouseUpWrapper = function(event) {
                                that_1.onMouseUp(event);
                            }, Scrollbar.addDocumentMouseUpEvent(this._mouseUpWrapper);
                        }
                        this._owner._scrollSmallIncrement(this._direction), this._owner.refresh(), this._timerHandle = setTimeout(function() {
                            that.onMouseDown(event);
                        }, 100), event.preventDefault && event.preventDefault();
                    }, ScrollbarButton.prototype.onMouseUp = function(event) {
                        clearTimeout(this._timerHandle), Scrollbar.removeDocumentMouseUpEvent(this._mouseUpWrapper), 
                        this._mouseUpWrapper = void 0;
                    }, ScrollbarButton.prototype.arrange = function(width, height, angle) {
                        var size = Math.min(width, height), scale = size / 16, x = (width - size) / 2, y = (height - size) / 2;
                        this._polygon.setAttributeNS(null, "transform", "translate(" + x + ", " + y + ") scale(" + scale + ") rotate(" + angle + ",8,8)"), 
                        this._svg.setAttributeNS(null, "width", width + "px"), this._svg.setAttributeNS(null, "height", height + "px"), 
                        controls.HTMLElementUtils.setElementWidth(this._element, width), controls.HTMLElementUtils.setElementHeight(this._element, height);
                    }, ScrollbarButton.MIN_WIDTH = 26, ScrollbarButton.ARROW_COLOR = "#404040", ScrollbarButton;
                }();
                controls.ScrollbarButton = ScrollbarButton;
                var Scrollbar = function() {
                    function Scrollbar(parentElement, layoutKind) {
                        this.MIN_BAR_SIZE = 10, this.min = 0, this.max = 10, this.viewMin = 0, this.viewSize = 2, 
                        this.smallIncrement = 1, this._onscroll = [], this._screenToOffsetScale = 1, this.createView(parentElement, layoutKind);
                        var that = this;
                        this._element.addEventListener("mousedown", function(e) {
                            that.onBackgroundMouseDown(e);
                        }), this._middleBar.addEventListener("mousedown", function(e) {
                            that.onMiddleBarMouseDown(e);
                        }), this._timerHandle = void 0, this._visible = !0, this.element.winControl = this, 
                        $(this._touchPanel).addClass(UNSELECTABLE_CLASS_NAME);
                    }
                    return Scrollbar.prototype.scrollBy = function(delta) {
                        this.scrollTo(this.viewMin + delta);
                    }, Scrollbar.prototype.scrollUp = function() {
                        this.scrollBy(-this.smallIncrement);
                    }, Scrollbar.prototype.scrollDown = function() {
                        this.scrollBy(this.smallIncrement);
                    }, Scrollbar.prototype.scrollPageUp = function() {
                        this.scrollBy(-this.viewSize);
                    }, Scrollbar.prototype.scrollPageDown = function() {
                        this.scrollBy(this.viewSize);
                    }, Object.defineProperty(Scrollbar.prototype, "width", {
                        get: function() {
                            return this._width;
                        },
                        set: function(value) {
                            this._width = value, this._element.style.width = value, this.invalidateArrange();
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(Scrollbar.prototype, "height", {
                        get: function() {
                            return this._height;
                        },
                        set: function(value) {
                            this._height = value, this._element.style.height = value, this.invalidateArrange();
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Scrollbar.prototype.refresh = function() {}, Object.defineProperty(Scrollbar.prototype, "element", {
                        get: function() {
                            return this._element;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(Scrollbar.prototype, "maxButton", {
                        get: function() {
                            return this._maxButton;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(Scrollbar.prototype, "middleBar", {
                        get: function() {
                            return this._middleBar;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Scrollbar.prototype._scrollSmallIncrement = function(direction) {
                        this.scrollBy(this.smallIncrement * direction);
                    }, Object.defineProperty(Scrollbar.prototype, "visible", {
                        get: function() {
                            return this._visible;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(Scrollbar.prototype, "isInMouseCapture", {
                        get: function() {
                            return void 0 !== this._timerHandle;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Scrollbar.prototype.show = function(value) {
                        this._visible = value, this.element.style.visibility = value ? "visible" : "hidden", 
                        this.invalidateArrange();
                    }, Scrollbar.prototype._getMouseOffset = function(event) {
                        return void 0 !== event.offsetX ? {
                            x: event.offsetX,
                            y: event.offsetY
                        } : void 0 !== event.layerX ? {
                            x: event.layerX,
                            y: event.layerY
                        } : {
                            x: event.screenX,
                            y: event.screenY
                        };
                    }, Scrollbar.prototype._getOffsetXDelta = function(event) {
                        return (event.screenX - this._screenPrevMousePos.x) / this._screenToOffsetScale;
                    }, Scrollbar.prototype._getOffsetYDelta = function(event) {
                        return (event.screenY - this._screenPrevMousePos.y) / this._screenToOffsetScale;
                    }, Scrollbar.prototype._getOffsetXTouchDelta = function(event) {
                        return this._getMouseOffset(event).x - this._offsetTouchPrevPos.x;
                    }, Scrollbar.prototype._getOffsetYTouchDelta = function(event) {
                        return this._getMouseOffset(event).y - this._offsetTouchPrevPos.y;
                    }, Scrollbar.prototype.initTouch = function(panel, allowMouseDrag) {
                        var _this = this;
                        this._touchPanel = panel, this._allowMouseDrag = void 0 === allowMouseDrag ? !0 : allowMouseDrag, 
                        "ontouchmove" in panel ? (panel.addEventListener("touchstart", function(e) {
                            return _this.onTouchStart(e);
                        }), panel.addEventListener("touchmove", function(e) {
                            return _this.onTouchMove(e);
                        }), panel.addEventListener("touchend", function(e) {
                            return _this.onTouchEnd(e);
                        })) : (panel.addEventListener("mousedown", function(e) {
                            return _this.onTouchMouseDown(e);
                        }), panel.addEventListener("mousemove", function(e) {
                            return _this.onTouchMouseMove(e);
                        }), panel.addEventListener("mouseup", function(e) {
                            return _this.onTouchMouseUp(e);
                        }));
                    }, Scrollbar.prototype.onTouchStart = function(e) {
                        1 === e.touches.length && this.onTouchMouseDown(e.touches[0]);
                    }, Scrollbar.prototype.onTouchMove = function(e) {
                        1 === e.touches.length && (e.preventDefault && e.preventDefault(), this.onTouchMouseMove(e.touches[0]));
                    }, Scrollbar.prototype.onTouchEnd = function(e) {
                        this.onTouchMouseUp(1 === e.touches.length ? e.touches[0] : e, !0);
                    }, Scrollbar.prototype.onTouchMouseDown = function(e) {
                        (this._allowMouseDrag || e.pointerType !== MSPointerEvent.MSPOINTER_TYPE_MOUSE) && ("setCapture" in this._touchPanel && this._touchPanel.setCapture(!0), 
                        this._offsetTouchPrevPos = this._offsetTouchStartPos = null, this._touchStarted = !0);
                    }, Scrollbar.prototype._getOffsetTouchDelta = function(e) {
                        return null;
                    }, Scrollbar.prototype.onTouchMouseMove = function(e) {
                        if (this._touchStarted) {
                            this._offsetTouchStartPos || (this._offsetTouchPrevPos = this._offsetTouchStartPos = this._getMouseOffset(e));
                            var delta = this._getOffsetTouchDelta(e);
                            0 !== delta && (this.scrollBy(-delta / this._getRunningSize(!1) * this.viewSize), 
                            this._offsetTouchPrevPos = this._getMouseOffset(e)), e.preventDefault && e.preventDefault(), 
                            e.cancelBubble = !0;
                        }
                    }, Scrollbar.prototype.onTouchMouseUp = function(e, bubble) {
                        if (this._touchStarted && this._offsetTouchStartPos) {
                            var end = this._getMouseOffset(e);
                            !bubble && (Math.abs(this._offsetTouchStartPos.x - end.x) > 3 || Math.abs(this._offsetTouchStartPos.y - end.y) > 3) && (e.preventDefault && e.preventDefault(), 
                            e.cancelBubble = !0);
                        }
                        "releaseCapture" in this._touchPanel && this._touchPanel.releaseCapture(), this._touchStarted = !1;
                    }, Scrollbar.prototype.createView = function(parentElement, layoutKind) {
                        this._element = document.createElement("div"), this._element.className = Scrollbar.className, 
                        this._element.setAttribute("drag-resize-disabled", "true"), 0 === layoutKind && parentElement.appendChild(this._element), 
                        this._minButton = new ScrollbarButton(this, -1), this._maxButton = new ScrollbarButton(this, 1), 
                        this._middleBar = document.createElement("div"), this._middleBar.className = Scrollbar.barClassName, 
                        this._element.appendChild(this._middleBar);
                    }, Scrollbar.prototype.scrollTo = function(pos) {
                        var viewMin = Math.min(this.max - this.viewSize, Math.max(this.min, pos));
                        viewMin !== this.viewMin && (this.viewMin = viewMin, fire(this._onscroll, null));
                    }, Scrollbar.prototype._scrollByPage = function(event) {}, Scrollbar.prototype._getRunningSize = function(net) {
                        return null;
                    }, Scrollbar.prototype._getOffsetDelta = function(event) {
                        return null;
                    }, Scrollbar.prototype.scroll = function(event) {
                        var delta = this._getOffsetDelta(event) / this._getRunningSize(!0) * (this.max - this.min);
                        if (0 > delta) {
                            if (this._getScreenMousePos(event) >= this._screenMaxMousePos) return;
                        } else if (delta > 0 && this._getScreenMousePos(event) <= this._screenMinMousePos) return;
                        this.scrollBy(delta);
                    }, Object.defineProperty(Scrollbar.prototype, "actualWidth", {
                        get: function() {
                            return void 0 === this._actualWidth && this.arrange(), this._actualWidth;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(Scrollbar.prototype, "actualHeight", {
                        get: function() {
                            return void 0 === !this._actualHeight && this.arrange(), this._actualHeight;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(Scrollbar.prototype, "actualButtonWidth", {
                        get: function() {
                            return void 0 === !this._actualButtonWidth && this.arrange(), this._actualButtonWidth;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(Scrollbar.prototype, "actualButtonHeight", {
                        get: function() {
                            return void 0 === !this._actualButtonHeight && this.arrange(), this._actualButtonHeight;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Scrollbar.prototype.arrange = function() {
                        this._actualWidth || (this._actualWidth = this._element.offsetWidth, this._actualHeight = this._element.offsetHeight, 
                        this._actualButtonWidth = this._calculateButtonWidth(), this._actualButtonHeight = this._calculateButtonHeight(), 
                        this._minButton.arrange(this._actualButtonWidth, this._actualButtonHeight, this._getMinButtonAngle()), 
                        this._maxButton.arrange(this._actualButtonWidth, this._actualButtonHeight, this._getMaxButtonAngle()), 
                        this._setMaxButtonPosition());
                    }, Scrollbar.prototype._calculateButtonWidth = function() {
                        return null;
                    }, Scrollbar.prototype._calculateButtonHeight = function() {
                        return null;
                    }, Scrollbar.prototype._getMinButtonAngle = function() {
                        return null;
                    }, Scrollbar.prototype._getMaxButtonAngle = function() {
                        return null;
                    }, Scrollbar.prototype._setMaxButtonPosition = function() {}, Scrollbar.prototype.invalidateArrange = function() {
                        this._actualWidth = void 0, this._actualHeight = void 0, this._actualButtonWidth = void 0, 
                        this._actualButtonHeight = void 0;
                    }, Scrollbar.prototype.onHoldBackgroundMouseDown = function(event) {
                        var _this = this, holdDelay = this._timerHandle ? Scrollbar.ScrollbarBackgroundMousedownHoldDelay : Scrollbar.ScrollbarBackgroundFirstTimeMousedownHoldDelay;
                        this._timerHandle = setTimeout(function() {
                            _this.onBackgroundMouseDown(event);
                        }, holdDelay);
                    }, Scrollbar.prototype.onBackgroundMouseDown = function(event) {
                        var that = this;
                        clearTimeout(this._timerHandle), this._backgroundMouseUpWrapper || (event.cancelBubble = !0, 
                        this._backgroundMouseUpWrapper = function(event) {
                            that.onBackgroundMouseUp(event);
                        }, Scrollbar.addDocumentMouseUpEvent(this._backgroundMouseUpWrapper)), this._scrollByPage(event), 
                        this.refresh(), this.onHoldBackgroundMouseDown(event), event.preventDefault && event.preventDefault();
                    }, Scrollbar.prototype.onBackgroundMouseUp = function(event) {
                        clearTimeout(this._timerHandle), this._timerHandle = void 0, Scrollbar.removeDocumentMouseUpEvent(this._backgroundMouseUpWrapper), 
                        this._backgroundMouseUpWrapper = void 0;
                    }, Scrollbar.prototype.getPinchZoomY = function() {
                        return document.documentElement.clientHeight / window.innerHeight;
                    }, Scrollbar.prototype.onMiddleBarMouseDown = function(event) {
                        event.cancelBubble = !0, this._screenPrevMousePos = {
                            x: event.screenX,
                            y: event.screenY
                        }, this._screenMinMousePos = this._getScreenMousePos(event) - (this._getScreenContextualLeft(this._middleBar) - this._getScreenContextualRight(this._minButton.element)), 
                        this._screenMaxMousePos = this._getScreenMousePos(event) + (this._getScreenContextualLeft(this._maxButton.element) - this._getScreenContextualRight(this._middleBar)), 
                        this._screenToOffsetScale = controls.HTMLElementUtils.getAccumulatedScale(this.element) * this.getPinchZoomY();
                        var that = this;
                        this._middleBarMouseMoveWrapper = function(e) {
                            that.onMiddleBarMouseMove(e);
                        }, Scrollbar.addDocumentMouseMoveEvent(this._middleBarMouseMoveWrapper), this._middleBarMouseUpWrapper = function(e) {
                            that.onMiddleBarMouseUp(e);
                        }, Scrollbar.addDocumentMouseUpEvent(this._middleBarMouseUpWrapper), event.preventDefault && event.preventDefault();
                    }, Scrollbar.prototype.onMiddleBarMouseMove = function(event) {
                        this._screenPrevMousePos && (this.scroll(event), this.refresh(), this._screenPrevMousePos = {
                            x: event.screenX,
                            y: event.screenY
                        });
                    }, Scrollbar.prototype.onMiddleBarMouseUp = function(event) {
                        this._screenPrevMousePos = void 0, Scrollbar.removeDocumentMouseMoveEvent(this._middleBarMouseMoveWrapper), 
                        this._middleBarMouseMoveWrapper = void 0, Scrollbar.removeDocumentMouseUpEvent(this._middleBarMouseUpWrapper), 
                        this._middleBarMouseUpWrapper = void 0, event.preventDefault && event.preventDefault();
                    }, Scrollbar.prototype._getScreenContextualLeft = function(element) {
                        return null;
                    }, Scrollbar.prototype._getScreenContextualRight = function(element) {
                        return null;
                    }, Scrollbar.prototype.onMouseWheel = function(delta) {
                        delta && this.mouseWheel(delta);
                    }, Scrollbar.prototype.mouseWheel = function(delta) {
                        this.visible && (0 > delta ? delta = Math.min(-Scrollbar.MouseWheelRange, delta) : delta > 0 && (delta = Math.max(Scrollbar.MouseWheelRange, delta)), 
                        this.scrollBy(-delta / Scrollbar.MouseWheelRange * this.smallIncrement));
                    }, Scrollbar.prototype._getScreenMousePos = function(event) {
                        return null;
                    }, Scrollbar.addDocumentMouseUpEvent = function(func) {
                        document.addEventListener("mouseup", func);
                    }, Scrollbar.removeDocumentMouseUpEvent = function(func) {
                        document.removeEventListener("mouseup", func);
                    }, Scrollbar.addDocumentMouseMoveEvent = function(func) {
                        document.addEventListener("mousemove", func);
                    }, Scrollbar.removeDocumentMouseMoveEvent = function(func) {
                        document.removeEventListener("mousemove", func);
                    }, Scrollbar.DefaultScrollbarWidth = "15px", Scrollbar.ScrollbarBackgroundFirstTimeMousedownHoldDelay = 500, 
                    Scrollbar.ScrollbarBackgroundMousedownHoldDelay = 50, Scrollbar.MouseWheelRange = 120, 
                    Scrollbar.className = "scroll-bar-div", Scrollbar.barClassName = "scroll-bar-part-bar", 
                    Scrollbar.arrowClassName = "scroll-bar-part-arrow", Scrollbar;
                }();
                controls.Scrollbar = Scrollbar;
                var HorizontalScrollbar = function(_super) {
                    function HorizontalScrollbar(parentElement, layoutKind) {
                        _super.call(this, parentElement, layoutKind), this.height = Scrollbar.DefaultScrollbarWidth;
                    }
                    return __extends(HorizontalScrollbar, _super), HorizontalScrollbar.prototype._calculateButtonWidth = function() {
                        return Math.min(this.actualWidth / 2, Math.max(this.actualHeight, ScrollbarButton.MIN_WIDTH));
                    }, HorizontalScrollbar.prototype._calculateButtonHeight = function() {
                        return this.actualHeight;
                    }, HorizontalScrollbar.prototype._getMinButtonAngle = function() {
                        return -180;
                    }, HorizontalScrollbar.prototype._getMaxButtonAngle = function() {
                        return 0;
                    }, HorizontalScrollbar.prototype._setMaxButtonPosition = function() {
                        controls.HTMLElementUtils.setElementLeft(this.maxButton.element, this.actualWidth - this.actualButtonWidth);
                    }, HorizontalScrollbar.prototype.refresh = function() {
                        this.arrange();
                        var runningSize = this.actualWidth - 2 * this.actualButtonWidth - 2, barSize = this.viewSize / (this.max - this.min) * runningSize;
                        barSize < this.MIN_BAR_SIZE && (runningSize -= this.MIN_BAR_SIZE - barSize, barSize = this.MIN_BAR_SIZE), 
                        0 > runningSize && (runningSize = 0, barSize = 0), barSize = Math.min(barSize, runningSize);
                        var barPos = this.viewMin / (this.max - this.min) * runningSize;
                        controls.HTMLElementUtils.setElementWidth(this.middleBar, barSize), controls.HTMLElementUtils.setElementHeight(this.middleBar, this.actualHeight), 
                        controls.HTMLElementUtils.setElementLeft(this.middleBar, this.actualButtonWidth + 1 + barPos);
                    }, HorizontalScrollbar.prototype.show = function(visible) {
                        visible !== this.visible && (_super.prototype.show.call(this, visible), visible ? this.element.style.height = this.height : controls.HTMLElementUtils.setElementHeight(this.element, 0));
                    }, HorizontalScrollbar.prototype._scrollByPage = function(event) {
                        var left = this.middleBar.offsetLeft, right = left + this.middleBar.offsetWidth, x = void 0 === event.offsetX ? event.layerX : event.offsetX;
                        x > right ? this.scrollPageDown() : left > x && this.scrollPageUp();
                    }, HorizontalScrollbar.prototype._getRunningSize = function(net) {
                        var result = this.actualWidth;
                        if (net) {
                            var barMinPos = this.actualButtonWidth + 1;
                            result -= 2 * barMinPos;
                            var barSize = result * (this.viewSize / (this.max - this.min));
                            barSize < this.MIN_BAR_SIZE && (result -= this.MIN_BAR_SIZE - barSize);
                        }
                        return result;
                    }, HorizontalScrollbar.prototype._getOffsetDelta = function(event) {
                        return this._getOffsetXDelta(event);
                    }, HorizontalScrollbar.prototype._getOffsetTouchDelta = function(e) {
                        return this._getOffsetXTouchDelta(e);
                    }, HorizontalScrollbar.prototype._getScreenContextualLeft = function(element) {
                        return element.getBoundingClientRect().left;
                    }, HorizontalScrollbar.prototype._getScreenContextualRight = function(element) {
                        return element.getBoundingClientRect().right;
                    }, HorizontalScrollbar.prototype._getScreenMousePos = function(event) {
                        return event.screenX;
                    }, HorizontalScrollbar;
                }(Scrollbar);
                controls.HorizontalScrollbar = HorizontalScrollbar;
                var VerticalScrollbar = function(_super) {
                    function VerticalScrollbar(parentElement, layoutKind) {
                        _super.call(this, parentElement, layoutKind), this.width = Scrollbar.DefaultScrollbarWidth;
                    }
                    return __extends(VerticalScrollbar, _super), VerticalScrollbar.prototype._calculateButtonWidth = function() {
                        return this.actualWidth;
                    }, VerticalScrollbar.prototype._calculateButtonHeight = function() {
                        return Math.min(this.actualHeight / 2, Math.max(this.actualWidth, ScrollbarButton.MIN_WIDTH));
                    }, VerticalScrollbar.prototype._getMinButtonAngle = function() {
                        return -90;
                    }, VerticalScrollbar.prototype._getMaxButtonAngle = function() {
                        return 90;
                    }, VerticalScrollbar.prototype._setMaxButtonPosition = function() {
                        controls.HTMLElementUtils.setElementTop(this.maxButton.element, this.actualHeight - this.actualButtonHeight);
                    }, VerticalScrollbar.prototype.refresh = function() {
                        this.arrange();
                        var runningSize = this.actualHeight - 2 * this.actualButtonHeight - 2, barSize = this.viewSize / (this.max - this.min) * runningSize;
                        barSize < this.MIN_BAR_SIZE && (runningSize -= this.MIN_BAR_SIZE - barSize, barSize = this.MIN_BAR_SIZE), 
                        0 > runningSize && (runningSize = 0, barSize = 0);
                        var barPos = this.viewMin / (this.max - this.min) * runningSize;
                        controls.HTMLElementUtils.setElementWidth(this.middleBar, this.actualWidth), controls.HTMLElementUtils.setElementHeight(this.middleBar, barSize), 
                        controls.HTMLElementUtils.setElementTop(this.middleBar, this.actualButtonHeight + 1 + barPos);
                    }, VerticalScrollbar.prototype.show = function(visible) {
                        visible !== this.visible && (_super.prototype.show.call(this, visible), visible ? this.element.style.width = this.width : controls.HTMLElementUtils.setElementWidth(this.element, 0));
                    }, VerticalScrollbar.prototype._scrollByPage = function(event) {
                        var top = this.middleBar.offsetTop, bottom = top + this.middleBar.offsetHeight, y = void 0 === event.offsetY ? event.layerY : event.offsetY;
                        y > bottom ? this.scrollPageDown() : top > y && this.scrollPageUp();
                    }, VerticalScrollbar.prototype._getRunningSize = function(net) {
                        var result = this.actualHeight;
                        if (net) {
                            var barMinPos = this.actualButtonHeight + 1;
                            result -= 2 * barMinPos;
                            var barSize = result * (this.viewSize / (this.max - this.min));
                            barSize < this.MIN_BAR_SIZE && (result -= this.MIN_BAR_SIZE - barSize);
                        }
                        return result;
                    }, VerticalScrollbar.prototype._getOffsetDelta = function(event) {
                        return this._getOffsetYDelta(event);
                    }, VerticalScrollbar.prototype._getOffsetTouchDelta = function(e) {
                        return this._getOffsetYTouchDelta(e);
                    }, VerticalScrollbar.prototype._getScreenContextualLeft = function(element) {
                        return element.getBoundingClientRect().top;
                    }, VerticalScrollbar.prototype._getScreenContextualRight = function(element) {
                        return element.getBoundingClientRect().bottom;
                    }, VerticalScrollbar.prototype._getScreenMousePos = function(event) {
                        return event.screenY;
                    }, VerticalScrollbar;
                }(Scrollbar);
                controls.VerticalScrollbar = VerticalScrollbar;
            }(controls = visuals.controls || (visuals.controls = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi), __extends = (window.powerbitests, 
    window.InJs, window.debug, window.jasmine, window.Microsoft, this && this.__extends || function(d, b) {
        function __() {
            this.constructor = d;
        }
        for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
    });
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var controls;
            !function(controls) {
                var internal;
                !function(internal) {
                    var UNSELECTABLE_CLASS_NAME = "unselectable", TablixResizer = function() {
                        function TablixResizer(element, handler) {
                            this._element = element, this._handler = handler, this._elementMouseDownWrapper = null, 
                            this._elementMouseMoveWrapper = null, this._elementMouseOutWrapper = null, this._documentMouseMoveWrapper = null, 
                            this._documentMouseUpWrapper = null, this._startMousePosition = null, this._originalCursor = null;
                        }
                        return TablixResizer.addDocumentMouseUpEvent = function(listener) {
                            document.addEventListener("mouseup", listener);
                        }, TablixResizer.removeDocumentMouseUpEvent = function(listener) {
                            document.removeEventListener("mouseup", listener);
                        }, TablixResizer.addDocumentMouseMoveEvent = function(listener) {
                            document.addEventListener("mousemove", listener);
                        }, TablixResizer.removeDocumentMouseMoveEvent = function(listener) {
                            document.removeEventListener("mousemove", listener);
                        }, TablixResizer.getMouseCoordinates = function(event) {
                            return {
                                x: event.pageX,
                                y: event.pageY
                            };
                        }, TablixResizer.getMouseCoordinateDelta = function(previous, current) {
                            return {
                                x: current.x - previous.x,
                                y: current.y - previous.y
                            };
                        }, TablixResizer.prototype.initialize = function() {
                            var _this = this;
                            this._elementMouseDownWrapper = function(e) {
                                return _this.onElementMouseDown(e);
                            }, this._element.addEventListener("mousedown", this._elementMouseDownWrapper), this._elementMouseMoveWrapper = function(e) {
                                return _this.onElementMouseMove(e);
                            }, this._element.addEventListener("mousemove", this._elementMouseMoveWrapper), this._elementMouseOutWrapper = function(e) {
                                return _this.onElementMouseOut(e);
                            }, this._element.addEventListener("mouseout", this._elementMouseOutWrapper), this._elementMouseDoubleClickOutWrapper = function(e) {
                                return _this.onElementMouseDoubleClick(e);
                            }, this._element.addEventListener("dblclick", this._elementMouseDoubleClickOutWrapper);
                        }, TablixResizer.prototype.uninitialize = function() {
                            this._element.removeEventListener("mousedown", this._elementMouseDownWrapper), this._elementMouseDownWrapper = null, 
                            this._element.removeEventListener("mousemove", this._elementMouseMoveWrapper), this._elementMouseMoveWrapper = null, 
                            this._element.removeEventListener("mouseout", this._elementMouseOutWrapper), this._elementMouseOutWrapper = null, 
                            this._element.removeEventListener("dblclick", this._elementMouseDoubleClickOutWrapper), 
                            this._elementMouseDoubleClickOutWrapper = null;
                        }, Object.defineProperty(TablixResizer.prototype, "cell", {
                            get: function() {
                                return null;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(TablixResizer.prototype, "element", {
                            get: function() {
                                return this._element;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), TablixResizer.prototype._hotSpot = function(position) {
                            return !1;
                        }, TablixResizer.prototype.onElementMouseDown = function(event) {
                            var _this = this, position = TablixResizer.getMouseCoordinates(event);
                            this._hotSpot(position) && ("setCapture" in this._element && this._element.setCapture(), 
                            event.cancelBubble = !0, this._startMousePosition = position, this._documentMouseMoveWrapper = function(e) {
                                return _this.onDocumentMouseMove(e);
                            }, TablixResizer.addDocumentMouseMoveEvent(this._documentMouseMoveWrapper), this._documentMouseUpWrapper = function(e) {
                                return _this.onDocumentMouseUp(e);
                            }, TablixResizer.addDocumentMouseUpEvent(this._documentMouseUpWrapper), document.documentElement && (this._originalCursor = document.documentElement.style.cursor, 
                            document.documentElement.style.cursor = TablixResizer.resizeCursor), this._handler.onStartResize(this.cell, this._startMousePosition.x, this._startMousePosition.y));
                        }, TablixResizer.prototype.onElementMouseMove = function(event) {
                            this._startMousePosition || (this._hotSpot(TablixResizer.getMouseCoordinates(event)) ? null === this._originalCursor && (this._originalCursor = this._element.style.cursor, 
                            this._element.style.cursor = TablixResizer.resizeCursor) : null !== this._originalCursor && (this._element.style.cursor = this._originalCursor, 
                            this._originalCursor = null));
                        }, TablixResizer.prototype.onElementMouseOut = function(event) {
                            this._startMousePosition || null !== this._originalCursor && (this._element.style.cursor = this._originalCursor, 
                            this._originalCursor = null);
                        }, TablixResizer.prototype.onElementMouseDoubleClick = function(event) {
                            this._hotSpot(TablixResizer.getMouseCoordinates(event)) && this._handler.onReset(this.cell);
                        }, TablixResizer.prototype.onDocumentMouseMove = function(event) {
                            if (this._startMousePosition) {
                                var delta = TablixResizer.getMouseCoordinateDelta(this._startMousePosition, TablixResizer.getMouseCoordinates(event));
                                this._handler.onResize(this.cell, delta.x, delta.y), event.preventDefault();
                            }
                        }, TablixResizer.prototype.onDocumentMouseUp = function(event) {
                            this._startMousePosition = null, "releaseCapture" in this._element && this._element.releaseCapture(), 
                            TablixResizer.removeDocumentMouseMoveEvent(this._documentMouseMoveWrapper), this._documentMouseMoveWrapper = null, 
                            TablixResizer.removeDocumentMouseUpEvent(this._documentMouseUpWrapper), this._documentMouseUpWrapper = null, 
                            document.documentElement && (document.documentElement.style.cursor = this._originalCursor), 
                            event.preventDefault && event.preventDefault(), this._handler.onEndResize(this.cell);
                        }, TablixResizer.resizeHandleSize = 4, TablixResizer.resizeCursor = "e-resize", 
                        TablixResizer;
                    }();
                    internal.TablixResizer = TablixResizer;
                    var TablixDomResizer = function(_super) {
                        function TablixDomResizer(cell, element, handler) {
                            _super.call(this, element, handler), this._cell = cell;
                        }
                        return __extends(TablixDomResizer, _super), Object.defineProperty(TablixDomResizer.prototype, "cell", {
                            get: function() {
                                return this._cell;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), TablixDomResizer.prototype._hotSpot = function(position) {
                            return position.x >= this.element.getBoundingClientRect().right - TablixResizer.resizeHandleSize;
                        }, TablixDomResizer;
                    }(TablixResizer);
                    internal.TablixDomResizer = TablixDomResizer;
                    var TablixCellPresenter = function() {
                        function TablixCellPresenter(fitProportionally, layoutKind) {
                            this._tableCell = null, this._contentElement = internal.TablixUtils.createDiv(), 
                            this._contentHost = internal.TablixUtils.createDiv(), this.layoutKind = layoutKind, 
                            this._contentElement.appendChild(this._contentHost), this._resizer = null;
                        }
                        return TablixCellPresenter.prototype.initialize = function(owner) {
                            this._owner = owner;
                        }, Object.defineProperty(TablixCellPresenter.prototype, "owner", {
                            get: function() {
                                return this._owner;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), TablixCellPresenter.prototype.registerTableCell = function(tableCell) {
                            this._tableCell = tableCell, tableCell.appendChild(this._contentElement);
                        }, Object.defineProperty(TablixCellPresenter.prototype, "tableCell", {
                            get: function() {
                                return this._tableCell;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(TablixCellPresenter.prototype, "contentElement", {
                            get: function() {
                                return this._contentElement;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(TablixCellPresenter.prototype, "contentHost", {
                            get: function() {
                                return this._contentHost;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), TablixCellPresenter.prototype.registerClickHandler = function(handler) {
                            this._contentElement.onclick = handler;
                        }, TablixCellPresenter.prototype.unregisterClickHandler = function() {
                            this._contentElement.onclick = null;
                        }, TablixCellPresenter.prototype.onContainerWidthChanged = function(value) {
                            controls.HTMLElementUtils.setElementWidth(this._contentElement, value);
                        }, TablixCellPresenter.prototype.onContinerHeightChanged = function(height) {
                            controls.HTMLElementUtils.setElementHeight(this._contentElement, height);
                        }, TablixCellPresenter.prototype.onColumnSpanChanged = function(value) {
                            this._tableCell.colSpan = value;
                        }, TablixCellPresenter.prototype.onRowSpanChanged = function(value) {
                            this._tableCell.rowSpan = value;
                        }, TablixCellPresenter.prototype.onTextAlignChanged = function(value) {
                            this._tableCell.style.textAlign = value;
                        }, TablixCellPresenter.prototype.onClear = function() {
                            this._contentHost.className = "", this._tableCell.className = "";
                        }, TablixCellPresenter.prototype.onHorizontalScroll = function(width, offset) {
                            controls.HTMLElementUtils.setElementLeft(this._contentHost, offset), controls.HTMLElementUtils.setElementWidth(this._contentHost, width);
                        }, TablixCellPresenter.prototype.onVerticalScroll = function(height, offset) {
                            controls.HTMLElementUtils.setElementTop(this._contentHost, offset), controls.HTMLElementUtils.setElementHeight(this._contentHost, height);
                        }, TablixCellPresenter.prototype.onInitializeScrolling = function() {
                            controls.HTMLElementUtils.setElementLeft(this._contentHost, 0), controls.HTMLElementUtils.setElementTop(this._contentHost, 0), 
                            controls.HTMLElementUtils.setElementWidth(this._contentHost, -1), controls.HTMLElementUtils.setElementHeight(this._contentHost, -1);
                        }, TablixCellPresenter.prototype.enableHorizontalResize = function(enable, handler) {
                            enable !== (null !== this._resizer) && (enable ? (this._resizer = new TablixDomResizer(this._owner, this._tableCell, handler), 
                            this._resizer.initialize()) : (this._resizer.uninitialize(), this._resizer = null));
                        }, TablixCellPresenter.prototype.disableDragResize = function() {
                            this._tableCell.setAttribute(TablixCellPresenter._dragResizeDisabledAttributeName, "true");
                        }, TablixCellPresenter._dragResizeDisabledAttributeName = "drag-resize-disabled", 
                        TablixCellPresenter;
                    }();
                    internal.TablixCellPresenter = TablixCellPresenter;
                    var TablixRowPresenter = function() {
                        function TablixRowPresenter(fitProportionally) {
                            this._tableRow = null, this._fitProportionally = fitProportionally;
                        }
                        return TablixRowPresenter.prototype.initialize = function(row) {
                            this._row = row;
                        }, TablixRowPresenter.prototype.createCellPresenter = function(layoutKind) {
                            return new TablixCellPresenter(this._fitProportionally, layoutKind);
                        }, TablixRowPresenter.prototype.registerRow = function(tableRow) {
                            this._tableRow = tableRow;
                        }, TablixRowPresenter.prototype.onAppendCell = function(cell) {
                            var presenter = cell._presenter;
                            if (null === presenter.tableCell) {
                                var tableCell = this._tableRow.insertCell(-1);
                                presenter.registerTableCell(tableCell);
                            } else this._tableRow.appendChild(presenter.tableCell);
                        }, TablixRowPresenter.prototype.onInsertCellBefore = function(cell, refCell) {
                            var presenter = cell._presenter;
                            if (null === presenter.tableCell) {
                                var tableCell = this._tableRow.insertCell(Math.max(0, refCell._presenter.tableCell.cellIndex - 1));
                                presenter.registerTableCell(tableCell);
                            } else this._tableRow.insertBefore(cell._presenter.tableCell, refCell._presenter.tableCell);
                        }, TablixRowPresenter.prototype.onRemoveCell = function(cell) {
                            this._tableRow.removeChild(cell._presenter.tableCell);
                        }, TablixRowPresenter.prototype.getHeight = function() {
                            return this.getCellHeight(this._row.getTablixCell());
                        }, TablixRowPresenter.prototype.getCellHeight = function(cell) {
                            return -1;
                        }, TablixRowPresenter.prototype.getCellContentHeight = function(cell) {
                            return -1;
                        }, Object.defineProperty(TablixRowPresenter.prototype, "tableRow", {
                            get: function() {
                                return this._tableRow;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), TablixRowPresenter;
                    }();
                    internal.TablixRowPresenter = TablixRowPresenter;
                    var DashboardRowPresenter = function(_super) {
                        function DashboardRowPresenter(gridPresenter, fitProportionally) {
                            _super.call(this, fitProportionally), this._gridPresenter = gridPresenter;
                        }
                        return __extends(DashboardRowPresenter, _super), DashboardRowPresenter.prototype.getCellHeight = function(cell) {
                            return cell.containerHeight;
                        }, DashboardRowPresenter.prototype.getCellContentHeight = function(cell) {
                            return cell.contentHeight;
                        }, DashboardRowPresenter;
                    }(TablixRowPresenter);
                    internal.DashboardRowPresenter = DashboardRowPresenter;
                    var CanvasRowPresenter = function(_super) {
                        function CanvasRowPresenter() {
                            _super.apply(this, arguments);
                        }
                        return __extends(CanvasRowPresenter, _super), CanvasRowPresenter.prototype.getCellHeight = function(cell) {
                            return cell.containerHeight;
                        }, CanvasRowPresenter.prototype.getCellContentHeight = function(cell) {
                            return cell.contentHeight;
                        }, CanvasRowPresenter;
                    }(TablixRowPresenter);
                    internal.CanvasRowPresenter = CanvasRowPresenter;
                    var TablixColumnPresenter = function() {
                        function TablixColumnPresenter() {}
                        return TablixColumnPresenter.prototype.initialize = function(column) {
                            this._column = column;
                        }, TablixColumnPresenter.prototype.getWidth = function() {
                            var width = this.getPersistedWidth();
                            return null == width && (width = this.getCellWidth(this._column.getTablixCell())), 
                            width;
                        }, TablixColumnPresenter.prototype.getPersistedWidth = function() {
                            return -1;
                        }, TablixColumnPresenter.prototype.getCellWidth = function(cell) {
                            return -1;
                        }, TablixColumnPresenter;
                    }();
                    internal.TablixColumnPresenter = TablixColumnPresenter;
                    var DashboardColumnPresenter = function(_super) {
                        function DashboardColumnPresenter(gridPresenter) {
                            _super.call(this), this._gridPresenter = gridPresenter;
                        }
                        return __extends(DashboardColumnPresenter, _super), DashboardColumnPresenter.prototype.getPersistedWidth = function() {
                            return this._gridPresenter.sizeComputationManager.cellWidth;
                        }, DashboardColumnPresenter.prototype.getCellWidth = function(cell) {
                            return this._gridPresenter.sizeComputationManager.cellWidth;
                        }, DashboardColumnPresenter;
                    }(TablixColumnPresenter);
                    internal.DashboardColumnPresenter = DashboardColumnPresenter;
                    var CanvasColumnPresenter = function(_super) {
                        function CanvasColumnPresenter(gridPresenter, index) {
                            _super.call(this), this._gridPresenter = gridPresenter, this._columnIndex = index;
                        }
                        return __extends(CanvasColumnPresenter, _super), CanvasColumnPresenter.prototype.getPersistedWidth = function() {
                            return this._gridPresenter.getPersistedColumnWidth(this._column);
                        }, CanvasColumnPresenter.prototype.getCellWidth = function(cell) {
                            var tablixCell = cell;
                            return tablixCell._presenter ? cell.contentWidth : 0;
                        }, CanvasColumnPresenter;
                    }(TablixColumnPresenter);
                    internal.CanvasColumnPresenter = CanvasColumnPresenter;
                    var TablixGridPresenter = function() {
                        function TablixGridPresenter(columnWidthManager) {
                            this._table = internal.TablixUtils.createTable(), this._table.className = UNSELECTABLE_CLASS_NAME, 
                            this._footerTable = internal.TablixUtils.createTable(), this._footerTable.className = UNSELECTABLE_CLASS_NAME, 
                            this._columnWidthManager = columnWidthManager;
                        }
                        return TablixGridPresenter.prototype.initialize = function(owner, gridHost, footerHost, control) {
                            this._owner = owner, gridHost.appendChild(this._table), footerHost.appendChild(this._footerTable);
                        }, TablixGridPresenter.prototype.getWidth = function() {
                            return -1;
                        }, TablixGridPresenter.prototype.getHeight = function() {
                            return -1;
                        }, TablixGridPresenter.prototype.getScreenToCssRatioX = function() {
                            return 1;
                        }, TablixGridPresenter.prototype.getScreenToCssRatioY = function() {
                            return 1;
                        }, TablixGridPresenter.prototype.createRowPresenter = function() {
                            return null;
                        }, TablixGridPresenter.prototype.createColumnPresenter = function(index) {
                            return null;
                        }, TablixGridPresenter.prototype.onAppendRow = function(row) {
                            var presenter = row.presenter;
                            if (null === presenter.tableRow) {
                                var tableRow = this._table.insertRow(-1);
                                presenter.registerRow(tableRow);
                            } else this._table.tBodies[0].appendChild(row.presenter.tableRow);
                        }, TablixGridPresenter.prototype.onInsertRowBefore = function(row, refRow) {
                            var presenter = row.presenter;
                            if (null === presenter.tableRow) {
                                var tableRow = this._table.insertRow(Math.max(0, refRow.presenter.tableRow.rowIndex - 1));
                                presenter.registerRow(tableRow);
                            } else this._table.tBodies[0].insertBefore(row.presenter.tableRow, refRow.presenter.tableRow);
                        }, TablixGridPresenter.prototype.onRemoveRow = function(row) {
                            this._table.tBodies[0].removeChild(row.presenter.tableRow);
                        }, TablixGridPresenter.prototype.onAddFooterRow = function(row) {
                            var presenter = row.presenter;
                            if (null === presenter.tableRow) {
                                var tableRow = this._footerTable.insertRow(-1);
                                presenter.registerRow(tableRow);
                            } else this._footerTable.tBodies[0].appendChild(row.presenter.tableRow);
                        }, TablixGridPresenter.prototype.onClear = function() {
                            controls.HTMLElementUtils.clearChildren(this._table), controls.HTMLElementUtils.clearChildren(this._footerTable);
                        }, TablixGridPresenter.prototype.onFillColumnsProportionallyChanged = function(value) {
                            value ? (this._table.style.width = "100%", this._footerTable.style.width = "100%") : (this._table.style.width = "auto", 
                            this._footerTable.style.width = "auto");
                        }, TablixGridPresenter.prototype.invokeColumnResizeEndCallback = function(column, width) {
                            this._columnWidthManager && this._columnWidthManager.onColumnWidthChanged(controls.TablixColumnWidthManager.getColumnQueryName(column), width);
                        }, TablixGridPresenter.prototype.getPersistedColumnWidth = function(column) {
                            return this._columnWidthManager ? this._columnWidthManager.getPersistedColumnWidth(controls.TablixColumnWidthManager.getColumnQueryName(column)) : void 0;
                        }, TablixGridPresenter;
                    }();
                    internal.TablixGridPresenter = TablixGridPresenter;
                    var DashboardTablixGridPresenter = function(_super) {
                        function DashboardTablixGridPresenter(sizeComputationManager) {
                            _super.call(this), this._sizeComputationManager = sizeComputationManager;
                        }
                        return __extends(DashboardTablixGridPresenter, _super), DashboardTablixGridPresenter.prototype.createRowPresenter = function() {
                            return new DashboardRowPresenter(this, this._owner.fillColumnsProportionally);
                        }, DashboardTablixGridPresenter.prototype.createColumnPresenter = function(index) {
                            return new DashboardColumnPresenter(this);
                        }, Object.defineProperty(DashboardTablixGridPresenter.prototype, "sizeComputationManager", {
                            get: function() {
                                return this._sizeComputationManager;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), DashboardTablixGridPresenter.prototype.getWidth = function() {
                            return this._sizeComputationManager.gridWidth;
                        }, DashboardTablixGridPresenter.prototype.getHeight = function() {
                            return this._sizeComputationManager.gridHeight;
                        }, DashboardTablixGridPresenter;
                    }(TablixGridPresenter);
                    internal.DashboardTablixGridPresenter = DashboardTablixGridPresenter;
                    var CanvasTablixGridPresenter = function(_super) {
                        function CanvasTablixGridPresenter(columnWidthManager) {
                            _super.call(this, columnWidthManager);
                        }
                        return __extends(CanvasTablixGridPresenter, _super), CanvasTablixGridPresenter.prototype.createRowPresenter = function() {
                            return new CanvasRowPresenter(this._owner.fillColumnsProportionally);
                        }, CanvasTablixGridPresenter.prototype.createColumnPresenter = function(index) {
                            return new CanvasColumnPresenter(this, index);
                        }, CanvasTablixGridPresenter.prototype.getWidth = function() {
                            return controls.HTMLElementUtils.getElementWidth(this._table);
                        }, CanvasTablixGridPresenter.prototype.getHeight = function() {
                            return controls.HTMLElementUtils.getElementHeight(this._table);
                        }, CanvasTablixGridPresenter;
                    }(TablixGridPresenter);
                    internal.CanvasTablixGridPresenter = CanvasTablixGridPresenter;
                }(internal = controls.internal || (controls.internal = {}));
            }(controls = visuals.controls || (visuals.controls = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi), __extends = (window.powerbitests, 
    window.InJs, window.debug, window.jasmine, window.Microsoft, this && this.__extends || function(d, b) {
        function __() {
            this.constructor = d;
        }
        for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
    });
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var controls;
            !function(controls) {
                var internal;
                !function(internal) {
                    var TablixDimensionRealizationManager = function() {
                        function TablixDimensionRealizationManager(binder) {
                            this._binder = binder, this._adjustmentFactor = 1;
                        }
                        return TablixDimensionRealizationManager.prototype._getOwner = function() {
                            return null;
                        }, Object.defineProperty(TablixDimensionRealizationManager.prototype, "binder", {
                            get: function() {
                                return this._binder;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(TablixDimensionRealizationManager.prototype, "adjustmentFactor", {
                            get: function() {
                                return this._adjustmentFactor;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(TablixDimensionRealizationManager.prototype, "itemsToRealizeCount", {
                            get: function() {
                                return this._itemsToRealizeCount;
                            },
                            set: function(count) {
                                this._itemsToRealizeCount = count;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(TablixDimensionRealizationManager.prototype, "itemsEstimatedContextualWidth", {
                            get: function() {
                                return this._itemsEstimatedContextualWidth;
                            },
                            set: function(contextualWidth) {
                                this._itemsEstimatedContextualWidth = contextualWidth;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), TablixDimensionRealizationManager.prototype.onStartRenderingIteration = function() {
                            var owner = this._getOwner();
                            owner.measureEnabled && !owner.done && this._getEstimatedItemsToRealizeCount(), 
                            this._realizedLeavesCount = 0;
                        }, TablixDimensionRealizationManager.prototype.onEndRenderingIteration = function(gridContextualWidth, filled) {
                            filled || this._getOwner().allItemsRealized || (this._adjustmentFactor *= this._getSizeAdjustment(gridContextualWidth));
                        }, TablixDimensionRealizationManager.prototype.onEndRenderingSession = function() {
                            this._adjustmentFactor = 1;
                        }, TablixDimensionRealizationManager.prototype.onCornerCellRealized = function(item, cell) {}, 
                        TablixDimensionRealizationManager.prototype.onHeaderRealized = function(item, cell, leaf) {
                            leaf && this._realizedLeavesCount++;
                        }, Object.defineProperty(TablixDimensionRealizationManager.prototype, "needsToRealize", {
                            get: function() {
                                return this._realizedLeavesCount < this._itemsToRealizeCount;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), TablixDimensionRealizationManager.prototype._getEstimatedItemsToRealizeCount = function() {}, 
                        TablixDimensionRealizationManager.prototype._getSizeAdjustment = function(gridContextualWidth) {
                            return 1;
                        }, TablixDimensionRealizationManager;
                    }();
                    internal.TablixDimensionRealizationManager = TablixDimensionRealizationManager;
                    var RowRealizationManager = function(_super) {
                        function RowRealizationManager() {
                            _super.apply(this, arguments);
                        }
                        return __extends(RowRealizationManager, _super), Object.defineProperty(RowRealizationManager.prototype, "owner", {
                            set: function(owner) {
                                this._owner = owner;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), RowRealizationManager.prototype._getOwner = function() {
                            return this._owner;
                        }, RowRealizationManager.prototype._getEstimatedItemsToRealizeCount = function() {
                            this.estimateRowsToRealizeCount();
                        }, RowRealizationManager.prototype.estimateRowsToRealizeCount = function() {
                            return this._owner.dimension.model ? void (this._owner.alignToEnd ? this.itemsToRealizeCount = this._owner.dimension.getItemsCount() - this._owner.dimension.getIntegerScrollOffset() + 1 : this.itemsToRealizeCount = Math.ceil(this._owner.contextualWidthToFill / (this._owner.owner.getEstimatedRowHeight() * this.adjustmentFactor) + this._owner.dimension.getFractionScrollOffset()) - this._owner.otherLayoutManager.dimension.getDepth() + 1) : void (this.itemsToRealizeCount = 0);
                        }, RowRealizationManager.prototype.getEstimatedRowHierarchyWidth = function() {
                            if (!this._owner.dimension.model || 0 === this._owner.dimension.getItemsCount()) return 0;
                            var levels = new RowWidths();
                            this.updateRowHiearchyEstimatedWidth(this._owner.dimension.model, this._owner.dimension._hierarchyNavigator.getIndex(this._owner.dimension.getFirstVisibleItem(0)), levels);
                            for (var levelsArray = levels.items, levelCount = levelsArray.length, width = 0, i = 0; levelCount > i; i++) {
                                var level = levelsArray[i];
                                width += 0 !== level.maxNonLeafWidth ? level.maxNonLeafWidth : level.maxLeafWidth;
                            }
                            return width;
                        }, RowRealizationManager.prototype.updateRowHiearchyEstimatedWidth = function(items, firstVisibleIndex, levels) {
                            if (!(0 > firstVisibleIndex)) for (var hierarchyNavigator = this._owner.owner.owner.hierarchyNavigator, binder = this.binder, length = hierarchyNavigator.getCount(items), i = firstVisibleIndex; length > i; i++) {
                                if (levels.leafCount === this.itemsToRealizeCount) return;
                                var item = hierarchyNavigator.getAt(items, i), label = binder.getHeaderLabel(item), itemWidth = this._owner.getEstimatedHeaderWidth(label, firstVisibleIndex), isLeaf = hierarchyNavigator.isLeaf(item), l = hierarchyNavigator.getLevel(item), level = levels.items[l];
                                level || (level = new RowWidth(), levels.items[l] = level), isLeaf ? (level.maxLeafWidth = Math.max(level.maxLeafWidth, itemWidth), 
                                levels.leafCount = levels.leafCount + 1) : (level.maxNonLeafWidth = Math.max(level.maxNonLeafWidth, itemWidth), 
                                this.updateRowHiearchyEstimatedWidth(hierarchyNavigator.getChildren(item), this._owner.dimension.getFirstVisibleChildIndex(item), levels));
                            }
                        }, RowRealizationManager.prototype._getSizeAdjustment = function(gridContextualWidth) {
                            return gridContextualWidth / ((this._owner.getRealizedItemsCount() - this._owner.dimension.getFractionScrollOffset()) * this._owner.owner.getEstimatedRowHeight());
                        }, RowRealizationManager;
                    }(TablixDimensionRealizationManager);
                    internal.RowRealizationManager = RowRealizationManager;
                    var ColumnRealizationManager = function(_super) {
                        function ColumnRealizationManager() {
                            _super.apply(this, arguments);
                        }
                        return __extends(ColumnRealizationManager, _super), Object.defineProperty(ColumnRealizationManager.prototype, "owner", {
                            set: function(owner) {
                                this._owner = owner;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), ColumnRealizationManager.prototype._getOwner = function() {
                            return this._owner;
                        }, ColumnRealizationManager.prototype._getEstimatedItemsToRealizeCount = function() {
                            this.estimateColumnsToRealizeCount(this.getEstimatedRowHierarchyWidth());
                        }, Object.defineProperty(ColumnRealizationManager.prototype, "rowRealizationManager", {
                            get: function() {
                                return this._owner.otherLayoutManager.realizationManager;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), ColumnRealizationManager.prototype.getEstimatedRowHierarchyWidth = function() {
                            return this._owner.otherLayoutManager.done ? this._owner.getOtherHierarchyContextualHeight() : this.rowRealizationManager.getEstimatedRowHierarchyWidth() * this.adjustmentFactor;
                        }, ColumnRealizationManager.prototype.estimateColumnsToRealizeCount = function(rowHierarchyWidth) {
                            var widthToFill = this._owner.contextualWidthToFill - rowHierarchyWidth;
                            if (!this._owner.dimension.model || powerbi.Double.lessOrEqualWithPrecision(widthToFill, 0, internal.DimensionLayoutManager._pixelPrecision)) return void (this.itemsToRealizeCount = 0);
                            var binder = this.binder, hierarchyNavigator = this._owner.owner.owner.hierarchyNavigator, startColumnIndex = this._owner.dimension.getIntegerScrollOffset(), endColumnIndex = this._owner.dimension.getItemsCount(), columnCount = endColumnIndex - startColumnIndex, startRowIndex = this._owner.otherLayoutManager.dimension.getIntegerScrollOffset(), endRowIndex = this._owner.otherLayoutManager.dimension.getItemsCount();
                            if (this.itemsEstimatedContextualWidth = 0, this._owner.alignToEnd) return void (this.itemsToRealizeCount = columnCount);
                            for (var i = startColumnIndex; endColumnIndex > i; i++) {
                                if (powerbi.Double.greaterOrEqualWithPrecision(this.itemsEstimatedContextualWidth, widthToFill, internal.DimensionLayoutManager._pixelPrecision)) return void (this.itemsToRealizeCount = i - startColumnIndex);
                                var maxWidth = 0, visibleSizeRatio = void 0;
                                visibleSizeRatio = i === startColumnIndex ? this._owner.getVisibleSizeRatio() : 1;
                                var columnMember = hierarchyNavigator.getLeafAt(this._owner.dimension.model, i), label = binder.getHeaderLabel(columnMember);
                                maxWidth = Math.max(maxWidth, this._owner.getEstimatedHeaderWidth(label, i));
                                for (var j = startRowIndex; endRowIndex > j; j++) {
                                    var intersection = hierarchyNavigator.getIntersection(hierarchyNavigator.getLeafAt(this._owner.otherLayoutManager.dimension.model, j), columnMember);
                                    label = binder.getCellContent(intersection), maxWidth = Math.max(maxWidth, this._owner.getEstimatedBodyCellWidth(label));
                                }
                                this.itemsEstimatedContextualWidth += maxWidth * visibleSizeRatio * this.adjustmentFactor;
                            }
                            this.itemsToRealizeCount = columnCount;
                        }, ColumnRealizationManager.prototype._getSizeAdjustment = function(gridContextualWidth) {
                            return gridContextualWidth / (this.getEstimatedRowHierarchyWidth() + this.itemsEstimatedContextualWidth);
                        }, ColumnRealizationManager;
                    }(TablixDimensionRealizationManager);
                    internal.ColumnRealizationManager = ColumnRealizationManager;
                    var RowWidths = function() {
                        function RowWidths() {
                            this.items = [], this.leafCount = 0;
                        }
                        return RowWidths;
                    }();
                    internal.RowWidths = RowWidths;
                    var RowWidth = function() {
                        function RowWidth() {
                            this.maxLeafWidth = 0, this.maxNonLeafWidth = 0;
                        }
                        return RowWidth;
                    }();
                    internal.RowWidth = RowWidth;
                }(internal = controls.internal || (controls.internal = {}));
            }(controls = visuals.controls || (visuals.controls = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var controls;
            !function(controls) {
                var internal;
                !function(internal) {
                    var TablixCell = function() {
                        function TablixCell(presenter, extension, row) {
                            this._scrollable = !1, this._presenter = presenter, this.extension = extension, 
                            this._presenter.initialize(this), this._row = row, this.item = null, this.type = null, 
                            this._horizontalOffset = 0, this._verticalOffset = 0, this._colSpan = 1, this._rowSpan = 1, 
                            this._containerWidth = -1, this._containerHeight = -1, this.contentHeight = this.contentWidth = 0, 
                            this.position = new internal.TablixUtils.CellPosition();
                        }
                        return TablixCell.prototype.unfixRowHeight = function() {
                            this._row.unfixSize();
                        }, Object.defineProperty(TablixCell.prototype, "colSpan", {
                            get: function() {
                                return this._colSpan;
                            },
                            set: function(value) {
                                this._colSpan !== value && (this._presenter.onColumnSpanChanged(value), this._colSpan = value, 
                                this._presenter.onContainerWidthChanged(-1));
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(TablixCell.prototype, "rowSpan", {
                            get: function() {
                                return this._rowSpan;
                            },
                            set: function(value) {
                                this._rowSpan !== value && (this._presenter.onRowSpanChanged(value), this._rowSpan = value, 
                                this._row.unfixSize());
                            },
                            enumerable: !0,
                            configurable: !0
                        }), TablixCell.prototype.getCellSpanningHeight = function() {
                            return this._row.getCellSpanningHeight(this);
                        }, Object.defineProperty(TablixCell.prototype, "textAlign", {
                            get: function() {
                                return this._textAlign;
                            },
                            set: function(value) {
                                value !== this._textAlign && (this._presenter.onTextAlignChanged(value), this._textAlign = value);
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(TablixCell.prototype, "horizontalOffset", {
                            get: function() {
                                return this._horizontalOffset;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(TablixCell.prototype, "verticalOffset", {
                            get: function() {
                                return this._verticalOffset;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), TablixCell.prototype.isScrollable = function() {
                            return this._scrollable;
                        }, TablixCell.prototype.clear = function() {
                            this.isScrollable() && this.initializeScrolling(), this._presenter.onClear(), this.setContainerWidth(-1), 
                            this.setContainerHeight(-1), this.contentHeight = this.contentWidth = 0;
                        }, TablixCell.prototype.initializeScrolling = function() {
                            this._presenter.onInitializeScrolling(), this._horizontalOffset = 0, this._verticalOffset = 0, 
                            1 === this.colSpan && this.setContainerWidth(-1), 1 === this.rowSpan && this.setContainerHeight(-1);
                        }, TablixCell.prototype.prepare = function(scrollable) {
                            this.isScrollable() && this.initializeScrolling(), this._scrollable = scrollable;
                        }, TablixCell.prototype.scrollVertically = function(height, offset) {
                            var offsetInPixels = Math.ceil(-height * offset);
                            this._verticalOffset = offsetInPixels, this.isScrollable() ? (this._presenter.onVerticalScroll(height, offsetInPixels), 
                            this.setContainerHeight(height + offsetInPixels)) : this.setContainerHeight(this._row.getCellSpanningHeight(this) + offsetInPixels);
                        }, TablixCell.prototype.scrollHorizontally = function(width, offset) {
                            this.isScrollable() && (this._presenter.onHorizontalScroll(width, offset), this.setContainerWidth(width + offset));
                        }, TablixCell.prototype.setContainerWidth = function(value) {
                            value !== this._containerWidth && (this._containerWidth = value, this._presenter.onContainerWidthChanged(value));
                        }, Object.defineProperty(TablixCell.prototype, "containerWidth", {
                            get: function() {
                                return this._containerWidth;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), TablixCell.prototype.setContainerHeight = function(value) {
                            0 > value && (value = -1), value !== this._containerHeight && (this._containerHeight = value, 
                            this._presenter.onContinerHeightChanged(value));
                        }, Object.defineProperty(TablixCell.prototype, "containerHeight", {
                            get: function() {
                                return this._containerHeight;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), TablixCell.prototype.applyStyle = function(style) {
                            style && (style.applyStyle(this), this.contentHeight += style.getExtraBottom() + style.getExtraTop(), 
                            this.contentWidth += style.getExtraLeft() + style.getExtraRight());
                        }, TablixCell.prototype.enableHorizontalResize = function(enable, handler) {
                            this._presenter.enableHorizontalResize(enable, handler);
                        }, TablixCell;
                    }();
                    internal.TablixCell = TablixCell;
                    var TablixColumn = function() {
                        function TablixColumn(presenter, columnIndex) {
                            this._presenter = presenter, this._presenter.initialize(this), this._containerWidth = -1, 
                            this._width = -1, this._sizeFixed = !1, this._aligningWidth = -1, this._fixedToAligningWidth = !1, 
                            this._items = [], this._itemType = null, this._footerCell = null, this._columnIndex = columnIndex;
                        }
                        return TablixColumn.prototype.initialize = function(owner) {
                            this._owner = owner, this._realizedRowHeaders = [], this._realizedColumnHeaders = [], 
                            this._realizedCornerCells = [], this._realizedBodyCells = [];
                        }, Object.defineProperty(TablixColumn.prototype, "owner", {
                            get: function() {
                                return this._owner;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), TablixColumn.prototype.getType = function() {
                            return this._realizedCornerCells.length > 0 ? 0 : 2;
                        }, TablixColumn.prototype.getColumnHeadersOrCorners = function() {
                            return this._realizedCornerCells.length > 0 ? this._realizedCornerCells : this._realizedColumnHeaders;
                        }, TablixColumn.prototype.columnHeadersOrCornersEqual = function(newType, headers, hierarchyNavigator) {
                            if (this._items.length !== headers.length) return !1;
                            for (var count = this._items.length, i = 0; count > i; i++) if (!this.columnHeaderOrCornerEquals(this._itemType, this._items[i], newType, headers[i].item, hierarchyNavigator)) return !1;
                            return !0;
                        }, Object.defineProperty(TablixColumn.prototype, "itemType", {
                            get: function() {
                                return this._itemType;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), TablixColumn.prototype.getLeafItem = function() {
                            return 0 === this._items.length ? null : this._items[this._items.length - 1];
                        }, TablixColumn.prototype.columnHeaderOrCornerEquals = function(type1, item1, type2, item2, hierarchyNavigator) {
                            if (type1 !== type2) return !1;
                            if (0 === type1) {
                                if (!hierarchyNavigator.cornerCellItemEquals(item1, item2)) return !1;
                            } else if (!hierarchyNavigator.headerItemEquals(item1, item2)) return !1;
                            return !0;
                        }, TablixColumn.prototype.OnLeafRealized = function(hierarchyNavigator) {
                            var type = this.getType(), columnHeadersOrCorners = this.getColumnHeadersOrCorners();
                            if (this.columnHeadersOrCornersEqual(type, columnHeadersOrCorners, hierarchyNavigator)) this.clearSpanningCellsWidth(this._realizedColumnHeaders); else {
                                var count = columnHeadersOrCorners.length;
                                this._items = [];
                                for (var i = 0; count > i; i++) this._items.push(columnHeadersOrCorners[i].item);
                                this._itemType = type, this.clearSize();
                            }
                        }, TablixColumn.prototype.clearSpanningCellsWidth = function(cells) {
                            for (var i = 0; i < cells.length; i++) {
                                var cell = cells[i];
                                cell.colSpan > 1 && cell.setContainerWidth(-1);
                            }
                        }, TablixColumn.prototype.addCornerCell = function(cell) {
                            cell._column = this, this._realizedCornerCells.push(cell), cell.setContainerWidth(this._containerWidth);
                        }, TablixColumn.prototype.addRowHeader = function(cell) {
                            cell._column = this, this._realizedRowHeaders.push(cell), cell.setContainerWidth(this._containerWidth);
                        }, TablixColumn.prototype.addColumnHeader = function(cell, isLeaf) {
                            cell._column = this, this._realizedColumnHeaders.push(cell), isLeaf && cell.setContainerWidth(this._containerWidth);
                        }, TablixColumn.prototype.addBodyCell = function(cell) {
                            cell._column = this, this._realizedBodyCells.push(cell), cell.setContainerWidth(this._containerWidth);
                        }, Object.defineProperty(TablixColumn.prototype, "footer", {
                            get: function() {
                                return this._footerCell;
                            },
                            set: function(footerCell) {
                                this._footerCell = footerCell, footerCell._column = this, footerCell.setContainerWidth(this._containerWidth);
                            },
                            enumerable: !0,
                            configurable: !0
                        }), TablixColumn.prototype.onResize = function(width) {
                            width !== this.getContentContextualWidth() && (this._containerWidth = width, this.setContainerWidth(this._containerWidth), 
                            this._sizeFixed = !0, this._fixedToAligningWidth = !1, this._aligningWidth = -1);
                        }, TablixColumn.prototype.onResizeEnd = function(width) {
                            var gridPresenter = this.owner._presenter;
                            gridPresenter && gridPresenter.invokeColumnResizeEndCallback(this, width);
                        }, TablixColumn.prototype.fixSize = function() {
                            var shouldAlign = -1 !== this._aligningWidth, switched = shouldAlign !== this._fixedToAligningWidth;
                            (!this._sizeFixed || switched || shouldAlign) && (-1 === this._aligningWidth ? this.setContainerWidth(this._containerWidth) : this.setContainerWidth(this._aligningWidth), 
                            this._sizeFixed = !0, this._fixedToAligningWidth = -1 !== this._aligningWidth);
                        }, TablixColumn.prototype.clearSize = function() {
                            this._containerWidth = -1, this.setContainerWidth(this._containerWidth), this._sizeFixed = !1;
                        }, TablixColumn.prototype.getContentContextualWidth = function() {
                            return this._containerWidth;
                        }, TablixColumn.prototype.getCellIContentContextualWidth = function(cell) {
                            return this._presenter.getCellWidth(cell);
                        }, TablixColumn.prototype.getCellSpanningWidthWithScrolling = function(cell, tablixGrid) {
                            var width = this.getContextualWidth() + this.getScrollingOffset();
                            if (cell.colSpan > 1) for (var index = this.getIndex(tablixGrid), columns = tablixGrid.realizedColumns, i = 1; i < cell.colSpan; i++) width += columns[i + index].getContextualWidth();
                            return width;
                        }, TablixColumn.prototype.getScrollingOffset = function() {
                            var offset = 0;
                            return this._realizedColumnHeaders.length > 0 && (offset = _.last(this._realizedColumnHeaders).horizontalOffset), 
                            offset;
                        }, TablixColumn.prototype.getContextualWidth = function() {
                            return -1 !== this._width && -1 !== this._containerWidth || (this._width = this._presenter.getWidth()), 
                            this._width;
                        }, TablixColumn.prototype.calculateSize = function() {
                            if (this._sizeFixed) return this._containerWidth;
                            var contentWidth = 0, persistedWidth = this._presenter.getPersistedWidth();
                            if (null != persistedWidth) {
                                contentWidth = persistedWidth;
                                for (var i = 0, len = this._realizedColumnHeaders.length; len - 1 > i; i++) {
                                    var cell = this._realizedColumnHeaders[i];
                                    1 === cell.colSpan && (contentWidth = Math.max(contentWidth, this._presenter.getCellWidth(cell)));
                                }
                                return this._containerWidth = contentWidth;
                            }
                            for (var _i = 0, _a = this._realizedColumnHeaders; _i < _a.length; _i++) {
                                var cell = _a[_i];
                                1 === cell.colSpan && (contentWidth = Math.max(contentWidth, this._presenter.getCellWidth(cell)));
                            }
                            for (var _b = 0, _c = this._realizedRowHeaders; _b < _c.length; _b++) {
                                var cell = _c[_b];
                                1 === cell.colSpan && (contentWidth = Math.max(contentWidth, this._presenter.getCellWidth(cell)));
                            }
                            for (var _d = 0, _e = this._realizedCornerCells; _d < _e.length; _d++) {
                                var cell = _e[_d];
                                contentWidth = Math.max(contentWidth, this._presenter.getCellWidth(cell));
                            }
                            for (var _f = 0, _g = this._realizedBodyCells; _f < _g.length; _f++) {
                                var cell = _g[_f];
                                contentWidth = Math.max(contentWidth, this._presenter.getCellWidth(cell));
                            }
                            return null !== this._footerCell && 1 === this._footerCell.colSpan && (contentWidth = Math.max(contentWidth, this._presenter.getCellWidth(this._footerCell))), 
                            this._containerWidth = contentWidth;
                        }, TablixColumn.prototype.setAligningContextualWidth = function(size) {
                            this._aligningWidth = size;
                        }, TablixColumn.prototype.getAligningContextualWidth = function() {
                            return this._aligningWidth;
                        }, TablixColumn.prototype.setContainerWidth = function(value) {
                            for (var _i = 0, _a = this._realizedColumnHeaders; _i < _a.length; _i++) {
                                var cell = _a[_i];
                                1 === cell.colSpan && cell.setContainerWidth(value);
                            }
                            for (var _b = 0, _c = this._realizedRowHeaders; _b < _c.length; _b++) {
                                var cell = _c[_b];
                                1 === cell.colSpan && cell.setContainerWidth(value);
                            }
                            for (var _d = 0, _e = this._realizedCornerCells; _d < _e.length; _d++) {
                                var cell = _e[_d];
                                cell.setContainerWidth(value);
                            }
                            for (var _f = 0, _g = this._realizedBodyCells; _f < _g.length; _f++) {
                                var cell = _g[_f];
                                cell.setContainerWidth(value);
                            }
                            null !== this._footerCell && 1 === this._footerCell.colSpan && this._footerCell.setContainerWidth(value), 
                            this._width = value;
                        }, TablixColumn.prototype.getTablixCell = function() {
                            var realizedCells = this._realizedColumnHeaders.length > 0 ? this._realizedColumnHeaders : this._realizedCornerCells;
                            return realizedCells[realizedCells.length - 1];
                        }, TablixColumn.prototype.getIndex = function(grid) {
                            return grid.realizedColumns.indexOf(this);
                        }, TablixColumn.prototype.getHeaders = function() {
                            return this._realizedColumnHeaders;
                        }, TablixColumn.prototype.getOtherDimensionHeaders = function() {
                            return this._realizedRowHeaders;
                        }, TablixColumn.prototype.getCellContextualSpan = function(cell) {
                            return cell.colSpan;
                        }, TablixColumn.prototype.getOtherDimensionOwner = function(cell) {
                            return cell._row;
                        }, TablixColumn;
                    }();
                    internal.TablixColumn = TablixColumn;
                    var TablixRow = function() {
                        function TablixRow(presenter) {
                            this._containerHeight = -1, this._presenter = presenter, this._presenter.initialize(this), 
                            this._allocatedCells = [], this._heightFixed = !1, this._containerHeight = -1, this._height = -1;
                        }
                        return TablixRow.prototype.initialize = function(owner) {
                            this._owner = owner, this._realizedRowHeaders = [], this._realizedBodyCells = [], 
                            this._realizedCornerCells = [], this._realizedColumnHeaders = [], this._realizedCellsCount = 0;
                        }, Object.defineProperty(TablixRow.prototype, "presenter", {
                            get: function() {
                                return this._presenter;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(TablixRow.prototype, "owner", {
                            get: function() {
                                return this._owner;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), TablixRow.prototype.releaseUnusedCells = function(owner) {
                            this.releaseCells(owner, this._realizedCellsCount);
                        }, TablixRow.prototype.releaseAllCells = function(owner) {
                            this.releaseCells(owner, 0);
                        }, TablixRow.prototype.releaseCells = function(owner, startIndex) {
                            for (var cells = this._allocatedCells, length = cells.length, i = startIndex; length > i; i++) {
                                var cell = cells[i];
                                owner._unbindCell(cell), cell.clear();
                            }
                        }, TablixRow.prototype.moveScrollableCellsToEnd = function(count) {
                            for (var frontIndex = Math.max(this._realizedRowHeaders.length, this._realizedCornerCells.length), i = frontIndex; frontIndex + count > i; i++) {
                                var cell = this._allocatedCells[i];
                                this._presenter.onRemoveCell(cell), this._presenter.onAppendCell(cell), this._allocatedCells.push(cell);
                            }
                            this._allocatedCells.splice(frontIndex, count);
                        }, TablixRow.prototype.moveScrollableCellsToStart = function(count) {
                            for (var frontIndex = Math.max(this._realizedRowHeaders.length, this._realizedCornerCells.length), i = frontIndex; frontIndex + count > i; i++) {
                                var cell = this._allocatedCells.pop();
                                this._presenter.onRemoveCell(cell), this._presenter.onInsertCellBefore(cell, this._allocatedCells[frontIndex]), 
                                this._allocatedCells.splice(frontIndex, 0, cell);
                            }
                        }, TablixRow.prototype.getOrCreateCornerCell = function(column) {
                            var cell = this.getOrCreateCell();
                            return cell.prepare(!1), column.addCornerCell(cell), this._realizedCornerCells.push(cell), 
                            cell.setContainerHeight(this._containerHeight), cell;
                        }, TablixRow.prototype.getOrCreateRowHeader = function(column, scrollable, leaf) {
                            var cell = this.getOrCreateCell();
                            return cell.prepare(scrollable), column.addRowHeader(cell), this._realizedRowHeaders.push(cell), 
                            leaf && cell.setContainerHeight(this._containerHeight), cell;
                        }, TablixRow.prototype.getOrCreateColumnHeader = function(column, scrollable, leaf) {
                            var cell = this.getOrCreateCell();
                            return cell.prepare(scrollable), column.addColumnHeader(cell, leaf), this._realizedColumnHeaders.push(cell), 
                            cell.setContainerHeight(this._containerHeight), cell;
                        }, TablixRow.prototype.getOrCreateBodyCell = function(column, scrollable) {
                            var cell = this.getOrCreateCell();
                            return cell.prepare(scrollable), column.addBodyCell(cell), this._realizedBodyCells.push(cell), 
                            cell.setContainerHeight(this._containerHeight), cell;
                        }, TablixRow.prototype.getOrCreateFooterRowHeader = function(column) {
                            var cell = this.getOrCreateCell();
                            return cell.prepare(!1), column.footer = cell, this._realizedRowHeaders.push(cell), 
                            cell.setContainerHeight(this._containerHeight), cell;
                        }, TablixRow.prototype.getOrCreateFooterBodyCell = function(column, scrollable) {
                            var cell = this.getOrCreateCell();
                            return cell.prepare(scrollable), column.footer = cell, this._realizedBodyCells.push(cell), 
                            cell.setContainerHeight(this._containerHeight), cell;
                        }, TablixRow.prototype.getRowHeaderLeafIndex = function() {
                            for (var index = -1, count = this._allocatedCells.length, i = 0; count > i && 1 === this._allocatedCells[i].type; i++) index++;
                            return index;
                        }, TablixRow.prototype.getAllocatedCellAt = function(index) {
                            return this._allocatedCells[index];
                        }, TablixRow.prototype.moveCellsBy = function(delta) {
                            if (0 !== this._allocatedCells.length) if (delta > 0) for (var refCell = this._allocatedCells[0], i = 0; delta > i; i++) {
                                var cell = this.createCell(this);
                                this._presenter.onInsertCellBefore(cell, refCell), this._allocatedCells.unshift(cell), 
                                refCell = cell;
                            } else {
                                delta = -delta;
                                for (var i = 0; delta > i; i++) this._presenter.onRemoveCell(this._allocatedCells[i]);
                                this._allocatedCells.splice(0, delta);
                            }
                        }, TablixRow.prototype.getRealizedCellCount = function() {
                            return this._realizedCellsCount;
                        }, TablixRow.prototype.getRealizedHeadersCount = function() {
                            return this._realizedRowHeaders.length;
                        }, TablixRow.prototype.getRealizedHeaderAt = function(index) {
                            return this._realizedRowHeaders[index];
                        }, TablixRow.prototype.getTablixCell = function() {
                            var realizedCells;
                            return realizedCells = this._realizedRowHeaders.length > 0 ? this._realizedRowHeaders : this._realizedCornerCells.length > 0 ? this._realizedCornerCells : this._realizedColumnHeaders, 
                            realizedCells[realizedCells.length - 1];
                        }, TablixRow.prototype.getOrCreateEmptySpaceCell = function() {
                            var cell = this._allocatedCells[this._realizedCellsCount];
                            return void 0 === cell && (cell = this.createCell(this), this._allocatedCells[this._realizedCellsCount] = cell, 
                            this._presenter.onAppendCell(cell)), cell;
                        }, TablixRow.prototype.createCell = function(row) {
                            var presenter = this._presenter.createCellPresenter(this._owner.owner.layoutManager.getLayoutKind());
                            return new TablixCell(presenter, presenter, this);
                        }, TablixRow.prototype.getOrCreateCell = function() {
                            var cell = this._allocatedCells[this._realizedCellsCount];
                            return void 0 === cell ? (cell = this.createCell(this), this._allocatedCells[this._realizedCellsCount] = cell, 
                            this._presenter.onAppendCell(cell)) : (cell.colSpan = 1, cell.rowSpan = 1), this._realizedCellsCount = this._realizedCellsCount + 1, 
                            cell;
                        }, TablixRow.prototype.onResize = function(height) {
                            height !== this.getContentContextualWidth() && (this._containerHeight = height, 
                            this.setContentHeight(), this._heightFixed = !0, this.setAligningContextualWidth(-1));
                        }, TablixRow.prototype.onResizeEnd = function(height) {}, TablixRow.prototype.fixSize = function() {
                            this.sizeFixed() || (this.setContentHeight(), this._heightFixed = !0);
                        }, TablixRow.prototype.unfixSize = function() {
                            this._heightFixed = !1, this._height = -1;
                        }, TablixRow.prototype.getContentContextualWidth = function() {
                            return this._containerHeight;
                        }, TablixRow.prototype.getCellIContentContextualWidth = function(cell) {
                            return this.presenter.getCellContentHeight(cell);
                        }, TablixRow.prototype.getCellSpanningHeight = function(cell) {
                            var height = this.getContextualWidth();
                            if (cell.rowSpan > 1) for (var index = this.getIndex(this.owner), rows = this.owner.realizedRows, i = 1; i < cell.rowSpan; i++) height += rows[i + index].getContextualWidth();
                            return height;
                        }, TablixRow.prototype.getContextualWidth = function() {
                            return -1 !== this._height && -1 !== this._containerHeight || (this._height = this._presenter.getHeight()), 
                            this._height;
                        }, TablixRow.prototype.sizeFixed = function() {
                            return this._heightFixed;
                        }, TablixRow.prototype.calculateSize = function() {
                            if (this._heightFixed) return this._containerHeight;
                            for (var contentHeight = 0, count = this._realizedRowHeaders.length, i = 0; count > i; i++) {
                                var cell = this._realizedRowHeaders[i];
                                1 === cell.rowSpan && (contentHeight = Math.max(contentHeight, this._presenter.getCellContentHeight(cell)));
                            }
                            count = this._realizedCornerCells.length;
                            for (var i = 0; count > i; i++) contentHeight = Math.max(contentHeight, this._presenter.getCellContentHeight(this._realizedCornerCells[i]));
                            count = this._realizedColumnHeaders.length;
                            for (var i = 0; count > i; i++) {
                                var cell = this._realizedColumnHeaders[i];
                                1 === cell.rowSpan && (contentHeight = Math.max(contentHeight, this._presenter.getCellContentHeight(cell)));
                            }
                            count = this._realizedBodyCells.length;
                            for (var i = 0; count > i; i++) contentHeight = Math.max(contentHeight, this._presenter.getCellContentHeight(this._realizedBodyCells[i]));
                            return this._containerHeight = contentHeight;
                        }, TablixRow.prototype.setAligningContextualWidth = function(size) {}, TablixRow.prototype.getAligningContextualWidth = function() {
                            return -1;
                        }, TablixRow.prototype.setContentHeight = function() {
                            for (var count = this._realizedRowHeaders.length, i = count - 1; i >= 0; i--) {
                                var cell = this._realizedRowHeaders[i];
                                cell.setContainerHeight(this._containerHeight), cell.rowSpan > 1 && cell.setContainerHeight(this.getCellSpanningHeight(cell));
                            }
                            count = this._realizedCornerCells.length;
                            for (var i = 0; count > i; i++) this._realizedCornerCells[i].setContainerHeight(this._containerHeight);
                            count = this._realizedColumnHeaders.length;
                            for (var i = 0; count > i; i++) {
                                var cell = this._realizedColumnHeaders[i];
                                cell.setContainerHeight(this._containerHeight), cell.rowSpan > 1 && cell.setContainerHeight(this.getCellSpanningHeight(cell));
                            }
                            count = this._realizedBodyCells.length;
                            for (var i = 0; count > i; i++) this._realizedBodyCells[i].setContainerHeight(this._containerHeight);
                            this._height = -1;
                        }, TablixRow.prototype.getIndex = function(grid) {
                            return grid.realizedRows.indexOf(this);
                        }, TablixRow.prototype.getHeaders = function() {
                            return this._realizedRowHeaders;
                        }, TablixRow.prototype.getOtherDimensionHeaders = function() {
                            return this._realizedColumnHeaders;
                        }, TablixRow.prototype.getCellContextualSpan = function(cell) {
                            return cell.rowSpan;
                        }, TablixRow.prototype.getOtherDimensionOwner = function(cell) {
                            return cell._column;
                        }, TablixRow;
                    }();
                    internal.TablixRow = TablixRow;
                    var TablixGrid = function() {
                        function TablixGrid(presenter) {
                            this._presenter = presenter, this._footerRow = null;
                        }
                        return TablixGrid.prototype.initialize = function(owner, gridHost, footerHost) {
                            this._owner = owner, this._presenter.initialize(this, gridHost, footerHost, owner), 
                            this.fillColumnsProportionally = !1, this._realizedRows = [], this._realizedColumns = [], 
                            this._emptySpaceHeaderCell = null, this._emptyFooterSpaceCell = null;
                        }, Object.defineProperty(TablixGrid.prototype, "owner", {
                            get: function() {
                                return this._owner;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(TablixGrid.prototype, "fillColumnsProportionally", {
                            get: function() {
                                return this._fillColumnsProportionally;
                            },
                            set: function(value) {
                                this._fillColumnsProportionally !== value && (this._fillColumnsProportionally = value, 
                                this._presenter.onFillColumnsProportionallyChanged(value));
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(TablixGrid.prototype, "realizedColumns", {
                            get: function() {
                                return this._realizedColumns;
                            },
                            set: function(columns) {
                                this._realizedColumns = columns;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(TablixGrid.prototype, "realizedRows", {
                            get: function() {
                                return this._realizedRows;
                            },
                            set: function(rows) {
                                this._realizedRows = rows;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(TablixGrid.prototype, "footerRow", {
                            get: function() {
                                return this._footerRow;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(TablixGrid.prototype, "emptySpaceHeaderCell", {
                            get: function() {
                                return this._emptySpaceHeaderCell;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(TablixGrid.prototype, "emptySpaceFooterCell", {
                            get: function() {
                                return this._emptyFooterSpaceCell;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), TablixGrid.prototype.ShowEmptySpaceCells = function(rowSpan, width) {
                            0 !== this._realizedRows.length && (0 === this._realizedRows.length || this._emptySpaceHeaderCell || (this._emptySpaceHeaderCell = this._realizedRows[0].getOrCreateEmptySpaceCell(), 
                            this._emptySpaceHeaderCell.rowSpan = rowSpan, this._emptySpaceHeaderCell.colSpan = 1, 
                            this._emptySpaceHeaderCell.setContainerWidth(width)), this._footerRow && null === this._emptyFooterSpaceCell && (this._emptyFooterSpaceCell = this._footerRow.getOrCreateEmptySpaceCell(), 
                            this._emptyFooterSpaceCell.rowSpan = 1, this._emptyFooterSpaceCell.colSpan = 1, 
                            this._emptyFooterSpaceCell.setContainerWidth(width)));
                        }, TablixGrid.prototype.HideEmptySpaceCells = function() {
                            this._emptySpaceHeaderCell && (this._emptySpaceHeaderCell.clear(), this._emptySpaceHeaderCell = null), 
                            this._emptyFooterSpaceCell && (this._emptyFooterSpaceCell.clear(), this._emptyFooterSpaceCell = null);
                        }, TablixGrid.prototype.onStartRenderingSession = function(clear) {
                            clear && (this.clearRows(), this.clearColumns());
                        }, TablixGrid.prototype.onStartRenderingIteration = function() {
                            this.initializeRows(), this.initializeColumns();
                        }, TablixGrid.prototype.onEndRenderingIteration = function() {
                            var rows = this._rows;
                            if (void 0 !== rows) for (var rowCount = rows.length, i = 0; rowCount > i; i++) rows[i].releaseUnusedCells(this._owner);
                            this._footerRow && this._footerRow.releaseUnusedCells(this._owner);
                        }, TablixGrid.prototype.getOrCreateRow = function(rowIndex) {
                            var currentRow = this._rows[rowIndex];
                            return void 0 === currentRow && (currentRow = new TablixRow(this._presenter.createRowPresenter()), 
                            currentRow.initialize(this), this._presenter.onAppendRow(currentRow), this._rows[rowIndex] = currentRow), 
                            void 0 === this._realizedRows[rowIndex] && (this._realizedRows[rowIndex] = currentRow), 
                            currentRow;
                        }, TablixGrid.prototype.getOrCreateFootersRow = function() {
                            return null === this._footerRow && (this._footerRow = new TablixRow(this._presenter.createRowPresenter()), 
                            this._footerRow.initialize(this), this._presenter.onAddFooterRow(this._footerRow)), 
                            this._footerRow;
                        }, TablixGrid.prototype.moveRowsToEnd = function(moveFromIndex, count) {
                            for (var i = 0; count > i; i++) {
                                var row = this._rows[i + moveFromIndex];
                                row.unfixSize(), this._presenter.onRemoveRow(row), this._presenter.onAppendRow(row), 
                                this._rows.push(row);
                            }
                            this._rows.splice(moveFromIndex, count);
                        }, TablixGrid.prototype.moveRowsToStart = function(moveToIndex, count) {
                            for (var refRow = this._rows[moveToIndex], i = 0; count > i; i++) {
                                var row = this._rows.pop();
                                row.unfixSize(), this._presenter.onRemoveRow(row), this._presenter.onInsertRowBefore(row, refRow), 
                                this._rows.splice(moveToIndex + i, 0, row);
                            }
                        }, TablixGrid.prototype.moveColumnsToEnd = function(moveFromIndex, count) {
                            for (var firstCol = this._rows[0]._realizedCornerCells.length, leafStartDepth = Math.max(this._columns[firstCol]._realizedColumnHeaders.length - 1, 0), i = leafStartDepth; i < this._rows.length; i++) this._rows[i].moveScrollableCellsToEnd(count);
                            for (var i = 0; count > i; i++) {
                                var column = this._columns[i + moveFromIndex];
                                this._columns.push(column);
                            }
                            this._columns.splice(moveFromIndex, count);
                        }, TablixGrid.prototype.moveColumnsToStart = function(moveToIndex, count) {
                            for (var firstCol = this._rows[0]._realizedCornerCells.length, leafStartDepth = Math.max(this._columns[firstCol]._realizedColumnHeaders.length - 1, 0), i = leafStartDepth; i < this._rows.length; i++) this._rows[i].moveScrollableCellsToStart(count);
                            for (var i = 0; count > i; i++) {
                                var column = this._columns.pop();
                                this._columns.splice(moveToIndex + i, 0, column);
                            }
                        }, TablixGrid.prototype.getOrCreateColumn = function(columnIndex) {
                            var currentColumn = this._columns[columnIndex];
                            return void 0 === currentColumn && (currentColumn = new TablixColumn(this._presenter.createColumnPresenter(columnIndex), columnIndex), 
                            currentColumn.initialize(this), this._columns[columnIndex] = currentColumn), void 0 === this._realizedColumns[columnIndex] && (this._realizedColumns[columnIndex] = currentColumn), 
                            currentColumn;
                        }, TablixGrid.prototype.initializeColumns = function() {
                            this._columns || (this._columns = []);
                            for (var length = this._columns.length, i = 0; length > i; i++) this._columns[i].initialize(this);
                            this._realizedColumns = [];
                        }, TablixGrid.prototype.clearColumns = function() {
                            this._columns = null, this._realizedColumns = null;
                        }, TablixGrid.prototype.initializeRows = function() {
                            var hasFooter = this._owner.rowDimension.hasFooter() && null !== this._footerRow;
                            this._realizedRows = [], this._rows || (this._rows = []);
                            for (var rows = this._rows, length = rows.length, i = 0; length > i; i++) rows[i].initialize(this);
                            hasFooter && (this._footerRow || this.getOrCreateFootersRow(), this._footerRow.initialize(this));
                        }, TablixGrid.prototype.clearRows = function() {
                            var rows = this._rows;
                            if (rows) {
                                for (var length_1 = rows.length, i = 0; length_1 > i; i++) rows[i].releaseAllCells(this._owner);
                                this._footerRow && this._footerRow.releaseAllCells(this._owner), this._presenter.onClear(), 
                                this._footerRow = null, this._rows = null, this._realizedRows = null;
                            }
                        }, TablixGrid.prototype.getWidth = function() {
                            return this._presenter.getWidth();
                        }, TablixGrid.prototype.getHeight = function() {
                            return this._presenter.getHeight();
                        }, TablixGrid;
                    }();
                    internal.TablixGrid = TablixGrid;
                }(internal = controls.internal || (controls.internal = {}));
            }(controls = visuals.controls || (visuals.controls = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi, __extends = (window.powerbitests, 
    window.InJs, window.debug, window.jasmine, window.Microsoft, this && this.__extends || function(d, b) {
        function __() {
            this.constructor = d;
        }
        for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
    });
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var controls;
            !function(controls) {
                var internal;
                !function(internal) {
                    var PixelConverter = jsCommon.PixelConverter, SizeComputationManager = function() {
                        function SizeComputationManager() {}
                        return Object.defineProperty(SizeComputationManager.prototype, "visibleWidth", {
                            get: function() {
                                return this._viewport ? this._viewport.width : 0;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(SizeComputationManager.prototype, "visibleHeight", {
                            get: function() {
                                return this._viewport ? this._viewport.height : 0;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(SizeComputationManager.prototype, "gridWidth", {
                            get: function() {
                                return this.visibleWidth;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(SizeComputationManager.prototype, "gridHeight", {
                            get: function() {
                                return this.visibleHeight;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(SizeComputationManager.prototype, "rowHeight", {
                            get: function() {
                                return this._cellHeight;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(SizeComputationManager.prototype, "cellWidth", {
                            get: function() {
                                return this._cellWidth;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(SizeComputationManager.prototype, "cellHeight", {
                            get: function() {
                                return this._cellHeight;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(SizeComputationManager.prototype, "contentWidth", {
                            get: function() {
                                return this._cellWidth;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(SizeComputationManager.prototype, "contentHeight", {
                            get: function() {
                                return this._cellHeight;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), SizeComputationManager.prototype.updateColumnCount = function(columnCount) {
                            this._columnCount = columnCount;
                        }, SizeComputationManager.prototype.updateRowHeight = function(rowHeight) {
                            this._cellHeight = rowHeight;
                        }, SizeComputationManager.prototype.updateScalingFactor = function(scalingFactor) {
                            this._scalingFactor = scalingFactor, this._cellWidth = this.computeColumnWidth(this._columnCount);
                        }, SizeComputationManager.prototype.updateViewport = function(viewport) {
                            this._viewport = viewport, this._cellWidth = this.computeColumnWidth(this._columnCount), 
                            this._cellHeight = this.computeColumnHeight();
                        }, SizeComputationManager.prototype.computeColumnWidth = function(totalColumnCount) {
                            var scalingFactor = this._scalingFactor;
                            scalingFactor || (scalingFactor = 1);
                            var minimumColumnWidth = scalingFactor * SizeComputationManager.TablixMinimumColumnWidth, maxAllowedColumns = Math.floor(this._viewport.width / minimumColumnWidth);
                            return this.fitToColumnCount(maxAllowedColumns, totalColumnCount);
                        }, SizeComputationManager.prototype.computeColumnHeight = function() {
                            if (!this.hasImageContent) return this._cellHeight;
                            var width = this._viewport.width;
                            return 250 >= width ? 20 : 510 >= width ? 51 : 770 >= width ? 52 : void 0;
                        }, SizeComputationManager.prototype.fitToColumnCount = function(maxAllowedColumnCount, totalColumnCount) {
                            var columnsToFit = Math.min(maxAllowedColumnCount, totalColumnCount);
                            return Math.floor(this._viewport.width / columnsToFit);
                        }, SizeComputationManager.TablixMinimumColumnWidth = 75, SizeComputationManager;
                    }();
                    internal.SizeComputationManager = SizeComputationManager;
                    var DimensionLayoutManager = function() {
                        function DimensionLayoutManager(owner, grid, realizationManager) {
                            this._owner = owner, this._grid = grid, this._lastScrollOffset = null, this._isScrolling = !1, 
                            this._fixedSizeEnabled = !0, this._done = !1, this._realizationManager = realizationManager;
                        }
                        return Object.defineProperty(DimensionLayoutManager.prototype, "owner", {
                            get: function() {
                                return this._owner;
                            },
                            set: function(owner) {
                                this._owner = owner;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(DimensionLayoutManager.prototype, "realizationManager", {
                            get: function() {
                                return this._realizationManager;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(DimensionLayoutManager.prototype, "fixedSizeEnabled", {
                            get: function() {
                                return this._fixedSizeEnabled;
                            },
                            set: function(enable) {
                                this._fixedSizeEnabled = enable;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), DimensionLayoutManager.prototype.onCornerCellRealized = function(item, cell, leaf) {
                            this._realizationManager.onCornerCellRealized(item, cell);
                        }, DimensionLayoutManager.prototype.onHeaderRealized = function(item, cell, leaf) {
                            this._realizationManager.onHeaderRealized(item, cell, leaf);
                        }, Object.defineProperty(DimensionLayoutManager.prototype, "needsToRealize", {
                            get: function() {
                                return this._realizationManager.needsToRealize;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), DimensionLayoutManager.prototype.getVisibleSizeRatio = function() {
                            return 1 - this.dimension.getFractionScrollOffset();
                        }, Object.defineProperty(DimensionLayoutManager.prototype, "alignToEnd", {
                            get: function() {
                                return this._alignToEnd;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(DimensionLayoutManager.prototype, "done", {
                            get: function() {
                                return this._done;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), DimensionLayoutManager.prototype._requiresMeasure = function() {
                            return !0;
                        }, DimensionLayoutManager.prototype.startScrollingSession = function() {
                            this._isScrolling = !0;
                        }, DimensionLayoutManager.prototype.endScrollingSession = function() {
                            this._isScrolling = !1;
                        }, DimensionLayoutManager.prototype.isScrolling = function() {
                            return this._isScrolling;
                        }, DimensionLayoutManager.prototype.isResizing = function() {
                            return !1;
                        }, DimensionLayoutManager.prototype.getOtherHierarchyContextualHeight = function() {
                            var otherDimension = this.dimension.otherDimension, count = otherDimension.getDepth(), contextualHeight = 0, items = this._getRealizedItems();
                            if (items.length > 0) for (var i = 0; count > i; i++) contextualHeight += items[i].getContextualWidth();
                            return contextualHeight;
                        }, DimensionLayoutManager.prototype._isAutoSized = function() {
                            return !1;
                        }, DimensionLayoutManager.prototype.onStartRenderingSession = function() {
                            this._measureEnabled = this._requiresMeasure(), this._gridOffset = this.dimension.otherDimension.getDepth();
                        }, DimensionLayoutManager.prototype.onEndRenderingSession = function() {
                            this._realizationManager.onEndRenderingSession(), this._alignToEnd = !1, this._done = !1, 
                            this._measureEnabled = !0, this._sendDimensionsToControl();
                        }, DimensionLayoutManager.prototype._sendDimensionsToControl = function() {}, Object.defineProperty(DimensionLayoutManager.prototype, "measureEnabled", {
                            get: function() {
                                return this._measureEnabled;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), DimensionLayoutManager.prototype.getFooterContextualWidth = function() {
                            return 0;
                        }, DimensionLayoutManager.prototype.onStartRenderingIteration = function(clear, contextualWidth) {
                            this._measureEnabled && !this._done && (this._contextualWidthToFill = (contextualWidth - this.otherScrollbarContextualWidth) * this.getGridScale() - this.getFooterContextualWidth()), 
                            this._realizationManager.onStartRenderingIteration(), clear ? this._lastScrollOffset = null : null !== this._lastScrollOffset && this.swapElements();
                        }, Object.defineProperty(DimensionLayoutManager.prototype, "allItemsRealized", {
                            get: function() {
                                return this.getRealizedItemsCount() - this._gridOffset === this.dimension.getItemsCount() || 0 === this.dimension.getItemsCount();
                            },
                            enumerable: !0,
                            configurable: !0
                        }), DimensionLayoutManager.prototype.onEndRenderingIteration = function() {
                            if (!this._done) {
                                if (!this._measureEnabled) return this._lastScrollOffset = this.dimension.scrollOffset, 
                                void (this._done = !0);
                                var newScrollOffset, gridContextualWidth = this.getGridContextualWidth(), filled = powerbi.Double.greaterOrEqualWithPrecision(gridContextualWidth, this._contextualWidthToFill, DimensionLayoutManager._pixelPrecision), allRealized = this.allItemsRealized;
                                newScrollOffset = filled ? this.scrollForwardToAlignEnd(gridContextualWidth) : this.scrollBackwardToFill(gridContextualWidth), 
                                this._realizationManager.onEndRenderingIteration(gridContextualWidth, filled);
                                var originalScrollbarVisible = this.dimension.scrollbar.visible;
                                this.updateScrollbar(gridContextualWidth), this._done = (filled || allRealized) && this.dimension.scrollbar.visible === originalScrollbarVisible && powerbi.Double.equalWithPrecision(newScrollOffset, this.dimension.scrollOffset, DimensionLayoutManager._scrollOffsetPrecision), 
                                this.dimension.scrollOffset = newScrollOffset, this._lastScrollOffset = this.dimension.scrollOffset;
                            }
                        }, DimensionLayoutManager.prototype.getScrollDeltaWithinPage = function() {
                            if (null !== this._lastScrollOffset) {
                                var delta = this.dimension.getIntegerScrollOffset() - Math.floor(this._lastScrollOffset);
                                if (Math.abs(delta) < this.getRealizedItemsCount() - this.dimension.otherDimension.getDepth()) return delta;
                            }
                            return null;
                        }, DimensionLayoutManager.prototype.swapElements = function() {
                            var delta = this.getScrollDeltaWithinPage();
                            if (null !== delta) {
                                var otherHierarchyDepth = this.dimension.otherDimension.getDepth();
                                Math.abs(delta) < this.getRealizedItemsCount() - otherHierarchyDepth && (delta > 0 ? this._moveElementsToBottom(otherHierarchyDepth, delta) : 0 > delta && this._moveElementsToTop(otherHierarchyDepth, -delta));
                            }
                        }, DimensionLayoutManager.prototype._getRealizedItems = function() {
                            return null;
                        }, DimensionLayoutManager.prototype.getRealizedItemsCount = function() {
                            var realizedItems = this._getRealizedItems();
                            return realizedItems.length;
                        }, DimensionLayoutManager.prototype._moveElementsToBottom = function(moveFromIndex, count) {}, 
                        DimensionLayoutManager.prototype._moveElementsToTop = function(moveToIndex, count) {}, 
                        DimensionLayoutManager.prototype.isScrollingWithinPage = function() {
                            return null !== this.getScrollDeltaWithinPage();
                        }, DimensionLayoutManager.prototype.getGridContextualWidth = function() {
                            return 0;
                        }, DimensionLayoutManager.prototype.updateScrollbar = function(gridContextualWidth) {
                            var scrollbar = this.dimension.scrollbar;
                            scrollbar.viewMin = this.dimension.scrollOffset, scrollbar.min = 0, scrollbar.max = this.dimension.getItemsCount(), 
                            scrollbar.viewSize = this.getViewSize(gridContextualWidth), this.dimension.scrollbar.show(this.canScroll(gridContextualWidth));
                        }, DimensionLayoutManager.prototype.getViewSize = function(gridContextualWidth) {
                            var count = this.getRealizedItemsCount();
                            if (0 === count) return 0;
                            for (var startIndex = this._gridOffset, sizeInItems = 0, sizeInPixels = 0, widthToFill = this._contextualWidthToFill, scrollableArea = widthToFill - this.getOtherHierarchyContextualHeight(), error = this.getMeaurementError(gridContextualWidth), i = startIndex; count > i; i++) {
                                var visibleRatio = void 0;
                                visibleRatio = i === startIndex ? this.getVisibleSizeRatio() : 1;
                                var itemContextualWidth = this.getItemContextualWidthWithScrolling(i) * error;
                                if (sizeInPixels += itemContextualWidth, sizeInItems += visibleRatio, powerbi.Double.greaterWithPrecision(sizeInPixels, scrollableArea, DimensionLayoutManager._pixelPrecision)) {
                                    sizeInItems -= (sizeInPixels - scrollableArea) / itemContextualWidth * visibleRatio;
                                    break;
                                }
                            }
                            return sizeInItems;
                        }, DimensionLayoutManager.prototype.isScrollableHeader = function(item, items, index) {
                            if (0 !== index || 0 === this.dimension.getFractionScrollOffset()) return !1;
                            var hierarchyNavigator = this.dimension._hierarchyNavigator;
                            if (hierarchyNavigator.isLeaf(item)) return !0;
                            var currentItem = item, currentItems = items;
                            do {
                                if (currentItems = hierarchyNavigator.getChildren(currentItem), currentItem = this.dimension.getFirstVisibleItem(hierarchyNavigator.getLevel(currentItem) + 1), 
                                void 0 === currentItem) break;
                                if (!hierarchyNavigator.isLastItem(currentItem, currentItems)) return !1;
                            } while (!hierarchyNavigator.isLeaf(currentItem));
                            return !0;
                        }, DimensionLayoutManager.prototype.reachedEnd = function() {
                            return this.dimension.getIntegerScrollOffset() + (this.getRealizedItemsCount() - this._gridOffset) >= this.dimension.getItemsCount();
                        }, DimensionLayoutManager.prototype.scrollBackwardToFill = function(gridContextualWidth) {
                            var newScrollOffset = this.dimension.scrollOffset;
                            if (this.reachedEnd()) {
                                var widthToFill = this._contextualWidthToFill - gridContextualWidth;
                                if (this.dimension.getItemsCount() > 0) {
                                    var averageColumnwidth = gridContextualWidth / (this.getRealizedItemsCount() - this.dimension.getFractionScrollOffset());
                                    newScrollOffset = this.dimension.getValidScrollOffset(Math.floor(this.dimension.scrollOffset - widthToFill / averageColumnwidth));
                                }
                                this._alignToEnd = !powerbi.Double.equalWithPrecision(newScrollOffset, this.dimension.scrollOffset, DimensionLayoutManager._scrollOffsetPrecision);
                            }
                            return newScrollOffset;
                        }, DimensionLayoutManager.prototype.getItemContextualWidth = function(index) {
                            var realizedItems = this._getRealizedItems();
                            return index >= realizedItems.length ? null : realizedItems[index].getContextualWidth();
                        }, DimensionLayoutManager.prototype.getItemContextualWidthWithScrolling = function(index) {
                            return this.getSizeWithScrolling(this.getItemContextualWidth(index), index);
                        }, DimensionLayoutManager.prototype.getSizeWithScrolling = function(size, index) {
                            var ratio;
                            return ratio = this._gridOffset === index ? this.getVisibleSizeRatio() : 1, size * ratio;
                        }, DimensionLayoutManager.prototype.getGridContextualWidthFromItems = function() {
                            for (var count = this.getRealizedItemsCount(), contextualWidth = 0, i = 0; count > i; i++) contextualWidth += this.getItemContextualWidthWithScrolling(i);
                            return contextualWidth;
                        }, DimensionLayoutManager.prototype.getMeaurementError = function(gridContextualWidth) {
                            return gridContextualWidth / this.getGridContextualWidthFromItems();
                        }, DimensionLayoutManager.prototype.scrollForwardToAlignEnd = function(gridContextualWidth) {
                            var newScrollOffset = this.dimension.scrollOffset;
                            if (this._alignToEnd) {
                                var withinThreshold = powerbi.Double.equalWithPrecision(gridContextualWidth, this._contextualWidthToFill, DimensionLayoutManager._pixelPrecision);
                                if (!withinThreshold) for (var count = this.getRealizedItemsCount(), startIndex = this._gridOffset, widthToScroll = gridContextualWidth - this._contextualWidthToFill, error = this.getMeaurementError(gridContextualWidth), i = startIndex; count > i; i++) {
                                    var itemContextualWidth = this.getItemContextualWidth(i) * error;
                                    if (!powerbi.Double.lessWithPrecision(itemContextualWidth, widthToScroll, DimensionLayoutManager._pixelPrecision)) {
                                        var visibleRatio = startIndex === i ? 1 - this.dimension.getFractionScrollOffset() : 1;
                                        newScrollOffset = this.dimension.getValidScrollOffset(this.dimension.scrollOffset + (i - startIndex) + widthToScroll * visibleRatio / itemContextualWidth);
                                        break;
                                    }
                                    widthToScroll -= itemContextualWidth;
                                }
                                this._alignToEnd = !withinThreshold;
                            }
                            return newScrollOffset;
                        }, Object.defineProperty(DimensionLayoutManager.prototype, "dimension", {
                            get: function() {
                                return null;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(DimensionLayoutManager.prototype, "otherLayoutManager", {
                            get: function() {
                                return this.dimension.otherDimension.layoutManager;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(DimensionLayoutManager.prototype, "contextualWidthToFill", {
                            get: function() {
                                return this._contextualWidthToFill;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), DimensionLayoutManager.prototype.getGridScale = function() {
                            return 0;
                        }, Object.defineProperty(DimensionLayoutManager.prototype, "otherScrollbarContextualWidth", {
                            get: function() {
                                return 0;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), DimensionLayoutManager.prototype.getActualContextualWidth = function(gridContextualWidth) {
                            return this._isAutoSized() && !this.canScroll(gridContextualWidth) ? gridContextualWidth : this._contextualWidthToFill;
                        }, DimensionLayoutManager.prototype.canScroll = function(gridContextualWidth) {
                            return !1;
                        }, DimensionLayoutManager.prototype.calculateSizes = function() {
                            this.fixedSizeEnabled && (this.calculateContextualWidths(), this.calculateSpans());
                        }, DimensionLayoutManager.prototype._calculateSize = function(item) {
                            return null;
                        }, DimensionLayoutManager.prototype.calculateContextualWidths = function() {
                            for (var items = this._getRealizedItems(), count = items.length, i = 0; count > i; i++) {
                                var item = items[i];
                                this.measureEnabled && item.setAligningContextualWidth(-1), this._calculateSize(item);
                            }
                        }, DimensionLayoutManager.prototype.calculateSpans = function() {
                            this.measureEnabled && (this.updateNonScrollableItemsSpans(), this.updateScrollableItemsSpans());
                        }, DimensionLayoutManager.prototype.updateNonScrollableItemsSpans = function() {
                            for (var otherDimensionItems = this.otherLayoutManager._getRealizedItems(), otherDimensionItemsCount = otherDimensionItems.length, startIndex = this.dimension.getDepth(), i = startIndex; otherDimensionItemsCount > i; i++) {
                                var otherDimensionItem = otherDimensionItems[i];
                                this.updateSpans(otherDimensionItem, otherDimensionItem.getHeaders(), !1);
                            }
                        }, DimensionLayoutManager.prototype.updateScrollableItemsSpans = function() {
                            for (var otherRealizedItems = this.otherLayoutManager._getRealizedItems(), otherRealizedItemsCount = Math.min(this.dimension.getDepth(), otherRealizedItems.length), i = 0; otherRealizedItemsCount > i; i++) {
                                var otherRealizedItem = otherRealizedItems[i];
                                this.updateSpans(otherRealizedItem, otherRealizedItem.getOtherDimensionHeaders(), !0);
                            }
                        }, DimensionLayoutManager.prototype.fixSizes = function() {
                            if (this.fixedSizeEnabled) for (var items = this._getRealizedItems(), count = items.length, i = count - 1; i >= 0; i--) items[i].fixSize();
                        }, DimensionLayoutManager.prototype.updateSpans = function(otherRealizedItem, cells, considerScrolling) {
                            for (var realizedItems = this._getRealizedItems(), cellCount = cells.length, j = 0; cellCount > j; j++) {
                                var cell = cells[j], owner = otherRealizedItem.getOtherDimensionOwner(cell), span = owner.getCellContextualSpan(cell);
                                if (span > 1) for (var totalSizeInSpan = 0, startIndex = owner.getIndex(this._grid), k = 0; span > k; k++) {
                                    var item = realizedItems[k + startIndex], childWidth = item.getContentContextualWidth();
                                    considerScrolling && 0 === j && 0 === k && (childWidth = Math.floor((1 - this.dimension.getFractionScrollOffset()) * childWidth)), 
                                    totalSizeInSpan += childWidth, k === span - 1 && this.updateLastChildSize(cell, item, totalSizeInSpan);
                                }
                            }
                        }, DimensionLayoutManager.prototype.updateLastChildSize = function(spanningCell, item, totalSpanSize) {
                            var delta = item.getCellIContentContextualWidth(spanningCell) - totalSpanSize;
                            delta > 0 && item.setAligningContextualWidth(Math.max(item.getAligningContextualWidth(), delta + item.getContentContextualWidth()));
                        }, DimensionLayoutManager._pixelPrecision = 1.0001, DimensionLayoutManager._scrollOffsetPrecision = .01, 
                        DimensionLayoutManager;
                    }();
                    internal.DimensionLayoutManager = DimensionLayoutManager;
                    var ResizeState = function() {
                        function ResizeState(column, width, scale) {
                            this.column = column, this.item = column.getLeafItem(), this.itemType = column.itemType, 
                            this.startColumnWidth = width, this.resizingDelta = 0, this.animationFrame = null, 
                            this.scale = scale;
                        }
                        return ResizeState.prototype.getNewSize = function() {
                            return this.startColumnWidth + this.resizingDelta;
                        }, ResizeState;
                    }();
                    internal.ResizeState = ResizeState;
                    var ColumnLayoutManager = function(_super) {
                        function ColumnLayoutManager(owner, grid, realizationManager) {
                            _super.call(this, owner, grid, realizationManager), realizationManager.owner = this, 
                            this.fillProportionally = !1, this._resizeState = null;
                        }
                        return __extends(ColumnLayoutManager, _super), Object.defineProperty(ColumnLayoutManager.prototype, "dimension", {
                            get: function() {
                                return this.owner.owner.columnDimension;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), ColumnLayoutManager.prototype.isResizing = function() {
                            return null !== this._resizeState;
                        }, Object.defineProperty(ColumnLayoutManager.prototype, "fillProportionally", {
                            get: function() {
                                return this._grid.fillColumnsProportionally;
                            },
                            set: function(value) {
                                this._grid.fillColumnsProportionally = value;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), ColumnLayoutManager.prototype.getGridScale = function() {
                            return this._grid._presenter.getScreenToCssRatioX();
                        }, Object.defineProperty(ColumnLayoutManager.prototype, "otherScrollbarContextualWidth", {
                            get: function() {
                                return this.dimension.otherDimension.scrollbar.visible ? controls.HTMLElementUtils.getElementWidth(this.dimension.otherDimension.scrollbar.element) : 0;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), ColumnLayoutManager.prototype._getRealizedItems = function() {
                            return this._grid.realizedColumns || (this._grid.realizedColumns = []), this._grid.realizedColumns;
                        }, ColumnLayoutManager.prototype._moveElementsToBottom = function(moveFromIndex, count) {
                            this._grid.moveColumnsToEnd(moveFromIndex, count);
                        }, ColumnLayoutManager.prototype._moveElementsToTop = function(moveToIndex, count) {
                            this._grid.moveColumnsToStart(moveToIndex, count);
                        }, ColumnLayoutManager.prototype._requiresMeasure = function() {
                            return !this.isScrolling() && !this.otherLayoutManager.isScrolling() || this.isScrolling() || this.isResizing();
                        }, ColumnLayoutManager.prototype.getGridContextualWidth = function() {
                            return this._grid.getWidth();
                        }, ColumnLayoutManager.prototype.getFirstVisibleColumn = function() {
                            return this._grid.realizedColumns[this._gridOffset];
                        }, ColumnLayoutManager.prototype._isAutoSized = function() {
                            return this.owner.owner.autoSizeWidth;
                        }, ColumnLayoutManager.prototype.applyScrolling = function() {
                            var columnOffset = this.dimension.getFractionScrollOffset(), firstVisibleColumnWidth = 0;
                            if (0 !== columnOffset) {
                                var firstVisibleColumn = this.getFirstVisibleColumn();
                                if (void 0 !== firstVisibleColumn) {
                                    firstVisibleColumnWidth = firstVisibleColumn.getContextualWidth();
                                    var offsetInPixels = Math.ceil(-firstVisibleColumnWidth * columnOffset);
                                    this.scroll(firstVisibleColumn, firstVisibleColumnWidth, offsetInPixels);
                                }
                            }
                        }, ColumnLayoutManager.prototype.scroll = function(firstVisibleColumn, width, offset) {
                            this.scrollCells(firstVisibleColumn._realizedColumnHeaders, width, offset), this.scrollBodyCells(this._grid.realizedRows, width, offset), 
                            null !== firstVisibleColumn.footer && firstVisibleColumn.footer.scrollHorizontally(width, offset);
                        }, ColumnLayoutManager.prototype.scrollCells = function(cells, width, offset) {
                            for (var length = cells.length, i = 0; length > i; i++) cells[i].scrollHorizontally(width, offset);
                        }, ColumnLayoutManager.prototype.scrollBodyCells = function(rows, width, offset) {
                            for (var cells, cell, length = rows.length, i = 0; length > i; i++) cells = rows[i]._realizedBodyCells, 
                            void 0 !== cells && (cell = cells[0], void 0 !== cell && cell.scrollHorizontally(width, offset));
                        }, ColumnLayoutManager.prototype.onStartResize = function(cell, currentX, currentY) {
                            this._resizeState = new ResizeState(cell._column, cell._column.getContentContextualWidth(), controls.HTMLElementUtils.getAccumulatedScale(this.owner.owner.container));
                        }, ColumnLayoutManager.prototype.onResize = function(cell, deltaX, deltaY) {
                            var _this = this;
                            this.isResizing() && (this._resizeState.resizingDelta = Math.round(Math.max(deltaX / this._resizeState.scale, ColumnLayoutManager.minColumnWidth - this._resizeState.startColumnWidth)), 
                            null === this._resizeState.animationFrame && (this._resizeState.animationFrame = requestAnimationFrame(function() {
                                return _this.performResizing();
                            })));
                        }, ColumnLayoutManager.prototype.onEndResize = function(cell) {
                            this.isResizing() && null !== this._resizeState.animationFrame && this.performResizing(), 
                            this.endResizing(), this._resizeState = null;
                        }, ColumnLayoutManager.prototype.onReset = function(cell) {
                            this._resizeState = new ResizeState(cell._column, -1, 1), cell._column.clearSize(), 
                            this.endResizing(), this.owner.owner.refresh(!1), this._resizeState = null;
                        }, ColumnLayoutManager.prototype.updateItemToResizeState = function(realizedColumns) {
                            if (null !== this._resizeState) for (var columnCount = realizedColumns.length, hierarchyNavigator = this.owner.owner.hierarchyNavigator, startIndex = this.otherLayoutManager.dimension.getDepth(), i = startIndex; columnCount > i; i++) {
                                var column = realizedColumns[i];
                                if (column.columnHeaderOrCornerEquals(this._resizeState.itemType, this._resizeState.item, column.itemType, column.getLeafItem(), hierarchyNavigator) && column !== this._resizeState.column) {
                                    this._resizeState.column = column, column.onResize(this._resizeState.getNewSize());
                                    break;
                                }
                            }
                        }, ColumnLayoutManager.prototype.performResizing = function() {
                            if (null !== this._resizeState) {
                                this._resizeState.animationFrame = null;
                                var newSize = this._resizeState.getNewSize();
                                this._resizeState.column.onResize(newSize), this.owner.owner.refresh(!1);
                            }
                        }, ColumnLayoutManager.prototype.endResizing = function() {
                            if (null !== this._resizeState) {
                                var newSize = this._resizeState.getNewSize();
                                this._resizeState.column.onResizeEnd(newSize);
                            }
                        }, ColumnLayoutManager.prototype._sendDimensionsToControl = function() {
                            var gridContextualWidth = this.getGridContextualWidth(), widthToFill = this.getActualContextualWidth(gridContextualWidth), otherContextualHeight = this.getOtherHierarchyContextualHeight(), scale = this.getGridScale();
                            this.owner.owner.updateColumnDimensions(otherContextualHeight / scale, (widthToFill - otherContextualHeight) / scale, this.getViewSize(gridContextualWidth));
                        }, ColumnLayoutManager.prototype.getEstimatedHeaderWidth = function(label, headerIndex) {
                            return -1;
                        }, ColumnLayoutManager.prototype.getEstimatedBodyCellWidth = function(content) {
                            return -1;
                        }, ColumnLayoutManager.minColumnWidth = 10, ColumnLayoutManager;
                    }(DimensionLayoutManager);
                    internal.ColumnLayoutManager = ColumnLayoutManager;
                    var DashboardColumnLayoutManager = function(_super) {
                        function DashboardColumnLayoutManager() {
                            _super.apply(this, arguments);
                        }
                        return __extends(DashboardColumnLayoutManager, _super), DashboardColumnLayoutManager.prototype.getEstimatedHeaderWidth = function(label, headerIndex) {
                            return this.ignoreColumn(headerIndex) ? 0 : this.owner.getCellWidth(void 0);
                        }, DashboardColumnLayoutManager.prototype.getEstimatedBodyCellWidth = function(content) {
                            return this.owner.getCellWidth(void 0);
                        }, DashboardColumnLayoutManager.prototype.canScroll = function(gridContextualWidth) {
                            return !1;
                        }, DashboardColumnLayoutManager.prototype._calculateSize = function(item) {
                            var headerIndex = item.getIndex(this._grid), computedSize = 0;
                            return this.ignoreColumn(headerIndex) || (computedSize = this.owner.getContentWidth(void 0)), 
                            item.onResize(computedSize), item.onResizeEnd(computedSize), computedSize;
                        }, DashboardColumnLayoutManager.prototype.ignoreColumn = function(headerIndex) {
                            return 0 === headerIndex && !this.owner.binder.hasRowGroups();
                        }, DashboardColumnLayoutManager;
                    }(ColumnLayoutManager);
                    internal.DashboardColumnLayoutManager = DashboardColumnLayoutManager;
                    var CanvasColumnLayoutManager = function(_super) {
                        function CanvasColumnLayoutManager() {
                            _super.apply(this, arguments);
                        }
                        return __extends(CanvasColumnLayoutManager, _super), CanvasColumnLayoutManager.prototype.getEstimatedHeaderWidth = function(label, headerIndex) {
                            return this.owner.getEstimatedTextWidth(label);
                        }, CanvasColumnLayoutManager.prototype.getEstimatedBodyCellWidth = function(content) {
                            return this.owner.getEstimatedTextWidth(content);
                        }, CanvasColumnLayoutManager.prototype.calculateContextualWidths = function() {
                            for (var items = this._getRealizedItems(), columnWidths = [], i = 0, len = items.length; len > i; i++) {
                                var item = items[i];
                                this.measureEnabled && item.setAligningContextualWidth(-1);
                                var queryName = controls.TablixColumnWidthManager.getColumnQueryName(item);
                                null != queryName && columnWidths.push({
                                    queryName: queryName,
                                    width: this._calculateSize(item),
                                    isFixed: !1
                                });
                            }
                            this.owner.columnWidthsToPersist = columnWidths;
                        }, CanvasColumnLayoutManager.prototype.canScroll = function(gridContextualWidth) {
                            return !powerbi.Double.equalWithPrecision(this.dimension.scrollOffset, 0, DimensionLayoutManager._scrollOffsetPrecision) || this.getRealizedItemsCount() - this._gridOffset < this.dimension.getItemsCount() && this._contextualWidthToFill > 0 || powerbi.Double.greaterWithPrecision(gridContextualWidth, this._contextualWidthToFill, DimensionLayoutManager._pixelPrecision);
                        }, CanvasColumnLayoutManager.prototype._calculateSize = function(item) {
                            return item.calculateSize();
                        }, CanvasColumnLayoutManager;
                    }(ColumnLayoutManager);
                    internal.CanvasColumnLayoutManager = CanvasColumnLayoutManager;
                    var RowLayoutManager = function(_super) {
                        function RowLayoutManager(owner, grid, realizationManager) {
                            _super.call(this, owner, grid, realizationManager), realizationManager.owner = this;
                        }
                        return __extends(RowLayoutManager, _super), Object.defineProperty(RowLayoutManager.prototype, "dimension", {
                            get: function() {
                                return this.owner.owner.rowDimension;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), RowLayoutManager.prototype.getGridScale = function() {
                            return this._grid._presenter.getScreenToCssRatioY();
                        }, Object.defineProperty(RowLayoutManager.prototype, "otherScrollbarContextualWidth", {
                            get: function() {
                                return this.dimension.otherDimension.scrollbar.visible ? controls.HTMLElementUtils.getElementHeight(this.dimension.otherDimension.scrollbar.element) : 0;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), RowLayoutManager.prototype.startScrollingSession = function() {
                            _super.prototype.startScrollingSession.call(this);
                        }, RowLayoutManager.prototype._getRealizedItems = function() {
                            return this._grid.realizedRows || (this._grid.realizedRows = []), this._grid.realizedRows;
                        }, RowLayoutManager.prototype._moveElementsToBottom = function(moveFromIndex, count) {
                            this._grid.moveRowsToEnd(moveFromIndex, count);
                        }, RowLayoutManager.prototype._moveElementsToTop = function(moveToIndex, count) {
                            this._grid.moveRowsToStart(moveToIndex, count);
                        }, RowLayoutManager.prototype._requiresMeasure = function() {
                            return !this.isScrolling() && !this.otherLayoutManager.isScrolling() && !this.otherLayoutManager.isResizing() || this.isScrolling() && this.dimension.getIntegerScrollOffset() + (this.getRealizedItemsCount() - this._gridOffset) >= this.dimension.getItemsCount();
                        }, RowLayoutManager.prototype.getGridContextualWidth = function() {
                            return this._grid.getHeight();
                        }, RowLayoutManager.prototype.getFirstVisibleRow = function() {
                            return this._grid.realizedRows[this._gridOffset];
                        }, RowLayoutManager.prototype._isAutoSized = function() {
                            return this.owner.owner.autoSizeHeight;
                        }, RowLayoutManager.prototype.applyScrolling = function() {
                            var rowOffset = this.dimension.getFractionScrollOffset(), firstVisibleRowHeight = 0;
                            if (0 !== rowOffset) {
                                var firstVisibleRow = this.getFirstVisibleRow();
                                firstVisibleRow && (firstVisibleRowHeight = firstVisibleRow.getContextualWidth(), 
                                this.scroll(firstVisibleRow, firstVisibleRowHeight, rowOffset));
                            }
                        }, RowLayoutManager.prototype.scroll = function(firstVisibleRow, height, offset) {
                            this.scrollCells(firstVisibleRow._realizedRowHeaders, height, offset), this.scrollCells(firstVisibleRow._realizedBodyCells, height, offset);
                        }, RowLayoutManager.prototype.scrollCells = function(cells, height, offset) {
                            for (var length = cells.length, i = 0; length > i; i++) cells[i].scrollVertically(height, offset);
                        }, RowLayoutManager.prototype.getFooterContextualWidth = function() {
                            return this.owner.owner.rowDimension.hasFooter() && this.owner.grid.footerRow ? this.owner.grid.footerRow.getContextualWidth() : 0;
                        }, RowLayoutManager.prototype.calculateContextualWidths = function() {
                            if (_super.prototype.calculateContextualWidths.call(this), this.fixedSizeEnabled) {
                                var footerRow = this._grid.footerRow;
                                footerRow && this._calculateSize(footerRow);
                            }
                        }, RowLayoutManager.prototype.fixSizes = function() {
                            _super.prototype.fixSizes.call(this), this.fixedSizeEnabled && this._grid.footerRow && this._grid.footerRow.fixSize();
                        }, RowLayoutManager.prototype._sendDimensionsToControl = function() {
                            var gridContextualWidth = this.getGridContextualWidth(), widthToFill = this.getActualContextualWidth(gridContextualWidth), otherContextualHeight = this.getOtherHierarchyContextualHeight(), scale = this.getGridScale();
                            this.owner.owner.updateRowDimensions(otherContextualHeight / scale, (widthToFill - otherContextualHeight) / scale, gridContextualWidth / scale, this.getViewSize(gridContextualWidth), this._grid.footerRow ? this._grid.footerRow.getContextualWidth() / scale : 0);
                        }, RowLayoutManager.prototype.getEstimatedHeaderWidth = function(label, headerIndex) {
                            return -1;
                        }, RowLayoutManager;
                    }(DimensionLayoutManager);
                    internal.RowLayoutManager = RowLayoutManager;
                    var DashboardRowLayoutManager = function(_super) {
                        function DashboardRowLayoutManager() {
                            _super.apply(this, arguments);
                        }
                        return __extends(DashboardRowLayoutManager, _super), DashboardRowLayoutManager.prototype.getEstimatedHeaderWidth = function(label, headerIndex) {
                            return this.getHeaderWidth(headerIndex);
                        }, DashboardRowLayoutManager.prototype.canScroll = function(gridContextualWidth) {
                            return !1;
                        }, DashboardRowLayoutManager.prototype._calculateSize = function(item) {
                            return item.calculateSize();
                        }, DashboardRowLayoutManager.prototype.getHeaderWidth = function(headerIndex) {
                            return 0 !== headerIndex || this.owner.binder.hasRowGroups() ? this.owner.getEstimatedTextWidth(void 0) : 0;
                        }, DashboardRowLayoutManager;
                    }(RowLayoutManager);
                    internal.DashboardRowLayoutManager = DashboardRowLayoutManager;
                    var CanvasRowLayoutManager = function(_super) {
                        function CanvasRowLayoutManager() {
                            _super.apply(this, arguments);
                        }
                        return __extends(CanvasRowLayoutManager, _super), CanvasRowLayoutManager.prototype.getEstimatedHeaderWidth = function(label, headerIndex) {
                            return this.owner.getEstimatedTextWidth(label);
                        }, CanvasRowLayoutManager.prototype.canScroll = function(gridContextualWidth) {
                            return !powerbi.Double.equalWithPrecision(this.dimension.scrollOffset, 0, DimensionLayoutManager._scrollOffsetPrecision) || this.getRealizedItemsCount() - this._gridOffset < this.dimension.getItemsCount() && this._contextualWidthToFill > 0 || powerbi.Double.greaterWithPrecision(gridContextualWidth, this._contextualWidthToFill, DimensionLayoutManager._pixelPrecision);
                        }, CanvasRowLayoutManager.prototype._calculateSize = function(item) {
                            return item.calculateSize();
                        }, CanvasRowLayoutManager;
                    }(RowLayoutManager);
                    internal.CanvasRowLayoutManager = CanvasRowLayoutManager;
                    var TablixLayoutManager = function() {
                        function TablixLayoutManager(binder, grid, columnLayoutManager, rowLayoutManager) {
                            this._allowHeaderResize = !0, this._binder = binder, this._grid = grid, this._columnLayoutManager = columnLayoutManager, 
                            this._rowLayoutManager = rowLayoutManager, this._columnWidthsToPersist = [];
                        }
                        return TablixLayoutManager.prototype.initialize = function(owner) {
                            this._owner = owner, this._container = owner.container, this._gridHost = owner.contentHost, 
                            this._footersHost = owner.footerHost, this._grid.initialize(owner, this._gridHost, this._footersHost);
                        }, Object.defineProperty(TablixLayoutManager.prototype, "owner", {
                            get: function() {
                                return this._owner;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(TablixLayoutManager.prototype, "binder", {
                            get: function() {
                                return this._binder;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(TablixLayoutManager.prototype, "columnWidthsToPersist", {
                            get: function() {
                                return this._columnWidthsToPersist;
                            },
                            set: function(columnWidths) {
                                this._columnWidthsToPersist = columnWidths;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), TablixLayoutManager.prototype.getTablixClassName = function() {
                            return null;
                        }, TablixLayoutManager.prototype.getLayoutKind = function() {
                            return null;
                        }, TablixLayoutManager.prototype.getOrCreateColumnHeader = function(item, items, rowIndex, columnIndex) {
                            var hierarchyNav = this.owner.hierarchyNavigator, row = this._grid.getOrCreateRow(rowIndex), column = this._grid.getOrCreateColumn(columnIndex + this._columnLayoutManager._gridOffset), isLeaf = hierarchyNav.isLeaf(item), cell = row.getOrCreateColumnHeader(column, this._columnLayoutManager.isScrollableHeader(item, items, columnIndex), isLeaf), rowIdx = hierarchyNav.getLevel(item);
                            cell.position.row.index = cell.position.row.indexInSiblings = rowIdx, cell.position.row.isFirst = 0 === rowIdx, 
                            cell.position.row.isLast = isLeaf;
                            var colIdx = hierarchyNav.getIndex(item);
                            return cell.position.column.index = cell.position.row.indexInSiblings = colIdx, 
                            cell.position.column.isFirst = hierarchyNav.areAllParentsFirst(item, items), cell.position.column.isLast = hierarchyNav.areAllParentsLast(item, items), 
                            this.enableCellHorizontalResize(isLeaf, cell), cell;
                        }, TablixLayoutManager.prototype.getOrCreateRowHeader = function(item, items, rowIndex, columnIndex) {
                            var hierarchyNav = this.owner.hierarchyNavigator, row = this._grid.getOrCreateRow(rowIndex + this._rowLayoutManager._gridOffset), column = this._grid.getOrCreateColumn(columnIndex), isLeaf = hierarchyNav.isLeaf(item), scrollable = this._rowLayoutManager.isScrollableHeader(item, items, rowIndex);
                            0 === row.getRealizedCellCount() && this.alignRowHeaderCells(item, row);
                            var cell = row.getOrCreateRowHeader(column, scrollable, hierarchyNav.isLeaf(item)), rowIdx = hierarchyNav.getIndex(item);
                            cell.position.row.index = cell.position.row.indexInSiblings = rowIdx, cell.position.row.isFirst = hierarchyNav.areAllParentsFirst(item, items), 
                            cell.position.row.isLast = hierarchyNav.areAllParentsLast(item, items);
                            var colIdx = hierarchyNav.getLevel(item);
                            return cell.position.column.index = cell.position.column.indexInSiblings = colIdx, 
                            cell.position.column.isFirst = 0 === colIdx, cell.position.column.isLast = isLeaf, 
                            cell.enableHorizontalResize(!1, this._columnLayoutManager), cell;
                        }, TablixLayoutManager.prototype.getOrCreateCornerCell = function(item, rowLevel, columnLevel) {
                            var row = this._grid.getOrCreateRow(columnLevel), column = this._grid.getOrCreateColumn(rowLevel), columnDepth = this._columnLayoutManager.dimension.getDepth(), isLeaf = columnLevel === columnDepth - 1, cell = row.getOrCreateCornerCell(column), rowIdx = columnLevel;
                            cell.position.row.index = cell.position.row.indexInSiblings = rowIdx, cell.position.row.isFirst = 0 === rowIdx, 
                            cell.position.row.isLast = isLeaf;
                            var colIdx = rowLevel;
                            return cell.position.column.index = cell.position.column.indexInSiblings = colIdx, 
                            cell.position.column.isFirst = 0 === colIdx, cell.position.column.isLast = colIdx === this._rowLayoutManager.dimension.getDepth() - 1, 
                            this.enableCellHorizontalResize(isLeaf, cell), cell;
                        }, TablixLayoutManager.prototype.getOrCreateBodyCell = function(cellItem, rowItem, rowItems, rowIndex, columnIndex) {
                            var scrollable, row = this._grid.getOrCreateRow(rowIndex + this._rowLayoutManager._gridOffset), column = this._grid.getOrCreateColumn(columnIndex + this._columnLayoutManager._gridOffset);
                            scrollable = 0 === row._realizedBodyCells.length && 0 !== this._owner.columnDimension.getFractionScrollOffset() ? !0 : this._rowLayoutManager.isScrollableHeader(rowItem, rowItems, rowIndex);
                            var cell = row.getOrCreateBodyCell(column, scrollable);
                            return cell.position = cellItem.position, cell.enableHorizontalResize(!1, this._columnLayoutManager), 
                            cell;
                        }, TablixLayoutManager.prototype.getOrCreateFooterBodyCell = function(cellItem, columnIndex) {
                            var scrollable, row = this._grid.getOrCreateFootersRow(), column = this._grid.getOrCreateColumn(columnIndex + this._columnLayoutManager._gridOffset);
                            scrollable = 0 === row._realizedBodyCells.length && 0 !== this._owner.columnDimension.getFractionScrollOffset();
                            var cell = row.getOrCreateFooterBodyCell(column, scrollable);
                            return cell.position = cellItem.position, cell.enableHorizontalResize(!1, this._columnLayoutManager), 
                            cell;
                        }, TablixLayoutManager.prototype.getOrCreateFooterRowHeader = function(item, items) {
                            var row = this._grid.getOrCreateFootersRow(), column = this._grid.getOrCreateColumn(0), cell = row.getOrCreateFooterRowHeader(column);
                            return cell.position = void 0, cell.enableHorizontalResize(!1, this._columnLayoutManager), 
                            cell;
                        }, TablixLayoutManager.prototype.getVisibleWidth = function() {
                            return -1;
                        }, TablixLayoutManager.prototype.getVisibleHeight = function() {
                            return -1;
                        }, TablixLayoutManager.prototype.updateColumnCount = function(rowDimension, columnDimension) {}, 
                        TablixLayoutManager.prototype.updateViewport = function(viewport) {}, TablixLayoutManager.prototype.getEstimatedRowHeight = function() {
                            return -1;
                        }, TablixLayoutManager.prototype.getCellWidth = function(cell) {
                            return -1;
                        }, TablixLayoutManager.prototype.getContentWidth = function(cell) {
                            return -1;
                        }, TablixLayoutManager.prototype.adjustContentSize = function(hasImage) {}, TablixLayoutManager.prototype.alignRowHeaderCells = function(item, currentRow) {
                            var index = currentRow.getRowHeaderLeafIndex();
                            if (-1 !== index) {
                                var rowDimension = this._owner.rowDimension, leaf = rowDimension.getFirstVisibleChildLeaf(item);
                                this.owner.hierarchyNavigator.headerItemEquals(leaf, currentRow.getAllocatedCellAt(index).item) && currentRow.moveCellsBy(this.owner.hierarchyNavigator.getLevel(leaf) - this.owner.hierarchyNavigator.getLevel(item) - index);
                            }
                        }, Object.defineProperty(TablixLayoutManager.prototype, "grid", {
                            get: function() {
                                return this._grid;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(TablixLayoutManager.prototype, "rowLayoutManager", {
                            get: function() {
                                return this._rowLayoutManager;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(TablixLayoutManager.prototype, "columnLayoutManager", {
                            get: function() {
                                return this._columnLayoutManager;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), TablixLayoutManager.prototype.showEmptySpaceHeader = function() {
                            return !1;
                        }, TablixLayoutManager.prototype.onStartRenderingSession = function(scrollingDimension, parentElement, clear) {
                            if (this.showEmptySpaceHeader()) {
                                var cell = this._grid.emptySpaceHeaderCell;
                                cell && this._binder.unbindEmptySpaceHeaderCell(cell), cell = this._grid.emptySpaceFooterCell, 
                                cell && this._binder.unbindEmptySpaceFooterCell(cell), this._grid.HideEmptySpaceCells();
                            }
                            this._scrollingDimension = scrollingDimension, this._scrollingDimension && this._scrollingDimension.layoutManager.startScrollingSession(), 
                            this._rowLayoutManager.onStartRenderingSession(), this._columnLayoutManager.onStartRenderingSession(), 
                            this._grid.onStartRenderingSession(clear);
                            var measureEnabled = this._columnLayoutManager.measureEnabled || this._rowLayoutManager.measureEnabled;
                            measureEnabled && this.measureSampleText(parentElement);
                        }, TablixLayoutManager.prototype.onEndRenderingSession = function() {
                            if (this._rowLayoutManager.onEndRenderingSession(), this._columnLayoutManager.onEndRenderingSession(), 
                            this._scrollingDimension && this._scrollingDimension.layoutManager.endScrollingSession(), 
                            this._scrollingDimension = null, this.showEmptySpaceHeader()) {
                                var emptySpace = this._columnLayoutManager.contextualWidthToFill - this._columnLayoutManager.getGridContextualWidth();
                                if (emptySpace > 0) {
                                    this._grid.ShowEmptySpaceCells(this._owner.columnDimension.getDepth(), emptySpace);
                                    var cell = this._grid.emptySpaceHeaderCell;
                                    cell && this._binder.bindEmptySpaceHeaderCell(cell), cell = this._grid.emptySpaceFooterCell, 
                                    cell && this._binder.bindEmptySpaceFooterCell(cell);
                                }
                            }
                        }, TablixLayoutManager.prototype.onStartRenderingIteration = function(clear) {
                            this._rowLayoutManager.onStartRenderingIteration(clear, this.getVisibleHeight()), 
                            this._columnLayoutManager.onStartRenderingIteration(clear, this.getVisibleWidth()), 
                            this._grid.onStartRenderingIteration();
                        }, TablixLayoutManager.prototype.onEndRenderingIteration = function() {
                            return this._grid.onEndRenderingIteration(), this._columnLayoutManager.calculateSizes(), 
                            this._rowLayoutManager.calculateSizes(), this._columnLayoutManager.fixSizes(), this._rowLayoutManager.fixSizes(), 
                            this._columnLayoutManager.updateItemToResizeState(this._grid.realizedColumns), this._columnLayoutManager.applyScrolling(), 
                            this._rowLayoutManager.applyScrolling(), this._columnLayoutManager.onEndRenderingIteration(), 
                            this._rowLayoutManager.onEndRenderingIteration(), this._columnLayoutManager.done && this._rowLayoutManager.done;
                        }, TablixLayoutManager.prototype.onCornerCellRealized = function(item, cell) {
                            var columnLeaf = this.owner.hierarchyNavigator.isColumnHierarchyLeaf(item), rowLeaf = this.owner.hierarchyNavigator.isRowHierarchyLeaf(item);
                            columnLeaf && cell._column.OnLeafRealized(this._owner.hierarchyNavigator), this._columnLayoutManager.onCornerCellRealized(item, cell, columnLeaf), 
                            this._rowLayoutManager.onCornerCellRealized(item, cell, rowLeaf);
                        }, TablixLayoutManager.prototype.onRowHeaderRealized = function(item, cell) {
                            var hierarchyNavigator = this._owner.hierarchyNavigator, leaf = hierarchyNavigator.isLeaf(item), tablixCell = cell;
                            tablixCell.colSpan > 1 && tablixCell.setContainerWidth(-1), this._rowLayoutManager.onHeaderRealized(item, cell, leaf);
                        }, TablixLayoutManager.prototype.onRowHeaderFooterRealized = function(item, cell) {}, 
                        TablixLayoutManager.prototype.onColumnHeaderRealized = function(item, cell) {
                            var hierarchyNavigator = this._owner.hierarchyNavigator, leaf = hierarchyNavigator.isLeaf(item);
                            leaf && cell._column.OnLeafRealized(this._owner.hierarchyNavigator), this._columnLayoutManager.onHeaderRealized(item, cell, leaf);
                        }, TablixLayoutManager.prototype.onBodyCellRealized = function(item, cell) {}, TablixLayoutManager.prototype.onBodyCellFooterRealized = function(item, cell) {}, 
                        TablixLayoutManager.prototype.setAllowHeaderResize = function(value) {
                            this._allowHeaderResize = value;
                        }, TablixLayoutManager.prototype.enableCellHorizontalResize = function(isLeaf, cell) {
                            var enableCellHorizontalResize = isLeaf && this._allowHeaderResize;
                            cell.enableHorizontalResize(enableCellHorizontalResize, this._columnLayoutManager);
                        }, TablixLayoutManager.prototype.getEstimatedTextWidth = function(label) {
                            return -1;
                        }, TablixLayoutManager.prototype.measureSampleText = function(parentElement) {}, 
                        TablixLayoutManager;
                    }();
                    internal.TablixLayoutManager = TablixLayoutManager;
                    var DashboardTablixLayoutManager = function(_super) {
                        function DashboardTablixLayoutManager(binder, sizeComputationManager, grid, rowRealizationManager, columnRealizationManager) {
                            var dashboardColumnLayoutManager = new DashboardColumnLayoutManager(null, grid, columnRealizationManager), dashboardRowLayoutManager = new DashboardRowLayoutManager(null, grid, rowRealizationManager);
                            _super.call(this, binder, grid, dashboardColumnLayoutManager, dashboardRowLayoutManager), 
                            dashboardColumnLayoutManager.owner = this, dashboardRowLayoutManager.owner = this, 
                            this._sizeComputationManager = sizeComputationManager;
                        }
                        return __extends(DashboardTablixLayoutManager, _super), DashboardTablixLayoutManager.createLayoutManager = function(binder) {
                            var sizeComputationManager = new SizeComputationManager();
                            return new DashboardTablixLayoutManager(binder, sizeComputationManager, new internal.TablixGrid(new internal.DashboardTablixGridPresenter(sizeComputationManager)), new internal.RowRealizationManager(binder), new internal.ColumnRealizationManager(binder));
                        }, DashboardTablixLayoutManager.prototype.getTablixClassName = function() {
                            return "tablixDashboard";
                        }, DashboardTablixLayoutManager.prototype.getLayoutKind = function() {
                            return 1;
                        }, DashboardTablixLayoutManager.prototype.showEmptySpaceHeader = function() {
                            return !1;
                        }, DashboardTablixLayoutManager.prototype.measureSampleText = function(parentElement) {
                            var textProperties = powerbi.TextMeasurementService.getSvgMeasurementProperties(parentElement);
                            this._characterHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties), 
                            this._sizeComputationManager.updateRowHeight(this._characterHeight);
                            var actualTextSize = PixelConverter.toPoint(parseFloat(textProperties.fontSize)), scalingFactor = actualTextSize / controls.TablixDefaultTextSize;
                            this._sizeComputationManager.updateScalingFactor(powerbi.Double.toIncrement(scalingFactor, .05));
                        }, DashboardTablixLayoutManager.prototype.getVisibleWidth = function() {
                            return this._sizeComputationManager.visibleWidth;
                        }, DashboardTablixLayoutManager.prototype.getVisibleHeight = function() {
                            return this._sizeComputationManager.visibleHeight;
                        }, DashboardTablixLayoutManager.prototype.getCellWidth = function(cell) {
                            return this._sizeComputationManager.cellWidth;
                        }, DashboardTablixLayoutManager.prototype.getContentWidth = function(cell) {
                            return this._sizeComputationManager.contentWidth;
                        }, DashboardTablixLayoutManager.prototype.getEstimatedTextWidth = function(label) {
                            return this._sizeComputationManager.contentWidth;
                        }, DashboardTablixLayoutManager.prototype.adjustContentSize = function(hasImage) {
                            this._sizeComputationManager.hasImageContent = hasImage;
                        }, DashboardTablixLayoutManager.prototype.updateColumnCount = function(rowDimension, columnDimension) {
                            var rowDimensionDepth = rowDimension ? rowDimension.getDepth() : 0, columnInstances = columnDimension ? columnDimension.getItemsCount() : 0, totalColumnCount = rowDimensionDepth + columnInstances;
                            this.binder.hasRowGroups() || totalColumnCount--, this._sizeComputationManager.updateColumnCount(totalColumnCount);
                        }, DashboardTablixLayoutManager.prototype.updateViewport = function(viewport) {
                            this._sizeComputationManager.updateViewport(viewport);
                        }, DashboardTablixLayoutManager.prototype.getEstimatedRowHeight = function() {
                            return this._characterHeight;
                        }, DashboardTablixLayoutManager;
                    }(TablixLayoutManager);
                    internal.DashboardTablixLayoutManager = DashboardTablixLayoutManager;
                    var CanvasTablixLayoutManager = function(_super) {
                        function CanvasTablixLayoutManager(binder, grid, rowRealizationManager, columnRealizationManager) {
                            var canvasColumnLayoutManager = new CanvasColumnLayoutManager(null, grid, columnRealizationManager), canvasRowLayoutManager = new CanvasRowLayoutManager(null, grid, rowRealizationManager);
                            _super.call(this, binder, grid, canvasColumnLayoutManager, canvasRowLayoutManager), 
                            canvasColumnLayoutManager.owner = this, canvasRowLayoutManager.owner = this;
                        }
                        return __extends(CanvasTablixLayoutManager, _super), CanvasTablixLayoutManager.createLayoutManager = function(binder, columnWidthManager) {
                            return new CanvasTablixLayoutManager(binder, new internal.TablixGrid(new controls.internal.CanvasTablixGridPresenter(columnWidthManager)), new internal.RowRealizationManager(binder), new internal.ColumnRealizationManager(binder));
                        }, CanvasTablixLayoutManager.prototype.getTablixClassName = function() {
                            return "tablixCanvas";
                        }, CanvasTablixLayoutManager.prototype.getLayoutKind = function() {
                            return 0;
                        }, CanvasTablixLayoutManager.prototype.measureSampleText = function(parentElement) {
                            var textDiv = controls.internal.TablixUtils.createDiv();
                            textDiv.style.cssFloat = "left", textDiv.style.whiteSpace = "nowrap", textDiv.style.overflow = "hidden", 
                            textDiv.style.lineHeight = "normal", parentElement.appendChild(textDiv);
                            var textNode = document.createTextNode("a");
                            textDiv.appendChild(textNode), this.characterWidth = controls.HTMLElementUtils.getElementWidth(textDiv), 
                            this.characterHeight = controls.HTMLElementUtils.getElementHeight(textDiv), textDiv.removeChild(textNode), 
                            parentElement.removeChild(textDiv);
                        }, CanvasTablixLayoutManager.prototype.showEmptySpaceHeader = function() {
                            return !this._columnLayoutManager.fillProportionally;
                        }, CanvasTablixLayoutManager.prototype.getVisibleWidth = function() {
                            return this._columnLayoutManager.measureEnabled ? this._owner.autoSizeWidth && this._owner.maxWidth ? this._owner.maxWidth : controls.HTMLElementUtils.getElementWidth(this._container) : -1;
                        }, CanvasTablixLayoutManager.prototype.getVisibleHeight = function() {
                            return this._rowLayoutManager.measureEnabled ? this._owner.autoSizeHeight && this._owner.maxHeight ? this._owner.maxHeight : controls.HTMLElementUtils.getElementHeight(this._container) : -1;
                        }, CanvasTablixLayoutManager.prototype.getCellWidth = function(cell) {
                            return cell.containerWidth;
                        }, CanvasTablixLayoutManager.prototype.getContentWidth = function(cell) {
                            return cell.contentWidth;
                        }, CanvasTablixLayoutManager.prototype.getEstimatedTextWidth = function(text) {
                            return text ? text.length * this.characterWidth : 0;
                        }, CanvasTablixLayoutManager.prototype.updateColumnCount = function(rowDimension, columnDimension) {}, 
                        CanvasTablixLayoutManager.prototype.updateViewport = function(viewport) {}, CanvasTablixLayoutManager.prototype.getEstimatedRowHeight = function() {
                            return this.characterHeight;
                        }, CanvasTablixLayoutManager;
                    }(TablixLayoutManager);
                    internal.CanvasTablixLayoutManager = CanvasTablixLayoutManager;
                }(internal = controls.internal || (controls.internal = {}));
            }(controls = visuals.controls || (visuals.controls = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi, InJs = (window.powerbitests, 
    window.InJs);
    window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var controls;
            !function(controls) {
                var HTMLElementUtils;
                !function(HTMLElementUtils) {
                    function clearChildren(element) {
                        if (element) for (;element.hasChildNodes(); ) element.removeChild(element.firstChild);
                    }
                    function setElementTop(element, top) {
                        element.style.top = top + "px";
                    }
                    function setElementLeft(element, left) {
                        element.style.left = left + "px";
                    }
                    function setElementHeight(element, height) {
                        HTMLElementUtils.isAutoSize(height) ? element.style.height = "" : element.style.height = height + "px";
                    }
                    function setElementWidth(element, width) {
                        HTMLElementUtils.isAutoSize(width) ? element.style.width = "" : element.style.width = width + "px";
                    }
                    function getElementWidth(element) {
                        return element.offsetWidth;
                    }
                    function getElementHeight(element) {
                        return element.offsetHeight;
                    }
                    function isAutoSize(size) {
                        return -1 === size;
                    }
                    function getAccumulatedScale(element) {
                        for (var scale = 1; element; ) scale *= HTMLElementUtils.getScale(element), element = element.parentElement;
                        return scale;
                    }
                    function getScale(element) {
                        element = $(element);
                        var str = element.css("-webkit-transform") || element.css("-moz-transform") || element.css("-ms-transform") || element.css("-o-transform") || element.css("transform");
                        return str && (str.match(/\d*\.\d*/) && Number(str.match(/\d*\.\d*/)[0]) || str.match(/\d+/) && Number(str.match(/\d+/)[0])) || 1;
                    }
                    HTMLElementUtils.clearChildren = clearChildren, HTMLElementUtils.setElementTop = setElementTop, 
                    HTMLElementUtils.setElementLeft = setElementLeft, HTMLElementUtils.setElementHeight = setElementHeight, 
                    HTMLElementUtils.setElementWidth = setElementWidth, HTMLElementUtils.getElementWidth = getElementWidth, 
                    HTMLElementUtils.getElementHeight = getElementHeight, HTMLElementUtils.isAutoSize = isAutoSize, 
                    HTMLElementUtils.getAccumulatedScale = getAccumulatedScale, HTMLElementUtils.getScale = getScale;
                }(HTMLElementUtils = controls.HTMLElementUtils || (controls.HTMLElementUtils = {}));
            }(controls = visuals.controls || (visuals.controls = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
    var powerbi;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var controls;
            !function(controls) {
                var internal;
                !function(internal) {
                    var TablixObjects, DomFactory = InJs.DomFactory, DataViewObjectDefinitions = powerbi.data.DataViewObjectDefinitions, DataViewRoleWildCard = powerbi.data.DataViewRoleWildcard;
                    !function(TablixObjects) {
                        function getMetadadataObjects(dataview) {
                            return dataview && dataview.metadata ? dataview.metadata.objects : null;
                        }
                        function enumerateObjectRepetition(enumeration, dataView, tablixType) {
                            if (tablixType === controls.TablixType.Table) {
                                for (var columns = getTableColumnMetadata(dataView), _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {
                                    var column = columns_1[_i], repetition = {
                                        selector: {
                                            data: [ DataViewRoleWildCard.fromRoles([ "Values" ]) ],
                                            metadata: column.queryName
                                        },
                                        objects: (_a = {}, _a[TablixObjects.ObjectValues] = {
                                            formattingProperties: [ TablixObjects.PropValuesBackColor.propertyName ]
                                        }, _a)
                                    };
                                    enumeration.push(repetition);
                                }
                                var _a;
                            }
                        }
                        function enumerateObjectInstances(options, enumeration, dataView, tablixType) {
                            var objects = getMetadadataObjects(dataView), totalsShown = !0;
                            switch (totalsShown = tablixType === controls.TablixType.Table ? shouldShowTableTotalsOption(dataView) && shouldShowTableTotals(objects) : shouldShowColumnSubtotalsOption(dataView) && shouldShowColumnSubtotals(objects) || shouldShowRowSubtotalsOption(dataView) && shouldShowRowSubtotals(objects), 
                            options.objectName) {
                              case TablixObjects.ObjectGeneral:
                                enumerateGeneralOptions(enumeration, objects, tablixType, dataView);
                                break;

                              case TablixObjects.ObjectGrid:
                                enumerateGridOptions(enumeration, objects, tablixType);
                                break;

                              case TablixObjects.ObjectColumnHeaders:
                                enumerateColumnHeadersOptions(enumeration, objects);
                                break;

                              case TablixObjects.ObjectRowHeaders:
                                enumerateRowHeadersOptions(enumeration, objects);
                                break;

                              case TablixObjects.ObjectValues:
                                enumerateValuesOptions(enumeration, objects, tablixType);
                                break;

                              case TablixObjects.ObjectTotal:
                                totalsShown && enumerateTotalOptions(enumeration, objects);
                                break;

                              case TablixObjects.ObjectSubTotals:
                                totalsShown && enumerateSubTotalsOptions(enumeration, objects);
                            }
                        }
                        function enumerateGeneralOptions(enumeration, objects, tablixType, dataView) {
                            var visualObjectinstance = {
                                selector: null,
                                objectName: TablixObjects.ObjectGeneral,
                                properties: {
                                    autoSizeColumnWidth: TablixObjects.PropGeneralAutoSizeColumns.getValue(objects),
                                    textSize: TablixObjects.PropGeneralTextSize.getValue(objects)
                                }
                            }, properties = visualObjectinstance.properties;
                            switch (tablixType) {
                              case controls.TablixType.Table:
                                shouldShowTableTotalsOption(dataView) && (properties[TablixObjects.PropGeneralTableTotals.propertyName] = shouldShowTableTotals(objects));
                                break;

                              case controls.TablixType.Matrix:
                                shouldShowRowSubtotalsOption(dataView) && (properties[TablixObjects.PropGeneralMatrixRowSubtotals.propertyName] = shouldShowRowSubtotals(objects)), 
                                shouldShowColumnSubtotalsOption(dataView) && (properties[TablixObjects.PropGeneralMatrixColumnSubtotals.propertyName] = shouldShowColumnSubtotals(objects));
                            }
                            enumeration.pushInstance(visualObjectinstance);
                        }
                        function enumerateGridOptions(enumeration, objects, tablixType) {
                            var visualObjectinstance = {
                                selector: null,
                                objectName: TablixObjects.ObjectGeneral,
                                properties: {}
                            }, properties = visualObjectinstance.properties, verticalGridEnabled = TablixObjects.PropGridVertical.getValue(objects);
                            properties[TablixObjects.PropGridVertical.propertyName] = verticalGridEnabled, verticalGridEnabled && (properties[TablixObjects.PropGridVerticalColor.propertyName] = TablixObjects.PropGridVerticalColor.getValue(objects), 
                            properties[TablixObjects.PropGridVerticalWeight.propertyName] = TablixObjects.PropGridVerticalWeight.getValue(objects));
                            var horizontalGridEnabled = (tablixType === controls.TablixType.Table ? TablixObjects.PropGridHorizontalTable : TablixObjects.PropGridHorizontalMatrix).getValue(objects);
                            properties[(tablixType === controls.TablixType.Table ? TablixObjects.PropGridHorizontalTable : TablixObjects.PropGridHorizontalMatrix).propertyName] = horizontalGridEnabled, 
                            horizontalGridEnabled && (properties[TablixObjects.PropGridHorizontalColor.propertyName] = TablixObjects.PropGridHorizontalColor.getValue(objects), 
                            properties[TablixObjects.PropGridHorizontalWeight.propertyName] = TablixObjects.PropGridHorizontalWeight.getValue(objects)), 
                            properties[TablixObjects.PropGridRowPadding.propertyName] = TablixObjects.PropGridRowPadding.getValue(objects), 
                            properties[TablixObjects.PropGridOutlineColor.propertyName] = TablixObjects.PropGridOutlineColor.getValue(objects), 
                            properties[TablixObjects.PropGridOutlineWeight.propertyName] = TablixObjects.PropGridOutlineWeight.getValue(objects), 
                            properties[TablixObjects.PropGridImageHeight.propertyName] = TablixObjects.PropGridImageHeight.getValue(objects), 
                            enumeration.pushInstance(visualObjectinstance);
                        }
                        function enumerateColumnHeadersOptions(enumeration, objects) {
                            enumeration.pushInstance({
                                selector: null,
                                objectName: TablixObjects.ObjectColumnHeaders,
                                properties: {
                                    fontColor: TablixObjects.PropColumnsFontColor.getValue(objects),
                                    backColor: TablixObjects.PropColumnsBackColor.getValue(objects),
                                    outline: TablixObjects.PropColumnsOutline.getValue(objects)
                                }
                            });
                        }
                        function enumerateRowHeadersOptions(enumeration, objects) {
                            enumeration.pushInstance({
                                selector: null,
                                objectName: TablixObjects.ObjectRowHeaders,
                                properties: {
                                    fontColor: TablixObjects.PropRowsFontColor.getValue(objects),
                                    backColor: TablixObjects.PropRowsBackColor.getValue(objects),
                                    outline: TablixObjects.PropRowsOutline.getValue(objects)
                                }
                            });
                        }
                        function enumerateValuesOptions(enumeration, objects, tablixType) {
                            var instance = {
                                selector: null,
                                objectName: TablixObjects.ObjectValues,
                                properties: {
                                    fontColorPrimary: TablixObjects.PropValuesFontColorPrimary.getValue(objects),
                                    backColorPrimary: TablixObjects.PropValuesBackColorPrimary.getValue(objects),
                                    fontColorSecondary: TablixObjects.PropValuesFontColorSecondary.getValue(objects),
                                    backColorSecondary: TablixObjects.PropValuesBackColorSecondary.getValue(objects),
                                    outline: TablixObjects.PropValuesOutline.getValue(objects)
                                }
                            };
                            tablixType === controls.TablixType.Table && (instance.properties[TablixObjects.PropValuesUrlIconProp.propertyName] = TablixObjects.PropValuesUrlIconProp.getValue(objects)), 
                            enumeration.pushInstance(instance);
                        }
                        function enumerateTotalOptions(enumeration, objects) {
                            enumeration.pushInstance({
                                selector: null,
                                objectName: TablixObjects.ObjectTotal,
                                properties: {
                                    fontColor: TablixObjects.PropTotalFontColor.getValue(objects),
                                    backColor: TablixObjects.PropTotalBackColor.getValue(objects),
                                    outline: TablixObjects.PropTotalOutline.getValue(objects)
                                }
                            });
                        }
                        function enumerateSubTotalsOptions(enumeration, objects) {
                            enumeration.pushInstance({
                                selector: null,
                                objectName: TablixObjects.ObjectSubTotals,
                                properties: {
                                    fontColor: TablixObjects.PropSubTotalsFontColor.getValue(objects),
                                    backColor: TablixObjects.PropSubTotalsBackColor.getValue(objects)
                                }
                            });
                        }
                        function getTableObjects(dataView) {
                            var objects = getMetadadataObjects(dataView), formattingProperties = {
                                general: {
                                    autoSizeColumnWidth: TablixObjects.PropGeneralAutoSizeColumns.getValue(objects),
                                    textSize: TablixObjects.PropGeneralTextSize.getValue(objects),
                                    totals: shouldShowTableTotals(objects)
                                }
                            };
                            return formattingProperties.grid = {
                                gridVertical: TablixObjects.PropGridVertical.getValue(objects),
                                gridVerticalColor: TablixObjects.PropGridVerticalColor.getValue(objects),
                                gridVerticalWeight: TablixObjects.PropGridVerticalWeight.getValue(objects),
                                gridHorizontal: TablixObjects.PropGridHorizontalTable.getValue(objects),
                                gridHorizontalColor: TablixObjects.PropGridHorizontalColor.getValue(objects),
                                gridHorizontalWeight: TablixObjects.PropGridHorizontalWeight.getValue(objects),
                                outlineColor: TablixObjects.PropGridOutlineColor.getValue(objects),
                                outlineWeight: TablixObjects.PropGridOutlineWeight.getValue(objects),
                                rowPadding: TablixObjects.PropGridRowPadding.getValue(objects),
                                imageHeight: TablixObjects.PropGridImageHeight.getValue(objects)
                            }, formattingProperties.columnHeaders = {
                                fontColor: TablixObjects.PropColumnsFontColor.getValue(objects),
                                backColor: TablixObjects.PropColumnsBackColor.getValue(objects),
                                outline: TablixObjects.PropColumnsOutline.getValue(objects)
                            }, formattingProperties.values = {
                                fontColorPrimary: TablixObjects.PropValuesFontColorPrimary.getValue(objects),
                                backColorPrimary: TablixObjects.PropValuesBackColorPrimary.getValue(objects),
                                fontColorSecondary: TablixObjects.PropValuesFontColorSecondary.getValue(objects),
                                backColorSecondary: TablixObjects.PropValuesBackColorSecondary.getValue(objects),
                                outline: TablixObjects.PropValuesOutline.getValue(objects),
                                urlIcon: TablixObjects.PropValuesUrlIconProp.getValue(objects)
                            }, formattingProperties.total = {
                                fontColor: TablixObjects.PropTotalFontColor.getValue(objects),
                                backColor: TablixObjects.PropTotalBackColor.getValue(objects),
                                outline: TablixObjects.PropTotalOutline.getValue(objects)
                            }, formattingProperties;
                        }
                        function getMatrixObjects(dataView) {
                            var objects = getMetadadataObjects(dataView), formattingProperties = {
                                general: {
                                    autoSizeColumnWidth: TablixObjects.PropGeneralAutoSizeColumns.getValue(objects),
                                    textSize: TablixObjects.PropGeneralTextSize.getValue(objects),
                                    rowSubtotals: shouldShowRowSubtotals(objects),
                                    columnSubtotals: shouldShowColumnSubtotals(objects)
                                }
                            };
                            return formattingProperties.grid = {
                                gridVertical: TablixObjects.PropGridVertical.getValue(objects),
                                gridVerticalColor: TablixObjects.PropGridVerticalColor.getValue(objects),
                                gridVerticalWeight: TablixObjects.PropGridVerticalWeight.getValue(objects),
                                gridHorizontal: TablixObjects.PropGridHorizontalMatrix.getValue(objects),
                                gridHorizontalColor: TablixObjects.PropGridHorizontalColor.getValue(objects),
                                gridHorizontalWeight: TablixObjects.PropGridHorizontalWeight.getValue(objects),
                                outlineColor: TablixObjects.PropGridOutlineColor.getValue(objects),
                                outlineWeight: TablixObjects.PropGridOutlineWeight.getValue(objects),
                                rowPadding: TablixObjects.PropGridRowPadding.getValue(objects),
                                imageHeight: TablixObjects.PropGridImageHeight.getValue(objects)
                            }, formattingProperties.columnHeaders = {
                                fontColor: TablixObjects.PropColumnsFontColor.getValue(objects),
                                backColor: TablixObjects.PropColumnsBackColor.getValue(objects),
                                outline: TablixObjects.PropColumnsOutline.getValue(objects)
                            }, formattingProperties.rowHeaders = {
                                fontColor: TablixObjects.PropRowsFontColor.getValue(objects),
                                backColor: TablixObjects.PropRowsBackColor.getValue(objects),
                                outline: TablixObjects.PropRowsOutline.getValue(objects)
                            }, formattingProperties.values = {
                                fontColorPrimary: TablixObjects.PropValuesFontColorPrimary.getValue(objects),
                                backColorPrimary: TablixObjects.PropValuesBackColorPrimary.getValue(objects),
                                fontColorSecondary: TablixObjects.PropValuesFontColorSecondary.getValue(objects),
                                backColorSecondary: TablixObjects.PropValuesBackColorSecondary.getValue(objects),
                                outline: TablixObjects.PropValuesOutline.getValue(objects)
                            }, formattingProperties.subtotals = {
                                fontColor: TablixObjects.PropSubTotalsFontColor.getValue(objects),
                                backColor: TablixObjects.PropSubTotalsBackColor.getValue(objects),
                                outline: TablixObjects.PropSubTotalsOutline.getValue(objects)
                            }, formattingProperties;
                        }
                        function generateTablixDefaultObjects(tablixType) {
                            return {
                                general: [ {
                                    selector: null,
                                    properties: {
                                        textSize: DataViewObjectDefinitions.encodePropertyValue(12, {
                                            numeric: !0
                                        }),
                                        totals: DataViewObjectDefinitions.encodePropertyValue(!1, {
                                            bool: !0
                                        })
                                    }
                                } ]
                            };
                        }
                        function getTextSizeInPx(textSize) {
                            return jsCommon.PixelConverter.fromPoint(textSize);
                        }
                        function shouldShowTableTotals(objects) {
                            return TablixObjects.PropGeneralTableTotals.getValue(objects);
                        }
                        function shouldShowTableTotalsOption(dataView) {
                            if (dataView && dataView.table && !_.isEmpty(dataView.table.columns)) {
                                var columns = dataView.table.columns;
                                if (_.some(columns, function(column) {
                                    return column.discourageAggregationAcrossGroups;
                                })) return !1;
                            }
                            return !0;
                        }
                        function getTableColumnMetadata(dataView) {
                            return dataView && dataView.table && !_.isEmpty(dataView.table.columns) ? dataView.table.columns : void 0;
                        }
                        function shouldShowRowSubtotals(objects) {
                            return TablixObjects.PropGeneralMatrixRowSubtotals.getValue(objects);
                        }
                        function shouldShowRowSubtotalsOption(dataView) {
                            return !(dataView && dataView.matrix && dataView.matrix.rows && isDiscourageAggregationAcrossGroups(dataView.matrix.rows.levels));
                        }
                        function shouldShowColumnSubtotals(objects) {
                            return TablixObjects.PropGeneralMatrixColumnSubtotals.getValue(objects);
                        }
                        function shouldShowColumnSubtotalsOption(dataView) {
                            return !(dataView && dataView.matrix && dataView.matrix.columns && isDiscourageAggregationAcrossGroups(dataView.matrix.columns.levels));
                        }
                        function isDiscourageAggregationAcrossGroups(levels) {
                            var lastLevel = _.last(levels);
                            return lastLevel && _.some(lastLevel.sources, function(source) {
                                return source.discourageAggregationAcrossGroups;
                            });
                        }
                        TablixObjects.ObjectGeneral = "general", TablixObjects.ObjectGrid = "grid", TablixObjects.ObjectColumnHeaders = "columnHeaders", 
                        TablixObjects.ObjectRowHeaders = "rowHeaders", TablixObjects.ObjectValues = "values", 
                        TablixObjects.ObjectTotal = "total", TablixObjects.ObjectSubTotals = "subTotals";
                        var TablixProperty = function() {
                            function TablixProperty(objectName, propertyName, defaultValue, getterFuntion) {
                                this.objectName = objectName, this.propertyName = propertyName, this.defaultValue = defaultValue, 
                                this.getterFuntion = getterFuntion;
                            }
                            return TablixProperty.prototype.getPropertyID = function() {
                                return {
                                    objectName: this.objectName,
                                    propertyName: this.propertyName
                                };
                            }, TablixProperty.prototype.getValue = function(objects) {
                                return this.getterFuntion(objects, this.getPropertyID(), this.defaultValue);
                            }, TablixProperty;
                        }();
                        TablixObjects.TablixProperty = TablixProperty, TablixObjects.PropColumnFormatString = new TablixProperty(TablixObjects.ObjectGeneral, "formatString", void 0, powerbi.DataViewObjects.getValue), 
                        TablixObjects.PropGeneralAutoSizeColumns = new TablixProperty(TablixObjects.ObjectGeneral, "autoSizeColumnWidth", !0, powerbi.DataViewObjects.getValue), 
                        TablixObjects.PropGeneralTextSize = new TablixProperty(TablixObjects.ObjectGeneral, "textSize", 8, powerbi.DataViewObjects.getValue), 
                        TablixObjects.PropGeneralTableTotals = new TablixProperty(TablixObjects.ObjectGeneral, "totals", !0, powerbi.DataViewObjects.getValue), 
                        TablixObjects.PropGeneralMatrixRowSubtotals = new TablixProperty(TablixObjects.ObjectGeneral, "rowSubtotals", !0, powerbi.DataViewObjects.getValue), 
                        TablixObjects.PropGeneralMatrixColumnSubtotals = new TablixProperty(TablixObjects.ObjectGeneral, "columnSubtotals", !0, powerbi.DataViewObjects.getValue), 
                        TablixObjects.PropGridVertical = new TablixProperty(TablixObjects.ObjectGrid, "gridVertical", !1, powerbi.DataViewObjects.getValue), 
                        TablixObjects.PropGridVerticalColor = new TablixProperty(TablixObjects.ObjectGrid, "gridVerticalColor", "#E8E8E8", powerbi.DataViewObjects.getFillColor), 
                        TablixObjects.PropGridVerticalWeight = new TablixProperty(TablixObjects.ObjectGrid, "gridVerticalWeight", 1, powerbi.DataViewObjects.getValue), 
                        TablixObjects.PropGridHorizontalTable = new TablixProperty(TablixObjects.ObjectGrid, "gridHorizontal", !0, powerbi.DataViewObjects.getValue), 
                        TablixObjects.PropGridHorizontalMatrix = new TablixProperty(TablixObjects.ObjectGrid, "gridHorizontal", !1, powerbi.DataViewObjects.getValue), 
                        TablixObjects.PropGridHorizontalColor = new TablixProperty(TablixObjects.ObjectGrid, "gridHorizontalColor", "#E8E8E8", powerbi.DataViewObjects.getFillColor), 
                        TablixObjects.PropGridHorizontalWeight = new TablixProperty(TablixObjects.ObjectGrid, "gridHorizontalWeight", 1, powerbi.DataViewObjects.getValue), 
                        TablixObjects.PropGridRowPadding = new TablixProperty(TablixObjects.ObjectGrid, "rowPadding", 0, powerbi.DataViewObjects.getValue), 
                        TablixObjects.PropGridOutlineColor = new TablixProperty(TablixObjects.ObjectGrid, "outlineColor", "#CCC", powerbi.DataViewObjects.getFillColor), 
                        TablixObjects.PropGridOutlineWeight = new TablixProperty(TablixObjects.ObjectGrid, "outlineWeight", 1, powerbi.DataViewObjects.getValue), 
                        TablixObjects.PropGridImageHeight = new TablixProperty(TablixObjects.ObjectGrid, "imageHeight", 75, powerbi.DataViewObjects.getValue), 
                        TablixObjects.PropColumnsFontColor = new TablixProperty(TablixObjects.ObjectColumnHeaders, "fontColor", "#666", powerbi.DataViewObjects.getFillColor), 
                        TablixObjects.PropColumnsBackColor = new TablixProperty(TablixObjects.ObjectColumnHeaders, "backColor", void 0, powerbi.DataViewObjects.getFillColor), 
                        TablixObjects.PropColumnsOutline = new TablixProperty(TablixObjects.ObjectColumnHeaders, "outline", "BottomOnly", powerbi.DataViewObjects.getValue), 
                        TablixObjects.PropRowsFontColor = new TablixProperty(TablixObjects.ObjectRowHeaders, "fontColor", "#666", powerbi.DataViewObjects.getFillColor), 
                        TablixObjects.PropRowsBackColor = new TablixProperty(TablixObjects.ObjectRowHeaders, "backColor", void 0, powerbi.DataViewObjects.getFillColor), 
                        TablixObjects.PropRowsOutline = new TablixProperty(TablixObjects.ObjectRowHeaders, "outline", "RightOnly", powerbi.DataViewObjects.getValue), 
                        TablixObjects.PropValuesBackColor = new TablixProperty(TablixObjects.ObjectValues, "backColor", void 0, powerbi.DataViewObjects.getFillColor), 
                        TablixObjects.PropValuesFontColorPrimary = new TablixProperty(TablixObjects.ObjectValues, "fontColorPrimary", "#333", powerbi.DataViewObjects.getFillColor), 
                        TablixObjects.PropValuesBackColorPrimary = new TablixProperty(TablixObjects.ObjectValues, "backColorPrimary", void 0, powerbi.DataViewObjects.getFillColor), 
                        TablixObjects.PropValuesFontColorSecondary = new TablixProperty(TablixObjects.ObjectValues, "fontColorSecondary", "#333", powerbi.DataViewObjects.getFillColor), 
                        TablixObjects.PropValuesBackColorSecondary = new TablixProperty(TablixObjects.ObjectValues, "backColorSecondary", void 0, powerbi.DataViewObjects.getFillColor), 
                        TablixObjects.PropValuesOutline = new TablixProperty(TablixObjects.ObjectValues, "outline", "None", powerbi.DataViewObjects.getValue), 
                        TablixObjects.PropValuesUrlIconProp = new TablixProperty(TablixObjects.ObjectValues, "urlIcon", !1, powerbi.DataViewObjects.getValue), 
                        TablixObjects.PropTotalFontColor = new TablixProperty(TablixObjects.ObjectTotal, "fontColor", "#333", powerbi.DataViewObjects.getFillColor), 
                        TablixObjects.PropTotalBackColor = new TablixProperty(TablixObjects.ObjectTotal, "backColor", void 0, powerbi.DataViewObjects.getFillColor), 
                        TablixObjects.PropTotalOutline = new TablixProperty(TablixObjects.ObjectTotal, "outline", "TopOnly", powerbi.DataViewObjects.getValue), 
                        TablixObjects.PropSubTotalsFontColor = new TablixProperty(TablixObjects.ObjectSubTotals, "fontColor", "#333", powerbi.DataViewObjects.getFillColor), 
                        TablixObjects.PropSubTotalsBackColor = new TablixProperty(TablixObjects.ObjectSubTotals, "backColor", void 0, powerbi.DataViewObjects.getFillColor), 
                        TablixObjects.PropSubTotalsOutline = new TablixProperty(TablixObjects.ObjectSubTotals, "outline", "TopOnly", powerbi.DataViewObjects.getValue), 
                        TablixObjects.getMetadadataObjects = getMetadadataObjects, TablixObjects.enumerateObjectRepetition = enumerateObjectRepetition, 
                        TablixObjects.enumerateObjectInstances = enumerateObjectInstances, TablixObjects.enumerateGeneralOptions = enumerateGeneralOptions, 
                        TablixObjects.enumerateGridOptions = enumerateGridOptions, TablixObjects.enumerateColumnHeadersOptions = enumerateColumnHeadersOptions, 
                        TablixObjects.enumerateRowHeadersOptions = enumerateRowHeadersOptions, TablixObjects.enumerateValuesOptions = enumerateValuesOptions, 
                        TablixObjects.enumerateTotalOptions = enumerateTotalOptions, TablixObjects.enumerateSubTotalsOptions = enumerateSubTotalsOptions, 
                        TablixObjects.getTableObjects = getTableObjects, TablixObjects.getMatrixObjects = getMatrixObjects, 
                        TablixObjects.generateTablixDefaultObjects = generateTablixDefaultObjects, TablixObjects.getTextSizeInPx = getTextSizeInPx, 
                        TablixObjects.shouldShowTableTotals = shouldShowTableTotals, TablixObjects.shouldShowRowSubtotals = shouldShowRowSubtotals, 
                        TablixObjects.shouldShowColumnSubtotals = shouldShowColumnSubtotals, TablixObjects.shouldShowColumnSubtotalsOption = shouldShowColumnSubtotalsOption, 
                        TablixObjects.isDiscourageAggregationAcrossGroups = isDiscourageAggregationAcrossGroups;
                    }(TablixObjects = internal.TablixObjects || (internal.TablixObjects = {}));
                    var TablixUtils;
                    !function(TablixUtils) {
                        function createTable() {
                            return document.createElement("table");
                        }
                        function createDiv() {
                            var div = document.createElement("div");
                            return div.className = "tablixDiv", div;
                        }
                        function resetCellCssClass(cell) {
                            cell.extension.contentElement.className = TablixUtils.CssClassTablixDiv + " " + TablixUtils.CssClassContentElement, 
                            cell.extension.contentHost.className = TablixUtils.CssClassTablixDiv + " " + TablixUtils.CssClassContentHost;
                        }
                        function addCellCssClass(cell, style) {
                            cell.extension.contentHost.className += " " + style;
                        }
                        function clearCellStyle(cell) {
                            cell.extension.contentHost.className = "", cell.extension.contentHost.style.cssText = "";
                        }
                        function clearCellTextAndTooltip(cell) {
                            cell.extension.contentHost.textContent = "", cell.extension.contentHost.removeAttribute("title"), 
                            cell.contentHeight = cell.contentWidth = 0, controls.HTMLElementUtils.clearChildren(cell.extension.contentHost);
                        }
                        function setCellTextAndTooltip(text, elementText, elementTooltip) {
                            var val = visuals.TextUtil.replaceSpaceWithNBSP(text);
                            elementText.textContent = val, (elementTooltip || elementText).title = val;
                        }
                        function isValidSortClick(e) {
                            var colHeader = e.target, x = e.offsetX;
                            return x >= 0 && x < colHeader.offsetWidth - internal.TablixResizer.resizeHandleSize;
                        }
                        function appendATagToBodyCell(value, cellElement, urlIcon) {
                            var atag = null;
                            0 === cellElement.childElementCount ? (atag = document.createElement("a"), cellElement.appendChild(atag)) : atag = cellElement.children[0], 
                            atag.href = value, atag.target = "_blank", atag.title = value, urlIcon === !0 ? (atag.className = TablixUtils.CssClassValueURLIcon, 
                            cellElement.className = TablixUtils.CssClassValueURLIconContainer) : atag.innerText = value;
                        }
                        function appendImgTagToBodyCell(value, cellElement, imageHeight) {
                            var imgContainer = TablixUtils.createDiv(), imgTag = document.createElement("img");
                            imgContainer.style.height = imageHeight + "px", imgContainer.style.width = "100%", 
                            imgContainer.style.textAlign = "center", imgTag.src = value, imgTag.style.maxHeight = "100%", 
                            imgTag.style.maxWidth = "100%", imgContainer.appendChild(imgTag), cellElement.appendChild(imgContainer), 
                            cellElement.title = value;
                        }
                        function createKpiDom(kpi, kpiValue) {
                            var className = visuals.KpiUtil.getClassForKpi(kpi, kpiValue) || "";
                            return DomFactory.div().addClass(className).css({
                                display: "inline-block",
                                "vertical-align": "bottom",
                                margin: "0"
                            });
                        }
                        function isValidStatusGraphic(kpi, kpiValue) {
                            return kpi && void 0 !== kpiValue ? !!visuals.KpiUtil.getClassForKpi(kpi, kpiValue) : !1;
                        }
                        function getCustomSortEventArgs(queryName, sortDirection) {
                            var sortDescriptors = [ {
                                queryName: queryName,
                                sortDirection: sortDirection
                            } ];
                            return {
                                sortDescriptors: sortDescriptors
                            };
                        }
                        function reverseSort(sortDirection) {
                            return 2 === sortDirection ? 1 : 2;
                        }
                        function addSortIconToColumnHeader(itemSort, cellDiv) {
                            var colHeaderContainer = TablixUtils.createDiv();
                            itemSort ? (colHeaderContainer.appendChild(createSortIcon(itemSort, !0)), colHeaderContainer.appendChild(createSortIcon(reverseSort(itemSort), !1))) : colHeaderContainer.appendChild(createSortIcon(2, !1));
                            var colHeaderTitle = TablixUtils.createDiv();
                            return colHeaderContainer.appendChild(colHeaderTitle), cellDiv.appendChild(colHeaderContainer), 
                            colHeaderTitle;
                        }
                        function createSortIcon(sort, isSorted) {
                            var imgSort = document.createElement("i");
                            return imgSort.className = SortIconContainerClassName + " " + (isSorted ? "sorted" : "future") + " " + (1 === sort ? "powervisuals-glyph caret-up" : "powervisuals-glyph caret-down"), 
                            imgSort;
                        }
                        function checkSortIconExists(cell) {
                            for (var i = 0, len = cell.extension.contentElement.childElementCount; len > i; i++) {
                                var element = cell.extension.contentElement.children.item(i);
                                if (element.classList.contains(SortIconContainerClassName)) return !0;
                            }
                            return !1;
                        }
                        function removeSortIcons(cell) {
                            checkSortIconExists(cell) && $(cell.extension.contentElement).find("." + SortIconContainerClassName).remove();
                        }
                        TablixUtils.CssClassTablixDiv = "tablixDiv", TablixUtils.CssClassContentElement = "tablixCellContentElement", 
                        TablixUtils.CssClassContentHost = "tablixCellContentHost", TablixUtils.CssClassTablixHeader = "tablixHeader", 
                        TablixUtils.CssClassTablixColumnHeaderLeaf = "tablixColumnHeaderLeaf", TablixUtils.CssClassTablixValueNumeric = "tablixValueNumeric", 
                        TablixUtils.CssClassTablixValueTotal = "tablixValueTotal", TablixUtils.CssClassValueURLIcon = "powervisuals-glyph url-icon tablixUrlIconGlyph", 
                        TablixUtils.CssClassValueURLIconContainer = "tablixValueUrlIcon", TablixUtils.CssClassMatrixRowHeaderLeaf = "matrixRowHeaderLeaf", 
                        TablixUtils.CssClassMatrixRowHeaderSubTotal = "matrixRowHeaderSubTotal", TablixUtils.CssClassTableFooter = "tableFooterCell", 
                        TablixUtils.CssClassTableBodyCell = "tableBodyCell", TablixUtils.CssClassTableBodyCellBottom = "tableBodyCellBottom", 
                        TablixUtils.StringNonBreakingSpace = "&nbsp;", TablixUtils.UnitOfMeasurement = "px";
                        var SortIconContainerClassName = "tablixSortIconContainer";
                        TablixUtils.CellPaddingLeft = 10, TablixUtils.CellPaddingRight = 5, TablixUtils.CellPaddingLeftMatrixTotal = 5, 
                        TablixUtils.SortIconPadding = 5, TablixUtils.ImageDefaultAspectRatio = 1, TablixUtils.FontFamilyCell = visuals.Font.Family.regular.css, 
                        TablixUtils.FontFamilyHeader = visuals.Font.Family.regular.css, TablixUtils.FontFamilyTotal = visuals.Font.Family.bold.css, 
                        TablixUtils.FontColorCells = "#333", TablixUtils.FontColorHeaders = "#666", function(EdgeType) {
                            EdgeType[EdgeType.Outline = 0] = "Outline", EdgeType[EdgeType.Gridline = 1] = "Gridline";
                        }(TablixUtils.EdgeType || (TablixUtils.EdgeType = {}));
                        var EdgeType = TablixUtils.EdgeType, EdgeSettings = function() {
                            function EdgeSettings(weight, color) {
                                this.applyParams(!0, weight, color);
                            }
                            return EdgeSettings.prototype.applyParams = function(shown, weight, color, type) {
                                shown ? (this.weight = null == weight ? 0 : weight, this.color = null == color ? "black" : color, 
                                this.type = null == type ? EdgeType.Gridline : type) : (this.weight = 0, this.color = "black", 
                                this.type = EdgeType.Gridline);
                            }, EdgeSettings.prototype.getCSS = function() {
                                var css = [];
                                return _.isNumber(this.weight) && (css.push(this.weight + TablixUtils.UnitOfMeasurement), 
                                this.color && css.push(this.color), css.push("solid")), css.join(" ");
                            }, EdgeSettings.prototype.getPriority = function(edges) {
                                return this === edges.top || this === edges.bottom ? this.type === EdgeType.Outline ? 2 : 0 : this === edges.right || this === edges.left ? this.type === EdgeType.Outline ? 3 : 1 : -1;
                            }, EdgeSettings.prototype.getShadowCss = function(edges) {
                                var output = "inset ";
                                if (this === edges.left) output += this.weight + TablixUtils.UnitOfMeasurement + " 0"; else if (this === edges.right) output += "-" + this.weight + TablixUtils.UnitOfMeasurement + " 0"; else if (this === edges.top) output += "0 " + this.weight + TablixUtils.UnitOfMeasurement; else {
                                    if (this !== edges.bottom) return "";
                                    output += "0 -" + this.weight + TablixUtils.UnitOfMeasurement;
                                }
                                return output + " 0 0 " + this.color;
                            }, EdgeSettings;
                        }();
                        TablixUtils.EdgeSettings = EdgeSettings;
                        var CellStyle = function() {
                            function CellStyle() {
                                this.borders = {}, this.paddings = {
                                    top: 0,
                                    left: TablixUtils.CellPaddingLeft,
                                    bottom: 0,
                                    right: TablixUtils.CellPaddingRight
                                }, this.fontFamily = "", this.fontColor = "", this.backColor = "";
                            }
                            return CellStyle.prototype.applyStyle = function(cell) {
                                var _this = this, div = cell.extension.contentHost, style = div.style;
                                style.fontFamily = this.fontFamily, style.color = this.fontColor, style.backgroundColor = this.backColor;
                                var edges = [ this.borders.top, this.borders.right, this.borders.bottom, this.borders.left ];
                                edges = _.sortBy(edges, function(e) {
                                    return e ? e.getPriority(_this.borders) : -1;
                                }).reverse(), style.boxShadow = _.map(edges, function(e) {
                                    return e ? e.getShadowCss(_this.borders) : void 0;
                                }).join(", "), style.border = "none", style.paddingTop = (null == this.paddings.top ? 0 : this.paddings.top) + (null == this.borders.top ? 0 : this.borders.top.weight) + TablixUtils.UnitOfMeasurement, 
                                style.paddingRight = (null == this.paddings.right ? TablixUtils.CellPaddingRight : this.paddings.right) + (null == this.borders.right ? 0 : this.borders.right.weight) + TablixUtils.UnitOfMeasurement, 
                                style.paddingBottom = (null == this.paddings.bottom ? 0 : this.paddings.bottom) + (null == this.borders.bottom ? 0 : this.borders.bottom.weight) + TablixUtils.UnitOfMeasurement, 
                                style.paddingLeft = (null == this.paddings.left ? TablixUtils.CellPaddingLeft : this.paddings.left) + (null == this.borders.left ? 0 : this.borders.left.weight) + TablixUtils.UnitOfMeasurement;
                            }, CellStyle.prototype.getExtraTop = function() {
                                var extra = 0;
                                return this.paddings.top && (extra += this.paddings.top), this.borders.top && (extra += this.borders.top.weight), 
                                extra;
                            }, CellStyle.prototype.getExtraBottom = function() {
                                var extra = 0;
                                return this.paddings.bottom && (extra += this.paddings.bottom), this.borders.bottom && (extra += this.borders.bottom.weight), 
                                extra;
                            }, CellStyle.prototype.getExtraRight = function() {
                                var extra = 0;
                                return this.paddings.right && (extra += this.paddings.right), this.borders.right && (extra += this.borders.right.weight), 
                                extra;
                            }, CellStyle.prototype.getExtraLeft = function() {
                                var extra = 0;
                                return this.paddings.left && (extra += this.paddings.left), this.borders.left && (extra += this.borders.left.weight), 
                                extra;
                            }, CellStyle;
                        }();
                        TablixUtils.CellStyle = CellStyle;
                        var DimensionPosition = function() {
                            function DimensionPosition() {}
                            return DimensionPosition;
                        }();
                        TablixUtils.DimensionPosition = DimensionPosition;
                        var CellPosition = function() {
                            function CellPosition() {
                                this.row = new DimensionPosition(), this.column = new DimensionPosition();
                            }
                            return CellPosition.prototype.isMatch = function(position) {
                                return this.column.index === position.column.index && this.row.index === position.row.index;
                            }, CellPosition;
                        }();
                        TablixUtils.CellPosition = CellPosition;
                        var TablixVisualCell = function() {
                            function TablixVisualCell(dataPoint, isTotal, columnMetadata, formatter, nullsAreBlank) {
                                this.dataPoint = dataPoint, this.columnMetadata = columnMetadata, this.formatter = formatter, 
                                this.isTotal = isTotal, this.nullsAreBlank = nullsAreBlank, this.position = new TablixUtils.CellPosition();
                            }
                            return Object.defineProperty(TablixVisualCell.prototype, "textContent", {
                                get: function() {
                                    return this.formatter ? this.formatter(this.dataPoint, this.columnMetadata, TablixObjects.PropColumnFormatString.getPropertyID(), this.nullsAreBlank) : null != this.dataPoint ? this.dataPoint : "";
                                },
                                enumerable: !0,
                                configurable: !0
                            }), Object.defineProperty(TablixVisualCell.prototype, "kpiContent", {
                                get: function() {
                                    return this.columnMetadata && isValidStatusGraphic(this.columnMetadata.kpi, this.textContent) ? createKpiDom(this.columnMetadata.kpi, this.textContent) : void 0;
                                },
                                enumerable: !0,
                                configurable: !0
                            }), Object.defineProperty(TablixVisualCell.prototype, "isNumeric", {
                                get: function() {
                                    return this.columnMetadata ? this.columnMetadata.type.numeric && !this.columnMetadata.kpi : void 0;
                                },
                                enumerable: !0,
                                configurable: !0
                            }), Object.defineProperty(TablixVisualCell.prototype, "isUrl", {
                                get: function() {
                                    return this.columnMetadata ? visuals.converterHelper.isWebUrlColumn(this.columnMetadata) : void 0;
                                },
                                enumerable: !0,
                                configurable: !0
                            }), Object.defineProperty(TablixVisualCell.prototype, "isImage", {
                                get: function() {
                                    return this.columnMetadata ? visuals.converterHelper.isImageUrlColumn(this.columnMetadata) : void 0;
                                },
                                enumerable: !0,
                                configurable: !0
                            }), Object.defineProperty(TablixVisualCell.prototype, "isValidUrl", {
                                get: function() {
                                    return jsCommon.UrlUtils.isValidImageUrl(this.textContent);
                                },
                                enumerable: !0,
                                configurable: !0
                            }), TablixVisualCell.prototype.isMatch = function(item) {
                                return this.position.isMatch(item.position) && this.backColor === item.backColor;
                            }, TablixVisualCell;
                        }();
                        TablixUtils.TablixVisualCell = TablixVisualCell, TablixUtils.createTable = createTable, 
                        TablixUtils.createDiv = createDiv, TablixUtils.resetCellCssClass = resetCellCssClass, 
                        TablixUtils.addCellCssClass = addCellCssClass, TablixUtils.clearCellStyle = clearCellStyle, 
                        TablixUtils.clearCellTextAndTooltip = clearCellTextAndTooltip, TablixUtils.setCellTextAndTooltip = setCellTextAndTooltip, 
                        TablixUtils.isValidSortClick = isValidSortClick, TablixUtils.appendATagToBodyCell = appendATagToBodyCell, 
                        TablixUtils.appendImgTagToBodyCell = appendImgTagToBodyCell, TablixUtils.createKpiDom = createKpiDom, 
                        TablixUtils.isValidStatusGraphic = isValidStatusGraphic, TablixUtils.getCustomSortEventArgs = getCustomSortEventArgs, 
                        TablixUtils.reverseSort = reverseSort, TablixUtils.addSortIconToColumnHeader = addSortIconToColumnHeader, 
                        TablixUtils.removeSortIcons = removeSortIcons;
                    }(TablixUtils = internal.TablixUtils || (internal.TablixUtils = {}));
                }(internal = controls.internal || (controls.internal = {}));
            }(controls = visuals.controls || (visuals.controls = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    window.jsCommon, window.powerbi, window.powerbitests, window.InJs, window.debug, 
    window.jasmine, window.Microsoft;
}, function(module, exports) {
    window.jsCommon, window.powerbi, window.powerbitests, window.InJs, window.debug, 
    window.jasmine, window.Microsoft;
}, function(module, exports) {
    window.jsCommon, window.powerbi, window.powerbitests, window.InJs, window.debug, 
    window.jasmine, window.Microsoft;
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var controls;
            !function(controls) {
                controls.TablixDefaultTextSize = jsCommon.TextSizeDefaults.TextSizeMin;
                var TablixControl = function() {
                    function TablixControl(hierarchyNavigator, layoutManager, binder, parentDomElement, options) {
                        var _this = this;
                        this.scrollBarElementWidth = 9, this.options = options;
                        var isInteractive = options.interactive;
                        this.isTouchEnabled = isInteractive && options.enableTouchSupport, this.mainDiv = controls.internal.TablixUtils.createDiv(), 
                        this.mainDiv.classList.add(TablixControl.TablixTableAreaClassName), this.footerDiv = controls.internal.TablixUtils.createDiv(), 
                        this.footerDiv.classList.add(TablixControl.TablixFooterClassName), this.isTouchEnabled && this.InitializeTouchSupport(), 
                        this.gridDimensions = {}, this.containerElement = controls.internal.TablixUtils.createDiv(), 
                        this.className = layoutManager.getTablixClassName(), this.autoSizeWidth = !1, this.autoSizeHeight = !1, 
                        this.fontFamily = controls.internal.TablixUtils.FontFamilyCell, this.fontColor = controls.internal.TablixUtils.FontColorCells, 
                        this.fontSize = options.fontSize, parentDomElement.className = TablixControl.TablixContainerClassName, 
                        parentDomElement.appendChild(this.containerElement), this.containerElement.addEventListener("mousewheel", function(e) {
                            _this.onMouseWheel(e);
                        }), this.containerElement.addEventListener("DOMMouseScroll", function(e) {
                            _this.onFireFoxMouseWheel(e);
                        }), this.containerElement.appendChild(this.mainDiv), this.containerElement.appendChild(this.footerDiv), 
                        this.isTouchEnabled && (this.touchInterpreter.initTouch(this.mainDiv, null, !1), 
                        this.footerTouchInterpreter.initTouch(this.footerDiv, this.mainDiv, !1)), this.controlLayoutManager = layoutManager, 
                        this.controlLayoutManager.initialize(this), this.hierarchyTablixNavigator = hierarchyNavigator, 
                        this.binder = binder, this.columnDim = new controls.TablixColumnDimension(this), 
                        this.rowDim = new controls.TablixRowDimension(this), this.columnDim._otherDimension = this.rowDimension, 
                        this.rowDim._otherDimension = this.columnDimension, this.InitializeScrollbars(), 
                        isInteractive || (this.scrollbarWidth = 0), this.updateHorizontalPosition(), this.updateVerticalPosition(), 
                        this.updateFooterVisibility(), this.lastRenderingArgs = {};
                    }
                    return TablixControl.prototype.InitializeTouchSupport = function() {
                        this.touchManager = new controls.TouchUtils.TouchManager(), this.touchInterpreter = new controls.TouchUtils.TouchEventInterpreter(this.touchManager), 
                        this.footerTouchInterpreter = new controls.TouchUtils.TouchEventInterpreter(this.touchManager), 
                        this.columnTouchDelegate = new controls.ColumnTouchDelegate(new controls.TouchUtils.Rectangle()), 
                        this.rowTouchDelegate = new controls.RowTouchDelegate(new controls.TouchUtils.Rectangle()), 
                        this.bodyTouchDelegate = new controls.BodyTouchDelegate(new controls.TouchUtils.Rectangle()), 
                        this.footerTouchDelegate = new controls.ColumnTouchDelegate(new controls.TouchUtils.Rectangle()), 
                        this.columnTouchDelegate.setHandler(this, this.onTouchEvent), this.rowTouchDelegate.setHandler(this, this.onTouchEvent), 
                        this.bodyTouchDelegate.setHandler(this, this.onTouchEvent), this.footerTouchDelegate.setHandler(this, this.onTouchEvent), 
                        this.touchManager.addTouchRegion(this.columnTouchDelegate.dimension, this.columnTouchDelegate, this.columnTouchDelegate), 
                        this.touchManager.addTouchRegion(this.rowTouchDelegate.dimension, this.rowTouchDelegate, this.rowTouchDelegate), 
                        this.touchManager.addTouchRegion(this.bodyTouchDelegate.dimension, this.bodyTouchDelegate, this.bodyTouchDelegate), 
                        this.touchManager.addTouchRegion(this.footerTouchDelegate.dimension, this.footerTouchDelegate, this.footerTouchDelegate);
                    }, TablixControl.prototype.InitializeScrollbars = function() {
                        this.rowDim._initializeScrollbar(this.containerElement, null, this.options.layoutKind);
                        var rowDimensionScrollbarStyle = this.rowDim.scrollbar.element.style;
                        rowDimensionScrollbarStyle.position = "absolute", rowDimensionScrollbarStyle.top = "0" + TablixControl.UnitOfMeasurement, 
                        rowDimensionScrollbarStyle.right = "0" + TablixControl.UnitOfMeasurement, this.rowDim.scrollbar.width = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement, 
                        this.rowDim.scrollbar.show(!0), this.columnDim._initializeScrollbar(this.containerElement, null, this.options.layoutKind);
                        var columnDimensionScrollbarStyle = this.columnDim.scrollbar.element.style;
                        columnDimensionScrollbarStyle.position = "absolute", columnDimensionScrollbarStyle.left = "0" + TablixControl.UnitOfMeasurement, 
                        columnDimensionScrollbarStyle.bottom = "0" + TablixControl.UnitOfMeasurement, this.columnDim.scrollbar.height = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement, 
                        this.columnDim.scrollbar.show(!1);
                    }, Object.defineProperty(TablixControl.prototype, "container", {
                        get: function() {
                            return this.containerElement;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixControl.prototype, "contentHost", {
                        get: function() {
                            return this.mainDiv;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixControl.prototype, "footerHost", {
                        get: function() {
                            return this.footerDiv;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixControl.prototype, "className", {
                        set: function(value) {
                            this.containerElement.className = value;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixControl.prototype, "hierarchyNavigator", {
                        get: function() {
                            return this.hierarchyTablixNavigator;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), TablixControl.prototype.getBinder = function() {
                        return this.binder;
                    }, Object.defineProperty(TablixControl.prototype, "autoSizeWidth", {
                        get: function() {
                            return this._autoSizeWidth;
                        },
                        set: function(value) {
                            this._autoSizeWidth = value, value || (this.containerElement.style.minWidth = this.containerElement.style.maxWidth = "none");
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixControl.prototype, "autoSizeHeight", {
                        get: function() {
                            return this._autoSizeHeight;
                        },
                        set: function(value) {
                            value || (this.containerElement.style.minHeight = this.containerElement.style.maxHeight = "none");
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixControl.prototype, "maxWidth", {
                        get: function() {
                            return this.maximumWidth;
                        },
                        set: function(value) {
                            this.maximumWidth = value, this.containerElement.style.maxWidth = this.maximumWidth + TablixControl.UnitOfMeasurement;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixControl.prototype, "viewport", {
                        get: function() {
                            return this.viewPort;
                        },
                        set: function(value) {
                            this.viewPort = value, this.containerElement.style.width = this.viewPort.width + TablixControl.UnitOfMeasurement, 
                            this.containerElement.style.height = this.viewPort.height + TablixControl.UnitOfMeasurement, 
                            this.rowDim.scrollbar.invalidateArrange(), this.columnDim.scrollbar.invalidateArrange(), 
                            this.controlLayoutManager.updateViewport(this.viewPort);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixControl.prototype, "maxHeight", {
                        get: function() {
                            return this.maximumHeight;
                        },
                        set: function(value) {
                            this.maximumHeight = value, this.containerElement.style.maxHeight = this.maximumHeight + TablixControl.UnitOfMeasurement;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixControl.prototype, "minWidth", {
                        get: function() {
                            return this.minimumWidth;
                        },
                        set: function(value) {
                            this.minimumWidth = value, this.containerElement.style.minWidth = this.minimumWidth + TablixControl.UnitOfMeasurement;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixControl.prototype, "minHeight", {
                        get: function() {
                            return this.minimumHeight;
                        },
                        set: function(value) {
                            this.minimumHeight = value, this.containerElement.style.minHeight = this.minimumHeight + TablixControl.UnitOfMeasurement;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixControl.prototype, "fontSize", {
                        get: function() {
                            return this.textFontSize;
                        },
                        set: function(value) {
                            this.textFontSize = value ? value : TablixControl.DefaultFontSize, this.containerElement.style.fontSize = this.textFontSize;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixControl.prototype, "fontFamily", {
                        get: function() {
                            return this.textFontFamily;
                        },
                        set: function(value) {
                            this.textFontFamily = value, this.containerElement.style.fontFamily = value;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixControl.prototype, "fontColor", {
                        get: function() {
                            return this.textFontColor;
                        },
                        set: function(value) {
                            this.textFontColor = value, this.containerElement.style.color = value;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixControl.prototype, "scrollbarWidth", {
                        set: function(value) {
                            this.scrollBarElementWidth = value, this.rowDim.scrollbar.width = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement, 
                            this.columnDim.scrollbar.height = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), TablixControl.prototype.updateModels = function(resetScrollOffsets, rowModel, columnModel) {
                        this.rowDim.model = rowModel, this.rowDim.modelDepth = this.hierarchyNavigator.getRowHierarchyDepth(), 
                        this.columnDim.model = columnModel, this.columnDim.modelDepth = this.hierarchyNavigator.getColumnHierarchyDepth(), 
                        resetScrollOffsets && (this.rowDim.scrollOffset = 0, this.columnDim.scrollOffset = 0), 
                        this.layoutManager.updateColumnCount(this.rowDim, this.columnDim);
                    }, TablixControl.prototype.updateColumnDimensions = function(rowHierarchyWidth, columnHierarchyWidth, count) {
                        var gridDimensions = this.gridDimensions;
                        gridDimensions.columnCount = count, gridDimensions.rowHierarchyWidth = rowHierarchyWidth, 
                        gridDimensions.columnHierarchyWidth = columnHierarchyWidth;
                    }, TablixControl.prototype.updateRowDimensions = function(columnHierarchyHeight, rowHierarchyHeight, rowHierarchyContentHeight, count, footerHeight) {
                        var gridDimensions = this.gridDimensions;
                        gridDimensions.rowCount = count, gridDimensions.rowHierarchyHeight = rowHierarchyHeight, 
                        gridDimensions.rowHierarchyContentHeight = rowHierarchyContentHeight, gridDimensions.columnHierarchyHeight = columnHierarchyHeight, 
                        gridDimensions.footerHeight = footerHeight;
                    }, TablixControl.prototype.updateTouchDimensions = function() {
                        var gridDimensions = this.gridDimensions;
                        this.columnTouchDelegate.resize(gridDimensions.rowHierarchyWidth, 0, gridDimensions.columnHierarchyWidth, gridDimensions.columnHierarchyHeight), 
                        this.columnTouchDelegate.setScrollDensity(gridDimensions.columnCount / gridDimensions.columnHierarchyWidth), 
                        this.rowTouchDelegate.resize(0, gridDimensions.columnHierarchyHeight, gridDimensions.rowHierarchyWidth, gridDimensions.rowHierarchyHeight), 
                        this.rowTouchDelegate.setScrollDensity(gridDimensions.rowCount / gridDimensions.rowHierarchyHeight), 
                        this.bodyTouchDelegate.resize(gridDimensions.rowHierarchyWidth, gridDimensions.columnHierarchyHeight, gridDimensions.columnHierarchyWidth, gridDimensions.rowHierarchyHeight), 
                        this.bodyTouchDelegate.setScrollDensity(gridDimensions.columnCount / gridDimensions.columnHierarchyWidth, gridDimensions.rowCount / gridDimensions.rowHierarchyHeight), 
                        this.footerTouchDelegate.resize(gridDimensions.rowHierarchyWidth, gridDimensions.columnHierarchyHeight + gridDimensions.rowHierarchyHeight, gridDimensions.columnHierarchyWidth, gridDimensions.footerHeight), 
                        this.footerTouchDelegate.setScrollDensity(gridDimensions.columnCount / gridDimensions.columnHierarchyWidth);
                    }, TablixControl.prototype.onMouseWheel = function(e) {
                        this.determineDimensionToScroll(e, function(dimension, delta) {
                            dimension.scrollbar.onMouseWheel(delta);
                        }), 0 === this.options.layoutKind && e.preventDefault();
                    }, TablixControl.prototype.onFireFoxMouseWheel = function(e) {
                        this.determineDimensionToScrollFirefox(e, function(dimension, delta) {
                            dimension.scrollbar.onMouseWheel(delta);
                        }), 0 === this.options.layoutKind && e.preventDefault();
                    }, TablixControl.prototype.determineDimensionToScroll = function(e, scrollCallback) {
                        this.rowDim.scrollbar.visible ? (e.wheelDeltaY && scrollCallback(this.rowDim, e.wheelDeltaY), 
                        e.wheelDeltaX && this.columnDim.scrollbar.visible && scrollCallback(this.columnDim, e.wheelDeltaX)) : this.columnDim.scrollbar.visible && (e.wheelDeltaX ? scrollCallback(this.columnDim, e.wheelDeltaX) : e.wheelDeltaY && scrollCallback(this.columnDim, e.wheelDeltaY));
                    }, TablixControl.prototype.determineDimensionToScrollFirefox = function(e, scrollCallback) {
                        if (e.detail) {
                            if (this.rowDim.scrollbar.visible) return void scrollCallback(this.rowDim, -e.detail);
                            if (this.columnDim.scrollbar.visible) return void scrollCallback(this.columnDim, -e.detail);
                        }
                    }, Object.defineProperty(TablixControl.prototype, "layoutManager", {
                        get: function() {
                            return this.controlLayoutManager;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixControl.prototype, "columnDimension", {
                        get: function() {
                            return this.columnDim;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixControl.prototype, "rowDimension", {
                        get: function() {
                            return this.rowDim;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), TablixControl.prototype.refresh = function(clear) {
                        this.render(clear, null);
                    }, TablixControl.prototype._onScrollAsync = function(dimension) {
                        var _this = this;
                        requestAnimationFrame(function() {
                            _this.performPendingScroll(dimension);
                        });
                    }, TablixControl.prototype.performPendingScroll = function(dimension) {
                        this.render(!1, dimension);
                    }, TablixControl.prototype.updateHorizontalPosition = function() {
                        this.rowDim.scrollbar.visible ? (this.columnDim.scrollbar.element.style.right = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement, 
                        this.footerDiv.style.right = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement, 
                        this.mainDiv.style.right = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement) : (this.columnDim.scrollbar.element.style.right = "0" + TablixControl.UnitOfMeasurement, 
                        this.mainDiv.style.right = "0" + TablixControl.UnitOfMeasurement, this.footerDiv.style.right = "0" + TablixControl.UnitOfMeasurement);
                    }, TablixControl.prototype.updateFooterVisibility = function() {
                        (this.rowDim.hasFooter() ? "block" !== this.footerDiv.style.display : "none" !== this.footerDiv.style.display) && (this.rowDim.hasFooter() ? this.footerDiv.style.display = "block" : this.footerDiv.style.display = "none");
                    }, TablixControl.prototype.updateVerticalPosition = function() {
                        var hasVerticalScrollbar = this.rowDim.scrollbar.visible, isDashboardTile = 1 === this.controlLayoutManager.getLayoutKind(), showFooter = hasVerticalScrollbar || isDashboardTile;
                        if (showFooter) {
                            var mainBottom = this.footerDiv.offsetHeight, footerBottom = 0, verticalScrollbarBottom = 0, hasHorizontalScrollbar = this.columnDim.scrollbar.visible;
                            hasHorizontalScrollbar && (mainBottom += this.scrollBarElementWidth, footerBottom += this.scrollBarElementWidth, 
                            verticalScrollbarBottom = this.scrollBarElementWidth), this.mainDiv.style.bottom = mainBottom + TablixControl.UnitOfMeasurement, 
                            this.rowDim.scrollbar.element.style.bottom = verticalScrollbarBottom + TablixControl.UnitOfMeasurement, 
                            this.footerDiv.style.bottom = footerBottom + TablixControl.UnitOfMeasurement, this.footerDiv.style.removeProperty("top");
                        } else this.footerDiv.style.top = this.gridDimensions.rowHierarchyContentHeight + TablixControl.UnitOfMeasurement, 
                        this.footerDiv.style.removeProperty("bottom"), this.mainDiv.style.removeProperty("bottom");
                    }, TablixControl.prototype.alreadyRendered = function(scrollingDimension) {
                        return scrollingDimension === this.lastRenderingArgs.scrollingDimension && this.rowDimension.scrollOffset === this.lastRenderingArgs.rowScrollOffset && this.columnDimension.scrollOffset === this.lastRenderingArgs.columnScrollOffset;
                    }, TablixControl.prototype.render = function(clear, scrollingDimension) {
                        if (this.columnDim.makeScrollOffsetValid(), this.rowDim.makeScrollOffsetValid(), 
                        clear || null === scrollingDimension) this.lastRenderingArgs = {}; else if (this.alreadyRendered(scrollingDimension)) return;
                        var done = !1;
                        this.renderIterationCount = 0, this.controlLayoutManager.onStartRenderingSession(scrollingDimension, this.mainDiv, clear);
                        var binder = this.binder;
                        binder.onStartRenderingSession();
                        for (var priorFooterHeight = this.gridDimensions.footerHeight, priorRowHierarchyHeight = this.gridDimensions.rowHierarchyHeight, priorRowHierarchyContentHeight = this.gridDimensions.rowHierarchyContentHeight; !done && this.renderIterationCount < TablixControl.MaxRenderIterationCount; ) {
                            var hScrollbarVisibility = this.columnDim.scrollbar.visible, vScrollbarVisibility = this.rowDim.scrollbar.visible;
                            this.columnDim._onStartRenderingIteration(), this.rowDim._onStartRenderingIteration(), 
                            this.controlLayoutManager.onStartRenderingIteration(clear), this.renderCorner(), 
                            this.columnDim._render(), this.rowDim._render(), done = this.controlLayoutManager.onEndRenderingIteration(), 
                            this.columnDim._onEndRenderingIteration(), this.rowDim._onEndRenderingIteration(), 
                            hScrollbarVisibility !== this.columnDim.scrollbar.visible && this.updateVerticalPosition(), 
                            vScrollbarVisibility !== this.rowDim.scrollbar.visible && this.updateHorizontalPosition(), 
                            this.renderIterationCount++;
                        }
                        this.controlLayoutManager.onEndRenderingSession(), binder.onEndRenderingSession(), 
                        this.isTouchEnabled && this.updateTouchDimensions(), this.lastRenderingArgs.rowScrollOffset = this.rowDimension.scrollOffset, 
                        this.lastRenderingArgs.columnScrollOffset = this.columnDimension.scrollOffset, this.updateContainerDimensions();
                        var lastRenderingArgs = this.lastRenderingArgs;
                        lastRenderingArgs.rowScrollOffset = this.rowDimension.scrollOffset, lastRenderingArgs.columnScrollOffset = this.columnDimension.scrollOffset, 
                        lastRenderingArgs.scrollingDimension = scrollingDimension, priorFooterHeight === this.gridDimensions.footerHeight && priorRowHierarchyHeight === this.gridDimensions.rowHierarchyHeight && priorRowHierarchyContentHeight === this.gridDimensions.rowHierarchyContentHeight || this.updateVerticalPosition(), 
                        this.options.interactive && (this.columnDim.scrollbar.refresh(), this.rowDim.scrollbar.refresh());
                    }, TablixControl.prototype.updateContainerDimensions = function() {
                        var gridDimensions = this.gridDimensions;
                        if (this._autoSizeWidth) {
                            var vScrollBarWidth = this.rowDim.scrollbar.visible ? this.scrollBarElementWidth : 0;
                            this.containerElement.style.width = gridDimensions.rowHierarchyWidth + gridDimensions.columnHierarchyWidth + vScrollBarWidth + TablixControl.UnitOfMeasurement;
                        }
                        if (this._autoSizeHeight) {
                            var hScrollBarHeight = this.columnDim.scrollbar.visible ? this.scrollBarElementWidth : 0;
                            this.containerElement.style.height = gridDimensions.columnHierarchyHeight + gridDimensions.rowHierarchyHeight + gridDimensions.footerHeight + hScrollBarHeight + TablixControl.UnitOfMeasurement;
                        }
                    }, TablixControl.prototype.cornerCellMatch = function(item, cell) {
                        var previousItem = cell.item;
                        return 0 === cell.type && previousItem && this.hierarchyTablixNavigator.cornerCellItemEquals(item, previousItem);
                    }, TablixControl.prototype.renderCorner = function() {
                        for (var columnDepth = this.columnDim.getDepth(), rowDepth = this.rowDim.getDepth(), i = 0; columnDepth > i; i++) for (var j = 0; rowDepth > j; j++) {
                            var item = this.hierarchyTablixNavigator.getCorner(j, i), cell = this.controlLayoutManager.getOrCreateCornerCell(item, j, i), match = this.cornerCellMatch(item, cell);
                            match || (this._unbindCell(cell), cell.type = 0, cell.item = item, this.binder.bindCornerCell(item, cell)), 
                            this.controlLayoutManager.onCornerCellRealized(item, cell);
                        }
                    }, TablixControl.prototype._unbindCell = function(cell) {
                        switch (cell.type) {
                          case 3:
                            this.binder.unbindBodyCell(cell.item, cell);
                            break;

                          case 2:
                            this.binder.unbindColumnHeader(cell.item, cell);
                            break;

                          case 1:
                            this.binder.unbindRowHeader(cell.item, cell);
                            break;

                          case 0:
                            this.binder.unbindCornerCell(cell.item, cell);
                        }
                        cell.item = null, cell.type = null;
                    }, TablixControl.prototype.onTouchEvent = function(args) {
                        var colShift, rowShift, that;
                        args && args.length > 0 && "columnDim" in args[0] && "rowDim" in args[0] && (that = args[0], 
                        colShift = that.columnDim.scrollbar.visible ? args[1] : 0, rowShift = that.rowDim.scrollbar.visible ? args[2] : 0, 
                        that.columnDim.scrollbar.viewMin = Math.max(0, that.columnDim.scrollbar.viewMin + colShift), 
                        that.columnDim.scrollOffset = Math.max(0, that.columnDim.scrollOffset + colShift), 
                        that.rowDim.scrollbar.viewMin = Math.max(0, that.rowDim.scrollbar.viewMin + rowShift), 
                        that.rowDim.scrollOffset = Math.max(0, that.rowDim.scrollOffset + rowShift), 0 === colShift ? that._onScrollAsync(that.rowDim) : 0 === rowShift ? that._onScrollAsync(that.columnDim) : that._onScrollAsync(null));
                    }, TablixControl.UnitOfMeasurement = "px", TablixControl.TablixContainerClassName = "tablixContainer", 
                    TablixControl.TablixTableAreaClassName = "tablixTableArea", TablixControl.TablixFooterClassName = "tableFooterArea", 
                    TablixControl.DefaultFontSize = jsCommon.PixelConverter.fromPoint(controls.TablixDefaultTextSize), 
                    TablixControl.MaxRenderIterationCount = 10, TablixControl;
                }();
                controls.TablixControl = TablixControl;
            }(controls = visuals.controls || (visuals.controls = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi), __extends = (window.powerbitests, 
    window.InJs, window.debug, window.jasmine, window.Microsoft, this && this.__extends || function(d, b) {
        function __() {
            this.constructor = d;
        }
        for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
    });
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var controls;
            !function(controls) {
                var TablixDimension = function() {
                    function TablixDimension(tablixControl) {
                        this._scrollStep = .1, this._owner = tablixControl, this._hierarchyNavigator = tablixControl.hierarchyNavigator, 
                        this._binder = tablixControl.getBinder(), this._tablixLayoutManager = tablixControl.layoutManager, 
                        this.scrollOffset = 0;
                    }
                    return TablixDimension.prototype._onStartRenderingIteration = function() {
                        this.updateScrollPosition();
                    }, TablixDimension.prototype._onEndRenderingIteration = function() {}, TablixDimension.prototype.getValidScrollOffset = function(scrollOffset) {
                        return Math.min(Math.max(scrollOffset, 0), Math.max(this.getItemsCount() - this._scrollStep, 0));
                    }, TablixDimension.prototype.makeScrollOffsetValid = function() {
                        this.scrollOffset = this.getValidScrollOffset(this.scrollOffset);
                    }, TablixDimension.prototype.getIntegerScrollOffset = function() {
                        return Math.floor(this.scrollOffset);
                    }, TablixDimension.prototype.getFractionScrollOffset = function() {
                        return this.scrollOffset - this.getIntegerScrollOffset();
                    }, Object.defineProperty(TablixDimension.prototype, "scrollbar", {
                        get: function() {
                            return this._scrollbar;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), TablixDimension.prototype.getFirstVisibleItem = function(level) {
                        return this._scrollItems[level];
                    }, TablixDimension.prototype.getFirstVisibleChild = function(item) {
                        return this._hierarchyNavigator.getAt(this._hierarchyNavigator.getChildren(item), this.getFirstVisibleChildIndex(item));
                    }, TablixDimension.prototype.getFirstVisibleChildIndex = function(item) {
                        var firstVisibleIndex, startItem = this.getFirstVisibleItem(this._hierarchyNavigator.getLevel(item) + 1);
                        return firstVisibleIndex = void 0 === startItem || void 0 !== startItem && this._hierarchyNavigator.getParent(startItem) !== item ? 0 : this._hierarchyNavigator.getIndex(startItem);
                    }, TablixDimension.prototype._initializeScrollbar = function(parentElement, touchDiv, layoutKind) {
                        var _this = this;
                        this._scrollbar = this._createScrollbar(parentElement, layoutKind), this._scrollbar._onscroll.push(function(e) {
                            return _this.onScroll();
                        }), touchDiv && (this.scrollbar.initTouch(touchDiv, !0), touchDiv.style.setProperty("-ms-touch-action", "pinch-zoom"));
                    }, TablixDimension.prototype.getItemsCount = function() {
                        return this.model ? this._hierarchyNavigator.getLeafCount(this.model) : 0;
                    }, TablixDimension.prototype.getDepth = function() {
                        return this.modelDepth;
                    }, TablixDimension.prototype.onScroll = function() {
                        this.scrollOffset = this._scrollbar.viewMin, this._owner._onScrollAsync(this);
                    }, Object.defineProperty(TablixDimension.prototype, "otherDimension", {
                        get: function() {
                            return this._otherDimension;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TablixDimension.prototype, "layoutManager", {
                        get: function() {
                            return this._layoutManager;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), TablixDimension.prototype._createScrollbar = function(parentElement, layoutKind) {
                        return null;
                    }, TablixDimension.prototype.updateScrollPosition = function() {
                        if (this._scrollItems = [], this.model) {
                            var firstVisibleScrollIndex = this.getIntegerScrollOffset(), firstVisible = this._hierarchyNavigator.getLeafAt(this.model, firstVisibleScrollIndex);
                            if (firstVisible) {
                                this._firstVisibleScrollIndex = firstVisibleScrollIndex;
                                do this._scrollItems[this._hierarchyNavigator.getLevel(firstVisible)] = firstVisible, 
                                firstVisible = this._hierarchyNavigator.getParent(firstVisible); while (null !== firstVisible);
                            }
                        }
                    }, TablixDimension;
                }();
                controls.TablixDimension = TablixDimension;
                var TablixRowDimension = function(_super) {
                    function TablixRowDimension(tablixControl) {
                        _super.call(this, tablixControl), this._layoutManager = this._tablixLayoutManager.rowLayoutManager, 
                        this._footer = null;
                    }
                    return __extends(TablixRowDimension, _super), TablixRowDimension.prototype.setFooter = function(footerHeader) {
                        this._footer = footerHeader, this._owner.updateFooterVisibility();
                    }, TablixRowDimension.prototype.hasFooter = function() {
                        return null !== this._footer;
                    }, TablixRowDimension.prototype._render = function() {
                        var firstVisibleRowItem = this.getFirstVisibleItem(0);
                        this.hasFooter() && (this.addFooterRowHeader(this._footer), this.addFooterBodyCells(this._footer)), 
                        void 0 !== firstVisibleRowItem && this.addNodes(this.model, 0, this.getDepth(), this._hierarchyNavigator.getIndex(firstVisibleRowItem));
                    }, TablixRowDimension.prototype._createScrollbar = function(parentElement, layoutKind) {
                        return new controls.VerticalScrollbar(parentElement, layoutKind);
                    }, TablixRowDimension.prototype.addNodes = function(items, rowIndex, depth, firstVisibleIndex) {
                        for (var count = this._hierarchyNavigator.getCount(items), i = firstVisibleIndex; count > i; i++) {
                            if (!this._layoutManager.needsToRealize) return;
                            var item = this._hierarchyNavigator.getAt(items, i), cell = this.addNode(item, items, rowIndex, depth);
                            rowIndex += cell.rowSpan;
                        }
                    }, TablixRowDimension.prototype.getFirstVisibleChildLeaf = function(item) {
                        for (var leaf = item; !this._hierarchyNavigator.isLeaf(leaf); ) leaf = this.getFirstVisibleChild(leaf);
                        return leaf;
                    }, TablixRowDimension.prototype.bindRowHeader = function(item, cell) {
                        this._binder.bindRowHeader(item, cell);
                    }, TablixRowDimension.prototype.addNode = function(item, items, rowIndex, depth) {
                        var previousCount, rowHeaderCell = this._tablixLayoutManager.getOrCreateRowHeader(item, items, rowIndex, this._hierarchyNavigator.getLevel(item)), match = this.rowHeaderMatch(item, rowHeaderCell);
                        return match || (this._owner._unbindCell(rowHeaderCell), rowHeaderCell.type = 1, 
                        rowHeaderCell.item = item, rowHeaderCell.unfixRowHeight()), this._hierarchyNavigator.isLeaf(item) ? (rowHeaderCell.colSpan = depth - this._hierarchyNavigator.getLevel(item), 
                        rowHeaderCell.rowSpan = 1, match || this.bindRowHeader(item, rowHeaderCell), this._tablixLayoutManager.onRowHeaderRealized(item, rowHeaderCell), 
                        this.addBodyCells(item, items, rowIndex)) : (previousCount = this._layoutManager.getRealizedItemsCount(), 
                        this.addNodes(this._hierarchyNavigator.getChildren(item), rowIndex, depth, this.getFirstVisibleChildIndex(item)), 
                        rowHeaderCell.colSpan = 1, rowHeaderCell.rowSpan = this._layoutManager.getRealizedItemsCount() - previousCount + 1, 
                        match || this.bindRowHeader(item, rowHeaderCell), this._tablixLayoutManager.onRowHeaderRealized(item, rowHeaderCell)), 
                        rowHeaderCell;
                    }, TablixRowDimension.prototype.rowHeaderMatch = function(item, cell) {
                        var previousItem = cell.item;
                        return 1 === cell.type && previousItem && this._hierarchyNavigator.headerItemEquals(item, previousItem);
                    }, TablixRowDimension.prototype.addBodyCells = function(item, items, rowIndex) {
                        for (var firstVisibleColumnIndex = this._otherDimension.getIntegerScrollOffset(), columnCount = this._otherDimension._layoutManager.getRealizedItemsCount() - this.getDepth(), hierarchyNavigator = this._hierarchyNavigator, otherModel = this._otherDimension.model, layoutManager = this._tablixLayoutManager, i = 0; columnCount > i; i++) {
                            var cellItem = hierarchyNavigator.getIntersection(item, hierarchyNavigator.getLeafAt(otherModel, firstVisibleColumnIndex + i)), cell = layoutManager.getOrCreateBodyCell(cellItem, item, items, rowIndex, i);
                            this.bindBodyCell(cellItem, cell), layoutManager.onBodyCellRealized(cellItem, cell);
                        }
                    }, TablixRowDimension.prototype.bindBodyCell = function(item, cell) {
                        var match = this.bodyCelMatch(item, cell);
                        match || (this._owner._unbindCell(cell), cell.type = 3, cell.item = item, cell.unfixRowHeight(), 
                        this._binder.bindBodyCell(item, cell));
                    }, TablixRowDimension.prototype.addFooterRowHeader = function(item) {
                        var cell = this._tablixLayoutManager.getOrCreateFooterRowHeader(item, this.model);
                        cell.colSpan = this.getDepth();
                        var match = this.rowHeaderMatch(item, cell);
                        match || (this._owner._unbindCell(cell), cell.type = 1, cell.item = item, cell.unfixRowHeight(), 
                        this.bindRowHeader(item, cell), this._tablixLayoutManager.onRowHeaderFooterRealized(item, cell));
                    }, TablixRowDimension.prototype.addFooterBodyCells = function(rowItem) {
                        for (var firstVisibleColumnIndex = this._otherDimension.getIntegerScrollOffset(), columnCount = this._otherDimension.layoutManager.getRealizedItemsCount() - this.getDepth(), layoutManager = this._tablixLayoutManager, i = 0; columnCount > i; i++) {
                            var columnItem = this._hierarchyNavigator.getLeafAt(this._otherDimension.model, firstVisibleColumnIndex + i), item = this._hierarchyNavigator.getIntersection(rowItem, columnItem), cell = layoutManager.getOrCreateFooterBodyCell(item, i);
                            this.bindBodyCell(item, cell), layoutManager.onBodyCellFooterRealized(item, cell);
                        }
                    }, TablixRowDimension.prototype.bodyCelMatch = function(item, cell) {
                        var previousItem = cell.item;
                        return 3 === cell.type && previousItem && this._hierarchyNavigator.bodyCellItemEquals(item, previousItem);
                    }, TablixRowDimension;
                }(TablixDimension);
                controls.TablixRowDimension = TablixRowDimension;
                var TablixColumnDimension = function(_super) {
                    function TablixColumnDimension(tablixControl) {
                        _super.call(this, tablixControl), this._layoutManager = this._tablixLayoutManager.columnLayoutManager;
                    }
                    return __extends(TablixColumnDimension, _super), TablixColumnDimension.prototype._render = function() {
                        var firstVisibleColumnItem = this.getFirstVisibleItem(0);
                        void 0 !== firstVisibleColumnItem && this.addNodes(this.model, 0, this.getDepth(), this._hierarchyNavigator.getIndex(firstVisibleColumnItem));
                    }, TablixColumnDimension.prototype._createScrollbar = function(parentElement, layoutKind) {
                        var scrollbar = new controls.HorizontalScrollbar(parentElement, layoutKind);
                        return scrollbar.smallIncrement = .2, scrollbar;
                    }, TablixColumnDimension.prototype.addNodes = function(items, columnIndex, depth, firstVisibleIndex) {
                        for (var count = this._hierarchyNavigator.getCount(items), i = firstVisibleIndex; count > i; i++) {
                            if (!this._layoutManager.needsToRealize) return;
                            var cell = this.addNode(this._hierarchyNavigator.getAt(items, i), items, columnIndex, depth);
                            columnIndex += cell.colSpan;
                        }
                    }, TablixColumnDimension.prototype.addNode = function(item, items, columnIndex, depth) {
                        var cell = this._tablixLayoutManager.getOrCreateColumnHeader(item, items, this._hierarchyNavigator.getLevel(item), columnIndex), match = this.columnHeaderMatch(item, cell);
                        if (match || (this._owner._unbindCell(cell), cell.type = 2, cell.item = item, cell.unfixRowHeight()), 
                        this._hierarchyNavigator.isLeaf(item)) cell.rowSpan = depth - this._hierarchyNavigator.getLevel(item); else {
                            var previousCount = this._layoutManager.getRealizedItemsCount();
                            this.addNodes(this._hierarchyNavigator.getChildren(item), columnIndex, depth, this.getFirstVisibleChildIndex(item));
                            var childrenLevelDifference = this._hierarchyNavigator.getChildrenLevelDifference(item);
                            childrenLevelDifference === 1 / 0 ? cell.rowSpan = 1 : cell.rowSpan = childrenLevelDifference, 
                            cell.colSpan = this._layoutManager.getRealizedItemsCount() - previousCount + 1;
                        }
                        return match || this._binder.bindColumnHeader(item, cell), this._tablixLayoutManager.onColumnHeaderRealized(item, cell), 
                        cell;
                    }, TablixColumnDimension.prototype.columnHeaderMatch = function(item, cell) {
                        var previousItem = cell.item;
                        return 2 === cell.type && previousItem && this._hierarchyNavigator.headerItemEquals(item, previousItem);
                    }, TablixColumnDimension;
                }(TablixDimension);
                controls.TablixColumnDimension = TablixColumnDimension;
            }(controls = visuals.controls || (visuals.controls = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var controls;
            !function(controls) {
                var ColumnTouchDelegate = function() {
                    function ColumnTouchDelegate(region) {
                        this.dim = region, this.averageSize = 1, this.handlers = null, this.tablixControl = null;
                    }
                    return Object.defineProperty(ColumnTouchDelegate.prototype, "dimension", {
                        get: function() {
                            return this.dim;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), ColumnTouchDelegate.prototype.setScrollDensity = function(xRatio) {
                        this.averageSize = xRatio;
                    }, ColumnTouchDelegate.prototype.resize = function(x, y, width, height) {
                        this.dim.x = x, this.dim.y = y, this.dim.width = width, this.dim.height = height;
                    }, ColumnTouchDelegate.prototype.getPixelToItem = function(x, y, dx, dy, down) {
                        return new controls.TouchUtils.TouchEvent(x * this.averageSize, 0, down, -dx * this.averageSize, 0);
                    }, ColumnTouchDelegate.prototype.touchEvent = function(e) {
                        var args = [];
                        args[0] = this.tablixControl, args[1] = e.dx, args[2] = e.dy, this.handlers && controls.fire([ this.handlers ], args);
                    }, ColumnTouchDelegate.prototype.setHandler = function(tablixObj, handlerCall) {
                        this.handlers = handlerCall, this.tablixControl = tablixObj;
                    }, ColumnTouchDelegate;
                }();
                controls.ColumnTouchDelegate = ColumnTouchDelegate;
                var RowTouchDelegate = function() {
                    function RowTouchDelegate(region) {
                        this.dim = region, this.averageSize = 30, this.handlers = null, this.tablixControl = null;
                    }
                    return Object.defineProperty(RowTouchDelegate.prototype, "dimension", {
                        get: function() {
                            return this.dim;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), RowTouchDelegate.prototype.setScrollDensity = function(yRatio) {
                        this.averageSize = yRatio;
                    }, RowTouchDelegate.prototype.resize = function(x, y, width, height) {
                        this.dim.x = x, this.dim.y = y, this.dim.width = width, this.dim.height = height;
                    }, RowTouchDelegate.prototype.getPixelToItem = function(x, y, dx, dy, down) {
                        var event = new controls.TouchUtils.TouchEvent(0, y * this.averageSize, down, 0, -dy * this.averageSize);
                        return event;
                    }, RowTouchDelegate.prototype.touchEvent = function(e) {
                        var args = [];
                        args[0] = this.tablixControl, args[1] = e.dx, args[2] = e.dy, this.handlers && controls.fire([ this.handlers ], args);
                    }, RowTouchDelegate.prototype.setHandler = function(tablixObj, handlerCall) {
                        this.handlers = handlerCall, this.tablixControl = tablixObj;
                    }, RowTouchDelegate;
                }();
                controls.RowTouchDelegate = RowTouchDelegate;
                var BodyTouchDelegate = function() {
                    function BodyTouchDelegate(region) {
                        this.dim = region, this.averageSizeX = BodyTouchDelegate.DefaultAverageSizeX, this.averageSizeY = BodyTouchDelegate.DefaultAverageSizeY, 
                        this.handlers = null, this.tablixControl = null;
                    }
                    return Object.defineProperty(BodyTouchDelegate.prototype, "dimension", {
                        get: function() {
                            return this.dim;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), BodyTouchDelegate.prototype.setScrollDensity = function(xRatio, yRatio) {
                        this.averageSizeX = xRatio, this.averageSizeY = yRatio;
                    }, BodyTouchDelegate.prototype.resize = function(x, y, width, height) {
                        var dimension = this.dim;
                        dimension.x = x, dimension.y = y, dimension.width = width, dimension.height = height;
                    }, BodyTouchDelegate.prototype.getPixelToItem = function(x, y, dx, dy, down) {
                        return new controls.TouchUtils.TouchEvent(x * this.averageSizeX, y * this.averageSizeY, down, -dx * this.averageSizeX, -dy * this.averageSizeY);
                    }, BodyTouchDelegate.prototype.touchEvent = function(e) {
                        var args = [ this.tablixControl, e.dx, e.dy ];
                        this.handlers && controls.fire([ this.handlers ], args);
                    }, BodyTouchDelegate.prototype.setHandler = function(tablixObj, handlerCall) {
                        this.handlers = handlerCall, this.tablixControl = tablixObj;
                    }, BodyTouchDelegate.DefaultAverageSizeX = 30, BodyTouchDelegate.DefaultAverageSizeY = 30, 
                    BodyTouchDelegate;
                }();
                controls.BodyTouchDelegate = BodyTouchDelegate;
            }(controls = visuals.controls || (visuals.controls = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi), __extends = (window.powerbitests, 
    window.InJs, window.debug, window.jasmine, window.Microsoft, this && this.__extends || function(d, b) {
        function __() {
            this.constructor = d;
        }
        for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
    });
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var controls;
            !function(controls) {
                var TouchUtils;
                !function(TouchUtils) {
                    var Point = function() {
                        function Point(x, y) {
                            this.x = x || 0, this.y = y || 0;
                        }
                        return Point.prototype.offset = function(offsetX, offsetY) {
                            this.x += offsetX, this.y += offsetY;
                        }, Point;
                    }();
                    TouchUtils.Point = Point;
                    var Rectangle = function(_super) {
                        function Rectangle(x, y, width, height) {
                            _super.call(this, x, y), this.width = width || 0, this.height = height || 0;
                        }
                        return __extends(Rectangle, _super), Object.defineProperty(Rectangle.prototype, "point", {
                            get: function() {
                                return new Point(this.x, this.y);
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Rectangle.prototype.contains = function(p) {
                            return Rectangle.contains(this, p);
                        }, Rectangle.contains = function(rect, p) {
                            return p && !Rectangle.isEmpty(rect) ? rect.x <= p.x && p.x < rect.x + rect.width && rect.y <= p.y && p.y < rect.y + rect.height : !1;
                        }, Rectangle.isEmpty = function(rect) {
                            return !(void 0 !== rect && rect.width >= 0 && rect.height >= 0);
                        }, Rectangle;
                    }(Point);
                    TouchUtils.Rectangle = Rectangle, function(MouseButton) {
                        MouseButton[MouseButton.NoClick = 0] = "NoClick", MouseButton[MouseButton.LeftClick = 1] = "LeftClick", 
                        MouseButton[MouseButton.RightClick = 2] = "RightClick", MouseButton[MouseButton.CenterClick = 3] = "CenterClick";
                    }(TouchUtils.MouseButton || (TouchUtils.MouseButton = {}));
                    var MouseButton = TouchUtils.MouseButton, TouchEvent = function() {
                        function TouchEvent(x, y, isMouseDown, dx, dy) {
                            this._x = x, this._y = y, this.isMouseButtonDown = isMouseDown, this._dx = dx || 0, 
                            this._dy = dy || 0;
                        }
                        return Object.defineProperty(TouchEvent.prototype, "x", {
                            get: function() {
                                return this._x;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(TouchEvent.prototype, "y", {
                            get: function() {
                                return this._y;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(TouchEvent.prototype, "dx", {
                            get: function() {
                                return this._dx;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(TouchEvent.prototype, "dy", {
                            get: function() {
                                return this._dy;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(TouchEvent.prototype, "isMouseDown", {
                            get: function() {
                                return this.isMouseButtonDown;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), TouchEvent;
                    }();
                    TouchUtils.TouchEvent = TouchEvent;
                    var TouchManager = function() {
                        function TouchManager() {
                            this.touchList = [], this.swipeDirection = 2, this.matchingDirectionCount = 0, this.lockThreshold = !0, 
                            this.scrollThreshold = !0, this.lastTouchEvent = new TouchEvent(0, 0, !1);
                        }
                        return Object.defineProperty(TouchManager.prototype, "lastEvent", {
                            get: function() {
                                return this.lastTouchEvent;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), TouchManager.prototype.addTouchRegion = function(region, handler, converter) {
                            var item = {
                                lastPoint: new TouchEvent(0, 0, !1),
                                handler: handler,
                                region: region,
                                converter: converter
                            };
                            this.touchList = this.touchList.concat([ item ]);
                        }, TouchManager.prototype.upAllTouches = function() {
                            var eventPoint, length;
                            length = this.touchList.length;
                            for (var i = 0; length > i; i++) this.touchList[i].lastPoint.isMouseDown && (eventPoint = this.touchList[i].converter.getPixelToItem(this.touchList[i].lastPoint.x, this.touchList[i].lastPoint.y, 0, 0, !1), 
                            this.touchList[i].handler.touchEvent(eventPoint)), this.touchList[i].lastPoint = new TouchEvent(this.touchList[i].lastPoint.x, this.touchList[i].lastPoint.y, !1);
                            this.lastTouchEvent = new TouchEvent(0, 0, !1);
                        }, TouchManager.prototype.touchEvent = function(e) {
                            var list, length, x = 0, y = 0, dx = 0, dy = 0, angle = 0, eventPoint = null;
                            list = this._getActive(), !this.lastTouchEvent.isMouseDown && e.isMouseDown && (list = this._findRegions(e)), 
                            dx = this.lastTouchEvent.x - e.x, dy = this.lastTouchEvent.y - e.y, this.lastTouchEvent = new TouchEvent(e.x, e.y, e.isMouseDown, dx, dy), 
                            length = list.length;
                            for (var i = 0; length > i; i++) x = e.x - list[i].region.point.x, y = e.y - list[i].region.point.y, 
                            list[i].lastPoint.isMouseDown && e.isMouseDown ? (dx = x - list[i].lastPoint.x, 
                            dy = y - list[i].lastPoint.y, angle = Math.abs(180 / Math.PI * Math.atan(dy / dx)), 
                            this.scrollThreshold && (this.lockThreshold && this.matchingDirectionCount > 5 ? 1 === this.swipeDirection ? dy = 0 : 0 === this.swipeDirection && (dx = 0) : 20 > angle ? (dy = 0, 
                            1 === this.swipeDirection ? this.matchingDirectionCount++ : (this.matchingDirectionCount = 1, 
                            this.swipeDirection = 1)) : (angle = Math.abs(180 / Math.PI * Math.atan(dx / dy)), 
                            20 > angle ? (dx = 0, 0 === this.swipeDirection ? this.matchingDirectionCount++ : (this.matchingDirectionCount = 1, 
                            this.swipeDirection = 0)) : 2 === this.swipeDirection ? this.matchingDirectionCount++ : (this.swipeDirection = 2, 
                            this.matchingDirectionCount = 1)))) : (dx = 0, dy = 0, this.swipeDirection = 2, 
                            this.matchingDirectionCount = 0), list[i].lastPoint = new TouchEvent(x, y, e.isMouseDown, dx, dy), 
                            eventPoint = list[i].converter.getPixelToItem(x, y, dx, dy, e.isMouseDown), list[i].handler.touchEvent(eventPoint);
                        }, TouchManager.prototype._findRegions = function(e) {
                            var length, list = [];
                            length = this.touchList.length;
                            for (var i = 0; length > i; i++) this.touchList[i].region.contains(new Point(e.x, e.y)) && (list = list.concat([ this.touchList[i] ]));
                            return list;
                        }, TouchManager.prototype._getActive = function() {
                            var length, list = [];
                            length = this.touchList.length;
                            for (var i = 0; length > i; i++) this.touchList[i].lastPoint.isMouseDown && (list = list.concat([ this.touchList[i] ]));
                            return list;
                        }, TouchManager;
                    }();
                    TouchUtils.TouchManager = TouchManager;
                    var MinDistanceForSwipe = 80, MaxTimeForSwipe = 600, TouchEventInterpreter = function() {
                        function TouchEventInterpreter(manager) {
                            this.manager = manager, this.allowMouseDrag = !0, this.touchPanel = null, this.scale = 1, 
                            this.documentMouseMoveWrapper = null, this.documentMouseUpWrapper = null, this.sliding = !1;
                        }
                        return TouchEventInterpreter.prototype.initTouch = function(panel, touchReferencePoint, allowMouseDrag) {
                            var _this = this;
                            panel.style.setProperty("-ms-touch-action", "pinch-zoom"), this.touchReferencePoint = touchReferencePoint, 
                            this.touchPanel = panel, this.allowMouseDrag = void 0 === allowMouseDrag ? !0 : allowMouseDrag, 
                            "ontouchmove" in panel ? (panel.addEventListener("touchstart", function(e) {
                                return _this.onTouchStart(e);
                            }), panel.addEventListener("touchend", function(e) {
                                return _this.onTouchEnd(e);
                            })) : (panel.addEventListener("mousedown", function(e) {
                                return _this.onTouchMouseDown(e);
                            }), panel.addEventListener("mouseup", function(e) {
                                return _this.onTouchMouseUp(e);
                            }));
                        }, TouchEventInterpreter.prototype.getXYByClient = function(pageX, pageY, rect) {
                            var x = rect.left, y = rect.top;
                            void 0 !== window.scrollX && (x += window.scrollX, y += window.scrollY);
                            var point = new Point(0, 0);
                            return point.offset(pageX - x, pageY - y), point;
                        }, TouchEventInterpreter.prototype.onTouchStart = function(e) {
                            if (1 === e.touches.length) {
                                e.cancelBubble = !0;
                                var mouchEvent = e.touches[0];
                                this.touchStartTime = new Date().getTime(), this.touchStartPageY = mouchEvent.pageY, 
                                this.onTouchMouseDown(mouchEvent);
                            }
                        }, TouchEventInterpreter.prototype.onTouchMove = function(e) {
                            if (1 === e.touches.length) {
                                e.preventDefault && e.preventDefault();
                                var mouchEvent = e.touches[0];
                                this.touchLastPageY = mouchEvent.pageY, this.touchLastPageX = mouchEvent.pageX, 
                                this.sliding || this.onTouchMouseMove(mouchEvent);
                            }
                        }, TouchEventInterpreter.prototype.onTouchEnd = function(e) {
                            this.clearTouchEvents();
                            var swipeInfo = this.getSwipeInfo();
                            this.didUserSwipe(swipeInfo) ? this.startSlideAffect(swipeInfo) : this.sliding || this.upAllTouches();
                        }, TouchEventInterpreter.prototype.onTouchMouseDown = function(e) {
                            var _this = this;
                            this.scale = controls.HTMLElementUtils.getAccumulatedScale(this.touchPanel), document.getSelection().removeAllRanges(), 
                            this.rect = (this.touchReferencePoint ? this.touchReferencePoint : this.touchPanel).getBoundingClientRect(), 
                            "ontouchmove" in this.touchPanel ? (this.documentMouseMoveWrapper = function(e) {
                                return _this.onTouchMove(e);
                            }, document.addEventListener("touchmove", this.documentMouseMoveWrapper), this.documentMouseUpWrapper = function(e) {
                                return _this.onTouchEnd(e);
                            }, document.addEventListener("touchend", this.documentMouseUpWrapper)) : (this.documentMouseMoveWrapper = function(e) {
                                return _this.onTouchMouseMove(e);
                            }, document.addEventListener("mousemove", this.documentMouseMoveWrapper), this.documentMouseUpWrapper = function(e) {
                                return _this.onTouchMouseUp(e);
                            }, document.addEventListener("mouseup", this.documentMouseUpWrapper)), "setCapture" in this.touchPanel && this.touchPanel.setCapture();
                        }, TouchEventInterpreter.prototype.onTouchMouseMove = function(e) {
                            var event, point, rect = this.rect, validMouseDragEvent = null !== rect && e.which !== MouseButton.NoClick;
                            validMouseDragEvent && !this.sliding && (point = this.getXYByClient(e.pageX, e.pageY, rect), 
                            event = new TouchEvent(point.x / this.scale, point.y / this.scale, validMouseDragEvent), 
                            this.manager.touchEvent(event), e.preventDefault ? e.preventDefault() : "returnValue" in e && (e.returnValue = !1));
                        }, TouchEventInterpreter.prototype.onTouchMouseUp = function(e, bubble) {
                            this.upAllTouches(), this.clearTouchEvents();
                        }, TouchEventInterpreter.prototype.getSwipeInfo = function() {
                            var touchEndTime = new Date().getTime(), touchTime = touchEndTime - this.touchStartTime, touchDist = this.touchLastPageY - this.touchStartPageY, touchDirection = 0 > touchDist ? -1 : 1;
                            return {
                                direction: touchDirection,
                                distance: touchDist,
                                endTime: touchEndTime,
                                time: touchTime
                            };
                        }, TouchEventInterpreter.prototype.didUserSwipe = function(swipeInfo) {
                            return swipeInfo.time < MaxTimeForSwipe && swipeInfo.distance * swipeInfo.direction > MinDistanceForSwipe;
                        }, TouchEventInterpreter.prototype.startSlideAffect = function(swipeInfo) {
                            var _this = this;
                            if (!this.sliding) {
                                this.sliding = !0;
                                var point = this.getXYByClient(this.touchLastPageX, this.touchLastPageY, this.rect);
                                this.slide(point, 300, swipeInfo), requestAnimationFrame(function() {
                                    _this.didUserChangeDirection(swipeInfo) || _this.slide(point, 200, swipeInfo), _this.clearSlide();
                                });
                            }
                        }, TouchEventInterpreter.prototype.didUserChangeDirection = function(swipeInfo) {
                            if (this.touchStartTime <= swipeInfo.endTime) return !1;
                            var updatedDist = this.touchLastPageY - this.touchStartPageY, updatedDirection = 0 > updatedDist ? -1 : 1;
                            return updatedDirection !== swipeInfo.direction;
                        }, TouchEventInterpreter.prototype.slide = function(point, slideDist, swipeInfo) {
                            var updatedDist = this.touchStartTime > swipeInfo.endTime ? this.touchLastPageY - this.touchStartPageY : 0;
                            point.y += slideDist * swipeInfo.direction + updatedDist;
                            var event = new TouchEvent(point.x / this.scale, point.y / this.scale, !0);
                            this.manager.touchEvent(event);
                        }, TouchEventInterpreter.prototype.clearSlide = function() {
                            this.sliding = !1, this.upAllTouches();
                        }, TouchEventInterpreter.prototype.upAllTouches = function() {
                            null === this.documentMouseMoveWrapper && (this.rect = null, this.manager.upAllTouches());
                        }, TouchEventInterpreter.prototype.clearTouchEvents = function() {
                            "releaseCapture" in this.touchPanel && this.touchPanel.releaseCapture(), null !== this.documentMouseMoveWrapper && ("ontouchmove" in this.touchPanel ? (document.removeEventListener("touchmove", this.documentMouseMoveWrapper), 
                            document.removeEventListener("touchend", this.documentMouseUpWrapper)) : (document.removeEventListener("mousemove", this.documentMouseMoveWrapper), 
                            document.removeEventListener("mouseup", this.documentMouseUpWrapper)), this.documentMouseMoveWrapper = null, 
                            this.documentMouseUpWrapper = null);
                        }, TouchEventInterpreter;
                    }();
                    TouchUtils.TouchEventInterpreter = TouchEventInterpreter;
                }(TouchUtils = controls.TouchUtils || (controls.TouchUtils = {}));
            }(controls = visuals.controls || (visuals.controls = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var controls;
            !function(controls) {
                !function(TablixType) {
                    TablixType[TablixType.Matrix = 0] = "Matrix", TablixType[TablixType.Table = 1] = "Table";
                }(controls.TablixType || (controls.TablixType = {}));
                controls.TablixType;
            }(controls = visuals.controls || (visuals.controls = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var controls;
            !function(controls) {
                var PropAutoSizeWidth = controls.internal.TablixObjects.PropGeneralAutoSizeColumns, getMetadataObjects = controls.internal.TablixObjects.getMetadadataObjects, TablixColumnWidthManager = function() {
                    function TablixColumnWidthManager(dataView, isMatrix, hostPersistCallBack, matrixLeafNodes) {
                        this.columnWidthObjects = {}, this.isMatrix = isMatrix, this.updateDataView(dataView, matrixLeafNodes), 
                        this.hostPersistCallBack = hostPersistCallBack, this.visualObjectInstancesToPersist = {
                            merge: [],
                            remove: []
                        };
                    }
                    return TablixColumnWidthManager.prototype.updateDataView = function(dataView, matrixLeafNodes) {
                        this.previousDataView = this.currentDataView, this.previousDataView ? this.previousAutoColumnSizePropertyValue = PropAutoSizeWidth.getValue(getMetadataObjects(this.previousDataView)) : this.previousAutoColumnSizePropertyValue = void 0, 
                        this.currentDataView = dataView, this.currentDataView ? this.currentAutoColumnSizePropertyValue = PropAutoSizeWidth.getValue(getMetadataObjects(this.currentDataView)) : this.currentAutoColumnSizePropertyValue = void 0, 
                        this.matrixLeafNodes = matrixLeafNodes, this.updateColumnsMetadata(), this.updateTablixColumnWidths();
                    }, TablixColumnWidthManager.prototype.updateColumnsMetadata = function() {
                        this.columnWidthObjects = {}, this.isMatrix ? this.updateMatrixColumnsMetadata() : this.updateTableColumnsMetadata();
                    }, TablixColumnWidthManager.prototype.updateTableColumnsMetadata = function() {
                        if (this.currentDataView && this.currentDataView.table) for (var columnMetaData = this.currentDataView.table.columns, i = 0, len = columnMetaData.length; len > i; i++) {
                            var queryName = columnMetaData[i].queryName;
                            queryName && (this.columnWidthObjects[queryName] = {
                                queryName: queryName,
                                width: void 0,
                                isFixed: !1
                            });
                        }
                    }, TablixColumnWidthManager.prototype.updateMatrixColumnsMetadata = function() {
                        if (this.currentDataView && this.currentDataView.matrix && this.currentDataView.matrix.rows) for (var i = 0, len = this.currentDataView.matrix.rows.levels.length; len > i; i++) {
                            var rowGroup = this.currentDataView.matrix.rows.levels[i];
                            if (1 === rowGroup.sources.length) {
                                var queryName = rowGroup.sources[0].queryName;
                                queryName && (this.columnWidthObjects[queryName] = {
                                    queryName: queryName,
                                    width: void 0,
                                    isFixed: !1
                                });
                            }
                        }
                        if (this.matrixLeafNodes) for (var i = 0, len = this.matrixLeafNodes.length; len > i; i++) {
                            var queryName = this.matrixLeafNodes[i].queryName;
                            queryName && (this.columnWidthObjects[queryName] = {
                                queryName: queryName,
                                width: void 0,
                                isFixed: !1
                            });
                        }
                    }, TablixColumnWidthManager.prototype.updateTablixColumnWidths = function() {
                        var columnMetaData = this.currentDataView && this.currentDataView.metadata && this.currentDataView.metadata.columns;
                        if (columnMetaData) {
                            if (this.shouldClearAllColumnWidths()) return void this.autoSizeAllColumns();
                            this.deserializeColumnsWidth(columnMetaData);
                        }
                    }, TablixColumnWidthManager.prototype.autoSizeAllColumns = function() {
                        for (var queryName in this.columnWidthObjects) this.visualObjectInstancesToPersist.remove.push(this.generateColumnWidthObjectToPersist(queryName, void 0));
                        this.callHostToPersist();
                    }, TablixColumnWidthManager.prototype.deserializeColumnsWidth = function(columnsMetadata) {
                        for (var colObj in this.columnWidthObjects) this.columnWidthObjects[colObj].isFixed = !this.currentAutoColumnSizePropertyValue, 
                        this.columnWidthObjects[colObj].width = void 0;
                        for (var i = 0, len = columnsMetadata.length; len > i; i++) {
                            var column = columnsMetadata[i], queryName = column.queryName, width = powerbi.DataViewObjects.getValue(column.objects, TablixColumnWidthManager.columnWidthProp);
                            this.columnWidthObjects.hasOwnProperty(queryName) && null != width && (this.columnWidthObjects[queryName].width = width, 
                            this.columnWidthObjects[queryName].isFixed = !0);
                        }
                    }, TablixColumnWidthManager.prototype.shouldPersistAllColumnWidths = function() {
                        return this.previousDataView ? !this.currentAutoColumnSizePropertyValue && this.previousAutoColumnSizePropertyValue : !1;
                    }, TablixColumnWidthManager.prototype.shouldClearAllColumnWidths = function() {
                        return null != this.previousDataView && this.previousAutoColumnSizePropertyValue === !1 && null != this.currentDataView && this.currentAutoColumnSizePropertyValue === !0;
                    }, TablixColumnWidthManager.getColumnQueryName = function(column) {
                        var headerCell = column.getTablixCell();
                        switch (headerCell.type) {
                          case 0:
                            if (null == headerCell.item || null == headerCell.item.metadata) return;
                            return headerCell.item.metadata.queryName;

                          case 2:
                            return headerCell.item.queryName;

                          default:
                            return;
                        }
                    }, TablixColumnWidthManager.prototype.getColumnWidthObjects = function() {
                        return this.columnWidthObjects;
                    }, TablixColumnWidthManager.prototype.getFixedColumnWidthObjects = function() {
                        var fixedOnly = {};
                        for (var queryName in this.columnWidthObjects) {
                            var obj = this.columnWidthObjects[queryName];
                            obj.isFixed && (fixedOnly[queryName] = obj);
                        }
                        return fixedOnly;
                    }, TablixColumnWidthManager.prototype.getPersistedColumnWidth = function(queryName) {
                        var obj = this.columnWidthObjects[queryName];
                        return obj && obj.width;
                    }, TablixColumnWidthManager.prototype.callHostToPersist = function() {
                        this.hostPersistCallBack && this.hostPersistCallBack(this.visualObjectInstancesToPersist), 
                        this.visualObjectInstancesToPersist = {
                            merge: [],
                            remove: []
                        };
                    }, TablixColumnWidthManager.prototype.onColumnWidthChanged = function(queryName, width) {
                        if (null != queryName && null != this.columnWidthObjects[queryName]) {
                            var resizedColumn = this.columnWidthObjects[queryName];
                            -1 === width ? (resizedColumn.width = void 0, resizedColumn.isFixed = !this.currentAutoColumnSizePropertyValue, 
                            this.visualObjectInstancesToPersist.remove.push(this.generateColumnWidthObjectToPersist(resizedColumn.queryName, void 0)), 
                            this.callHostToPersist()) : (resizedColumn.width = width, resizedColumn.isFixed = !0, 
                            this.visualObjectInstancesToPersist.merge.push(this.generateColumnWidthObjectToPersist(queryName, width)), 
                            this.callHostToPersist());
                        }
                    }, TablixColumnWidthManager.prototype.onColumnsRendered = function(renderedColumns) {
                        for (var maxWidths = {}, i = 0, len = renderedColumns.length; len > i; i++) {
                            var queryName = renderedColumns[i].queryName, newWidth = renderedColumns[i].width;
                            null == maxWidths[queryName] ? maxWidths[queryName] = {
                                queryName: queryName,
                                width: newWidth,
                                isFixed: !1
                            } : newWidth > maxWidths[queryName].width && (maxWidths[queryName].width = newWidth);
                        }
                        var widthChanged = !1;
                        for (var queryName in this.columnWidthObjects) if (maxWidths[queryName]) {
                            var colWidthObj = this.columnWidthObjects[queryName];
                            colWidthObj.isFixed && null == colWidthObj.width && (colWidthObj.width = maxWidths[queryName].width, 
                            this.visualObjectInstancesToPersist.merge.push(this.generateColumnWidthObjectToPersist(queryName, colWidthObj.width)), 
                            widthChanged = !0);
                        }
                        return widthChanged && this.callHostToPersist(), widthChanged;
                    }, TablixColumnWidthManager.prototype.generateColumnWidthObjectToPersist = function(queryName, width) {
                        return {
                            selector: {
                                metadata: queryName
                            },
                            objectName: "general",
                            properties: {
                                columnWidth: width
                            }
                        };
                    }, TablixColumnWidthManager.columnWidthProp = {
                        objectName: "general",
                        propertyName: "columnWidth"
                    }, TablixColumnWidthManager;
                }();
                controls.TablixColumnWidthManager = TablixColumnWidthManager;
            }(controls = visuals.controls || (visuals.controls = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var AnimatedText = function() {
                function AnimatedText(name) {
                    this.mainText = jsCommon.CssConstants.createClassAndSelector("mainText"), this.name = name, 
                    this.visualConfiguration = {
                        maxFontSize: 60
                    };
                }
                return AnimatedText.prototype.getMetaDataColumn = function(dataView) {
                    if (dataView && dataView.metadata && dataView.metadata.columns) for (var i = 0, ilen = dataView.metadata.columns.length; ilen > i; i++) {
                        var column = dataView.metadata.columns[i];
                        if (column.isMeasure) {
                            this.metaDataColumn = column;
                            break;
                        }
                    }
                }, AnimatedText.prototype.getAdjustedFontHeight = function(availableWidth, textToMeasure, seedFontHeight) {
                    var textProperties = {
                        fontFamily: null,
                        fontSize: null,
                        text: textToMeasure
                    }, fontHeight = this.getAdjustedFontHeightCore(textProperties, availableWidth, seedFontHeight, 0);
                    return fontHeight;
                }, AnimatedText.prototype.getAdjustedFontHeightCore = function(textProperties, availableWidth, seedFontHeight, iteration) {
                    if (iteration > 10) return seedFontHeight;
                    textProperties.fontSize = jsCommon.PixelConverter.toString(seedFontHeight);
                    var candidateLength = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                    return availableWidth > candidateLength ? seedFontHeight : this.getAdjustedFontHeightCore(textProperties, availableWidth, .9 * seedFontHeight, iteration + 1);
                }, AnimatedText.prototype.clear = function() {
                    this.svg.select(this.mainText.selector).text("");
                }, AnimatedText.prototype.doValueTransition = function(startValue, endValue, displayUnitSystemType, animationOptions, duration, forceUpdate, formatter) {
                    if (forceUpdate || startValue !== endValue || null == endValue) {
                        startValue || (startValue = 0);
                        var svg = this.svg, viewport = this.currentViewport, height = viewport.height, width = viewport.width, endValueArr = [ endValue ], seedFontHeight = this.getSeedFontHeight(width, height), translateX = this.getTranslateX(width), translateY = this.getTranslateY(seedFontHeight), metaDataColumn = this.metaDataColumn;
                        formatter || (formatter = visuals.valueFormatter.create({
                            format: this.getFormatString(metaDataColumn),
                            value: endValue,
                            displayUnitSystemType: displayUnitSystemType,
                            formatSingleValues: !0,
                            allowFormatBeautification: !0,
                            columnType: metaDataColumn ? metaDataColumn.type : void 0
                        }));
                        var startText = formatter.format(startValue), endText = formatter.format(endValue);
                        svg.attr("class", this.name);
                        var textElement = svg.selectAll("text").data(endValueArr);
                        textElement.enter().append("text").attr("class", this.mainText["class"]);
                        var fontHeight = this.getAdjustedFontHeight(width, endText, seedFontHeight);
                        translateY = this.getTranslateY(fontHeight + (height - fontHeight) / 2);
                        var textElementUpdate = textElement.text(startText).attr({
                            "text-anchor": this.getTextAnchor(),
                            "font-size": fontHeight,
                            transform: visuals.SVGUtil.translate(translateX, translateY)
                        }).style({
                            fill: this.style.titleText.color.value
                        }).call(visuals.tooltipUtils.tooltipUpdate, [ startText ]);
                        if (null == endValue) textElementUpdate.text(endText).call(visuals.tooltipUtils.tooltipUpdate, [ endText ]); else if (metaDataColumn && visuals.AxisHelper.isDateTime(metaDataColumn.type)) textElementUpdate.text(endText).call(visuals.tooltipUtils.tooltipUpdate, [ endText ]); else {
                            var interpolatedValue_1 = startValue;
                            textElementUpdate.transition().duration(duration).tween("text", function(d) {
                                var i = d3.interpolate(interpolatedValue_1, d);
                                return function(t) {
                                    var num = i(t);
                                    this.textContent = formatter.format(num);
                                };
                            });
                        }
                        visuals.SVGUtil.flushAllD3TransitionsIfNeeded(animationOptions);
                    }
                }, AnimatedText.prototype.setTextColor = function(color) {
                    this.style.titleText.color.value = color;
                }, AnimatedText.prototype.getSeedFontHeight = function(boundingWidth, boundingHeight) {
                    var estimatedSize = Math.floor(.75 * Math.min(boundingWidth, boundingHeight)), maxFontSize = this.visualConfiguration.maxFontSize;
                    return maxFontSize ? Math.min(maxFontSize, estimatedSize) : estimatedSize;
                }, AnimatedText.prototype.getTranslateX = function(width) {
                    if (this.visualConfiguration) switch (this.visualConfiguration.align) {
                      case "left":
                        return 0;

                      case "right":
                        return width;
                    }
                    return width / 2;
                }, AnimatedText.prototype.getTranslateY = function(height) {
                    return height;
                }, AnimatedText.prototype.getTextAnchor = function() {
                    if (this.visualConfiguration) switch (this.visualConfiguration.align) {
                      case "left":
                        return "start";

                      case "right":
                        return "end";
                    }
                    return "middle";
                }, AnimatedText.prototype.getFormatString = function(column) {
                    return visuals.valueFormatter.getFormatString(column, AnimatedText.formatStringProp);
                }, AnimatedText.formatStringProp = {
                    objectName: "general",
                    propertyName: "formatString"
                }, AnimatedText;
            }();
            visuals.AnimatedText = AnimatedText;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi), __extends = (window.powerbitests, 
    window.InJs, window.debug, window.jasmine, window.Microsoft, this && this.__extends || function(d, b) {
        function __() {
            this.constructor = d;
        }
        for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
    });
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var AnimatedNumber = function(_super) {
                function AnimatedNumber(svg, animator) {
                    _super.call(this, "animatedNumber"), svg && (this.svg = svg), animator && (this.animator = animator);
                }
                return __extends(AnimatedNumber, _super), AnimatedNumber.prototype.init = function(options) {
                    this.options = options;
                    var element = options.element;
                    this.svg || (this.svg = d3.select(element.get(0)).append("svg")), this.currentViewport = options.viewport, 
                    this.hostServices = options.host, this.style = options.style, this.updateViewportDependantProperties();
                }, AnimatedNumber.prototype.updateViewportDependantProperties = function() {
                    var viewport = this.currentViewport;
                    this.svg.attr("width", viewport.width).attr("height", viewport.height);
                }, AnimatedNumber.prototype.update = function(options) {
                    this.currentViewport = options.viewport;
                    var dataViews = this.dataViews = options.dataViews;
                    if (dataViews && dataViews[0]) {
                        var dataView = dataViews[0];
                        this.updateViewportDependantProperties(), this.getMetaDataColumn(dataView);
                        var newValue = dataView && dataView.single ? dataView.single.value : 0;
                        this.updateInternal(newValue, options.suppressAnimations, !0, this.formatter);
                    }
                }, AnimatedNumber.prototype.setFormatter = function(formatter) {
                    this.formatter = formatter;
                }, AnimatedNumber.prototype.onDataChanged = function(options) {
                    this.update({
                        dataViews: options.dataViews,
                        suppressAnimations: options.suppressAnimations,
                        viewport: this.currentViewport
                    });
                }, AnimatedNumber.prototype.onResizing = function(viewport) {
                    this.update({
                        dataViews: this.dataViews,
                        suppressAnimations: !0,
                        viewport: viewport
                    });
                }, AnimatedNumber.prototype.canResizeTo = function(viewport) {
                    return !0;
                }, AnimatedNumber.prototype.updateInternal = function(target, suppressAnimations, forceUpdate, formatter) {
                    void 0 === forceUpdate && (forceUpdate = !1);
                    var start = this.value, duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                    this.doValueTransition(start, target, null, this.options.animation, duration, forceUpdate, formatter), 
                    this.value = target;
                }, AnimatedNumber;
            }(visuals.AnimatedText);
            visuals.AnimatedNumber = AnimatedNumber;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var BasicShapeVisual = function() {
                function BasicShapeVisual(options) {}
                return Object.defineProperty(BasicShapeVisual.prototype, "shapeType", {
                    get: function() {
                        return this.data.shapeType;
                    },
                    set: function(shapeType) {
                        this.data.shapeType = shapeType;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(BasicShapeVisual.prototype, "lineColor", {
                    get: function() {
                        return this.data ? this.data.lineColor : BasicShapeVisual.DefaultStrokeColor;
                    },
                    set: function(color) {
                        this.data.lineColor = color;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(BasicShapeVisual.prototype, "lineTransparency", {
                    get: function() {
                        return this.data ? this.data.lineTransparency : BasicShapeVisual.DefaultLineTransValue;
                    },
                    set: function(trans) {
                        this.data.lineTransparency = trans;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(BasicShapeVisual.prototype, "lineWeight", {
                    get: function() {
                        return this.data ? this.data.lineWeight : BasicShapeVisual.DefaultWeightValue;
                    },
                    set: function(weight) {
                        this.data.lineWeight = weight;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(BasicShapeVisual.prototype, "roundEdge", {
                    get: function() {
                        return this.data ? this.data.roundEdge : BasicShapeVisual.DefaultRoundEdgeValue;
                    },
                    set: function(roundEdge) {
                        this.data.roundEdge = roundEdge;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(BasicShapeVisual.prototype, "showFill", {
                    get: function() {
                        return this.data ? this.data.showFill : BasicShapeVisual.DefaultFillShowValue;
                    },
                    set: function(show) {
                        this.data.showFill = show;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(BasicShapeVisual.prototype, "fillColor", {
                    get: function() {
                        return this.data ? this.data.fillColor : BasicShapeVisual.DefaultFillColor;
                    },
                    set: function(color) {
                        this.data.fillColor = color;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(BasicShapeVisual.prototype, "shapeTransparency", {
                    get: function() {
                        return this.data ? this.data.shapeTransparency : BasicShapeVisual.DefaultFillTransValue;
                    },
                    set: function(trans) {
                        this.data.shapeTransparency = trans;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(BasicShapeVisual.prototype, "angle", {
                    get: function() {
                        return this.data ? this.data.angle : BasicShapeVisual.DefaultAngle;
                    },
                    set: function(angle) {
                        this.data.angle = this.scaleTo360Deg(angle);
                    },
                    enumerable: !0,
                    configurable: !0
                }), BasicShapeVisual.prototype.init = function(options) {
                    this.element = options.element, this.selection = d3.select(this.element.context), 
                    this.currentViewport = options.viewport;
                }, BasicShapeVisual.prototype.update = function(options) {
                    this.currentViewport = options.viewport;
                    var dataViews = options.dataViews;
                    if (!_.isEmpty(dataViews)) {
                        var dataView = options.dataViews[0];
                        if (dataView.metadata && dataView.metadata.objects) {
                            var dataViewObject = options.dataViews[0].metadata.objects;
                            this.data = this.getDataFromDataView(dataViewObject), this.render();
                        }
                    }
                }, BasicShapeVisual.prototype.getDataFromDataView = function(dataViewObject) {
                    return dataViewObject ? {
                        shapeType: powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.general.shapeType, BasicShapeVisual.DefaultShape),
                        lineColor: this.getValueFromColor(powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.line.lineColor, BasicShapeVisual.DefaultStrokeColor)),
                        lineTransparency: powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.line.transparency, BasicShapeVisual.DefaultLineTransValue),
                        lineWeight: powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.line.weight, BasicShapeVisual.DefaultWeightValue),
                        roundEdge: powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.line.roundEdge, BasicShapeVisual.DefaultRoundEdgeValue),
                        shapeTransparency: powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.fill.transparency, BasicShapeVisual.DefaultFillTransValue),
                        fillColor: this.getValueFromColor(powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.fill.fillColor, BasicShapeVisual.DefaultFillColor)),
                        showFill: powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.fill.show, BasicShapeVisual.DefaultFillShowValue),
                        angle: this.scaleTo360Deg(powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.rotation.angle, BasicShapeVisual.DefaultAngle))
                    } : null;
                }, BasicShapeVisual.prototype.scaleTo360Deg = function(angle) {
                    return 0 !== angle && Math.abs(angle) % 360 === 0 ? angle : (angle %= 360, angle = (angle + 360) % 360);
                }, BasicShapeVisual.prototype.getValueFromColor = function(color) {
                    return color.solid ? color.solid.color : color;
                }, BasicShapeVisual.prototype.enumerateObjectInstances = function(options) {
                    var objectInstances = [];
                    if (!this.data) return objectInstances;
                    switch (options.objectName) {
                      case "line":
                        var instance = {
                            selector: null,
                            properties: {
                                lineColor: this.lineColor,
                                transparency: this.lineTransparency,
                                weight: this.lineWeight
                            },
                            objectName: options.objectName
                        };
                        return this.shapeType === visuals.basicShapeType.rectangle && (instance.properties.roundEdge = this.roundEdge), 
                        objectInstances.push(instance), objectInstances;

                      case "fill":
                        return this.shapeType !== visuals.basicShapeType.line && objectInstances.push({
                            selector: null,
                            properties: {
                                show: this.showFill,
                                fillColor: this.fillColor,
                                transparency: this.shapeTransparency
                            },
                            objectName: options.objectName
                        }), objectInstances;

                      case "rotation":
                        return objectInstances.push({
                            selector: null,
                            properties: {
                                angle: this.angle
                            },
                            objectName: options.objectName
                        }), objectInstances;
                    }
                    return null;
                }, BasicShapeVisual.prototype.render = function() {
                    switch (this.selection.html(""), this.shapeType) {
                      case visuals.basicShapeType.rectangle:
                        visuals.ShapeFactory.createRectangle(this.data, this.currentViewport.height, this.currentViewport.width, this.selection, this.angle);
                        break;

                      case visuals.basicShapeType.oval:
                        visuals.ShapeFactory.createOval(this.data, this.currentViewport.height, this.currentViewport.width, this.selection, this.angle);
                        break;

                      case visuals.basicShapeType.line:
                        visuals.ShapeFactory.createLine(this.data, this.currentViewport.height, this.currentViewport.width, this.selection, this.angle);
                        break;

                      case visuals.basicShapeType.arrow:
                        visuals.ShapeFactory.createUpArrow(this.data, this.currentViewport.height, this.currentViewport.width, this.selection, this.angle);
                        break;

                      case visuals.basicShapeType.triangle:
                        visuals.ShapeFactory.createTriangle(this.data, this.currentViewport.height, this.currentViewport.width, this.selection, this.angle);
                    }
                }, BasicShapeVisual.DefaultShape = visuals.basicShapeType.rectangle, BasicShapeVisual.DefaultStrokeColor = "#00B8AA", 
                BasicShapeVisual.DefaultFillColor = "#E6E6E6", BasicShapeVisual.DefaultFillShowValue = !0, 
                BasicShapeVisual.DefaultFillTransValue = 0, BasicShapeVisual.DefaultWeightValue = 3, 
                BasicShapeVisual.DefaultLineTransValue = 0, BasicShapeVisual.DefaultRoundEdgeValue = 0, 
                BasicShapeVisual.DefaultAngle = 0, BasicShapeVisual;
            }();
            visuals.BasicShapeVisual = BasicShapeVisual;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            function shouldExpandCategoryWindow(mappings) {
                if (_.isEmpty(mappings)) return !1;
                var hasSeries = _.any(mappings, function(mapping) {
                    var categorical = mapping.categorical;
                    if (!categorical) return !1;
                    var categories = categorical.categories;
                    if (!categories) return !1;
                    var values = categorical.values;
                    return !(!(values && values.group && values.group.by) || _.isEmpty(values.group.by.items));
                });
                return !hasSeries;
            }
            function getLayerDataViews(dataViews) {
                return _.isEmpty(dataViews) ? [] : _.filter(dataViews, function(dataView) {
                    return !visuals.TrendLineHelper.isDataViewForRegression(dataView) && !visuals.ForecastHelper.isDataViewForForecast(dataView);
                });
            }
            function hasMultipleYAxes(layers) {
                return layers.length > 1;
            }
            function shouldShowYAxisLabel(layerNumber, valueAxisProperties, yAxisWillMerge) {
                return 0 === layerNumber && !!valueAxisProperties && !!valueAxisProperties.showAxisTitle || 1 === layerNumber && !yAxisWillMerge && !!valueAxisProperties && !!valueAxisProperties.secShowAxisTitle;
            }
            function tryMergeYDomains(layers, visualOptions) {
                var noMerge = {
                    domain: void 0,
                    merged: !1,
                    tickCount: void 0
                };
                if (layers.length < 2) return noMerge;
                var min, max, minOfMax, maxOfMin, y1props = layers[0].calculateAxesProperties(visualOptions)[1], y2props = layers[1].calculateAxesProperties(visualOptions)[1], firstYDomain = y1props.scale.domain(), secondYDomain = y2props.scale.domain();
                if (y1props.values && y1props.values.length > 0 && y2props.values && y2props.values.length > 0 && (noMerge.tickCount = Math.max(y1props.values.length, y2props.values.length)), 
                min = Math.min(firstYDomain[0], secondYDomain[0]), max = Math.max(firstYDomain[1], secondYDomain[1]), 
                visualOptions.forceMerge) return {
                    domain: [ min, max ],
                    merged: !0,
                    tickCount: noMerge.tickCount
                };
                if (firstYDomain[0] > secondYDomain[1] || firstYDomain[1] < secondYDomain[0]) return noMerge;
                maxOfMin = Math.max(firstYDomain[0], secondYDomain[0]), minOfMax = Math.min(firstYDomain[1], secondYDomain[1]);
                var range = max - min;
                if (0 === range) return noMerge;
                var intersection = Math.abs((minOfMax - maxOfMin) / range);
                return COMBOCHART_DOMAIN_OVERLAP_TRESHOLD_PERCENTAGE > intersection ? noMerge : {
                    domain: [ min, max ],
                    merged: !0,
                    tickCount: noMerge.tickCount
                };
            }
            var EnumExtensions = jsCommon.EnumExtensions, createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, DEFAULT_AXIS_SCALE_TYPE = visuals.axisScale.linear, COMBOCHART_DOMAIN_OVERLAP_TRESHOLD_PERCENTAGE = .1, INTERACTIVITY_RIGHT_MARGIN = 6;
            visuals.DEFAULT_AXIS_COLOR = "#777";
            var CartesianChart = function() {
                function CartesianChart(options) {
                    this.xRefLine = createClassAndSelector("x-ref-line"), this.y1RefLine = createClassAndSelector("y1-ref-line");
                    var isScrollable = !1;
                    this.trimOrdinalDataOnOverflow = !0, options && (this.tooltipsEnabled = options.tooltipsEnabled, 
                    this.tooltipBucketEnabled = options.tooltipBucketEnabled, this.forecastEnabled = options.forecastEnabled, 
                    this.type = options.chartType, this.isLabelInteractivityEnabled = options.isLabelInteractivityEnabled, 
                    this.advancedLineLabelsEnabled = options.advancedLineLabelsEnabled, void 0 !== options.trimOrdinalDataOnOverflow && (this.trimOrdinalDataOnOverflow = options.trimOrdinalDataOnOverflow), 
                    options.isScrollable && (isScrollable = options.isScrollable), this.animator = options.animator, 
                    options.cartesianSmallViewPortProperties && (this.cartesianSmallViewPortProperties = options.cartesianSmallViewPortProperties), 
                    options.behavior && (this.behavior = options.behavior)), this.axes = new CartesianAxes(isScrollable, ScrollableAxes.ScrollbarWidth, this.trimOrdinalDataOnOverflow), 
                    this.svgAxes = new SvgCartesianAxes(this.axes), this.svgBrush = new SvgBrush(ScrollableAxes.ScrollbarWidth), 
                    this.scrollableAxes = new ScrollableAxes(this.axes, this.svgBrush);
                }
                return CartesianChart.getAxisVisibility = function(type) {
                    switch (type) {
                      case 6:
                      case 5:
                      case 7:
                        return 1;

                      case 9:
                        return 3;

                      default:
                        return 2;
                    }
                }, CartesianChart.prototype.init = function(options) {
                    this.visualInitOptions = options, this.layers = [];
                    var element = this.element = options.element;
                    this.currentViewport = options.viewport, this.hostServices = options.host;
                    var chartAreaSvg = this.chartAreaSvg = d3.select(element.get(0)).append("svg");
                    chartAreaSvg.classed(CartesianChart.ClassName, !0), chartAreaSvg.style("position", "absolute"), 
                    this.behavior && (this.clearCatcher = visuals.appendClearCatcher(chartAreaSvg), 
                    this.interactivityService = visuals.createInteractivityService(this.hostServices)), 
                    null != options.style.maxMarginFactor && this.axes.setMaxMarginFactor(options.style.maxMarginFactor);
                    var axisLinesVisibility = CartesianChart.getAxisVisibility(this.type);
                    this.axes.setAxisLinesVisibility(axisLinesVisibility), this.svgAxes.init(chartAreaSvg), 
                    this.svgBrush.init(chartAreaSvg), this.sharedColorPalette = new SharedColorPalette(options.style.colorPalette.dataColors), 
                    this.legend = visuals.createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, 12 !== this.type ? this.interactivityService : void 0, this.axes.isScrollable), 
                    this.isMobileChart = options.interactivity && options.interactivity.isInteractiveLegend;
                }, CartesianChart.prototype.isPlayAxis = function() {
                    if (!this.dataViews || !this.dataViews[0]) return !1;
                    var dataView = this.dataViews[0], categoryRoleIsPlay = dataView.categorical && dataView.categorical.categories && dataView.categorical.categories[0] && dataView.categorical.categories[0].source && dataView.categorical.categories[0].source.roles && dataView.categorical.categories[0].source.roles.Play;
                    return 9 === this.type && (this.animator || this.isMobileChart) && null != dataView.matrix && (!dataView.categorical || categoryRoleIsPlay);
                }, CartesianChart.getIsScalar = function(objects, propertyId, type, scalarKeys) {
                    if (!CartesianChart.supportsScalar(type, scalarKeys)) return !1;
                    var axisTypeValue = powerbi.DataViewObjects.getValue(objects, propertyId);
                    return objects && null != axisTypeValue ? axisTypeValue === visuals.axisType.scalar : !0;
                }, CartesianChart.supportsScalar = function(type, scalarKeys) {
                    return scalarKeys && !_.isEmpty(scalarKeys.values) ? !0 : !visuals.AxisHelper.isOrdinal(type);
                }, CartesianChart.getAdditionalTelemetry = function(dataView) {
                    var telemetry = {}, categoryColumn = dataView && dataView.categorical && _.first(dataView.categorical.categories);
                    return categoryColumn && (telemetry.axisType = visuals.CartesianChart.getIsScalar(dataView.metadata.objects, visuals.columnChartProps.categoryAxis.axisType, categoryColumn.source.type) ? "scalar" : "categorical"), 
                    telemetry;
                }, CartesianChart.detectScalarMapping = function(dataViewMapping) {
                    if (!dataViewMapping || !dataViewMapping.categorical || !dataViewMapping.categorical.categories) return !1;
                    var dataViewCategories = dataViewMapping.categorical.categories, categoryItems = dataViewCategories["for"]["in"].items;
                    if (_.isEmpty(categoryItems)) return !1;
                    var categoryType = categoryItems[0].type;
                    if (!dataViewMapping.metadata) return !1;
                    var objects = dataViewMapping.metadata.objects;
                    return CartesianChart.getIsScalar(objects, visuals.columnChartProps.categoryAxis.axisType, categoryType);
                }, CartesianChart.prototype.populateObjectProperties = function(dataViews) {
                    if (dataViews && dataViews.length > 0) {
                        var dataViewMetadata = dataViews[0].metadata;
                        dataViewMetadata ? (this.legendObjectProperties = powerbi.DataViewObjects.getObject(dataViewMetadata.objects, "legend", {}), 
                        this.xAxisReferenceLines = powerbi.DataViewObjects.getUserDefinedObjects(dataViewMetadata.objects, "xAxisReferenceLine"), 
                        this.y1AxisReferenceLines = powerbi.DataViewObjects.getUserDefinedObjects(dataViewMetadata.objects, "y1AxisReferenceLine"), 
                        this.referenceLines = powerbi.DataViewObjects.getUserDefinedObjects(dataViewMetadata.objects, "referenceLine")) : this.legendObjectProperties = {}, 
                        this.categoryAxisProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataViewMetadata), 
                        this.valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataViewMetadata);
                    }
                }, CartesianChart.prototype.updateInternal = function(options, operationKind) {
                    var dataViews = this.dataViews = options.dataViews;
                    if (this.currentViewport = options.viewport, dataViews) {
                        if (0 === this.layers.length) {
                            var objects = this.extractMetadataObjects(dataViews);
                            this.layers = this.createAndInitLayers(objects);
                        }
                        var layers = this.layers;
                        if (null != operationKind) {
                            if (!_.isEmpty(dataViews)) {
                                this.populateObjectProperties(dataViews), this.axes.update(dataViews), this.svgAxes.update(this.categoryAxisProperties, this.valueAxisProperties);
                                var dataView = dataViews[0];
                                if (dataView.metadata) {
                                    this.background = {
                                        image: powerbi.DataViewObjects.getValue(dataView.metadata.objects, visuals.scatterChartProps.plotArea.image),
                                        transparency: powerbi.DataViewObjects.getValue(dataView.metadata.objects, visuals.scatterChartProps.plotArea.transparency, visuals.visualBackgroundHelper.getDefaultTransparency())
                                    };
                                    var isScalar = !0, categoryColumn = dataView && dataView.categorical && _.first(dataView.categorical.categories);
                                    categoryColumn && categoryColumn.source && (isScalar = visuals.CartesianChart.getIsScalar(dataView.metadata.objects, visuals.columnChartProps.categoryAxis.axisType, categoryColumn.source.type)), 
                                    isScalar && this.loadMoreDataHandler ? this.loadMoreDataHandler = null : isScalar || this.loadMoreDataHandler || (this.loadMoreDataHandler = new CartesianLoadMoreDataHandler(null, this.hostServices.loadMoreData, CartesianChart.LoadMoreThreshold));
                                }
                            }
                            this.sharedColorPalette.clearPreferredScale();
                            var layerDataViews = getLayerDataViews(dataViews), trendLineDataViews = _.filter(dataViews, visuals.TrendLineHelper.isDataViewForRegression);
                            this.trendLines = [];
                            var forecastDataViews = _.filter(dataViews, visuals.ForecastHelper.isDataViewForForecast);
                            this.forecastLine = null;
                            for (var i = 0, layerCount = layers.length; layerCount > i; i++) {
                                var layerDataView = layerDataViews[i];
                                if (layers[i].setData(layerDataView ? [ layerDataView ] : []), this.supportsTrendLines(i)) {
                                    var trendLineDataView = trendLineDataViews[i];
                                    if (trendLineDataView) {
                                        var y2 = i > 0, trendLines = visuals.TrendLineHelper.readDataView(trendLineDataView, layerDataView, y2, this.sharedColorPalette);
                                        (_a = this.trendLines).push.apply(_a, trendLines);
                                    }
                                }
                                if (this.supportsForecast(i)) {
                                    var forecastDataView = forecastDataViews[i];
                                    if (forecastDataView) {
                                        var forecastLine = visuals.ForecastHelper.readDataView(forecastDataView, layerDataView, this.sharedColorPalette);
                                        this.forecastLine = forecastLine;
                                    }
                                }
                                layerCount > 1 && this.sharedColorPalette.rotateScale();
                            }
                        }
                        if (this.loadMoreDataHandler && null != operationKind && this.loadMoreDataHandler.onLoadMoreDataCompleted(), 
                        this.render(!this.hasSetData || options.suppressAnimations, options.resizeMode, operationKind), 
                        this.hasSetData = this.hasSetData || dataViews && dataViews.length > 0, dataViews && dataViews.length > 0) {
                            var warnings = visuals.getInvalidValueWarnings(dataViews, !1, !1, !1);
                            this.axes.addWarnings(warnings), warnings && warnings.length > 0 && this.hostServices.setWarnings(warnings);
                        }
                        var _a;
                    }
                }, CartesianChart.prototype.onDataChanged = function(options) {
                    this.updateInternal({
                        dataViews: options.dataViews,
                        suppressAnimations: options.suppressAnimations,
                        viewport: this.currentViewport
                    }, null != options.operationKind ? options.operationKind : powerbi.VisualDataChangeOperationKind.Create);
                }, CartesianChart.prototype.onResizing = function(viewport, resizeMode) {
                    this.updateInternal({
                        dataViews: this.dataViews,
                        suppressAnimations: !0,
                        viewport: viewport,
                        resizeMode: resizeMode
                    });
                }, CartesianChart.prototype.scrollTo = function(position) {
                    this.scrollableAxes.scrollTo(position);
                }, CartesianChart.prototype.enumerateObjectInstances = function(options) {
                    var enumeration = new visuals.ObjectEnumerationBuilder(), layersLength = this.layers ? this.layers.length : 0;
                    if ("legend" === options.objectName) {
                        if (!this.shouldShowLegendCard()) return;
                        var show = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.show, this.legend.isVisible()), showTitle = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.showTitle, !0), titleText = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.titleText, this.layerLegendData ? this.layerLegendData.title : ""), labelColor = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.labelColor, visuals.LegendData.DefaultLegendLabelFillColor), fontSize = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.fontSize, this.layerLegendData && this.layerLegendData.fontSize ? this.layerLegendData.fontSize : visuals.SVGLegend.DefaultFontSizeInPt), position = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.position, visuals.legendPosition.top);
                        enumeration.pushInstance({
                            selector: null,
                            properties: {
                                show: show,
                                position: position,
                                showTitle: showTitle,
                                titleText: titleText,
                                labelColor: labelColor,
                                fontSize: fontSize
                            },
                            objectName: options.objectName
                        });
                    } else if ("categoryAxis" === options.objectName && this.axes.hasCategoryAxis()) this.getCategoryAxisValues(enumeration); else if ("valueAxis" === options.objectName) this.getValueAxisValues(enumeration); else if ("y1AxisReferenceLine" === options.objectName) {
                        var refLinedefaultColor = this.sharedColorPalette.getColorByIndex(0).value;
                        visuals.ReferenceLineHelper.enumerateObjectInstances(enumeration, this.y1AxisReferenceLines, refLinedefaultColor, options.objectName);
                    } else if ("xAxisReferenceLine" === options.objectName) {
                        var refLinedefaultColor = this.sharedColorPalette.getColorByIndex(0).value;
                        visuals.ReferenceLineHelper.enumerateObjectInstances(enumeration, this.xAxisReferenceLines, refLinedefaultColor, options.objectName);
                    } else if ("referenceLine" === options.objectName) {
                        if (this.supportsDataBoundReferenceLines()) {
                            var refLinedefaultColor = this.sharedColorPalette.getColorByIndex(0).value;
                            visuals.ReferenceLineHelper.enumerateObjectInstances(enumeration, this.referenceLines, refLinedefaultColor, options.objectName);
                        }
                    } else "trend" === options.objectName ? this.supportsTrendLines() && visuals.TrendLineHelper.enumerateObjectInstances(enumeration, this.trendLines) : "forecast" === options.objectName && this.forecastEnabled ? this.supportsForecast() && visuals.ForecastHelper.enumerateObjectInstances(enumeration, this.forecastLine) : "plotArea" === options.objectName && visuals.visualBackgroundHelper.enumeratePlot(enumeration, this.background);
                    if ("dataPoint" === options.objectName && visuals.ComboChart.isComboChart(this.type)) visuals.ComboChart.enumerateDataPoints(enumeration, options, this.layers); else for (var i = 0, len = layersLength; len > i; i++) {
                        var layer = this.layers[i];
                        layer.enumerateObjectInstances && layer.enumerateObjectInstances(enumeration, options);
                    }
                    return enumeration.complete();
                }, CartesianChart.prototype.supportsTrendLines = function(layerIndex) {
                    return this.allLayerSupports(function(layer) {
                        return layer.supportsTrendLine && layer.supportsTrendLine();
                    }, layerIndex);
                }, CartesianChart.prototype.supportsForecast = function(layerIndex) {
                    return this.allLayerSupports(function(layer) {
                        return layer.supportsForecast && layer.supportsForecast();
                    }, layerIndex);
                }, CartesianChart.prototype.supportsDataBoundReferenceLines = function(layerIndex) {
                    return this.allLayerSupports(function(layer) {
                        return !layer.isStacked || !layer.isStacked();
                    }, layerIndex);
                }, CartesianChart.prototype.allLayerSupports = function(predicate, layerIndex) {
                    var layerDataViews = getLayerDataViews(this.dataViews);
                    if (_.isEmpty(this.layers)) return !1;
                    var layers = null == layerIndex ? this.layers : [ this.layers[layerIndex] ];
                    return _.all(layers, function(layer, index) {
                        return layerDataViews[index] ? predicate(layer) : !0;
                    });
                }, CartesianChart.prototype.shouldShowLegendCard = function() {
                    var layers = this.layers, dataViews = this.dataViews;
                    if (layers && dataViews) for (var layersLength = layers.length, layersWithValuesCtr = 0, i = 0; layersLength > i; i++) {
                        if (layers[i].hasLegend()) return !0;
                        var dataView = dataViews[i];
                        if (dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.values.length > 0 && (layersWithValuesCtr++, 
                        layersWithValuesCtr > 1)) return !0;
                    }
                    return !1;
                }, CartesianChart.prototype.getAxisScaleOptions = function(axisType) {
                    var scaleOptions = [ DEFAULT_AXIS_SCALE_TYPE ];
                    return this.axes.isLogScaleAllowed(axisType) && scaleOptions.push(visuals.axisScale.log), 
                    scaleOptions;
                }, CartesianChart.prototype.getCategoryAxisValues = function(enumeration) {
                    if (this.categoryAxisProperties) {
                        var supportedType = visuals.axisType.both, isScalar = !1, scaleOptions = this.getAxisScaleOptions(0);
                        this.layers && this.layers[0].getSupportedCategoryAxisType && (supportedType = this.layers[0].getSupportedCategoryAxisType(), 
                        isScalar = supportedType === visuals.axisType.scalar ? !0 : visuals.CartesianHelper.isScalar(supportedType === visuals.axisType.both, this.categoryAxisProperties)), 
                        isScalar || (this.categoryAxisProperties.start = null, this.categoryAxisProperties.end = null);
                        var instance = {
                            selector: null,
                            properties: {},
                            objectName: "categoryAxis",
                            validValues: {
                                axisScale: scaleOptions,
                                axisStyle: this.axes.categoryAxisHasUnitType ? [ visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth ] : [ visuals.axisStyle.showTitleOnly ]
                            }
                        };
                        if (instance.properties.show = null != this.categoryAxisProperties.show ? this.categoryAxisProperties.show : !0, 
                        this.axes.isYAxisCategorical() && (instance.properties.position = this.valueAxisProperties && null != this.valueAxisProperties.position ? this.valueAxisProperties.position : visuals.yAxisPosition.left), 
                        supportedType === visuals.axisType.both && (instance.properties.axisType = isScalar ? visuals.axisType.scalar : visuals.axisType.categorical), 
                        isScalar && (instance.properties.axisScale = this.categoryAxisProperties.axisScale || DEFAULT_AXIS_SCALE_TYPE, 
                        instance.properties.start = this.categoryAxisProperties.start, instance.properties.end = this.categoryAxisProperties.end), 
                        instance.properties.showAxisTitle = null != this.categoryAxisProperties.showAxisTitle ? this.categoryAxisProperties.showAxisTitle : !1, 
                        instance.properties.axisStyle = this.categoryAxisProperties.axisStyle ? this.categoryAxisProperties.axisStyle : visuals.axisStyle.showTitleOnly, 
                        instance.properties.labelColor = this.categoryAxisProperties.labelColor || visuals.DEFAULT_AXIS_COLOR, 
                        isScalar) {
                            instance.properties.labelDisplayUnits = this.categoryAxisProperties.labelDisplayUnits ? this.categoryAxisProperties.labelDisplayUnits : 0;
                            var labelPrecision = this.categoryAxisProperties.labelPrecision;
                            instance.properties.labelPrecision = void 0 === labelPrecision || 0 > labelPrecision ? visuals.dataLabelUtils.defaultLabelPrecision : labelPrecision;
                        }
                        enumeration.pushInstance(instance);
                    }
                }, CartesianChart.prototype.getValueAxisValues = function(enumeration) {
                    if (this.valueAxisProperties) {
                        var scaleOptions = this.getAxisScaleOptions(1), secScaleOption = this.getAxisScaleOptions(2), instance = {
                            selector: null,
                            properties: {},
                            objectName: "valueAxis",
                            validValues: {
                                axisScale: scaleOptions,
                                secAxisScale: secScaleOption,
                                axisStyle: this.axes.valueAxisHasUnitType ? [ visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth ] : [ visuals.axisStyle.showTitleOnly ],
                                secAxisStyle: this.axes.secondaryValueAxisHasUnitType ? [ visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth ] : [ visuals.axisStyle.showTitleOnly ]
                            }
                        };
                        if (instance.properties.show = null != this.valueAxisProperties.show ? this.valueAxisProperties.show : !0, 
                        instance.properties.axisLabel = this.valueAxisProperties.axisLabel, this.axes.isYAxisCategorical() || (instance.properties.position = null != this.valueAxisProperties.position ? this.valueAxisProperties.position : visuals.yAxisPosition.left), 
                        instance.properties.axisScale = this.valueAxisProperties.axisScale || DEFAULT_AXIS_SCALE_TYPE, 
                        instance.properties.start = this.valueAxisProperties.start, instance.properties.end = this.valueAxisProperties.end, 
                        instance.properties.showAxisTitle = null != this.valueAxisProperties.showAxisTitle ? this.valueAxisProperties.showAxisTitle : !1, 
                        instance.properties.axisStyle = null != this.valueAxisProperties.axisStyle ? this.valueAxisProperties.axisStyle : visuals.axisStyle.showTitleOnly, 
                        instance.properties.labelColor = this.valueAxisProperties.labelColor || visuals.DEFAULT_AXIS_COLOR, 
                        7 !== this.type && 8 !== this.type) {
                            instance.properties.labelDisplayUnits = this.valueAxisProperties.labelDisplayUnits ? this.valueAxisProperties.labelDisplayUnits : 0;
                            var labelPrecision = this.valueAxisProperties.labelPrecision;
                            instance.properties.labelPrecision = void 0 === labelPrecision || 0 > labelPrecision ? visuals.dataLabelUtils.defaultLabelPrecision : labelPrecision;
                        }
                        2 === this.layers.length && (instance.properties.secShow = null != this.valueAxisProperties.secShow ? this.valueAxisProperties.secShow : this.axes.hasY2Axis()), 
                        this.axes.hasY2Axis() && instance.properties.secShow && (instance.properties.secAxisLabel = "", 
                        instance.properties.secPosition = null != this.valueAxisProperties.secPosition ? this.valueAxisProperties.secPosition : visuals.yAxisPosition.right, 
                        instance.properties.secAxisScale = this.valueAxisProperties.secAxisScale || DEFAULT_AXIS_SCALE_TYPE, 
                        instance.properties.secStart = this.valueAxisProperties.secStart, instance.properties.secEnd = this.valueAxisProperties.secEnd, 
                        instance.properties.secShowAxisTitle = null != this.valueAxisProperties.secShowAxisTitle ? this.valueAxisProperties.secShowAxisTitle : !1, 
                        instance.properties.secAxisStyle = this.valueAxisProperties.secAxisStyle ? this.valueAxisProperties.secAxisStyle : visuals.axisStyle.showTitleOnly, 
                        instance.properties.labelColor = this.valueAxisProperties.secLabelColor, instance.properties.secLabelDisplayUnits = this.valueAxisProperties.secLabelDisplayUnits ? this.valueAxisProperties.secLabelDisplayUnits : 0, 
                        instance.properties.secLabelPrecision = this.valueAxisProperties.secLabelPrecision < 0 ? 0 : this.valueAxisProperties.secLabelPrecision), 
                        enumeration.pushInstance(instance);
                    }
                }, CartesianChart.prototype.onClearSelection = function() {
                    if (this.hasSetData) for (var i = 0, len = this.layers.length; len > i; i++) {
                        var layer = this.layers[i];
                        layer.onClearSelection(), layer.render(!0);
                    }
                }, CartesianChart.prototype.extractMetadataObjects = function(dataViews) {
                    var objects;
                    if (dataViews && dataViews.length > 0) {
                        var dataViewMetadata = dataViews[0].metadata;
                        dataViewMetadata && (objects = dataViewMetadata.objects);
                    }
                    return objects;
                }, CartesianChart.prototype.createAndInitLayers = function(objects) {
                    var _this = this, layers = CartesianLayerFactory.createLayers(this.type, objects, this.interactivityService, this.animator, this.axes.isScrollable, this.tooltipsEnabled, this.tooltipBucketEnabled, this.advancedLineLabelsEnabled), cartesianOptions = powerbi.Prototype.inherit(this.visualInitOptions);
                    cartesianOptions.svg = this.svgAxes.getScrollableRegion(), cartesianOptions.labelsContext = this.svgAxes.getLabelsRegion(), 
                    cartesianOptions.cartesianHost = {
                        updateLegend: function(data) {
                            return _this.legend.drawLegend(data, _this.currentViewport);
                        },
                        getSharedColors: function() {
                            return _this.sharedColorPalette;
                        },
                        triggerRender: function(suppressAnimations) {
                            return _this.render(suppressAnimations);
                        }
                    }, cartesianOptions.chartType = this.type;
                    for (var i = 0, len = layers.length; len > i; i++) layers[i].init(cartesianOptions);
                    return layers;
                }, CartesianChart.prototype.renderLegend = function() {
                    for (var layers = this.layers, legendData = {
                        title: "",
                        dataPoints: []
                    }, _loop_1 = function(i, len) {
                        this_1.layerLegendData = layers[i].calculateLegend(), this_1.layerLegendData && (legendData.title = 0 === i ? this_1.layerLegendData.title || "" : legendData.title, 
                        legendData.labelColor = this_1.layerLegendData.labelColor, _.isEmpty(this_1.layerLegendData.dataPoints) || this_1.layerLegendData.dataPoints.forEach(function(dataPoint) {
                            return dataPoint.layerNumber = i;
                        }), legendData.dataPoints = legendData.dataPoints.concat(this_1.layerLegendData.dataPoints || []), 
                        legendData.fontSize = this_1.layerLegendData.fontSize || visuals.SVGLegend.DefaultFontSizeInPt, 
                        this_1.layerLegendData.grouped && (legendData.grouped = !0));
                    }, this_1 = this, i = 0, len = layers.length; len > i; i++) _loop_1(i, len);
                    var legendProperties = this.legendObjectProperties;
                    if (legendProperties) {
                        visuals.LegendData.update(legendData, legendProperties);
                        var position = legendProperties[visuals.legendProps.position];
                        position && this.legend.changeOrientation(visuals.LegendPosition[position]);
                    } else this.legend.changeOrientation(visuals.LegendPosition.Top);
                    (1 === legendData.dataPoints.length && !legendData.grouped || this.hideLegends()) && (legendData.dataPoints = []), 
                    this.legend.drawLegend(legendData, this.currentViewport);
                }, CartesianChart.prototype.hideLegends = function() {
                    return !!(this.cartesianSmallViewPortProperties && this.cartesianSmallViewPortProperties.hideLegendOnSmallViewPort && this.currentViewport.height < this.cartesianSmallViewPortProperties.MinHeightLegendVisible);
                }, CartesianChart.prototype.render = function(suppressAnimations, resizeMode, operationKind) {
                    var _this = this;
                    this.visualInitOptions.interactivity && this.visualInitOptions.interactivity.isInteractiveLegend || this.renderLegend();
                    var playAxisControlLayout, legendMargins = this.legendMargins = this.legend.getMargins(), legendOrientation = this.legend.getOrientation(), hideAxisLabels = this.hideAxisLabels(legendMargins), plotAreaViewport = {
                        height: this.currentViewport.height - legendMargins.height,
                        width: this.currentViewport.width - legendMargins.width
                    }, padding = powerbi.Prototype.inherit(SvgCartesianAxes.AxisPadding);
                    this.isPlayAxis() && (plotAreaViewport.height -= CartesianChart.PlayAxisBottomMargin, 
                    playAxisControlLayout = {
                        left: visuals.Legend.isLeft(legendOrientation) ? legendMargins.width : 0,
                        top: visuals.Legend.isTop(legendOrientation) ? legendMargins.height + plotAreaViewport.height : plotAreaViewport.height,
                        height: CartesianChart.PlayAxisBottomMargin,
                        width: plotAreaViewport.width
                    }), this.chartAreaSvg.attr({
                        width: plotAreaViewport.width,
                        height: plotAreaViewport.height
                    }), visuals.Legend.positionChartArea(this.chartAreaSvg, this.legend);
                    var interactivityRightMargin = this.calculateInteractivityRightMargin(), _a = this.getMinimumDomainExtents(), ensureXDomain = _a[0], ensureYDomain = _a[1], plotAreaHasChanged = !this.renderedPlotArea || this.renderedPlotArea.height !== plotAreaViewport.height || this.renderedPlotArea.width !== plotAreaViewport.width;
                    suppressAnimations = suppressAnimations || plotAreaHasChanged;
                    var axesLayout = this.axes.negotiateAxes(this.layers, plotAreaViewport, padding, playAxisControlLayout, hideAxisLabels, CartesianChart.AxisTextProperties, interactivityRightMargin, ensureXDomain, ensureYDomain), categoryAxis = axesLayout.axes.x.isCategoryAxis ? axesLayout.axes.x : axesLayout.axes.y1;
                    this.loadMoreDataHandler && this.loadMoreDataHandler.setScale(categoryAxis.scale), 
                    this.scrollableAxes.render(axesLayout, this.layers, suppressAnimations, function(layers, axesLayout, suppressAnimations) {
                        return _this.renderPlotArea(layers, axesLayout, suppressAnimations, legendMargins, resizeMode);
                    }, this.loadMoreDataHandler, operationKind === powerbi.VisualDataChangeOperationKind.Append), 
                    this.chartAreaSvg.on("wheel", function() {
                        if (_this.axes.isXScrollBarVisible || _this.axes.isYScrollBarVisible) {
                            visuals.TooltipManager.ToolTipInstance.hide();
                            var wheelEvent = d3.event, dy = wheelEvent.deltaY;
                            _this.scrollableAxes.scrollDelta(dy), wheelEvent.preventDefault();
                        }
                    }), this.renderedPlotArea = plotAreaViewport;
                }, CartesianChart.prototype.getMinimumDomainExtents = function() {
                    var xs = [], ys = [];
                    if (!_.isEmpty(this.xAxisReferenceLines)) {
                        var xAxisReferenceLineProperties = this.xAxisReferenceLines[0].object, value = visuals.ReferenceLineHelper.extractReferenceLineValue(xAxisReferenceLineProperties);
                        xs.push(value);
                    }
                    if (!_.isEmpty(this.y1AxisReferenceLines)) {
                        var y1AxisReferenceLineProperties = this.y1AxisReferenceLines[0].object, value = visuals.ReferenceLineHelper.extractReferenceLineValue(y1AxisReferenceLineProperties);
                        ys.push(value);
                    }
                    this.forecastLine && !_.isEmpty(this.forecastLine.points) && (xs.push.apply(xs, _.map(this.forecastLine.points, function(p) {
                        return p.point.x;
                    })), ys.push.apply(ys, _.map(this.forecastLine.points, function(p) {
                        return p.point.y;
                    })), xs.push.apply(xs, _.map(this.forecastLine.points, function(p) {
                        return p.upperBound.x;
                    })), ys.push.apply(ys, _.map(this.forecastLine.points, function(p) {
                        return p.upperBound.y;
                    })), xs.push.apply(xs, _.map(this.forecastLine.points, function(p) {
                        return p.lowerBound.x;
                    })), ys.push.apply(ys, _.map(this.forecastLine.points, function(p) {
                        return p.lowerBound.y;
                    })));
                    var ensureXDomain = {
                        min: d3.min(xs),
                        max: d3.max(xs)
                    }, ensureYDomain = {
                        min: d3.min(ys),
                        max: d3.max(ys)
                    };
                    return [ ensureXDomain, ensureYDomain ];
                }, CartesianChart.prototype.getPlotAreaRect = function(axesLayout, legendMargins) {
                    var rect = {
                        left: axesLayout.margin.left,
                        top: axesLayout.margin.top,
                        width: axesLayout.plotArea.width,
                        height: axesLayout.plotArea.height
                    };
                    if (this.legend) {
                        var legendPosition_1 = this.legend.getOrientation();
                        visuals.Legend.isTop(legendPosition_1) ? rect.top += legendMargins.height : visuals.Legend.isLeft(legendPosition_1) && (rect.left += legendMargins.width);
                    }
                    return rect;
                }, CartesianChart.prototype.renderBackgroundImage = function(layout) {
                    visuals.visualBackgroundHelper.renderBackgroundImage(this.background, this.element, layout);
                }, CartesianChart.prototype.hideAxisLabels = function(legendMargins) {
                    return !(!(this.cartesianSmallViewPortProperties && this.cartesianSmallViewPortProperties.hideAxesOnSmallViewPort && this.currentViewport.height < this.cartesianSmallViewPortProperties.MinHeightAxesVisible) || this.visualInitOptions.interactivity.isInteractiveLegend);
                }, CartesianChart.prototype.calculateInteractivityRightMargin = function() {
                    return this.visualInitOptions.interactivity && this.visualInitOptions.interactivity.isInteractiveLegend && !this.trimOrdinalDataOnOverflow ? INTERACTIVITY_RIGHT_MARGIN : 0;
                }, CartesianChart.prototype.renderPlotArea = function(layers, axesLayout, suppressAnimations, legendMargins, resizeMode) {
                    suppressAnimations = suppressAnimations || _.any(layers, function(layer) {
                        return layer.shouldSuppressAnimation && layer.shouldSuppressAnimation();
                    });
                    var axes = axesLayout.axes, plotArea = axesLayout.plotArea, plotAreaRect = this.getPlotAreaRect(axesLayout, legendMargins), duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations), easing = this.animator && this.animator.getEasing();
                    this.renderBackgroundImage(plotAreaRect), _.isEmpty(easing) ? this.svgAxes.renderAxes(axesLayout, duration) : this.svgAxes.renderAxes(axesLayout, duration, easing), 
                    this.renderReferenceLines(axesLayout), this.renderLayers(layers, plotArea, axes, suppressAnimations, resizeMode), 
                    this.renderTrendLines(axesLayout), this.renderForecast(axesLayout, suppressAnimations);
                }, CartesianChart.prototype.renderTrendLines = function(axesLayout) {
                    var scrollableRegion = this.svgAxes.getScrollableRegion();
                    visuals.TrendLineHelper.render(this.trendLines, scrollableRegion, axesLayout.axes, axesLayout.plotArea);
                }, CartesianChart.prototype.renderForecast = function(axesLayout, suppressAnimations) {
                    var scrollableRegion = this.svgAxes.getScrollableRegion();
                    visuals.ForecastHelper.render(this.forecastLine, scrollableRegion, axesLayout.axes, axesLayout.plotArea, this.animator, suppressAnimations);
                }, CartesianChart.prototype.renderReferenceLines = function(axesLayout) {
                    var axes = axesLayout.axes, plotArea = axesLayout.plotArea, scrollableRegion = this.svgAxes.getScrollableRegion(), refLineDefaultColor = this.sharedColorPalette.getColorByIndex(0).value, showY1ReferenceLines = !1;
                    if (this.y1AxisReferenceLines) for (var _i = 0, _a = this.y1AxisReferenceLines; _i < _a.length; _i++) {
                        var referenceLineProperties = _a[_i], object = referenceLineProperties.object;
                        if (object[visuals.ReferenceLineHelper.referenceLineProps.show]) {
                            var isHorizontal = !axes.y1.isCategoryAxis, y1RefLineOptions = {
                                graphicContext: scrollableRegion,
                                referenceLineProperties: object,
                                axes: axes,
                                viewport: plotArea,
                                classAndSelector: this.y1RefLine,
                                defaultColor: refLineDefaultColor,
                                isHorizontal: isHorizontal
                            };
                            visuals.ReferenceLineHelper.render(y1RefLineOptions), showY1ReferenceLines = !0;
                        }
                    }
                    showY1ReferenceLines || scrollableRegion.selectAll(this.y1RefLine.selector).remove();
                    var showXReferenceLines = !1;
                    if (this.xAxisReferenceLines) for (var _b = 0, _c = this.xAxisReferenceLines; _b < _c.length; _b++) {
                        var referenceLineProperties = _c[_b], object = referenceLineProperties.object;
                        if (object[visuals.ReferenceLineHelper.referenceLineProps.show]) {
                            var isHorizontal = !1, xRefLineOptions = {
                                graphicContext: scrollableRegion,
                                referenceLineProperties: object,
                                axes: axes,
                                viewport: plotArea,
                                classAndSelector: this.xRefLine,
                                defaultColor: refLineDefaultColor,
                                isHorizontal: isHorizontal
                            };
                            visuals.ReferenceLineHelper.render(xRefLineOptions), showXReferenceLines = !0;
                        }
                    }
                    showXReferenceLines || scrollableRegion.selectAll(this.xRefLine.selector).remove();
                }, CartesianChart.prototype.getReferenceLineLabels = function(axes, plotArea) {
                    var refLineDefaultColor = this.sharedColorPalette.getColorByIndex(0).value, referenceLineLabels = [];
                    if (this.y1AxisReferenceLines) for (var _i = 0, _a = this.y1AxisReferenceLines; _i < _a.length; _i++) {
                        var referenceLineProperties = _a[_i], object = referenceLineProperties.object;
                        if (object[visuals.ReferenceLineHelper.referenceLineProps.show] && object[visuals.ReferenceLineHelper.referenceLineProps.dataLabelShow]) {
                            var isHorizontal = !axes.y1.isCategoryAxis, y1RefLineLabelOptions = {
                                referenceLineProperties: object,
                                axes: axes,
                                viewport: plotArea,
                                defaultColor: refLineDefaultColor,
                                isHorizontal: isHorizontal,
                                key: JSON.stringify({
                                    type: "y1AxisReferenceLine",
                                    id: referenceLineProperties.id
                                })
                            };
                            referenceLineLabels.push(visuals.ReferenceLineHelper.createLabelDataPoint(y1RefLineLabelOptions));
                        }
                    }
                    if (this.xAxisReferenceLines) for (var _b = 0, _c = this.xAxisReferenceLines; _b < _c.length; _b++) {
                        var referenceLineProperties = _c[_b], object = referenceLineProperties.object;
                        if (object[visuals.ReferenceLineHelper.referenceLineProps.show] && object[visuals.ReferenceLineHelper.referenceLineProps.dataLabelShow]) {
                            var isHorizontal = !1, xRefLineLabelOptions = {
                                referenceLineProperties: object,
                                axes: axes,
                                viewport: plotArea,
                                defaultColor: refLineDefaultColor,
                                isHorizontal: isHorizontal,
                                key: JSON.stringify({
                                    type: "xAxisReferenceLine",
                                    id: referenceLineProperties.id
                                })
                            };
                            referenceLineLabels.push(visuals.ReferenceLineHelper.createLabelDataPoint(xRefLineLabelOptions));
                        }
                    }
                    return referenceLineLabels;
                }, CartesianChart.prototype.renderDataLabels = function(labelDataPointGroups, labelsAreNumeric, plotArea, suppressAnimations, isCombo) {
                    var labelBackgroundRegion = this.svgAxes.getLabelBackground(), labelRegion = this.svgAxes.getLabelsRegion();
                    if (this.behavior) {
                        var labelLayoutOptions = visuals.NewDataLabelUtils.getDataLabelLayoutOptions(this.type), labelLayout = new powerbi.LabelLayout(labelLayoutOptions), dataLabels = labelLayout.layout(labelDataPointGroups, plotArea);
                        isCombo && visuals.NewDataLabelUtils.drawLabelBackground(labelBackgroundRegion, dataLabels, "#FFFFFF", .7);
                        var svgLabels = void 0, animator = this.animator;
                        if (animator && !suppressAnimations) {
                            var isPlayAxis = this.isPlayAxis(), duration = isPlayAxis ? visuals.PlayChart.FrameAnimationDuration : animator.getDuration();
                            svgLabels = visuals.NewDataLabelUtils.animateDefaultLabels(labelRegion, dataLabels, duration, labelsAreNumeric, isPlayAxis ? "linear" : animator.getEasing());
                        } else svgLabels = visuals.NewDataLabelUtils.drawDefaultLabels(labelRegion, dataLabels, labelsAreNumeric);
                        if (labelLayoutOptions.allowLeaderLines) {
                            var filteredLabels = _.filter(dataLabels, function(d) {
                                return null != d.leaderLinePoints && !_.isEmpty(d.leaderLinePoints) && null != d.identity;
                            });
                            visuals.NewDataLabelUtils.drawLabelLeaderLines(labelRegion, filteredLabels, function(d) {
                                return d.identity.getKey();
                            });
                        }
                        if (this.interactivityService && this.isLabelInteractivityEnabled) {
                            var labelsBehaviorOptions = {
                                labelItems: svgLabels
                            };
                            this.interactivityService.bind(dataLabels, new visuals.LabelsBehavior(), labelsBehaviorOptions, {
                                isLabels: !0
                            });
                        }
                    } else {
                        var labelLayout = new powerbi.LabelLayout({
                            maximumOffset: visuals.NewDataLabelUtils.maxLabelOffset,
                            startingOffset: visuals.NewDataLabelUtils.startingLabelOffset,
                            attemptToMoveLabelsIntoViewport: !0
                        }), dataLabels = labelLayout.layout(labelDataPointGroups, plotArea);
                        isCombo && visuals.NewDataLabelUtils.drawLabelBackground(labelBackgroundRegion, dataLabels, "#FFFFFF", .7), 
                        visuals.NewDataLabelUtils.drawDefaultLabels(labelRegion, dataLabels, labelsAreNumeric);
                    }
                }, CartesianChart.prototype.renderLayers = function(layers, plotArea, axes, suppressAnimations, resizeMode) {
                    var labelDataPointGroups = [], dataPoints = [], layerBehaviorOptions = [], labelsAreNumeric = !0;
                    suppressAnimations = suppressAnimations || _.any(layers, function(layer) {
                        return layer.shouldSuppressAnimation && layer.shouldSuppressAnimation();
                    });
                    for (var _i = 0, layers_1 = layers; _i < layers_1.length; _i++) {
                        var layer = layers_1[_i], result = layer.render(suppressAnimations, resizeMode);
                        if (result) {
                            if (this.behavior && (dataPoints = dataPoints.concat(result.dataPoints), layerBehaviorOptions.push(result.behaviorOptions)), 
                            result.labelDataPointGroups) for (var resultLabelDataPointsGroups = result.labelDataPointGroups, _a = 0, resultLabelDataPointsGroups_1 = resultLabelDataPointsGroups; _a < resultLabelDataPointsGroups_1.length; _a++) {
                                var resultLabelDataPointsGroup = resultLabelDataPointsGroups_1[_a];
                                resultLabelDataPointsGroup && labelDataPointGroups.push({
                                    labelDataPoints: visuals.NewDataLabelUtils.removeDuplicates(resultLabelDataPointsGroup.labelDataPoints || []),
                                    maxNumberOfLabels: resultLabelDataPointsGroup.maxNumberOfLabels
                                });
                            } else {
                                var resultsLabelDataPoints = result.labelDataPoints || [];
                                labelDataPointGroups.push({
                                    labelDataPoints: visuals.NewDataLabelUtils.removeDuplicates(resultsLabelDataPoints),
                                    maxNumberOfLabels: resultsLabelDataPoints.length
                                });
                            }
                            labelsAreNumeric = labelsAreNumeric && result.labelsAreNumeric;
                        }
                    }
                    var referenceLineLabels = this.getReferenceLineLabels(axes, plotArea);
                    if (_.isEmpty(referenceLineLabels) || labelDataPointGroups.unshift({
                        labelDataPoints: referenceLineLabels,
                        maxNumberOfLabels: referenceLineLabels.length
                    }), this.renderDataLabels(labelDataPointGroups, labelsAreNumeric, plotArea, suppressAnimations, visuals.ComboChart.isComboChart(this.type)), 
                    this.interactivityService) {
                        var behaviorOptions = {
                            layerOptions: layerBehaviorOptions,
                            clearCatcher: this.clearCatcher
                        };
                        this.interactivityService.bind(dataPoints, this.behavior, behaviorOptions);
                    }
                }, CartesianChart.getPreferredPlotArea = function(categoryCount, categoryThickness, viewport, isScrollable, isScalar, margin, noOuterPadding) {
                    margin || (margin = {
                        top: 0,
                        right: 0,
                        bottom: 0,
                        left: 0
                    });
                    var plotArea = {
                        height: viewport.height - margin.top - margin.bottom,
                        width: viewport.width - margin.left - margin.right
                    };
                    if (!isScalar && isScrollable) {
                        var preferredCategorySpan = CartesianChart.getPreferredCategorySpan(categoryCount, categoryThickness, noOuterPadding);
                        plotArea.width = Math.max(preferredCategorySpan, plotArea.width);
                    }
                    return plotArea;
                }, CartesianChart.getPreferredCategorySpan = function(categoryCount, categoryThickness, noOuterPadding) {
                    var span = categoryThickness * categoryCount;
                    return noOuterPadding ? span : span + categoryThickness * CartesianChart.OuterPaddingRatio * 2;
                }, CartesianChart.getLayout = function(data, options) {
                    var categoryCount = options.categoryCount, availableWidth = options.availableWidth, domain = options.domain, trimOrdinalDataOnOverflow = options.trimOrdinalDataOnOverflow, isScalar = !!options.isScalar, isScrollable = !!options.isScrollable, categoryThickness = CartesianChart.getCategoryThickness(data ? data.series : null, categoryCount, availableWidth, domain, isScalar, trimOrdinalDataOnOverflow), totalOuterPadding = categoryThickness * CartesianChart.OuterPaddingRatio * 2, calculatedBarCount = powerbi.Double.floorWithPrecision((availableWidth - totalOuterPadding) / categoryThickness), visibleCategoryCount = Math.min(calculatedBarCount, categoryCount), willScroll = categoryCount > visibleCategoryCount && isScrollable, outerPaddingRatio = CartesianChart.OuterPaddingRatio;
                    if (!isScalar && !willScroll) {
                        var oneOuterPadding = (availableWidth - categoryThickness * visibleCategoryCount) / 2;
                        outerPaddingRatio = oneOuterPadding / categoryThickness;
                    }
                    return !isScalar && isScrollable && (visibleCategoryCount = categoryCount), {
                        categoryCount: visibleCategoryCount,
                        categoryThickness: categoryThickness,
                        outerPaddingRatio: outerPaddingRatio,
                        isScalar: isScalar
                    };
                }, CartesianChart.getCategoryThickness = function(seriesList, numCategories, plotLength, domain, isScalar, trimOrdinalDataOnOverflow) {
                    var thickness;
                    if (2 > numCategories) thickness = plotLength * (1 - CartesianChart.OuterPaddingRatio); else if (isScalar && domain && domain.length > 1) {
                        var minInterval = CartesianChart.getMinInterval(seriesList), domainSpan = domain[domain.length - 1] - domain[0], ratio = minInterval / (domainSpan + minInterval * CartesianChart.OuterPaddingRatio * 2);
                        thickness = plotLength * ratio, thickness = Math.max(thickness, CartesianChart.MinScalarRectThickness);
                    } else thickness = plotLength / (numCategories + 2 * CartesianChart.OuterPaddingRatio), 
                    trimOrdinalDataOnOverflow && (thickness = Math.max(thickness, CartesianChart.MinOrdinalRectThickness));
                    var maxRectThickness = plotLength / (3 + 2 * CartesianChart.OuterPaddingRatio);
                    return thickness = Math.min(thickness, maxRectThickness), !isScalar && numCategories >= 3 && trimOrdinalDataOnOverflow ? Math.max(thickness, CartesianChart.MinOrdinalRectThickness) : thickness;
                }, CartesianChart.getMinInterval = function(seriesList) {
                    var minInterval = Number.MAX_VALUE;
                    if (seriesList.length > 0) for (var series0data = seriesList[0].data.filter(function(d) {
                        return !d.highlight;
                    }), i = 0, ilen = series0data.length - 1; ilen > i; i++) minInterval = Math.min(minInterval, Math.abs(series0data[i + 1].categoryValue - series0data[i].categoryValue));
                    return minInterval;
                }, CartesianChart.expandCategoryWindow = function(mappings) {
                    var NoSeriesWindowCount = 1e3;
                    if (shouldExpandCategoryWindow(mappings)) for (var _i = 0, mappings_1 = mappings; _i < mappings_1.length; _i++) {
                        var mapping = mappings_1[_i];
                        if (!mapping.categorical) return;
                        var categories = mapping.categorical.categories;
                        if (!categories) return;
                        categories.dataReductionAlgorithm = {
                            window: {
                                count: NoSeriesWindowCount
                            }
                        };
                    }
                }, CartesianChart.MinOrdinalRectThickness = 20, CartesianChart.MinScalarRectThickness = 2, 
                CartesianChart.OuterPaddingRatio = .4, CartesianChart.InnerPaddingRatio = .2, CartesianChart.TickLabelPadding = 2, 
                CartesianChart.LoadMoreThreshold = 1, CartesianChart.ClassName = "cartesianChart", 
                CartesianChart.PlayAxisBottomMargin = 80, CartesianChart.FontSize = 11, CartesianChart.FontSizeString = jsCommon.PixelConverter.toString(CartesianChart.FontSize), 
                CartesianChart.AxisTextProperties = {
                    fontFamily: visuals.Font.Family.regular.css,
                    fontSize: CartesianChart.FontSizeString
                }, CartesianChart;
            }();
            visuals.CartesianChart = CartesianChart;
            var SvgBrush = function() {
                function SvgBrush(brushWidth) {
                    this.brush = d3.svg.brush(), this.brushWidth = brushWidth;
                }
                return SvgBrush.prototype.init = function(element) {
                    this.element = element;
                }, SvgBrush.prototype.remove = function() {
                    this.element.selectAll(SvgBrush.Brush.selector).remove(), this.brush.on(SvgBrush.events.brushStart, null).on(SvgBrush.events.brush, null).on(SvgBrush.events.brushEnd, null), 
                    this.brushGraphicsContext = void 0;
                }, SvgBrush.prototype.getExtent = function() {
                    return this.brush.extent();
                }, SvgBrush.prototype.setExtent = function(extent) {
                    this.brush.extent(extent);
                }, SvgBrush.prototype.setScale = function(scale) {
                    this.isHorizontal ? this.brush.x(scale) : this.brush.y(scale);
                }, SvgBrush.prototype.setOrientation = function(isHorizontal) {
                    this.isHorizontal = isHorizontal;
                }, SvgBrush.prototype.renderBrush = function(extentLength, brushX, brushY, scrollCallback) {
                    var _this = this;
                    this.brushGraphicsContext || (this.brushGraphicsContext = this.element.append("g").classed(SvgBrush.Brush["class"], !0)), 
                    this.scrollCallback = scrollCallback, this.brush.on(SvgBrush.events.brushStart, function() {
                        return _this.brushStartExtent = _this.brush.extent();
                    }).on(SvgBrush.events.brush, function() {
                        window.requestAnimationFrame(scrollCallback);
                    }).on(SvgBrush.events.brushEnd, function() {
                        _this.resizeExtent(extentLength), _this.updateExtentPosition(extentLength), _this.brushStartExtent = null;
                    });
                    var brushContext = this.brushGraphicsContext.attr({
                        transform: visuals.SVGUtil.translate(brushX, brushY),
                        "drag-resize-disabled": "true"
                    }).call(this.brush);
                    brushContext.selectAll(".resize").remove(), this.isHorizontal ? brushContext.selectAll("rect").attr("height", this.brushWidth) : brushContext.selectAll("rect").attr("width", this.brushWidth);
                }, SvgBrush.prototype.scroll = function(scrollBarLength) {
                    this.updateExtentPosition(scrollBarLength), this.scrollCallback();
                }, SvgBrush.prototype.updateExtentPosition = function(scrollBarLength) {
                    var extent = this.brush.extent(), newStartPos = extent[0], halfScrollBarLen = scrollBarLength / 2;
                    if (extent[0] === extent[1] && (newStartPos -= halfScrollBarLen), extent[1] - extent[0] > scrollBarLength) {
                        var halfDragLength = (extent[1] - extent[0]) / 2;
                        newStartPos = extent[0] < this.brushStartExtent[0] ? extent[0] + halfDragLength - halfScrollBarLen : extent[1] - halfDragLength - halfScrollBarLen;
                    }
                    this.isHorizontal ? this.brushGraphicsContext.select(".extent").attr("x", newStartPos) : this.brushGraphicsContext.select(".extent").attr("y", newStartPos);
                }, SvgBrush.prototype.resizeExtent = function(extentLength) {
                    this.isHorizontal ? this.brushGraphicsContext.select(".extent").attr("width", extentLength) : this.brushGraphicsContext.select(".extent").attr("height", extentLength);
                }, SvgBrush.events = {
                    brushStart: "brushstart",
                    brush: "brush",
                    brushEnd: "brushend"
                }, SvgBrush.Brush = createClassAndSelector("brush"), SvgBrush;
            }(), ScrollableAxes = function() {
                function ScrollableAxes(axes, svgBrush) {
                    this.axes = axes, this.brush = svgBrush;
                }
                return ScrollableAxes.prototype.filterDataToViewport = function(mainAxisScale, layers, axes, scrollScale, extent, visibleCategoryCount) {
                    if (scrollScale) {
                        var selected, data = [], startIndex = visuals.AxisHelper.lookupOrdinalIndex(scrollScale, extent[0]), endIndex = startIndex + visibleCategoryCount, domain = scrollScale.domain();
                        if (selected = domain.slice(startIndex, endIndex), !_.isEqual(selected, mainAxisScale.domain())) {
                            if (selected && selected.length > 0) {
                                for (var i = 0; i < layers.length; i++) data[i] = layers[i].setFilteredData(selected[0], selected[selected.length - 1] + 1);
                                mainAxisScale.domain(selected);
                                var axisPropsToUpdate = void 0;
                                axisPropsToUpdate = this.axes.isXScrollBarVisible ? axes.x : axes.y1, axisPropsToUpdate.axis.scale(mainAxisScale), 
                                axisPropsToUpdate.scale(mainAxisScale), axisPropsToUpdate.axis.ticks(selected.length), 
                                axisPropsToUpdate.axis.tickValues(selected);
                                var tickFormat_1 = axisPropsToUpdate.axis.tickFormat();
                                axisPropsToUpdate.values = _.map(selected, function(d) {
                                    return tickFormat_1(d);
                                });
                            }
                            return {
                                startIndex: startIndex,
                                endIndex: endIndex - 1
                            };
                        }
                    }
                }, ScrollableAxes.prototype.render = function(axesLayout, layers, suppressAnimations, renderDelegate, loadMoreDataHandler, preserveScrollPosition) {
                    var _this = this, plotArea = axesLayout.plotArea;
                    if (!(plotArea.width < 1 || plotArea.height < 1)) {
                        this.axisScale = null;
                        var brushX, brushY, scrollbarLength, numVisibleCategories, categoryThickness, newAxisLength, showingScrollBar = this.axes.isXScrollBarVisible || this.axes.isYScrollBarVisible;
                        if (loadMoreDataHandler || showingScrollBar) if (this.axes.isYAxisCategorical()) {
                            this.axisScale = axesLayout.axes.y1.scale, brushX = axesLayout.viewport.width, brushY = axesLayout.margin.top, 
                            categoryThickness = axesLayout.axes.y1.categoryThickness;
                            var outerPadding = axesLayout.axes.y1.outerPadding;
                            numVisibleCategories = powerbi.Double.floorWithPrecision((plotArea.height - 2 * outerPadding) / categoryThickness), 
                            scrollbarLength = (numVisibleCategories + 1) * categoryThickness, newAxisLength = plotArea.height;
                        } else {
                            this.axisScale = axesLayout.axes.x.scale, brushX = axesLayout.margin.left, brushY = axesLayout.viewport.height, 
                            categoryThickness = axesLayout.axes.x.categoryThickness;
                            var outerPadding = axesLayout.axes.x.outerPadding;
                            numVisibleCategories = powerbi.Double.floorWithPrecision((plotArea.width - 2 * outerPadding) / categoryThickness), 
                            scrollbarLength = (numVisibleCategories + 1) * categoryThickness, newAxisLength = plotArea.width;
                        }
                        if (!showingScrollBar) return loadMoreDataHandler && (loadMoreDataHandler.viewportDataRange = {
                            startIndex: 0,
                            endIndex: numVisibleCategories
                        }, loadMoreDataHandler.shouldLoadMoreData() && loadMoreDataHandler.loadMoreData()), 
                        this.brush.remove(), void renderDelegate(layers, axesLayout, suppressAnimations);
                        if (!(1 > numVisibleCategories)) {
                            this.scrollScale = this.axisScale.copy(), this.scrollScale.rangeBands([ 0, scrollbarLength ]), 
                            this.brushMinExtent = this.scrollScale(numVisibleCategories - 1), this.axisScale.rangeBands([ 0, newAxisLength ], CartesianChart.InnerPaddingRatio, CartesianChart.OuterPaddingRatio), 
                            this.brush.setOrientation(this.axes.isXScrollBarVisible), this.brush.setScale(this.scrollScale), 
                            this.brush.setExtent([ 0, this.brushMinExtent ]);
                            var renderOnScroll = function(extent, suppressAnimations) {
                                var dataRange = _this.filterDataToViewport(_this.axisScale, layers, axesLayout.axes, _this.scrollScale, extent, numVisibleCategories);
                                null != dataRange && (loadMoreDataHandler && (loadMoreDataHandler.viewportDataRange = dataRange, 
                                loadMoreDataHandler.shouldLoadMoreData() && loadMoreDataHandler.loadMoreData()), 
                                renderDelegate(layers, axesLayout, suppressAnimations));
                            }, scrollCallback = function() {
                                return _this.onBrushed(scrollbarLength, renderOnScroll);
                            };
                            if (this.brush.renderBrush(this.brushMinExtent, brushX, brushY, scrollCallback), 
                            preserveScrollPosition && loadMoreDataHandler) {
                                var startIndex = loadMoreDataHandler.viewportDataRange ? loadMoreDataHandler.viewportDataRange.startIndex : 0;
                                ScrollableAxes.clampBrushExtent(this.brush, scrollbarLength, this.brushMinExtent), 
                                this.scrollTo(startIndex);
                            } else renderOnScroll(this.brush.getExtent(), suppressAnimations);
                        }
                    }
                }, ScrollableAxes.prototype.scrollDelta = function(delta) {
                    if (this.axisScale && !_.isEmpty(this.axisScale.domain())) {
                        var currentStartIndex = this.axisScale.domain()[0], newStartIndex = currentStartIndex + Math.round(delta / CartesianChart.MinOrdinalRectThickness);
                        this.scrollTo(newStartIndex);
                    }
                }, ScrollableAxes.prototype.scrollTo = function(startIndex) {
                    var lastIndex = _.last(this.scrollScale.domain());
                    startIndex = Math.max(0, Math.min(startIndex, lastIndex));
                    var extent = this.brush.getExtent(), extentLength = extent[1] - extent[0], halfCategoryThickness = (this.scrollScale(1) - this.scrollScale(0)) / 2;
                    extent[0] = this.scrollScale(startIndex) + halfCategoryThickness, extent[1] = extent[0] + extentLength + halfCategoryThickness, 
                    this.brush.setExtent(extent);
                    var scrollbarLength = this.scrollScale.rangeExtent()[1];
                    ScrollableAxes.clampBrushExtent(this.brush, scrollbarLength, this.brushMinExtent), 
                    this.brush.scroll(scrollbarLength);
                }, ScrollableAxes.prototype.onBrushed = function(scrollbarLength, render) {
                    var brush = this.brush;
                    ScrollableAxes.clampBrushExtent(this.brush, scrollbarLength, this.brushMinExtent);
                    var extent = brush.getExtent();
                    render(extent, !0);
                }, ScrollableAxes.clampBrushExtent = function(brush, scrollbarLength, minExtent) {
                    var extent = brush.getExtent(), width = extent[1] - extent[0];
                    if (!(width === minExtent && extent[1] <= scrollbarLength && extent[0] >= 0)) {
                        if (width > minExtent) {
                            var padding = (width - minExtent) / 2;
                            extent[0] += padding, extent[1] -= padding;
                        } else if (minExtent > width) {
                            var padding = (minExtent - width) / 2;
                            extent[0] -= padding, extent[1] += padding;
                        }
                        extent[0] < 0 ? (extent[0] = 0, extent[1] = minExtent) : extent[0] > scrollbarLength - minExtent && (extent[0] = scrollbarLength - minExtent, 
                        extent[1] = scrollbarLength), brush.setExtent(extent);
                    }
                }, ScrollableAxes.ScrollbarWidth = 10, ScrollableAxes;
            }(), SvgCartesianAxes = function() {
                function SvgCartesianAxes(axes) {
                    this.axes = axes;
                }
                return SvgCartesianAxes.prototype.getScrollableRegion = function() {
                    return this.axisGraphicsContextScrollable;
                }, SvgCartesianAxes.prototype.getLabelsRegion = function() {
                    return this.labelRegion;
                }, SvgCartesianAxes.prototype.getLabelBackground = function() {
                    return this.labelBackgroundRegion;
                }, SvgCartesianAxes.prototype.getXAxis = function() {
                    return this.xAxisGraphicsContext;
                }, SvgCartesianAxes.prototype.getY1Axis = function() {
                    return this.y1AxisGraphicsContext;
                }, SvgCartesianAxes.prototype.getY2Axis = function() {
                    return this.y2AxisGraphicsContext;
                }, SvgCartesianAxes.prototype.update = function(categoryAxisProperties, valueAxisProperties) {
                    this.categoryAxisProperties = categoryAxisProperties, this.valueAxisProperties = valueAxisProperties;
                }, SvgCartesianAxes.prototype.init = function(svg) {
                    var axisGraphicsContext = this.axisGraphicsContext = svg.append("g").classed(SvgCartesianAxes.AxisGraphicsContext["class"], !0);
                    this.svgScrollable = svg.append("svg").classed("svgScrollable", !0).style("overflow", "hidden");
                    var axisGraphicsContextScrollable = this.axisGraphicsContextScrollable = this.svgScrollable.append("g").classed(SvgCartesianAxes.AxisGraphicsContext["class"], !0);
                    this.labelBackgroundRegion = this.svgScrollable.append("g").classed(visuals.NewDataLabelUtils.labelBackgroundGraphicsContextClass["class"], !0), 
                    this.labelRegion = this.svgScrollable.append("g").classed(visuals.NewDataLabelUtils.labelGraphicsContextClass["class"], !0);
                    var showLinesOnX = this.axes.showLinesOnX, showLinesOnY = this.axes.showLinesOnY, scrollX = showLinesOnY, scrollY = !scrollX;
                    scrollY ? (this.y1AxisGraphicsContext = axisGraphicsContextScrollable.append("g").attr("class", "y axis"), 
                    this.y2AxisGraphicsContext = axisGraphicsContextScrollable.append("g").attr("class", "y axis")) : (this.y1AxisGraphicsContext = axisGraphicsContext.append("g").attr("class", "y axis"), 
                    this.y2AxisGraphicsContext = axisGraphicsContext.append("g").attr("class", "y axis")), 
                    scrollX ? this.xAxisGraphicsContext = axisGraphicsContextScrollable.append("g").attr("class", "x axis") : this.xAxisGraphicsContext = axisGraphicsContext.append("g").attr("class", "x axis"), 
                    this.xAxisGraphicsContext.classed("showLinesOnAxis", showLinesOnX), this.y1AxisGraphicsContext.classed("showLinesOnAxis", showLinesOnY), 
                    this.y2AxisGraphicsContext.classed("showLinesOnAxis", showLinesOnY), this.xAxisGraphicsContext.classed("hideLinesOnAxis", !showLinesOnX), 
                    this.y1AxisGraphicsContext.classed("hideLinesOnAxis", !showLinesOnY), this.y2AxisGraphicsContext.classed("hideLinesOnAxis", !showLinesOnY);
                }, SvgCartesianAxes.updateAnimatedTickTooltips = function(axisSelection, values) {
                    axisSelection.each("end", function() {
                        d3.select(this).selectAll("text").append("title").text(function(d, i) {
                            return values[i];
                        });
                    });
                }, SvgCartesianAxes.updateTickTooltips = function(axisSelection, values) {
                    axisSelection.selectAll("text").append("title").text(function(d, i) {
                        return values[i];
                    });
                }, SvgCartesianAxes.prototype.renderAxes = function(axesLayout, duration, easing) {
                    void 0 === easing && (easing = "cubic-in-out");
                    var xLabelColor, yLabelColor, y2LabelColor, marginLimits = axesLayout.marginLimits, plotArea = axesLayout.plotArea, viewport = axesLayout.viewport, margin = axesLayout.margin, axes = axesLayout.axes, tickLabelMargins = axesLayout.tickLabelMargins, bottomMarginLimit = marginLimits.bottom, leftRightMarginLimit = marginLimits.left;
                    if (this.axes.shouldRenderAxis(axes.x)) {
                        xLabelColor = axes.x.isCategoryAxis ? this.categoryAxisProperties && this.categoryAxisProperties.labelColor ? this.categoryAxisProperties.labelColor : null : this.valueAxisProperties && this.valueAxisProperties.labelColor ? this.valueAxisProperties.labelColor : null, 
                        axes.x.axis.orient("bottom"), !axes.x.willLabelsFit && visuals.AxisHelper.isOrdinalScale(axes.x.scale) && axes.x.axis.tickPadding(SvgCartesianAxes.TickPaddingRotatedX);
                        var xAxisGraphicsElement = this.xAxisGraphicsContext;
                        duration ? xAxisGraphicsElement.transition().duration(duration).ease(easing).call(axes.x.axis).call(SvgCartesianAxes.updateAnimatedTickTooltips, axes.x.values) : xAxisGraphicsElement.call(axes.x.axis), 
                        xAxisGraphicsElement.call(SvgCartesianAxes.darkenZeroLine).call(SvgCartesianAxes.setAxisLabelColor, xLabelColor);
                        var xAxisTextNodes = xAxisGraphicsElement.selectAll("text");
                        axes.x.willLabelsWordBreak ? xAxisTextNodes.call(visuals.AxisHelper.LabelLayoutStrategy.wordBreak, axes.x, bottomMarginLimit) : xAxisTextNodes.call(visuals.AxisHelper.LabelLayoutStrategy.rotate, bottomMarginLimit, powerbi.TextMeasurementService.getTailoredTextOrDefault, CartesianChart.AxisTextProperties, !axes.x.willLabelsFit && visuals.AxisHelper.isOrdinalScale(axes.x.scale), bottomMarginLimit === tickLabelMargins.xMax, axes.x, margin, this.axes.isXScrollBarVisible || this.axes.isYScrollBarVisible), 
                        duration || SvgCartesianAxes.updateTickTooltips(xAxisGraphicsElement, axes.x.values);
                    } else this.xAxisGraphicsContext.selectAll("*").remove();
                    if (this.axes.shouldRenderAxis(axes.y1)) {
                        yLabelColor = axes.y1.isCategoryAxis ? this.categoryAxisProperties && this.categoryAxisProperties.labelColor ? this.categoryAxisProperties.labelColor : null : this.valueAxisProperties && this.valueAxisProperties.labelColor ? this.valueAxisProperties.labelColor : null;
                        var showY1OnRight = this.axes.shouldShowY1OnRight(), y1TickPadding = showY1OnRight ? axesLayout.tickPadding.right : axesLayout.tickPadding.left;
                        axes.y1.axis.tickSize(-plotArea.width).tickPadding(y1TickPadding).orient(this.axes.getYAxisOrientation().toLowerCase());
                        var y1AxisGraphicsElement = this.y1AxisGraphicsContext;
                        if (duration ? y1AxisGraphicsElement.transition().duration(duration).ease(easing).call(axes.y1.axis).call(SvgCartesianAxes.updateAnimatedTickTooltips, axes.y1.values) : y1AxisGraphicsElement.call(axes.y1.axis), 
                        y1AxisGraphicsElement.call(SvgCartesianAxes.darkenZeroLine).call(SvgCartesianAxes.setAxisLabelColor, yLabelColor), 
                        tickLabelMargins.yLeft >= leftRightMarginLimit && y1AxisGraphicsElement.selectAll("text").call(visuals.AxisHelper.LabelLayoutStrategy.clip, leftRightMarginLimit - y1TickPadding, powerbi.TextMeasurementService.svgEllipsis), 
                        duration || SvgCartesianAxes.updateTickTooltips(y1AxisGraphicsElement, axes.y1.values), 
                        !axes.y2 || this.valueAxisProperties && null != this.valueAxisProperties.secShow && !this.valueAxisProperties.secShow) this.y2AxisGraphicsContext.selectAll("*").remove(); else {
                            y2LabelColor = this.valueAxisProperties && this.valueAxisProperties.secLabelColor ? this.valueAxisProperties.secLabelColor : null;
                            var y2TickPadding = showY1OnRight ? axesLayout.tickPadding.left : axesLayout.tickPadding.right;
                            axes.y2.axis.tickSize(SvgCartesianAxes.Y2TickSize).tickPadding(y2TickPadding).orient(showY1OnRight ? visuals.yAxisPosition.left.toLowerCase() : visuals.yAxisPosition.right.toLowerCase());
                            var y2AxisGraphicsElement = this.y2AxisGraphicsContext;
                            duration ? y2AxisGraphicsElement.transition().duration(duration).ease(easing).call(axes.y2.axis).call(SvgCartesianAxes.updateAnimatedTickTooltips, axes.y2.values) : y2AxisGraphicsElement.call(axes.y2.axis), 
                            y2AxisGraphicsElement.call(SvgCartesianAxes.darkenZeroLine).call(SvgCartesianAxes.setAxisLabelColor, y2LabelColor), 
                            tickLabelMargins.yRight >= leftRightMarginLimit && y2AxisGraphicsElement.selectAll("text").call(visuals.AxisHelper.LabelLayoutStrategy.clip, leftRightMarginLimit - y2TickPadding, powerbi.TextMeasurementService.svgEllipsis), 
                            duration || SvgCartesianAxes.updateTickTooltips(y2AxisGraphicsElement, axes.y2.values);
                        }
                    } else this.y1AxisGraphicsContext.selectAll("*").remove(), this.y2AxisGraphicsContext.selectAll("*").remove();
                    var axisLabels = axesLayout.axisLabels, chartHasAxisLabels = null != axisLabels.x || null != axisLabels.y || null != axisLabels.y2;
                    if (chartHasAxisLabels) {
                        var hideXAxisTitle = !this.axes.shouldRenderAxisTitle(axes.x, !0, !1), hideYAxisTitle = !this.axes.shouldRenderAxisTitle(axes.y1, !0, !1), hideY2AxisTitle = !this.axes.shouldRenderAxisTitle(axes.y2, !1, !0), renderAxisOptions = {
                            axisLabels: axisLabels,
                            viewport: viewport,
                            margin: margin,
                            hideXAxisTitle: hideXAxisTitle,
                            hideYAxisTitle: hideYAxisTitle,
                            hideY2AxisTitle: hideY2AxisTitle,
                            xLabelColor: xLabelColor,
                            yLabelColor: yLabelColor,
                            y2LabelColor: y2LabelColor,
                            fontSize: SvgCartesianAxes.AxisLabelFontSize
                        };
                        this.renderAxesLabels(renderAxisOptions);
                    } else this.axisGraphicsContext.selectAll(".xAxisLabel").remove(), this.axisGraphicsContext.selectAll(".yAxisLabel").remove();
                    this.translateAxes(viewport, margin);
                }, SvgCartesianAxes.prototype.renderAxesLabels = function(options) {
                    this.axisGraphicsContext.selectAll(".xAxisLabel").remove(), this.axisGraphicsContext.selectAll(".yAxisLabel").remove();
                    var margin = options.margin, width = options.viewport.width - (margin.left + margin.right), height = options.viewport.height, fontSize = options.fontSize, axisTextProperties = _.clone(CartesianChart.AxisTextProperties);
                    axisTextProperties.fontSize = fontSize + "px";
                    var showOnRight = this.axes.shouldShowY1OnRight();
                    if (!options.hideXAxisTitle) {
                        axisTextProperties.text = options.axisLabels.x;
                        var heightOffset_1 = powerbi.TextMeasurementService.estimateSvgTextHeight(axisTextProperties), xAxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(options.axisLabels.x).call(function(text) {
                            text.each(function() {
                                var text = d3.select(this);
                                text.attr({
                                    "class": "xAxisLabel",
                                    transform: visuals.SVGUtil.translate(width / 2, height - heightOffset_1)
                                });
                            });
                        });
                        xAxisLabel.style("fill", options.xLabelColor ? options.xLabelColor.solid.color : null), 
                        xAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width, powerbi.TextMeasurementService.svgEllipsis).call(visuals.tooltipUtils.tooltipUpdate, [ options.axisLabels.x ]);
                    }
                    if (!options.hideYAxisTitle) {
                        axisTextProperties.text = options.axisLabels.y;
                        var textHeight_1 = powerbi.TextMeasurementService.estimateSvgTextHeight(axisTextProperties), yAxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(options.axisLabels.y).call(function(text) {
                            text.each(function() {
                                var text = d3.select(this);
                                text.attr({
                                    "class": "yAxisLabel",
                                    transform: "rotate(-90)",
                                    y: showOnRight ? width + margin.right - textHeight_1 : -margin.left,
                                    x: -((height - margin.top - margin.bottom) / 2),
                                    dy: "1em"
                                });
                            });
                        });
                        yAxisLabel.style("fill", options.yLabelColor ? options.yLabelColor.solid.color : null), 
                        yAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis).call(visuals.tooltipUtils.tooltipUpdate, [ options.axisLabels.y ]);
                    }
                    if (!options.hideY2AxisTitle && options.axisLabels.y2) {
                        axisTextProperties.text = options.axisLabels.y2;
                        var textHeight_2 = powerbi.TextMeasurementService.estimateSvgTextHeight(axisTextProperties), y2AxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(options.axisLabels.y2).call(function(text) {
                            text.each(function() {
                                var text = d3.select(this);
                                text.attr({
                                    "class": "yAxisLabel",
                                    transform: "rotate(-90)",
                                    y: showOnRight ? -margin.left : width + margin.right - textHeight_2,
                                    x: -((height - margin.top - margin.bottom) / 2),
                                    dy: "1em"
                                });
                            });
                        });
                        y2AxisLabel.style("fill", options.y2LabelColor ? options.y2LabelColor.solid.color : null), 
                        y2AxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis).call(visuals.tooltipUtils.tooltipUpdate, [ options.axisLabels.y2 ]);
                    }
                }, SvgCartesianAxes.prototype.translateAxes = function(viewport, margin) {
                    var width = viewport.width - (margin.left + margin.right), height = viewport.height - (margin.top + margin.bottom), showY1OnRight = this.axes.shouldShowY1OnRight();
                    this.xAxisGraphicsContext.attr("transform", visuals.SVGUtil.translate(0, height)), 
                    this.y1AxisGraphicsContext.attr("transform", visuals.SVGUtil.translate(showY1OnRight ? width : 0, 0)), 
                    this.y2AxisGraphicsContext.attr("transform", visuals.SVGUtil.translate(showY1OnRight ? 0 : width, 0)), 
                    this.svgScrollable.attr({
                        x: 0,
                        width: viewport.width,
                        height: viewport.height
                    }), this.axisGraphicsContext.attr("transform", visuals.SVGUtil.translate(margin.left, margin.top)), 
                    this.axisGraphicsContextScrollable.attr("transform", visuals.SVGUtil.translate(margin.left, margin.top)), 
                    this.labelRegion.attr("transform", visuals.SVGUtil.translate(margin.left, margin.top)), 
                    this.labelBackgroundRegion.attr("transform", visuals.SVGUtil.translate(margin.left, margin.top)), 
                    this.axes.isXScrollBarVisible ? (this.svgScrollable.attr({
                        x: margin.left
                    }), this.axisGraphicsContextScrollable.attr("transform", visuals.SVGUtil.translate(0, margin.top)), 
                    this.labelRegion.attr("transform", visuals.SVGUtil.translate(0, margin.top)), this.labelBackgroundRegion.attr("transform", visuals.SVGUtil.translate(0, margin.top)), 
                    this.svgScrollable.attr("width", width)) : this.axes.isYScrollBarVisible && this.svgScrollable.attr("height", height + margin.top);
                }, SvgCartesianAxes.darkenZeroLine = function(g) {
                    g.selectAll("g.tick line").classed("zero-line", !1);
                    var zeroTick = g.selectAll("g.tick").filter(function(data) {
                        return 0 === data;
                    }).node();
                    zeroTick && d3.select(zeroTick).select("line").classed("zero-line", !0);
                }, SvgCartesianAxes.setAxisLabelColor = function(g, fill) {
                    g.selectAll("g.tick text").style("fill", fill ? fill.solid.color : null);
                }, SvgCartesianAxes.AxisPadding = {
                    left: 10,
                    right: 10,
                    top: 0,
                    bottom: 13
                }, SvgCartesianAxes.AxisGraphicsContext = createClassAndSelector("axisGraphicsContext"), 
                SvgCartesianAxes.TickPaddingRotatedX = 5, SvgCartesianAxes.AxisLabelFontSize = 11, 
                SvgCartesianAxes.Y2TickSize = -6, SvgCartesianAxes;
            }();
            visuals.SvgCartesianAxes = SvgCartesianAxes;
            var CartesianAxes = function() {
                function CartesianAxes(isScrollable, scrollbarWidth, trimOrdinalDataOnOverflow) {
                    this.scrollbarWidth = scrollbarWidth, this.isScrollable = isScrollable, this.maxMarginFactor = CartesianAxes.MaxMarginFactor, 
                    this.yAxisOrientation = visuals.yAxisPosition.left, this.trimOrdinalDataOnOverflow = trimOrdinalDataOnOverflow;
                }
                return CartesianAxes.prototype.shouldShowY1OnRight = function() {
                    return this.yAxisOrientation === visuals.yAxisPosition.right;
                }, CartesianAxes.prototype.isYAxisCategorical = function() {
                    return this.layout && this.layout.axes.y1.isCategoryAxis;
                }, CartesianAxes.prototype.hasCategoryAxis = function() {
                    var axes = this.layout && this.layout.axes;
                    return axes ? this.isYAxisCategorical() ? axes.y1 && null != axes.y1.axis : axes.x && null != axes.x.axis : !1;
                }, CartesianAxes.prototype.hasY2Axis = function() {
                    return this.layout && null != this.layout.axes.y2;
                }, CartesianAxes.prototype.getYAxisOrientation = function() {
                    return this.yAxisOrientation;
                }, CartesianAxes.prototype.setAxisLinesVisibility = function(axisLinesVisibility) {
                    this.showLinesOnX = EnumExtensions.hasFlag(axisLinesVisibility, 3) || EnumExtensions.hasFlag(axisLinesVisibility, 1), 
                    this.showLinesOnY = EnumExtensions.hasFlag(axisLinesVisibility, 3) || EnumExtensions.hasFlag(axisLinesVisibility, 2);
                }, CartesianAxes.prototype.setMaxMarginFactor = function(factor) {
                    this.maxMarginFactor = factor;
                }, CartesianAxes.prototype.update = function(dataViews) {
                    if (dataViews && dataViews.length > 0) {
                        var dataViewMetadata = dataViews[0].metadata;
                        this.categoryAxisProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataViewMetadata), 
                        this.valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataViewMetadata);
                    }
                    var axisPosition = this.valueAxisProperties.position;
                    this.yAxisOrientation = axisPosition ? axisPosition.toString() : visuals.yAxisPosition.left;
                }, CartesianAxes.prototype.addWarnings = function(warnings) {
                    var axes = this.layout && this.layout.axes;
                    (axes && axes.x && axes.x.hasDisallowedZeroInDomain || axes.y1 && axes.y1.hasDisallowedZeroInDomain || axes.y2 && axes.y2.hasDisallowedZeroInDomain) && warnings.unshift(new visuals.ZeroValueWarning());
                }, CartesianAxes.prototype.calculateAxes = function(layers, viewport, margin, playAxisControlLayout, textProperties, scrollbarVisible, existingAxisProperties, hideAxisTitles, ensureXDomain, ensureYDomain) {
                    var mergeResult, visualOptions = {
                        viewport: viewport,
                        margin: margin,
                        forcedXDomain: [ this.categoryAxisProperties ? this.categoryAxisProperties.start : null, this.categoryAxisProperties ? this.categoryAxisProperties.end : null ],
                        forceMerge: this.valueAxisProperties && this.valueAxisProperties.secShow === !1,
                        showCategoryAxisLabel: !1,
                        showValueAxisLabel: !1,
                        trimOrdinalDataOnOverflow: this.trimOrdinalDataOnOverflow,
                        categoryAxisScaleType: this.categoryAxisProperties && null != this.categoryAxisProperties.axisScale ? this.categoryAxisProperties.axisScale : DEFAULT_AXIS_SCALE_TYPE,
                        valueAxisScaleType: this.valueAxisProperties && null != this.valueAxisProperties.axisScale ? this.valueAxisProperties.axisScale : DEFAULT_AXIS_SCALE_TYPE,
                        categoryAxisDisplayUnits: this.categoryAxisProperties && null != this.categoryAxisProperties.labelDisplayUnits ? this.categoryAxisProperties.labelDisplayUnits : 0,
                        valueAxisDisplayUnits: this.valueAxisProperties && null != this.valueAxisProperties.labelDisplayUnits ? this.valueAxisProperties.labelDisplayUnits : 0,
                        categoryAxisPrecision: this.categoryAxisProperties ? visuals.CartesianHelper.getPrecision(this.categoryAxisProperties.labelPrecision) : null,
                        valueAxisPrecision: this.valueAxisProperties ? visuals.CartesianHelper.getPrecision(this.valueAxisProperties.labelPrecision) : null,
                        playAxisControlLayout: playAxisControlLayout,
                        ensureXDomain: ensureXDomain,
                        ensureYDomain: ensureYDomain
                    }, skipMerge = this.valueAxisProperties && this.valueAxisProperties.secShow === !0, yAxisWillMerge = !1;
                    hasMultipleYAxes(layers) && !skipMerge && (mergeResult = tryMergeYDomains(layers, visualOptions), 
                    yAxisWillMerge = mergeResult.merged, yAxisWillMerge ? visualOptions.forcedYDomain = mergeResult.domain : visualOptions.forcedTickCount = mergeResult.tickCount), 
                    this.valueAxisProperties && (visualOptions.forcedYDomain = visuals.AxisHelper.applyCustomizedDomain([ this.valueAxisProperties.start, this.valueAxisProperties.end ], visualOptions.forcedYDomain));
                    for (var result, layerNumber = 0, len = layers.length; len > layerNumber; layerNumber++) {
                        var currentlayer = layers[layerNumber];
                        1 !== layerNumber || yAxisWillMerge || (visualOptions.forcedYDomain = this.valueAxisProperties ? [ this.valueAxisProperties.secStart, this.valueAxisProperties.secEnd ] : null, 
                        visualOptions.valueAxisScaleType = this.valueAxisProperties && null != this.valueAxisProperties.secAxisScale ? this.valueAxisProperties.secAxisScale : DEFAULT_AXIS_SCALE_TYPE, 
                        visualOptions.valueAxisDisplayUnits = this.valueAxisProperties && null != this.valueAxisProperties.secLabelDisplayUnits ? this.valueAxisProperties.secLabelDisplayUnits : 0, 
                        visualOptions.valueAxisPrecision = this.valueAxisProperties ? visuals.CartesianHelper.getPrecision(this.valueAxisProperties.secLabelPrecision) : null), 
                        visualOptions.showCategoryAxisLabel = !!this.categoryAxisProperties && !!this.categoryAxisProperties.showAxisTitle, 
                        visualOptions.showValueAxisLabel = shouldShowYAxisLabel(layerNumber, this.valueAxisProperties, yAxisWillMerge);
                        var axes = currentlayer.calculateAxesProperties(visualOptions);
                        if (0 === layerNumber) result = {
                            x: axes[0],
                            y1: axes[1]
                        }; else if (axes && !result.y2) if (result.x.usingDefaultDomain || _.isEmpty(result.x.dataDomain)) {
                            visualOptions.showValueAxisLabel = !!this.valueAxisProperties && !!this.valueAxisProperties.showAxisTitle;
                            var axes_1 = currentlayer.calculateAxesProperties(visualOptions);
                            result.x = axes_1[0], result.y1 = axes_1[1];
                        } else currentlayer.overrideXScale(result.x), yAxisWillMerge || axes[1].usingDefaultDomain || (result.y2 = axes[1]);
                        if (existingAxisProperties && existingAxisProperties.x) result.x.willLabelsFit = existingAxisProperties.x.willLabelsFit, 
                        result.x.willLabelsWordBreak = existingAxisProperties.x.willLabelsWordBreak; else {
                            var width = viewport.width - (margin.left + margin.right);
                            result.x.willLabelsFit = visuals.AxisHelper.LabelLayoutStrategy.willLabelsFit(result.x, width, powerbi.TextMeasurementService.measureSvgTextWidth, textProperties), 
                            result.x.willLabelsWordBreak = !result.x.willLabelsFit && !scrollbarVisible && visuals.AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(result.x, margin, width, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, powerbi.TextMeasurementService.getTailoredTextOrDefault, textProperties);
                        }
                    }
                    return hideAxisTitles && (result.x.axisLabel = null, result.y1.axisLabel = null, 
                    result.y2 && (result.y2.axisLabel = null)), this.addUnitTypeToAxisLabels(result), 
                    result;
                }, CartesianAxes.prototype.negotiateAxes = function(layers, parentViewport, padding, playAxisControlLayout, hideAxisLabels, textProperties, interactivityRightMargin, ensureXDomain, ensureYDomain) {
                    var margin = powerbi.Prototype.inherit(CartesianAxes.MinimumMargin), viewport = powerbi.Prototype.inherit(parentViewport), leftRightMarginLimit = viewport.width * this.maxMarginFactor, bottomMarginLimit = Math.max(CartesianAxes.MinimumMargin.bottom, Math.ceil(viewport.height * this.maxMarginFactor)), marginLimits = {
                        left: leftRightMarginLimit,
                        right: leftRightMarginLimit,
                        top: 0,
                        bottom: bottomMarginLimit
                    }, axes = this.calculateAxes(layers, viewport, margin, playAxisControlLayout, textProperties, !1, null, hideAxisLabels, ensureXDomain, ensureYDomain), renderXAxis = this.shouldRenderAxis(axes.x), renderY1Axis = this.shouldRenderAxis(axes.y1), renderY2Axis = this.shouldRenderAxis(axes.y2, !0), showY1OnRight = this.shouldShowY1OnRight(), plotArea = {
                        width: viewport.width - (margin.left + margin.right),
                        height: viewport.height - (margin.top + margin.bottom)
                    }, isScalar = !1;
                    _.isEmpty(layers) || layers[0].getVisualCategoryAxisIsScalar && (isScalar = layers[0].getVisualCategoryAxisIsScalar());
                    var tickLabelMargins = void 0;
                    tickLabelMargins = visuals.AxisHelper.getTickLabelMargins(plotArea, marginLimits.left, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, axes, marginLimits.bottom, textProperties, !1, showY1OnRight, renderXAxis, renderY1Axis, renderY2Axis), 
                    margin = this.updateAxisMargins(axes, tickLabelMargins, padding, showY1OnRight, renderY1Axis, renderY2Axis, isScalar ? 0 : interactivityRightMargin);
                    var previousTickCountY1 = axes.y1 && axes.y1.values.length, previousTickCountY2 = axes.y2 && axes.y2.values.length, previousWillFitX = axes.x && axes.x.willLabelsFit, previousWillBreakX = axes.x && axes.x.willLabelsWordBreak;
                    axes = this.calculateAxes(layers, viewport, margin, playAxisControlLayout, textProperties, !1, null, hideAxisLabels, ensureXDomain, ensureYDomain), 
                    plotArea.width = viewport.width - (margin.left + margin.right), plotArea.height = viewport.height - (margin.top + margin.bottom);
                    var preferredPlotArea = this.getPreferredPlotArea(axes, layers, isScalar), rotateXTickLabels90 = !this.willAllCategoriesFitInPlotArea(plotArea, preferredPlotArea), allDone = !(axes.y1 && axes.y1.values.length !== previousTickCountY1 || axes.y2 && axes.y2.values.length !== previousTickCountY2 || axes.x && axes.x.willLabelsFit !== previousWillFitX || axes.x && axes.x.willLabelsWordBreak !== previousWillBreakX || rotateXTickLabels90);
                    if (this.isXScrollBarVisible = !1, this.isYScrollBarVisible = !1, !allDone) {
                        tickLabelMargins = visuals.AxisHelper.getTickLabelMargins(plotArea, marginLimits.left, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, axes, marginLimits.bottom, textProperties, rotateXTickLabels90, showY1OnRight, renderXAxis, renderY1Axis, renderY2Axis), 
                        margin = this.updateAxisMargins(axes, tickLabelMargins, padding, showY1OnRight, renderY1Axis, renderY2Axis, isScalar ? 0 : interactivityRightMargin), 
                        axes = this.calculateAxes(layers, viewport, margin, playAxisControlLayout, textProperties, rotateXTickLabels90, axes, hideAxisLabels, ensureXDomain, ensureYDomain), 
                        plotArea.width = viewport.width - (margin.left + margin.right), plotArea.height = viewport.height - (margin.top + margin.bottom), 
                        preferredPlotArea = this.getPreferredPlotArea(axes, layers, isScalar);
                        var willScroll = !this.willAllCategoriesFitInPlotArea(plotArea, preferredPlotArea);
                        willScroll && (this.showLinesOnY && (this.isXScrollBarVisible = !0, plotArea.height -= this.scrollbarWidth, 
                        viewport.height -= this.scrollbarWidth), this.showLinesOnX && (this.isYScrollBarVisible = !0, 
                        plotArea.width -= this.scrollbarWidth, viewport.width -= this.scrollbarWidth), axes = this.calculateAxes(layers, viewport, margin, playAxisControlLayout, textProperties, !0, axes, hideAxisLabels, ensureXDomain, ensureYDomain));
                    }
                    var axisLabels = hideAxisLabels ? {
                        x: null,
                        y: null,
                        y2: null
                    } : {
                        x: axes.x.axisLabel,
                        y: axes.y1.axisLabel,
                        y2: axes.y2 ? axes.y2.axisLabel : null
                    };
                    return this.layout = {
                        axes: axes,
                        axisLabels: axisLabels,
                        margin: margin,
                        marginLimits: marginLimits,
                        viewport: viewport,
                        plotArea: plotArea,
                        preferredPlotArea: preferredPlotArea,
                        tickLabelMargins: tickLabelMargins,
                        tickPadding: padding,
                        rotateXTickLabels90: rotateXTickLabels90
                    }, this.layout;
                }, CartesianAxes.prototype.getPreferredPlotArea = function(axes, layers, isScalar) {
                    var preferredPlotArea;
                    if (!isScalar && this.isScrollable && !_.isEmpty(layers) && layers[0].getPreferredPlotArea) {
                        var categoryThickness = this.showLinesOnY ? axes.x.categoryThickness : axes.y1.categoryThickness, categoryCount = this.showLinesOnY ? axes.x.dataDomain.length : axes.y1.dataDomain.length;
                        preferredPlotArea = layers[0].getPreferredPlotArea(isScalar, categoryCount, categoryThickness);
                    }
                    return preferredPlotArea;
                }, CartesianAxes.prototype.willAllCategoriesFitInPlotArea = function(plotArea, preferredPlotArea) {
                    return this.showLinesOnY && preferredPlotArea && powerbi.Double.greaterWithPrecision(preferredPlotArea.width, plotArea.width) ? !1 : !(this.showLinesOnX && preferredPlotArea && powerbi.Double.greaterWithPrecision(preferredPlotArea.height, plotArea.height));
                }, CartesianAxes.prototype.updateAxisMargins = function(axes, tickLabelMargins, padding, showY1OnRight, renderY1Axis, renderY2Axis, interactivityRightMargin) {
                    var maxY1Padding = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft, maxY2Padding = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight, maxXAxisBottom = tickLabelMargins.xMax;
                    maxY1Padding += padding.left, (renderY2Axis && !showY1OnRight || showY1OnRight && renderY1Axis) && (maxY2Padding += padding.right), 
                    maxXAxisBottom += padding.bottom;
                    var axisLabels = {
                        x: axes.x.axisLabel,
                        y: axes.y1.axisLabel,
                        y2: axes.y2 ? axes.y2.axisLabel : null
                    };
                    null != axisLabels.x && (maxXAxisBottom += CartesianAxes.XAxisLabelPadding), null != axisLabels.y && (maxY1Padding += CartesianAxes.YAxisLabelPadding), 
                    null != axisLabels.y2 && (maxY2Padding += CartesianAxes.YAxisLabelPadding);
                    var margin = powerbi.Prototype.inherit(CartesianAxes.MinimumMargin);
                    return margin.left = showY1OnRight ? maxY2Padding : maxY1Padding, margin.right = showY1OnRight ? maxY1Padding : maxY2Padding, 
                    margin.right += interactivityRightMargin, margin.bottom = maxXAxisBottom, margin;
                }, CartesianAxes.prototype.isLogScaleAllowed = function(axisType) {
                    var axes = this.layout && this.layout.axes;
                    if (!axes) return !1;
                    switch (axisType) {
                      case 0:
                        return axes.x.isLogScaleAllowed;

                      case 1:
                        return axes.y1.isLogScaleAllowed;

                      case 2:
                        return axes.y2 && axes.y2.isLogScaleAllowed;
                    }
                }, CartesianAxes.prototype.axesHaveTicks = function(viewport) {
                    if (!this.layout) return !1;
                    var margin = this.layout.margin, width = viewport.width - (margin.left + margin.right), height = viewport.height - (margin.top + margin.bottom);
                    return 0 !== visuals.AxisHelper.getRecommendedNumberOfTicksForXAxis(width) || 0 !== visuals.AxisHelper.getRecommendedNumberOfTicksForYAxis(height);
                }, CartesianAxes.prototype.shouldRenderAxisTitle = function(axisProperties, defaultValue, secondary) {
                    var propertyName = secondary ? "secShowAxisTitle" : "showAxisTitle";
                    return !!this.getAxisProperty(axisProperties, propertyName, defaultValue);
                }, CartesianAxes.prototype.shouldRenderAxis = function(axisProperties, secondary) {
                    if (void 0 === secondary && (secondary = !1), !axisProperties) return !1;
                    var propertyName = secondary ? "secShow" : "show";
                    return this.getAxisProperty(axisProperties, propertyName, !0) && axisProperties.values && axisProperties.values.length > 0;
                }, CartesianAxes.prototype.getAxisProperty = function(axisProperties, propertyName, defaultValue) {
                    if (!axisProperties) return defaultValue;
                    var properties = axisProperties.isCategoryAxis ? this.categoryAxisProperties : this.valueAxisProperties;
                    return properties && null != properties[propertyName] ? properties[propertyName] : defaultValue;
                }, CartesianAxes.prototype.addUnitTypeToAxisLabels = function(axes) {
                    var unitType = CartesianAxes.getUnitType(axes.x.formatter);
                    if (axes.x.isCategoryAxis ? this.categoryAxisHasUnitType = null != unitType : this.valueAxisHasUnitType = null != unitType, 
                    axes.x.axisLabel && unitType && (axes.x.isCategoryAxis ? axes.x.axisLabel = visuals.AxisHelper.createAxisLabel(this.categoryAxisProperties, axes.x.axisLabel, unitType) : axes.x.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, axes.x.axisLabel, unitType)), 
                    unitType = CartesianAxes.getUnitType(axes.y1.formatter), axes.y1.isCategoryAxis ? this.categoryAxisHasUnitType = null != unitType : this.valueAxisHasUnitType = null != unitType, 
                    axes.y1.axisLabel && unitType && (axes.y1.isCategoryAxis ? axes.y1.axisLabel = visuals.AxisHelper.createAxisLabel(this.categoryAxisProperties, axes.y1.axisLabel, unitType) : axes.y1.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, axes.y1.axisLabel, unitType)), 
                    axes.y2) {
                        var unitType_1 = CartesianAxes.getUnitType(axes.y2.formatter);
                        this.secondaryValueAxisHasUnitType = null != unitType_1, axes.y2.axisLabel && unitType_1 && (axes.y2.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, axes.y2.axisLabel, unitType_1, !0));
                    }
                }, CartesianAxes.getUnitType = function(formatter) {
                    return formatter && formatter.displayUnit && formatter.displayUnit.value > 1 ? formatter.displayUnit.title : void 0;
                }, CartesianAxes.YAxisLabelPadding = 20, CartesianAxes.XAxisLabelPadding = 18, CartesianAxes.MaxMarginFactor = .25, 
                CartesianAxes.MinimumMargin = {
                    left: 1,
                    right: 1,
                    top: 8,
                    bottom: 25
                }, CartesianAxes;
            }();
            visuals.CartesianAxes = CartesianAxes;
            var CartesianLayerFactory;
            !function(CartesianLayerFactory) {
                function createLayers(type, objects, interactivityService, animator, isScrollable, tooltipsEnabled, tooltipBucketEnabled, advancedLineLabelsEnabled) {
                    void 0 === isScrollable && (isScrollable = !1);
                    var layers = [], cartesianOptions = {
                        isScrollable: isScrollable,
                        animator: animator,
                        interactivityService: interactivityService,
                        tooltipsEnabled: tooltipsEnabled,
                        tooltipBucketEnabled: tooltipBucketEnabled,
                        advancedLineLabelsEnabled: advancedLineLabelsEnabled
                    };
                    switch (type) {
                      case 1:
                        layers.push(createLineChartLayer(2, !1, cartesianOptions));
                        break;

                      case 0:
                        layers.push(createLineChartLayer(1, !1, cartesianOptions));
                        break;

                      case 2:
                        layers.push(createLineChartLayer(16, !1, cartesianOptions));
                        break;

                      case 9:
                        layers.push(createScatterChartLayer(cartesianOptions));
                        break;

                      case 12:
                        layers.push(createWaterfallChartLayer(cartesianOptions));
                        break;

                      case 11:
                        layers.push(createDataDotChartLayer(cartesianOptions));
                        break;

                      case 4:
                        layers.push(createColumnChartLayer(visuals.ColumnChartType.stackedColumn, cartesianOptions));
                        break;

                      case 3:
                        layers.push(createColumnChartLayer(visuals.ColumnChartType.clusteredColumn, cartesianOptions));
                        break;

                      case 8:
                        layers.push(createColumnChartLayer(visuals.ColumnChartType.hundredPercentStackedColumn, cartesianOptions));
                        break;

                      case 6:
                        layers.push(createColumnChartLayer(visuals.ColumnChartType.stackedBar, cartesianOptions));
                        break;

                      case 5:
                        layers.push(createColumnChartLayer(visuals.ColumnChartType.clusteredBar, cartesianOptions));
                        break;

                      case 7:
                        layers.push(createColumnChartLayer(visuals.ColumnChartType.hundredPercentStackedBar, cartesianOptions));
                        break;

                      case 10:
                        var columnType = getComboColumnType();
                        layers.push(createColumnChartLayer(columnType, cartesianOptions)), layers.push(createLineChartLayer(1, !0, cartesianOptions));
                        break;

                      case 13:
                        layers.push(createColumnChartLayer(visuals.ColumnChartType.clusteredColumn, cartesianOptions)), 
                        layers.push(createLineChartLayer(1, !0, cartesianOptions));
                        break;

                      case 14:
                        layers.push(createColumnChartLayer(visuals.ColumnChartType.stackedColumn, cartesianOptions)), 
                        layers.push(createLineChartLayer(1, !0, cartesianOptions));
                        break;

                      case 15:
                        layers.push(createColumnChartLayer(visuals.ColumnChartType.clusteredColumn, cartesianOptions)), 
                        layers.push(createDataDotChartLayer(cartesianOptions));
                        break;

                      case 16:
                        layers.push(createColumnChartLayer(visuals.ColumnChartType.stackedColumn, cartesianOptions)), 
                        layers.push(createDataDotChartLayer(cartesianOptions));
                    }
                    return layers;
                }
                function createLineChartLayer(type, inComboChart, defaultOptions, isTrendLayer) {
                    var options = {
                        animator: defaultOptions.animator,
                        interactivityService: defaultOptions.interactivityService,
                        isScrollable: defaultOptions.isScrollable,
                        tooltipsEnabled: !isTrendLayer && defaultOptions.tooltipsEnabled,
                        tooltipBucketEnabled: defaultOptions.tooltipBucketEnabled,
                        chartType: type,
                        advancedLineLabelsEnabled: defaultOptions.advancedLineLabelsEnabled
                    };
                    return inComboChart && (options.chartType = 8 | options.chartType), new visuals.LineChart(options);
                }
                function createScatterChartLayer(defaultOptions) {
                    return defaultOptions.isScrollable = !1, new visuals.ScatterChart(defaultOptions);
                }
                function createWaterfallChartLayer(defaultOptions) {
                    return new visuals.WaterfallChart(defaultOptions);
                }
                function createDataDotChartLayer(defaultOptions) {
                    return new visuals.DataDotChart(defaultOptions);
                }
                function createColumnChartLayer(type, defaultOptions) {
                    var options = {
                        animator: defaultOptions.animator,
                        interactivityService: defaultOptions.interactivityService,
                        isScrollable: defaultOptions.isScrollable,
                        tooltipsEnabled: defaultOptions.tooltipsEnabled,
                        tooltipBucketEnabled: defaultOptions.tooltipBucketEnabled,
                        chartType: type
                    };
                    return new visuals.ColumnChart(options);
                }
                function getComboColumnType(objects) {
                    var columnType = visuals.ColumnChartType.clusteredColumn;
                    if (objects) {
                        var comboChartTypes = objects.general;
                        if (comboChartTypes) {
                            switch (comboChartTypes.visualType1) {
                              case "Column":
                                columnType = visuals.ColumnChartType.clusteredColumn;
                                break;

                              case "ColumnStacked":
                                columnType = visuals.ColumnChartType.stackedColumn;
                            }
                            comboChartTypes.visualType2;
                        }
                    }
                    return columnType;
                }
                CartesianLayerFactory.createLayers = createLayers;
            }(CartesianLayerFactory || (CartesianLayerFactory = {}));
            var SharedColorPalette = function() {
                function SharedColorPalette(palette) {
                    this.palette = palette, this.clearPreferredScale();
                }
                return SharedColorPalette.prototype.getColorScaleByKey = function(scaleKey) {
                    return this.setPreferredScale(scaleKey), this.preferredScale;
                }, SharedColorPalette.prototype.getNewColorScale = function() {
                    return this.preferredScale;
                }, SharedColorPalette.prototype.getColorByIndex = function(index) {
                    return this.palette.getColorByIndex(index);
                }, SharedColorPalette.prototype.getSentimentColors = function() {
                    return this.palette.getSentimentColors();
                }, SharedColorPalette.prototype.getBasePickerColors = function() {
                    return this.palette.getBasePickerColors();
                }, SharedColorPalette.prototype.clearPreferredScale = function() {
                    this.preferredScale = this.palette.getNewColorScale(), this.rotated = !1;
                }, SharedColorPalette.prototype.rotateScale = function() {
                    this.preferredScale = this.preferredScale.clone(), this.preferredScale.clearAndRotateScale(), 
                    this.rotated = !0;
                }, SharedColorPalette.prototype.setPreferredScale = function(scaleKey) {
                    this.rotated || (this.preferredScale = this.palette.getColorScaleByKey(scaleKey));
                }, SharedColorPalette;
            }();
            visuals.SharedColorPalette = SharedColorPalette;
            var CartesianLoadMoreDataHandler = function() {
                function CartesianLoadMoreDataHandler(scale, loadMoreCallback, loadMoreThreshold) {
                    void 0 === loadMoreThreshold && (loadMoreThreshold = 0), this.loadMoreThreshold = loadMoreThreshold, 
                    this.loadMoreCallback = loadMoreCallback, this.setScale(scale);
                }
                return CartesianLoadMoreDataHandler.prototype.setScale = function(scale) {
                    scale && (this.loadMoreThresholdIndex = scale.domain().length - 1 - this.loadMoreThreshold);
                }, CartesianLoadMoreDataHandler.prototype.isLoadingMoreData = function() {
                    return this.loadingMoreData;
                }, CartesianLoadMoreDataHandler.prototype.onLoadMoreDataCompleted = function() {
                    this.loadingMoreData = !1;
                }, CartesianLoadMoreDataHandler.prototype.shouldLoadMoreData = function() {
                    var viewportDataRange = this.viewportDataRange;
                    return !viewportDataRange || this.isLoadingMoreData() ? !1 : viewportDataRange.endIndex >= this.loadMoreThresholdIndex;
                }, CartesianLoadMoreDataHandler.prototype.loadMoreData = function() {
                    this.isLoadingMoreData() || (this.loadingMoreData = !0, this.loadMoreCallback());
                }, CartesianLoadMoreDataHandler;
            }();
            visuals.CartesianLoadMoreDataHandler = CartesianLoadMoreDataHandler;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var EnumExtensions = jsCommon.EnumExtensions, DataRoleHelper = powerbi.data.DataRoleHelper, flagBar = 2, flagColumn = 4, flagClustered = 8, flagStacked = 16, flagStacked100 = 32 | flagStacked;
            !function(ColumnChartType) {
                ColumnChartType[ColumnChartType.clusteredBar = flagBar | flagClustered] = "clusteredBar", 
                ColumnChartType[ColumnChartType.clusteredColumn = flagColumn | flagClustered] = "clusteredColumn", 
                ColumnChartType[ColumnChartType.hundredPercentStackedBar = flagBar | flagStacked100] = "hundredPercentStackedBar", 
                ColumnChartType[ColumnChartType.hundredPercentStackedColumn = flagColumn | flagStacked100] = "hundredPercentStackedColumn", 
                ColumnChartType[ColumnChartType.stackedBar = flagBar | flagStacked] = "stackedBar", 
                ColumnChartType[ColumnChartType.stackedColumn = flagColumn | flagStacked] = "stackedColumn";
            }(visuals.ColumnChartType || (visuals.ColumnChartType = {}));
            var ColumnChartType = visuals.ColumnChartType, RoleNames = {
                category: "Category",
                series: "Series",
                y: "Y"
            }, ColumnChart = function() {
                function ColumnChart(options) {
                    var chartType = options.chartType;
                    this.chartType = chartType, this.categoryAxisType = null, this.animator = options.animator, 
                    this.isScrollable = options.isScrollable, this.tooltipsEnabled = options.tooltipsEnabled, 
                    this.tooltipBucketEnabled = options.tooltipBucketEnabled, this.interactivityService = options.interactivityService;
                }
                return ColumnChart.customizeQuery = function(options) {
                    var dataViewMapping = options.dataViewMappings[0];
                    if (dataViewMapping && dataViewMapping.categorical && dataViewMapping.categorical.categories) if (dataViewMapping.categorical.dataVolume = 4, 
                    visuals.CartesianChart.detectScalarMapping(dataViewMapping)) {
                        var dataViewCategories = dataViewMapping.categorical.categories;
                        dataViewCategories.dataReductionAlgorithm = {
                            sample: {}
                        };
                        var values = dataViewMapping.categorical.values;
                        values && values.group && (values.group.dataReductionAlgorithm = {
                            top: {}
                        });
                    } else visuals.CartesianChart.expandCategoryWindow([ dataViewMapping ]);
                }, ColumnChart.getSortableRoles = function(options) {
                    var dataViewMapping = options.dataViewMappings[0];
                    if (!dataViewMapping || !dataViewMapping.categorical || !dataViewMapping.categorical.categories) return null;
                    var dataViewCategories = dataViewMapping.categorical.categories, categoryItems = dataViewCategories["for"]["in"].items;
                    if (!_.isEmpty(categoryItems)) {
                        var categoryType = categoryItems[0].type, objects = void 0;
                        if (dataViewMapping.metadata && (objects = dataViewMapping.metadata.objects), !visuals.CartesianChart.getIsScalar(objects, visuals.columnChartProps.categoryAxis.axisType, categoryType)) return [ "Category", "Y" ];
                    }
                    return null;
                }, ColumnChart.prototype.updateVisualMetadata = function(x, y, margin) {
                    this.xAxisProperties = x, this.yAxisProperties = y, this.margin = margin;
                }, ColumnChart.prototype.init = function(options) {
                    this.svg = options.svg, this.svg.classed(ColumnChart.ColumnChartClassName, !0), 
                    this.unclippedGraphicsContext = this.svg.append("g").classed("columnChartUnclippedGraphicsContext", !0), 
                    this.mainGraphicsContext = this.unclippedGraphicsContext.append("svg").classed("mainGraphicsContext", !0), 
                    this.style = options.style, this.currentViewport = options.viewport, this.hostService = options.host, 
                    this.interactivity = options.interactivity, this.colors = this.style.colorPalette.dataColors, 
                    this.cartesianVisualHost = options.cartesianHost, this.options = options, this.isComboChart = visuals.ComboChart.isComboChart(options.chartType), 
                    this.element = options.element;
                }, ColumnChart.prototype.getCategoryLayout = function(numCategoryValues, options) {
                    var availableWidth;
                    availableWidth = ColumnChart.isBar(this.chartType) ? this.currentViewport.height - (this.margin.top + this.margin.bottom) : this.currentViewport.width - (this.margin.left + this.margin.right);
                    var metaDataColumn = this.data ? this.data.categoryMetadata : void 0, categoryDataType = visuals.AxisHelper.getCategoryValueType(metaDataColumn), isScalar = this.data ? this.data.scalarCategoryAxis : !1, domain = visuals.AxisHelper.createDomain(this.data.series, categoryDataType, isScalar, options.forcedXDomain, options.ensureXDomain);
                    return visuals.CartesianChart.getLayout(this.data, {
                        availableWidth: availableWidth,
                        categoryCount: numCategoryValues,
                        domain: domain,
                        isScalar: isScalar,
                        isScrollable: this.isScrollable,
                        trimOrdinalDataOnOverflow: options.trimOrdinalDataOnOverflow
                    });
                }, ColumnChart.converter = function(dataView, colors, is100PercentStacked, isScalar, dataViewMetadata, chartType, interactivityService, tooltipsEnabled, tooltipBucketEnabled) {
                    void 0 === is100PercentStacked && (is100PercentStacked = !1), void 0 === isScalar && (isScalar = !1), 
                    void 0 === dataViewMetadata && (dataViewMetadata = null), void 0 === tooltipsEnabled && (tooltipsEnabled = !0);
                    var xAxisCardProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataViewMetadata), valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataViewMetadata);
                    isScalar = visuals.CartesianHelper.isScalar(isScalar, xAxisCardProperties);
                    var dataViewCat = visuals.ColumnUtil.applyUserMinMax(isScalar, dataView.categorical, xAxisCardProperties), converterStrategy = new ColumnChartConverterHelper(dataView), categoryInfo = visuals.converterHelper.getPivotedCategories(dataViewCat, visuals.columnChartProps.general.formatString), categories = categoryInfo.categories, categoryFormatter = categoryInfo.categoryFormatter, categoryIdentities = categoryInfo.categoryIdentities, categoryMetadata = dataViewCat && dataViewCat.categories && dataViewCat.categories.length > 0 ? dataViewCat.categories[0].source : void 0, labelSettings = visuals.dataLabelUtils.getDefaultColumnLabelSettings(is100PercentStacked || ColumnChart.isStacked(chartType)), defaultLegendLabelColor = visuals.LegendData.DefaultLegendLabelFillColor, defaultDataPointColor = void 0, showAllDataPoints = void 0;
                    if (dataViewMetadata && dataViewMetadata.objects) {
                        var objects = dataViewMetadata.objects;
                        defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.columnChartProps.dataPoint.defaultColor), 
                        showAllDataPoints = powerbi.DataViewObjects.getValue(objects, visuals.columnChartProps.dataPoint.showAllDataPoints), 
                        defaultLegendLabelColor = powerbi.DataViewObjects.getFillColor(objects, visuals.columnChartProps.legend.labelColor, visuals.LegendData.DefaultLegendLabelFillColor);
                        var labelsObj = objects.labels;
                        visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, labelSettings);
                    }
                    for (var legendAndSeriesInfo = converterStrategy.getLegend(colors, defaultLegendLabelColor, defaultDataPointColor), legend = legendAndSeriesInfo.legend.dataPoints, seriesSources = legendAndSeriesInfo.seriesSources, result = ColumnChart.createDataPoints(dataView, categories, categoryIdentities, legend, legendAndSeriesInfo.seriesObjects, converterStrategy, labelSettings, is100PercentStacked, isScalar, visuals.converterHelper.categoryIsAlsoSeriesRole(dataView, RoleNames.series, RoleNames.category), categoryInfo.categoryObjects, defaultDataPointColor, chartType, categoryMetadata, tooltipsEnabled, tooltipBucketEnabled), columnSeries = result.series, valuesMetadata = [], j = 0, jlen = legend.length; jlen > j; j++) valuesMetadata.push(seriesSources[j]);
                    var labels = visuals.converterHelper.createAxesLabels(xAxisCardProperties, valueAxisProperties, categoryMetadata, valuesMetadata);
                    if (!ColumnChart.isColumn(chartType)) {
                        var temp = labels.xAxisLabel;
                        labels.xAxisLabel = labels.yAxisLabel, labels.yAxisLabel = temp;
                    }
                    if (interactivityService) {
                        for (var _i = 0, columnSeries_1 = columnSeries; _i < columnSeries_1.length; _i++) {
                            var series = columnSeries_1[_i];
                            interactivityService.applySelectionStateToData(series.data);
                        }
                        interactivityService.applySelectionStateToData(legendAndSeriesInfo.legend.dataPoints);
                    }
                    return {
                        categories: categories,
                        categoryFormatter: categoryFormatter,
                        series: columnSeries,
                        valuesMetadata: valuesMetadata,
                        legendData: legendAndSeriesInfo.legend,
                        hasHighlights: result.hasHighlights,
                        categoryMetadata: categoryMetadata,
                        scalarCategoryAxis: isScalar,
                        labelSettings: labelSettings,
                        axesLabels: {
                            x: labels.xAxisLabel,
                            y: labels.yAxisLabel
                        },
                        hasDynamicSeries: result.hasDynamicSeries,
                        isMultiMeasure: result.isMultiMeasure,
                        defaultDataPointColor: defaultDataPointColor,
                        showAllDataPoints: showAllDataPoints
                    };
                }, ColumnChart.canSupportOverflow = function(chartType, seriesCount) {
                    return !ColumnChart.isStacked(chartType) || 1 === seriesCount;
                }, ColumnChart.createDataPoints = function(dataView, categories, categoryIdentities, legend, seriesObjectsList, converterStrategy, defaultLabelSettings, is100PercentStacked, isScalar, isCategoryAlsoSeries, categoryObjectsList, defaultDataPointColor, chartType, categoryMetadata, tooltipsEnabled, tooltipBucketEnabled) {
                    void 0 === is100PercentStacked && (is100PercentStacked = !1), void 0 === isScalar && (isScalar = !1);
                    var dataViewCat = dataView.categorical, reader = powerbi.data.createIDataViewCategoricalReader(dataView), grouped = dataViewCat && dataViewCat.values ? dataViewCat.values.grouped() : void 0, categoryCount = categories.length, seriesCount = reader.hasValues("Y") ? reader.getSeriesCount("Y") : void 0, columnSeries = [];
                    if (1 > seriesCount || 1 > categoryCount) return {
                        series: columnSeries,
                        hasHighlights: !1,
                        hasDynamicSeries: !1,
                        isMultiMeasure: !1
                    };
                    var dvCategories = dataViewCat.categories;
                    categoryMetadata = _.isEmpty(dvCategories) ? null : dvCategories[0].source;
                    for (var categoryType = visuals.AxisHelper.getCategoryValueType(categoryMetadata), isDateTime = visuals.AxisHelper.isDateTime(categoryType), baseValuesPos = [], baseValuesNeg = [], rawValues = [], rawHighlightValues = [], hasDynamicSeries = !(!dataViewCat.values || !dataViewCat.values.source), isMultiMeasure = !hasDynamicSeries && seriesCount > 1, highlightsOverflow = !1, hasHighlights = converterStrategy.hasHighlightValues(0), seriesIndex = 0; seriesCount > seriesIndex; seriesIndex++) {
                        for (var seriesValues = [], seriesHighlightValues = [], categoryIndex = 0; categoryCount > categoryIndex; categoryIndex++) {
                            var value = converterStrategy.getValueBySeriesAndCategory(seriesIndex, categoryIndex);
                            if (seriesValues[categoryIndex] = value, hasHighlights) {
                                var highlightValue = converterStrategy.getHighlightBySeriesAndCategory(seriesIndex, categoryIndex);
                                seriesHighlightValues[categoryIndex] = highlightValue, value >= 0 && highlightValue >= 0 && value >= highlightValue || 0 >= value && 0 >= highlightValue && highlightValue >= value || (highlightsOverflow = !0);
                            }
                        }
                        rawValues.push(seriesValues), hasHighlights && rawHighlightValues.push(seriesHighlightValues);
                    }
                    highlightsOverflow && !ColumnChart.canSupportOverflow(chartType, seriesCount) && (highlightsOverflow = !1, 
                    hasHighlights = !1, rawValues = rawHighlightValues);
                    for (var dataPointObjects = categoryObjectsList, formatStringProp = visuals.columnChartProps.general.formatString, seriesIndex = 0; seriesCount > seriesIndex; seriesIndex++) {
                        var seriesDataPoints = [], legendItem = legend[seriesIndex], seriesLabelSettings = void 0;
                        if (!hasDynamicSeries) {
                            var labelsSeriesGroup = !_.isEmpty(grouped) && grouped[0].values ? grouped[0].values[seriesIndex] : null, labelObjects = labelsSeriesGroup && labelsSeriesGroup.source && labelsSeriesGroup.source.objects ? labelsSeriesGroup.source.objects.labels : null;
                            labelObjects && (seriesLabelSettings = powerbi.Prototype.inherit(defaultLabelSettings), 
                            visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelObjects, seriesLabelSettings));
                        }
                        columnSeries.push({
                            displayName: legendItem.label,
                            key: "series" + seriesIndex,
                            index: seriesIndex,
                            data: seriesDataPoints,
                            identity: legendItem.identity,
                            color: legendItem.color,
                            labelSettings: seriesLabelSettings
                        }), seriesCount > 1 && (dataPointObjects = seriesObjectsList[seriesIndex]);
                        for (var valueColumnMetadata = reader.getValueMetadataColumn("Y", seriesIndex), gradientMeasureIndex = visuals.GradientUtils.getGradientMeasureIndex(dataViewCat), gradientValueColumn = visuals.GradientUtils.getGradientValueColumn(dataViewCat), valueMeasureIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Y"), pctFormatString = visuals.valueFormatter.getLocalizedString("Percentage"), categoryIndex = 0; categoryCount > categoryIndex; categoryIndex++) {
                            0 === seriesIndex && (baseValuesPos.push(0), baseValuesNeg.push(0));
                            var value = visuals.AxisHelper.normalizeNonFiniteNumber(rawValues[seriesIndex][categoryIndex]);
                            if (!(null == value && seriesIndex > 0)) {
                                var originalValue = value, categoryValue = categories[categoryIndex];
                                if ((!isDateTime || null == categoryValue || categoryValue instanceof Date) && (isDateTime && categoryValue && (categoryValue = categoryValue.getTime()), 
                                !isScalar || null != categoryValue && !isNaN(categoryValue))) {
                                    var multipliers = void 0;
                                    is100PercentStacked && (multipliers = visuals.StackedUtil.getStackedMultiplier(dataViewCat, categoryIndex, seriesCount, categoryCount, converterStrategy));
                                    var unadjustedValue = value, isNegative = 0 > value;
                                    multipliers && (value *= isNegative ? multipliers.neg : multipliers.pos);
                                    var valueAbsolute = Math.abs(value), position = void 0;
                                    isNegative ? (position = baseValuesNeg[categoryIndex], isNaN(valueAbsolute) || (baseValuesNeg[categoryIndex] -= valueAbsolute)) : (isNaN(valueAbsolute) || (baseValuesPos[categoryIndex] += valueAbsolute), 
                                    position = baseValuesPos[categoryIndex]);
                                    var seriesGroup = grouped && grouped.length > seriesIndex && grouped[seriesIndex].values ? grouped[seriesIndex].values[valueMeasureIndex] : null, category = _.isEmpty(dataViewCat.categories) ? null : dataViewCat.categories[0], identity = visuals.SelectionIdBuilder.builder().withCategory(category, categoryIndex).withSeries(dataViewCat.values, seriesGroup).withMeasure(converterStrategy.getMeasureNameByIndex(seriesIndex)).createSelectionId(), rawCategoryValue = reader.getCategoryValue("Category", categoryIndex), color = ColumnChart.getDataPointColor(legendItem, categoryIndex, dataPointObjects), gradientColumnForTooltip = 0 === gradientMeasureIndex ? null : gradientValueColumn, valueHighlight = void 0, unadjustedValueHighlight = void 0, absoluteValueHighlight = void 0, highlightValue = void 0, highlightPosition = void 0, highlightIdentity = void 0;
                                    if (hasHighlights) {
                                        valueHighlight = reader.getHighlight("Y", categoryIndex, seriesIndex), unadjustedValueHighlight = valueHighlight;
                                        var highlightedTooltip = !0;
                                        null === valueHighlight && (valueHighlight = 0, highlightedTooltip = !1), is100PercentStacked && (valueHighlight *= multipliers.pos), 
                                        absoluteValueHighlight = Math.abs(valueHighlight), highlightPosition = position, 
                                        valueHighlight > 0 ? highlightPosition -= valueAbsolute - absoluteValueHighlight : 0 === valueHighlight && value > 0 && (highlightPosition -= valueAbsolute), 
                                        highlightIdentity = visuals.SelectionId.createWithHighlight(identity);
                                        var highlightedValueAndPct = void 0, highlightedValueFormat = void 0;
                                        if (highlightedTooltip && null != unadjustedValueHighlight && null != valueHighlight) {
                                            var highlightedPct = visuals.valueFormatter.format(valueHighlight, pctFormatString);
                                            highlightedValueFormat = visuals.converterHelper.formatFromMetadataColumn(unadjustedValueHighlight, valueColumnMetadata, formatStringProp), 
                                            highlightedValueAndPct = highlightedValueFormat + " (" + highlightedPct + ")";
                                        }
                                        highlightValue = is100PercentStacked ? highlightedValueAndPct : highlightedValueFormat;
                                    }
                                    var tooltipInfo = void 0;
                                    if (tooltipsEnabled) {
                                        if (tooltipInfo = [], category && tooltipInfo.push({
                                            displayName: reader.getCategoryDisplayName("Category"),
                                            value: visuals.converterHelper.formatFromMetadataColumn(rawCategoryValue, category.source, formatStringProp)
                                        }), hasDynamicSeries && (category && category.source === dataViewCat.values.source || tooltipInfo.push({
                                            displayName: dataViewCat.values.source.displayName,
                                            value: visuals.converterHelper.formatFromMetadataColumn(grouped[seriesIndex].name, dataViewCat.values.source, formatStringProp)
                                        })), null != originalValue) {
                                            var valueString = void 0, formattedOriginalValue = visuals.converterHelper.formatFromMetadataColumn(originalValue, valueColumnMetadata, formatStringProp);
                                            if (is100PercentStacked) {
                                                var originalPct = visuals.valueFormatter.format(valueAbsolute, pctFormatString);
                                                valueString = formattedOriginalValue + " (" + originalPct + ")";
                                            } else valueString = formattedOriginalValue;
                                            tooltipInfo.push({
                                                displayName: valueColumnMetadata.displayName,
                                                value: valueString
                                            });
                                        }
                                        null != highlightValue && tooltipInfo.push({
                                            displayName: visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName,
                                            value: highlightValue
                                        }), gradientColumnForTooltip && null != gradientColumnForTooltip.values[categoryIndex] && tooltipInfo.push({
                                            displayName: gradientColumnForTooltip.source.displayName,
                                            value: visuals.converterHelper.formatFromMetadataColumn(gradientColumnForTooltip.values[categoryIndex], gradientColumnForTooltip.source, formatStringProp)
                                        }), tooltipBucketEnabled && visuals.TooltipBuilder.addTooltipBucketItem(reader, tooltipInfo, categoryIndex, hasDynamicSeries ? seriesIndex : void 0);
                                    }
                                    var series = columnSeries[seriesIndex], dataPointLabelSettings = series.labelSettings ? series.labelSettings : defaultLabelSettings, labelColor = dataPointLabelSettings.labelColor, lastValue = void 0;
                                    ColumnChart.isStacked(chartType) && (lastValue = this.getStackedLabelColor(isNegative, seriesIndex, seriesCount, categoryIndex, rawValues), 
                                    labelColor = lastValue || seriesIndex === seriesCount - 1 && !isNegative ? labelColor : visuals.dataLabelUtils.defaultInsideLabelColor);
                                    var dataPoint = {
                                        categoryValue: categoryValue,
                                        value: value,
                                        position: position,
                                        valueAbsolute: valueAbsolute,
                                        valueOriginal: unadjustedValue,
                                        seriesIndex: seriesIndex,
                                        labelSettings: dataPointLabelSettings,
                                        categoryIndex: categoryIndex,
                                        color: color,
                                        selected: !1,
                                        originalValue: value,
                                        originalPosition: position,
                                        originalValueAbsolute: valueAbsolute,
                                        identity: identity,
                                        key: identity.getKey(),
                                        tooltipInfo: tooltipInfo,
                                        labelFill: labelColor,
                                        labelFormatString: valueColumnMetadata.format,
                                        lastSeries: lastValue,
                                        chartType: chartType
                                    };
                                    if (seriesDataPoints.push(dataPoint), hasHighlights) {
                                        var highlightDataPoint = {
                                            categoryValue: categoryValue,
                                            value: valueHighlight,
                                            position: highlightPosition,
                                            valueAbsolute: absoluteValueHighlight,
                                            valueOriginal: unadjustedValueHighlight,
                                            seriesIndex: seriesIndex,
                                            labelSettings: dataPointLabelSettings,
                                            categoryIndex: categoryIndex,
                                            color: color,
                                            selected: !1,
                                            highlight: !0,
                                            originalValue: value,
                                            originalPosition: position,
                                            originalValueAbsolute: valueAbsolute,
                                            drawThinner: highlightsOverflow,
                                            identity: highlightIdentity,
                                            key: highlightIdentity.getKey(),
                                            tooltipInfo: tooltipInfo,
                                            labelFormatString: valueColumnMetadata.format,
                                            labelFill: labelColor,
                                            lastSeries: lastValue,
                                            chartType: chartType
                                        };
                                        seriesDataPoints.push(highlightDataPoint);
                                    }
                                }
                            }
                        }
                    }
                    return {
                        series: columnSeries,
                        hasHighlights: hasHighlights,
                        hasDynamicSeries: hasDynamicSeries,
                        isMultiMeasure: isMultiMeasure
                    };
                }, ColumnChart.getDataPointColor = function(legendItem, categoryIndex, dataPointObjects) {
                    if (dataPointObjects) {
                        var colorOverride = powerbi.DataViewObjects.getFillColor(dataPointObjects[categoryIndex], visuals.columnChartProps.dataPoint.fill);
                        if (colorOverride) return colorOverride;
                    }
                    return legendItem.color;
                }, ColumnChart.getStackedLabelColor = function(isNegative, seriesIndex, seriesCount, categoryIndex, rawValues) {
                    for (var lastValue = !(isNegative && seriesIndex === seriesCount - 1 && 1 !== seriesCount), i = seriesIndex + 1; seriesCount > i; i++) {
                        var nextValues = visuals.AxisHelper.normalizeNonFiniteNumber(rawValues[i][categoryIndex]);
                        if (null !== nextValues && ((!isNegative || isNegative && 0 === seriesIndex) && nextValues > 0 || isNegative && 0 !== seriesIndex)) {
                            lastValue = !1;
                            break;
                        }
                    }
                    return lastValue;
                }, ColumnChart.sliceSeries = function(series, endIndex, startIndex) {
                    void 0 === startIndex && (startIndex = 0);
                    var newSeries = [];
                    if (series && series.length > 0) for (var i = 0, len = series.length; len > i; i++) {
                        var iNewSeries = newSeries[i] = powerbi.Prototype.inherit(series[i]);
                        iNewSeries.data = series[i].data.filter(function(d) {
                            return d.categoryIndex >= startIndex && d.categoryIndex < endIndex;
                        });
                    }
                    return newSeries;
                }, ColumnChart.getInteractiveColumnChartDomElement = function(element) {
                    return element.children("svg").get(0);
                }, ColumnChart.prototype.setData = function(dataViews) {
                    var is100PctStacked = ColumnChart.isStacked100(this.chartType);
                    if (this.data = {
                        categories: [],
                        categoryFormatter: null,
                        series: [],
                        valuesMetadata: [],
                        legendData: null,
                        hasHighlights: !1,
                        categoryMetadata: null,
                        scalarCategoryAxis: !1,
                        labelSettings: visuals.dataLabelUtils.getDefaultColumnLabelSettings(is100PctStacked || ColumnChart.isStacked(this.chartType)),
                        axesLabels: {
                            x: null,
                            y: null
                        },
                        hasDynamicSeries: !1,
                        defaultDataPointColor: null,
                        isMultiMeasure: !1
                    }, dataViews.length > 0) {
                        var dataView = this.dataView = dataViews[0];
                        if (dataView && dataView.categorical) {
                            var dvCategories = dataView.categorical.categories, categoryMetadata = dvCategories && dvCategories.length > 0 ? dvCategories[0].source : null, categoryType = visuals.AxisHelper.getCategoryValueType(categoryMetadata);
                            this.data = ColumnChart.converter(dataView, this.cartesianVisualHost.getSharedColors(), is100PctStacked, visuals.CartesianChart.getIsScalar(dataView.metadata ? dataView.metadata.objects : null, visuals.columnChartProps.categoryAxis.axisType, categoryType), dataView.metadata, this.chartType, this.interactivityService, this.tooltipsEnabled, this.tooltipBucketEnabled);
                        }
                    }
                    this.setChartStrategy();
                }, ColumnChart.prototype.setChartStrategy = function() {
                    switch (this.chartType) {
                      case ColumnChartType.clusteredBar:
                        this.columnChart = new visuals.ClusteredBarChartStrategy();
                        break;

                      case ColumnChartType.clusteredColumn:
                        this.columnChart = new visuals.ClusteredColumnChartStrategy();
                        break;

                      case ColumnChartType.stackedBar:
                      case ColumnChartType.hundredPercentStackedBar:
                        this.columnChart = new visuals.StackedBarChartStrategy();
                        break;

                      case ColumnChartType.stackedColumn:
                      case ColumnChartType.hundredPercentStackedColumn:
                      default:
                        this.columnChart = new visuals.StackedColumnChartStrategy();
                    }
                    if (ColumnChart.isStacked(this.chartType) && 1 === this.data.series.length) switch (this.chartType) {
                      case ColumnChartType.stackedBar:
                        this.columnChart = new visuals.ClusteredBarChartStrategy();
                        break;

                      case ColumnChartType.stackedColumn:
                        this.columnChart = new visuals.ClusteredColumnChartStrategy();
                    }
                }, ColumnChart.prototype.calculateLegend = function() {
                    if (this.interactivity && this.interactivity.isInteractiveLegend) return this.createInteractiveLegendDataPoints(0);
                    var legendData = this.data ? this.data.legendData : null, legendDataPoints = legendData ? legendData.dataPoints : [];
                    return _.isEmpty(legendDataPoints) ? null : legendData;
                }, ColumnChart.prototype.hasLegend = function() {
                    return this.data && (this.data.hasDynamicSeries || this.data.series && this.data.series.length > 1);
                }, ColumnChart.prototype.enumerateObjectInstances = function(enumeration, options) {
                    switch (options.objectName) {
                      case "dataPoint":
                        this.dataView && !visuals.GradientUtils.hasGradientRole(this.dataView.categorical) && this.enumerateDataPoints(enumeration);
                        break;

                      case "labels":
                        this.enumerateDataLabels(enumeration);
                    }
                }, ColumnChart.prototype.enumerateDataLabels = function(enumeration) {
                    var data = this.data, labelSettings = this.data.labelSettings, seriesCount = data.series.length, showLabelPerSeries = !data.hasDynamicSeries && (seriesCount > 1 || !data.categoryMetadata);
                    if (visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings, null, showLabelPerSeries)), 
                    0 !== seriesCount && showLabelPerSeries && labelSettings.showLabelPerSeries) for (var i = 0; seriesCount > i; i++) {
                        var series = data.series[i], labelSettings_1 = series.labelSettings ? series.labelSettings : this.data.labelSettings;
                        enumeration.pushContainer({
                            displayName: series.displayName
                        }), visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings_1, series)), 
                        enumeration.popContainer();
                    }
                }, ColumnChart.prototype.getLabelSettingsOptions = function(enumeration, labelSettings, series, showAll) {
                    return {
                        enumeration: enumeration,
                        dataLabelsSettings: labelSettings,
                        show: !0,
                        displayUnits: !ColumnChart.isStacked100(this.chartType),
                        precision: !0,
                        selector: series && series.identity ? series.identity.getSelector() : null,
                        showAll: showAll,
                        fontSize: !0
                    };
                }, ColumnChart.prototype.enumerateDataPoints = function(enumeration) {
                    var data = this.data;
                    if (data) {
                        var seriesCount = data.series.length;
                        if (0 !== seriesCount) if (data.hasDynamicSeries || seriesCount > 1 || !data.categoryMetadata) for (var i = 0; seriesCount > i; i++) {
                            var series = data.series[i];
                            enumeration.pushInstance({
                                objectName: "dataPoint",
                                displayName: series.displayName,
                                selector: visuals.ColorHelper.normalizeSelector(series.identity.getSelector()),
                                properties: {
                                    fill: {
                                        solid: {
                                            color: series.color
                                        }
                                    }
                                }
                            });
                        } else {
                            var singleSeriesData = data.series[0].data, categoryFormatter = data.categoryFormatter;
                            if (enumeration.pushInstance({
                                objectName: "dataPoint",
                                selector: null,
                                properties: {
                                    defaultColor: {
                                        solid: {
                                            color: data.defaultDataPointColor || this.colors.getColorByIndex(0).value
                                        }
                                    }
                                }
                            }).pushInstance({
                                objectName: "dataPoint",
                                selector: null,
                                properties: {
                                    showAllDataPoints: !!data.showAllDataPoints
                                }
                            }), data.showAllDataPoints) for (var i = 0; i < singleSeriesData.length; i++) {
                                var singleSeriesDataPoints = singleSeriesData[i], categoryValue = data.categories[i];
                                enumeration.pushInstance({
                                    objectName: "dataPoint",
                                    displayName: categoryFormatter ? categoryFormatter.format(categoryValue) : categoryValue,
                                    selector: visuals.ColorHelper.normalizeSelector(singleSeriesDataPoints.identity.getSelector(), !0),
                                    properties: {
                                        fill: {
                                            solid: {
                                                color: singleSeriesDataPoints.color
                                            }
                                        }
                                    }
                                });
                            }
                        }
                    }
                }, ColumnChart.prototype.calculateAxesProperties = function(options) {
                    var data = this.data;
                    this.currentViewport = options.viewport;
                    var margin = this.margin = options.margin, origCatgSize = data && data.categories ? data.categories.length : 0, chartLayout = data ? this.getCategoryLayout(origCatgSize, options) : {
                        categoryCount: 0,
                        categoryThickness: visuals.CartesianChart.MinOrdinalRectThickness,
                        outerPaddingRatio: visuals.CartesianChart.OuterPaddingRatio,
                        isScalar: !1
                    };
                    if (this.categoryAxisType = chartLayout.isScalar ? visuals.axisType.scalar : null, 
                    data && !chartLayout.isScalar && !this.isScrollable && options.trimOrdinalDataOnOverflow) {
                        var catgSize = Math.min(origCatgSize, chartLayout.categoryCount);
                        catgSize !== origCatgSize && (data = powerbi.Prototype.inherit(data), data.series = ColumnChart.sliceSeries(data.series, catgSize), 
                        data.categories = data.categories.slice(0, catgSize));
                    }
                    this.columnChart.setData(data);
                    var preferredPlotArea = this.getPreferredPlotArea(chartLayout.isScalar, chartLayout.categoryCount, chartLayout.categoryThickness), is100Pct = ColumnChart.isStacked100(this.chartType), chartContext = {
                        height: preferredPlotArea.height,
                        width: preferredPlotArea.width,
                        duration: 0,
                        hostService: this.hostService,
                        unclippedGraphicsContext: this.unclippedGraphicsContext,
                        mainGraphicsContext: this.mainGraphicsContext,
                        margin: this.margin,
                        layout: chartLayout,
                        animator: this.animator,
                        interactivityService: this.interactivityService,
                        viewportHeight: this.currentViewport.height - (margin.top + margin.bottom),
                        viewportWidth: this.currentViewport.width - (margin.left + margin.right),
                        is100Pct: is100Pct,
                        isComboChart: this.isComboChart
                    };
                    this.ApplyInteractivity(chartContext), this.columnChart.setupVisualProps(chartContext);
                    var ensureXDomain, ensureYDomain, isBarChart = ColumnChart.isBar(this.chartType);
                    if (isBarChart) {
                        var temp = options.forcedXDomain;
                        options.forcedXDomain = options.forcedYDomain, options.forcedYDomain = temp, ensureXDomain = options.ensureYDomain;
                    } else ensureYDomain = options.ensureYDomain;
                    return this.xAxisProperties = this.columnChart.setXScale(is100Pct, options.forcedTickCount, options.forcedXDomain, isBarChart ? options.valueAxisScaleType : options.categoryAxisScaleType, isBarChart ? options.valueAxisDisplayUnits : options.categoryAxisDisplayUnits, isBarChart ? options.valueAxisPrecision : options.categoryAxisPrecision, ensureXDomain), 
                    this.yAxisProperties = this.columnChart.setYScale(is100Pct, options.forcedTickCount, options.forcedYDomain, isBarChart ? options.categoryAxisScaleType : options.valueAxisScaleType, isBarChart ? options.categoryAxisDisplayUnits : options.valueAxisDisplayUnits, isBarChart ? options.categoryAxisPrecision : options.valueAxisPrecision, ensureYDomain), 
                    options.showCategoryAxisLabel && this.xAxisProperties.isCategoryAxis || options.showValueAxisLabel && !this.xAxisProperties.isCategoryAxis ? this.xAxisProperties.axisLabel = data.axesLabels.x : this.xAxisProperties.axisLabel = null, 
                    options.showValueAxisLabel && !this.yAxisProperties.isCategoryAxis || options.showCategoryAxisLabel && this.yAxisProperties.isCategoryAxis ? this.yAxisProperties.axisLabel = data.axesLabels.y : this.yAxisProperties.axisLabel = null, 
                    [ this.xAxisProperties, this.yAxisProperties ];
                }, ColumnChart.prototype.getPreferredPlotArea = function(isScalar, categoryCount, categoryThickness) {
                    var plotArea = {
                        height: this.currentViewport.height - this.margin.top - this.margin.bottom,
                        width: this.currentViewport.width - this.margin.left - this.margin.right
                    };
                    if (this.isScrollable && !isScalar) {
                        var preferredCategorySpan = visuals.CartesianChart.getPreferredCategorySpan(categoryCount, categoryThickness);
                        ColumnChart.isBar(this.chartType) ? plotArea.height = Math.max(preferredCategorySpan, plotArea.height) : plotArea.width = Math.max(preferredCategorySpan, plotArea.width);
                    }
                    return plotArea;
                }, ColumnChart.prototype.ApplyInteractivity = function(chartContext) {
                    var _this = this, interactivity = this.interactivity;
                    if (interactivity && (interactivity.dragDataPoint && (chartContext.onDragStart = function(datum) {
                        datum.identity && _this.hostService.onDragStart({
                            event: d3.event,
                            data: {
                                data: datum.identity.getSelector()
                            }
                        });
                    }), interactivity.isInteractiveLegend)) {
                        var dragMove = function() {
                            var mousePoint = d3.mouse(_this.mainGraphicsContext[0][0]), x = mousePoint[0], y = mousePoint[1], index = _this.columnChart.getClosestColumnIndex(x, y);
                            _this.selectColumn(index);
                        }, ColumnChartSvg = ColumnChart.getInteractiveColumnChartDomElement(this.element);
                        this.svg.on("click", dragMove), d3.select(ColumnChartSvg).on("click", dragMove).style("touch-action", "none");
                        var drag = d3.behavior.drag().origin(Object).on("drag", dragMove);
                        this.svg.call(drag), d3.select(ColumnChartSvg).call(drag);
                    }
                }, ColumnChart.prototype.selectColumn = function(indexOfColumnSelected, force) {
                    if (void 0 === force && (force = !1), force || this.lastInteractiveSelectedColumnIndex !== indexOfColumnSelected) {
                        var legendData = this.createInteractiveLegendDataPoints(indexOfColumnSelected), legendDataPoints = legendData.dataPoints;
                        this.cartesianVisualHost.updateLegend(legendData), legendDataPoints.length > 0 && this.columnChart.selectColumn(indexOfColumnSelected, this.lastInteractiveSelectedColumnIndex), 
                        this.lastInteractiveSelectedColumnIndex = indexOfColumnSelected;
                    }
                }, ColumnChart.prototype.createInteractiveLegendDataPoints = function(columnIndex) {
                    var data = this.data;
                    if (!data || _.isEmpty(data.series)) return {
                        dataPoints: []
                    };
                    for (var formatStringProp = visuals.columnChartProps.general.formatString, legendDataPoints = [], category = data.categories && data.categories[columnIndex], allSeries = data.series, dataPoints = data.legendData && data.legendData.dataPoints, converterStrategy = new ColumnChartConverterHelper(this.dataView), i = 0, len = allSeries.length; len > i; i++) {
                        var measure = converterStrategy.getValueBySeriesAndCategory(i, columnIndex), valueMetadata = data.valuesMetadata[i], formattedLabel = visuals.converterHelper.getFormattedLegendLabel(valueMetadata, this.dataView.categorical.values, formatStringProp), dataPointColor = void 0;
                        if (1 === allSeries.length) {
                            var series = allSeries[0];
                            dataPointColor = series.data.length > columnIndex && series.data[columnIndex].color;
                        } else dataPointColor = dataPoints.length > i && dataPoints[i].color;
                        legendDataPoints.push({
                            color: dataPointColor,
                            icon: visuals.LegendIcon.Box,
                            label: formattedLabel,
                            category: data.categoryFormatter ? data.categoryFormatter.format(category) : category,
                            measure: visuals.valueFormatter.format(measure, visuals.valueFormatter.getFormatString(valueMetadata, formatStringProp)),
                            identity: visuals.SelectionId.createNull(),
                            selected: !1
                        });
                    }
                    return {
                        dataPoints: legendDataPoints
                    };
                }, ColumnChart.prototype.overrideXScale = function(xProperties) {
                    this.xAxisProperties = xProperties;
                }, ColumnChart.prototype.render = function(suppressAnimations) {
                    var columnChartDrawInfo = this.columnChart.drawColumns(!suppressAnimations), data = this.data, margin = this.margin, viewport = this.currentViewport, height = viewport.height - (margin.top + margin.bottom), width = viewport.width - (margin.left + margin.right);
                    this.mainGraphicsContext.attr("height", height).attr("width", width), this.tooltipsEnabled && visuals.TooltipManager.addTooltip(columnChartDrawInfo.eventGroup, function(tooltipEvent) {
                        return tooltipEvent.data.tooltipInfo;
                    });
                    var allDataPoints = [], behaviorOptions = void 0;
                    if (this.interactivityService) {
                        for (var i = 0, ilen = data.series.length; ilen > i; i++) allDataPoints = allDataPoints.concat(data.series[i].data);
                        behaviorOptions = {
                            datapoints: allDataPoints,
                            eventGroup: columnChartDrawInfo.eventGroup,
                            bars: columnChartDrawInfo.shapesSelection,
                            hasHighlights: data.hasHighlights,
                            mainGraphicsContext: this.mainGraphicsContext,
                            viewport: columnChartDrawInfo.viewport,
                            axisOptions: columnChartDrawInfo.axisOptions,
                            showLabel: data.labelSettings.show
                        };
                    }
                    return this.interactivity && this.interactivity.isInteractiveLegend && this.data.series.length > 0 && this.selectColumn(visuals.CartesianHelper.findMaxCategoryIndex(this.data.series), !0), 
                    visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options), {
                        dataPoints: allDataPoints,
                        behaviorOptions: behaviorOptions,
                        labelDataPoints: columnChartDrawInfo.labelDataPoints,
                        labelsAreNumeric: !0
                    };
                }, ColumnChart.prototype.onClearSelection = function() {
                    this.interactivityService && this.interactivityService.clearSelection();
                }, ColumnChart.prototype.getVisualCategoryAxisIsScalar = function() {
                    return this.data ? this.data.scalarCategoryAxis : !1;
                }, ColumnChart.prototype.getSupportedCategoryAxisType = function() {
                    var metaDataColumn = this.data ? this.data.categoryMetadata : void 0, valueType = visuals.AxisHelper.getCategoryValueType(metaDataColumn), isOrdinal = visuals.AxisHelper.isOrdinal(valueType);
                    return isOrdinal ? visuals.axisType.categorical : visuals.axisType.both;
                }, ColumnChart.prototype.setFilteredData = function(startIndex, endIndex) {
                    var data = powerbi.Prototype.inherit(this.data);
                    return data.series = ColumnChart.sliceSeries(data.series, endIndex, startIndex), 
                    data.categories = data.categories.slice(startIndex, endIndex), this.columnChart.setData(data), 
                    data;
                }, ColumnChart.getLabelFill = function(labelColor, isInside, isCombo) {
                    return labelColor ? labelColor : isInside && !isCombo ? visuals.NewDataLabelUtils.defaultInsideLabelColor : visuals.NewDataLabelUtils.defaultLabelColor;
                }, ColumnChart.prototype.supportsTrendLine = function() {
                    var dataView = this.dataView, reader = powerbi.data.createIDataViewCategoricalReader(dataView), isScalar = this.data ? this.data.scalarCategoryAxis : !1;
                    return this.chartType === ColumnChartType.clusteredColumn && isScalar && reader.hasValues("Y");
                }, ColumnChart.prototype.isStacked = function() {
                    return ColumnChart.isStacked(this.chartType);
                }, ColumnChart.isBar = function(chartType) {
                    return EnumExtensions.hasFlag(chartType, flagBar);
                }, ColumnChart.isColumn = function(chartType) {
                    return EnumExtensions.hasFlag(chartType, flagColumn);
                }, ColumnChart.isClustered = function(chartType) {
                    return EnumExtensions.hasFlag(chartType, flagClustered);
                }, ColumnChart.isStacked = function(chartType) {
                    return EnumExtensions.hasFlag(chartType, flagStacked);
                }, ColumnChart.isStacked100 = function(chartType) {
                    return EnumExtensions.hasFlag(chartType, flagStacked100);
                }, ColumnChart.ColumnChartClassName = "columnChart", ColumnChart.clusteredValidLabelPositions = [ 16, 4, 1, 2 ], 
                ColumnChart.stackedValidLabelPositions = [ 1, 4, 2 ], ColumnChart.SeriesClasses = jsCommon.CssConstants.createClassAndSelector("series"), 
                ColumnChart;
            }();
            visuals.ColumnChart = ColumnChart;
            var ColumnChartConverterHelper = function() {
                function ColumnChartConverterHelper(dataView) {
                    this.dataView = dataView && dataView.categorical, this.reader = powerbi.data.createIDataViewCategoricalReader(dataView);
                }
                return ColumnChartConverterHelper.prototype.getLegend = function(colors, defaultLegendLabelColor, defaultColor) {
                    var legend = [], seriesSources = [], seriesObjects = [], grouped = !1, reader = this.reader, colorHelper = new visuals.ColorHelper(colors, visuals.columnChartProps.dataPoint.fill, defaultColor), legendTitle = void 0;
                    if (this.dataView && this.dataView.values) {
                        for (var allValues = this.dataView.values, valueGroups = allValues.grouped(), hasDynamicSeries = !(!allValues || !allValues.source), formatStringProp = visuals.columnChartProps.general.formatString, valueGroupsIndex = 0, valueGroupsLen = valueGroups.length; valueGroupsLen > valueGroupsIndex; valueGroupsIndex++) for (var valueGroup = valueGroups[valueGroupsIndex], valueGroupObjects = valueGroup.objects, values = valueGroup.values, valueIndex = 0, valuesLen = values.length; valuesLen > valueIndex; valueIndex++) {
                            var series = values[valueIndex], source = series.source;
                            if (!DataRoleHelper.hasRole(source, "Gradient") && !DataRoleHelper.hasRole(source, "Tooltips") || DataRoleHelper.hasRole(source, "Y")) {
                                seriesSources.push(source), seriesObjects.push(series.objects);
                                var selectionIdBuilder = new visuals.SelectionIdBuilder();
                                selectionIdBuilder = selectionIdBuilder.withMeasure(this.getMeasureNameByIndex(valueIndex)), 
                                reader.hasDynamicSeries() && (selectionIdBuilder = selectionIdBuilder.withSeries(reader.getSeriesValueColumns(), reader.getSeriesValueColumnGroup(valueGroupsIndex)));
                                var selectionId = selectionIdBuilder.createSelectionId(), label = visuals.converterHelper.getFormattedLegendLabel(source, allValues, formatStringProp), color = hasDynamicSeries ? colorHelper.getColorForSeriesValue(valueGroupObjects, allValues.identityFields, source.groupName) : colorHelper.getColorForMeasure(source.objects, source.queryName);
                                legend.push({
                                    icon: visuals.LegendIcon.Box,
                                    color: color,
                                    label: label,
                                    identity: selectionId,
                                    selected: !1
                                }), series.identity && void 0 !== source.groupName && (grouped = !0);
                            }
                        }
                        var dvValues = this.dataView.values;
                        legendTitle = dvValues && dvValues.source ? dvValues.source.displayName : "";
                    }
                    var legendData = {
                        title: legendTitle,
                        dataPoints: legend,
                        grouped: grouped,
                        labelColor: defaultLegendLabelColor
                    };
                    return {
                        legend: legendData,
                        seriesSources: seriesSources,
                        seriesObjects: seriesObjects
                    };
                }, ColumnChartConverterHelper.prototype.getValueBySeriesAndCategory = function(series, category) {
                    return this.reader.getValue("Y", category, series);
                }, ColumnChartConverterHelper.prototype.getMeasureNameByIndex = function(index) {
                    return this.dataView.values[index].source.queryName;
                }, ColumnChartConverterHelper.prototype.hasHighlightValues = function(series) {
                    var column = this.dataView && this.dataView.values ? this.dataView.values[series] : void 0;
                    return column && !!column.highlights;
                }, ColumnChartConverterHelper.prototype.getHighlightBySeriesAndCategory = function(series, category) {
                    return this.dataView.values[series].highlights[category];
                }, ColumnChartConverterHelper;
            }();
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var PixelConverter = jsCommon.PixelConverter, ClusteredColumnChartStrategy = function() {
                function ClusteredColumnChartStrategy() {}
                return ClusteredColumnChartStrategy.prototype.setupVisualProps = function(columnChartProps) {
                    this.graphicsContext = columnChartProps, this.margin = columnChartProps.margin, 
                    this.width = this.graphicsContext.width, this.height = this.graphicsContext.height, 
                    this.categoryLayout = columnChartProps.layout, this.animator = columnChartProps.animator, 
                    this.interactivityService = columnChartProps.interactivityService, this.viewportHeight = columnChartProps.viewportHeight, 
                    this.viewportWidth = columnChartProps.viewportWidth, this.isComboChart = columnChartProps.isComboChart;
                }, ClusteredColumnChartStrategy.prototype.setData = function(data) {
                    this.data = data;
                }, ClusteredColumnChartStrategy.prototype.setXScale = function(is100Pct, forcedTickCount, forcedXDomain, axisScaleType, axisDisplayUnits, axisPrecision, ensureXDomain) {
                    var forcedXMin, forcedXMax, width = this.width;
                    forcedXDomain && 2 === forcedXDomain.length && (forcedXMin = forcedXDomain[0], forcedXMax = forcedXDomain[1]);
                    var props = this.xProps = visuals.ColumnUtil.getCategoryAxis(this.data, width, this.categoryLayout, !1, forcedXMin, forcedXMax, axisScaleType, axisDisplayUnits, axisPrecision, ensureXDomain), seriesLength = this.data.series.length, columnWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio) / seriesLength;
                    return this.seriesOffsetScale = d3.scale.ordinal().domain(this.data.series.map(function(s) {
                        return s.index;
                    })).rangeBands([ 0, seriesLength * columnWidth ]), props;
                }, ClusteredColumnChartStrategy.prototype.setYScale = function(is100Pct, forcedTickCount, forcedYDomain, axisScaleType, axisDisplayUnits, axisPrecision, ensureYDomain) {
                    var height = this.viewportHeight, valueDomain = visuals.AxisHelper.createValueDomain(this.data.series, !0) || visuals.emptyDomain, combinedDomain = visuals.AxisHelper.combineDomain(forcedYDomain, valueDomain, ensureYDomain), shouldClamp = visuals.AxisHelper.scaleShouldClamp(combinedDomain, valueDomain);
                    return this.yProps = visuals.AxisHelper.createAxis({
                        pixelSpan: height,
                        dataDomain: combinedDomain,
                        metaDataColumn: this.data.valuesMetadata[0],
                        formatString: visuals.valueFormatter.getFormatString(this.data.valuesMetadata[0], visuals.columnChartProps.general.formatString),
                        outerPadding: 0,
                        isScalar: !0,
                        isVertical: !0,
                        forcedTickCount: forcedTickCount,
                        useTickIntervalForDisplayUnits: !0,
                        isCategoryAxis: !1,
                        scaleType: axisScaleType,
                        axisDisplayUnits: axisDisplayUnits,
                        axisPrecision: axisPrecision,
                        shouldClamp: shouldClamp
                    }), this.yProps;
                }, ClusteredColumnChartStrategy.prototype.drawColumns = function(useAnimation) {
                    var data = this.data;
                    this.columnsCenters = null;
                    var categoryWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio), columnWidth = categoryWidth / data.series.length, axisOptions = {
                        columnWidth: columnWidth,
                        categoryWidth: categoryWidth,
                        xScale: this.xProps.scale,
                        yScale: this.yProps.scale,
                        seriesOffsetScale: this.seriesOffsetScale,
                        isScalar: this.categoryLayout.isScalar,
                        margin: this.margin
                    }, clusteredColumnLayout = this.layout = ClusteredColumnChartStrategy.getLayout(data, axisOptions), dataLabelSettings = data.labelSettings, labelDataPoints = [];
                    dataLabelSettings && dataLabelSettings.show && (labelDataPoints = this.createLabelDataPoints());
                    var result, shapes, series = visuals.ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);
                    return this.animator && useAnimation && (result = this.animator.animate({
                        viewModel: data,
                        series: series,
                        layout: clusteredColumnLayout,
                        itemCS: ClusteredColumnChartStrategy.classes.item,
                        interactivityService: this.interactivityService,
                        mainGraphicsContext: this.graphicsContext.mainGraphicsContext,
                        viewPort: {
                            height: this.height,
                            width: this.width
                        }
                    }), shapes = result.shapes), this.animator && useAnimation && !result.failed || (shapes = visuals.ColumnUtil.drawDefaultShapes(data, series, clusteredColumnLayout, ClusteredColumnChartStrategy.classes.item, !this.animator, this.interactivityService && this.interactivityService.hasSelection())), 
                    visuals.ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart), 
                    {
                        eventGroup: this.graphicsContext.mainGraphicsContext,
                        shapesSelection: shapes,
                        viewport: {
                            height: this.height,
                            width: this.width
                        },
                        axisOptions: axisOptions,
                        labelDataPoints: labelDataPoints
                    };
                }, ClusteredColumnChartStrategy.prototype.selectColumn = function(selectedColumnIndex, lastSelectedColumnIndex) {
                    visuals.ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, ClusteredColumnChartStrategy.classes.item.selector, selectedColumnIndex, lastSelectedColumnIndex), 
                    this.moveHandle(selectedColumnIndex);
                }, ClusteredColumnChartStrategy.prototype.getClosestColumnIndex = function(x, y) {
                    return visuals.ColumnUtil.getClosestColumnIndex(x, this.getColumnsCenters());
                }, ClusteredColumnChartStrategy.prototype.getColumnsCenters = function() {
                    var _this = this;
                    if (!this.columnsCenters) {
                        var categoryWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                        if (this.data.series.length > 0) {
                            var xScaleOffset_1 = 0;
                            this.categoryLayout.isScalar || (xScaleOffset_1 = categoryWidth / 2);
                            var firstSeries = this.data.series[0];
                            this.columnsCenters = firstSeries.data.map(function(d) {
                                return _this.xProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + xScaleOffset_1;
                            });
                        }
                    }
                    return this.columnsCenters;
                }, ClusteredColumnChartStrategy.prototype.moveHandle = function(selectedColumnIndex) {
                    var columnCenters = this.getColumnsCenters(), x = columnCenters[selectedColumnIndex], hoverLine = d3.select(".interactive-hover-line");
                    if (hoverLine.empty() || this.columnSelectionLineHandle || (this.columnSelectionLineHandle = d3.select(hoverLine.node().parentNode)), 
                    this.columnSelectionLineHandle) {
                        var handle = this.columnSelectionLineHandle;
                        handle.select("line").attr({
                            x1: x,
                            x2: x
                        }), handle.select("circle").attr({
                            cx: x
                        });
                    } else {
                        var handle = this.columnSelectionLineHandle = this.graphicsContext.unclippedGraphicsContext.append("g");
                        handle.append("line").classed("interactive-hover-line", !0).attr({
                            x1: x,
                            x2: x,
                            y1: 0,
                            y2: this.height
                        }), handle.append("circle").attr({
                            cx: x,
                            cy: this.height,
                            r: "6px"
                        }).classed("drag-handle", !0);
                    }
                }, ClusteredColumnChartStrategy.getLayout = function(data, axisOptions) {
                    var columnWidth = axisOptions.columnWidth, halfColumnWidth = .5 * columnWidth, quarterColumnWidth = halfColumnWidth / 2, isScalar = axisOptions.isScalar, xScale = axisOptions.xScale, yScale = axisOptions.yScale, seriesOffsetScale = axisOptions.seriesOffsetScale, scaledY0 = yScale(0), xScaleOffset = 0;
                    return isScalar && (xScaleOffset = axisOptions.categoryWidth / 2), {
                        shapeLayout: {
                            width: function(d) {
                                return d.drawThinner ? halfColumnWidth : columnWidth;
                            },
                            x: function(d) {
                                return xScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - xScaleOffset + (d.drawThinner ? quarterColumnWidth : 0);
                            },
                            y: function(d) {
                                return scaledY0 + visuals.AxisHelper.diffScaled(yScale, Math.max(0, d.value), 0);
                            },
                            height: function(d) {
                                return Math.abs(visuals.AxisHelper.diffScaled(yScale, 0, d.value));
                            }
                        },
                        shapeLayoutWithoutHighlights: {
                            width: function(d) {
                                return columnWidth;
                            },
                            x: function(d) {
                                return xScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - xScaleOffset;
                            },
                            y: function(d) {
                                return scaledY0 + visuals.AxisHelper.diffScaled(yScale, Math.max(0, d.originalValue), 0);
                            },
                            height: function(d) {
                                return Math.abs(visuals.AxisHelper.diffScaled(yScale, 0, d.originalValue));
                            }
                        },
                        zeroShapeLayout: {
                            width: function(d) {
                                return d.drawThinner ? halfColumnWidth : columnWidth;
                            },
                            x: function(d) {
                                return xScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - xScaleOffset + (d.drawThinner ? quarterColumnWidth : 0);
                            },
                            y: function(d) {
                                return scaledY0;
                            },
                            height: function(d) {
                                return 0;
                            }
                        }
                    };
                }, ClusteredColumnChartStrategy.prototype.createLabelDataPoints = function() {
                    for (var labelDataPoints = [], data = this.data, series = data.series, formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager(), shapeLayout = this.layout.shapeLayout, _i = 0, series_1 = series; _i < series_1.length; _i++) {
                        var currentSeries = series_1[_i], labelSettings = currentSeries.labelSettings ? currentSeries.labelSettings : data.labelSettings;
                        if (labelSettings.show) for (var axisFormatter = visuals.NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yProps.formatter, labelSettings), _a = 0, _b = currentSeries.data; _a < _b.length; _a++) {
                            var dataPoint = _b[_a];
                            if ((!data.hasHighlights || dataPoint.highlight) && null != dataPoint.value) {
                                var parentRect = {
                                    left: shapeLayout.x(dataPoint),
                                    top: shapeLayout.y(dataPoint),
                                    width: shapeLayout.width(dataPoint),
                                    height: shapeLayout.height(dataPoint)
                                }, formatString = dataPoint.labelFormatString, formatter = formattersCache.getOrCreate(formatString, labelSettings, axisFormatter), text = visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(dataPoint.value)), properties = {
                                    text: text,
                                    fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                                    fontSize: PixelConverter.fromPoint(labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt),
                                    fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight
                                }, textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties), textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, !0);
                                labelDataPoints.push({
                                    isPreferred: !0,
                                    text: text,
                                    textSize: {
                                        width: textWidth,
                                        height: textHeight
                                    },
                                    outsideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, !1, this.isComboChart),
                                    insideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, !0, this.isComboChart),
                                    parentType: 1,
                                    parentShape: {
                                        rect: parentRect,
                                        orientation: dataPoint.value >= 0 ? 1 : 2,
                                        validPositions: visuals.ColumnChart.clusteredValidLabelPositions
                                    },
                                    identity: dataPoint.identity,
                                    fontSize: labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt
                                });
                            }
                        }
                    }
                    return labelDataPoints;
                }, ClusteredColumnChartStrategy.classes = {
                    item: {
                        "class": "column",
                        selector: ".column"
                    }
                }, ClusteredColumnChartStrategy;
            }();
            visuals.ClusteredColumnChartStrategy = ClusteredColumnChartStrategy;
            var ClusteredBarChartStrategy = function() {
                function ClusteredBarChartStrategy() {}
                return ClusteredBarChartStrategy.prototype.setupVisualProps = function(barChartProps) {
                    this.graphicsContext = barChartProps, this.margin = barChartProps.margin, this.width = this.graphicsContext.width, 
                    this.height = this.graphicsContext.height, this.categoryLayout = barChartProps.layout, 
                    this.animator = barChartProps.animator, this.interactivityService = barChartProps.interactivityService, 
                    this.viewportHeight = barChartProps.viewportHeight, this.viewportWidth = barChartProps.viewportWidth, 
                    this.isComboChart = barChartProps.isComboChart;
                }, ClusteredBarChartStrategy.prototype.setData = function(data) {
                    this.data = data;
                }, ClusteredBarChartStrategy.prototype.setYScale = function(is100Pct, forcedTickCount, forcedYDomain, axisScaleType, axisDisplayUnits, axisPrecision, ensureYDomain) {
                    var forcedYMin, forcedYMax, height = this.height;
                    forcedYDomain && 2 === forcedYDomain.length && (forcedYMin = forcedYDomain[0], forcedYMax = forcedYDomain[1]);
                    var props = this.yProps = visuals.ColumnUtil.getCategoryAxis(this.data, height, this.categoryLayout, !0, forcedYMin, forcedYMax, axisScaleType, axisDisplayUnits, axisPrecision, ensureYDomain), seriesLength = this.data.series.length, columnWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio) / seriesLength;
                    return this.seriesOffsetScale = d3.scale.ordinal().domain(this.data.series.map(function(s) {
                        return s.index;
                    })).rangeBands([ 0, seriesLength * columnWidth ]), props;
                }, ClusteredBarChartStrategy.prototype.setXScale = function(is100Pct, forcedTickCount, forcedXDomain, axisScaleType, axisDisplayUnits, axisPrecision, ensureXDomain) {
                    var width = this.width, valueDomain = visuals.AxisHelper.createValueDomain(this.data.series, !0) || visuals.emptyDomain, combinedDomain = visuals.AxisHelper.combineDomain(forcedXDomain, valueDomain, ensureXDomain), shouldClamp = visuals.AxisHelper.scaleShouldClamp(combinedDomain, valueDomain);
                    return this.xProps = visuals.AxisHelper.createAxis({
                        pixelSpan: width,
                        dataDomain: combinedDomain,
                        metaDataColumn: this.data.valuesMetadata[0],
                        formatString: visuals.valueFormatter.getFormatString(this.data.valuesMetadata[0], visuals.columnChartProps.general.formatString),
                        outerPadding: 0,
                        isScalar: !0,
                        isVertical: !1,
                        forcedTickCount: forcedTickCount,
                        useTickIntervalForDisplayUnits: !0,
                        isCategoryAxis: !1,
                        scaleType: axisScaleType,
                        axisDisplayUnits: axisDisplayUnits,
                        axisPrecision: axisPrecision,
                        shouldClamp: shouldClamp
                    }), this.xProps.axis.tickSize(-this.viewportHeight, 0), this.xProps;
                }, ClusteredBarChartStrategy.prototype.drawColumns = function(useAnimation) {
                    var data = this.data;
                    this.barsCenters = null;
                    var categoryWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio), columnWidth = categoryWidth / data.series.length, axisOptions = {
                        columnWidth: columnWidth,
                        categoryWidth: categoryWidth,
                        xScale: this.xProps.scale,
                        yScale: this.yProps.scale,
                        seriesOffsetScale: this.seriesOffsetScale,
                        isScalar: this.categoryLayout.isScalar,
                        margin: this.margin
                    }, clusteredBarLayout = this.layout = ClusteredBarChartStrategy.getLayout(data, axisOptions), dataLabelSettings = data.labelSettings, labelDataPoints = [];
                    dataLabelSettings && dataLabelSettings.show && (labelDataPoints = this.createLabelDataPoints());
                    var result, shapes, series = visuals.ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);
                    return this.animator && useAnimation && (result = this.animator.animate({
                        viewModel: data,
                        series: series,
                        layout: clusteredBarLayout,
                        itemCS: ClusteredBarChartStrategy.classes.item,
                        interactivityService: this.interactivityService,
                        mainGraphicsContext: this.graphicsContext.mainGraphicsContext,
                        viewPort: {
                            height: this.height,
                            width: this.width
                        }
                    }), shapes = result.shapes), this.animator && useAnimation && !result.failed || (shapes = visuals.ColumnUtil.drawDefaultShapes(data, series, clusteredBarLayout, ClusteredBarChartStrategy.classes.item, !this.animator, this.interactivityService && this.interactivityService.hasSelection())), 
                    visuals.ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart), 
                    {
                        eventGroup: this.graphicsContext.mainGraphicsContext,
                        shapesSelection: shapes,
                        viewport: {
                            height: this.height,
                            width: this.width
                        },
                        axisOptions: axisOptions,
                        labelDataPoints: labelDataPoints
                    };
                }, ClusteredBarChartStrategy.prototype.selectColumn = function(selectedColumnIndex, lastSelectedColumnIndex) {
                    visuals.ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, ClusteredBarChartStrategy.classes.item.selector, selectedColumnIndex, lastSelectedColumnIndex), 
                    this.moveHandle(selectedColumnIndex);
                }, ClusteredBarChartStrategy.prototype.getClosestColumnIndex = function(x, y) {
                    return visuals.ColumnUtil.getClosestColumnIndex(y, this.getBarsCenters());
                }, ClusteredBarChartStrategy.prototype.getBarsCenters = function() {
                    var _this = this;
                    if (!this.barsCenters) {
                        var barWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                        if (this.data.series.length > 0) {
                            var yScaleOffset_1 = 0;
                            this.categoryLayout.isScalar || (yScaleOffset_1 = barWidth / 2);
                            var firstSeries = this.data.series[0];
                            this.barsCenters = firstSeries.data.map(function(d) {
                                return _this.yProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + yScaleOffset_1;
                            });
                        }
                    }
                    return this.barsCenters;
                }, ClusteredBarChartStrategy.prototype.moveHandle = function(selectedColumnIndex) {
                    var barCenters = this.getBarsCenters(), y = barCenters[selectedColumnIndex], hoverLine = d3.select(".interactive-hover-line");
                    if (hoverLine.empty() || this.columnSelectionLineHandle || (this.columnSelectionLineHandle = d3.select(hoverLine.node().parentNode)), 
                    this.columnSelectionLineHandle) {
                        var handle = this.columnSelectionLineHandle;
                        handle.select("line").attr({
                            y1: y,
                            y2: y
                        }), handle.select("circle").attr({
                            cy: y
                        });
                    } else {
                        var handle = this.columnSelectionLineHandle = this.graphicsContext.unclippedGraphicsContext.append("g");
                        handle.append("line").classed("interactive-hover-line", !0).attr({
                            x1: 0,
                            x2: this.width,
                            y1: y,
                            y2: y
                        }), handle.append("circle").attr({
                            cx: 0,
                            cy: y,
                            r: "6px"
                        }).classed("drag-handle", !0);
                    }
                }, ClusteredBarChartStrategy.getLayout = function(data, axisOptions) {
                    var columnWidth = axisOptions.columnWidth, halfColumnWidth = .5 * columnWidth, quarterColumnWidth = halfColumnWidth / 2, isScalar = axisOptions.isScalar, xScale = axisOptions.xScale, yScale = axisOptions.yScale, seriesOffsetScale = axisOptions.seriesOffsetScale, scaledX0 = xScale(0), yScaleOffset = 0;
                    return isScalar && (yScaleOffset = axisOptions.categoryWidth / 2), {
                        shapeLayout: {
                            width: function(d) {
                                return Math.abs(visuals.AxisHelper.diffScaled(xScale, 0, d.value));
                            },
                            x: function(d) {
                                return scaledX0 + visuals.AxisHelper.diffScaled(xScale, Math.min(0, d.value), 0);
                            },
                            y: function(d) {
                                return yScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - yScaleOffset + (d.drawThinner ? quarterColumnWidth : 0);
                            },
                            height: function(d) {
                                return d.drawThinner ? halfColumnWidth : columnWidth;
                            }
                        },
                        shapeLayoutWithoutHighlights: {
                            width: function(d) {
                                return Math.abs(visuals.AxisHelper.diffScaled(xScale, 0, d.originalValue));
                            },
                            x: function(d) {
                                return scaledX0 + visuals.AxisHelper.diffScaled(xScale, Math.min(0, d.originalValue), 0);
                            },
                            y: function(d) {
                                return yScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - yScaleOffset;
                            },
                            height: function(d) {
                                return columnWidth;
                            }
                        },
                        zeroShapeLayout: {
                            width: function(d) {
                                return 0;
                            },
                            x: function(d) {
                                return scaledX0 + visuals.AxisHelper.diffScaled(xScale, Math.min(0, d.value), 0);
                            },
                            y: function(d) {
                                return yScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - yScaleOffset + (d.drawThinner ? quarterColumnWidth : 0);
                            },
                            height: function(d) {
                                return d.drawThinner ? halfColumnWidth : columnWidth;
                            }
                        }
                    };
                }, ClusteredBarChartStrategy.prototype.createLabelDataPoints = function() {
                    for (var labelDataPoints = [], data = this.data, series = data.series, formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager(), shapeLayout = this.layout.shapeLayout, _i = 0, series_2 = series; _i < series_2.length; _i++) {
                        var currentSeries = series_2[_i], labelSettings = currentSeries.labelSettings ? currentSeries.labelSettings : data.labelSettings;
                        if (labelSettings.show) for (var axisFormatter = visuals.NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yProps.formatter, labelSettings), _a = 0, _b = currentSeries.data; _a < _b.length; _a++) {
                            var dataPoint = _b[_a];
                            if ((!data.hasHighlights || dataPoint.highlight) && null != dataPoint.value) {
                                var formatString = dataPoint.labelFormatString, formatter = formattersCache.getOrCreate(formatString, labelSettings, axisFormatter), text = visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(dataPoint.value)), properties = {
                                    text: text,
                                    fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                                    fontSize: PixelConverter.fromPoint(labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt),
                                    fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight
                                }, textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties), textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, !0), parentRect = {
                                    left: shapeLayout.x(dataPoint),
                                    top: shapeLayout.y(dataPoint),
                                    width: shapeLayout.width(dataPoint),
                                    height: shapeLayout.height(dataPoint)
                                };
                                labelDataPoints.push({
                                    isPreferred: !0,
                                    text: text,
                                    textSize: {
                                        width: textWidth,
                                        height: textHeight
                                    },
                                    outsideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, !1, this.isComboChart),
                                    insideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, !0, this.isComboChart),
                                    parentType: 1,
                                    parentShape: {
                                        rect: parentRect,
                                        orientation: dataPoint.value >= 0 ? 3 : 4,
                                        validPositions: visuals.ColumnChart.clusteredValidLabelPositions
                                    },
                                    identity: dataPoint.identity,
                                    fontSize: labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt
                                });
                            }
                        }
                    }
                    return labelDataPoints;
                }, ClusteredBarChartStrategy.classes = {
                    item: {
                        "class": "bar",
                        selector: ".bar"
                    }
                }, ClusteredBarChartStrategy;
            }();
            visuals.ClusteredBarChartStrategy = ClusteredBarChartStrategy;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var PixelConverter = jsCommon.PixelConverter, StackedColumnChartStrategy = function() {
                function StackedColumnChartStrategy() {}
                return StackedColumnChartStrategy.prototype.setupVisualProps = function(columnChartProps) {
                    this.graphicsContext = columnChartProps, this.margin = columnChartProps.margin, 
                    this.width = this.graphicsContext.width, this.height = this.graphicsContext.height, 
                    this.categoryLayout = columnChartProps.layout, this.animator = columnChartProps.animator, 
                    this.interactivityService = columnChartProps.interactivityService, this.viewportHeight = columnChartProps.viewportHeight, 
                    this.viewportWidth = columnChartProps.viewportWidth, this.isComboChart = columnChartProps.isComboChart;
                }, StackedColumnChartStrategy.prototype.setData = function(data) {
                    this.data = data;
                }, StackedColumnChartStrategy.prototype.setXScale = function(is100Pct, forcedTickCount, forcedXDomain, axisScaleType, axisDisplayUnits, axisPrecision, xReferenceLineValue) {
                    var forcedXMin, forcedXMax, width = this.width;
                    forcedXDomain && 2 === forcedXDomain.length && (forcedXMin = forcedXDomain[0], forcedXMax = forcedXDomain[1]);
                    var props = this.xProps = visuals.ColumnUtil.getCategoryAxis(this.data, width, this.categoryLayout, !1, forcedXMin, forcedXMax, axisScaleType, axisDisplayUnits, axisPrecision, xReferenceLineValue);
                    return props;
                }, StackedColumnChartStrategy.prototype.setYScale = function(is100Pct, forcedTickCount, forcedYDomain, axisScaleType, axisDisplayUnits, axisPrecision, y1ReferenceLineValue) {
                    var height = this.viewportHeight, valueDomain = visuals.StackedUtil.calcValueDomain(this.data.series, is100Pct), valueDomainArr = [ valueDomain.min, valueDomain.max ], combinedDomain = visuals.AxisHelper.combineDomain(forcedYDomain, valueDomainArr, y1ReferenceLineValue), shouldClamp = visuals.AxisHelper.scaleShouldClamp(combinedDomain, valueDomainArr), metadataColumn = this.data.valuesMetadata[0], formatString = is100Pct ? this.graphicsContext.hostService.getLocalizedString("Percentage") : visuals.valueFormatter.getFormatString(metadataColumn, visuals.columnChartProps.general.formatString);
                    return this.yProps = visuals.AxisHelper.createAxis({
                        pixelSpan: height,
                        dataDomain: combinedDomain,
                        metaDataColumn: metadataColumn,
                        formatString: formatString,
                        outerPadding: 0,
                        isScalar: !0,
                        isVertical: !0,
                        forcedTickCount: forcedTickCount,
                        useTickIntervalForDisplayUnits: !0,
                        isCategoryAxis: !1,
                        scaleType: axisScaleType,
                        axisDisplayUnits: axisDisplayUnits,
                        axisPrecision: axisPrecision,
                        is100Pct: is100Pct,
                        shouldClamp: shouldClamp
                    }), this.yProps;
                }, StackedColumnChartStrategy.prototype.drawColumns = function(useAnimation) {
                    var data = this.data;
                    this.columnsCenters = null;
                    var axisOptions = {
                        columnWidth: this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio),
                        xScale: this.xProps.scale,
                        yScale: this.yProps.scale,
                        isScalar: this.categoryLayout.isScalar,
                        margin: this.margin
                    }, stackedColumnLayout = this.layout = StackedColumnChartStrategy.getLayout(data, axisOptions), dataLabelSettings = data.labelSettings, labelDataPoints = [];
                    dataLabelSettings && dataLabelSettings.show && (labelDataPoints = this.createLabelDataPoints());
                    var result, shapes, series = visuals.ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);
                    return this.animator && useAnimation && (result = this.animator.animate({
                        viewModel: data,
                        series: series,
                        layout: stackedColumnLayout,
                        itemCS: StackedColumnChartStrategy.classes.item,
                        interactivityService: this.interactivityService,
                        mainGraphicsContext: this.graphicsContext.mainGraphicsContext,
                        viewPort: {
                            height: this.height,
                            width: this.width
                        }
                    }), shapes = result.shapes), this.animator && useAnimation && !result.failed || (shapes = visuals.ColumnUtil.drawDefaultShapes(data, series, stackedColumnLayout, StackedColumnChartStrategy.classes.item, !this.animator, this.interactivityService && this.interactivityService.hasSelection())), 
                    visuals.ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart), 
                    {
                        eventGroup: this.graphicsContext.mainGraphicsContext,
                        shapesSelection: shapes,
                        viewport: {
                            height: this.height,
                            width: this.width
                        },
                        axisOptions: axisOptions,
                        labelDataPoints: labelDataPoints
                    };
                }, StackedColumnChartStrategy.prototype.selectColumn = function(selectedColumnIndex, lastSelectedColumnIndex) {
                    visuals.ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, StackedColumnChartStrategy.classes.item.selector, selectedColumnIndex, lastSelectedColumnIndex), 
                    this.moveHandle(selectedColumnIndex);
                }, StackedColumnChartStrategy.prototype.getClosestColumnIndex = function(x, y) {
                    return visuals.ColumnUtil.getClosestColumnIndex(x, this.getColumnsCenters());
                }, StackedColumnChartStrategy.prototype.getColumnsCenters = function() {
                    var _this = this;
                    if (!this.columnsCenters) {
                        var categoryWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                        if (this.data.series.length > 0) {
                            var xScaleOffset_1 = 0;
                            this.categoryLayout.isScalar || (xScaleOffset_1 = categoryWidth / 2);
                            var firstSeries = this.data.series[0];
                            this.columnsCenters = firstSeries.data.map(function(d) {
                                return _this.xProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + xScaleOffset_1;
                            });
                        }
                    }
                    return this.columnsCenters;
                }, StackedColumnChartStrategy.prototype.moveHandle = function(selectedColumnIndex) {
                    var columnCenters = this.getColumnsCenters(), x = columnCenters[selectedColumnIndex], hoverLine = d3.select(".interactive-hover-line");
                    if (hoverLine.empty() || this.columnSelectionLineHandle || (this.columnSelectionLineHandle = d3.select(hoverLine.node().parentNode)), 
                    this.columnSelectionLineHandle) {
                        var handle = this.columnSelectionLineHandle;
                        handle.select("line").attr({
                            x1: x,
                            x2: x
                        }), handle.select("circle").attr({
                            cx: x
                        });
                    } else {
                        var handle = this.columnSelectionLineHandle = this.graphicsContext.unclippedGraphicsContext.append("g");
                        handle.append("line").classed("interactive-hover-line", !0).attr({
                            x1: x,
                            x2: x,
                            y1: 0,
                            y2: this.height
                        }), handle.append("circle").attr({
                            cx: x,
                            cy: this.height,
                            r: "6px"
                        }).classed("drag-handle", !0);
                    }
                }, StackedColumnChartStrategy.getLayout = function(data, axisOptions) {
                    var columnWidth = axisOptions.columnWidth, isScalar = axisOptions.isScalar, xScale = axisOptions.xScale, yScale = axisOptions.yScale, xScaleOffset = 0;
                    return isScalar && (xScaleOffset = columnWidth / 2), {
                        shapeLayout: {
                            width: function(d) {
                                return columnWidth;
                            },
                            x: function(d) {
                                return xScale(isScalar ? d.categoryValue : d.categoryIndex) - xScaleOffset;
                            },
                            y: function(d) {
                                return yScale(d.position);
                            },
                            height: function(d) {
                                return yScale(d.position - d.valueAbsolute) - yScale(d.position);
                            }
                        },
                        shapeLayoutWithoutHighlights: {
                            width: function(d) {
                                return columnWidth;
                            },
                            x: function(d) {
                                return xScale(isScalar ? d.categoryValue : d.categoryIndex) - xScaleOffset;
                            },
                            y: function(d) {
                                return yScale(d.originalPosition);
                            },
                            height: function(d) {
                                return yScale(d.originalPosition - d.originalValueAbsolute) - yScale(d.originalPosition);
                            }
                        },
                        zeroShapeLayout: {
                            width: function(d) {
                                return columnWidth;
                            },
                            x: function(d) {
                                return xScale(isScalar ? d.categoryValue : d.categoryIndex) - xScaleOffset;
                            },
                            y: function(d) {
                                return yScale(d.value >= 0 ? d.position - d.valueAbsolute : d.position);
                            },
                            height: function(d) {
                                return 0;
                            }
                        }
                    };
                }, StackedColumnChartStrategy.prototype.createLabelDataPoints = function() {
                    for (var labelDataPoints = [], data = this.data, series = data.series, formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager(), shapeLayout = this.layout.shapeLayout, _i = 0, series_1 = series; _i < series_1.length; _i++) {
                        var currentSeries = series_1[_i], labelSettings = currentSeries.labelSettings ? currentSeries.labelSettings : data.labelSettings;
                        if (labelSettings.show) for (var axisFormatter = visuals.NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yProps.formatter, labelSettings), _a = 0, _b = currentSeries.data; _a < _b.length; _a++) {
                            var dataPoint = _b[_a];
                            if ((!data.hasHighlights || dataPoint.highlight) && null != dataPoint.value) {
                                var parentRect = {
                                    left: shapeLayout.x(dataPoint),
                                    top: shapeLayout.y(dataPoint),
                                    width: shapeLayout.width(dataPoint),
                                    height: shapeLayout.height(dataPoint)
                                }, formatString = "";
                                formatString = this.graphicsContext.is100Pct ? visuals.NewDataLabelUtils.hundredPercentFormat : dataPoint.labelFormatString;
                                var formatter = formattersCache.getOrCreate(formatString, labelSettings, axisFormatter), text = visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(dataPoint.value)), properties = {
                                    text: text,
                                    fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                                    fontSize: PixelConverter.fromPoint(labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt),
                                    fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight
                                }, textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties), textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, !0);
                                labelDataPoints.push({
                                    isPreferred: !0,
                                    text: text,
                                    textSize: {
                                        width: textWidth,
                                        height: textHeight
                                    },
                                    outsideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, !1, this.isComboChart),
                                    insideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, !0, this.isComboChart),
                                    parentType: 1,
                                    parentShape: {
                                        rect: parentRect,
                                        orientation: dataPoint.value >= 0 ? 1 : 2,
                                        validPositions: visuals.ColumnChart.stackedValidLabelPositions
                                    },
                                    identity: dataPoint.identity,
                                    fontSize: labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt
                                });
                            }
                        }
                    }
                    return labelDataPoints;
                }, StackedColumnChartStrategy.classes = {
                    item: {
                        "class": "column",
                        selector: ".column"
                    },
                    highlightItem: {
                        "class": "highlightColumn",
                        selector: ".highlightColumn"
                    }
                }, StackedColumnChartStrategy;
            }();
            visuals.StackedColumnChartStrategy = StackedColumnChartStrategy;
            var StackedBarChartStrategy = function() {
                function StackedBarChartStrategy() {}
                return StackedBarChartStrategy.prototype.setupVisualProps = function(barChartProps) {
                    this.graphicsContext = barChartProps, this.margin = barChartProps.margin, this.width = this.graphicsContext.width, 
                    this.height = this.graphicsContext.height, this.categoryLayout = barChartProps.layout, 
                    this.animator = barChartProps.animator, this.interactivityService = barChartProps.interactivityService, 
                    this.viewportHeight = barChartProps.viewportHeight, this.viewportWidth = barChartProps.viewportWidth, 
                    this.isComboChart = barChartProps.isComboChart;
                }, StackedBarChartStrategy.prototype.setData = function(data) {
                    this.data = data;
                }, StackedBarChartStrategy.prototype.setYScale = function(is100Pct, forcedTickCount, forcedYDomain, axisScaleType, axisDisplayUnits, axisPrecision, ensureYDomain) {
                    var forcedYMin, forcedYMax, height = this.height;
                    forcedYDomain && 2 === forcedYDomain.length && (forcedYMin = forcedYDomain[0], forcedYMax = forcedYDomain[1]);
                    var props = this.yProps = visuals.ColumnUtil.getCategoryAxis(this.data, height, this.categoryLayout, !0, forcedYMin, forcedYMax, axisScaleType, axisDisplayUnits, axisPrecision, ensureYDomain);
                    return props;
                }, StackedBarChartStrategy.prototype.setXScale = function(is100Pct, forcedTickCount, forcedXDomain, axisScaleType, axisDisplayUnits, axisPrecision, ensureXDomain) {
                    var width = this.width, valueDomain = visuals.StackedUtil.calcValueDomain(this.data.series, is100Pct), valueDomainArr = [ valueDomain.min, valueDomain.max ], combinedDomain = visuals.AxisHelper.combineDomain(forcedXDomain, valueDomainArr, ensureXDomain), shouldClamp = visuals.AxisHelper.scaleShouldClamp(combinedDomain, valueDomainArr), metadataColumn = this.data.valuesMetadata[0], formatString = is100Pct ? this.graphicsContext.hostService.getLocalizedString("Percentage") : visuals.valueFormatter.getFormatString(metadataColumn, visuals.columnChartProps.general.formatString);
                    return this.xProps = visuals.AxisHelper.createAxis({
                        pixelSpan: width,
                        dataDomain: combinedDomain,
                        metaDataColumn: metadataColumn,
                        formatString: formatString,
                        outerPadding: 0,
                        isScalar: !0,
                        isVertical: !1,
                        forcedTickCount: forcedTickCount,
                        useTickIntervalForDisplayUnits: !0,
                        isCategoryAxis: !1,
                        scaleType: axisScaleType,
                        axisDisplayUnits: axisDisplayUnits,
                        axisPrecision: axisPrecision,
                        is100Pct: is100Pct,
                        shouldClamp: shouldClamp
                    }), this.xProps.axis.tickSize(-this.viewportHeight, 0), this.xProps;
                }, StackedBarChartStrategy.prototype.drawColumns = function(useAnimation) {
                    var data = this.data;
                    this.barsCenters = null;
                    var axisOptions = {
                        columnWidth: this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio),
                        xScale: this.xProps.scale,
                        yScale: this.yProps.scale,
                        isScalar: this.categoryLayout.isScalar,
                        margin: this.margin
                    }, stackedBarLayout = this.layout = StackedBarChartStrategy.getLayout(data, axisOptions), dataLabelSettings = data.labelSettings, labelDataPoints = [];
                    dataLabelSettings && dataLabelSettings.show && (labelDataPoints = this.createLabelDataPoints());
                    var result, shapes, series = visuals.ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);
                    return this.animator && useAnimation && (result = this.animator.animate({
                        viewModel: data,
                        series: series,
                        layout: stackedBarLayout,
                        itemCS: StackedBarChartStrategy.classes.item,
                        interactivityService: this.interactivityService,
                        mainGraphicsContext: this.graphicsContext.mainGraphicsContext,
                        viewPort: {
                            height: this.height,
                            width: this.width
                        }
                    }), shapes = result.shapes), this.animator && useAnimation && !result.failed || (shapes = visuals.ColumnUtil.drawDefaultShapes(data, series, stackedBarLayout, StackedBarChartStrategy.classes.item, !this.animator, this.interactivityService && this.interactivityService.hasSelection())), 
                    visuals.ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart), 
                    {
                        eventGroup: this.graphicsContext.mainGraphicsContext,
                        shapesSelection: shapes,
                        viewport: {
                            height: this.height,
                            width: this.width
                        },
                        axisOptions: axisOptions,
                        labelDataPoints: labelDataPoints
                    };
                }, StackedBarChartStrategy.prototype.selectColumn = function(selectedColumnIndex, lastInteractiveSelectedColumnIndex) {
                    visuals.ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, StackedBarChartStrategy.classes.item.selector, selectedColumnIndex, lastInteractiveSelectedColumnIndex), 
                    this.moveHandle(selectedColumnIndex);
                }, StackedBarChartStrategy.prototype.getClosestColumnIndex = function(x, y) {
                    return visuals.ColumnUtil.getClosestColumnIndex(y, this.getBarsCenters());
                }, StackedBarChartStrategy.prototype.getBarsCenters = function() {
                    var _this = this;
                    if (!this.barsCenters) {
                        var barWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                        if (this.data.series.length > 0) {
                            var yScaleOffset_1 = 0;
                            this.categoryLayout.isScalar || (yScaleOffset_1 = barWidth / 2);
                            var firstSeries = this.data.series[0];
                            this.barsCenters = firstSeries.data.map(function(d) {
                                return _this.yProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + yScaleOffset_1;
                            });
                        }
                    }
                    return this.barsCenters;
                }, StackedBarChartStrategy.prototype.moveHandle = function(selectedColumnIndex) {
                    var barCenters = this.getBarsCenters(), y = barCenters[selectedColumnIndex], hoverLine = d3.select(".interactive-hover-line");
                    if (hoverLine.empty() || this.columnSelectionLineHandle || (this.columnSelectionLineHandle = d3.select(hoverLine.node().parentNode)), 
                    this.columnSelectionLineHandle) {
                        var handle = this.columnSelectionLineHandle;
                        handle.select("line").attr({
                            y1: y,
                            y2: y
                        }), handle.select("circle").attr({
                            cy: y
                        });
                    } else {
                        var handle = this.columnSelectionLineHandle = this.graphicsContext.unclippedGraphicsContext.append("g");
                        handle.append("line").classed("interactive-hover-line", !0).attr({
                            x1: 0,
                            x2: this.width,
                            y1: y,
                            y2: y
                        }), handle.append("circle").classed("drag-handle", !0).attr({
                            cx: 0,
                            cy: y,
                            r: "6px"
                        });
                    }
                }, StackedBarChartStrategy.getLayout = function(data, axisOptions) {
                    var columnWidth = axisOptions.columnWidth, isScalar = axisOptions.isScalar, xScale = axisOptions.xScale, yScale = axisOptions.yScale, yScaleOffset = 0;
                    return isScalar && (yScaleOffset = columnWidth / 2), {
                        shapeLayout: {
                            width: function(d) {
                                return xScale(d.position) - xScale(d.position - d.valueAbsolute);
                            },
                            x: function(d) {
                                return xScale(d.position - d.valueAbsolute);
                            },
                            y: function(d) {
                                return yScale(isScalar ? d.categoryValue : d.categoryIndex) - yScaleOffset;
                            },
                            height: function(d) {
                                return columnWidth;
                            }
                        },
                        shapeLayoutWithoutHighlights: {
                            width: function(d) {
                                return xScale(d.originalPosition) - xScale(d.originalPosition - d.originalValueAbsolute);
                            },
                            x: function(d) {
                                return xScale(d.originalPosition - d.originalValueAbsolute);
                            },
                            y: function(d) {
                                return yScale(isScalar ? d.categoryValue : d.categoryIndex) - yScaleOffset;
                            },
                            height: function(d) {
                                return columnWidth;
                            }
                        },
                        zeroShapeLayout: {
                            width: function(d) {
                                return 0;
                            },
                            x: function(d) {
                                return xScale(d.value >= 0 ? d.position - d.valueAbsolute : d.position);
                            },
                            y: function(d) {
                                return yScale(isScalar ? d.categoryValue : d.categoryIndex) - yScaleOffset;
                            },
                            height: function(d) {
                                return columnWidth;
                            }
                        }
                    };
                }, StackedBarChartStrategy.prototype.createLabelDataPoints = function() {
                    for (var labelDataPoints = [], data = this.data, series = data.series, formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager(), shapeLayout = this.layout.shapeLayout, _i = 0, series_2 = series; _i < series_2.length; _i++) {
                        var currentSeries = series_2[_i], labelSettings = currentSeries.labelSettings ? currentSeries.labelSettings : data.labelSettings;
                        if (labelSettings.show) for (var axisFormatter = visuals.NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yProps.formatter, labelSettings), _a = 0, _b = currentSeries.data; _a < _b.length; _a++) {
                            var dataPoint = _b[_a];
                            if ((!data.hasHighlights || dataPoint.highlight) && null != dataPoint.value) {
                                var formatString = void 0;
                                formatString = this.graphicsContext.is100Pct ? visuals.NewDataLabelUtils.hundredPercentFormat : dataPoint.labelFormatString;
                                var formatter = formattersCache.getOrCreate(formatString, labelSettings, axisFormatter), text = visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(dataPoint.value)), properties = {
                                    text: text,
                                    fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                                    fontSize: PixelConverter.fromPoint(labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt),
                                    fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight
                                }, textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties), textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, !0), parentRect = {
                                    left: shapeLayout.x(dataPoint),
                                    top: shapeLayout.y(dataPoint),
                                    width: shapeLayout.width(dataPoint),
                                    height: shapeLayout.height(dataPoint)
                                };
                                labelDataPoints.push({
                                    isPreferred: !0,
                                    text: text,
                                    textSize: {
                                        width: textWidth,
                                        height: textHeight
                                    },
                                    outsideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, !1, this.isComboChart),
                                    insideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, !0, this.isComboChart),
                                    parentType: 1,
                                    parentShape: {
                                        rect: parentRect,
                                        orientation: dataPoint.value >= 0 ? 3 : 4,
                                        validPositions: visuals.ColumnChart.stackedValidLabelPositions
                                    },
                                    identity: dataPoint.identity,
                                    fontSize: labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt
                                });
                            }
                        }
                    }
                    return labelDataPoints;
                }, StackedBarChartStrategy.classes = {
                    item: {
                        "class": "bar",
                        selector: ".bar"
                    },
                    highlightItem: {
                        "class": "highlightBar",
                        selector: ".highlightBar"
                    }
                }, StackedBarChartStrategy;
            }();
            visuals.StackedBarChartStrategy = StackedBarChartStrategy;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var SelectionManager = visuals.utility.SelectionManager, HelloIVisual = function() {
                    function HelloIVisual() {}
                    return HelloIVisual.converter = function(dataView) {
                        var viewModel = {
                            size: HelloIVisual.getSize(dataView),
                            color: HelloIVisual.getFill(dataView).solid.color,
                            text: HelloIVisual.DefaultText,
                            toolTipInfo: [ {
                                displayName: "Test",
                                value: "1...2....3... can you see me? I am sending random strings to the tooltip"
                            } ],
                            selector: visuals.SelectionId.createNull()
                        }, table = dataView.table;
                        return table ? (viewModel.text = table.rows[0][0], dataView.categorical && (viewModel.selector = dataView.categorical.categories[0].identity ? visuals.SelectionId.createWithId(dataView.categorical.categories[0].identity[0]) : visuals.SelectionId.createNull()), 
                        viewModel) : viewModel;
                    }, HelloIVisual.prototype.init = function(options) {
                        this.root = d3.select(options.element.get(0)).append("svg").classed("hello", !0), 
                        this.svgText = this.root.append("text").style("cursor", "pointer").style("stroke", "green").style("stroke-width", "0px").attr("text-anchor", "middle"), 
                        this.selectiionManager = new SelectionManager({
                            hostServices: options.host
                        });
                    }, HelloIVisual.prototype.update = function(options) {
                        if (options.dataViews || options.dataViews[0]) {
                            var dataView = this.dataView = options.dataViews[0], viewport = options.viewport, viewModel = HelloIVisual.converter(dataView);
                            this.root.attr({
                                height: viewport.height,
                                width: viewport.width
                            });
                            var textProperties = {
                                fontFamily: "tahoma",
                                fontSize: viewModel.size + "px",
                                text: viewModel.text
                            }, textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties), selectionManager = this.selectiionManager;
                            this.svgText.style({
                                fill: viewModel.color,
                                "font-size": textProperties.fontSize,
                                "font-family": textProperties.fontFamily
                            }).attr({
                                y: viewport.height / 2 + textHeight / 3 + "px",
                                x: viewport.width / 2
                            }).text(viewModel.text).on("click", function() {
                                var _this = this;
                                selectionManager.select(viewModel.selector).then(function(ids) {
                                    return d3.select(_this).style("stroke-width", ids.length > 0 ? "2px" : "0px");
                                });
                            }).data([ viewModel ]), visuals.TooltipManager.addTooltip(this.svgText, function(tooltipEvent) {
                                return tooltipEvent.data.toolTipInfo;
                            });
                        }
                    }, HelloIVisual.getFill = function(dataView) {
                        if (dataView) {
                            var objects = dataView.metadata.objects;
                            if (objects) {
                                var general = objects.general;
                                if (general) {
                                    var fill = general.fill;
                                    if (fill) return fill;
                                }
                            }
                        }
                        return {
                            solid: {
                                color: "red"
                            }
                        };
                    }, HelloIVisual.getSize = function(dataView) {
                        if (dataView) {
                            var objects = dataView.metadata.objects;
                            if (objects) {
                                var general = objects.general;
                                if (general) {
                                    var size = general.size;
                                    if (size) return size;
                                }
                            }
                        }
                        return 100;
                    }, HelloIVisual.prototype.enumerateObjectInstances = function(options) {
                        var instances = [], dataView = this.dataView;
                        switch (options.objectName) {
                          case "general":
                            var general = {
                                objectName: "general",
                                displayName: "General",
                                selector: null,
                                properties: {
                                    fill: HelloIVisual.getFill(dataView),
                                    size: HelloIVisual.getSize(dataView)
                                }
                            };
                            instances.push(general);
                        }
                        return instances;
                    }, HelloIVisual.prototype.destroy = function() {
                        this.root = null;
                    }, HelloIVisual.capabilities = {
                        dataRoles: [ {
                            displayName: "Values",
                            name: "Values",
                            kind: powerbi.VisualDataRoleKind.GroupingOrMeasure
                        } ],
                        dataViewMappings: [ {
                            table: {
                                rows: {
                                    "for": {
                                        "in": "Values"
                                    },
                                    dataReductionAlgorithm: {
                                        window: {
                                            count: 100
                                        }
                                    }
                                },
                                rowCount: {
                                    preferred: {
                                        min: 1
                                    }
                                }
                            }
                        } ],
                        objects: {
                            general: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                                properties: {
                                    fill: {
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        },
                                        displayName: "Fill"
                                    },
                                    size: {
                                        type: {
                                            numeric: !0
                                        },
                                        displayName: "Size"
                                    }
                                }
                            }
                        }
                    }, HelloIVisual.DefaultText = "Invalid DV", HelloIVisual;
                }();
                samples.HelloIVisual = HelloIVisual;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var ComboChart;
            !function(ComboChart) {
                function enumerateDataPoints(enumeration, options, layers) {
                    if (layers) {
                        for (var columnChartLayerIndex, layersLength = layers.length, layerIndex = 0; layersLength > layerIndex; layerIndex++) {
                            var layer = layers[layerIndex];
                            if (layer.enumerateObjectInstances) {
                                if (layer instanceof visuals.ColumnChart) {
                                    columnChartLayerIndex = layerIndex;
                                    continue;
                                }
                                layer.enumerateObjectInstances(enumeration, options);
                            }
                        }
                        void 0 !== columnChartLayerIndex && layers[columnChartLayerIndex].enumerateObjectInstances(enumeration, options);
                    }
                }
                function customizeQuery(options) {
                    var columnMapping = !_.isEmpty(options.dataViewMappings) && options.dataViewMappings[0];
                    if (columnMapping) {
                        var columnValuesMapping = columnMapping.categorical && columnMapping.categorical.values, seriesSelect = columnValuesMapping.group && !_.isEmpty(columnValuesMapping.group.select) && columnValuesMapping.group.select[0];
                        _.isEmpty(seriesSelect["for"]["in"].items) && (columnValuesMapping.group.by.items = void 0);
                    }
                    var isScalar = visuals.CartesianChart.detectScalarMapping(columnMapping);
                    if (columnMapping && columnMapping.categorical && (columnMapping.categorical.dataVolume = 4, 
                    isScalar)) {
                        var dataViewCategories = columnMapping.categorical.categories;
                        dataViewCategories.dataReductionAlgorithm = {
                            sample: {}
                        };
                        var values = columnMapping.categorical.values;
                        values && values.group && (values.group.dataReductionAlgorithm = {
                            top: {}
                        });
                    }
                    var lineMapping = options.dataViewMappings.length > 1 && options.dataViewMappings[1];
                    if (lineMapping && lineMapping.categorical && (lineMapping.categorical.dataVolume = 4, 
                    isScalar)) {
                        var dataViewCategories = lineMapping.categorical.categories;
                        dataViewCategories.dataReductionAlgorithm = {
                            sample: {}
                        };
                        var values = lineMapping.categorical.values;
                        values && values.group && (values.group.dataReductionAlgorithm = {
                            top: {}
                        });
                    }
                    isScalar || visuals.CartesianChart.expandCategoryWindow(options.dataViewMappings);
                }
                function getSortableRoles(options) {
                    if (options && options.dataViewMappings.length > 0) {
                        var dataViewMapping = options.dataViewMappings[0];
                        if (!visuals.CartesianChart.detectScalarMapping(dataViewMapping)) return [ "Category", "Y", "Y2" ];
                    }
                    return null;
                }
                function isComboChart(chartType) {
                    return 10 === chartType || 13 === chartType || 14 === chartType || 15 === chartType || 16 === chartType;
                }
                ComboChart.capabilities = visuals.comboChartCapabilities, ComboChart.enumerateDataPoints = enumerateDataPoints, 
                ComboChart.customizeQuery = customizeQuery, ComboChart.getSortableRoles = getSortableRoles, 
                ComboChart.isComboChart = isComboChart;
            }(ComboChart = visuals.ComboChart || (visuals.ComboChart = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var ArrayExtensions = jsCommon.ArrayExtensions, DataColorPalette = function() {
                function DataColorPalette(colors, sentimentcolors) {
                    this.basePickerColors = [ {
                        value: "#FFFFFF"
                    }, {
                        value: "#000000"
                    }, {
                        value: "#00B8AA"
                    }, {
                        value: "#374649"
                    }, {
                        value: "#FD625E"
                    }, {
                        value: "#F2C811"
                    }, {
                        value: "#5F6B6D"
                    }, {
                        value: "#8AD4EB"
                    }, {
                        value: "#FE9666"
                    }, {
                        value: "#A66999"
                    } ], this.colors = colors || ThemeManager.getDefaultTheme(), this.sentimentColors = sentimentcolors || ThemeManager.defaultSentimentColors, 
                    this.scales = {};
                }
                return DataColorPalette.prototype.getColorScaleByKey = function(key) {
                    var scale = this.scales[key];
                    return void 0 === scale && (scale = this.createScale(), this.scales[key] = scale), 
                    scale;
                }, DataColorPalette.prototype.getNewColorScale = function() {
                    return this.createScale();
                }, DataColorPalette.prototype.getColorByIndex = function(index) {
                    return this.colors[index];
                }, DataColorPalette.prototype.getSentimentColors = function() {
                    return this.sentimentColors;
                }, DataColorPalette.prototype.getBasePickerColors = function() {
                    return this.basePickerColors;
                }, DataColorPalette.prototype.getAllColors = function() {
                    return this.colors;
                }, DataColorPalette.prototype.createScale = function() {
                    return D3ColorScale.createFromColors(this.colors);
                }, DataColorPalette;
            }();
            visuals.DataColorPalette = DataColorPalette;
            var D3ColorScale = function() {
                function D3ColorScale(scale) {
                    this.scale = scale;
                }
                return D3ColorScale.prototype.getColor = function(key) {
                    return this.scale(key);
                }, D3ColorScale.prototype.clearAndRotateScale = function() {
                    var offset = this.scale.domain().length, rotatedColors = ArrayExtensions.rotate(this.scale.range(), offset);
                    this.scale = d3.scale.ordinal().range(rotatedColors);
                }, D3ColorScale.prototype.clone = function() {
                    return new D3ColorScale(this.scale.copy());
                }, D3ColorScale.prototype.getDomain = function() {
                    return this.scale.domain();
                }, D3ColorScale.createFromColors = function(colors) {
                    return new D3ColorScale(d3.scale.ordinal().range(colors));
                }, D3ColorScale;
            }();
            visuals.D3ColorScale = D3ColorScale;
            var ThemeManager = function() {
                function ThemeManager() {}
                return ThemeManager.getDefaultTheme = function() {
                    if (!ThemeManager.defaultTheme) {
                        ThemeManager.defaultTheme = [];
                        for (var baseColors = ThemeManager.defaultBaseColors, i = 0; i < ThemeManager.colorSectorCount; ++i) for (var j = 0, jlen = baseColors.length; jlen > j; ++j) ThemeManager.defaultTheme.push({
                            value: jsCommon.Color.rotate(baseColors[j].value, i / ThemeManager.colorSectorCount)
                        });
                    }
                    return ThemeManager.defaultTheme;
                }, ThemeManager.colorSectorCount = 12, ThemeManager.defaultBaseColors = [ {
                    value: "#01B8AA"
                }, {
                    value: "#374649"
                }, {
                    value: "#FD625E"
                }, {
                    value: "#F2C80F"
                }, {
                    value: "#5F6B6D"
                }, {
                    value: "#8AD4EB"
                }, {
                    value: "#FE9666"
                }, {
                    value: "#A66999"
                }, {
                    value: "#3599B8"
                }, {
                    value: "#DFBFBF"
                }, {
                    value: "#4AC5BB"
                }, {
                    value: "#5F6B6D"
                }, {
                    value: "#FB8281"
                }, {
                    value: "#F4D25A"
                }, {
                    value: "#7F898A"
                }, {
                    value: "#A4DDEE"
                }, {
                    value: "#FDAB89"
                }, {
                    value: "#B687AC"
                }, {
                    value: "#28738A"
                }, {
                    value: "#A78F8F"
                }, {
                    value: "#168980"
                }, {
                    value: "#293537"
                }, {
                    value: "#BB4A4A"
                }, {
                    value: "#B59525"
                }, {
                    value: "#475052"
                }, {
                    value: "#6A9FB0"
                }, {
                    value: "#BD7150"
                }, {
                    value: "#7B4F71"
                }, {
                    value: "#1B4D5C"
                }, {
                    value: "#706060"
                }, {
                    value: "#0F5C55"
                }, {
                    value: "#1C2325"
                }, {
                    value: "#7D3231"
                }, {
                    value: "#796419"
                }, {
                    value: "#303637"
                }, {
                    value: "#476A75"
                }, {
                    value: "#7E4B36"
                }, {
                    value: "#52354C"
                }, {
                    value: "#0D262E"
                }, {
                    value: "#544848"
                } ], ThemeManager.defaultSentimentColors = [ {
                    value: "#C0433A"
                }, {
                    value: "#E8D62E"
                }, {
                    value: "#79C75B"
                } ], ThemeManager;
            }();
            visuals.ThemeManager = ThemeManager;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var DataDotChart = function() {
                function DataDotChart(options) {
                    this.isScrollable = options.isScrollable, this.interactivityService = options.interactivityService;
                }
                return DataDotChart.prototype.init = function(options) {
                    this.options = options, this.svg = options.svg, this.svg.classed(DataDotChart.ClassName, !0), 
                    this.mainGraphicsG = this.svg.append("g").classed("dataDotChartMainGraphicsContext", !0), 
                    this.mainGraphicsContext = this.mainGraphicsG.append("svg"), this.currentViewport = options.viewport, 
                    this.hostService = options.host, this.cartesianVisualHost = options.cartesianHost, 
                    this.style = options.style, this.colors = this.style.colorPalette.dataColors, this.interactivity = options.interactivity, 
                    this.element = options.element;
                }, DataDotChart.prototype.setData = function(dataViews) {
                    if (this.data = {
                        series: {
                            data: []
                        },
                        hasHighlights: !1,
                        hasDynamicSeries: !1
                    }, dataViews.length > 0) {
                        var dataView = dataViews[0];
                        if (dataView && dataView.categorical) {
                            var dataViewCategorical = this.dataViewCategorical = dataView.categorical, dvCategories = dataViewCategorical.categories, categoryType = powerbi.ValueType.fromDescriptor({
                                text: !0
                            });
                            dvCategories && dvCategories.length > 0 && dvCategories[0].source && dvCategories[0].source.type && (categoryType = dvCategories[0].source.type), 
                            this.data = DataDotChart.converter(dataView, visuals.valueFormatter.format(null), this.interactivityService);
                        }
                    }
                }, DataDotChart.prototype.setFilteredData = function(startIndex, endIndex) {
                    var data = this.clippedData = powerbi.Prototype.inherit(this.data);
                    return data && data.series && data.series.data && (data.series = {
                        data: data.series.data.slice(startIndex, endIndex),
                        xCol: data.series.xCol,
                        yCol: data.series.yCol
                    }), data;
                }, DataDotChart.prototype.calculateAxesProperties = function(options) {
                    var _this = this;
                    this.currentViewport = options.viewport, this.margin = options.margin;
                    var data = this.clippedData = this.data, viewport = this.currentViewport, margin = this.margin, series = data ? data.series : null, seriesArray = series && series.data && series.data.length > 0 ? [ series ] : [], categoryCount = series && series.data ? series.data.length : 0;
                    data.hasHighlights && (categoryCount /= 2);
                    var xMetaDataColumn, yMetaDataColumn, width = viewport.width - (margin.left + margin.right), height = viewport.height - (margin.top + margin.bottom);
                    DataDotChart.hasDataPoint(series) && (xMetaDataColumn = series.xCol, yMetaDataColumn = series.yCol);
                    var layout = visuals.CartesianChart.getLayout(null, {
                        availableWidth: width,
                        categoryCount: categoryCount,
                        domain: null,
                        isScalar: !1,
                        isScrollable: this.isScrollable,
                        trimOrdinalDataOnOverflow: options.trimOrdinalDataOnOverflow
                    }), outerPadding = layout.categoryThickness * visuals.CartesianChart.OuterPaddingRatio;
                    this.isScrollable || (this.clippedData = DataDotChart.createClippedDataIfOverflowed(data, layout.categoryCount));
                    var yDomain = visuals.AxisHelper.createValueDomain(seriesArray, !0) || visuals.emptyDomain, combinedDomain = visuals.AxisHelper.combineDomain(options.forcedYDomain, yDomain, options.ensureYDomain);
                    this.yAxisProperties = visuals.AxisHelper.createAxis({
                        pixelSpan: height,
                        dataDomain: combinedDomain,
                        metaDataColumn: yMetaDataColumn,
                        formatString: visuals.valueFormatter.getFormatString(yMetaDataColumn, DataDotChart.formatStringProp),
                        outerPadding: 0,
                        isScalar: !0,
                        isVertical: !0,
                        forcedTickCount: options.forcedTickCount,
                        useTickIntervalForDisplayUnits: !0,
                        isCategoryAxis: !1
                    });
                    var axisType = this.xAxisProperties ? this.xAxisProperties.axisType : powerbi.ValueType.fromDescriptor({
                        text: !0
                    }), xDomain = visuals.AxisHelper.createDomain(seriesArray, axisType, !1, options.forcedXDomain, options.ensureXDomain);
                    return this.xAxisProperties = visuals.AxisHelper.createAxis({
                        pixelSpan: width,
                        dataDomain: xDomain,
                        metaDataColumn: xMetaDataColumn,
                        formatString: visuals.valueFormatter.getFormatString(xMetaDataColumn, DataDotChart.formatStringProp),
                        outerPadding: outerPadding,
                        isScalar: !1,
                        isVertical: !1,
                        forcedTickCount: options.forcedTickCount,
                        useTickIntervalForDisplayUnits: !0,
                        categoryThickness: layout.categoryThickness,
                        getValueFn: function(index, type) {
                            return _this.lookupXValue(index, type);
                        },
                        isCategoryAxis: !0
                    }), [ this.xAxisProperties, this.yAxisProperties ];
                }, DataDotChart.createClippedDataIfOverflowed = function(data, categoryCount) {
                    var requiredLength = data.hasHighlights ? Math.min(data.series.data.length, 2 * categoryCount) : Math.min(data.series.data.length, categoryCount);
                    if (requiredLength >= data.series.data.length) return data;
                    var clipped = powerbi.Prototype.inherit(data);
                    return clipped.series = powerbi.Prototype.inherit(data.series), clipped.series.data = clipped.series.data.slice(0, requiredLength), 
                    clipped;
                }, DataDotChart.hasDataPoint = function(series) {
                    return series && series.data && series.data.length > 0;
                }, DataDotChart.prototype.lookupXValue = function(index, type) {
                    var data = this.data, isDateTime = visuals.AxisHelper.isDateTime(type);
                    if (isDateTime) return new Date(index);
                    if (data && data.series) {
                        var seriesData = data.series.data;
                        if (seriesData) {
                            var dataAtIndex = seriesData[index];
                            if (dataAtIndex) return dataAtIndex.categoryValue;
                        }
                    }
                    return index;
                }, DataDotChart.prototype.overrideXScale = function(xProperties) {
                    this.xAxisProperties = xProperties;
                }, DataDotChart.prototype.render = function(suppressAnimations) {
                    var _this = this;
                    if (this.clippedData) {
                        var data = this.clippedData, dataPoints = data.series.data, hasHighlights = data.hasHighlights, margin = this.margin, viewport = this.currentViewport, width = viewport.width - (margin.left + margin.right), height = viewport.height - (margin.top + margin.bottom), xScale = this.xAxisProperties.scale, yScale = this.yAxisProperties.scale, dotWidth = this.xAxisProperties.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio), dotRadius = dotWidth / 2, dotColor = this.cartesianVisualHost.getSharedColors().getNewColorScale().getColor(DataDotChart.DotColorKey), hasSelection = this.interactivityService ? this.interactivityService.hasSelection() : !1;
                        this.mainGraphicsContext.attr("width", width).attr("height", height);
                        var dots = this.mainGraphicsContext.selectAll(DataDotChart.DotClassSelector).data(dataPoints, function(d) {
                            return d.identity.getKey();
                        });
                        dots.enter().append("circle").classed(DataDotChart.DotClassName, !0), dots.style({
                            fill: dotColor.value
                        }).style("fill-opacity", function(d) {
                            return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, hasHighlights);
                        }).classed("null-value", function(d) {
                            return null === d.value;
                        }).attr({
                            r: function(d) {
                                return dotRadius;
                            },
                            cx: function(d) {
                                return xScale(d.categoryIndex) + dotRadius;
                            },
                            cy: function(d) {
                                return yScale(d.value);
                            }
                        }), dots.exit().remove();
                        var dotLabels = this.mainGraphicsContext.selectAll(DataDotChart.DotLabelClassSelector).data(dataPoints, function(d) {
                            return d.identity.getKey();
                        });
                        dotLabels.enter().append("text").classed(DataDotChart.DotLabelClassName, !0).attr({
                            "text-anchor": DataDotChart.DotLabelTextAnchor,
                            dy: DataDotChart.DotLabelVerticalOffset
                        }), dotLabels.classed("null-value", function(d) {
                            return null === d.value;
                        }).classed("overflowed", !1).attr({
                            x: function(d) {
                                return xScale(d.categoryIndex) + dotRadius;
                            },
                            y: function(d) {
                                return yScale(d.value);
                            }
                        }).text(function(d) {
                            return _this.yAxisProperties.formatter.format(d.value);
                        });
                        var overflowed = !1;
                        dotLabels.each(function() {
                            if (!overflowed && !$("<div>").addClass($(this).attr("class")).hasClass("null-value")) {
                                var width_1 = powerbi.TextMeasurementService.measureSvgTextElementWidth(this);
                                width_1 > dotWidth && (dotLabels.classed("overflowed", !0), overflowed = !0);
                            }
                        }), dotLabels.exit().remove();
                        var behaviorOptions = void 0;
                        return this.interactivityService && (behaviorOptions = {
                            dots: dots,
                            dotLabels: dotLabels,
                            datapoints: dataPoints
                        }), visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options), {
                            dataPoints: dataPoints,
                            behaviorOptions: behaviorOptions,
                            labelDataPoints: [],
                            labelsAreNumeric: !0
                        };
                    }
                }, DataDotChart.prototype.calculateLegend = function() {
                    return this.createLegendDataPoints(0);
                }, DataDotChart.prototype.hasLegend = function() {
                    return this.data && this.data.hasDynamicSeries;
                }, DataDotChart.prototype.createLegendDataPoints = function(columnIndex) {
                    var data = this.data;
                    if (!data) return null;
                    var category, series = data.series, seriesData = series.data, legendDataPoints = [], axisType = this.xAxisProperties ? this.xAxisProperties.axisType : powerbi.ValueType.fromDescriptor({
                        text: !0
                    });
                    if (data.series && data.series.data) {
                        var firstDataPoint = data.series.data[0];
                        category = firstDataPoint && this.lookupXValue(firstDataPoint.categoryValue, axisType);
                    }
                    if (series.yCol) {
                        var formatStringProp = DataDotChart.formatStringProp, lineDataPoint = seriesData[columnIndex], measure = lineDataPoint && lineDataPoint.value, label = visuals.converterHelper.getFormattedLegendLabel(series.yCol, this.dataViewCategorical.values, formatStringProp), dotColor = this.cartesianVisualHost.getSharedColors().getNewColorScale().getColor(DataDotChart.DotColorKey), dataViewCategoricalValues = this.dataViewCategorical.values, identity = dataViewCategoricalValues && dataViewCategoricalValues.length > columnIndex ? visuals.SelectionId.createWithIdAndMeasure(dataViewCategoricalValues[columnIndex].identity, dataViewCategoricalValues[columnIndex].source.queryName) : visuals.SelectionId.createWithMeasure(dataViewCategoricalValues.source.queryName);
                        legendDataPoints.push({
                            color: dotColor.value,
                            icon: visuals.LegendIcon.Line,
                            label: label,
                            category: visuals.valueFormatter.format(category, visuals.valueFormatter.getFormatString(series.xCol, formatStringProp)),
                            measure: visuals.valueFormatter.format(measure, visuals.valueFormatter.getFormatString(series.yCol, formatStringProp)),
                            identity: identity,
                            selected: !1
                        });
                    }
                    return {
                        dataPoints: legendDataPoints
                    };
                }, DataDotChart.prototype.onClearSelection = function() {
                    this.interactivityService && this.interactivityService.clearSelection();
                }, DataDotChart.converter = function(dataView, blankCategoryValue, interactivityService) {
                    var categorical = dataView.categorical, category = categorical.categories && categorical.categories.length > 0 ? categorical.categories[0] : {
                        source: void 0,
                        values: [ blankCategoryValue ],
                        identity: void 0
                    }, categoryType = visuals.AxisHelper.getCategoryValueType(category.source), isDateTime = visuals.AxisHelper.isDateTime(categoryType), categoryValues = category.values;
                    if (!_.isEmpty(categorical.values)) {
                        for (var measure = categorical.values[0], hasHighlights = !!measure.highlights, dataPoints = [], categoryIndex = 0, len = measure.values.length; len > categoryIndex; categoryIndex++) {
                            var idBuilder = new visuals.SelectionIdBuilder();
                            category.identity && (idBuilder = idBuilder.withCategory(category, categoryIndex));
                            var identity = idBuilder.withMeasure(measure.source.queryName).createSelectionId(), categoryValue = categoryValues[categoryIndex];
                            if ((!isDateTime || null == categoryValue || categoryValue instanceof Date) && (dataPoints.push({
                                categoryValue: isDateTime && categoryValue ? categoryValue.getTime() : categoryValue,
                                value: measure.values[categoryIndex],
                                categoryIndex: categoryIndex,
                                seriesIndex: 0,
                                selected: !1,
                                identity: identity,
                                highlight: !1
                            }), hasHighlights)) {
                                var highlightIdentity = visuals.SelectionId.createWithHighlight(identity), highlightValue = measure.highlights[categoryIndex];
                                dataPoints.push({
                                    categoryValue: isDateTime && categoryValue ? categoryValue.getTime() : categoryValue,
                                    value: highlightValue,
                                    categoryIndex: categoryIndex,
                                    seriesIndex: 0,
                                    selected: !1,
                                    identity: highlightIdentity,
                                    highlight: !0
                                });
                            }
                        }
                        return interactivityService && interactivityService.applySelectionStateToData(dataPoints), 
                        {
                            series: {
                                xCol: category.source,
                                yCol: measure.source,
                                data: dataPoints
                            },
                            hasHighlights: hasHighlights,
                            hasDynamicSeries: !0
                        };
                    }
                    return {
                        series: {
                            data: []
                        },
                        hasHighlights: !1,
                        hasDynamicSeries: !1
                    };
                }, DataDotChart.formatStringProp = {
                    objectName: "general",
                    propertyName: "formatString"
                }, DataDotChart.ClassName = "dataDotChart", DataDotChart.DotClassName = "dot", DataDotChart.DotClassSelector = ".dot", 
                DataDotChart.DotColorKey = "dataDot", DataDotChart.DotLabelClassName = "label", 
                DataDotChart.DotLabelClassSelector = ".label", DataDotChart.DotLabelVerticalOffset = "0.4em", 
                DataDotChart.DotLabelTextAnchor = "middle", DataDotChart;
            }();
            visuals.DataDotChart = DataDotChart;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, PixelConverter = jsCommon.PixelConverter, LabelUtils = visuals.NewDataLabelUtils, FunnelChart = function() {
                function FunnelChart(options) {
                    this.labelPositionObjects = [ visuals.labelPosition.outsideEnd, visuals.labelPosition.insideCenter ], 
                    options && (this.tooltipsEnabled = options.tooltipsEnabled, this.tooltipBucketEnabled = options.tooltipBucketEnabled, 
                    options.funnelSmallViewPortProperties && (this.funnelSmallViewPortProperties = options.funnelSmallViewPortProperties), 
                    options.animator && (this.animator = options.animator), options.behavior && (this.behavior = options.behavior));
                }
                return FunnelChart.converter = function(dataView, colors, hostServices, defaultDataPointColor, tooltipsEnabled, tooltipBucketEnabled) {
                    void 0 === tooltipsEnabled && (tooltipsEnabled = !0);
                    for (var reader = powerbi.data.createIDataViewCategoricalReader(dataView), dataPoints = [], formatStringProp = visuals.funnelChartProps.general.formatString, categorical = dataView.categorical, hasHighlights = reader.hasHighlights("Y"), valueMetaData = [], seriesIndex = 0, seriesCount = reader.getSeriesCount("Y"); seriesCount > seriesIndex; seriesIndex++) valueMetaData.push(reader.getValueMetadataColumn("Y", seriesIndex));
                    var firstValue, firstHighlight, previousValue, previousHighlight, highlightsOverflow = !1, hasNegativeValues = !1, allValuesAreNegative = !1, categoryLabels = [], dataLabelsSettings = this.getDefaultLabelSettings(), percentBarLabelSettings = this.getDefaultPercentLabelSettings(), colorHelper = new visuals.ColorHelper(colors, visuals.funnelChartProps.dataPoint.fill, defaultDataPointColor), gradientValueColumn = visuals.GradientUtils.getGradientValueColumn(categorical);
                    if (dataView && dataView.metadata && dataView.metadata.objects) {
                        var labelsObj = dataView.metadata.objects.labels;
                        labelsObj && visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, dataLabelsSettings);
                        var percentLabelsObj = dataView.metadata.objects.percentBarLabel;
                        percentLabelsObj && visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(percentLabelsObj, percentBarLabelSettings);
                    }
                    if (!reader.hasValues("Y")) return {
                        dataPoints: dataPoints,
                        categoryLabels: categoryLabels,
                        valuesMetadata: valueMetaData,
                        hasHighlights: hasHighlights,
                        highlightsOverflow: highlightsOverflow,
                        canShowDataLabels: !0,
                        dataLabelsSettings: dataLabelsSettings,
                        hasNegativeValues: hasNegativeValues,
                        allValuesAreNegative: allValuesAreNegative,
                        percentBarLabelSettings: percentBarLabelSettings
                    };
                    firstValue = reader.getValue("Y", 0, 0), hasHighlights && (firstHighlight = reader.getHighlight("Y", 0, 0));
                    var pctFormatString = visuals.valueFormatter.getLocalizedString("Percentage");
                    if (reader.hasCategories()) for (var categoryIndex = 0, categoryCount = reader.getCategoryCount(); categoryCount > categoryIndex; categoryIndex++) {
                        var categoryColumn = reader.getCategoryColumn("Category"), categoryValue = reader.getCategoryValue("Category", categoryIndex), valueMetadataColumn = reader.getValueMetadataColumn("Y"), identity = visuals.SelectionIdBuilder.builder().withCategory(categoryColumn, categoryIndex).withMeasure(valueMetadataColumn.queryName).createSelectionId(), value = reader.getValue("Y", categoryIndex), formattedCategoryValue = visuals.converterHelper.formatFromMetadataColumn(categoryValue, categoryColumn.source, formatStringProp), tooltipInfo = void 0;
                        if (tooltipsEnabled) {
                            tooltipInfo = [], tooltipInfo.push({
                                displayName: categoryColumn.source.displayName,
                                value: formattedCategoryValue
                            }), null != value && tooltipInfo.push({
                                displayName: valueMetadataColumn.displayName,
                                value: visuals.converterHelper.formatFromMetadataColumn(value, valueMetadataColumn, formatStringProp)
                            });
                            var highlightValue = void 0;
                            hasHighlights && (highlightValue = reader.getHighlight("Y", categoryIndex), null != highlightValue && tooltipInfo.push({
                                displayName: visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName,
                                value: visuals.converterHelper.formatFromMetadataColumn(highlightValue, valueMetadataColumn, formatStringProp)
                            }));
                            var gradientColumnMetadata = gradientValueColumn ? gradientValueColumn.source : void 0;
                            gradientColumnMetadata && gradientColumnMetadata !== valueMetadataColumn && null != gradientValueColumn.values[categoryIndex] && tooltipInfo.push({
                                displayName: gradientColumnMetadata.displayName,
                                value: visuals.converterHelper.formatFromMetadataColumn(reader.getValue("Gradient", categoryIndex), gradientColumnMetadata, formatStringProp)
                            }), hasHighlights ? FunnelChart.addFunnelPercentsToTooltip(pctFormatString, tooltipInfo, hostServices, firstHighlight ? highlightValue / firstHighlight : null, previousHighlight ? highlightValue / previousHighlight : null, !0) : FunnelChart.addFunnelPercentsToTooltip(pctFormatString, tooltipInfo, hostServices, firstValue ? value / firstValue : null, previousValue ? value / previousValue : null), 
                            tooltipBucketEnabled && visuals.TooltipBuilder.addTooltipBucketItem(reader, tooltipInfo, categoryIndex);
                        }
                        var color = colorHelper.getColorForMeasure(reader.getCategoryObjects("Category", categoryIndex), "");
                        if (dataPoints.push({
                            label: formattedCategoryValue,
                            value: value,
                            originalValue: value,
                            categoryOrMeasureIndex: categoryIndex,
                            identity: identity,
                            selected: !1,
                            key: identity.getKey(),
                            tooltipInfo: tooltipInfo,
                            color: color,
                            labelFill: dataLabelsSettings.labelColor
                        }), hasHighlights) {
                            var highlightIdentity = visuals.SelectionId.createWithHighlight(identity), highlightValue = reader.getHighlight("Y", categoryIndex);
                            dataPoints.push({
                                label: formattedCategoryValue,
                                value: value,
                                originalValue: value,
                                categoryOrMeasureIndex: categoryIndex,
                                identity: highlightIdentity,
                                selected: !1,
                                key: highlightIdentity.getKey(),
                                highlight: !0,
                                highlightValue: highlightValue,
                                originalHighlightValue: highlightValue,
                                tooltipInfo: tooltipInfo,
                                color: color
                            }), previousHighlight = highlightValue;
                        }
                        previousValue = value;
                    } else for (var categoryIndex = 0, seriesIndex = 0, seriesCount = reader.getSeriesCount("Y"); seriesCount > seriesIndex; seriesIndex++) {
                        var value = reader.getValue("Y", categoryIndex, seriesIndex), valueMetadataColumn = reader.getValueMetadataColumn("Y", seriesIndex), identity = visuals.SelectionId.createWithMeasure(valueMetadataColumn.queryName), tooltipInfo = void 0, color = colorHelper.getColorForMeasure(valueMetadataColumn.objects, "");
                        if (tooltipsEnabled) {
                            if (tooltipInfo = [], null != value && tooltipInfo.push({
                                displayName: valueMetadataColumn.displayName,
                                value: visuals.converterHelper.formatFromMetadataColumn(value, valueMetadataColumn, formatStringProp)
                            }), hasHighlights) {
                                var highlightValue = reader.getHighlight("Y", categoryIndex, seriesIndex);
                                null != highlightValue && tooltipInfo.push({
                                    displayName: visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName,
                                    value: visuals.converterHelper.formatFromMetadataColumn(highlightValue, valueMetadataColumn, formatStringProp)
                                }), FunnelChart.addFunnelPercentsToTooltip(pctFormatString, tooltipInfo, hostServices, firstHighlight ? highlightValue / firstHighlight : null, previousHighlight ? highlightValue / previousHighlight : null, !0);
                            } else FunnelChart.addFunnelPercentsToTooltip(pctFormatString, tooltipInfo, hostServices, firstValue ? value / firstValue : null, previousValue ? value / previousValue : null);
                            if (tooltipBucketEnabled) {
                                var tooltipValues = reader.getAllValuesForRole("Tooltips", categoryIndex, void 0), tooltipMetadataColumns = reader.getAllValueMetadataColumnsForRole("Tooltips", void 0);
                                if (tooltipValues && tooltipMetadataColumns) for (var j = 0; j < tooltipValues.length; j++) null != tooltipValues[j] && tooltipInfo.push({
                                    displayName: tooltipMetadataColumns[j].displayName,
                                    value: visuals.converterHelper.formatFromMetadataColumn(tooltipValues[j], tooltipMetadataColumns[j], formatStringProp)
                                });
                            }
                        }
                        if (dataPoints.push({
                            label: valueMetadataColumn.displayName,
                            value: value,
                            originalValue: value,
                            categoryOrMeasureIndex: seriesIndex,
                            identity: identity,
                            selected: !1,
                            key: identity.getKey(),
                            tooltipInfo: tooltipInfo,
                            color: color,
                            labelFill: dataLabelsSettings.labelColor
                        }), hasHighlights) {
                            var highlightIdentity = visuals.SelectionId.createWithHighlight(identity), highlight = reader.getHighlight("Y", categoryIndex, seriesIndex);
                            dataPoints.push({
                                label: valueMetadataColumn.displayName,
                                value: value,
                                originalValue: value,
                                categoryOrMeasureIndex: seriesIndex,
                                identity: highlightIdentity,
                                key: highlightIdentity.getKey(),
                                selected: !1,
                                highlight: !0,
                                originalHighlightValue: highlight,
                                highlightValue: highlight,
                                tooltipInfo: tooltipInfo,
                                color: color
                            }), previousHighlight = highlight;
                        }
                        previousValue = value;
                    }
                    for (var i = 0; i < dataPoints.length; i += hasHighlights ? 2 : 1) {
                        var dataPoint = dataPoints[i];
                        categoryLabels.push(dataPoint.label);
                    }
                    allValuesAreNegative = dataPoints.length > 0 && _.every(dataPoints, function(dataPoint) {
                        return (dataPoint.highlight ? dataPoint.highlightValue <= 0 : !0) && dataPoint.value < 0;
                    });
                    for (var _i = 0, dataPoints_1 = dataPoints; _i < dataPoints_1.length; _i++) {
                        var dataPoint = dataPoints_1[_i];
                        if (allValuesAreNegative) dataPoint.value = Math.abs(dataPoint.value), dataPoint.highlight && (dataPoint.highlightValue = Math.abs(dataPoint.highlightValue)); else {
                            var value = dataPoint.value, isValueNegative = 0 > value;
                            isValueNegative && (dataPoint.value = 0);
                            var isHighlightValueNegative = !1;
                            if (dataPoint.highlight) {
                                var highlightValue = dataPoint.highlightValue;
                                isHighlightValueNegative = 0 > highlightValue, dataPoint.highlightValue = isHighlightValueNegative ? 0 : highlightValue;
                            }
                            hasNegativeValues || (hasNegativeValues = isValueNegative || isHighlightValueNegative);
                        }
                        dataPoint.highlightValue > dataPoint.value && (highlightsOverflow = !0);
                    }
                    return {
                        dataPoints: dataPoints,
                        categoryLabels: categoryLabels,
                        valuesMetadata: valueMetaData,
                        hasHighlights: hasHighlights,
                        highlightsOverflow: highlightsOverflow,
                        canShowDataLabels: !0,
                        dataLabelsSettings: dataLabelsSettings,
                        hasNegativeValues: hasNegativeValues,
                        allValuesAreNegative: allValuesAreNegative,
                        percentBarLabelSettings: percentBarLabelSettings
                    };
                }, FunnelChart.prototype.enumerateObjectInstances = function(options) {
                    var enumeration = new visuals.ObjectEnumerationBuilder();
                    switch (options.objectName) {
                      case "dataPoint":
                        var dataViewCat = this.dataViews && this.dataViews.length > 0 && this.dataViews[0] && this.dataViews[0].categorical, hasGradientRole = visuals.GradientUtils.hasGradientRole(dataViewCat);
                        hasGradientRole || this.enumerateDataPoints(enumeration);
                        break;

                      case "labels":
                        var labelSettingsOptions = FunnelChart.getLabelSettingsOptions(enumeration, this.data.dataLabelsSettings, !0, this.labelPositionObjects);
                        visuals.dataLabelUtils.enumerateDataLabels(labelSettingsOptions);
                        break;

                      case "percentBarLabel":
                        var percentLabelSettingOptions = FunnelChart.getLabelSettingsOptions(enumeration, this.data.percentBarLabelSettings, !1);
                        visuals.dataLabelUtils.enumerateDataLabels(percentLabelSettingOptions);
                    }
                    return enumeration.complete();
                }, FunnelChart.getLabelSettingsOptions = function(enumeration, labelSettings, isDataLabels, positionObject) {
                    return {
                        enumeration: enumeration,
                        dataLabelsSettings: labelSettings,
                        show: !0,
                        displayUnits: isDataLabels,
                        precision: isDataLabels,
                        position: isDataLabels,
                        positionObject: positionObject,
                        fontSize: !0
                    };
                }, FunnelChart.prototype.enumerateDataPoints = function(enumeration) {
                    var data = this.data;
                    if (data) {
                        var dataPoints = data.dataPoints;
                        enumeration.pushInstance({
                            objectName: "dataPoint",
                            selector: null,
                            properties: {
                                defaultColor: {
                                    solid: {
                                        color: this.defaultDataPointColor || this.colors.getColorByIndex(0).value
                                    }
                                }
                            }
                        });
                        for (var i = 0; i < dataPoints.length; i++) {
                            var dataPont = dataPoints[i];
                            if (!dataPont.highlight) {
                                var color = dataPont.color, selector = dataPont.identity.getSelector(), isSingleSeries = !!selector.data;
                                enumeration.pushInstance({
                                    objectName: "dataPoint",
                                    displayName: dataPont.label,
                                    selector: visuals.ColorHelper.normalizeSelector(selector, isSingleSeries),
                                    properties: {
                                        fill: {
                                            solid: {
                                                color: color
                                            }
                                        }
                                    }
                                });
                            }
                        }
                    }
                }, FunnelChart.prototype.init = function(options) {
                    this.options = options;
                    var element = options.element, svg = this.svg = d3.select(element.get(0)).append("svg").classed(FunnelChart.VisualClassName, !0);
                    this.behavior && (this.clearCatcher = visuals.appendClearCatcher(this.svg)), this.currentViewport = options.viewport, 
                    this.margin = {
                        left: 5,
                        right: 5,
                        top: 0,
                        bottom: 0
                    };
                    var style = options.style;
                    this.colors = style.colorPalette.dataColors, this.hostServices = options.host, this.behavior && (this.interactivityService = visuals.createInteractivityService(this.hostServices)), 
                    this.percentGraphicsContext = svg.append("g").classed(FunnelChart.Selectors.percentBar.root["class"], !0), 
                    this.funnelGraphicsContext = svg.append("g"), this.axisGraphicsContext = svg.append("g"), 
                    this.labelGraphicsContext = svg.append("g").classed(LabelUtils.labelGraphicsContextClass["class"], !0), 
                    this.updateViewportProperties();
                }, FunnelChart.prototype.updateViewportProperties = function() {
                    var viewport = this.currentViewport;
                    this.svg.attr("width", viewport.width).attr("height", viewport.height);
                }, FunnelChart.prototype.update = function(options) {
                    this.data = {
                        dataPoints: [],
                        categoryLabels: [],
                        valuesMetadata: [],
                        hasHighlights: !1,
                        highlightsOverflow: !1,
                        canShowDataLabels: !0,
                        dataLabelsSettings: visuals.dataLabelUtils.getDefaultLabelSettings(),
                        hasNegativeValues: !1,
                        allValuesAreNegative: !1,
                        percentBarLabelSettings: visuals.dataLabelUtils.getDefaultLabelSettings(!0)
                    };
                    var dataViews = this.dataViews = options.dataViews;
                    if (this.currentViewport = options.viewport, dataViews && dataViews.length > 0) {
                        var dataView = dataViews[0];
                        if (dataView.metadata && dataView.metadata.objects) {
                            var defaultColor = powerbi.DataViewObjects.getFillColor(dataView.metadata.objects, visuals.funnelChartProps.dataPoint.defaultColor);
                            defaultColor && (this.defaultDataPointColor = defaultColor);
                        }
                        dataView.categorical && (this.data = FunnelChart.converter(dataView, this.colors, this.hostServices, this.defaultDataPointColor, this.tooltipsEnabled, this.tooltipBucketEnabled), 
                        this.interactivityService && this.interactivityService.applySelectionStateToData(this.data.dataPoints));
                        var warnings = visuals.getInvalidValueWarnings(dataViews, !1, !1, !1);
                        this.data.allValuesAreNegative ? warnings.push(new visuals.AllNegativeValuesWarning()) : this.data.hasNegativeValues && warnings.push(new visuals.NegativeValuesNotSupportedWarning()), 
                        this.hostServices.setWarnings(warnings);
                    }
                    this.updateViewportProperties(), this.updateInternal(options.suppressAnimations);
                }, FunnelChart.prototype.onDataChanged = function(options) {
                    this.update({
                        dataViews: options.dataViews,
                        suppressAnimations: options.suppressAnimations,
                        viewport: this.currentViewport
                    });
                }, FunnelChart.prototype.onResizing = function(viewport) {
                    this.currentViewport = viewport, this.update({
                        dataViews: this.dataViews,
                        suppressAnimations: !0,
                        viewport: this.currentViewport
                    });
                }, FunnelChart.prototype.getMaxLabelLength = function(labels, properties) {
                    for (var max = 0, textMeasurer = powerbi.TextMeasurementService.measureSvgTextWidth, i = 0, len = labels.length; len > i; i++) properties.text = labels[i], 
                    max = Math.max(max, textMeasurer(properties));
                    return max + FunnelChart.LabelFunnelPadding;
                }, FunnelChart.prototype.updateInternal = function(suppressAnimations) {
                    if (null != this.data) {
                        var data = this.data, dataPoints = data.dataPoints, dataPointsWithoutHighlights = dataPoints.filter(function(d) {
                            return !d.highlight;
                        }), isHidingPercentBars = this.isHidingPercentBars(), axisOptions = this.setUpAxis(), margin = axisOptions.margin, funnelContext = this.funnelGraphicsContext.attr("transform", visuals.SVGUtil.translate(margin.left, margin.top)), labelContext = this.labelGraphicsContext.attr("transform", visuals.SVGUtil.translate(margin.left, margin.top));
                        this.percentGraphicsContext.attr("transform", visuals.SVGUtil.translate(margin.left, margin.top)), 
                        this.svg.style("font-family", visuals.dataLabelUtils.StandardFontFamily);
                        var result, shapes, layout = FunnelChart.getLayout(data, axisOptions), labels = this.getLabels(layout);
                        if (this.animator && !suppressAnimations) {
                            var animationOptions = {
                                viewModel: data,
                                interactivityService: this.interactivityService,
                                layout: layout,
                                axisGraphicsContext: this.axisGraphicsContext,
                                shapeGraphicsContext: funnelContext,
                                percentGraphicsContext: this.percentGraphicsContext,
                                labelGraphicsContext: this.labelGraphicsContext,
                                axisOptions: axisOptions,
                                dataPointsWithoutHighlights: dataPointsWithoutHighlights,
                                labelLayout: labels,
                                isHidingPercentBars: isHidingPercentBars,
                                visualInitOptions: this.options
                            };
                            result = this.animator.animate(animationOptions), shapes = result.shapes;
                        }
                        if ((!this.animator || suppressAnimations || result.failed) && (FunnelChart.drawDefaultAxis(this.axisGraphicsContext, axisOptions, isHidingPercentBars), 
                        shapes = FunnelChart.drawDefaultShapes(data, dataPoints, funnelContext, layout, this.interactivityService && this.interactivityService.hasSelection()), 
                        FunnelChart.drawPercentBars(data, this.percentGraphicsContext, layout, isHidingPercentBars), 
                        LabelUtils.drawDefaultLabels(labelContext, labels, !1)), this.interactivityService) {
                            var interactors = FunnelChart.drawInteractorShapes(dataPoints, funnelContext, layout), behaviorOptions = {
                                bars: shapes,
                                interactors: interactors,
                                clearCatcher: this.clearCatcher,
                                hasHighlights: data.hasHighlights
                            };
                            this.interactivityService.bind(dataPoints, this.behavior, behaviorOptions), this.tooltipsEnabled && visuals.TooltipManager.addTooltip(interactors, function(tooltipEvent) {
                                return tooltipEvent.data.tooltipInfo;
                            });
                        }
                        this.tooltipsEnabled && visuals.TooltipManager.addTooltip(shapes, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        }), visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
                    }
                }, FunnelChart.prototype.getUsableVerticalSpace = function() {
                    var categoryLabels = this.data.categoryLabels, margin = this.margin, verticalSpace = this.currentViewport.height - (margin.top + margin.bottom);
                    return verticalSpace - FunnelChart.MinBarThickness * categoryLabels.length;
                }, FunnelChart.prototype.isHidingPercentBars = function() {
                    var data = this.data;
                    if (data.percentBarLabelSettings.show) {
                        var percentBarTextHeight = this.getPercentBarTextHeight(), verticalSpace = this.getUsableVerticalSpace() - 2 * FunnelChart.MinBarThickness * FunnelChart.PercentBarToBarRatio - 2 * percentBarTextHeight;
                        return 0 >= verticalSpace;
                    }
                    return !0;
                }, FunnelChart.prototype.isSparklines = function() {
                    return this.getUsableVerticalSpace() <= 0;
                }, FunnelChart.prototype.setUpAxis = function() {
                    var data = this.data, dataPoints = data.dataPoints, categoryLabels = data.categoryLabels, viewport = this.currentViewport, margin = this.margin, isSparklines = this.isSparklines(), isHidingPercentBars = this.isHidingPercentBars(), percentBarTextHeight = isHidingPercentBars ? 0 : this.getPercentBarTextHeight(), verticalRange = viewport.height - (margin.top + margin.bottom) - 2 * percentBarTextHeight, maxMarginFactor = FunnelChart.MaxMarginFactor;
                    if (categoryLabels.length > 0 && isSparklines) categoryLabels = [], data.canShowDataLabels = !1; else if (this.showCategoryLabels()) {
                        var textProperties = FunnelChart.getTextProperties(), longestLabelLength = this.getMaxLabelLength(categoryLabels, textProperties), maxLabelLength = viewport.width * maxMarginFactor, labelLength = Math.min(longestLabelLength, maxLabelLength);
                        margin.left = labelLength + FunnelChart.YAxisPadding;
                    } else categoryLabels = [];
                    var horizontalRange = viewport.width - (margin.left + margin.right), barToSpaceRatio = FunnelChart.BarToSpaceRatio, maxScore = d3.max(dataPoints.map(function(d) {
                        return d.value;
                    }));
                    if (data.hasHighlights) {
                        var maxHighlight = d3.max(dataPoints.map(function(d) {
                            return d.highlightValue;
                        }));
                        maxScore = d3.max([ maxScore, maxHighlight ]);
                    }
                    var delta, minScore = 0, rangeStart = 0, rangeEnd = verticalRange;
                    delta = isHidingPercentBars ? verticalRange - categoryLabels.length * FunnelChart.MaxBarHeight : verticalRange - categoryLabels.length * FunnelChart.MaxBarHeight - 2 * FunnelChart.MaxBarHeight * FunnelChart.PercentBarToBarRatio, 
                    categoryLabels.length > 0 && delta > 0 && (rangeStart = Math.ceil(delta / 2), rangeEnd = Math.ceil(verticalRange - delta / 2)), 
                    isHidingPercentBars || (rangeStart += percentBarTextHeight, rangeEnd += percentBarTextHeight);
                    var valueScale = d3.scale.linear().domain([ minScore, maxScore ]).range([ horizontalRange, 0 ]), categoryScale = d3.scale.ordinal().domain(d3.range(0, data.categoryLabels.length)).rangeBands([ rangeStart, rangeEnd ], barToSpaceRatio, isHidingPercentBars ? barToSpaceRatio : FunnelChart.PercentBarToBarRatio);
                    return {
                        margin: margin,
                        valueScale: valueScale,
                        categoryScale: categoryScale,
                        maxScore: maxScore,
                        maxWidth: horizontalRange,
                        rangeStart: rangeStart,
                        rangeEnd: rangeEnd,
                        barToSpaceRatio: barToSpaceRatio,
                        categoryLabels: categoryLabels
                    };
                }, FunnelChart.prototype.getPercentBarTextHeight = function() {
                    var percentBarTextProperties = FunnelChart.getTextProperties(this.data.percentBarLabelSettings.fontSize);
                    return powerbi.TextMeasurementService.estimateSvgTextHeight(percentBarTextProperties);
                }, FunnelChart.prototype.onClearSelection = function() {
                    this.interactivityService && this.interactivityService.clearSelection();
                }, FunnelChart.getLayout = function(data, axisOptions) {
                    var highlightsOverflow = data.highlightsOverflow, categoryScale = axisOptions.categoryScale, valueScale = axisOptions.valueScale, maxScore = axisOptions.maxScore, columnHeight = categoryScale.rangeBand(), percentBarTickHeight = Math.ceil(columnHeight / 2), overFlowHighlightColumnWidth = columnHeight * FunnelChart.OverflowingHighlightWidthRatio, overFlowHighlightOffset = overFlowHighlightColumnWidth / 2, lastCategoryIndex = axisOptions.categoryLabels.length - 1, horizontalDistance = Math.abs(valueScale(maxScore) - valueScale(0)), emptyHorizontalSpace = function(value) {
                        return (horizontalDistance - Math.abs(valueScale(value) - valueScale(0))) / 2;
                    }, getMinimumShapeSize = function(value) {
                        return Math.max(FunnelChart.MinimumInteractorSize, Math.abs(valueScale(value) - valueScale(0)));
                    }, percentBarFontSize = PixelConverter.fromPoint(data.percentBarLabelSettings.fontSize), percentBarTextProperties = FunnelChart.getTextProperties(data.percentBarLabelSettings.fontSize), baselineDelta = powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(percentBarTextProperties), percentBarYOffset = powerbi.TextMeasurementService.estimateSvgTextHeight(percentBarTextProperties) - baselineDelta;
                    return {
                        percentBarLayout: {
                            mainLine: {
                                x2: function(d) {
                                    return Math.abs(valueScale(d.value) - valueScale(0));
                                },
                                transform: function(d) {
                                    var xOffset = valueScale(d.value) - emptyHorizontalSpace(d.value), yOffset = d.isTop ? categoryScale(0) - percentBarTickHeight : categoryScale(lastCategoryIndex) + columnHeight + percentBarTickHeight;
                                    return visuals.SVGUtil.translate(xOffset, yOffset);
                                }
                            },
                            leftTick: {
                                y2: function(d) {
                                    return percentBarTickHeight;
                                },
                                transform: function(d) {
                                    var xOffset = valueScale(d.value) - emptyHorizontalSpace(d.value), yOffset = d.isTop ? categoryScale(0) - percentBarTickHeight - percentBarTickHeight / 2 : categoryScale(lastCategoryIndex) + columnHeight + percentBarTickHeight - percentBarTickHeight / 2;
                                    return visuals.SVGUtil.translate(xOffset, yOffset);
                                }
                            },
                            rightTick: {
                                y2: function(d) {
                                    return percentBarTickHeight;
                                },
                                transform: function(d) {
                                    var columnOffset = valueScale(d.value) - emptyHorizontalSpace(d.value), columnWidth = Math.abs(valueScale(d.value) - valueScale(0)), xOffset = columnOffset + columnWidth, yOffset = d.isTop ? categoryScale(0) - percentBarTickHeight - percentBarTickHeight / 2 : categoryScale(lastCategoryIndex) + columnHeight + percentBarTickHeight - percentBarTickHeight / 2;
                                    return visuals.SVGUtil.translate(xOffset, yOffset);
                                }
                            },
                            text: {
                                x: function(d) {
                                    return Math.ceil(Math.abs(valueScale(maxScore) - valueScale(0)) / 2);
                                },
                                y: function(d) {
                                    return d.isTop ? -percentBarTickHeight / 2 - baselineDelta : percentBarYOffset + percentBarTickHeight / 2;
                                },
                                style: function() {
                                    return "font-size: " + percentBarFontSize + ";";
                                },
                                transform: function(d) {
                                    var xOffset = d.isTop ? categoryScale(0) - percentBarTickHeight : categoryScale(lastCategoryIndex) + columnHeight + percentBarTickHeight;
                                    return visuals.SVGUtil.translate(0, xOffset);
                                },
                                fill: data.percentBarLabelSettings.labelColor,
                                maxWidth: horizontalDistance
                            }
                        },
                        shapeLayout: {
                            height: function(d) {
                                return d.highlight && highlightsOverflow ? overFlowHighlightColumnWidth : columnHeight;
                            },
                            width: function(d) {
                                return Math.abs(valueScale(FunnelChart.getValueFromDataPoint(d)) - valueScale(0));
                            },
                            y: function(d) {
                                return categoryScale(d.categoryOrMeasureIndex) + (d.highlight && highlightsOverflow ? overFlowHighlightOffset : 0);
                            },
                            x: function(d) {
                                var value = FunnelChart.getValueFromDataPoint(d);
                                return valueScale(value) - emptyHorizontalSpace(value);
                            }
                        },
                        shapeLayoutWithoutHighlights: {
                            height: function(d) {
                                return columnHeight;
                            },
                            width: function(d) {
                                return Math.abs(valueScale(d.value) - valueScale(0));
                            },
                            y: function(d) {
                                return categoryScale(d.categoryOrMeasureIndex) + 0;
                            },
                            x: function(d) {
                                return valueScale(d.value) - emptyHorizontalSpace(d.value);
                            }
                        },
                        zeroShapeLayout: {
                            height: function(d) {
                                return d.highlight && highlightsOverflow ? overFlowHighlightColumnWidth : columnHeight;
                            },
                            width: function(d) {
                                return 0;
                            },
                            y: function(d) {
                                return categoryScale(d.categoryOrMeasureIndex) + (d.highlight && highlightsOverflow ? overFlowHighlightOffset : 0);
                            },
                            x: function(d) {
                                return valueScale((valueScale.domain()[0] + valueScale.domain()[1]) / 2);
                            }
                        },
                        interactorLayout: {
                            height: function(d) {
                                return d.highlight && highlightsOverflow ? overFlowHighlightColumnWidth : columnHeight;
                            },
                            width: function(d) {
                                return getMinimumShapeSize(FunnelChart.getValueFromDataPoint(d));
                            },
                            y: function(d) {
                                return categoryScale(d.categoryOrMeasureIndex) + (d.highlight && highlightsOverflow ? overFlowHighlightOffset : 0);
                            },
                            x: function(d) {
                                var size = getMinimumShapeSize(FunnelChart.getValueFromDataPoint(d));
                                return (horizontalDistance - size) / 2;
                            }
                        }
                    };
                }, FunnelChart.drawDefaultAxis = function(graphicsContext, axisOptions, isHidingPercentBars) {
                    var indices = d3.range(0, axisOptions.categoryLabels.length), xScaleForAxis = d3.scale.ordinal().domain(indices).rangeBands([ axisOptions.rangeStart, axisOptions.rangeEnd ], axisOptions.barToSpaceRatio, isHidingPercentBars ? axisOptions.barToSpaceRatio : FunnelChart.PercentBarToBarRatio), xAxis = d3.svg.axis().scale(xScaleForAxis).orient("right").tickPadding(FunnelChart.TickPadding).innerTickSize(FunnelChart.InnerTickSize).ticks(indices.length).tickValues(indices).tickFormat(function(i) {
                        return axisOptions.categoryLabels[i];
                    });
                    graphicsContext.attr("class", "axis hideLinesOnAxis").attr("transform", visuals.SVGUtil.translate(0, axisOptions.margin.top)).call(xAxis), 
                    graphicsContext.selectAll(".tick").call(visuals.tooltipUtils.tooltipUpdate, axisOptions.categoryLabels);
                    var leftRightMarginLimit = axisOptions.margin.left - FunnelChart.LabelFunnelPadding;
                    graphicsContext.selectAll(".tick text").call(visuals.AxisHelper.LabelLayoutStrategy.clip, leftRightMarginLimit, powerbi.TextMeasurementService.svgEllipsis);
                }, FunnelChart.drawDefaultShapes = function(data, dataPoints, graphicsContext, layout, hasSelection) {
                    var hasHighlights = data.hasHighlights, columns = graphicsContext.selectAll(FunnelChart.Selectors.funnel.bars.selector).data(dataPoints, function(d) {
                        return d.key;
                    });
                    return columns.enter().append("rect").attr("class", function(d) {
                        return d.highlight ? FunnelChart.FunnelBarHighlightClass : FunnelChart.Selectors.funnel.bars["class"];
                    }), columns.style("fill", function(d) {
                        return d.color;
                    }).style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, hasHighlights);
                    }).attr(layout.shapeLayout), columns.exit().remove(), columns;
                }, FunnelChart.getValueFromDataPoint = function(dataPoint, asOriginal) {
                    return void 0 === asOriginal && (asOriginal = !1), asOriginal ? dataPoint.highlight ? dataPoint.originalHighlightValue : dataPoint.originalValue : dataPoint.highlight ? dataPoint.highlightValue : dataPoint.value;
                }, FunnelChart.drawInteractorShapes = function(dataPoints, graphicsContext, layout) {
                    var interactorsData = dataPoints.filter(function(d) {
                        return !d.highlight && layout.interactorLayout.width(d) === FunnelChart.MinimumInteractorSize;
                    }), columns = graphicsContext.selectAll(FunnelChart.Selectors.funnel.interactors.selector).data(interactorsData, function(d) {
                        return d.key;
                    });
                    return columns.enter().append("rect").attr("class", FunnelChart.Selectors.funnel.interactors["class"]), 
                    columns.style("fill-opacity", 0).attr(layout.interactorLayout), columns.exit().remove(), 
                    columns;
                }, FunnelChart.drawPercentBarComponents = function(graphicsContext, data, layout, percentLabelSettings) {
                    var mainLine = graphicsContext.selectAll(FunnelChart.Selectors.percentBar.mainLine.selector).data(data);
                    mainLine.exit().remove(), mainLine.enter().append("line").classed(FunnelChart.Selectors.percentBar.mainLine["class"], !0), 
                    mainLine.attr(layout.percentBarLayout.mainLine);
                    var leftTick = graphicsContext.selectAll(FunnelChart.Selectors.percentBar.leftTick.selector).data(data);
                    leftTick.exit().remove(), leftTick.enter().append("line").classed(FunnelChart.Selectors.percentBar.leftTick["class"], !0), 
                    leftTick.attr(layout.percentBarLayout.leftTick);
                    var rightTick = graphicsContext.selectAll(FunnelChart.Selectors.percentBar.rightTick.selector).data(data);
                    rightTick.exit().remove(), rightTick.enter().append("line").classed(FunnelChart.Selectors.percentBar.rightTick["class"], !0), 
                    rightTick.attr(layout.percentBarLayout.rightTick);
                    var text = graphicsContext.selectAll(FunnelChart.Selectors.percentBar.text.selector).data(data), localizedString = visuals.valueFormatter.getLocalizedString("Percentage1");
                    text.exit().remove(), text.enter().append("text").classed(FunnelChart.Selectors.percentBar.text["class"], !0), 
                    text.attr(layout.percentBarLayout.text).text(function(fp) {
                        return visuals.dataLabelUtils.getLabelFormattedText({
                            label: fp.percent,
                            format: localizedString,
                            fontSize: percentLabelSettings.fontSize,
                            maxWidth: layout.percentBarLayout.text.maxWidth
                        });
                    }).append("title").text(function(d) {
                        return powerbi.formattingService.formatValue(d.percent, localizedString);
                    });
                }, FunnelChart.drawPercentBars = function(data, graphicsContext, layout, isHidingPercentBars) {
                    if (isHidingPercentBars || !data.dataPoints || (data.hasHighlights ? data.dataPoints.length / 2 : data.dataPoints.length) < 2) return void FunnelChart.drawPercentBarComponents(graphicsContext, [], layout, data.percentBarLabelSettings);
                    var dataPoints = [ data.dataPoints[data.hasHighlights ? 1 : 0], data.dataPoints[data.dataPoints.length - 1] ], baseline = FunnelChart.getValueFromDataPoint(dataPoints[0]);
                    if (0 >= baseline) return void FunnelChart.drawPercentBarComponents(graphicsContext, [], layout, data.percentBarLabelSettings);
                    var percentData = [ {
                        value: FunnelChart.getValueFromDataPoint(dataPoints[0]),
                        percent: 1,
                        isTop: !0
                    }, {
                        value: FunnelChart.getValueFromDataPoint(dataPoints[1]),
                        percent: FunnelChart.getValueFromDataPoint(dataPoints[1]) / baseline,
                        isTop: !1
                    } ];
                    FunnelChart.drawPercentBarComponents(graphicsContext, percentData, layout, data.percentBarLabelSettings);
                }, FunnelChart.prototype.showCategoryLabels = function() {
                    return !(this.funnelSmallViewPortProperties && this.funnelSmallViewPortProperties.hideFunnelCategoryLabelsOnSmallViewPort && this.currentViewport.height < this.funnelSmallViewPortProperties.minHeightFunnelCategoryLabelsVisible);
                }, FunnelChart.addFunnelPercentsToTooltip = function(pctFormatString, tooltipInfo, hostServices, percentOfFirst, percentOfPrevious, highlight) {
                    null != percentOfFirst && tooltipInfo.push({
                        displayName: hostServices.getLocalizedString("Funnel_PercentOfFirst" + (highlight ? "_Highlight" : "")),
                        value: visuals.valueFormatter.format(percentOfFirst, pctFormatString)
                    }), null != percentOfPrevious && tooltipInfo.push({
                        displayName: hostServices.getLocalizedString("Funnel_PercentOfPrevious" + (highlight ? "_Highlight" : "")),
                        value: visuals.valueFormatter.format(percentOfPrevious, pctFormatString)
                    });
                }, FunnelChart.getTextProperties = function(fontSize) {
                    return {
                        fontSize: PixelConverter.fromPoint(fontSize || visuals.dataLabelUtils.DefaultFontSizeInPt),
                        fontFamily: FunnelChart.DefaultFontFamily
                    };
                }, FunnelChart.getDefaultLabelSettings = function() {
                    return {
                        show: !0,
                        position: powerbi.visuals.labelPosition.insideCenter,
                        displayUnits: 0,
                        labelColor: null,
                        fontSize: LabelUtils.DefaultLabelFontSizeInPt
                    };
                }, FunnelChart.getDefaultPercentLabelSettings = function() {
                    return {
                        show: !0,
                        position: 0,
                        displayUnits: 0,
                        labelColor: LabelUtils.defaultLabelColor,
                        fontSize: LabelUtils.DefaultLabelFontSizeInPt
                    };
                }, FunnelChart.prototype.getLabels = function(layout) {
                    var labels = [];
                    if (this.data.dataLabelsSettings.show && this.data.canShowDataLabels) {
                        var labelDataPoints = this.createLabelDataPoints(layout.shapeLayout, this.data.dataLabelsSettings), newLabelLayout = new powerbi.LabelLayout({
                            maximumOffset: LabelUtils.maxLabelOffset,
                            startingOffset: LabelUtils.startingLabelOffset
                        }), labelDataPointsGroup = {
                            labelDataPoints: labelDataPoints,
                            maxNumberOfLabels: labelDataPoints.length
                        }, labelViewport = {
                            width: this.currentViewport.width - this.margin.left,
                            height: this.currentViewport.height - this.margin.top
                        };
                        labels = newLabelLayout.layout([ labelDataPointsGroup ], labelViewport);
                    }
                    return labels;
                }, FunnelChart.prototype.createLabelDataPoints = function(shapeLayout, visualSettings) {
                    var data = this.data, dataPoints = data.dataPoints;
                    if (_.isEmpty(dataPoints)) return [];
                    var points = new Array(), generalSettings = dataPoints[0], validPositions = FunnelChart.LabelInsidePosition, height = shapeLayout.height(generalSettings);
                    visualSettings.position && visualSettings.position === visuals.labelPosition.outsideEnd && (validPositions = FunnelChart.LabelOutsidePosition);
                    var maxAbsoluteValue = null;
                    0 === visualSettings.displayUnits && (maxAbsoluteValue = data.dataPoints.reduce(function(memo, value) {
                        return Math.abs(memo.value) > Math.abs(value.value) ? memo : value;
                    }).value);
                    for (var formatString = visuals.valueFormatter.getFormatString(data.valuesMetadata[0], visuals.funnelChartProps.general.formatString), formattersCache = LabelUtils.createColumnFormatterCacheManager(), fontSize = visualSettings.fontSize, properties = {
                        fontFamily: LabelUtils.LabelTextProperties.fontFamily,
                        fontSize: PixelConverter.fromPoint(fontSize || LabelUtils.DefaultLabelFontSizeInPt),
                        fontWeight: LabelUtils.LabelTextProperties.fontWeight
                    }, outsideFill = generalSettings.labelFill || LabelUtils.defaultLabelColor, insideFill = generalSettings.labelFill || LabelUtils.defaultInsideLabelColor, _i = 0, dataPoints_2 = dataPoints; _i < dataPoints_2.length; _i++) {
                        var dataPoint = dataPoints_2[_i], value = FunnelChart.getValueFromDataPoint(dataPoint, !0);
                        if (null != value && (!data.hasHighlights || dataPoint.highlight)) {
                            var labelFormatString = null != formatString ? formatString : generalSettings.labelFormatString, formatter = formattersCache.getOrCreate(labelFormatString, visualSettings, maxAbsoluteValue), labelText = formatter.format(value);
                            properties.text = labelText;
                            var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties), textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties), parentType = 1, shape = {
                                rect: {
                                    left: shapeLayout.x(dataPoint),
                                    top: shapeLayout.y(dataPoint),
                                    width: shapeLayout.width(dataPoint),
                                    height: height
                                },
                                orientation: FunnelChart.LabelOrientation,
                                validPositions: validPositions
                            }, point = {
                                isPreferred: !0,
                                text: labelText,
                                textSize: {
                                    width: textWidth,
                                    height: textHeight
                                },
                                fontSize: fontSize,
                                parentType: parentType,
                                parentShape: shape,
                                insideFill: insideFill,
                                outsideFill: outsideFill,
                                identity: dataPoint.identity,
                                hasBackground: !1
                            };
                            0 === dataPoint.value && (shape = {
                                validPositions: [ 256 ],
                                point: {
                                    x: shapeLayout.x(dataPoint),
                                    y: shapeLayout.y(dataPoint) + height / 2
                                }
                            }, parentType = 0, point.parentShape = shape, point.parentType = parentType, point.insideFill = point.outsideFill), 
                            points.push(point);
                        }
                    }
                    return points;
                }, FunnelChart.LabelInsidePosition = [ 1, 16 ], FunnelChart.LabelOutsidePosition = [ 16, 4 ], 
                FunnelChart.LabelOrientation = 3, FunnelChart.DefaultBarOpacity = 1, FunnelChart.DimmedBarOpacity = .4, 
                FunnelChart.PercentBarToBarRatio = .75, FunnelChart.TickPadding = 0, FunnelChart.InnerTickSize = 0, 
                FunnelChart.MinimumInteractorSize = 15, FunnelChart.InnerTextClassName = "labelSeries", 
                FunnelChart.Selectors = {
                    funnel: {
                        bars: createClassAndSelector("funnelBar"),
                        highlights: createClassAndSelector("highlight"),
                        interactors: createClassAndSelector("funnelBarInteractor")
                    },
                    percentBar: {
                        root: createClassAndSelector("percentBars"),
                        mainLine: createClassAndSelector("mainLine"),
                        leftTick: createClassAndSelector("leftTick"),
                        rightTick: createClassAndSelector("rightTick"),
                        text: createClassAndSelector("value")
                    }
                }, FunnelChart.FunnelBarHighlightClass = [ FunnelChart.Selectors.funnel.bars["class"], FunnelChart.Selectors.funnel.highlights["class"] ].join(" "), 
                FunnelChart.YAxisPadding = 10, FunnelChart.VisualClassName = "funnelChart", FunnelChart.DefaultFontFamily = visuals.Font.Family.regularSecondary.css, 
                FunnelChart.BarToSpaceRatio = .1, FunnelChart.MaxBarHeight = 40, FunnelChart.MinBarThickness = 12, 
                FunnelChart.LabelFunnelPadding = 6, FunnelChart.OverflowingHighlightWidthRatio = .5, 
                FunnelChart.MaxMarginFactor = .25, FunnelChart;
            }();
            visuals.FunnelChart = FunnelChart;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, PixelConverter = jsCommon.PixelConverter, DataRoleHelper = powerbi.data.DataRoleHelper, Gauge = function() {
                function Gauge(options) {
                    this.lastAngle = -Math.PI / 2, options && (options.gaugeSmallViewPortProperties && (this.gaugeSmallViewPortProperties = options.gaugeSmallViewPortProperties), 
                    this.animator = options.animator, this.tooltipsEnabled = options.tooltipsEnabled, 
                    this.tooltipBucketEnabled = options.tooltipBucketEnabled);
                }
                return Gauge.prototype.enumerateObjectInstances = function(options) {
                    var enumeration = new visuals.ObjectEnumerationBuilder();
                    switch (options.objectName) {
                      case "axis":
                        this.enumerateAxis(enumeration);
                        break;

                      case "labels":
                        var labelSettings = this.data ? this.data.dataLabelsSettings : visuals.dataLabelUtils.getDefaultGaugeLabelSettings();
                        visuals.dataLabelUtils.enumerateDataLabels(this.getDataLabelSettingsOptions(enumeration, labelSettings));
                        break;

                      case "calloutValue":
                        var labelSettings = this.data ? this.data.calloutValueLabelsSettings : visuals.dataLabelUtils.getDefaultGaugeLabelSettings();
                        visuals.dataLabelUtils.enumerateDataLabels(this.getDataLabelSettingsOptions(enumeration, labelSettings));
                        break;

                      case "dataPoint":
                        this.enumerateDataPoint(enumeration);
                    }
                    return enumeration.complete();
                }, Gauge.prototype.getDataLabelSettingsOptions = function(enumeration, labelSettings) {
                    return {
                        dataLabelsSettings: labelSettings,
                        show: !0,
                        precision: !0,
                        displayUnits: !0,
                        fontSize: !0,
                        enumeration: enumeration
                    };
                }, Gauge.prototype.enumerateAxis = function(enumeration) {
                    var dataView = this.dataView;
                    if (dataView && dataView.metadata) {
                        var properties = Gauge.getGaugeObjectsProperties(dataView);
                        enumeration.pushInstance({
                            selector: null,
                            objectName: "axis",
                            properties: properties
                        });
                    }
                }, Gauge.prototype.enumerateDataPoint = function(enumeration) {
                    var dataPointSettings = this.data ? this.data.dataPointSettings : Gauge.DefaultDataPointSettings, properties = {};
                    properties.fill = {
                        solid: {
                            color: dataPointSettings.fillColor
                        }
                    }, null != dataPointSettings.targetColor && (properties.target = {
                        solid: {
                            color: dataPointSettings.targetColor
                        }
                    }), enumeration.pushInstance({
                        selector: null,
                        objectName: visuals.gaugeProps.dataPoint.target.objectName,
                        properties: properties
                    });
                }, Gauge.getGaugeObjectsProperties = function(dataView) {
                    var properties = {}, objects = dataView.metadata.objects, hasAxisObject = !!objects && !!objects.axis;
                    return DataRoleHelper.hasRoleInDataView(dataView, visuals.gaugeRoleNames.minValue) || (properties.min = hasAxisObject ? objects.axis.min : void 0), 
                    DataRoleHelper.hasRoleInDataView(dataView, visuals.gaugeRoleNames.maxValue) || (properties.max = hasAxisObject ? objects.axis.max : void 0), 
                    DataRoleHelper.hasRoleInDataView(dataView, visuals.gaugeRoleNames.targetValue) || (properties.target = hasAxisObject ? objects.axis.target : void 0), 
                    properties;
                }, Gauge.prototype.init = function(options) {
                    this.element = options.element, this.currentViewport = options.viewport, this.style = options.style, 
                    this.options = options, this.settings = Gauge.DefaultStyleProperties, this.targetSettings = Gauge.DefaultTargetSettings, 
                    this.setMargins(), this.color = d3.scale.ordinal().range(this.style.colorPalette.dataColors.getSentimentColors().map(function(color) {
                        return color.value;
                    })), this.hostService = options.host;
                    var svg = this.svg = d3.select(this.element.get(0)).append("svg");
                    svg.classed(Gauge.VisualClassName, !0);
                    var mainGraphicsContext = this.mainGraphicsContext = svg.append("g");
                    mainGraphicsContext.attr("class", Gauge.MainGaugeGroupClassName), this.initKpiBands();
                    var backgroundArc = this.backgroundArc = d3.svg.arc().innerRadius(0).outerRadius(0).startAngle(-Math.PI / 2).endAngle(Math.PI / 2), foregroundArc = this.foregroundArc = d3.svg.arc().innerRadius(0).outerRadius(0).startAngle(-Math.PI / 2);
                    this.backgroundArcPath = mainGraphicsContext.append("path").classed("backgroundArc", !0).attr("d", backgroundArc), 
                    this.foregroundArcPath = mainGraphicsContext.append("path").datum({
                        endAngle: -Math.PI / 2
                    }).classed("foregroundArc", !0).attr("d", foregroundArc);
                    var g = this.animatedNumberGrapicsContext = svg.append("g");
                    this.animatedNumber = new visuals.AnimatedNumber(g), this.animatedNumber.init(options);
                    var gaugeDrawingOptions = this.gaugeVisualProperties = this.getGaugeVisualProperties(), animatedNumberProperties = this.getAnimatedNumberProperties(gaugeDrawingOptions.radius, gaugeDrawingOptions.innerRadiusFactor, gaugeDrawingOptions.top, gaugeDrawingOptions.left);
                    this.animatedNumberGrapicsContext.attr("transform", animatedNumberProperties.transformString), 
                    this.animatedNumber.onResizing(animatedNumberProperties.viewport);
                }, Gauge.prototype.update = function(options) {
                    if (this.currentViewport = options.viewport, options.dataViews && options.dataViews[0]) {
                        var dataView = this.dataView = options.dataViews[0], reader = powerbi.data.createIDataViewCategoricalReader(dataView);
                        this.data = Gauge.converter(reader, this.tooltipBucketEnabled), this.targetSettings = this.data.targetSettings, 
                        this.dataView.single = {
                            value: this.data.total
                        }, this.labels = this.createLabels(), this.showTargetLabel = null != this.targetSettings.target && this.targetSettings.target >= this.targetSettings.min && this.targetSettings.target <= this.targetSettings.max && (this.currentViewport.width > Gauge.MinWidthForTargetLabel || 2 !== this.getLabelsPosition()) && this.showSideNumbersLabelText() && this.data.dataLabelsSettings.show, 
                        this.setMargins(), this.gaugeVisualProperties = this.getGaugeVisualProperties(), 
                        this.drawViewPort(this.gaugeVisualProperties), this.updateInternal(options.suppressAnimations), 
                        this.updateCalloutValue(options.suppressAnimations);
                        var warnings = visuals.getInvalidValueWarnings([ dataView ], !1, !1, !1);
                        this.hostService.setWarnings(warnings);
                    }
                }, Gauge.prototype.updateCalloutValue = function(suppressAnimations) {
                    if (this.data.calloutValueLabelsSettings.show) {
                        var animatedNumberProperties = this.getAnimatedNumberProperties(this.gaugeVisualProperties.radius, this.gaugeVisualProperties.innerRadiusFactor, this.gaugeVisualProperties.top, this.gaugeVisualProperties.left);
                        this.animatedNumberGrapicsContext.attr("transform", animatedNumberProperties.transformString), 
                        this.animatedNumber.setTextColor(this.data.calloutValueLabelsSettings.labelColor);
                        var calloutValue = this.data ? this.data.total : null, formatter = this.getFormatter(this.data.calloutValueLabelsSettings, this.data.metadataColumn, calloutValue);
                        this.animatedNumber.setFormatter(formatter), this.animatedNumber.update({
                            viewport: animatedNumberProperties.viewport,
                            dataViews: [ this.dataView ],
                            suppressAnimations: suppressAnimations
                        }), this.animatedNumberGrapicsContext.selectAll("title").remove(), this.animatedNumberGrapicsContext.append("title").text([ formatter.format(calloutValue) ]);
                    } else this.animatedNumber.clear(), this.animatedNumberGrapicsContext.selectAll("title").remove();
                }, Gauge.prototype.onDataChanged = function(options) {
                    this.update({
                        dataViews: options.dataViews,
                        suppressAnimations: options.suppressAnimations,
                        viewport: this.currentViewport
                    });
                }, Gauge.prototype.onResizing = function(viewport) {
                    this.update({
                        dataViews: [ this.dataView ],
                        suppressAnimations: !0,
                        viewMode: 0,
                        viewport: viewport
                    });
                }, Gauge.parseGaugeData = function(reader, tooltipBucketEnabled) {
                    var dataViewObjects = reader.getStaticObjects(), valueMetadata = reader.getValueMetadataColumn(visuals.gaugeRoleNames.y), axisObject = dataViewObjects ? dataViewObjects.axis : null, isValueDefined = reader.hasValues(visuals.gaugeRoleNames.y), isMaxDefined = reader.hasValues(visuals.gaugeRoleNames.maxValue), isMinDefined = reader.hasValues(visuals.gaugeRoleNames.minValue), valueIndex = 0, data = {
                        max: null,
                        min: null,
                        target: null,
                        value: null,
                        tooltipItems: []
                    };
                    if (isValueDefined) {
                        data.value = reader.getValue(visuals.gaugeRoleNames.y, valueIndex);
                        var value = visuals.converterHelper.formatFromMetadataColumn(data.value, valueMetadata, Gauge.formatStringProp);
                        data.tooltipItems.push({
                            displayName: reader.getValueDisplayName(visuals.gaugeRoleNames.y),
                            value: value
                        });
                    }
                    if (reader.hasValues(visuals.gaugeRoleNames.targetValue)) {
                        var targetMetadata = reader.getValueMetadataColumn(visuals.gaugeRoleNames.targetValue);
                        data.target = reader.getValue(visuals.gaugeRoleNames.targetValue, valueIndex);
                        var value = visuals.converterHelper.formatFromMetadataColumn(data.target, targetMetadata, Gauge.formatStringProp);
                        data.tooltipItems.push({
                            displayName: reader.getValueDisplayName(visuals.gaugeRoleNames.targetValue),
                            value: value
                        });
                    } else axisObject && (data.target = axisObject.target);
                    if (isMaxDefined) data.max = reader.getValue(visuals.gaugeRoleNames.maxValue, valueIndex); else if (axisObject && null != axisObject.max) data.max = axisObject.max; else if (data.max = Gauge.DEFAULT_MAX, 
                    isValueDefined && data.value && 0 !== data.value) {
                        var hasPercent = !1;
                        if (valueMetadata) {
                            var formatString = visuals.valueFormatter.getFormatString(valueMetadata, Gauge.formatStringProp, !0);
                            null != formatString && (hasPercent = visuals.valueFormatter.getFormatMetadata(formatString).hasPercent);
                        }
                        hasPercent || isMinDefined || (data.max = data.value < 0 ? Gauge.DEFAULT_MIN : 2 * data.value);
                    }
                    return isMinDefined ? data.min = reader.getValue(visuals.gaugeRoleNames.minValue, valueIndex) : axisObject && null != axisObject.min ? data.min = axisObject.min : (data.min = Gauge.DEFAULT_MIN, 
                    !isMaxDefined && isValueDefined && null != data.value && data.value < 0 && (data.min = 2 * data.value)), 
                    tooltipBucketEnabled && visuals.TooltipBuilder.addTooltipBucketItem(reader, data.tooltipItems, 0), 
                    data;
                }, Gauge.converter = function(reader, tooltipBucketEnabled) {
                    void 0 === tooltipBucketEnabled && (tooltipBucketEnabled = !0);
                    var objectSettings = reader.getStaticObjects(), metadataColumn = reader.getValueMetadataColumn(visuals.gaugeRoleNames.y), gaugeData = Gauge.parseGaugeData(reader, tooltipBucketEnabled), value = gaugeData.value;
                    return {
                        total: value,
                        tooltipInfo: gaugeData.tooltipItems,
                        maxColumnMetadata: reader.getValueMetadataColumn(visuals.gaugeRoleNames.maxValue),
                        minColumnMetadata: reader.getValueMetadataColumn(visuals.gaugeRoleNames.minValue),
                        targetColumnMetadata: reader.getValueMetadataColumn(visuals.gaugeRoleNames.targetValue),
                        metadataColumn: metadataColumn,
                        targetSettings: {
                            min: gaugeData.min,
                            max: gaugeData.max,
                            target: gaugeData.target
                        },
                        dataLabelsSettings: Gauge.convertDataLabelSettings(objectSettings, "labels"),
                        calloutValueLabelsSettings: Gauge.convertDataLabelSettings(objectSettings, "calloutValue"),
                        dataPointSettings: Gauge.convertDataPointSettings(objectSettings, gaugeData)
                    };
                }, Gauge.convertDataLabelSettings = function(objects, objectName) {
                    var dataLabelsSettings = visuals.dataLabelUtils.getDefaultGaugeLabelSettings();
                    if (objects) {
                        var labelsObj = objects[objectName];
                        visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, dataLabelsSettings);
                    }
                    return dataLabelsSettings;
                }, Gauge.convertDataPointSettings = function(objects, targetSettings) {
                    var targetColor, fillColor = Gauge.DefaultDataPointSettings.fillColor;
                    return objects ? (fillColor = powerbi.DataViewObjects.getFillColor(objects, visuals.gaugeProps.dataPoint.fill, Gauge.DefaultDataPointSettings.fillColor), 
                    targetSettings && null != targetSettings.target && (targetColor = powerbi.DataViewObjects.getFillColor(objects, visuals.gaugeProps.dataPoint.target, Gauge.DefaultDataPointSettings.targetColor))) : targetSettings && null != targetSettings.target && (targetColor = Gauge.DefaultDataPointSettings.targetColor), 
                    {
                        fillColor: fillColor,
                        targetColor: targetColor
                    };
                }, Gauge.prototype.initKpiBands = function() {
                    if (this.settings.kpiBands.show) for (var kpiArcs = this.kpiArcs = [], kpiArcPaths = this.kpiArcPaths = [], mainGraphicsContext = this.mainGraphicsContext, i = 0; 3 > i; i++) {
                        var arc = d3.svg.arc().innerRadius(0).outerRadius(0).startAngle(0).endAngle(0);
                        kpiArcs.push(arc);
                        var arcPath = mainGraphicsContext.append("path").attr("d", arc);
                        kpiArcPaths.push(arcPath);
                    }
                }, Gauge.prototype.isValid = function() {
                    if (!this.data || !this.data.targetSettings) return !1;
                    var targetSettings = this.data.targetSettings;
                    return $.isNumeric(targetSettings.min) && $.isNumeric(targetSettings.max) || targetSettings.min > targetSettings.max;
                }, Gauge.prototype.updateKpiBands = function(radius, innerRadiusFactor, tString, kpiAngleAttr) {
                    if (this.settings.kpiBands.show) for (var i = 0; i < kpiAngleAttr.length; i++) this.kpiArcs[i].innerRadius(radius * innerRadiusFactor - (Gauge.KpiBandDistanceFromMainArc + this.settings.kpiBands.thickness)).outerRadius(radius * innerRadiusFactor - Gauge.KpiBandDistanceFromMainArc).startAngle(kpiAngleAttr[i].start).endAngle(kpiAngleAttr[i].end), 
                    this.kpiArcPaths[i].attr("fill", kpiAngleAttr[i].fill).attr("d", this.kpiArcs[i]).attr("transform", tString);
                }, Gauge.prototype.removeTargetElements = function() {
                    this.targetLine && (this.targetLine.remove(), this.targetText.remove(), this.targetConnector.remove(), 
                    this.targetLine = this.targetConnector = this.targetText = null);
                }, Gauge.prototype.getTargetRatio = function() {
                    var targetSettings = this.targetSettings, range = targetSettings.max - targetSettings.min;
                    return 0 !== range ? (targetSettings.target - targetSettings.min) / range : 0;
                }, Gauge.prototype.updateTargetLine = function(radius, innerRadius, left, top) {
                    this.targetLine || (this.targetLine = this.mainGraphicsContext.append("line"));
                    var angle = this.getTargetRatio() * Math.PI, outY = top - radius * Math.sin(angle), outX = left - radius * Math.cos(angle), inY = top - innerRadius * Math.sin(angle), inX = left - innerRadius * Math.cos(angle);
                    this.targetLine.attr({
                        x1: inX,
                        y1: inY,
                        x2: outX,
                        y2: outY
                    });
                }, Gauge.prototype.getAnimatedNumberProperties = function(radius, innerRadiusFactor, top, left) {
                    var boxAngle = Math.PI / 4, scale = 1, innerRadiusOfArc = radius * innerRadiusFactor, innerRadiusForTextBoundingBox = innerRadiusOfArc - (this.settings.kpiBands.show ? Gauge.KpiBandDistanceFromMainArc + this.settings.kpiBands.thickness : 0), innerRCos = innerRadiusForTextBoundingBox * Math.cos(boxAngle), innerRSin = innerRadiusForTextBoundingBox * Math.sin(boxAngle), innerY = top - innerRSin, innerX = left - innerRCos;
                    innerY *= scale, innerX *= scale;
                    var animatedNumberWidth = 2 * innerRCos, properties = {
                        transformString: visuals.SVGUtil.translate(innerX, innerY),
                        viewport: {
                            height: innerRSin,
                            width: animatedNumberWidth
                        }
                    };
                    return properties;
                }, Gauge.prototype.getGaugeVisualProperties = function() {
                    var viewport = this.currentViewport, margin = this.margin, width = viewport.width - margin.right - margin.left, halfWidth = width / 2, height = viewport.height - margin.top - margin.bottom, radius = Math.min(halfWidth, height), innerRadiusFactor = Gauge.InnerRadiusFactor, left = margin.left + halfWidth, top = radius + (height - radius) / 2 + margin.top, tString = visuals.SVGUtil.translate(left, top), innerRadiusOfArc = radius * innerRadiusFactor, gaugeData = {
                        radius: radius,
                        innerRadiusOfArc: innerRadiusOfArc,
                        left: left,
                        top: top,
                        height: height,
                        width: width,
                        margin: margin,
                        transformString: tString,
                        innerRadiusFactor: innerRadiusFactor
                    };
                    return gaugeData;
                }, Gauge.prototype.drawViewPort = function(drawOptions) {
                    var separation = this.settings.kpiBands.separationRadians, innerRadiusFactor = Gauge.InnerRadiusFactor, backgroudArc = this.backgroundArc, color = this.color, attrs = [ {
                        fill: color(0),
                        start: -Math.PI / 2,
                        end: -Math.PI / 2 + Math.PI / 4 - separation
                    }, {
                        fill: color(1),
                        start: -Math.PI / 2 + 1 * Math.PI / 4 + separation,
                        end: -Math.PI / 2 + 3 * Math.PI / 4 - separation
                    }, {
                        fill: color(2),
                        start: -Math.PI / 2 + 3 * Math.PI / 4 + separation,
                        end: Math.PI / 2
                    } ], radius = drawOptions.radius, transformString = drawOptions.transformString;
                    this.updateKpiBands(radius, innerRadiusFactor, transformString, attrs), backgroudArc.innerRadius(radius * innerRadiusFactor).outerRadius(radius).startAngle(-Math.PI / 2).endAngle(Math.PI / 2), 
                    this.backgroundArcPath.attr("d", backgroudArc).attr("transform", transformString);
                    var foregroundArc = this.foregroundArc;
                    foregroundArc.innerRadius(radius * innerRadiusFactor).outerRadius(radius).startAngle(-Math.PI / 2), 
                    this.foregroundArcPath.datum({
                        endAngle: this.lastAngle
                    }).attr("transform", transformString).attr("d", foregroundArc);
                    var innerRadiusOfArc = drawOptions.innerRadiusOfArc, left = drawOptions.left, top = drawOptions.top, margin = drawOptions.margin, height = drawOptions.height, targetSettings = this.targetSettings;
                    this.settings.targetLine.show && this.isValid() && $.isNumeric(targetSettings.target) ? targetSettings.min > targetSettings.target || targetSettings.max < targetSettings.target ? this.removeTargetElements() : (this.updateTargetLine(radius, innerRadiusOfArc, left, top), 
                    this.renderTarget(radius, height, drawOptions.width, margin)) : this.removeTargetElements(), 
                    this.svg.attr("height", this.currentViewport.height).attr("width", this.currentViewport.width);
                }, Gauge.prototype.getValueAngle = function() {
                    var settings = this.data.targetSettings, total = this.data.total;
                    if (!this.isValid() || !$.isNumeric(total)) return 0;
                    var adjustedTotal = Math.min(Math.max(total, settings.min), settings.max), angle = (adjustedTotal - settings.min) / (settings.max - settings.min);
                    return angle;
                }, Gauge.prototype.createLabels = function() {
                    var targetSettings = this.targetSettings, arr = [], label = null, textProperties = {
                        fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                        fontSize: PixelConverter.fromPoint(this.data.dataLabelsSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt),
                        fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight
                    }, minFormatter = this.getFormatter(this.data.dataLabelsSettings, this.data.minColumnMetadata, targetSettings.max);
                    textProperties.text = minFormatter.format(targetSettings.min), label = {
                        size: {
                            width: powerbi.TextMeasurementService.measureSvgTextWidth(textProperties),
                            height: powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties)
                        },
                        text: textProperties.text
                    }, arr.push(label);
                    var maxFormatter = this.getFormatter(this.data.dataLabelsSettings, this.data.maxColumnMetadata, targetSettings.max);
                    return textProperties.text = maxFormatter.format(targetSettings.max), label = {
                        size: {
                            width: powerbi.TextMeasurementService.measureSvgTextWidth(textProperties),
                            height: powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties)
                        },
                        text: textProperties.text
                    }, arr.push(label), arr;
                }, Gauge.prototype.updateInternal = function(suppressAnimations) {
                    var height = this.gaugeVisualProperties.height, width = this.gaugeVisualProperties.width, radius = this.gaugeVisualProperties.radius, margin = this.margin, duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations), data = this.data, lastAngle = this.lastAngle = -Math.PI / 2 + Math.PI * this.getValueAngle();
                    this.foregroundArcPath.transition().ease(this.settings.transition.ease).duration(duration).call(this.arcTween, [ lastAngle, this.foregroundArc ]), 
                    this.renderMinMaxLabels(this.labels, radius, height, width, margin), this.updateVisualConfigurations(), 
                    this.updateVisualStyles(), this.tooltipsEnabled && (visuals.TooltipManager.addTooltip(this.foregroundArcPath, function(tooltipEvent) {
                        return data.tooltipInfo;
                    }), visuals.TooltipManager.addTooltip(this.backgroundArcPath, function(tooltipEvent) {
                        return data.tooltipInfo;
                    }));
                }, Gauge.prototype.updateVisualStyles = function() {
                    var fillColor = this.data.dataLabelsSettings.labelColor || this.style.labelText.color.value;
                    this.mainGraphicsContext.selectAll("text").style({
                        fill: fillColor
                    });
                }, Gauge.prototype.updateVisualConfigurations = function() {
                    var configOptions = this.settings, dataPointSettings = this.data.dataPointSettings;
                    this.mainGraphicsContext.select("line").attr({
                        stroke: dataPointSettings.targetColor,
                        "stroke-width": configOptions.targetLine.thickness
                    }), this.backgroundArcPath.style("fill", configOptions.arcColors.background), this.foregroundArcPath.style("fill", dataPointSettings.fillColor);
                }, Gauge.prototype.renderMinMaxLabels = function(ticks, radius, height, width, margin) {
                    if (this.svg.selectAll(Gauge.LabelText.selector).remove(), this.data.dataLabelsSettings.show) for (var total = ticks.length, divisor = total - 1, position = this.getLabelsPosition(), fontSize = PixelConverter.fromPoint(this.data.dataLabelsSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt), padding = this.settings.labels.padding, index = 0; total > index; index++) {
                        var y = this.gaugeVisualProperties.top, textProperties = {
                            text: ticks[index].text,
                            fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                            fontSize: PixelConverter.fromPoint(this.data.dataLabelsSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt),
                            fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight
                        };
                        if (this.showSideNumbersLabelText()) {
                            var x = margin.left + width / 2 - radius * Math.cos(Math.PI * index / divisor), anchor = void 0, onRight = 1 === index, onBottom = !1;
                            2 === position ? (onBottom = !0, y += padding, anchor = onRight ? "end" : "start", 
                            textProperties.text = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, radius)) : (anchor = onRight ? "start" : "end", 
                            x += padding * (onRight ? 1 : -1));
                            var text = this.mainGraphicsContext.append("text").attr({
                                x: x,
                                y: y,
                                dy: onBottom ? fontSize : 0,
                                "class": Gauge.LabelText["class"]
                            }).style({
                                "text-anchor": anchor,
                                "font-size": fontSize
                            }).text(textProperties.text).append("title").text(textProperties.text);
                            onBottom || this.truncateTextIfNeeded(text, x, onRight);
                        }
                    }
                }, Gauge.prototype.truncateTextIfNeeded = function(text, positionX, onRight) {
                    var availableSpace = onRight ? this.currentViewport.width - positionX : positionX;
                    text.call(visuals.AxisHelper.LabelLayoutStrategy.clip, availableSpace, powerbi.TextMeasurementService.svgEllipsis);
                }, Gauge.prototype.getFormatter = function(dataLabelSettings, metadataColumn, maxValue) {
                    var max = 0 === dataLabelSettings.displayUnits ? maxValue : null;
                    metadataColumn && metadataColumn.objects && !_.isEmpty(powerbi.DataViewObjects.getValue(metadataColumn.objects, Gauge.formatStringProp)) || (metadataColumn = this.data.metadataColumn);
                    var formatString = visuals.valueFormatter.getFormatString(metadataColumn, Gauge.formatStringProp), precision = visuals.dataLabelUtils.getLabelPrecision(dataLabelSettings.precision, formatString), valueFormatterOptions = visuals.dataLabelUtils.getOptionsForLabelFormatter(dataLabelSettings, formatString, max, precision);
                    return valueFormatterOptions.formatSingleValues = !(dataLabelSettings.displayUnits > 0), 
                    visuals.valueFormatter.create(valueFormatterOptions);
                }, Gauge.prototype.renderTarget = function(radius, height, width, margin) {
                    var targetSettings = this.targetSettings, target = targetSettings.target, tRatio = this.getTargetRatio(), top = radius + (height - radius) / 2 + margin.top, flag = tRatio > .5, padding = this.settings.labels.padding, anchor = flag ? "start" : "end", formatter = this.getFormatter(this.data.dataLabelsSettings, this.data.targetColumnMetadata, targetSettings.max), maxRatio = Math.asin(Gauge.MinDistanceFromBottom / radius) / Math.PI, finalRatio = maxRatio > tRatio || tRatio > 1 - maxRatio ? flag ? 1 - maxRatio : maxRatio : tRatio, targetX = margin.left + width / 2 - (radius + padding) * Math.cos(Math.PI * finalRatio), targetY = top - (radius + padding) * Math.sin(Math.PI * finalRatio);
                    this.targetText || (this.targetText = this.mainGraphicsContext.append("text").classed(Gauge.TargetText["class"], !0)), 
                    this.targetText.attr({
                        x: targetX,
                        y: targetY
                    }).style({
                        "text-anchor": anchor,
                        display: this.showTargetLabel ? "" : "none",
                        "font-size": this.style.labelText.fontSize
                    }).text(formatter.format(target)), this.truncateTextIfNeeded(this.targetText, targetX, flag), 
                    this.targetText.call(visuals.tooltipUtils.tooltipUpdate, [ formatter.format(target) ]), 
                    this.targetConnector || (this.targetConnector = this.mainGraphicsContext.append("line").classed(Gauge.TargetConnector["class"], !0)), 
                    tRatio === finalRatio ? this.targetConnector.style("display", "none") : this.targetConnector.attr({
                        x1: margin.left + width / 2 - radius * Math.cos(Math.PI * tRatio),
                        y1: top - radius * Math.sin(Math.PI * tRatio),
                        x2: targetX,
                        y2: targetY
                    }).style({
                        "stroke-width": this.settings.targetLine.thickness,
                        stroke: this.settings.targetLine.color,
                        display: ""
                    });
                }, Gauge.prototype.arcTween = function(transition, arr) {
                    transition.attrTween("d", function(d) {
                        var interpolate = d3.interpolate(d.endAngle, arr[0]);
                        return function(t) {
                            return d.endAngle = interpolate(t), arr[1](d);
                        };
                    });
                }, Gauge.prototype.getLabelsPosition = function() {
                    if (!this.data || !this.data.dataLabelsSettings.show || _.isEmpty(this.labels)) return 0;
                    var textWidth = this.labels[0].size.width + this.labels[1].size.width, textHeight = this.labels[0].size.height;
                    if (this.currentViewport.height - textHeight > (this.currentViewport.width - textWidth) / 2) return 2;
                    if (this.gaugeVisualProperties) for (var labels = this.labels, visualWhitespace = (this.currentViewport.width - 2 * this.gaugeVisualProperties.radius) / 2, maxLabelWidth = visualWhitespace - this.settings.labels.padding, _i = 0, labels_1 = labels; _i < labels_1.length; _i++) {
                        var label = labels_1[_i];
                        if (label.size.width > maxLabelWidth) return 2;
                    }
                    return 1;
                }, Gauge.prototype.setMargins = function() {
                    if (this.gaugeSmallViewPortProperties && this.gaugeSmallViewPortProperties.smallGaugeMarginsOnSmallViewPort && this.currentViewport.height < this.gaugeSmallViewPortProperties.MinHeightGaugeSideNumbersVisible) {
                        var margins = this.gaugeSmallViewPortProperties.GaugeMarginsOnSmallViewPort;
                        return void (this.margin = {
                            top: margins,
                            bottom: margins,
                            left: margins,
                            right: margins
                        });
                    }
                    var labelsPosition = this.getLabelsPosition();
                    if (this.margin = {
                        bottom: 0,
                        left: 0,
                        right: 0,
                        top: this.showTargetLabel ? Gauge.DefaultTopBottomMargin : 0
                    }, 2 === labelsPosition) {
                        if (this.margin.bottom = this.labels[0].size.height + 2 * this.settings.labels.padding, 
                        this.showTargetLabel) {
                            var targetSettings = this.targetSettings, tRatio = (targetSettings.target - targetSettings.min) / (targetSettings.max - targetSettings.min);
                            tRatio > .5 ? this.margin.left = Gauge.ReducedLeftRightMargin : this.margin.right = Gauge.ReducedLeftRightMargin;
                        }
                    } else if (1 === labelsPosition) {
                        var padding = 2 * this.settings.labels.padding;
                        this.margin.left = this.labels[0].size.width + padding, this.margin.right = this.labels[1].size.width + padding, 
                        this.margin.bottom = padding;
                    }
                }, Gauge.prototype.showSideNumbersLabelText = function() {
                    return !(this.gaugeSmallViewPortProperties && this.gaugeSmallViewPortProperties.hideGaugeSideNumbersOnSmallViewPort && this.currentViewport.height < this.gaugeSmallViewPortProperties.MinHeightGaugeSideNumbersVisible);
                }, Gauge.MinDistanceFromBottom = 10, Gauge.MinWidthForTargetLabel = 150, Gauge.DefaultTopBottomMargin = 20, 
                Gauge.ReducedLeftRightMargin = 15, Gauge.DEFAULT_MAX = 1, Gauge.DEFAULT_MIN = 0, 
                Gauge.VisualClassName = "gauge", Gauge.DefaultStyleProperties = {
                    transition: {
                        ease: "cubic-in-out"
                    },
                    arcColors: {
                        background: "#e9e9e9",
                        foreground: "#00B8AA"
                    },
                    targetLine: {
                        show: !0,
                        color: "#666666",
                        thickness: 2
                    },
                    labels: {
                        count: 2,
                        padding: 5,
                        fontSize: visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt
                    },
                    kpiBands: {
                        show: !1,
                        separationRadians: Math.PI / 128,
                        thickness: 5
                    }
                }, Gauge.DefaultTargetSettings = {
                    min: 0,
                    max: 1,
                    target: void 0
                }, Gauge.DefaultDataPointSettings = {
                    fillColor: Gauge.DefaultStyleProperties.arcColors.foreground,
                    targetColor: Gauge.DefaultStyleProperties.targetLine.color
                }, Gauge.InnerRadiusFactor = .7, Gauge.KpiBandDistanceFromMainArc = 2, Gauge.MainGaugeGroupClassName = "mainGroup", 
                Gauge.LabelText = createClassAndSelector("labelText"), Gauge.TargetConnector = createClassAndSelector("targetConnector"), 
                Gauge.TargetText = createClassAndSelector("targetText"), Gauge.formatStringProp = {
                    objectName: "general",
                    propertyName: "formatString"
                }, Gauge;
            }();
            visuals.Gauge = Gauge;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var Utility = jsCommon.Utility, ImageVisual = function() {
                function ImageVisual() {
                    this.scalingType = visuals.imageScalingType.normal;
                }
                return ImageVisual.prototype.init = function(options) {
                    this.element = options.element;
                }, ImageVisual.prototype.enumerateObjectInstances = function(options) {
                    switch (options.objectName) {
                      case "imageScaling":
                        return this.enumerateImageScaling();
                    }
                    return null;
                }, ImageVisual.prototype.enumerateImageScaling = function() {
                    return [ {
                        selector: null,
                        objectName: "imageScaling",
                        properties: {
                            imageScalingType: this.scalingType
                        }
                    } ];
                }, ImageVisual.prototype.update = function(options) {
                    var dataViews = options.dataViews;
                    if (dataViews && 0 !== dataViews.length) {
                        var objects = dataViews[0].metadata.objects;
                        if (objects && objects.general) {
                            var div = this.imageBackgroundElement;
                            div || (div = $("<div class='imageBackground' />"), this.imageBackgroundElement = div, 
                            this.imageBackgroundElement.appendTo(this.element));
                            var viewport = options.viewport;
                            div.css("height", viewport.height), objects.imageScaling ? this.scalingType = objects.imageScaling.imageScalingType.toString() : this.scalingType = visuals.imageScalingType.normal;
                            var imageUrl = objects.general.imageUrl;
                            Utility.isLocalUrl(imageUrl) && div.css("backgroundImage", "url(" + imageUrl + ")"), 
                            this.scalingType === visuals.imageScalingType.fit ? div.css("background-size", "100% 100%") : this.scalingType === visuals.imageScalingType.fill ? div.css("background-size", "cover") : div.css("background-size", "contain");
                        }
                    }
                }, ImageVisual;
            }();
            visuals.ImageVisual = ImageVisual;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            function GetStatus(actual, goals, directionType) {
                if (!goals || 0 === goals.length) return KPIStatusWithHistory.status.NOGOAL;
                var maxGoal, minGoal;
                if (2 === goals.length) {
                    if (maxGoal = Math.max.apply(Math, goals), minGoal = Math.min.apply(Math, goals), 
                    actual >= minGoal && maxGoal >= actual) return KPIStatusWithHistory.status.IN_BETWEEN;
                } else maxGoal = goals[0], minGoal = goals[0];
                switch (directionType) {
                  case visuals.kpiDirection.positive:
                    if (minGoal > actual) return KPIStatusWithHistory.status.DROP;
                    break;

                  case visuals.kpiDirection.negative:
                    if (actual > maxGoal) return KPIStatusWithHistory.status.DROP;
                }
                return KPIStatusWithHistory.status.INCREASE;
            }
            function getDistanceFromGoalInPercentageString(actual, goals, directionType) {
                if (!goals || 1 !== goals.length || 0 === goals[0]) return "";
                var distance, sign = "+", goal = goals[0];
                switch (distance = Math.abs(actual - goal), directionType) {
                  case visuals.kpiDirection.positive:
                    goal > actual && (sign = "-");
                    break;

                  case visuals.kpiDirection.negative:
                    actual > goal && (sign = "-");
                }
                var percent = Number((100 * distance / goal).toFixed(2));
                return "(" + sign + percent + "%)";
            }
            function GetTextColorClassByStatus(status) {
                switch (status) {
                  case KPIStatusWithHistory.status.NOGOAL:
                    return KPIStatusWithHistory.kpiTextGreyClass;

                  case KPIStatusWithHistory.status.INCREASE:
                    return KPIStatusWithHistory.kpiGreenClass;

                  case KPIStatusWithHistory.status.IN_BETWEEN:
                    return KPIStatusWithHistory.kpiYellowClass;

                  case KPIStatusWithHistory.status.DROP:
                    return KPIStatusWithHistory.kpiRedClass;
                }
            }
            function GetGraphColorClassByStatus(status) {
                switch (status) {
                  case KPIStatusWithHistory.status.NOGOAL:
                    return KPIStatusWithHistory.kpiGraphGreyClass;

                  case KPIStatusWithHistory.status.INCREASE:
                    return KPIStatusWithHistory.kpiGreenClass;

                  case KPIStatusWithHistory.status.IN_BETWEEN:
                    return KPIStatusWithHistory.kpiYellowClass;

                  case KPIStatusWithHistory.status.DROP:
                    return KPIStatusWithHistory.kpiRedClass;
                }
            }
            var DataRoleHelper = powerbi.data.DataRoleHelper, KPIStatusWithHistory = function() {
                function KPIStatusWithHistory() {}
                return KPIStatusWithHistory.prototype.init = function(options) {
                    KPIStatusWithHistory.getLocalizedString = options.host.getLocalizedString, this.rootElement = d3.select(options.element.get(0)).append("div").attr("text-align", "center").classed("kpiVisual", !0), 
                    this.svg = this.rootElement.append("svg");
                    var mainGroupElement = this.mainGroupElement = this.svg.append("g");
                    this.areaFill = mainGroupElement.append("path"), this.textContainer = this.rootElement.append("div").classed("textContainer", !0), 
                    this.indicatorTextContainer = this.textContainer.append("div").classed("indicatorText", !0), 
                    this.absoluteGoalDistanceText = this.textContainer.append("div").classed("goalText", !0), 
                    this.kpiActualText = this.indicatorTextContainer.append("div").attr("id", "indicatorText"), 
                    this.initIcons(), this.host = options.host;
                }, KPIStatusWithHistory.prototype.update = function(options) {
                    if (options.dataViews && options.dataViews[0]) {
                        var dataView = this.dataView = options.dataViews[0], viewport = options.viewport;
                        if ((!dataView.categorical || !dataView.categorical.values || dataView.categorical.values.length < 1) && (!dataView.categorical || !dataView.categorical.categories || dataView.categorical.categories.length < 1)) return this.svg.attr("visibility", "hidden"), 
                        void this.textContainer.attr("style", "display:none");
                        this.svg.attr("visibility", "visible");
                        var kpiViewModel = KPIStatusWithHistory.converter(dataView, viewport, KPIStatusWithHistory.getProp_KPIDirection(dataView));
                        this.render(kpiViewModel, viewport);
                    }
                }, KPIStatusWithHistory.prototype.initIcons = function() {
                    this.successMarkIcon = this.indicatorTextContainer.append("div").classed("powervisuals-glyph checkmark kpi-visual-green", !0), 
                    this.betweenIcon = this.indicatorTextContainer.append("div").classed("powervisuals-glyph circle-small kpi-visual-yellow", !0), 
                    this.exclamationMarkIcon = this.indicatorTextContainer.append("div").classed("powervisuals-glyph exclamation kpi-visual-red", !0), 
                    this.successMarkIcon.attr("style", "display:none"), this.betweenIcon.attr("style", "display:none"), 
                    this.exclamationMarkIcon.attr("style", "display:none");
                }, KPIStatusWithHistory.prototype.render = function(kpiViewModel, viewport) {
                    if (this.setShowDataMissingWarning(!(kpiViewModel.indicatorExists && kpiViewModel.trendExists)), 
                    0 === kpiViewModel.dataPoints.length || !kpiViewModel.indicatorExists || !kpiViewModel.trendExists) return this.areaFill.attr("visibility", "hidden"), 
                    this.svg.attr("visibility", "hidden"), void this.textContainer.attr("style", "display:none");
                    this.svg.attr({
                        height: viewport.height,
                        width: viewport.width
                    });
                    var status = KPIStatusWithHistory.status.NOGOAL;
                    kpiViewModel.targetExists && kpiViewModel.indicatorExists && kpiViewModel.trendExists && (status = GetStatus(kpiViewModel.actual, kpiViewModel.goals, kpiViewModel.directionType));
                    var actualText = kpiViewModel.formattedValue, calculatedHeight = KPIStatusWithHistory.indicatorTextSizeInPx;
                    this.textContainer.attr("style", "width:" + viewport.width + "px;top:" + (viewport.height - calculatedHeight) / 2 + "px"), 
                    this.kpiActualText.classed(KPIStatusWithHistory.allColorClasses, !1).classed(GetTextColorClassByStatus(status), !0).attr("text-anchor", "middle").text(actualText);
                    var icon = null;
                    switch (status) {
                      case KPIStatusWithHistory.status.INCREASE:
                        icon = this.successMarkIcon, this.exclamationMarkIcon.attr("style", "display:none"), 
                        this.betweenIcon.attr("style", "display:none");
                        break;

                      case KPIStatusWithHistory.status.IN_BETWEEN:
                        icon = this.betweenIcon, this.exclamationMarkIcon.attr("style", "display:none"), 
                        this.successMarkIcon.attr("style", "display:none");
                        break;

                      case KPIStatusWithHistory.status.DROP:
                        icon = this.exclamationMarkIcon, this.successMarkIcon.attr("style", "display:none"), 
                        this.betweenIcon.attr("style", "display:none");
                        break;

                      default:
                        this.exclamationMarkIcon.attr("style", "display:none"), this.successMarkIcon.attr("style", "display:none"), 
                        this.betweenIcon.attr("style", "display:none");
                    }
                    icon && icon.attr("style", "font-size:12px");
                    var shownGoalString = kpiViewModel.showGoal ? kpiViewModel.formattedGoalString + " " : "", shownDistanceFromGoalString = kpiViewModel.showDistanceFromGoal ? getDistanceFromGoalInPercentageString(kpiViewModel.actual, kpiViewModel.goals, kpiViewModel.directionType) : "";
                    if (this.absoluteGoalDistanceText.attr("text-anchor", "middle").text(shownGoalString + shownDistanceFromGoalString), 
                    kpiViewModel.showTrendLine && kpiViewModel.historyExists) {
                        var area = d3.svg.area().x(function(d) {
                            return d.x;
                        }).y0(viewport.height).y1(function(d) {
                            return d.y;
                        });
                        this.areaFill.classed(KPIStatusWithHistory.allColorClasses, !1).classed(GetGraphColorClassByStatus(status), !0).attr("d", area(kpiViewModel.dataPoints)).attr("stroke", "none").attr("visibility", "visible").attr("fill-opacity", .2);
                    } else this.areaFill.attr("visibility", "hidden");
                }, KPIStatusWithHistory.prototype.setShowDataMissingWarning = function(show) {
                    this.host.setWarnings(show ? [ new visuals.VisualKPIDataMissingWarning() ] : []);
                }, KPIStatusWithHistory.getDefaultFormatSettings = function() {
                    return {
                        labelSettings: visuals.dataLabelUtils.getDefaultLabelSettings(!0, visuals.Card.DefaultStyle.value.color),
                        textSize: 27,
                        wordWrap: !1
                    };
                }, KPIStatusWithHistory.getFormatString = function(column) {
                    return visuals.valueFormatter.getFormatString(column, visuals.AnimatedText.formatStringProp);
                }, KPIStatusWithHistory.getProp_Show_KPIGoal = function(dataView) {
                    return dataView && dataView.metadata ? powerbi.DataViewObjects.getValue(dataView.metadata.objects, KPIStatusWithHistory.showKPIGoal, !0) : !0;
                }, KPIStatusWithHistory.getProp_Show_KPITrendLine = function(dataView) {
                    return dataView && dataView.metadata ? powerbi.DataViewObjects.getValue(dataView.metadata.objects, KPIStatusWithHistory.showKPITrendLine, !0) : !0;
                }, KPIStatusWithHistory.getProp_Show_KPIDistance = function(dataView) {
                    return dataView && dataView.metadata ? powerbi.DataViewObjects.getValue(dataView.metadata.objects, KPIStatusWithHistory.showKPIDistance, !0) : !0;
                }, KPIStatusWithHistory.getProp_KPIDirection = function(dataView) {
                    return dataView && dataView.metadata ? powerbi.DataViewObjects.getValue(dataView.metadata.objects, KPIStatusWithHistory.directionTypeStringProp, visuals.kpiDirection.positive) : visuals.kpiDirection.positive;
                }, KPIStatusWithHistory.getProp_Indicator_DisplayUnits = function(dataView) {
                    return KPIStatusWithHistory.initDefaultLabelSettings(), dataView && dataView.metadata ? powerbi.DataViewObjects.getValue(dataView.metadata.objects, KPIStatusWithHistory.indicatorDisplayUnitsProp, KPIStatusWithHistory.defaultLabelSettings.displayUnits) : KPIStatusWithHistory.defaultLabelSettings.displayUnits;
                }, KPIStatusWithHistory.getProp_Indicator_Precision = function(dataView) {
                    return KPIStatusWithHistory.initDefaultLabelSettings(), dataView && dataView.metadata ? powerbi.DataViewObjects.getValue(dataView.metadata.objects, KPIStatusWithHistory.indicatorPrecisionProp, KPIStatusWithHistory.defaultLabelSettings.precision) : KPIStatusWithHistory.defaultLabelSettings.precision;
                }, KPIStatusWithHistory.initDefaultLabelSettings = function() {
                    KPIStatusWithHistory.defaultCardFormatSetting || (KPIStatusWithHistory.defaultCardFormatSetting = KPIStatusWithHistory.getDefaultFormatSettings(), 
                    KPIStatusWithHistory.defaultLabelSettings = KPIStatusWithHistory.defaultCardFormatSetting.labelSettings);
                }, KPIStatusWithHistory.getFormattedValue = function(metaDataColumn, theValue, precision, displayUnits, displayUnitSystemType) {
                    void 0 === displayUnitSystemType && (displayUnitSystemType = powerbi.DisplayUnitSystemType.WholeUnits);
                    var isDefaultDisplayUnit = 0 === displayUnits, formatter = visuals.valueFormatter.create({
                        format: KPIStatusWithHistory.getFormatString(metaDataColumn),
                        value: displayUnits,
                        precision: precision,
                        displayUnitSystemType: displayUnitSystemType,
                        formatSingleValues: !!isDefaultDisplayUnit,
                        allowFormatBeautification: !0,
                        columnType: metaDataColumn ? metaDataColumn.type : void 0
                    });
                    return formatter.format(theValue);
                }, KPIStatusWithHistory.getFormattedGoalString = function(metaDataColumn, goals, precision, displayUnits) {
                    if (!goals || 0 === goals.length) return "";
                    var goalsString = KPIStatusWithHistory.getLocalizedString("Visual_KPI_Goal_Title") + ": " + KPIStatusWithHistory.getFormattedValue(metaDataColumn, goals[0], precision, displayUnits);
                    return 2 === goals.length && (goalsString += ", " + KPIStatusWithHistory.getFormattedValue(metaDataColumn, goals[1], precision, displayUnits)), 
                    goalsString;
                }, KPIStatusWithHistory.converter = function(dataView, viewPort, directionType) {
                    var dataPoints = [], catDv = dataView.categorical, indicatorMetadataColumn = null, goalMetadataColumn = null, formattedGoalString = "", formattedValue = "", targetExists = !1, indicatorExists = !1, trendExists = !1, historyExists = !0;
                    dataView.categorical.categories || (historyExists = !1);
                    for (var values = catDv.values, columns = dataView.metadata.columns, _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {
                        var column = columns_1[_i];
                        DataRoleHelper.hasRole(column, "Indicator") && (indicatorExists = !0, indicatorMetadataColumn = column), 
                        DataRoleHelper.hasRole(column, "TrendLine") && (trendExists = !0), DataRoleHelper.hasRole(column, "Goal") && (targetExists = !0, 
                        goalMetadataColumn = column);
                    }
                    if (!(indicatorExists && trendExists && values && 0 !== values.length && values[0].values && dataView.categorical.values)) return {
                        dataPoints: dataPoints,
                        directionType: directionType,
                        actual: 0,
                        goals: [],
                        formattedGoalString: formattedGoalString,
                        targetExists: targetExists,
                        historyExists: historyExists,
                        indicatorExists: indicatorExists,
                        trendExists: trendExists,
                        formattedValue: formattedValue,
                        showGoal: !1,
                        showDistanceFromGoal: !1,
                        showTrendLine: !1
                    };
                    var category, categoryValues;
                    historyExists && (category = catDv.categories[0], categoryValues = category.values);
                    for (var actualValue, historyActualData = [], historyGoalData = [], indicatorColumns = KPIStatusWithHistory.getColumnsByRole(values, "Indicator"), goalColumns = KPIStatusWithHistory.getColumnsByRole(values, "Goal"), i = 0, len = values[0].values.length; len > i; i++) {
                        actualValue = indicatorColumns[0].values[i];
                        for (var goals_1 = [], goalCnt = 0; goalCnt < goalColumns.length; goalCnt++) goals_1.push(goalColumns[goalCnt].values[i]);
                        historyGoalData.push(goals_1), historyActualData.push(actualValue);
                    }
                    for (var maxActualData = Math.max.apply(Math, historyActualData), minActualData = Math.min.apply(Math, historyActualData), areaMaxHight = viewPort.height * KPIStatusWithHistory.trendAreaFilePercentage, precision = KPIStatusWithHistory.getProp_Indicator_Precision(dataView), displayUnits = KPIStatusWithHistory.getProp_Indicator_DisplayUnits(dataView), i = 0; i < historyActualData.length; i++) {
                        var yPos = areaMaxHight * (historyActualData[i] - minActualData) / (maxActualData - minActualData), selectorId = null;
                        historyExists && (selectorId = visuals.SelectionId.createWithId(category.identity[i]).getSelector()), 
                        dataPoints.push({
                            x: i * viewPort.width / (historyActualData.length - 1),
                            y: viewPort.height - yPos,
                            actual: historyActualData[i],
                            goals: historyGoalData[i]
                        });
                    }
                    var actual, goals;
                    dataPoints.length > 0 && (actual = dataPoints[dataPoints.length - 1].actual, goals = dataPoints[dataPoints.length - 1].goals), 
                    1 === dataPoints.length && (historyExists = !1), formattedValue = KPIStatusWithHistory.getFormattedValue(indicatorMetadataColumn, actual, precision, displayUnits, powerbi.DisplayUnitSystemType.DataLabels), 
                    formattedGoalString = KPIStatusWithHistory.getFormattedGoalString(goalMetadataColumn, goals, precision, displayUnits);
                    var showGoal = KPIStatusWithHistory.getProp_Show_KPIGoal(dataView), showDistanceFromGoal = KPIStatusWithHistory.getProp_Show_KPIDistance(dataView), showTrendLine = KPIStatusWithHistory.getProp_Show_KPITrendLine(dataView);
                    return {
                        dataPoints: dataPoints,
                        directionType: directionType,
                        actual: actual,
                        goals: goals,
                        formattedGoalString: formattedGoalString,
                        targetExists: targetExists,
                        historyExists: historyExists,
                        indicatorExists: indicatorExists,
                        trendExists: trendExists,
                        formattedValue: formattedValue,
                        showGoal: showGoal,
                        showDistanceFromGoal: showDistanceFromGoal,
                        showTrendLine: showTrendLine
                    };
                }, KPIStatusWithHistory.getColumnsByRole = function(values, roleString) {
                    for (var retval = [], i = 0; i < values.length; i++) DataRoleHelper.hasRole(values[i].source, roleString) && retval.push(values[i]);
                    return retval;
                }, KPIStatusWithHistory.prototype.enumerateObjectInstances = function(options) {
                    var instances = [], dataView = this.dataView;
                    switch (options.objectName) {
                      case "indicator":
                        instances.push({
                            selector: null,
                            objectName: "indicator",
                            properties: {
                                indicatorDisplayUnits: KPIStatusWithHistory.getProp_Indicator_DisplayUnits(dataView),
                                indicatorPrecision: KPIStatusWithHistory.getProp_Indicator_Precision(dataView)
                            }
                        });

                      case "trendline":
                        instances.push({
                            selector: null,
                            objectName: "trendline",
                            properties: {
                                show: KPIStatusWithHistory.getProp_Show_KPITrendLine(dataView)
                            }
                        });

                      case "goals":
                        instances.push({
                            selector: null,
                            objectName: "goals",
                            properties: {
                                showGoal: KPIStatusWithHistory.getProp_Show_KPIGoal(dataView),
                                showDistance: KPIStatusWithHistory.getProp_Show_KPIDistance(dataView)
                            }
                        });

                      case "status":
                        instances.push({
                            selector: null,
                            objectName: "status",
                            properties: {
                                direction: KPIStatusWithHistory.getProp_KPIDirection(dataView)
                            }
                        });
                    }
                    return instances;
                }, KPIStatusWithHistory.prototype.destroy = function() {
                    this.svg = null;
                }, KPIStatusWithHistory.directionTypeStringProp = {
                    objectName: "status",
                    propertyName: "direction"
                }, KPIStatusWithHistory.showKPIGoal = {
                    objectName: "goals",
                    propertyName: "showGoal"
                }, KPIStatusWithHistory.showKPIDistance = {
                    objectName: "goals",
                    propertyName: "showDistance"
                }, KPIStatusWithHistory.showKPITrendLine = {
                    objectName: "trendline",
                    propertyName: "show"
                }, KPIStatusWithHistory.indicatorDisplayUnitsProp = {
                    objectName: "indicator",
                    propertyName: "indicatorDisplayUnits"
                }, KPIStatusWithHistory.indicatorPrecisionProp = {
                    objectName: "indicator",
                    propertyName: "indicatorPrecision"
                }, KPIStatusWithHistory.status = {
                    INCREASE: "increase",
                    DROP: "drop",
                    IN_BETWEEN: "in-between",
                    NOGOAL: "no-goal"
                }, KPIStatusWithHistory.statusBandingType = {
                    Below: "BELOW",
                    Above: "ABOVE"
                }, KPIStatusWithHistory.actualTextConsts = {
                    VERTICAL_OFFSET_FROM_HALF_HEIGHT: 20,
                    FONT_WIDTH_FACTOR: 14,
                    RIGHT_MARGIN: 10
                }, KPIStatusWithHistory.kpiRedClass = "kpi-visual-red", KPIStatusWithHistory.kpiYellowClass = "kpi-visual-yellow", 
                KPIStatusWithHistory.kpiGreenClass = "kpi-visual-green", KPIStatusWithHistory.kpiTextGreyClass = "kpi-visual-text-grey", 
                KPIStatusWithHistory.kpiGraphGreyClass = "kpi-visual-graph-grey", KPIStatusWithHistory.allColorClasses = KPIStatusWithHistory.kpiRedClass + " " + KPIStatusWithHistory.kpiYellowClass + " " + KPIStatusWithHistory.kpiGreenClass + " " + KPIStatusWithHistory.kpiTextGreyClass + " " + KPIStatusWithHistory.kpiGraphGreyClass, 
                KPIStatusWithHistory.trendAreaFilePercentage = 1, KPIStatusWithHistory.estimatedIconHeightInPx = 9, 
                KPIStatusWithHistory.indicatorTextSizeInPx = 60, KPIStatusWithHistory;
            }();
            visuals.KPIStatusWithHistory = KPIStatusWithHistory;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var EnumExtensions = jsCommon.EnumExtensions, createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, PixelConverter = jsCommon.PixelConverter, LineChart = function() {
                function LineChart(options) {
                    var _this = this;
                    this.pathXAdjustment = 0, this.deferDragMoveOperation = jsCommon.DeferUtility.deferUntilNextFrame(function() {
                        if (_this.lastDragMoveXPosition) {
                            var index = _this.findIndex(_this.lastDragMoveXPosition - _this.margin.left);
                            _this.selectColumn(index), _this.lastDragMoveXPosition = void 0;
                        }
                    }), this.isScrollable = options.isScrollable ? options.isScrollable : !1, this.tooltipsEnabled = options.tooltipsEnabled, 
                    this.lineType = options.chartType ? options.chartType : 1, this.interactivityService = options.interactivityService, 
                    this.animator = options.animator, this.lineClassAndSelector = LineChart.LineClassSelector, 
                    this.tooltipBucketEnabled = options.tooltipBucketEnabled, this.advancedLineLabelsEnabled = options.advancedLineLabelsEnabled;
                }
                return LineChart.customizeQuery = function(options) {
                    var dataViewMapping = options.dataViewMappings[0];
                    if (dataViewMapping && dataViewMapping.categorical && dataViewMapping.categorical.categories) {
                        dataViewMapping.categorical.dataVolume = 4;
                        var dataViewCategories = dataViewMapping.categorical.categories, usingScalarKey = !1, roleItems = dataViewCategories["for"]["in"].items;
                        if (roleItems && LineChart.shouldUseScalarKey(dataViewMapping, roleItems)) for (var _i = 0, roleItems_1 = roleItems; _i < roleItems_1.length; _i++) {
                            var item = roleItems_1[_i];
                            if (item.hasScalarKey) {
                                item.scalarKeyMinProperty = visuals.lineChartProps.scalarKey.scalarKeyMin, usingScalarKey = !0;
                                break;
                            }
                        }
                        if (visuals.CartesianChart.detectScalarMapping(dataViewMapping) || usingScalarKey) {
                            dataViewCategories.dataReductionAlgorithm = {
                                sample: {}
                            };
                            var values = dataViewMapping.categorical.values;
                            values && values.group && (values.group.dataReductionAlgorithm = {
                                top: {}
                            });
                        } else _.remove(options.dataViewMappings, function(dataViewMapping) {
                            return dataViewMapping.usage && dataViewMapping.usage.forecast;
                        }), visuals.CartesianChart.expandCategoryWindow([ dataViewMapping ]);
                    }
                }, LineChart.shouldUseScalarKey = function(dataViewMapping, categoryRoleItems) {
                    var axisTypeValue = powerbi.DataViewObjects.getValue(dataViewMapping.metadata.objects, visuals.lineChartProps.categoryAxis.axisType);
                    if (axisTypeValue === visuals.axisType.categorical) return !1;
                    var sortedColumns, columns = dataViewMapping.metadata && dataViewMapping.metadata.columns;
                    if (columns && (sortedColumns = _.filter(columns, function(c) {
                        return void 0 !== c.sort;
                    })), !_.isEmpty(sortedColumns)) {
                        if (_.any(sortedColumns, function(c) {
                            return !_.find(categoryRoleItems, function(ri) {
                                return c.queryName === ri.queryName;
                            });
                        })) return !1;
                        if (_.any(sortedColumns, function(c) {
                            return c.sort !== sortedColumns[0].sort;
                        })) return !1;
                    }
                    return !0;
                }, LineChart.getSortableRoles = function(options) {
                    var dataViewMapping = options.dataViewMappings[0];
                    if (!dataViewMapping || !dataViewMapping.categorical || !dataViewMapping.categorical.categories) return null;
                    var dataViewCategories = dataViewMapping.categorical.categories, categoryItems = dataViewCategories["for"]["in"].items;
                    if (!_.isEmpty(categoryItems)) {
                        var categoryType = categoryItems[0].type, objects = void 0;
                        if (dataViewMapping.metadata && (objects = dataViewMapping.metadata.objects), !visuals.CartesianChart.getIsScalar(objects, visuals.lineChartProps.categoryAxis.axisType, categoryType)) return [ "Category", "Y" ];
                    }
                    return null;
                }, LineChart.converter = function(dataView, blankCategoryValue, colors, isScalar, interactivityService, shouldCalculateStacked, isComboChart, tooltipsEnabled, tooltipBucketEnabled) {
                    void 0 === tooltipsEnabled && (tooltipsEnabled = !0), void 0 === tooltipBucketEnabled && (tooltipBucketEnabled = !1);
                    var reader = powerbi.data.createIDataViewCategoricalReader(dataView), valueRoleName = isComboChart ? "Y2" : "Y", categorical = dataView.categorical, category = categorical.categories && categorical.categories.length > 0 ? categorical.categories[0] : {
                        source: void 0,
                        values: [ blankCategoryValue ],
                        identity: void 0
                    }, xAxisCardProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataView.metadata);
                    isScalar = visuals.CartesianHelper.isScalar(isScalar, xAxisCardProperties);
                    var scalarMetadataColumn, scalarKeys = LineChart.getScalarKeys(category), useScalarKeys = isScalar && scalarKeys && !_.isEmpty(scalarKeys.values);
                    useScalarKeys && (scalarMetadataColumn = {
                        displayName: null,
                        type: {
                            dateTime: !0
                        }
                    }), categorical = visuals.ColumnUtil.applyUserMinMax(isScalar, categorical, xAxisCardProperties);
                    var defaultSeriesColor, formatStringProp = visuals.lineChartProps.general.formatString, categoryType = visuals.AxisHelper.getCategoryValueType(category.source, isScalar), isDateTime = visuals.AxisHelper.isDateTime(categoryType), categoryValues = category.values, categoryData = [], categoryIdentities = [], series = [], seriesCount = reader.getSeriesCount(valueRoleName), hasDynamicSeries = !(!categorical.values || !categorical.values.source), values = categorical.values, defaultLabelSettings = visuals.dataLabelUtils.getDefaultLineChartLabelSettings(isComboChart);
                    if (dataView.metadata && dataView.metadata.objects) {
                        var objects = dataView.metadata.objects;
                        defaultSeriesColor = isComboChart ? void 0 : powerbi.DataViewObjects.getFillColor(objects, visuals.lineChartProps.dataPoint.defaultColor);
                        var labelsObj = objects.labels;
                        visuals.dataLabelUtils.updateLineChartLabelSettingsFromLabelsObject(labelsObj, defaultLabelSettings);
                    }
                    var grouped, colorHelper = new visuals.ColorHelper(colors, visuals.lineChartProps.dataPoint.fill, defaultSeriesColor);
                    dataView.categorical.values && (grouped = dataView.categorical.values.grouped());
                    var stackedValues;
                    if (shouldCalculateStacked && (stackedValues = categorical.values && categorical.values.length > 0 ? _.times(categorical.values[0].values.length, function() {
                        return 0;
                    }) : []), reader.hasValues(valueRoleName)) for (var seriesIndex = 0; seriesCount > seriesIndex; seriesIndex++) {
                        var column = reader.getValueColumn(valueRoleName, seriesIndex), valuesMetadata = column.source, dataPoints = [], groupedIdentity = grouped[seriesIndex], identity = visuals.SelectionIdBuilder.builder().withSeries(categorical.values, column).withMeasure(reader.getValueMetadataColumn(valueRoleName, seriesIndex).queryName).createSelectionId(), key = identity.getKey(), color = this.getColor(colorHelper, hasDynamicSeries, values, grouped, seriesIndex, groupedIdentity), seriesLabelSettings = void 0;
                        if (!hasDynamicSeries) {
                            var labelsSeriesGroup = grouped && grouped.length > 0 && grouped[0].values ? grouped[0].values[seriesIndex] : null, labelObjects = labelsSeriesGroup && labelsSeriesGroup.source && labelsSeriesGroup.source.objects ? labelsSeriesGroup.source.objects.labels : null;
                            labelObjects && (seriesLabelSettings = powerbi.Prototype.inherit(defaultLabelSettings), 
                            visuals.dataLabelUtils.updateLineChartLabelSettingsFromLabelsObject(labelObjects, seriesLabelSettings));
                        }
                        for (var dataPointLabelSettings = seriesLabelSettings ? seriesLabelSettings : defaultLabelSettings, useHighlightValues = column.highlights && column.highlights.length > 0, categoryCount = reader.hasCategories() ? reader.getCategoryCount() : 1, categoryIndex = 0; categoryCount > categoryIndex; categoryIndex++) {
                            var categoryValue = categoryValues[categoryIndex], xAxisValue = useScalarKeys ? scalarKeys.values[categoryIndex].min : categoryValue, value = visuals.AxisHelper.normalizeNonFiniteNumber(useHighlightValues ? reader.getHighlight(valueRoleName, categoryIndex, seriesIndex) : reader.getValue(valueRoleName, categoryIndex, seriesIndex));
                            if ((!isScalar || null != xAxisValue && null != value) && (!isDateTime || null == categoryValue || categoryValue instanceof Date)) {
                                var categorical_1 = dataView.categorical, tooltipInfo = void 0, extraTooltipInfo = void 0;
                                tooltipsEnabled && (tooltipInfo = [], category.source && tooltipInfo.push({
                                    displayName: category.source.displayName,
                                    value: visuals.converterHelper.formatFromMetadataColumn(categoryValue, category.source, formatStringProp)
                                }), hasDynamicSeries && (category.source && category.source === categorical_1.values.source || tooltipInfo.push({
                                    displayName: categorical_1.values.source.displayName,
                                    value: visuals.converterHelper.formatFromMetadataColumn(grouped[seriesIndex].name, categorical_1.values.source, formatStringProp)
                                })), null != value && tooltipInfo.push({
                                    displayName: valuesMetadata.displayName,
                                    value: visuals.converterHelper.formatFromMetadataColumn(value, valuesMetadata, formatStringProp)
                                }), tooltipBucketEnabled && (extraTooltipInfo = [], visuals.TooltipBuilder.addTooltipBucketItem(reader, extraTooltipInfo, categoryIndex, hasDynamicSeries ? seriesIndex : void 0)));
                                var idBuilder = new visuals.SelectionIdBuilder();
                                reader.hasCategories() && (idBuilder = idBuilder.withCategory(reader.getCategoryColumn("Category"), categoryIndex)), 
                                hasDynamicSeries && (idBuilder = idBuilder.withSeries(dataView.categorical.values, reader.getValueColumn(valueRoleName, seriesIndex)));
                                var specificIdentity = idBuilder.withMeasure(reader.getValueMetadataColumn(valueRoleName, seriesIndex).queryName).createSelectionId(), categoryKey = category && !_.isEmpty(category.identity) && category.identity[categoryIndex] ? category.identity[categoryIndex].key : categoryIndex, dataPoint = {
                                    categoryValue: (isDateTime || useScalarKeys) && xAxisValue ? xAxisValue.getTime() : xAxisValue,
                                    value: value,
                                    categoryIndex: categoryIndex,
                                    seriesIndex: seriesIndex,
                                    tooltipInfo: tooltipInfo,
                                    selected: !1,
                                    identity: identity,
                                    specificIdentity: specificIdentity,
                                    key: JSON.stringify({
                                        series: key,
                                        category: categoryKey
                                    }),
                                    labelFill: dataPointLabelSettings.labelColor,
                                    labelFormatString: valuesMetadata.format,
                                    labelSettings: dataPointLabelSettings,
                                    extraTooltipInfo: extraTooltipInfo
                                };
                                if (shouldCalculateStacked && (stackedValues[categoryIndex] += value, dataPoint.stackedValue = stackedValues[categoryIndex]), 
                                category.objects && category.objects[categoryIndex] && (dataPoint.pointColor = powerbi.DataViewObjects.getFillColor(category.objects[categoryIndex], visuals.lineChartProps.dataPoint.fill)), 
                                dataPoints.push(dataPoint), categoryData[categoryIndex] || (categoryData[categoryIndex] = dataPoint), 
                                !categoryIdentities[categoryIndex] && reader.hasCategories()) {
                                    var categoryIdBuilder = new visuals.SelectionIdBuilder();
                                    categoryIdentities[categoryIndex] = categoryIdBuilder.withCategory(reader.getCategoryColumn("Category"), categoryIndex).withMeasure(reader.getValueMetadataColumn(valueRoleName, seriesIndex).queryName).createSelectionId();
                                }
                            }
                        }
                        interactivityService && interactivityService.applySelectionStateToData(dataPoints), 
                        dataPoints.length > 0 && series.push({
                            displayName: visuals.converterHelper.formatFromMetadataColumn(reader.getValueDisplayName(valueRoleName, seriesIndex), reader.getValueMetadataColumn(valueRoleName, seriesIndex), formatStringProp),
                            dynamicDisplayName: hasDynamicSeries ? visuals.converterHelper.formatFromMetadataColumn(reader.getSeriesName(seriesIndex), reader.getSeriesMetadataColumn(), formatStringProp) : void 0,
                            key: key,
                            lineIndex: seriesIndex,
                            color: color,
                            xCol: useScalarKeys ? scalarMetadataColumn : category.source,
                            yCol: reader.getValueMetadataColumn(valueRoleName, seriesIndex),
                            data: dataPoints,
                            identity: identity,
                            selected: !1,
                            labelSettings: seriesLabelSettings
                        });
                    }
                    xAxisCardProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataView.metadata);
                    var valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataView.metadata), valuesMetadataArray = [];
                    if (values) for (var i = 0; i < values.length; i++) values[i] && values[i].source && values[i].source.displayName && valuesMetadataArray.push({
                        displayName: values[i].source.displayName
                    });
                    var axesLabels = visuals.converterHelper.createAxesLabels(xAxisCardProperties, valueAxisProperties, category.source, valuesMetadataArray);
                    return interactivityService && interactivityService.applySelectionStateToData(series), 
                    {
                        series: series,
                        isScalar: isScalar,
                        dataLabelsSettings: defaultLabelSettings,
                        axesLabels: {
                            x: axesLabels.xAxisLabel,
                            y: axesLabels.yAxisLabel
                        },
                        hasDynamicSeries: hasDynamicSeries,
                        categoryMetadata: category.source,
                        scalarMetadata: scalarMetadataColumn,
                        scalarKeyCount: useScalarKeys ? scalarKeys.values.length : void 0,
                        categories: categoryValues,
                        categoryData: categoryData,
                        seriesDisplayName: hasDynamicSeries && reader.hasValues(valueRoleName) ? visuals.converterHelper.formatFromMetadataColumn(reader.getSeriesDisplayName(), reader.getSeriesMetadataColumn(), formatStringProp) : void 0,
                        hasValues: reader.hasValues(valueRoleName),
                        categoryIdentities: categoryIdentities
                    };
                }, LineChart.getInteractiveLineChartDomElement = function(element) {
                    return element.children("svg").get(0);
                }, LineChart.getColor = function(colorHelper, hasDynamicSeries, values, grouped, seriesIndex, groupedIdentity) {
                    var objects;
                    return hasDynamicSeries ? grouped && grouped[seriesIndex] && (objects = grouped[seriesIndex].objects) : values[seriesIndex] && (objects = values[seriesIndex].source.objects), 
                    hasDynamicSeries && groupedIdentity ? colorHelper.getColorForSeriesValue(objects, values.identityFields, groupedIdentity.name) : colorHelper.getColorForMeasure(objects, values[seriesIndex].source.queryName);
                }, LineChart.createStackedValueDomain = function(data) {
                    if (0 === data.length) return null;
                    var minY = d3.min(data, function(kv) {
                        return d3.min(kv.data, function(d) {
                            return d.stackedValue;
                        });
                    }), maxY = d3.max(data, function(kv) {
                        return d3.max(kv.data, function(d) {
                            return d.stackedValue;
                        });
                    });
                    return [ minY, maxY ];
                }, LineChart.prototype.init = function(options) {
                    var _this = this;
                    this.options = options, this.element = options.element, this.cartesainSVG = options.svg, 
                    this.host = options.host, this.currentViewport = options.viewport, this.colors = options.style.colorPalette.dataColors, 
                    this.isInteractiveChart = options.interactivity && options.interactivity.isInteractiveLegend, 
                    this.cartesianVisualHost = options.cartesianHost, this.scaleDetector = new visuals.SVGScaleDetector(this.cartesainSVG);
                    var chartType = options.chartType;
                    this.isComboChart = 10 === chartType || 13 === chartType || 14 === chartType;
                    var svg = options.svg;
                    svg.classed(LineChart.ClassName, !0);
                    var graphicsContextParent = this.mainGraphicsSVG = svg.append("svg").classed("lineChartSVG", !0);
                    this.isComboChart || this.isInteractiveChart || (this.overlayRect = graphicsContextParent.append(LineChart.RectOverlayName).style("opacity", visuals.SVGUtil.AlmostZero)), 
                    this.mainGraphicsContext = graphicsContextParent.append("g").classed(LineChart.MainGraphicsContextClassName, !0), 
                    this.hoverLineContext = svg.append("g").classed("hover-line", !0), this.hoverLineContext.append(LineChart.LineElementName).attr("x1", 0).attr("x2", 0).attr("y1", 0).attr("y2", 0);
                    var hoverLine = this.hoverLine = this.hoverLineContext.select(LineChart.LineElementName);
                    if (this.isInteractiveChart && hoverLine.classed("interactive", !0), hoverLine.style("opacity", visuals.SVGUtil.AlmostZero), 
                    this.selectionCircles = [], this.xAxisProperties = {
                        axis: null,
                        scale: null,
                        axisType: null,
                        formatter: null,
                        graphicsContext: null,
                        values: null,
                        axisLabel: null,
                        isCategoryAxis: !0
                    }, this.isInteractiveChart) {
                        var rootSvg_1 = LineChart.getInteractiveLineChartDomElement(this.element), dragMove = function() {
                            _this.lastDragMoveXPosition = d3.mouse(rootSvg_1)[0], _this.deferDragMoveOperation();
                        }, drag = d3.behavior.drag().origin(Object).on("drag", dragMove);
                        d3.select(rootSvg_1).style("touch-action", "none").call(drag).on("click", dragMove);
                    }
                    jsCommon.BrowserUtils.isInternetExplorerOrEdge() ? this.pathXAdjustment = 5 : jsCommon.BrowserUtils.isFirefox() && (this.pathXAdjustment = 2 * LineChart.interactivityStrokeWidth);
                }, LineChart.prototype.setData = function(dataViews) {
                    if (this.data = {
                        series: [],
                        dataLabelsSettings: visuals.dataLabelUtils.getDefaultLineChartLabelSettings(this.isComboChart),
                        axesLabels: {
                            x: null,
                            y: null
                        },
                        hasDynamicSeries: !1,
                        categories: [],
                        categoryMetadata: void 0,
                        categoryData: [],
                        categoryIdentities: []
                    }, dataViews.length > 0) {
                        var dataView = dataViews[0];
                        if (dataView && dataView.categorical) {
                            var dataViewCat = this.dataViewCat = dataView.categorical, dvCategories = dataViewCat.categories, categoryType = {
                                text: !0
                            }, scalarKeys = void 0;
                            dvCategories && !_.isEmpty(dvCategories) && (dvCategories[0].source && dvCategories[0].source.type && (categoryType = dvCategories[0].source.type), 
                            scalarKeys = LineChart.getScalarKeys(dvCategories[0]));
                            var convertedData = LineChart.converter(dataView, visuals.valueFormatter.format(null), this.cartesianVisualHost.getSharedColors(), visuals.CartesianChart.getIsScalar(dataView.metadata ? dataView.metadata.objects : null, visuals.lineChartProps.categoryAxis.axisType, categoryType, scalarKeys), this.interactivityService, EnumExtensions.hasFlag(this.lineType, 16), this.isComboChart, this.tooltipsEnabled, this.tooltipBucketEnabled);
                            this.data = convertedData;
                            var previousCategoryIds = this.previousCategoryIds, currentCategoryIds = convertedData.categoryIdentities;
                            if (null != previousCategoryIds && !(previousCategoryIds.length > visuals.AnimatorCommon.MaxDataPointsToAnimate || currentCategoryIds.length > visuals.AnimatorCommon.MaxDataPointsToAnimate)) {
                                this.suppressAnimation = !1;
                                for (var categoryIndex = 0, categoryCount = Math.min(previousCategoryIds.length, currentCategoryIds.length); categoryCount > categoryIndex; categoryIndex++) if (!previousCategoryIds[categoryIndex].equals(currentCategoryIds[categoryIndex])) {
                                    this.suppressAnimation = !0;
                                    break;
                                }
                            }
                            this.previousCategoryIds = currentCategoryIds;
                        }
                    }
                }, LineChart.prototype.calculateLegend = function() {
                    return this.createLegendDataPoints(0);
                }, LineChart.prototype.hasLegend = function() {
                    return this.data && (this.data.hasDynamicSeries || this.data.series && this.data.series.length > 1);
                }, LineChart.prototype.setFilteredData = function(startIndex, endIndex) {
                    var catgSize = endIndex - startIndex, data = this.clippedData = powerbi.Prototype.inherit(this.data);
                    return data.series = LineChart.sliceSeries(data.series, catgSize, startIndex), data.categories = data.categories.slice(startIndex, endIndex), 
                    data;
                }, LineChart.prototype.calculateAxesProperties = function(options) {
                    var _this = this, data = this.data, viewport = options.viewport, margin = options.margin;
                    this.currentViewport = viewport, this.margin = margin;
                    var origCatgSize = data.series && data.series.length > 0 ? data.series[0].data.length : 0, categoryWidth = visuals.CartesianChart.MinOrdinalRectThickness, isScalar = this.data.isScalar, trimOrdinalDataOnOverflow = options.trimOrdinalDataOnOverflow, preferredPlotArea = this.getPreferredPlotArea(isScalar, origCatgSize, categoryWidth);
                    if (this.clippedData = void 0, data && !isScalar && !this.isScrollable && trimOrdinalDataOnOverflow) {
                        var categoryCount = this.getCategoryCount(origCatgSize), catgSize = Math.min(origCatgSize, categoryCount);
                        catgSize !== origCatgSize && (data = this.clippedData = powerbi.Prototype.inherit(data), 
                        this.clippedData.series = LineChart.sliceSeries(data.series, catgSize));
                    }
                    var xMetaDataColumn, yMetaDataColumn;
                    data.series && data.series.length > 0 && (xMetaDataColumn = data.series[0].xCol, 
                    yMetaDataColumn = data.series[0].yCol);
                    var valueDomain = EnumExtensions.hasFlag(this.lineType, 16) ? LineChart.createStackedValueDomain(data.series) : visuals.AxisHelper.createValueDomain(data.series, !1), hasZeroValueInYDomain = options.valueAxisScaleType === visuals.axisScale.log && !visuals.AxisHelper.isLogScalePossible(valueDomain), combinedDomain = visuals.AxisHelper.combineDomain(options.forcedYDomain, valueDomain, options.ensureYDomain);
                    this.yAxisProperties = visuals.AxisHelper.createAxis({
                        pixelSpan: preferredPlotArea.height,
                        dataDomain: combinedDomain,
                        metaDataColumn: yMetaDataColumn,
                        formatString: visuals.valueFormatter.getFormatString(yMetaDataColumn, visuals.lineChartProps.general.formatString),
                        outerPadding: 0,
                        isScalar: !0,
                        isVertical: !0,
                        forcedTickCount: options.forcedTickCount,
                        useTickIntervalForDisplayUnits: !0,
                        isCategoryAxis: !1,
                        scaleType: options.valueAxisScaleType,
                        axisDisplayUnits: options.valueAxisDisplayUnits,
                        axisPrecision: options.valueAxisPrecision,
                        shouldClamp: !1
                    });
                    var metaDataColumn = data.scalarMetadata ? data.scalarMetadata : data.categoryMetadata, xAxisDataType = visuals.AxisHelper.getCategoryValueType(metaDataColumn), xDomain = visuals.AxisHelper.createDomain(data.series, xAxisDataType, this.data.isScalar, options.forcedXDomain, options.ensureXDomain), hasZeroValueInXDomain = options.categoryAxisScaleType === visuals.axisScale.log && !visuals.AxisHelper.isLogScalePossible(xDomain);
                    return this.xAxisProperties = visuals.AxisHelper.createAxis({
                        pixelSpan: preferredPlotArea.width,
                        dataDomain: xDomain,
                        metaDataColumn: xMetaDataColumn,
                        formatString: visuals.valueFormatter.getFormatString(xMetaDataColumn, visuals.lineChartProps.general.formatString),
                        outerPadding: this.data.isScalar ? LineChart.ScalarOuterPadding : 0,
                        isScalar: this.data.isScalar,
                        isVertical: !1,
                        forcedTickCount: options.forcedTickCount,
                        maxTickCount: data.scalarKeyCount,
                        useTickIntervalForDisplayUnits: !0,
                        getValueFn: function(index, type) {
                            return visuals.CartesianHelper.lookupXValue(_this.data, index, type, _this.data.isScalar);
                        },
                        categoryThickness: visuals.CartesianChart.getCategoryThickness(data.series, origCatgSize, this.getAvailableWidth(), xDomain, isScalar, trimOrdinalDataOnOverflow),
                        isCategoryAxis: !0,
                        scaleType: options.categoryAxisScaleType,
                        axisDisplayUnits: options.categoryAxisDisplayUnits,
                        axisPrecision: options.categoryAxisPrecision
                    }), this.xAxisProperties.axisLabel = options.showCategoryAxisLabel ? data.axesLabels.x : null, 
                    this.yAxisProperties.axisLabel = options.showValueAxisLabel ? data.axesLabels.y : null, 
                    this.xAxisProperties.hasDisallowedZeroInDomain = hasZeroValueInXDomain, this.yAxisProperties.hasDisallowedZeroInDomain = hasZeroValueInYDomain, 
                    [ this.xAxisProperties, this.yAxisProperties ];
                }, LineChart.prototype.enumerateObjectInstances = function(enumeration, options) {
                    switch (options.objectName) {
                      case "dataPoint":
                        this.enumerateDataPoints(enumeration);
                        break;

                      case "labels":
                        this.enumerateDataLabels(enumeration);
                    }
                }, LineChart.prototype.enumerateDataPoints = function(enumeration) {
                    var data = this.data;
                    if (data && data.series && 0 !== data.series.length) for (var formatStringProp = visuals.lineChartProps.general.formatString, singleSeriesData = data.series, seriesLength = singleSeriesData.length, i = 0; seriesLength > i; i++) {
                        var selector = visuals.ColorHelper.normalizeSelector(singleSeriesData[i].identity.getSelector()), label = visuals.converterHelper.getFormattedLegendLabel(singleSeriesData[i].yCol, this.dataViewCat.values, formatStringProp);
                        enumeration.pushInstance({
                            objectName: "dataPoint",
                            displayName: label,
                            selector: selector,
                            properties: {
                                fill: {
                                    solid: {
                                        color: data.defaultSeriesColor || singleSeriesData[i].color
                                    }
                                }
                            }
                        });
                    }
                }, LineChart.prototype.enumerateDataLabels = function(enumeration) {
                    var data = this.data, labelSettings = this.data.dataLabelsSettings, seriesCount = data.series.length, showLabelPerSeries = this.showLabelPerSeries();
                    if (visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings, null, showLabelPerSeries)), 
                    0 !== seriesCount && showLabelPerSeries && labelSettings.showLabelPerSeries) for (var i = 0; seriesCount > i; i++) {
                        var series = data.series[i], labelSettings_1 = series.labelSettings ? series.labelSettings : this.data.dataLabelsSettings;
                        enumeration.pushContainer({
                            displayName: series.displayName
                        }), visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings_1, series)), 
                        enumeration.popContainer();
                    }
                }, LineChart.prototype.supportsTrendLine = function() {
                    var isScalar = this.data ? this.data.isScalar : !1;
                    return !EnumExtensions.hasFlag(this.lineType, 16) && isScalar && this.data.hasValues;
                }, LineChart.prototype.supportsForecast = function() {
                    var isScalar = this.data ? this.data.isScalar : !1;
                    return !EnumExtensions.hasFlag(this.lineType, 16) && isScalar && this.data.hasValues && 1 === this.data.series.length;
                }, LineChart.prototype.isStacked = function() {
                    return EnumExtensions.hasFlag(this.lineType, 16);
                }, LineChart.prototype.shouldSuppressAnimation = function() {
                    return !!this.suppressAnimation;
                }, LineChart.prototype.showLabelPerSeries = function() {
                    var data = this.data;
                    return !data.hasDynamicSeries && (data.series.length > 1 || !data.categoryMetadata);
                }, LineChart.prototype.getLabelSettingsOptions = function(enumeration, labelSettings, series, showAll) {
                    return {
                        enumeration: enumeration,
                        dataLabelsSettings: labelSettings,
                        show: !0,
                        displayUnits: !0,
                        precision: !0,
                        selector: series && series.identity ? series.identity.getSelector() : null,
                        showAll: showAll,
                        fontSize: !0,
                        labelDensity: (this.isComboChart ? this.data.series.length > 0 : !0) && this.advancedLineLabelsEnabled && this.data.isScalar
                    };
                }, LineChart.prototype.overrideXScale = function(xProperties) {
                    this.xAxisProperties = xProperties;
                }, LineChart.prototype.onClearSelection = function() {
                    this.interactivityService && this.interactivityService.clearSelection();
                }, LineChart.prototype.render = function(suppressAnimations) {
                    var duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                    this.suppressAnimation && (duration = 0), this.previousCategoryCount = this.data.categoryData.length;
                    var result;
                    return result = this.isInteractiveChart ? this.renderOld(duration) : this.renderNew(duration), 
                    visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options), result;
                }, LineChart.prototype.renderNew = function(duration) {
                    var _this = this, data = this.clippedData ? this.clippedData : this.data;
                    if (data) {
                        var dataPointCount = data.categories.length * data.series.length;
                        dataPointCount > visuals.AnimatorCommon.MaxDataPointsToAnimate && (duration = 0);
                        var y0Position, yPosition, isStackedArea = EnumExtensions.hasFlag(this.lineType, 16), margin = this.margin, viewport = this.currentViewport, height = viewport.height - (margin.top + margin.bottom), width = viewport.width - (margin.left + margin.right), xScale = this.xAxisProperties.scale, yScale = this.yAxisProperties.scale, horizontalOffset = this.getXOfFirstCategory(), hasSelection = this.interactivityService && this.interactivityService.hasSelection(), renderAreas = EnumExtensions.hasFlag(this.lineType, 2) || EnumExtensions.hasFlag(this.lineType, 16), xPosition = function(d) {
                            return xScale(_this.getXValue(d)) + horizontalOffset;
                        };
                        isStackedArea ? (y0Position = function(d) {
                            return yScale(d.stackedValue - d.value);
                        }, yPosition = function(d) {
                            return yScale(d.stackedValue);
                        }) : (y0Position = yScale(0), yPosition = function(d) {
                            return yScale(d.value);
                        });
                        var area;
                        renderAreas && (area = d3.svg.area().x(xPosition).y0(y0Position).y1(yPosition).defined(function(d) {
                            return null !== d.value;
                        }));
                        var line = d3.svg.line().x(xPosition).y(yPosition).defined(function(d) {
                            return null !== d.value;
                        });
                        EnumExtensions.hasFlag(this.lineType, 4) && (line.interpolate("basis"), area && area.interpolate("basis")), 
                        this.mainGraphicsSVG.attr("height", height).attr("width", width);
                        var areas = void 0;
                        renderAreas && (areas = this.mainGraphicsContext.selectAll(LineChart.CategoryAreaSelector.selector).data(data.series, function(d) {
                            return d.identity.getKey();
                        }), areas.enter().append(LineChart.PathElementName).classed(LineChart.CategoryAreaSelector["class"], !0), 
                        areas.style("fill", function(d) {
                            return d.color;
                        }).style("fill-opacity", function(d) {
                            return hasSelection && !d.selected ? LineChart.DimmedAreaFillOpacity : LineChart.AreaFillOpacity;
                        }).transition().ease("linear").duration(duration).attr("d", function(d) {
                            return area(d.data);
                        }), areas.exit().remove());
                        var lines = this.mainGraphicsContext.selectAll(this.lineClassAndSelector.selector).data(data.series, function(d) {
                            return d.identity.getKey();
                        });
                        lines.enter().append(LineChart.PathElementName).classed(this.lineClassAndSelector["class"], !0), 
                        lines.style("stroke", function(d) {
                            return d.color;
                        }).style("stroke-opacity", function(d) {
                            return visuals.ColumnUtil.getFillOpacity(d.selected, !1, hasSelection, !1);
                        }).transition().ease("linear").duration(duration).attr("d", function(d) {
                            return line(d.data);
                        }), lines.exit().remove();
                        var interactivityLines = this.mainGraphicsContext.selectAll(".interactivity-line").data(data.series, function(d) {
                            return d.identity.getKey();
                        });
                        interactivityLines.enter().append(LineChart.PathElementName).classed("interactivity-line", !0).style("stroke-width", LineChart.interactivityStrokeWidth), 
                        interactivityLines.attr("d", function(d) {
                            return line(d.data);
                        }), interactivityLines.exit().remove();
                        var dotGroups = this.mainGraphicsContext.selectAll(LineChart.CategorySelector.selector).data(data.series, function(d) {
                            return d.identity.getKey();
                        });
                        dotGroups.enter().append("g").classed(LineChart.CategorySelector["class"], !0), 
                        dotGroups.exit().remove();
                        var dots = dotGroups.selectAll(LineChart.CategoryValuePoint.selector).data(function(series) {
                            return series.data.filter(function(value, i) {
                                return _this.shouldDrawCircle(series, i);
                            });
                        }, function(d) {
                            return d.key;
                        });
                        dots.enter().append(LineChart.CircleElementName).classed(LineChart.CategoryValuePoint["class"], !0), 
                        dots.style("fill", function() {
                            var lineSeries = d3.select(this.parentNode).datum();
                            return lineSeries.color;
                        }).style("fill-opacity", function() {
                            var lineSeries = d3.select(this.parentNode).datum();
                            return visuals.ColumnUtil.getFillOpacity(lineSeries.selected, !1, hasSelection, !1);
                        }).transition().duration(duration).attr({
                            cx: function(d, i) {
                                return xScale(_this.getXValue(d)) + horizontalOffset;
                            },
                            cy: function(d, i) {
                                return yScale(isStackedArea ? d.stackedValue : d.value);
                            },
                            r: LineChart.CircleRadius
                        }), dots.exit().remove();
                        var explicitDots;
                        this.isComboChart || (explicitDots = dotGroups.selectAll(LineChart.CategoryPointSelector.selector).data(function(series) {
                            return _.filter(series.data, function(value) {
                                return null != value.pointColor;
                            });
                        }, function(d) {
                            return d.key;
                        }), explicitDots.enter().append(LineChart.CircleElementName).classed(LineChart.CategoryPointSelector["class"], !0), 
                        explicitDots.style("fill", function(d) {
                            return d.pointColor;
                        }).transition().duration(duration).attr({
                            cx: function(d) {
                                return xScale(_this.getXValue(d));
                            },
                            cy: function(d) {
                                return yScale(isStackedArea ? d.stackedValue : d.value);
                            },
                            r: LineChart.PointRadius
                        }), explicitDots.exit().remove());
                        var labelDataPointGroups;
                        if (data.dataLabelsSettings.show && (labelDataPointGroups = this.createLabelDataPoints()), 
                        this.tooltipsEnabled) if (this.isComboChart) {
                            var seriesTooltipApplier = function(tooltipEvent) {
                                var pointX = tooltipEvent.elementCoordinates[0];
                                return _this.getTooltipInfoForCombo(tooltipEvent, pointX);
                            };
                            interactivityLines && visuals.TooltipManager.addTooltip(interactivityLines, seriesTooltipApplier, !0), 
                            visuals.TooltipManager.addTooltip(dots, function(tooltipEvent) {
                                return tooltipEvent.data.tooltipInfo;
                            }, !0), explicitDots && visuals.TooltipManager.addTooltip(explicitDots, function(tooltipEvent) {
                                return tooltipEvent.data.tooltipInfo;
                            }, !0);
                        } else {
                            this.overlayRect.attr({
                                x: 0,
                                width: width,
                                height: height
                            });
                            var seriesTooltipApplier = function(tooltipEvent) {
                                var pointX = tooltipEvent.elementCoordinates[0], index = _this.getCategoryIndexFromTooltipEvent(tooltipEvent, pointX), categoryData = _this.selectColumnForTooltip(index);
                                return _this.getSeriesTooltipInfo(categoryData);
                            }, clearHoverLine = function() {
                                _this.hoverLine.style("opacity", visuals.SVGUtil.AlmostZero), _this.hoverLineContext.selectAll(LineChart.HoverLineCircleDot.selector).remove();
                            };
                            visuals.TooltipManager.addTooltip(this.mainGraphicsSVG, seriesTooltipApplier, !0, clearHoverLine);
                        }
                        var dataPointsToBind = void 0, behaviorOptions = void 0;
                        if (this.interactivityService) {
                            dataPointsToBind = data.series.slice();
                            for (var i = 0, ilen = data.series.length; ilen > i; i++) dataPointsToBind = dataPointsToBind.concat(data.series[i].data);
                            behaviorOptions = {
                                lines: lines,
                                interactivityLines: interactivityLines,
                                dots: dots,
                                areas: areas,
                                tooltipOverlay: this.overlayRect,
                                getCategoryIndex: function(seriesData, pointX) {
                                    return _this.getCategoryIndexFromSeriesAndPointX(seriesData, pointX);
                                },
                                categoryIdentities: data.categoryIdentities
                            };
                        }
                        return {
                            dataPoints: dataPointsToBind,
                            behaviorOptions: behaviorOptions,
                            labelDataPoints: [],
                            labelsAreNumeric: !0,
                            labelDataPointGroups: labelDataPointGroups
                        };
                    }
                }, LineChart.prototype.renderOld = function(duration) {
                    var _this = this, data = this.clippedData ? this.clippedData : this.data;
                    if (data) {
                        var area, margin = this.margin, viewport = this.currentViewport, height = viewport.height - (margin.top + margin.bottom), xScale = this.xAxisProperties.scale, yScale = this.yAxisProperties.scale, hasSelection = this.interactivityService && this.interactivityService.hasSelection();
                        EnumExtensions.hasFlag(this.lineType, 2) && (area = d3.svg.area().x(function(d) {
                            return xScale(_this.getXValue(d));
                        }).y0(height).y1(function(d) {
                            return yScale(d.value);
                        }).defined(function(d) {
                            return null !== d.value;
                        }));
                        var line = d3.svg.line().x(function(d) {
                            return xScale(_this.getXValue(d));
                        }).y(function(d) {
                            return yScale(d.value);
                        }).defined(function(d) {
                            return null !== d.value;
                        });
                        EnumExtensions.hasFlag(this.lineType, 4) && (line.interpolate("basis"), area && area.interpolate("basis"));
                        var firstCategoryOffset = this.getXOfFirstCategory();
                        if (this.mainGraphicsContext.attr("transform", visuals.SVGUtil.translate(firstCategoryOffset, 0)), 
                        this.mainGraphicsSVG.attr("height", this.getAvailableHeight()).attr("width", this.getAvailableWidth()), 
                        this.hoverLineContext.attr("transform", visuals.SVGUtil.translate(firstCategoryOffset, 0)), 
                        EnumExtensions.hasFlag(this.lineType, 2)) {
                            var catAreaSelect = this.mainGraphicsContext.selectAll(LineChart.CategoryAreaSelector.selector).data(data.series, function(d) {
                                return d.identity.getKey();
                            }), catAreaEnter = catAreaSelect.enter().append("g").classed(LineChart.CategoryAreaSelector["class"], !0);
                            catAreaEnter.append(LineChart.PathElementName);
                            var catAreaUpdate = this.mainGraphicsContext.selectAll(LineChart.CategoryAreaSelector.selector);
                            catAreaUpdate.select(LineChart.PathElementName).transition().ease("linear").duration(duration).attr("d", function(d) {
                                return area(d.data);
                            }).style("fill", function(d) {
                                return d.color;
                            }).style("fill-opacity", function(d) {
                                return hasSelection && !d.selected ? LineChart.DimmedAreaFillOpacity : LineChart.AreaFillOpacity;
                            }), catAreaSelect.exit().remove();
                        }
                        var catSelect = this.mainGraphicsContext.selectAll(LineChart.CategorySelector.selector).data(data.series, function(d) {
                            return d.identity.getKey();
                        }), catEnter = catSelect.enter().append("g").classed(LineChart.CategorySelector["class"], !0);
                        if (catEnter.append(LineChart.PathElementName), catEnter.selectAll(LineChart.CategoryValuePoint.selector).data(function(d) {
                            return d.data;
                        }).enter().append(LineChart.CircleElementName).classed(LineChart.CategoryValuePoint["class"], !0), 
                        catSelect.exit().remove(), this.isInteractiveChart && !this.dragHandle) {
                            var handleTop = this.getAvailableHeight();
                            this.dragHandle = this.hoverLineContext.append("circle").attr("cx", 0).attr("cy", handleTop).attr("r", "6px").classed("drag-handle", !0);
                        }
                        for (var linesCount = catSelect.data().length; this.selectionCircles.length < linesCount; ) {
                            var addedCircle = this.hoverLineContext.append(LineChart.CircleElementName).classed(LineChart.CircleClassName, !0).attr("r", LineChart.CircleRadius).style("opacity", 0);
                            this.selectionCircles.push(addedCircle);
                        }
                        for (;this.selectionCircles.length > linesCount; ) this.selectionCircles.pop().remove();
                        var catUpdate = this.mainGraphicsContext.selectAll(LineChart.CategorySelector.selector), lineSelection = catUpdate.select(LineChart.PathElementName).classed(this.lineClassAndSelector["class"], !0).style("stroke", function(d) {
                            return d.color;
                        }).style("stroke-opacity", function(d) {
                            return visuals.ColumnUtil.getFillOpacity(d.selected, !1, hasSelection, !1);
                        });
                        lineSelection.transition().ease("linear").duration(duration).attr("d", function(d) {
                            return line(d.data);
                        });
                        var that = this, updateSelection = catUpdate.selectAll(LineChart.CategoryValuePoint.selector), transitions = updateSelection.style("fill", function() {
                            var lineSeries = d3.select(this.parentNode).datum();
                            return lineSeries.color;
                        }).style("fill-opacity", function() {
                            var lineSeries = d3.select(this.parentNode).datum();
                            return visuals.ColumnUtil.getFillOpacity(lineSeries.selected, !1, hasSelection, !1);
                        }).transition().duration(duration).attr({
                            cx: function(d, i) {
                                var lineSeries = d3.select(this.parentNode).datum(), circleIndex = that.shouldDrawCircle(lineSeries, i);
                                return circleIndex ? xScale(that.getXValue(d)) : 0;
                            },
                            cy: function(d, i) {
                                var lineSeries = d3.select(this.parentNode).datum(), circleIndex = that.shouldDrawCircle(lineSeries, i);
                                return circleIndex ? yScale(d.value) : 0;
                            },
                            r: function(d, i) {
                                var lineSeries = d3.select(this.parentNode).datum(), circleIndex = that.shouldDrawCircle(lineSeries, i);
                                return circleIndex ? LineChart.CircleRadius : 0;
                            }
                        });
                        if (this.isInteractiveChart && this.hasDataPoint(data.series)) {
                            var selectionSize_1 = updateSelection.size(), endedTransitionCount_1 = 0;
                            transitions.each("end", function() {
                                endedTransitionCount_1++, endedTransitionCount_1 === selectionSize_1 && _this.selectColumn(visuals.CartesianHelper.findMaxCategoryIndex(data.series), !0);
                            });
                        }
                        var dataPoints = null;
                        if (data.dataLabelsSettings.show) {
                            dataPoints = [];
                            for (var i = 0, ilen = data.series.length; ilen > i; i++) Array.prototype.push.apply(dataPoints, data.series[i].data);
                        }
                        catSelect.exit().remove();
                        var labelDataPointsGroups;
                        return data.dataLabelsSettings.show && (labelDataPointsGroups = this.createLabelDataPoints()), 
                        null == dataPoints ? null : {
                            dataPoints: dataPoints,
                            behaviorOptions: null,
                            labelDataPoints: null,
                            labelsAreNumeric: null,
                            labelDataPointGroups: labelDataPointsGroups
                        };
                    }
                }, LineChart.prototype.getSeriesTooltipInfo = function(pointData) {
                    if (_.isEmpty(pointData)) return null;
                    var transparentColor = "#000000", hiddenItemOpacity = "0", tooltipinfo = [], maxNumberOfItems = 10, hasDynamicSeries = !_.isEmpty(pointData) && pointData[0].seriesDisplayName, count = 0;
                    if (_.any(pointData, function(point) {
                        return !_.isEmpty(point.extraTooltipInfo);
                    })) {
                        for (var _a = 0, pointData_2 = pointData; _a < pointData_2.length; _a++) {
                            var point = pointData_2[_a];
                            if (count >= maxNumberOfItems) break;
                            if (null != point.value && (hasDynamicSeries && tooltipinfo.push({
                                header: point.category,
                                displayName: point.seriesDisplayName,
                                value: point.seriesName
                            }), tooltipinfo.push({
                                header: point.category,
                                color: point.color,
                                displayName: point.measureDisplayName,
                                value: point.measure
                            }), count += 2, hasDynamicSeries && !_.isEmpty(point.extraTooltipInfo))) for (var _b = 0, _c = point.extraTooltipInfo; _b < _c.length; _b++) {
                                var extraTooltipInfo = _c[_b];
                                if (count >= maxNumberOfItems) break;
                                tooltipinfo.push({
                                    header: point.category,
                                    color: transparentColor,
                                    displayName: extraTooltipInfo.displayName,
                                    value: extraTooltipInfo.value,
                                    opacity: hiddenItemOpacity
                                }), count++;
                            }
                        }
                        if (!hasDynamicSeries) for (var _d = 0, _e = pointData[0].extraTooltipInfo; _d < _e.length; _d++) {
                            var extraTooltipInfo = _e[_d];
                            if (count >= maxNumberOfItems) break;
                            tooltipinfo.push({
                                header: pointData[0].category,
                                color: transparentColor,
                                displayName: extraTooltipInfo.displayName,
                                value: extraTooltipInfo.value,
                                opacity: hiddenItemOpacity
                            }), count++;
                        }
                    } else for (var _i = 0, pointData_1 = pointData; _i < pointData_1.length; _i++) {
                        var point = pointData_1[_i];
                        if (count >= maxNumberOfItems) break;
                        null != point.value && (tooltipinfo.push({
                            header: point.category,
                            color: point.color,
                            displayName: point.seriesName || point.measureDisplayName,
                            value: point.measure
                        }), count++);
                    }
                    return 0 === tooltipinfo.length ? null : tooltipinfo;
                }, LineChart.prototype.getTooltipInfoForCombo = function(tooltipEvent, pointX) {
                    var dataPoint, categoryIndex = this.getCategoryIndexFromTooltipEvent(tooltipEvent, pointX), seriesData = tooltipEvent.data;
                    return seriesData && seriesData.data && seriesData.data.length && (dataPoint = _.find(seriesData.data, function(dp) {
                        return dp.categoryIndex === categoryIndex;
                    })), dataPoint ? dataPoint.tooltipInfo : void 0;
                }, LineChart.prototype.getCategoryIndexFromTooltipEvent = function(tooltipEvent, pointX) {
                    if (tooltipEvent.data && null != tooltipEvent.data.categoryIndex) return tooltipEvent.data.categoryIndex;
                    var seriesData = tooltipEvent.data;
                    return this.getCategoryIndexFromSeriesAndPointX(seriesData, pointX);
                }, LineChart.prototype.getCategoryIndexFromSeriesAndPointX = function(seriesData, pointX) {
                    var offsetX = 0;
                    if (seriesData && !_.isEmpty(seriesData.data) && this.xAxisProperties) {
                        pointX = this.adjustPathXCoordinate(pointX);
                        var firstPathPoint = _.find(seriesData.data, function(dataPoint, index, dataPoints) {
                            var nextDataPoint = dataPoints[index + 1];
                            return null != dataPoint.value && nextDataPoint && null != nextDataPoint.value;
                        });
                        offsetX = this.xAxisProperties.scale(this.getXValue(firstPathPoint)) + this.getXOfFirstCategory();
                    }
                    return this.findIndex(pointX, offsetX);
                }, LineChart.prototype.getVisualCategoryAxisIsScalar = function() {
                    return this.data ? this.data.isScalar : !1;
                }, LineChart.prototype.getSupportedCategoryAxisType = function() {
                    var dvCategories = this.dataViewCat ? this.dataViewCat.categories : void 0, categoryType = {
                        text: !0
                    };
                    if (!_.isEmpty(dvCategories)) {
                        var scalarKeys = LineChart.getScalarKeys(dvCategories[0]);
                        if (scalarKeys && !_.isEmpty(scalarKeys.values)) return visuals.axisType.both;
                        dvCategories[0].source && dvCategories[0].source.type && (categoryType = dvCategories[0].source.type);
                    }
                    var isOrdinal = visuals.AxisHelper.isOrdinal(categoryType);
                    return isOrdinal ? visuals.axisType.categorical : visuals.axisType.both;
                }, LineChart.prototype.getPreferredPlotArea = function(isScalar, categoryCount, categoryThickness) {
                    return visuals.CartesianChart.getPreferredPlotArea(categoryCount, categoryThickness, this.currentViewport, this.isScrollable, isScalar, this.margin, !0);
                }, LineChart.prototype.getCategoryCount = function(origCatgSize) {
                    var availableWidth = this.getAvailableWidth(), categoryThickness = visuals.CartesianChart.MinOrdinalRectThickness;
                    return Math.min(Math.round((availableWidth - categoryThickness * visuals.CartesianChart.OuterPaddingRatio * 2) / categoryThickness), origCatgSize);
                }, LineChart.prototype.getAvailableWidth = function() {
                    return this.currentViewport.width - (this.margin.left + this.margin.right);
                }, LineChart.prototype.getAvailableHeight = function() {
                    return this.currentViewport.height - (this.margin.top + this.margin.bottom);
                }, LineChart.sliceSeries = function(series, newLength, startIndex) {
                    void 0 === startIndex && (startIndex = 0);
                    var newSeries = [];
                    if (series && series.length > 0) for (var i = 0, len = series.length; len > i; i++) newSeries[i] = powerbi.Prototype.inherit(series[i]), 
                    newSeries[i].data = series[i].data.slice(startIndex, startIndex + newLength);
                    return newSeries;
                }, LineChart.getScalarKeys = function(dataViewCategoryColumn) {
                    var categoryColumnObjects;
                    if (dataViewCategoryColumn && (categoryColumnObjects = dataViewCategoryColumn.objects), 
                    !_.isEmpty(categoryColumnObjects)) {
                        for (var scalarKeys = void 0, categoryObjectsLength = categoryColumnObjects.length, i = 0; categoryObjectsLength > i; i++) {
                            var categoryObjects = categoryColumnObjects[i], scalarKey = powerbi.DataViewObjects.getValue(categoryObjects, visuals.lineChartProps.scalarKey.scalarKeyMin);
                            if (void 0 !== scalarKey) {
                                scalarKeys || (scalarKeys = {
                                    values: new Array(categoryObjectsLength)
                                });
                                var key = {
                                    min: scalarKey
                                };
                                scalarKeys.values[i] = key;
                            }
                        }
                        return scalarKeys;
                    }
                }, LineChart.prototype.getXOfFirstCategory = function() {
                    if (!this.data.isScalar) {
                        var xScale = this.xAxisProperties.scale;
                        if (xScale.rangeBand) return xScale.rangeBand() / 2;
                    }
                    return 0;
                }, LineChart.prototype.hasDataPoint = function(series) {
                    if (0 === series.length) return !1;
                    for (var i = 0, len = series.length; len > i; i++) if (series[i].data.length > 0) return !0;
                    return !1;
                }, LineChart.prototype.getXValue = function(d) {
                    return this.data.isScalar ? d.categoryValue : d.categoryIndex;
                }, LineChart.prototype.shouldDrawCircle = function(d, i) {
                    var dataLength = d.data.length, isLastPoint = i === dataLength - 1, isFirstPoint = 0 === i;
                    return i > dataLength - 1 || null === d.data[i] || null === d.data[i].value ? !1 : isFirstPoint && isLastPoint ? !0 : isFirstPoint && dataLength > 1 && null === d.data[i + 1].value ? !0 : !isFirstPoint && isLastPoint && null === d.data[i - 1].value ? !0 : !isFirstPoint && !isLastPoint && null === d.data[i - 1].value && null === d.data[i + 1].value;
                }, LineChart.prototype.selectColumnForTooltip = function(columnIndex, force) {
                    void 0 === force && (force = !1);
                    var x = this.getChartX(columnIndex) + this.getXOfFirstCategory(), dataPoints = this.createTooltipDataPoints(columnIndex);
                    return dataPoints.length > 0 && this.setHoverLineForTooltip(x), this.setDotsForTooltip(x, dataPoints), 
                    dataPoints;
                }, LineChart.prototype.setHoverLineForTooltip = function(chartX) {
                    chartX = chartX || 0, this.hoverLine.attr("x1", chartX).attr("x2", chartX).attr("y1", 0).attr("y2", this.getAvailableHeight()).style("opacity", 1);
                }, LineChart.prototype.setDotsForTooltip = function(chartX, dataPoints) {
                    var _this = this, isStackedArea = EnumExtensions.hasFlag(this.lineType, 16), dotYPosition = isStackedArea ? function(d) {
                        return _this.yAxisProperties.scale(d.stackedValue);
                    } : function(d) {
                        return _this.yAxisProperties.scale(d.value);
                    }, tooltipDots = this.hoverLineContext.selectAll(LineChart.HoverLineCircleDot.selector).data(dataPoints);
                    tooltipDots.enter().append(LineChart.CircleElementName).classed(LineChart.HoverLineCircleDot["class"], !0), 
                    tooltipDots.filter(function(d) {
                        return d.value;
                    }).attr("fill", function(d) {
                        return d.color;
                    }).attr("r", 3).attr("cx", chartX).attr("cy", dotYPosition), tooltipDots.exit().remove();
                }, LineChart.prototype.selectColumn = function(columnIndex, force) {
                    if (void 0 === force && (force = !1), force || this.lastInteractiveSelectedColumnIndex !== columnIndex) {
                        this.lastInteractiveSelectedColumnIndex = columnIndex;
                        var x = this.getChartX(columnIndex);
                        this.setHoverLine(x, columnIndex);
                        var legendItems = this.createLegendDataPoints(columnIndex);
                        legendItems && this.options.cartesianHost.updateLegend(legendItems);
                    }
                }, LineChart.prototype.setHoverLine = function(chartX, columnIndex) {
                    this.hoverLine.attr("x1", chartX).attr("x2", chartX).attr("y1", 0).attr("y2", this.getAvailableHeight()).style("opacity", 1);
                    var that = this;
                    this.mainGraphicsContext.selectAll(LineChart.CategorySelector.selector).selectAll(LineChart.PathElementName).each(function(series) {
                        var _this = this, color = series.color, circleToChange = that.selectionCircles[series.lineIndex];
                        circleToChange && circleToChange.attr({
                            cx: chartX,
                            cy: function() {
                                var pathElement = d3.select(_this).node(), pos = that.getPosition(chartX, pathElement);
                                return pos.y;
                            }
                        }).style({
                            opacity: function() {
                                return _.some(series.data, function(value) {
                                    return value.categoryIndex === columnIndex;
                                }) ? 1 : 0;
                            },
                            fill: color
                        }), that.dragHandle && that.dragHandle.attr("cx", chartX);
                    });
                }, LineChart.prototype.getChartX = function(columnIndex) {
                    var x = 0;
                    this.data.isScalar ? columnIndex >= 0 && columnIndex < this.data.categoryData.length && (x = Math.max(0, this.xAxisProperties.scale(this.data.categoryData[columnIndex].categoryValue))) : x = Math.max(0, this.xAxisProperties.scale(columnIndex));
                    var rangeEnd = powerbi.visuals.AxisHelper.extent(this.xAxisProperties.scale)[1];
                    return x = Math.min(x, rangeEnd), isNaN(x) ? 0 : x;
                }, LineChart.prototype.findIndex = function(pointX, offsetX) {
                    var xScale = this.scaleDetector.getScale().x;
                    powerbi.Double.equalWithPrecision(xScale, 1, 1e-5) || (pointX /= xScale), offsetX && (pointX += offsetX);
                    var index = powerbi.visuals.AxisHelper.invertScale(this.xAxisProperties.scale, pointX);
                    return this.data.isScalar && (index = visuals.AxisHelper.findClosestXAxisIndex(index, this.data.categoryData)), 
                    index;
                }, LineChart.prototype.getPosition = function(x, pathElement) {
                    for (var pos, target, pathLength = pathElement.getTotalLength(), beginning = 0, end = pathLength; ;) {
                        if (target = Math.floor((beginning + end) / 2), pos = pathElement.getPointAtLength(target), 
                        visuals.SVGUtil.ensureValidSVGPoint(pos), (target === end || target === beginning) && pos.x !== x) break;
                        if (pos.x > x) end = target; else {
                            if (!(pos.x < x)) break;
                            beginning = target;
                        }
                    }
                    return pos;
                }, LineChart.prototype.createTooltipDataPoints = function(columnIndex) {
                    var data = this.data;
                    if (!data || 0 === data.series.length || !data.categories || !data.categoryData) return [];
                    var category, dataPoints = [], categoryDataPoint = data.categoryData[columnIndex];
                    this.data.isScalar ? categoryDataPoint && (category = visuals.AxisHelper.isDateTime(this.xAxisProperties.axisType) && !data.scalarMetadata ? visuals.CartesianHelper.lookupXValue(this.data, categoryDataPoint.categoryValue, this.xAxisProperties.axisType, this.data.isScalar) : data.categories[columnIndex]) : category = visuals.CartesianHelper.lookupXValue(this.data, columnIndex, this.xAxisProperties.axisType, this.data.isScalar);
                    for (var formatStringProp = visuals.lineChartProps.general.formatString, _i = 0, _a = data.series; _i < _a.length; _i++) {
                        var series = _a[_i], lineData = series.data, lineDataPoint = void 0;
                        this.data.isScalar ? categoryDataPoint && (lineDataPoint = lineData.filter(function(data) {
                            return data.categoryValue === categoryDataPoint.categoryValue;
                        })[0]) : lineDataPoint = lineData[columnIndex];
                        var value = lineDataPoint && lineDataPoint.value;
                        if (null != value) {
                            var dataPoint = {
                                color: series.color,
                                category: visuals.valueFormatter.format(category, visuals.valueFormatter.getFormatString(series.xCol, formatStringProp)),
                                measureDisplayName: series.displayName,
                                measure: visuals.valueFormatter.format(value, visuals.valueFormatter.getFormatString(series.yCol, formatStringProp)),
                                value: value,
                                stackedValue: lineDataPoint.stackedValue,
                                extraTooltipInfo: lineDataPoint.extraTooltipInfo
                            };
                            data.hasDynamicSeries && (dataPoint.seriesDisplayName = data.seriesDisplayName, 
                            dataPoint.seriesName = series.dynamicDisplayName), dataPoints.push(dataPoint);
                        }
                    }
                    return dataPoints;
                }, LineChart.prototype.createLegendDataPoints = function(columnIndex) {
                    var data = this.data;
                    if (data && data.series && !(data.series.length < 1)) {
                        var category, legendDataPoints = [], categoryDataPoint = data.categoryData[columnIndex];
                        this.isInteractiveChart && categoryDataPoint && (this.data.isScalar ? (category = categoryDataPoint.categoryValue, 
                        visuals.AxisHelper.isDateTime(this.xAxisProperties.axisType) && (category = new Date(category))) : category = visuals.CartesianHelper.lookupXValue(this.data, columnIndex, this.xAxisProperties.axisType, this.data.isScalar));
                        for (var formatStringProp = visuals.lineChartProps.general.formatString, seriesYCol = null, i = 0, len = data.series.length; len > i; i++) {
                            var series = data.series[i], lineData = series.data, measure = void 0;
                            if (this.isInteractiveChart) {
                                var lineDataPoint = void 0;
                                if (this.data.isScalar) {
                                    if (categoryDataPoint) for (var targetCategoryValue = categoryDataPoint.categoryValue, i_1 = 0; i_1 < lineData.length; i_1++) if (lineData[i_1].categoryValue === targetCategoryValue) {
                                        lineDataPoint = lineData[i_1];
                                        break;
                                    }
                                } else lineDataPoint = lineData[columnIndex];
                                measure = lineDataPoint && lineDataPoint.value;
                            }
                            var label = visuals.converterHelper.getFormattedLegendLabel(series.yCol, this.dataViewCat.values, formatStringProp);
                            seriesYCol = series.yCol, legendDataPoints.push({
                                color: series.color,
                                icon: visuals.LegendIcon.Line,
                                label: label,
                                category: visuals.valueFormatter.format(category, visuals.valueFormatter.getFormatString(series.xCol, formatStringProp)),
                                measure: visuals.valueFormatter.format(measure, visuals.valueFormatter.getFormatString(series.yCol, formatStringProp)),
                                identity: series.identity,
                                selected: series.selected
                            });
                        }
                        var dvValues = this.dataViewCat ? this.dataViewCat.values : null, title = dvValues && dvValues.source ? dvValues.source.displayName : "";
                        return {
                            title: title,
                            dataPoints: legendDataPoints,
                            grouped: data.hasDynamicSeries
                        };
                    }
                }, LineChart.prototype.createLabelDataPoints = function() {
                    var labelSettings, axisFormatter, seriesLabelDataPoints, seriesDataPointsCandidates, seriesIndex, seriesCount, currentSeries, _this = this, xScale = this.xAxisProperties.scale, yScale = this.yAxisProperties.scale, lineshift = this.getXOfFirstCategory(), data = this.data, series = this.clippedData ? this.clippedData.series : data.series, baseLabelSettings = data.dataLabelsSettings, formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager(), isStackedArea = EnumExtensions.hasFlag(this.lineType, 16), labelDataPointGroups = [], _loop_1 = function() {
                        currentSeries = series[seriesIndex], labelSettings = currentSeries.labelSettings || baseLabelSettings;
                        var densityAtMax = "100" === labelSettings.labelDensity, maxNumberOfLabels = this_1.advancedLineLabelsEnabled && !densityAtMax && data.isScalar ? LineChart.getNumberOfLabelsToRender(this_1.currentViewport.width, _.parseInt(labelSettings.labelDensity)) : currentSeries.data.length;
                        if (!labelSettings.show) return labelDataPointGroups[seriesIndex] = {
                            labelDataPoints: [],
                            maxNumberOfLabels: 0
                        }, "continue";
                        axisFormatter = visuals.NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this_1.yAxisProperties.formatter, labelSettings);
                        var dataPoints = currentSeries.data;
                        seriesLabelDataPoints = [], seriesDataPointsCandidates = [];
                        var createLabelDataPoint = function(dataPoint, categoryIndex) {
                            if (null == dataPoint.value) return null;
                            var parentShape, formatString = dataPoint.labelFormatString, formatter = formattersCache.getOrCreate(formatString, labelSettings, axisFormatter), text = visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(dataPoint.value)), properties = {
                                text: text,
                                fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                                fontSize: PixelConverter.fromPoint(labelSettings.fontSize),
                                fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight
                            }, textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties) + visuals.NewDataLabelUtils.LabelDensityPadding, textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, !0), isParentRect = !1;
                            if (isStackedArea) {
                                var bottomPos = Math.max(dataPoint.stackedValue - dataPoint.value, yScale.domain()[0]), areaWidth = _this.currentViewport.width;
                                parentShape = {
                                    rect: {
                                        left: xScale(_this.getXValue(dataPoint)) - areaWidth / 2,
                                        top: yScale(Math.max(dataPoint.stackedValue, dataPoint.stackedValue - dataPoint.value)),
                                        width: areaWidth,
                                        height: Math.abs(yScale(dataPoint.stackedValue) - yScale(bottomPos))
                                    },
                                    orientation: dataPoint.value >= 0 ? 1 : 2,
                                    validPositions: LineChart.validStackedLabelPositions
                                }, isParentRect = !0;
                            } else parentShape = {
                                point: {
                                    x: xScale(_this.getXValue(dataPoint)) + lineshift,
                                    y: yScale(dataPoint.value)
                                },
                                radius: 0,
                                validPositions: densityAtMax ? [ 1 ] : _this.getValidLabelPositions(currentSeries, categoryIndex)
                            };
                            var labelDataPoint = {
                                isPreferred: !1,
                                text: text,
                                textSize: {
                                    width: textWidth,
                                    height: textHeight
                                },
                                outsideFill: labelSettings.labelColor ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultLabelColor,
                                insideFill: labelSettings.labelColor && isStackedArea ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultInsideLabelColor,
                                parentType: isParentRect ? 1 : 0,
                                parentShape: parentShape,
                                fontSize: labelSettings.fontSize,
                                identity: dataPoint.identity,
                                key: dataPoint.key
                            };
                            return labelDataPoint;
                        };
                        if (!_.isEmpty(dataPoints)) for (var categoryIndex = 0, categoryCount = dataPoints.length; categoryCount > categoryIndex; categoryIndex++) {
                            var labelDataPoint = createLabelDataPoint(dataPoints[categoryIndex], categoryIndex);
                            labelDataPoint && seriesLabelDataPoints.push(labelDataPoint);
                        }
                        labelDataPointGroups[seriesIndex] = {
                            labelDataPoints: seriesLabelDataPoints,
                            maxNumberOfLabels: maxNumberOfLabels
                        };
                    }, this_1 = this;
                    for (seriesIndex = 0, seriesCount = series.length; seriesCount > seriesIndex; seriesIndex++) {
                        _loop_1();
                    }
                    if (this.advancedLineLabelsEnabled && 16 !== this.lineType) {
                        var sorter = new visuals.MinMaxLabelDataPointSorter({
                            unsortedLabelDataPointGroups: labelDataPointGroups,
                            series: series,
                            viewport: this.currentViewport,
                            yAxisProperties: this.yAxisProperties
                        });
                        return sorter.getSortedDataLabels();
                    }
                    return labelDataPointGroups;
                }, LineChart.getNumberOfLabelsToRender = function(viewPortWidth, labelDensity) {
                    if (null == labelDensity || 0 === labelDensity) return LineChart.minimumLabelsToRender;
                    var parsedAndNormalizedDensity = labelDensity / 100, maxNumberForViewport = Math.ceil(viewPortWidth / visuals.MinMaxLabelDataPointSorter.estimatedLabelWidth);
                    return 1 === parsedAndNormalizedDensity ? maxNumberForViewport : LineChart.minimumLabelsToRender + Math.floor(parsedAndNormalizedDensity * (maxNumberForViewport - LineChart.minimumLabelsToRender));
                }, LineChart.prototype.adjustPathXCoordinate = function(x) {
                    var xScale = this.scaleDetector.getScale().x;
                    return x -= powerbi.Double.equalWithPrecision(xScale, 1, 1e-5) ? this.pathXAdjustment : this.pathXAdjustment * xScale;
                }, LineChart.prototype.getValidLabelPositions = function(series, categoryIndex) {
                    if (!this.advancedLineLabelsEnabled) return [ 1 ];
                    var data = series.data, dataLength = data.length, isLastPoint = categoryIndex === dataLength - 1, isFirstPoint = 0 === categoryIndex, currentValue = data[categoryIndex].value, previousValue = isFirstPoint ? void 0 : data[categoryIndex - 1].value, nextValue = isLastPoint ? void 0 : data[categoryIndex + 1].value, previousRelativePosition = 1, nextRelativePosition = 1;
                    if (null == previousValue ? previousRelativePosition = 0 : previousValue > currentValue ? previousRelativePosition = 3 : currentValue > previousValue && (previousRelativePosition = 2), 
                    null === nextValue ? nextRelativePosition = 0 : nextValue > currentValue ? nextRelativePosition = 3 : currentValue > nextValue && (nextRelativePosition = 2), 
                    isFirstPoint) switch (nextRelativePosition) {
                      case 3:
                        return [ 2, 1 ];

                      default:
                        return [ 1, 2 ];
                    }
                    if (isLastPoint) switch (previousRelativePosition) {
                      case 3:
                        return [ 2, 1 ];

                      default:
                        return [ 1, 2 ];
                    }
                    switch (previousRelativePosition) {
                      case 0:
                        switch (nextRelativePosition) {
                          case 0:
                            return [ 1, 2, 8, 4 ];

                          case 1:
                            return [ 1, 2, 4, 8 ];

                          case 3:
                            return [ 2, 1, 4, 8 ];

                          case 2:
                            return [ 1, 2, 4, 8 ];
                        }

                      case 1:
                        switch (nextRelativePosition) {
                          case 0:
                            return [ 1, 2, 8, 4 ];

                          case 1:
                            return [ 1, 2, 8, 4 ];

                          case 3:
                            return [ 2, 1, 8, 4 ];

                          case 2:
                            return [ 1, 2, 8, 4 ];
                        }

                      case 3:
                        switch (nextRelativePosition) {
                          case 0:
                            return [ 2, 1, 8, 4 ];

                          case 1:
                            return [ 2, 1, 4, 8 ];

                          case 3:
                            return [ 2, 1, 8, 4 ];

                          case 2:
                            return [ 1, 2, 8, 4 ];
                        }

                      case 2:
                        switch (nextRelativePosition) {
                          case 0:
                            return [ 1, 2, 8, 4 ];

                          case 1:
                            return [ 1, 2, 4, 8 ];

                          case 3:
                            return [ 1, 2, 8, 4 ];

                          case 2:
                            return [ 1, 2, 8, 4 ];
                        }
                    }
                }, LineChart.ClassName = "lineChart", LineChart.MainGraphicsContextClassName = "mainGraphicsContext", 
                LineChart.CategorySelector = createClassAndSelector("cat"), LineChart.CategoryValuePoint = createClassAndSelector("dot"), 
                LineChart.CategoryPointSelector = createClassAndSelector("point"), LineChart.CategoryAreaSelector = createClassAndSelector("catArea"), 
                LineChart.HoverLineCircleDot = createClassAndSelector("circle-item"), LineChart.LineClassSelector = createClassAndSelector("line"), 
                LineChart.PointRadius = 5, LineChart.CircleRadius = 4, LineChart.PathElementName = "path", 
                LineChart.CircleElementName = "circle", LineChart.CircleClassName = "selection-circle", 
                LineChart.LineElementName = "line", LineChart.RectOverlayName = "rect", LineChart.ScalarOuterPadding = 10, 
                LineChart.interactivityStrokeWidth = 10, LineChart.minimumLabelsToRender = 4, LineChart.AreaFillOpacity = .4, 
                LineChart.DimmedAreaFillOpacity = .2, LineChart.validStackedLabelPositions = [ 1, 4, 2 ], 
                LineChart;
            }();
            visuals.LineChart = LineChart;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi, InJs = (window.powerbitests, 
    window.InJs), Microsoft = (window.debug, window.jasmine, window.Microsoft);
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var Color = jsCommon.Color, PixelConverter = jsCommon.PixelConverter, Polygon = visuals.shapes.Polygon, DataRoleHelper = powerbi.data.DataRoleHelper;
            visuals.MaxLevelOfDetail = 23, visuals.MinLevelOfDetail = 1, visuals.DefaultFillOpacity = .5, 
            visuals.DefaultBackgroundColor = "#000000", visuals.LeaderLineColor = "#000000";
            var MapBubbleDataPointRenderer = function() {
                function MapBubbleDataPointRenderer(tooltipsEnabled) {
                    this.tooltipsEnabled = tooltipsEnabled;
                }
                return MapBubbleDataPointRenderer.prototype.init = function(mapControl, mapDiv, addClearCatcher) {
                    this.mapControl = mapControl, this.root = mapDiv;
                    var root = d3.select(mapDiv[0]);
                    root.attr("drag-resize-disabled", "true");
                    var svg = this.svg = root.append("svg").style("position", "absolute").style("pointer-events", "none");
                    if (addClearCatcher) {
                        var clearSvg = this.clearSvg = d3.select(this.mapControl.getRootElement()).append("svg").style("position", "absolute");
                        this.clearCatcher = visuals.appendClearCatcher(clearSvg);
                    }
                    this.bubbleGraphicsContext = svg.append("g").classed("mapBubbles", !0), this.sliceGraphicsContext = svg.append("g").classed("mapSlices", !0), 
                    this.labelBackgroundGraphicsContext = svg.append("g").classed(visuals.NewDataLabelUtils.labelBackgroundGraphicsContextClass["class"], !0), 
                    this.labelGraphicsContext = svg.append("g").classed(visuals.NewDataLabelUtils.labelGraphicsContextClass["class"], !0), 
                    this.sliceLayout = d3.layout.pie().sort(null).value(function(d) {
                        return d.value;
                    }), this.arc = d3.svg.arc(), this.clearMaxDataPointRadius(), this.dataLabelsSettings = visuals.dataLabelUtils.getDefaultMapLabelSettings();
                }, MapBubbleDataPointRenderer.prototype.setData = function(data) {
                    this.mapData = data;
                }, MapBubbleDataPointRenderer.prototype.clearDataPoints = function() {
                    this.mapData = {
                        dataPoints: [],
                        geocodingCategory: null,
                        hasDynamicSeries: !1,
                        hasSize: !1
                    };
                }, MapBubbleDataPointRenderer.prototype.getDataPointCount = function() {
                    return this.mapData ? _.filter(this.mapData.dataPoints, function(value) {
                        return !!value.location;
                    }).length : 0;
                }, MapBubbleDataPointRenderer.prototype.getDataPointPadding = function() {
                    return 2 * this.maxDataPointRadius;
                }, MapBubbleDataPointRenderer.prototype.clearMaxDataPointRadius = function() {
                    this.maxDataPointRadius = 0;
                }, MapBubbleDataPointRenderer.prototype.setMaxDataPointRadius = function(dataPointRadius) {
                    this.maxDataPointRadius = Math.max(dataPointRadius, this.maxDataPointRadius);
                }, MapBubbleDataPointRenderer.prototype.getDefaultMap = function(geocodingCategory, dataPointCount) {
                    this.clearDataPoints();
                }, MapBubbleDataPointRenderer.prototype.converter = function(viewport, dataView, labelSettings, interactivityService, tooltipsEnabled) {
                    void 0 === tooltipsEnabled && (tooltipsEnabled = !0);
                    var mapControl = this.mapControl, widthOverTwo = viewport.width / 2, heightOverTwo = viewport.height / 2, strokeWidth = 1;
                    this.dataLabelsSettings = labelSettings;
                    var radiusScale = Math.min(viewport.width, viewport.height) / 384;
                    this.clearMaxDataPointRadius();
                    var grouped, dataValuesSource, bubbleData = [], sliceData = [], categorical = dataView ? dataView.categorical : null, sizeIndex = -1;
                    categorical && categorical.values && (grouped = categorical.values.grouped(), sizeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Size"), 
                    dataValuesSource = categorical.values.source);
                    for (var dataPoints = this.mapData ? this.mapData.dataPoints : [], hasSize = this.mapData.hasSize, categoryIndex = 0, categoryCount = dataPoints.length; categoryCount > categoryIndex; categoryIndex++) {
                        var dataPoint = dataPoints[categoryIndex], categoryValue = dataPoint.categoryValue, location_1 = dataPoint.location;
                        if (location_1) {
                            var xy = mapControl.tryLocationToPixel(new Microsoft.Maps.Location(location_1.latitude, location_1.longitude)), x = xy.x + widthOverTwo, y = xy.y + heightOverTwo, radius = dataPoint.radius * radiusScale;
                            this.setMaxDataPointRadius(radius);
                            var subDataPoints = dataPoint.subDataPoints, seriesCount = subDataPoints.length;
                            if (1 === seriesCount) {
                                var subDataPoint = subDataPoints[0];
                                bubbleData.push({
                                    x: x,
                                    y: y,
                                    labeltext: categoryValue,
                                    radius: radius,
                                    fill: subDataPoint.fill,
                                    stroke: subDataPoint.stroke,
                                    strokeWidth: strokeWidth,
                                    tooltipInfo: subDataPoint.tooltipInfo,
                                    identity: subDataPoint.identity,
                                    selected: !1,
                                    labelFill: labelSettings.labelColor
                                });
                            } else {
                                for (var slices = [], seriesIndex = 0; seriesCount > seriesIndex; seriesIndex++) {
                                    var subDataPoint = subDataPoints[seriesIndex], value = hasSize ? subDataPoint.value : 1;
                                    slices.push({
                                        x: x,
                                        y: y,
                                        labeltext: categoryValue,
                                        radius: radius,
                                        fill: subDataPoint.fill,
                                        stroke: subDataPoint.stroke,
                                        strokeWidth: strokeWidth,
                                        value: value,
                                        tooltipInfo: subDataPoint.tooltipInfo,
                                        identity: subDataPoint.identity,
                                        selected: !1,
                                        labelFill: labelSettings.labelColor
                                    });
                                }
                                interactivityService && interactivityService.applySelectionStateToData(slices), 
                                sliceData.push(slices);
                            }
                        }
                    }
                    return interactivityService && interactivityService.applySelectionStateToData(bubbleData), 
                    {
                        bubbleData: bubbleData,
                        sliceData: sliceData
                    };
                }, MapBubbleDataPointRenderer.prototype.updateInternal = function(data, viewport, dataChanged, interactivityService, redrawDataLabels) {
                    Map.removeTransform3d(this.root), this.mapRendererData = data, this.svg && this.svg.style("width", viewport.width.toString() + "px").style("height", viewport.height.toString() + "px"), 
                    this.clearSvg && this.clearSvg.style("width", viewport.width.toString() + "px").style("height", viewport.height.toString() + "px");
                    var arc = this.arc, hasSelection = interactivityService && interactivityService.hasSelection(), bubbles = this.bubbleGraphicsContext.selectAll(".bubble").data(data.bubbleData, function(d) {
                        return d.identity.getKey();
                    });
                    bubbles.enter().append("circle").classed("bubble", !0), bubbles.attr("cx", function(d) {
                        return d.x;
                    }).attr("cy", function(d) {
                        return d.y;
                    }).attr("r", function(d) {
                        return d.radius;
                    }).style("fill", function(d) {
                        return d.fill;
                    }).style("stroke", function(d) {
                        return d.stroke;
                    }).style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.selected, !1, hasSelection, !1);
                    }).style("strokeWidth", function(d) {
                        return d.strokeWidth;
                    }).style("stroke-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.selected, !1, hasSelection, !1);
                    }).style("cursor", "default"), bubbles.exit().remove(), this.tooltipsEnabled && (visuals.TooltipManager.addTooltip(this.bubbleGraphicsContext, function(tooltipEvent) {
                        return tooltipEvent.data.tooltipInfo;
                    }), bubbles.style("pointer-events", "all"));
                    var sliceData = data.sliceData, sliceContainers = this.sliceGraphicsContext.selectAll(".sliceContainer").data(sliceData);
                    sliceContainers.enter().append("g").classed("sliceContainer", !0), sliceContainers.exit().remove();
                    var sliceLayout = this.sliceLayout, slices = sliceContainers.selectAll(".slice").data(function(d) {
                        return sliceLayout(d);
                    }, function(d) {
                        return d.data.identity.getKey();
                    });
                    slices.enter().append("path").classed("slice", !0), slices.style("fill", function(t) {
                        return t.data.fill;
                    }).style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.data.selected, !1, hasSelection, !1);
                    }).style("stroke", function(t) {
                        return t.data.stroke;
                    }).style("strokeWidth", function(t) {
                        return t.data.strokeWidth;
                    }).style("stroke-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.data.selected, !1, hasSelection, !1);
                    }).style("cursor", "default").attr("transform", function(t) {
                        return visuals.SVGUtil.translate(t.data.x, t.data.y);
                    }).attr("d", function(t) {
                        return arc.innerRadius(0).outerRadius(function(t) {
                            return t.data.radius;
                        })(t);
                    }), slices.exit().remove(), this.updateInternalDataLabels(viewport, redrawDataLabels), 
                    this.tooltipsEnabled && (visuals.TooltipManager.addTooltip(this.sliceGraphicsContext, function(tooltipEvent) {
                        return tooltipEvent.data.data.tooltipInfo;
                    }), slices.style("pointer-events", "all"));
                    for (var allData = data.bubbleData.slice(), i = 0, ilen = sliceData.length; ilen > i; i++) allData.push.apply(allData, sliceData[i]);
                    var behaviorOptions = {
                        bubbleEventGroup: this.bubbleGraphicsContext,
                        sliceEventGroup: this.sliceGraphicsContext,
                        bubbles: bubbles,
                        slices: slices,
                        clearCatcher: this.clearCatcher,
                        dataPoints: allData
                    };
                    return behaviorOptions;
                }, MapBubbleDataPointRenderer.prototype.updateInternalDataLabels = function(viewport, redrawDataLabels) {
                    var labelSettings = this.dataLabelsSettings, dataLabels = [];
                    if (labelSettings && (labelSettings.show || labelSettings.showCategory)) {
                        var labelDataPoints = this.createLabelDataPoints(), labelLayout = new powerbi.LabelLayout({
                            maximumOffset: visuals.NewDataLabelUtils.maxLabelOffset,
                            startingOffset: visuals.NewDataLabelUtils.startingLabelOffset
                        }), labelDataPointsGroup = {
                            labelDataPoints: labelDataPoints,
                            maxNumberOfLabels: labelDataPoints.length
                        };
                        dataLabels = labelLayout.layout([ labelDataPointsGroup ], {
                            width: viewport.width,
                            height: viewport.height
                        });
                    }
                    visuals.NewDataLabelUtils.drawLabelBackground(this.labelGraphicsContext, dataLabels, powerbi.visuals.DefaultBackgroundColor, powerbi.visuals.DefaultFillOpacity), 
                    visuals.NewDataLabelUtils.drawDefaultLabels(this.labelGraphicsContext, dataLabels, !1);
                }, MapBubbleDataPointRenderer.prototype.createLabelDataPoints = function() {
                    var data = this.mapRendererData, labelDataPoints = [], dataPoints = data.bubbleData;
                    dataPoints = dataPoints.concat(_.map(data.sliceData, function(value) {
                        return value[0];
                    }));
                    for (var labelSettings = this.dataLabelsSettings, _i = 0, dataPoints_1 = dataPoints; _i < dataPoints_1.length; _i++) {
                        var dataPoint = dataPoints_1[_i], text = dataPoint.labeltext, properties = {
                            text: text,
                            fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                            fontSize: PixelConverter.fromPoint(labelSettings.fontSize),
                            fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight
                        }, textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties), textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
                        labelDataPoints.push({
                            isPreferred: !0,
                            text: text,
                            textSize: {
                                width: textWidth,
                                height: textHeight
                            },
                            outsideFill: labelSettings.labelColor ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultInsideLabelColor,
                            insideFill: visuals.NewDataLabelUtils.defaultInsideLabelColor,
                            parentType: 0,
                            parentShape: {
                                point: {
                                    x: dataPoint.x,
                                    y: dataPoint.y
                                },
                                radius: dataPoint.radius,
                                validPositions: MapBubbleDataPointRenderer.validLabelPositions
                            },
                            fontSize: labelSettings.fontSize,
                            identity: void 0,
                            hasBackground: !0
                        });
                    }
                    return labelDataPoints;
                }, MapBubbleDataPointRenderer.validLabelPositions = [ 1, 2, 4, 8 ], MapBubbleDataPointRenderer;
            }();
            visuals.MapBubbleDataPointRenderer = MapBubbleDataPointRenderer;
            var MapShapeDataPointRenderer = function() {
                function MapShapeDataPointRenderer(fillMapDataLabelsEnabled, tooltipsEnabled) {
                    this.filledMapDataLabelsEnabled = fillMapDataLabelsEnabled, this.tooltipsEnabled = tooltipsEnabled;
                }
                return MapShapeDataPointRenderer.getFilledMapParams = function(category, dataCount) {
                    switch (category) {
                      case visuals.MapUtil.CategoryTypes.Continent:
                      case visuals.MapUtil.CategoryTypes.CountryRegion:
                        return 10 > dataCount ? {
                            level: 1,
                            maxPolygons: 50,
                            strokeWidth: 0
                        } : 30 > dataCount ? {
                            level: 1,
                            maxPolygons: 20,
                            strokeWidth: 0
                        } : {
                            level: 1,
                            maxPolygons: 5,
                            strokeWidth: 0
                        };

                      default:
                        return 100 > dataCount ? {
                            level: 1,
                            maxPolygons: 5,
                            strokeWidth: 6
                        } : 200 > dataCount ? {
                            level: 0,
                            maxPolygons: 5,
                            strokeWidth: 6
                        } : {
                            level: 0,
                            maxPolygons: 5,
                            strokeWidth: 0
                        };
                    }
                }, MapShapeDataPointRenderer.buildPaths = function(locations) {
                    for (var paths = [], i = 0; i < locations.length; i++) {
                        var location_2 = locations[i], polygon = location_2.geographic;
                        polygon.length > 2 && paths.push(location_2);
                    }
                    return paths;
                }, MapShapeDataPointRenderer.prototype.init = function(mapControl, mapDiv, addClearCatcher) {
                    this.mapControl = mapControl, this.polygonInfo = new visuals.MapPolygonInfo(), this.root = mapDiv;
                    var root = d3.select(mapDiv[0]);
                    root.attr("drag-resize-disabled", "true");
                    var svg = this.svg = root.append("svg").style("position", "absolute").style("pointer-events", "none");
                    if (addClearCatcher) {
                        var clearSvg = this.clearSvg = d3.select(this.mapControl.getRootElement()).append("svg").style("position", "absolute");
                        this.clearCatcher = visuals.appendClearCatcher(clearSvg);
                    }
                    this.shapeGraphicsContext = svg.append("g").classed("mapShapes", !0), this.labelBackgroundGraphicsContext = svg.append("g").classed(visuals.NewDataLabelUtils.labelBackgroundGraphicsContextClass["class"], !0), 
                    this.labelGraphicsContext = svg.append("g").classed(visuals.NewDataLabelUtils.labelGraphicsContextClass["class"], !0), 
                    this.clearMaxShapeDimension(), this.dataLabelsSettings = visuals.dataLabelUtils.getDefaultMapLabelSettings();
                }, MapShapeDataPointRenderer.prototype.setData = function(data) {
                    this.mapData = data;
                }, MapShapeDataPointRenderer.prototype.clearDataPoints = function() {
                    this.mapData = {
                        dataPoints: [],
                        geocodingCategory: null,
                        hasDynamicSeries: !1,
                        hasSize: !1
                    };
                }, MapShapeDataPointRenderer.prototype.getDataPointCount = function() {
                    return this.mapData ? _.filter(this.mapData.dataPoints, function(value) {
                        return !!value.paths;
                    }).length : 0;
                }, MapShapeDataPointRenderer.prototype.converter = function(viewport, dataView, labelSettings, interactivityService) {
                    this.clearMaxShapeDimension(), this.dataLabelsSettings = labelSettings;
                    for (var strokeWidth = 1, shapeData = [], dataPoints = this.mapData ? this.mapData.dataPoints : [], categoryIndex = 0, categoryCount = dataPoints.length; categoryCount > categoryIndex; categoryIndex++) {
                        var categorical = dataView ? dataView.categorical : null, dataPoint = dataPoints[categoryIndex], subDataPoint = dataPoint.subDataPoints[0], paths = dataPoint.paths, grouped = void 0, sizeIndex = -1, dataValuesSource = void 0;
                        if (categorical && categorical.values && (grouped = categorical.values.grouped(), 
                        sizeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Size"), dataValuesSource = categorical.values.source), 
                        paths) for (var value = dataPoint.value, categoryValue = dataPoint.categoryValue, identity = subDataPoint.identity, idKey = identity.getKey(), formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager(), mainShapeIndex = MapShapeDataPointRenderer.getIndexOfLargestShape(paths), pathIndex = 0, pathCount = paths.length; pathCount > pathIndex; pathIndex++) {
                            var path = paths[pathIndex], labelFormatString = dataView && dataView.categorical && !_.isEmpty(dataView.categorical.values) ? visuals.valueFormatter.getFormatString(dataView.categorical.values[0].source, visuals.filledMapProps.general.formatString) : void 0;
                            this.setMaxShapeDimension(path.absoluteBounds.width, path.absoluteBounds.height);
                            var formatter = formattersCache.getOrCreate(labelFormatString, labelSettings);
                            shapeData.push({
                                absolutePointArray: path.absolute,
                                path: path.absoluteString,
                                fill: subDataPoint.fill,
                                stroke: subDataPoint.stroke,
                                strokeWidth: strokeWidth,
                                tooltipInfo: subDataPoint.tooltipInfo,
                                identity: identity,
                                selected: !1,
                                key: JSON.stringify({
                                    id: idKey,
                                    pIdx: pathIndex
                                }),
                                displayLabel: pathIndex === mainShapeIndex,
                                labeltext: categoryValue,
                                catagoryLabeltext: null != value ? visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(value)) : void 0,
                                labelFormatString: labelFormatString
                            });
                        }
                    }
                    return interactivityService && interactivityService.applySelectionStateToData(shapeData), 
                    {
                        shapeData: shapeData
                    };
                }, MapShapeDataPointRenderer.prototype.updateInternal = function(data, viewport, dataChanged, interactivityService, redrawDataLabels) {
                    Map.removeTransform3d(this.root), this.mapRendererData = data, this.svg && this.svg.style("width", viewport.width.toString() + "px").style("height", viewport.height.toString() + "px"), 
                    this.clearSvg && this.clearSvg.style("width", viewport.width.toString() + "px").style("height", viewport.height.toString() + "px"), 
                    this.polygonInfo.reCalc(this.mapControl, viewport.width, viewport.height), this.shapeGraphicsContext.attr("transform", this.polygonInfo.transformToString(this.polygonInfo.transform));
                    var hasSelection = interactivityService && interactivityService.hasSelection(), shapes = this.shapeGraphicsContext.selectAll("polygon").data(data.shapeData, function(d) {
                        return d.key;
                    });
                    shapes.enter().append("polygon").classed("shape", !0).attr("points", function(d) {
                        return d.path;
                    }), shapes.style("fill", function(d) {
                        return d.fill;
                    }).style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.selected, !1, hasSelection, !1);
                    }).style("cursor", "default"), dataChanged && shapes.attr("points", function(d) {
                        return d.path;
                    }), shapes.exit().remove(), this.updateInternalDataLabels(viewport, redrawDataLabels), 
                    this.tooltipsEnabled && (visuals.TooltipManager.addTooltip(this.shapeGraphicsContext, function(tooltipEvent) {
                        return tooltipEvent.data.tooltipInfo;
                    }), shapes.style("pointer-events", "all"));
                    var behaviorOptions = {
                        shapeEventGroup: this.shapeGraphicsContext,
                        shapes: shapes,
                        clearCatcher: this.clearCatcher,
                        dataPoints: data.shapeData
                    };
                    return behaviorOptions;
                }, MapShapeDataPointRenderer.prototype.getDataPointPadding = function() {
                    return 12;
                }, MapShapeDataPointRenderer.getIndexOfLargestShape = function(paths) {
                    for (var largestShapeIndex = 0, largestShapeArea = 0, pathIndex = 0, pathCount = paths.length; pathCount > pathIndex; pathIndex++) {
                        var path = paths[pathIndex], polygon = new Polygon(path.absolute), currentShapeArea = Math.abs(Polygon.calculateAbsolutePolygonArea(polygon.polygonPoints));
                        currentShapeArea > largestShapeArea && (largestShapeIndex = pathIndex, largestShapeArea = currentShapeArea);
                    }
                    return largestShapeIndex;
                }, MapShapeDataPointRenderer.prototype.updateInternalDataLabels = function(viewport, redrawDataLabels) {
                    var labels, labelSettings = this.dataLabelsSettings;
                    if (labelSettings && (labelSettings.show || labelSettings.showCategory)) {
                        var labelDataPoints = this.createLabelDataPoints();
                        void 0 === this.labelLayout && (this.labelLayout = new powerbi.FilledMapLabelLayout()), 
                        labels = this.labelLayout.layout(labelDataPoints, {
                            width: viewport.width,
                            height: viewport.height
                        }, this.polygonInfo.transform, redrawDataLabels);
                    }
                    this.drawLabelStems(this.labelGraphicsContext, labels, labelSettings.show, labelSettings.showCategory), 
                    visuals.NewDataLabelUtils.drawLabelBackground(this.labelGraphicsContext, labels, powerbi.visuals.DefaultBackgroundColor, powerbi.visuals.DefaultFillOpacity), 
                    visuals.NewDataLabelUtils.drawDefaultLabels(this.labelGraphicsContext, labels, !1, labelSettings.show && labelSettings.showCategory);
                }, MapShapeDataPointRenderer.prototype.clearMaxShapeDimension = function() {
                    this.maxShapeDimension = 0;
                }, MapShapeDataPointRenderer.prototype.setMaxShapeDimension = function(width, height) {
                    this.maxShapeDimension = Math.max(width, this.maxShapeDimension), this.maxShapeDimension = Math.max(height, this.maxShapeDimension);
                }, MapShapeDataPointRenderer.prototype.createLabelDataPoints = function() {
                    var data = this.mapRendererData, labelDataPoints = [];
                    if (this.filledMapDataLabelsEnabled) for (var dataShapes = data.shapeData, labelSettings = this.dataLabelsSettings, _i = 0, dataShapes_1 = dataShapes; _i < dataShapes_1.length; _i++) {
                        var dataShape = dataShapes_1[_i];
                        if (dataShape.displayLabel) {
                            var text = void 0, secondRowText = void 0, secondRowTextWidth = 0, hasSecondRow = !1;
                            if (this.dataLabelsSettings.show && !this.dataLabelsSettings.showCategory) {
                                if (text = dataShape.catagoryLabeltext, void 0 === text) continue;
                            } else if (this.dataLabelsSettings.showCategory && !this.dataLabelsSettings.show) {
                                if (text = dataShape.labeltext, void 0 === text) continue;
                            } else if (this.dataLabelsSettings.showCategory && this.dataLabelsSettings.show) {
                                if (text = dataShape.catagoryLabeltext, secondRowText = dataShape.labeltext, void 0 === text && void 0 === secondRowText) continue;
                                hasSecondRow = !0;
                            }
                            if (hasSecondRow) {
                                var secondRowProperties = {
                                    text: secondRowText,
                                    fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                                    fontSize: visuals.NewDataLabelUtils.LabelTextProperties.fontSize,
                                    fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight
                                };
                                secondRowTextWidth = powerbi.TextMeasurementService.measureSvgTextWidth(secondRowProperties);
                            }
                            var firstRowProperties = {
                                text: text,
                                fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                                fontSize: visuals.NewDataLabelUtils.LabelTextProperties.fontSize,
                                fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight
                            }, textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(firstRowProperties), textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(firstRowProperties);
                            secondRowText && void 0 !== dataShape.labeltext && void 0 !== dataShape.catagoryLabeltext && (textHeight = 2 * textHeight);
                            var labelDataPoint = {
                                parentType: 2,
                                parentShape: {
                                    polygon: new Polygon(dataShape.absolutePointArray),
                                    validPositions: MapShapeDataPointRenderer.validLabelPolygonPositions
                                },
                                text: text,
                                secondRowText: secondRowText,
                                textSize: {
                                    width: Math.max(textWidth, secondRowTextWidth),
                                    height: textHeight
                                },
                                insideFill: labelSettings.labelColor,
                                outsideFill: labelSettings.labelColor ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultInsideLabelColor,
                                isPreferred: !1,
                                identity: void 0,
                                hasBackground: !0
                            };
                            labelDataPoints.push(labelDataPoint);
                        }
                    }
                    return labelDataPoints;
                }, MapShapeDataPointRenderer.prototype.drawLabelStems = function(labelsContext, dataLabels, showText, showCategory) {
                    var filteredLabels = _.filter(dataLabels, function(d) {
                        return d.isVisible;
                    }), key = function(d, index) {
                        return d.identity ? d.identity.getKeyWithoutHighlight() : index;
                    };
                    visuals.NewDataLabelUtils.drawLabelLeaderLines(labelsContext, filteredLabels, key, visuals.LeaderLineColor);
                }, MapShapeDataPointRenderer.validLabelPolygonPositions = [ 256, 2, 1, 8, 4, 16, 32, 64, 128 ], 
                MapShapeDataPointRenderer;
            }();
            visuals.MapShapeDataPointRenderer = MapShapeDataPointRenderer;
            var DefaultLocationZoomLevel = 11, Map = function() {
                function Map(options) {
                    this.isDestroyed = !1, options.filledMap ? (this.dataPointRenderer = new MapShapeDataPointRenderer(options.filledMapDataLabelsEnabled, options.tooltipsEnabled), 
                    this.filledMapDataLabelsEnabled = options.filledMapDataLabelsEnabled, this.isFilledMap = !0) : (this.dataPointRenderer = new MapBubbleDataPointRenderer(options.tooltipsEnabled), 
                    this.isFilledMap = !1), this.mapControlFactory = options.mapControlFactory ? options.mapControlFactory : this.getDefaultMapControlFactory(), 
                    this.behavior = options.behavior, this.tooltipsEnabled = options.tooltipsEnabled, 
                    this.tooltipBucketEnabled = options.tooltipBucketEnabled, this.disableZooming = options.disableZooming, 
                    this.disablePanning = options.disablePanning, this.isLegendScrollable = !!options.behavior, 
                    this.viewChangeThrottleInterval = options.viewChangeThrottleInterval, this.enableCurrentLocation = options.enableCurrentLocation, 
                    this.boundsHaveBeenUpdated = !1;
                }
                return Map.prototype.init = function(options) {
                    var _this = this, element = this.element = options.element;
                    this.pendingGeocodingRender = !1, this.currentViewport = options.viewport, this.style = options.style, 
                    this.colors = this.style.colorPalette.dataColors, this.behavior && (this.interactivityService = visuals.createInteractivityService(options.host)), 
                    this.dataLabelsSettings = visuals.dataLabelUtils.getDefaultMapLabelSettings(), this.legend = powerbi.visuals.createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, this.interactivityService, this.isLegendScrollable), 
                    this.legendHeight = 0, this.legendData = {
                        dataPoints: []
                    }, this.geoTaggingAnalyzerService = powerbi.createGeoTaggingAnalyzerService(options.host.getLocalizedString), 
                    this.host = options.host, options.host.locale && (this.locale = options.host.locale()), 
                    this.geocoder = options.host.geocoder(), this.promiseFactory = options.host.promiseFactory(), 
                    this.resetBounds(), this.isDestroyed = !1, this.mapControlFactory.ensureMap(this.locale, function() {
                        _this.isDestroyed || (Map.removeHillShading(), Microsoft.Maps.loadModule("Microsoft.Maps.Overlays.Style", {
                            callback: function() {
                                _this.isDestroyed || (_this.initialize(element[0]), _this.enableCurrentLocation && _this.createCurrentLocation(element));
                            }
                        }));
                    });
                }, Map.prototype.destroy = function() {
                    this.isDestroyed = !0, this.geocodingContext && this.geocodingContext.timeout && this.geocodingContext.timeout.resolve(null);
                }, Map.prototype.createCurrentLocation = function(element) {
                    var pushpin, _this = this, myLocBtn = InJs.DomFactory.div().addClass("mapCurrentLocation").appendTo(element);
                    myLocBtn.on("click", function() {
                        _this.isCurrentLocation ? (pushpin && _this.mapControl.entities.remove(pushpin), 
                        _this.updateInternal(!1, !1), _this.isCurrentLocation = !1) : _this.host.geolocation().getCurrentPosition(function(position) {
                            var location = new Microsoft.Maps.Location(position.coords.latitude, position.coords.longitude);
                            pushpin && _this.mapControl.entities.remove(pushpin), pushpin = visuals.MapUtil.CurrentLocation.createPushpin(location), 
                            _this.mapControl.entities.push(pushpin), _this.updateMapView(location, DefaultLocationZoomLevel), 
                            _this.isCurrentLocation = !0;
                        });
                    });
                }, Map.prototype.addDataPoint = function(dataPoint) {
                    var location = dataPoint.location;
                    this.updateBounds(location.latitude, location.longitude), this.scheduleRedraw();
                }, Map.prototype.scheduleRedraw = function() {
                    var _this = this;
                    !this.pendingGeocodingRender && this.mapControl && (this.pendingGeocodingRender = !0, 
                    setTimeout(function() {
                        _this.updateInternal(!0, !0), _this.pendingGeocodingRender = !1;
                    }, Map.ScheduleRedrawInterval));
                }, Map.prototype.enqueueGeoCode = function(dataPoint) {
                    var _this = this, location = this.geocoder.tryGeocodeImmediate(dataPoint.geocodingQuery, this.geocodingCategory);
                    if (location) this.completeGeoCode(dataPoint, location); else {
                        var geocodingContext_1 = this.geocodingContext;
                        this.geocoder.geocode(dataPoint.geocodingQuery, this.geocodingCategory, {
                            timeout: geocodingContext_1.timeout.promise
                        }).then(function(location) {
                            !_this.isDestroyed && location && geocodingContext_1 === _this.geocodingContext && _this.completeGeoCode(dataPoint, location);
                        });
                    }
                }, Map.prototype.completeGeoCode = function(dataPoint, location) {
                    dataPoint.location = location, this.addDataPoint(dataPoint);
                }, Map.prototype.enqueueGeoCodeAndGeoShape = function(dataPoint, params) {
                    var _this = this, location = this.geocoder.tryGeocodeImmediate(dataPoint.geocodingQuery, this.geocodingCategory);
                    if (location) this.completeGeoCodeAndGeoShape(dataPoint, params, location); else {
                        var geocodingContext_2 = this.geocodingContext;
                        this.geocoder.geocode(dataPoint.geocodingQuery, this.geocodingCategory, {
                            timeout: geocodingContext_2.timeout.promise
                        }).then(function(location) {
                            !_this.isDestroyed && location && geocodingContext_2 === _this.geocodingContext && _this.completeGeoCodeAndGeoShape(dataPoint, params, location);
                        });
                    }
                }, Map.prototype.completeGeoCodeAndGeoShape = function(dataPoint, params, location) {
                    dataPoint.location = location, this.enqueueGeoShape(dataPoint, params);
                }, Map.prototype.enqueueGeoShape = function(dataPoint, params) {
                    var _this = this, result = this.geocoder.tryGeocodeBoundaryImmediate(dataPoint.location.latitude, dataPoint.location.longitude, this.geocodingCategory, params.level, params.maxPolygons);
                    if (result) this.completeGeoShape(dataPoint, params, result); else {
                        var geocodingContext_3 = this.geocodingContext;
                        this.geocoder.geocodeBoundary(dataPoint.location.latitude, dataPoint.location.longitude, this.geocodingCategory, params.level, params.maxPolygons, {
                            timeout: geocodingContext_3.timeout.promise
                        }).then(function(result) {
                            !_this.isDestroyed && result && geocodingContext_3 === _this.geocodingContext && _this.completeGeoShape(dataPoint, params, result);
                        });
                    }
                }, Map.prototype.completeGeoShape = function(dataPoint, params, result) {
                    var paths;
                    0 === result.locations.length || result.locations[0].geographic ? paths = MapShapeDataPointRenderer.buildPaths(result.locations) : (visuals.MapUtil.calcGeoData(result), 
                    paths = MapShapeDataPointRenderer.buildPaths(result.locations)), dataPoint.paths = paths, 
                    this.addDataPoint(dataPoint);
                }, Map.prototype.getOptimumLevelOfDetail = function(width, height) {
                    var dataPointCount = this.dataPointRenderer.getDataPointCount();
                    if (0 === dataPointCount) return visuals.MapUtil.MinLevelOfDetail;
                    for (var threshold = this.dataPointRenderer.getDataPointPadding(), levelOfDetail = visuals.MapUtil.MaxLevelOfDetail; levelOfDetail >= visuals.MapUtil.MinLevelOfDetail; levelOfDetail--) {
                        var minXmaxY = visuals.MapUtil.latLongToPixelXY(this.minLatitude, this.minLongitude, levelOfDetail), maxXminY = visuals.MapUtil.latLongToPixelXY(this.maxLatitude, this.maxLongitude, levelOfDetail);
                        if (maxXminY.x - minXmaxY.x + threshold <= width && minXmaxY.y - maxXminY.y + threshold <= height) return 2 > dataPointCount && (levelOfDetail = Math.min(visuals.MapUtil.MaxAutoZoomLevel, levelOfDetail)), 
                        levelOfDetail;
                    }
                    return visuals.MapUtil.MinLevelOfDetail;
                }, Map.prototype.getViewCenter = function(levelOfDetail) {
                    var minXmaxY = visuals.MapUtil.latLongToPixelXY(this.minLatitude, this.minLongitude, levelOfDetail), maxXminY = visuals.MapUtil.latLongToPixelXY(this.maxLatitude, this.maxLongitude, levelOfDetail);
                    return visuals.MapUtil.pixelXYToLocation((minXmaxY.x + maxXminY.x) / 2, (maxXminY.y + minXmaxY.y) / 2, levelOfDetail);
                }, Map.prototype.resetBounds = function() {
                    this.boundsHaveBeenUpdated = !1, this.minLongitude = visuals.MapUtil.MaxAllowedLongitude, 
                    this.maxLongitude = visuals.MapUtil.MinAllowedLongitude, this.minLatitude = visuals.MapUtil.MaxAllowedLatitude, 
                    this.maxLatitude = visuals.MapUtil.MinAllowedLatitude;
                }, Map.prototype.updateBounds = function(latitude, longitude) {
                    this.boundsHaveBeenUpdated = !0, longitude < this.minLongitude && (this.minLongitude = longitude), 
                    longitude > this.maxLongitude && (this.maxLongitude = longitude), latitude < this.minLatitude && (this.minLatitude = latitude), 
                    latitude > this.maxLatitude && (this.maxLatitude = latitude);
                }, Map.legendObject = function(dataView) {
                    return dataView && dataView.metadata && dataView.metadata.objects && dataView.metadata.objects.legend;
                }, Map.isLegendHidden = function(dataView) {
                    var legendObject = Map.legendObject(dataView);
                    return null != legendObject && legendObject[visuals.legendProps.show] === !1;
                }, Map.legendPosition = function(dataView) {
                    var legendObject = Map.legendObject(dataView);
                    return legendObject && visuals.LegendPosition[legendObject[visuals.legendProps.position]];
                }, Map.getLegendFontSize = function(dataView) {
                    var legendObject = Map.legendObject(dataView);
                    return legendObject && legendObject[visuals.legendProps.fontSize] || visuals.SVGLegend.DefaultFontSizeInPt;
                }, Map.isShowLegendTitle = function(dataView) {
                    var legendObject = Map.legendObject(dataView);
                    return legendObject && legendObject[visuals.legendProps.showTitle];
                }, Map.prototype.legendTitle = function() {
                    var legendObject = Map.legendObject(this.dataView);
                    return legendObject && legendObject[visuals.legendProps.titleText] || this.legendData.title;
                }, Map.prototype.renderLegend = function(legendData) {
                    var hideLegend = Map.isLegendHidden(this.dataView), showTitle = Map.isShowLegendTitle(this.dataView), title = this.legendTitle(), clonedLegendData = {
                        dataPoints: hideLegend ? [] : legendData.dataPoints,
                        grouped: legendData.grouped,
                        title: showTitle ? title : "",
                        fontSize: Map.getLegendFontSize(this.dataView)
                    }, targetOrientation = Map.legendPosition(this.dataView);
                    void 0 !== targetOrientation ? this.legend.changeOrientation(targetOrientation) : this.legend.changeOrientation(visuals.LegendPosition.Top), 
                    this.legend.drawLegend(clonedLegendData, this.currentViewport);
                }, Map.calculateGroupSizes = function(categorical, grouped, groupSizeTotals, sizeMeasureIndex, currentValueScale) {
                    for (var categoryCount = categorical.values[0].values.length, seriesCount = grouped.length, i = 0, len = categoryCount; len > i; ++i) {
                        var groupTotal = null;
                        if (sizeMeasureIndex >= 0) for (var j = 0; seriesCount > j; ++j) {
                            var value = grouped[j].values[sizeMeasureIndex].values[i];
                            value && (null === groupTotal ? groupTotal = value : groupTotal += value);
                        }
                        groupSizeTotals.push(groupTotal), groupTotal && (currentValueScale ? (currentValueScale.min = Math.min(currentValueScale.min, groupTotal), 
                        currentValueScale.max = Math.max(currentValueScale.max, groupTotal)) : currentValueScale = {
                            min: groupTotal,
                            max: groupTotal
                        });
                    }
                    return currentValueScale;
                }, Map.calculateRadius = function(range, value) {
                    var rangeDiff = range ? range.max - range.min : 0, radius = 6;
                    return null != range && null != value && 0 !== rangeDiff && (radius = 14 * ((value - range.min) / rangeDiff) + 6), 
                    radius;
                }, Map.getGeocodingCategory = function(categorical, geoTaggingAnalyzerService) {
                    if (categorical && categorical.categories && categorical.categories.length > 0 && categorical.categories[0].source) {
                        var type = categorical.categories[0].source.type;
                        if (type && type.categoryString) return geoTaggingAnalyzerService.getFieldType(type.categoryString);
                        var categoryName = categorical.categories[0].source.displayName, geotaggedResult = geoTaggingAnalyzerService.getFieldType(categoryName);
                        if (geotaggedResult) return geotaggedResult;
                        var roles = categorical.categories[0].source.roles;
                        if (roles) for (var roleNames = Object.keys(roles), i = 0, len = roleNames.length; len > i; ++i) {
                            var typeFromRoleName = geoTaggingAnalyzerService.getFieldType(roleNames[i]);
                            if (typeFromRoleName) return typeFromRoleName;
                        }
                    }
                }, Map.hasSizeField = function(values, defaultIndexIfNoRole) {
                    if (_.isEmpty(values)) return !1;
                    for (var i = 0, ilen = values.length; ilen > i; i++) {
                        var roles = values[i].source.roles;
                        if (!roles && i === defaultIndexIfNoRole && values[i].source.type.numeric) return !0;
                        if (roles) for (var roleNames = Object.keys(roles), j = 0, jlen = roleNames.length; jlen > j; j++) {
                            var role = roleNames[j];
                            if ("Size" === role) return !0;
                        }
                    }
                    return !1;
                }, Map.shouldEnumerateDataPoints = function(dataView, usesSizeForGradient) {
                    var hasSeries = DataRoleHelper.hasRoleInDataView(dataView, "Series"), gradientRole = usesSizeForGradient ? "Size" : "Gradient", hasGradientRole = DataRoleHelper.hasRoleInDataView(dataView, gradientRole);
                    return hasSeries || !hasGradientRole;
                }, Map.shouldEnumerateCategoryLabels = function(isFilledMap, filledMapDataLabelsEnabled) {
                    return !isFilledMap || filledMapDataLabelsEnabled;
                }, Map.prototype.enumerateObjectInstances = function(options) {
                    var enumeration = new visuals.ObjectEnumerationBuilder();
                    switch (options.objectName) {
                      case "dataPoint":
                        if (Map.shouldEnumerateDataPoints(this.dataView, this.isFilledMap)) {
                            var bubbleData = [], hasDynamicSeries = this.hasDynamicSeries;
                            if (!hasDynamicSeries) {
                                var mapData = this.dataPointRenderer.converter(this.getMapViewPort(), this.dataView, this.dataLabelsSettings, this.interactivityService, this.tooltipsEnabled);
                                bubbleData = mapData.bubbleData;
                            }
                            Map.enumerateDataPoints(enumeration, this.dataPointsToEnumerate, this.colors, hasDynamicSeries, this.defaultDataPointColor, this.showAllDataPoints, bubbleData);
                        }
                        break;

                      case "categoryLabels":
                        Map.shouldEnumerateCategoryLabels(this.isFilledMap, this.filledMapDataLabelsEnabled) && visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, this.dataLabelsSettings, !0, !0);
                        break;

                      case "legend":
                        this.hasDynamicSeries && Map.enumerateLegend(enumeration, this.dataView, this.legend, this.legendTitle());
                        break;

                      case "labels":
                        if (this.filledMapDataLabelsEnabled) {
                            this.dataLabelsSettings = this.dataLabelsSettings ? this.dataLabelsSettings : visuals.dataLabelUtils.getDefaultMapLabelSettings();
                            var labelSettingOptions = {
                                enumeration: enumeration,
                                dataLabelsSettings: this.dataLabelsSettings,
                                show: !0,
                                displayUnits: !0,
                                precision: !0
                            };
                            visuals.dataLabelUtils.enumerateDataLabels(labelSettingOptions);
                        }
                    }
                    return enumeration.complete();
                }, Map.enumerateDataPoints = function(enumeration, dataPoints, colors, hasDynamicSeries, defaultDataPointColor, showAllDataPoints, bubbleData) {
                    var seriesLength = dataPoints && dataPoints.length;
                    if (hasDynamicSeries) for (var i = 0; seriesLength > i; i++) {
                        var dataPoint = dataPoints[i];
                        enumeration.pushInstance({
                            objectName: "dataPoint",
                            displayName: dataPoint.label,
                            selector: visuals.ColorHelper.normalizeSelector(dataPoint.identity.getSelector()),
                            properties: {
                                fill: {
                                    solid: {
                                        color: dataPoint.color
                                    }
                                }
                            }
                        });
                    } else if (enumeration.pushInstance({
                        objectName: "dataPoint",
                        selector: null,
                        properties: {
                            defaultColor: {
                                solid: {
                                    color: defaultDataPointColor || colors.getColorByIndex(0).value
                                }
                            }
                        }
                    }).pushInstance({
                        objectName: "dataPoint",
                        selector: null,
                        properties: {
                            showAllDataPoints: !!showAllDataPoints
                        }
                    }), bubbleData) for (var i = 0; i < bubbleData.length; i++) {
                        var bubbleDataPoint = bubbleData[i];
                        enumeration.pushInstance({
                            objectName: "dataPoint",
                            displayName: bubbleDataPoint.labeltext,
                            selector: visuals.ColorHelper.normalizeSelector(bubbleDataPoint.identity.getSelector()),
                            properties: {
                                fill: {
                                    solid: {
                                        color: Color.normalizeToHexString(bubbleDataPoint.fill)
                                    }
                                }
                            }
                        });
                    }
                }, Map.enumerateLegend = function(enumeration, dataView, legend, legendTitle) {
                    enumeration.pushInstance({
                        selector: null,
                        properties: {
                            show: !Map.isLegendHidden(dataView),
                            position: visuals.LegendPosition[legend.getOrientation()],
                            showTitle: Map.isShowLegendTitle(dataView),
                            titleText: legendTitle,
                            fontSize: Map.getLegendFontSize(dataView)
                        },
                        objectName: "legend"
                    });
                }, Map.prototype.onDataChanged = function(options) {
                    var _this = this;
                    this.resetBounds(), this.geocodingContext && this.geocodingContext.timeout && this.geocodingContext.timeout.resolve(null), 
                    this.geocodingContext = {
                        timeout: this.promiseFactory.defer()
                    }, this.behavior && this.behavior.resetZoomPan(), this.dataLabelsSettings = visuals.dataLabelUtils.getDefaultMapLabelSettings(), 
                    this.defaultDataPointColor = null, this.showAllDataPoints = null;
                    var dataView = this.dataView = options.dataViews[0], isFilledMap = this.isFilledMap, warnings = [], data = {
                        dataPoints: [],
                        geocodingCategory: null,
                        hasDynamicSeries: !1,
                        hasSize: !1
                    };
                    if (dataView) {
                        if (dataView.metadata && dataView.metadata.objects) {
                            var objects = dataView.metadata.objects;
                            if (this.defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.mapProps.dataPoint.defaultColor), 
                            this.showAllDataPoints = powerbi.DataViewObjects.getValue(objects, visuals.mapProps.dataPoint.showAllDataPoints), 
                            this.dataLabelsSettings.showCategory = powerbi.DataViewObjects.getValue(objects, visuals.filledMapProps.categoryLabels.show, this.dataLabelsSettings.showCategory), 
                            isFilledMap) {
                                this.dataLabelsSettings.precision = powerbi.DataViewObjects.getValue(objects, visuals.filledMapProps.labels.labelPrecision, this.dataLabelsSettings.precision), 
                                this.dataLabelsSettings.precision = this.dataLabelsSettings.precision !== visuals.dataLabelUtils.defaultLabelPrecision && this.dataLabelsSettings.precision < 0 ? 0 : this.dataLabelsSettings.precision, 
                                this.dataLabelsSettings.displayUnits = powerbi.DataViewObjects.getValue(objects, visuals.filledMapProps.labels.labelDisplayUnits, this.dataLabelsSettings.displayUnits);
                                var datalabelsObj = objects.labels;
                                datalabelsObj && (this.dataLabelsSettings.show = void 0 !== datalabelsObj.show ? datalabelsObj.show : this.dataLabelsSettings.show, 
                                void 0 !== datalabelsObj.color && (this.dataLabelsSettings.labelColor = datalabelsObj.color.solid.color));
                            } else {
                                var categoryLabelsObj = objects.categoryLabels;
                                categoryLabelsObj && visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(categoryLabelsObj, this.dataLabelsSettings);
                            }
                        }
                        var colorHelper = new visuals.ColorHelper(this.colors, visuals.mapProps.dataPoint.fill, this.defaultDataPointColor);
                        data = Map.converter(dataView, colorHelper, this.geoTaggingAnalyzerService, isFilledMap, this.tooltipBucketEnabled), 
                        this.hasDynamicSeries = data.hasDynamicSeries, this.legendData = Map.createLegendData(dataView, colorHelper), 
                        this.dataPointsToEnumerate = this.legendData.dataPoints, this.renderLegend(this.legendData), 
                        null != data ? (this.geocodingCategory = data.geocodingCategory, this.mapControlFactory.ensureMap(this.locale, function() {
                            if (!_this.isDestroyed) {
                                Map.removeHillShading();
                                var params;
                                isFilledMap && (params = MapShapeDataPointRenderer.getFilledMapParams(_this.geocodingCategory, data.dataPoints.length));
                                for (var _i = 0, _a = data.dataPoints; _i < _a.length; _i++) {
                                    var dataPoint = _a[_i];
                                    if (dataPoint.location) isFilledMap && !dataPoint.paths ? _this.enqueueGeoShape(dataPoint, params) : _this.addDataPoint(dataPoint); else {
                                        var categoryValue = dataPoint.categoryValue;
                                        null != categoryValue && "" !== categoryValue && (isFilledMap ? _this.enqueueGeoCodeAndGeoShape(dataPoint, params) : _this.enqueueGeoCode(dataPoint));
                                    }
                                }
                            }
                        })) : this.clearDataPoints(), isFilledMap && (this.geocodingCategory && this.geoTaggingAnalyzerService.isGeoshapable(this.geocodingCategory) || warnings.push(new visuals.FilledMapWithoutValidGeotagCategoryWarning()));
                    } else this.clearDataPoints(), this.renderLegend({
                        dataPoints: [],
                        title: void 0
                    }), this.dataPointsToEnumerate = [];
                    _.isEmpty(warnings) || this.host.setWarnings(warnings), this.dataPointRenderer.setData(data), 
                    this.updateInternal(!0, !0);
                }, Map.converter = function(dataView, colorHelper, geoTaggingAnalyzerService, isFilledMap, tooltipBucketEnabled) {
                    var reader = powerbi.data.createIDataViewCategoricalReader(dataView), dataPoints = [], hasDynamicSeries = reader.hasDynamicSeries(), seriesColumnIdentifier = reader.getSeriesColumnIdentityFields(), sizeQueryName = reader.getMeasureQueryName("Size");
                    null == sizeQueryName && (sizeQueryName = "");
                    var hasSize = reader.hasValues("Size"), geocodingCategory = null, formatStringProp = visuals.mapProps.general.formatString;
                    if (reader.hasCategories()) {
                        var categoryTotals = [], categoryTotalRange = void 0;
                        if (hasSize) {
                            for (var categoryMin = void 0, categoryMax = void 0, categoryIndex = 0, categoryCount = reader.getCategoryCount(); categoryCount > categoryIndex; categoryIndex++) {
                                for (var categoryTotal = void 0, seriesIndex = 0, seriesCount = reader.getSeriesCount(); seriesCount > seriesIndex; seriesIndex++) {
                                    var currentValue = reader.getValue("Size", categoryIndex, seriesIndex);
                                    null == categoryTotal && null != currentValue && (categoryTotal = 0), null != categoryTotal && (categoryTotal += currentValue);
                                }
                                categoryTotals.push(categoryTotal), null != categoryTotal && ((void 0 === categoryMin || categoryMin > categoryTotal) && (categoryMin = categoryTotal), 
                                (void 0 === categoryMax || categoryTotal > categoryMax) && (categoryMax = categoryTotal));
                            }
                            categoryTotalRange = void 0 !== categoryMin && void 0 !== categoryMax ? {
                                max: categoryMax,
                                min: categoryMin
                            } : void 0;
                        }
                        var hasLatLongGroup = reader.hasCompositeCategories() && reader.hasCategoryWithRole("X") && reader.hasCategoryWithRole("Y"), hasCategoryGroup = reader.hasCategoryWithRole("Category");
                        if (geocodingCategory = Map.getGeocodingCategory(dataView.categorical, geoTaggingAnalyzerService), 
                        hasLatLongGroup || hasCategoryGroup) for (var categoryIndex = 0, categoryCount = reader.getCategoryCount(); categoryCount > categoryIndex; categoryIndex++) {
                            var categoryValue = void 0, categoryObjects = hasCategoryGroup ? reader.getCategoryObjects("Category", categoryIndex) : reader.getCategoryObjects("Y", categoryIndex), location_3 = void 0, categoryTooltipItem = void 0, latitudeTooltipItem = void 0, longitudeTooltipItem = void 0, seriesTooltipItem = void 0, sizeTooltipItem = void 0, gradientTooltipItem = void 0;
                            if (hasCategoryGroup) {
                                if (categoryValue = visuals.converterHelper.formatFromMetadataColumn(reader.getCategoryValue("Category", categoryIndex), reader.getCategoryMetadataColumn("Category"), formatStringProp), 
                                categoryTooltipItem = {
                                    displayName: reader.getCategoryDisplayName("Category"),
                                    value: categoryValue
                                }, reader.hasValues("Y") && reader.hasValues("X")) {
                                    var latitude = reader.getFirstNonNullValueForCategory("Y", categoryIndex), longitude = reader.getFirstNonNullValueForCategory("X", categoryIndex);
                                    null != latitude && null != longitude && (location_3 = {
                                        latitude: latitude,
                                        longitude: longitude
                                    }), latitudeTooltipItem = {
                                        displayName: reader.getValueDisplayName("Y"),
                                        value: visuals.converterHelper.formatFromMetadataColumn(latitude, reader.getValueMetadataColumn("Y"), formatStringProp)
                                    }, longitudeTooltipItem = {
                                        displayName: reader.getValueDisplayName("X"),
                                        value: visuals.converterHelper.formatFromMetadataColumn(longitude, reader.getValueMetadataColumn("X"), formatStringProp)
                                    };
                                }
                            } else {
                                var latitude = reader.getCategoryValue("Y", categoryIndex), longitude = reader.getCategoryValue("X", categoryIndex);
                                null != latitude && null != longitude && (categoryValue = latitude + ", " + longitude, 
                                location_3 = {
                                    latitude: latitude,
                                    longitude: longitude
                                }, latitudeTooltipItem = {
                                    displayName: reader.getCategoryDisplayName("Y"),
                                    value: visuals.converterHelper.formatFromMetadataColumn(latitude, reader.getCategoryMetadataColumn("Y"), formatStringProp)
                                }, longitudeTooltipItem = {
                                    displayName: reader.getCategoryDisplayName("X"),
                                    value: visuals.converterHelper.formatFromMetadataColumn(longitude, reader.getCategoryMetadataColumn("X"), formatStringProp)
                                });
                            }
                            var value = hasSize ? categoryTotals[categoryIndex] : void 0, subDataPoints = [], seriesCount = reader.getSeriesCount();
                            hasSize || hasDynamicSeries || (seriesCount = 1);
                            for (var seriesIndex = 0; seriesCount > seriesIndex; seriesIndex++) {
                                var color = void 0;
                                color = hasDynamicSeries ? colorHelper.getColorForSeriesValue(reader.getSeriesObjects(seriesIndex), seriesColumnIdentifier, reader.getSeriesName(seriesIndex)) : reader.hasCategoryWithRole("Series") ? colorHelper.getColorForSeriesValue(reader.getCategoryObjects("Series", categoryIndex), reader.getCategoryColumnIdentityFields("Series"), categoryValue) : colorHelper.getColorForMeasure(categoryObjects, sizeQueryName);
                                var colorRgb = Color.parseColorString(color), stroke = Color.hexString(Color.darken(colorRgb, Map.StrokeDarkenColorValue));
                                colorRgb.A = .6;
                                var fill = Color.rgbString(colorRgb), identityBuilder = new visuals.SelectionIdBuilder().withCategory(reader.getCategoryColumn(hasCategoryGroup ? "Category" : "Y"), categoryIndex).withMeasure(sizeQueryName);
                                hasDynamicSeries && (identityBuilder = identityBuilder.withSeries(reader.getSeriesValueColumns(), reader.getSeriesValueColumnGroup(seriesIndex))), 
                                hasDynamicSeries && (seriesTooltipItem = {
                                    displayName: reader.getSeriesDisplayName(),
                                    value: visuals.converterHelper.formatFromMetadataColumn(reader.getSeriesName(seriesIndex), reader.getSeriesMetadataColumn(), formatStringProp)
                                });
                                var subsliceValue = void 0;
                                hasSize && (subsliceValue = reader.getValue("Size", categoryIndex, seriesIndex), 
                                sizeTooltipItem = {
                                    displayName: reader.getValueDisplayName("Size"),
                                    value: visuals.converterHelper.formatFromMetadataColumn(subsliceValue, reader.getValueMetadataColumn("Size", seriesIndex), formatStringProp)
                                }), reader.hasValues("Gradient") && (gradientTooltipItem = {
                                    displayName: reader.getValueDisplayName("Gradient"),
                                    value: visuals.converterHelper.formatFromMetadataColumn(reader.getValue("Gradient", categoryIndex, seriesIndex), reader.getValueMetadataColumn("Gradient", seriesIndex), formatStringProp)
                                });
                                var tooltipInfo = [];
                                categoryTooltipItem && tooltipInfo.push(categoryTooltipItem), seriesTooltipItem && tooltipInfo.push(seriesTooltipItem), 
                                latitudeTooltipItem && tooltipInfo.push(latitudeTooltipItem), longitudeTooltipItem && tooltipInfo.push(longitudeTooltipItem), 
                                sizeTooltipItem && tooltipInfo.push(sizeTooltipItem), gradientTooltipItem && tooltipInfo.push(gradientTooltipItem), 
                                tooltipBucketEnabled && visuals.TooltipBuilder.addTooltipBucketItem(reader, tooltipInfo, categoryIndex, seriesIndex), 
                                (subsliceValue || !hasSize || 0 === subsliceValue && isFilledMap) && subDataPoints.push({
                                    value: subsliceValue,
                                    fill: fill,
                                    stroke: stroke,
                                    identity: identityBuilder.createSelectionId(),
                                    tooltipInfo: tooltipInfo
                                });
                            }
                            (value || !hasSize || 0 === value && isFilledMap) && dataPoints.push({
                                geocodingQuery: categoryValue,
                                value: value,
                                categoryValue: categoryValue,
                                subDataPoints: subDataPoints,
                                radius: Map.calculateRadius(categoryTotalRange, value),
                                location: location_3
                            });
                        }
                    }
                    var mapData = {
                        dataPoints: dataPoints,
                        geocodingCategory: geocodingCategory,
                        hasDynamicSeries: hasDynamicSeries,
                        hasSize: hasSize
                    };
                    return mapData;
                }, Map.createLegendData = function(dataView, colorHelper) {
                    var legendTitle, reader = powerbi.data.createIDataViewCategoricalReader(dataView), legendDataPoints = [];
                    if (reader.hasDynamicSeries()) {
                        legendTitle = reader.getSeriesDisplayName();
                        for (var seriesColumnIdentifier = reader.getSeriesColumnIdentityFields(), seriesIndex = 0, seriesCount = reader.getSeriesCount(); seriesCount > seriesIndex; seriesIndex++) {
                            var color = colorHelper.getColorForSeriesValue(reader.getSeriesObjects(seriesIndex), seriesColumnIdentifier, reader.getSeriesName(seriesIndex)), identity = new visuals.SelectionIdBuilder().withSeries(reader.getSeriesValueColumns(), reader.getSeriesValueColumnGroup(seriesIndex)).createSelectionId();
                            legendDataPoints.push({
                                color: color,
                                label: visuals.valueFormatter.format(reader.getSeriesName(seriesIndex)),
                                icon: visuals.LegendIcon.Circle,
                                identity: identity,
                                selected: !1
                            });
                        }
                    }
                    var legendData = {
                        dataPoints: legendDataPoints,
                        title: legendTitle
                    };
                    return legendData;
                }, Map.prototype.swapLogoContainerChildElement = function() {
                    var logoContainer = this.element.find(".LogoContainer");
                    if (logoContainer) {
                        var aNode = logoContainer.find("a");
                        if (null == aNode) return;
                        var divNode = $("<div>");
                        aNode.children().clone().appendTo(divNode), aNode.remove(), divNode.appendTo(logoContainer);
                    }
                }, Map.prototype.onResizing = function(viewport) {
                    this.currentViewport.width === viewport.width && this.currentViewport.height === viewport.height || (this.currentViewport = viewport, 
                    this.renderLegend(this.legendData), this.updateInternal(!1, !1));
                }, Map.prototype.initialize = function(container) {
                    var _this = this, mapOptions = {
                        credentials: visuals.MapUtil.Settings.BingKey,
                        showMapTypeSelector: !1,
                        enableClickableLogo: !1,
                        enableSearchLogo: !1,
                        mapTypeId: Microsoft.Maps.MapTypeId.road,
                        customizeOverlays: !0,
                        showDashboard: !1,
                        showScalebar: !1,
                        disableKeyboardInput: !0,
                        disableZooming: this.disableZooming,
                        disablePanning: this.disablePanning
                    }, divQuery = this.root = InJs.DomFactory.div().addClass(Map.MapContainer.cssClass).appendTo(container);
                    this.mapControl = this.mapControlFactory.createMapControl(divQuery[0], mapOptions), 
                    void 0 !== this.viewChangeThrottleInterval ? Microsoft.Maps.Events.addThrottledHandler(this.mapControl, "viewchange", function() {
                        _this.onViewChanged();
                    }, this.viewChangeThrottleInterval) : Microsoft.Maps.Events.addHandler(this.mapControl, "viewchange", function() {
                        _this.onViewChanged();
                    }), Microsoft.Maps.Events.addHandler(this.mapControl, "viewchangeend", function() {
                        _this.onViewChangeEnded();
                    }), this.dataPointRenderer.init(this.mapControl, divQuery, !!this.behavior), this.pendingGeocodingRender || this.updateInternal(!0, !0);
                }, Map.prototype.onViewChanged = function() {
                    this.updateOffsets(!1, !1), this.behavior && this.behavior.viewChanged(), this.swapLogoContainerChildElement();
                }, Map.prototype.onViewChangeEnded = function() {
                    this.dataPointRenderer.updateInternalDataLabels(this.currentViewport, !0);
                }, Map.prototype.getMapViewPort = function() {
                    var currentViewport = this.currentViewport, legendMargins = this.legend.getMargins(), mapViewport = {
                        width: currentViewport.width - legendMargins.width,
                        height: currentViewport.height - legendMargins.height
                    };
                    return mapViewport;
                }, Map.removeTransform3d = function(mapRoot) {
                    var userAgent = window.navigator.userAgent.toLowerCase();
                    if (mapRoot && -1 === userAgent.indexOf("applewebkit")) {
                        var imageTiles = mapRoot.find("img");
                        imageTiles.css("transform", "");
                    }
                }, Map.prototype.updateInternal = function(dataChanged, redrawDataLabels) {
                    if (this.mapControl) {
                        var isLegendVisible = this.legend.isVisible();
                        isLegendVisible || (this.legendData = {
                            dataPoints: []
                        });
                        var mapDiv = this.element.children(Map.MapContainer.selector), mapViewport = this.getMapViewPort();
                        if (mapDiv.height(mapViewport.height), mapDiv.width(mapViewport.width), this.updateOffsets(dataChanged, redrawDataLabels), 
                        this.boundsHaveBeenUpdated && (!this.behavior || !this.behavior.hasReceivedZoomOrPanEvent())) {
                            var levelOfDetail = this.getOptimumLevelOfDetail(mapViewport.width, mapViewport.height), center = this.getViewCenter(levelOfDetail);
                            this.updateMapView(center, levelOfDetail);
                        }
                    }
                }, Map.prototype.updateMapView = function(center, levelOfDetail) {
                    this.mapControl.setView({
                        center: center,
                        zoom: levelOfDetail,
                        animate: !0
                    });
                }, Map.prototype.updateOffsets = function(dataChanged, redrawDataLabels) {
                    var data, dataView = this.dataView, viewport = this.getMapViewPort();
                    data = dataView && dataView.categorical ? this.dataPointRenderer.converter(viewport, this.dataView, this.dataLabelsSettings, this.interactivityService, this.tooltipsEnabled) : {
                        bubbleData: [],
                        shapeData: [],
                        sliceData: []
                    };
                    var behaviorOptions = this.dataPointRenderer.updateInternal(data, viewport, dataChanged, this.interactivityService, redrawDataLabels);
                    visuals.Legend.positionChartArea(d3.select(this.root[0]), this.legend), this.interactivityService && behaviorOptions && this.interactivityService.bind(behaviorOptions.dataPoints, this.behavior, behaviorOptions);
                }, Map.prototype.onClearSelection = function() {
                    this.interactivityService.clearSelection(), this.updateOffsets(!1, !1);
                }, Map.prototype.clearDataPoints = function() {
                    this.dataPointRenderer.clearDataPoints(), this.legend.drawLegend({
                        dataPoints: []
                    }, this.currentViewport);
                }, Map.prototype.getDefaultMapControlFactory = function() {
                    return {
                        createMapControl: function(element, options) {
                            return new Microsoft.Maps.Map(element, options);
                        },
                        ensureMap: jsCommon.ensureMap
                    };
                }, Map.removeHillShading = function() {
                    Microsoft.Maps.Globals.roadUriFormat = Microsoft.Maps.Globals.roadUriFormat.replace("&shading=hill", "");
                }, Map.MapContainer = {
                    cssClass: "mapControl",
                    selector: ".mapControl"
                }, Map.StrokeDarkenColorValue = 63.75, Map.ScheduleRedrawInterval = 3e3, Map;
            }();
            visuals.Map = Map;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            function appendImage(selection) {
                selection.append("div").classed("imgCon", !0).append("img");
            }
            function setImageStyle(selection, imageStyle) {
                selection.selectAll(".imgCon").style({
                    height: getPixelString(imageStyle.maxHeight)
                }).selectAll("img").style({
                    "max-height": getPixelString(imageStyle.maxHeight),
                    "max-width": getPixelString(imageStyle.maxWidth)
                });
            }
            function getPixelString(value) {
                return value + "px";
            }
            var getKpiImageMetadata = powerbi.visuals.KpiUtil.getKpiImageMetadata, createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, PixelConverter = jsCommon.PixelConverter, UrlUtils = jsCommon.UrlUtils, EdgeSettings = powerbi.visuals.controls.internal.TablixUtils.EdgeSettings, TitleFontFamily = visuals.Font.Family.semibold.css, DefaultFontFamily = visuals.Font.Family.regular.css, DefaultCaptionFontSizeInPt = 10, DefaultTitleFontSizeInPt = 13, DefaultDetailFontSizeInPt = 9, DefaultTitleColor = "#767676", DefaultTextColor = "#333333", DefaultCategoryColor = "#ACACAC", DefaultOutline = visuals.outline.none, DefaultOutlineColor = "#E8E8E8", DefaultOutlineWeight = 1, DefaultBarShow = !0, DefaultBarColor = "#A6A6A6", DefaultBarOutline = visuals.outline.leftOnly, DefaultBarWeight = 3, MultiRowCard = function() {
                function MultiRowCard() {
                    this.isInteractivityOverflowHidden = !1;
                }
                return MultiRowCard.prototype.init = function(options) {
                    this.options = options, this.style = options.style;
                    var viewport = this.currentViewport = options.viewport, interactivity = this.interactivity = options.interactivity;
                    interactivity && "hidden" === interactivity.overflow && (this.isInteractivityOverflowHidden = !0);
                    var multiRowCardDiv = this.element = $("<div/>").addClass(MultiRowCard.MultiRowCardRoot["class"]).css({
                        height: getPixelString(viewport.height)
                    });
                    options.element.append(multiRowCardDiv), this.initializeCardRowSelection();
                }, MultiRowCard.prototype.onDataChanged = function(options) {
                    var dataViews = options.dataViews;
                    if (dataViews && dataViews.length > 0) {
                        var dataView = this.dataView = dataViews[0], columnMetadata = dataView.table.columns, tableRows = dataView.table.rows, resetScrollbarPosition = options.operationKind !== powerbi.VisualDataChangeOperationKind.Append, data_1 = this.data = MultiRowCard.converter(dataView, columnMetadata.length, tableRows.length, this.isInteractivityOverflowHidden);
                        this.setCardDimensions(), this.listView.data(data_1.dataModel, function(d) {
                            return data_1.dataModel.indexOf(d);
                        }, resetScrollbarPosition);
                    } else this.data = {
                        dataModel: [],
                        dataColumnCount: 0,
                        cardTitleSettings: visuals.dataLabelUtils.getDefaultLabelSettings(!0, DefaultTitleColor, DefaultTitleFontSizeInPt),
                        categoryLabelsSettings: visuals.dataLabelUtils.getDefaultLabelSettings(!0, DefaultCategoryColor, DefaultDetailFontSizeInPt),
                        dataLabelsSettings: visuals.dataLabelUtils.getDefaultLabelSettings(!0, DefaultTextColor, DefaultCaptionFontSizeInPt),
                        cardSettings: MultiRowCard.getCardSettings(null)
                    };
                    this.waitingForData = !1;
                }, MultiRowCard.getCardSettings = function(dataView) {
                    var objects = dataView && dataView.metadata && dataView.metadata.objects ? dataView.metadata.objects : null, outlineSettings = {
                        outline: powerbi.DataViewObjects.getValue(objects, visuals.multiRowCardProps.card.outline, DefaultOutline),
                        color: powerbi.DataViewObjects.getFillColor(objects, visuals.multiRowCardProps.card.outlineColor, DefaultOutlineColor),
                        weight: powerbi.DataViewObjects.getValue(objects, visuals.multiRowCardProps.card.outlineWeight, DefaultOutlineWeight)
                    }, barShow = powerbi.DataViewObjects.getValue(objects, visuals.multiRowCardProps.card.barShow, DefaultBarShow), barSettings = {
                        outline: barShow ? DefaultBarOutline : visuals.outline.none,
                        color: powerbi.DataViewObjects.getFillColor(objects, visuals.multiRowCardProps.card.barColor, DefaultBarColor),
                        weight: powerbi.DataViewObjects.getValue(objects, visuals.multiRowCardProps.card.barWeight, DefaultBarWeight)
                    }, cardPadding = powerbi.DataViewObjects.getValue(objects, visuals.multiRowCardProps.card.cardPadding, MultiRowCard.DefaultStyle.row.marginBottom), cardBackground = powerbi.DataViewObjects.getFillColor(objects, visuals.multiRowCardProps.card.cardBackground, MultiRowCard.DefaultStyle.row.background);
                    return {
                        outlineSettings: outlineSettings,
                        barSettings: barSettings,
                        cardPadding: cardPadding,
                        cardBackground: cardBackground
                    };
                }, MultiRowCard.prototype.onResizing = function(viewport) {
                    var heightNotChanged = this.currentViewport.height === viewport.height;
                    if (this.currentViewport = viewport, this.element.css("height", getPixelString(viewport.height)), 
                    this.dataView) {
                        var previousMaxColPerRow = this.maxColPerRow;
                        this.maxColPerRow = this.getMaxColPerRow();
                        var widthNotChanged = previousMaxColPerRow === this.maxColPerRow;
                        heightNotChanged && widthNotChanged || this.listView.viewport(viewport);
                    }
                }, MultiRowCard.converter = function(dataView, columnCount, maxCards, isDashboardVisual) {
                    void 0 === isDashboardVisual && (isDashboardVisual = !1);
                    var cardTitleSettings, dataLabelsSettings, categoryLabelsSettings, details = [], tableDataRows = dataView.table.rows, columnMetadata = dataView.table.columns;
                    if (cardTitleSettings = visuals.dataLabelUtils.getDefaultLabelSettings(!0, DefaultTitleColor, DefaultTitleFontSizeInPt), 
                    dataLabelsSettings = visuals.dataLabelUtils.getDefaultLabelSettings(!0, DefaultTextColor, DefaultCaptionFontSizeInPt), 
                    categoryLabelsSettings = visuals.dataLabelUtils.getDefaultLabelSettings(!0, DefaultCategoryColor, DefaultDetailFontSizeInPt), 
                    dataView.metadata && dataView.metadata.objects) {
                        var cardTitleLabelObjects = powerbi.DataViewObjects.getObject(dataView.metadata.objects, "cardTitle");
                        visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(cardTitleLabelObjects, cardTitleSettings);
                        var dataLabelObject = powerbi.DataViewObjects.getObject(dataView.metadata.objects, "dataLabels");
                        visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(dataLabelObject, dataLabelsSettings);
                        var categoryLabelObject = powerbi.DataViewObjects.getObject(dataView.metadata.objects, "categoryLabels");
                        visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(categoryLabelObject, categoryLabelsSettings);
                    }
                    for (var i = 0, len = maxCards; len > i; i++) {
                        for (var row = tableDataRows[i], isValuePromoted = void 0, title = void 0, showTitleAsURL = !1, showTitleAsImage = !1, showTitleAsKPI = !1, cardData = [], j = 0; columnCount > j; j++) {
                            var column = columnMetadata[j], statusGraphicInfo = getKpiImageMetadata(column, row[j]), columnCaption = void 0, statusGraphic = void 0;
                            statusGraphicInfo && (columnCaption = statusGraphicInfo["class"], statusGraphic = statusGraphicInfo.statusGraphic), 
                            columnCaption || (columnCaption = visuals.valueFormatter.format(row[j], visuals.valueFormatter.getFormatString(column, MultiRowCard.formatStringProp)));
                            var showKPI = void 0 !== statusGraphicInfo && void 0 !== statusGraphicInfo.caption, columnDetail = columnMetadata[j].displayName;
                            isDashboardVisual || column.type.numeric || (void 0 === isValuePromoted ? (isValuePromoted = !0, 
                            title = columnCaption, showTitleAsURL = visuals.converterHelper.isWebUrlColumn(column) && UrlUtils.isValidUrl(title), 
                            showTitleAsImage = visuals.converterHelper.isImageUrlColumn(column) && UrlUtils.isValidImageUrl(columnCaption), 
                            showTitleAsKPI = showKPI) : isValuePromoted && (isValuePromoted = !1)), cardData.push({
                                caption: columnCaption,
                                details: columnDetail,
                                showURL: visuals.converterHelper.isWebUrlColumn(column) && UrlUtils.isValidUrl(columnCaption),
                                showImage: visuals.converterHelper.isImageUrlColumn(column) && UrlUtils.isValidImageUrl(columnCaption),
                                showKPI: showKPI,
                                columnIndex: j
                            });
                        }
                        details.push({
                            title: isValuePromoted ? title : void 0,
                            showTitleAsURL: showTitleAsURL,
                            showTitleAsImage: showTitleAsImage,
                            showTitleAsKPI: showTitleAsKPI,
                            cardItemsData: isValuePromoted ? cardData.filter(function(d) {
                                return d.caption !== title;
                            }) : cardData
                        });
                    }
                    return {
                        dataModel: details,
                        dataColumnCount: details[0] ? details[0].cardItemsData.length : 0,
                        cardTitleSettings: cardTitleSettings,
                        categoryLabelsSettings: categoryLabelsSettings,
                        dataLabelsSettings: dataLabelsSettings,
                        cardSettings: MultiRowCard.getCardSettings(dataView)
                    };
                }, MultiRowCard.getSortableRoles = function(options) {
                    if (options && options.dataViewMappings && !_.isEmpty(options.dataViewMappings)) for (var _i = 0, _a = options.dataViewMappings; _i < _a.length; _i++) {
                        var dataViewMapping = _a[_i];
                        if (dataViewMapping.table) {
                            var rows = dataViewMapping.table.rows;
                            if (rows && rows["for"] && rows["for"]["in"] && rows["for"]["in"].items) return [ MultiRowCard.ValuesRole ];
                        }
                    }
                }, MultiRowCard.prototype.initializeCardRowSelection = function() {
                    var _this = this, isDashboardVisual = this.isInteractivityOverflowHidden, rowEnter = function(rowSelection) {
                        var cardRow = rowSelection.append("div").classed(MultiRowCard.Card["class"], !0);
                        isDashboardVisual ? cardRow.classed("mrtile", !0) : _this.cardHasTitle && cardRow.append("div").classed(MultiRowCard.Title["class"], !0).each(function(d) {
                            d.showTitleAsImage ? appendImage(d3.select(this)) : d.showTitleAsURL ? d3.select(this).append("a") : d.showTitleAsKPI && d3.select(this).append("div").classed(MultiRowCard.KPITitle["class"], !0).classed(d.title, !0).style({
                                display: "inline-block",
                                verticalAlign: "sub"
                            });
                        });
                        var cardItem = cardRow.selectAll(MultiRowCard.CardItemContainer.selector).data(function(d) {
                            return d.cardItemsData;
                        }).enter().append("div").classed(MultiRowCard.CardItemContainer["class"], !0);
                        cardItem.append("div").classed(MultiRowCard.Caption["class"], !0).each(function(d) {
                            d.showURL ? d3.select(this).append("a") : d.showImage ? appendImage(d3.select(this)) : d.showKPI && d3.select(this).append("div").classed(d.caption, !0).style({
                                display: "inline-block",
                                verticalAlign: "sub"
                            });
                        }), cardItem.append("div").classed(MultiRowCard.Details["class"], !0);
                    }, rowUpdate = function(rowSelection) {
                        var style = _this.getStyle(), dataLabelHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(MultiRowCard.getTextProperties(!1, style.caption.fontSize)), categoryLabelHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(MultiRowCard.getTextProperties(!1, style.details.fontSize)), titleLabelHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(MultiRowCard.getTextProperties(!0, style.title.fontSize)), rowBorderStyle = _this.getBorderStyles(style.row.border, style.row.padding);
                        rowSelection.style(rowBorderStyle).style({
                            "margin-bottom": isDashboardVisual ? "0px" : _this.isSingleRowCard ? "0px" : getPixelString(style.row.marginBottom),
                            background: style.row.background
                        }), !isDashboardVisual && _this.cardHasTitle && (rowSelection.selectAll(MultiRowCard.Title.selector).filter(function(d) {
                            return !d.showTitleAsImage && !d.showTitleAsKPI;
                        }).style({
                            "font-size": PixelConverter.fromPoint(style.title.fontSize),
                            "line-height": PixelConverter.toString(titleLabelHeight),
                            color: style.title.color
                        }), rowSelection.selectAll(MultiRowCard.Title.selector).filter(function(d) {
                            return !d.showTitleAsURL && !d.showTitleAsImage && !d.showTitleAsKPI;
                        }).text(function(d) {
                            return d.title;
                        }).attr("title", function(d) {
                            return d.title;
                        }), rowSelection.selectAll(MultiRowCard.TitleUrlSelector).text(function(d) {
                            return d.title;
                        }).attr({
                            href: function(d) {
                                return d.title;
                            },
                            target: "_blank"
                        }), rowSelection.selectAll(MultiRowCard.TitleImageSelector).attr("src", function(d) {
                            return d.title;
                        }), setImageStyle(rowSelection.selectAll(MultiRowCard.Title.selector), style.imageTitle), 
                        rowSelection.selectAll(MultiRowCard.KPITitle.selector).each(function(d) {
                            var element = d3.select(this);
                            element.classed(d.title);
                        }));
                        var cardSelection = rowSelection.selectAll(MultiRowCard.Card.selector), cardBorderStyle = _this.getBorderStyles(style.card.border, style.card.padding);
                        cardSelection.style(cardBorderStyle), cardSelection.selectAll(MultiRowCard.Caption.selector).filter(function(d) {
                            return !d.showImage;
                        }).style({
                            "line-height": PixelConverter.toString(dataLabelHeight),
                            "font-size": PixelConverter.fromPoint(style.caption.fontSize)
                        }).filter(function(d) {
                            return !d.showKPI;
                        }).style({
                            color: style.caption.color
                        }).filter(function(d) {
                            return !d.showURL;
                        }).text(function(d) {
                            return d.caption;
                        }).attr("title", function(d) {
                            return d.caption;
                        }), cardSelection.selectAll(MultiRowCard.CaptionImageSelector).attr("src", function(d) {
                            return d.caption;
                        }).style(style.imageCaption);
                        var cardPaddingTop = getPixelString(style.cardItemContainer.padding.top);
                        cardSelection.selectAll(MultiRowCard.CardItemContainer.selector).style({
                            "padding-top": function(d) {
                                return _this.isInFirstRow(d.columnIndex) ? "" : cardPaddingTop;
                            },
                            "padding-right": function(d) {
                                return _this.isLastRowItem(d.columnIndex, _this.dataView.metadata.columns.length) ? "0px" : getPixelString(style.cardItemContainer.paddingRight);
                            },
                            width: function(d) {
                                return _this.getColumnWidth(d.columnIndex, _this.data.dataColumnCount);
                            }
                        }), setImageStyle(cardSelection.selectAll(MultiRowCard.Caption.selector), style.imageCaption), 
                        cardSelection.selectAll(MultiRowCard.CaptionUrlSelector).attr({
                            href: function(d) {
                                return d.caption;
                            },
                            target: "_blank"
                        }).text(function(d) {
                            return d.caption;
                        }), style.details.isVisible && cardSelection.selectAll(MultiRowCard.Details.selector).text(function(d) {
                            return d.details;
                        }).style({
                            "font-size": PixelConverter.fromPoint(style.details.fontSize),
                            "line-height": PixelConverter.toString(categoryLabelHeight),
                            color: style.details.color
                        }).attr("title", function(d) {
                            return d.details;
                        });
                    }, rowExit = function(rowSelection) {
                        rowSelection.remove();
                    }, listViewOptions = {
                        rowHeight: void 0,
                        enter: rowEnter,
                        exit: rowExit,
                        update: rowUpdate,
                        loadMoreData: function() {
                            return _this.onLoadMoreData();
                        },
                        viewport: this.currentViewport,
                        baseContainer: d3.select(this.element.get(0)),
                        scrollEnabled: !this.isInteractivityOverflowHidden,
                        isReadMode: function() {
                            return 1 !== _this.options.host.getViewMode();
                        }
                    };
                    this.listView = visuals.ListViewFactory.createListView(listViewOptions);
                }, MultiRowCard.prototype.getBorderStyles = function(border, padding) {
                    var hasBorder = {
                        top: null != border && null != border.top,
                        right: null != border && null != border.right,
                        bottom: null != border && null != border.bottom,
                        left: null != border && null != border.left
                    }, hasPadding = {
                        top: null != padding && null != padding.top,
                        right: null != padding && null != padding.right,
                        bottom: null != padding && null != padding.bottom,
                        left: null != padding && null != padding.left
                    };
                    return {
                        "border-top": hasBorder.top ? border.top.getCSS() : "",
                        "border-right": hasBorder.right ? border.right.getCSS() : "",
                        "border-bottom": hasBorder.bottom ? border.bottom.getCSS() : "",
                        "border-left": hasBorder.left ? border.left.getCSS() : "",
                        "padding-top": hasBorder.top && hasPadding.top ? getPixelString(padding.top) : "",
                        "padding-right": hasBorder.right && hasPadding.right ? getPixelString(padding.right) : "",
                        "padding-bottom": hasBorder.bottom && hasPadding.bottom ? getPixelString(padding.bottom) : "",
                        "padding-left": hasBorder.left && hasPadding.left ? getPixelString(padding.left) : ""
                    };
                }, MultiRowCard.prototype.getMaxColPerRow = function() {
                    var rowWidth = this.currentViewport.width, minColumnWidth = this.getStyle().cardItemContainer.minWidth, columnCount = this.data.dataColumnCount, maxColumnPerRow = Math.floor(rowWidth / minColumnWidth) || 1;
                    return Math.min(columnCount, maxColumnPerRow);
                }, MultiRowCard.prototype.getRowIndex = function(fieldIndex) {
                    return Math.floor(1 * fieldIndex / this.getMaxColPerRow());
                }, MultiRowCard.prototype.getStyle = function() {
                    var defaultStyles = MultiRowCard.DefaultStyle, customStyles = this.getCustomStyles();
                    if (!this.isInteractivityOverflowHidden) return $.extend(!0, {}, defaultStyles, customStyles);
                    for (var viewportWidth = this.currentViewport.width, overrideStyle = {}, _i = 0, _a = MultiRowCard.tileMediaQueries; _i < _a.length; _i++) {
                        var currentQuery = _a[_i];
                        if (viewportWidth <= currentQuery.maxWidth) {
                            overrideStyle = currentQuery.style;
                            break;
                        }
                    }
                    return $.extend(!0, {}, defaultStyles, customStyles, overrideStyle);
                }, MultiRowCard.prototype.getSurroundSettings = function(outlineSettings) {
                    var edge = new EdgeSettings(outlineSettings.weight, outlineSettings.color), outlineProp = outlineSettings.outline;
                    return {
                        top: visuals.outline.showTop(outlineProp) ? edge : null,
                        right: visuals.outline.showRight(outlineProp) ? edge : null,
                        bottom: visuals.outline.showBottom(outlineProp) ? edge : null,
                        left: visuals.outline.showLeft(outlineProp) ? edge : null
                    };
                }, MultiRowCard.prototype.getCustomStyles = function() {
                    var dataLabelsSettings = this.data.dataLabelsSettings, categoryLabelSettings = this.data.categoryLabelsSettings, titleLabelSettings = this.data.cardTitleSettings, cardSettings = this.data.cardSettings, customStyle = {
                        row: {
                            border: this.getSurroundSettings(cardSettings.outlineSettings),
                            marginBottom: cardSettings.cardPadding,
                            background: cardSettings.cardBackground
                        },
                        card: {
                            border: this.getSurroundSettings(cardSettings.barSettings)
                        },
                        details: {
                            fontSize: categoryLabelSettings.fontSize,
                            color: categoryLabelSettings.labelColor,
                            isVisible: categoryLabelSettings.show
                        },
                        caption: {
                            fontSize: dataLabelsSettings.fontSize,
                            color: dataLabelsSettings.labelColor
                        },
                        title: {
                            fontSize: titleLabelSettings.fontSize,
                            color: titleLabelSettings.labelColor
                        }
                    };
                    return customStyle;
                }, MultiRowCard.getTextProperties = function(isTitle, fontSizeInPt) {
                    return {
                        fontFamily: isTitle ? TitleFontFamily : DefaultFontFamily,
                        fontSize: PixelConverter.fromPoint(fontSizeInPt)
                    };
                }, MultiRowCard.prototype.getColumnWidth = function(fieldIndex, columnCount) {
                    var maxColumnPerRow = this.getMaxColPerRow();
                    if (maxColumnPerRow >= columnCount) return 100 / columnCount + "%";
                    var rowIndex = this.getRowIndex(fieldIndex), totalRows = Math.ceil(1 * columnCount / maxColumnPerRow), lastRowCount = columnCount % maxColumnPerRow;
                    return totalRows > rowIndex || 0 === lastRowCount ? 100 / maxColumnPerRow + "%" : 100 / lastRowCount + "%";
                }, MultiRowCard.prototype.isLastRowItem = function(fieldIndex, columnCount) {
                    if (fieldIndex + 1 === columnCount) return !0;
                    var maxColumnPerRow = this.getMaxColPerRow();
                    return maxColumnPerRow - fieldIndex % maxColumnPerRow === 1;
                }, MultiRowCard.prototype.isInFirstRow = function(fieldIndex) {
                    return fieldIndex < this.getMaxColPerRow();
                }, MultiRowCard.prototype.setCardDimensions = function() {
                    this.cardHasTitle = !1;
                    var dataModel = this.data.dataModel;
                    !this.isInteractivityOverflowHidden && dataModel && dataModel.length > 0 && (this.cardHasTitle = void 0 !== dataModel[0].title, 
                    this.isSingleRowCard = 1 === dataModel.length);
                }, MultiRowCard.prototype.onLoadMoreData = function() {
                    !this.waitingForData && this.dataView.metadata && this.dataView.metadata.segment && (this.options.host.loadMoreData(), 
                    this.waitingForData = !0);
                }, MultiRowCard.getDataLabelSettingsOptions = function(enumeration, labelSettings, show) {
                    return void 0 === show && (show = !1), {
                        enumeration: enumeration,
                        dataLabelsSettings: labelSettings,
                        show: show,
                        fontSize: !0
                    };
                }, MultiRowCard.prototype.enumerateObjectInstances = function(options) {
                    var enumeration = new visuals.ObjectEnumerationBuilder(), cardTitleSettings = this.data.cardTitleSettings, dataLabelsSettings = this.data.dataLabelsSettings, categoryLabelsSettings = this.data.categoryLabelsSettings;
                    switch (options.objectName) {
                      case "cardTitle":
                        !this.isInteractivityOverflowHidden && this.cardHasTitle && visuals.dataLabelUtils.enumerateDataLabels(MultiRowCard.getDataLabelSettingsOptions(enumeration, cardTitleSettings));
                        break;

                      case "dataLabels":
                        visuals.dataLabelUtils.enumerateDataLabels(MultiRowCard.getDataLabelSettingsOptions(enumeration, dataLabelsSettings));
                        break;

                      case "categoryLabels":
                        visuals.dataLabelUtils.enumerateDataLabels(MultiRowCard.getDataLabelSettingsOptions(enumeration, categoryLabelsSettings, !0));
                        break;

                      case visuals.multiRowCardProps.card.outline.objectName:
                        this.enumerateCard(enumeration);
                    }
                    return enumeration.complete();
                }, MultiRowCard.prototype.enumerateCard = function(enumeration) {
                    var cardSettings = this.data.cardSettings, propNames = visuals.multiRowCardProps.card, properties = {}, outlineSettings = cardSettings.outlineSettings;
                    properties[propNames.outline.propertyName] = outlineSettings.outline, outlineSettings.outline !== visuals.outline.none && (properties[propNames.outlineColor.propertyName] = outlineSettings.color, 
                    properties[propNames.outlineWeight.propertyName] = outlineSettings.weight);
                    var barSettings = cardSettings.barSettings, barShow = barSettings.outline !== visuals.outline.none;
                    properties[propNames.barShow.propertyName] = barShow, barShow && (properties[propNames.barColor.propertyName] = barSettings.color, 
                    properties[propNames.barWeight.propertyName] = barSettings.weight), properties[propNames.cardPadding.propertyName] = cardSettings.cardPadding, 
                    properties[propNames.cardBackground.propertyName] = cardSettings.cardBackground, 
                    enumeration.pushInstance({
                        selector: null,
                        objectName: propNames.outline.objectName,
                        properties: properties
                    });
                }, MultiRowCard.formatStringProp = {
                    objectName: "general",
                    propertyName: "formatString"
                }, MultiRowCard.MultiRowCardRoot = createClassAndSelector("multiRowCard"), MultiRowCard.Card = createClassAndSelector("card"), 
                MultiRowCard.Title = createClassAndSelector("title"), MultiRowCard.CardItemContainer = createClassAndSelector("cardItemContainer"), 
                MultiRowCard.Caption = createClassAndSelector("caption"), MultiRowCard.Details = createClassAndSelector("details"), 
                MultiRowCard.TitleUrlSelector = MultiRowCard.Title.selector + " a", MultiRowCard.CaptionUrlSelector = MultiRowCard.Caption.selector + " a", 
                MultiRowCard.TitleImageSelector = MultiRowCard.Title.selector + " img", MultiRowCard.CaptionImageSelector = MultiRowCard.Caption.selector + " img", 
                MultiRowCard.KPITitle = createClassAndSelector("kpiTitle"), MultiRowCard.ValuesRole = "Values", 
                MultiRowCard.DefaultStyle = {
                    row: {
                        border: null,
                        marginBottom: 20,
                        background: void 0,
                        padding: {
                            top: 5,
                            right: 5,
                            bottom: 5,
                            left: 5
                        }
                    },
                    card: {
                        border: null,
                        padding: {
                            top: 10,
                            right: 10,
                            bottom: 10,
                            left: 10
                        }
                    },
                    cardItemContainer: {
                        paddingRight: 20,
                        minWidth: 120,
                        padding: {
                            top: 7
                        }
                    },
                    imageCaption: {
                        maxHeight: 75,
                        maxWidth: 100
                    },
                    imageTitle: {
                        maxHeight: 75,
                        maxWidth: 100
                    }
                }, MultiRowCard.tileMediaQueries = [ {
                    maxWidth: 250,
                    style: {
                        cardItemContainer: {
                            minWidth: 110
                        },
                        imageCaption: {
                            maxHeight: 45
                        }
                    }
                }, {
                    maxWidth: 490,
                    style: {
                        cardItemContainer: {
                            minWidth: 130
                        },
                        imageCaption: {
                            maxHeight: 52
                        }
                    }
                }, {
                    maxWidth: 750,
                    style: {
                        cardItemContainer: {
                            minWidth: 120
                        },
                        imageCaption: {
                            maxHeight: 53
                        }
                    }
                }, {
                    maxWidth: Number.MAX_VALUE,
                    style: {
                        cardItemContainer: {
                            padding: {
                                top: 5
                            }
                        }
                    }
                } ], MultiRowCard;
            }();
            visuals.MultiRowCard = MultiRowCard;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, KeyUtils = jsCommon.KeyUtils, StringExtensions = jsCommon.StringExtensions, UrlUtils = jsCommon.UrlUtils, Textbox = function() {
                function Textbox() {}
                return Textbox.prototype.init = function(options) {
                    this.element = options.element, this.host = options.host, this.viewport = options.viewport, 
                    this.readOnly = 0 === this.host.getViewMode(), this.paragraphs = [], this.refreshView();
                }, Textbox.prototype.onResizing = function(viewport) {
                    this.viewport = viewport, this.updateSize();
                }, Textbox.prototype.onDataChanged = function(options) {
                    var dataViews = options.dataViews;
                    if (this.paragraphs = [], dataViews && dataViews.length > 0) {
                        var objects = dataViews[0].metadata.objects;
                        objects && objects.general && (this.paragraphs = objects.general.paragraphs);
                    }
                    this.refreshView();
                }, Textbox.prototype.destroy = function() {}, Textbox.prototype.focus = function() {
                    return this.editor ? (this.editor.focus(), !0) : void 0;
                }, Textbox.prototype.onViewModeChanged = function(viewMode) {
                    this.readOnly = 0 === viewMode, this.refreshView();
                }, Textbox.prototype.setSelection = function(start, end) {
                    this.editor && this.editor.setSelection(start, end);
                }, Textbox.prototype.refreshView = function() {
                    var _this = this;
                    if (this.readOnly) {
                        this.editor && (this.saveContents(), this.editor.destroy(), this.editor = null), 
                        this.element.empty();
                        var htmlContent = RichTextConversion.convertParagraphsToHtml(this.paragraphs);
                        htmlContent.addClass(Textbox.ClassName), htmlContent.css({
                            "font-family": RichText.defaultFont,
                            "font-size": RichText.defaultFontSize
                        }), this.element.append(htmlContent);
                    } else {
                        if (!this.editor) {
                            this.editor = new RichText.QuillWrapper(this.readOnly, this.host), this.editor.textChanged = function(delta, source) {
                                return _this.saveContents();
                            }, this.element.empty();
                            var editorElement = this.editor.getElement();
                            editorElement.addClass(Textbox.ClassName), editorElement.css({
                                "font-family": RichText.defaultFont,
                                "font-size": RichText.defaultFontSize
                            }), this.element.append(editorElement);
                        }
                        this.editor.setContents(RichTextConversion.convertParagraphsToOps(this.paragraphs));
                    }
                    this.updateSize();
                }, Textbox.prototype.saveContents = function() {
                    if (this.editor) {
                        var contents = this.editor.getContents();
                        this.paragraphs = RichTextConversion.convertDeltaToParagraphs(contents);
                        var changes = [ {
                            objectName: "general",
                            properties: {
                                paragraphs: this.paragraphs
                            },
                            selector: null
                        } ];
                        this.host.persistProperties(changes);
                    }
                }, Textbox.prototype.updateSize = function() {
                    this.editor && this.editor.resize(this.viewport);
                }, Textbox.ClassName = "textbox", Textbox;
            }();
            visuals.Textbox = Textbox;
            var RichTextConversion;
            !function(RichTextConversion) {
                function convertDeltaToParagraphs(contents) {
                    for (var paragraphs = [], paragraph = {
                        textRuns: []
                    }, i = 0, len = contents.ops.length; len > i; i++) {
                        var insertOp = contents.ops[i];
                        if ("string" == typeof insertOp.insert) {
                            var text = insertOp.insert, attributes = insertOp.attributes;
                            attributes && attributes.align && (paragraph.horizontalTextAlignment = attributes.align);
                            var start = 0, end = 0, newParagraph = void 0;
                            do {
                                if (end = text.indexOf("\n", start), 0 > end ? (newParagraph = !1, end = text.length) : newParagraph = !0, 
                                end - start > 0) {
                                    var span = text.substring(start, end), textRun = {
                                        value: span
                                    };
                                    if (attributes) {
                                        void 0 !== attributes.link && UrlUtils.isValidUrl(attributes.link) && (textRun.url = attributes.link);
                                        var textStyle = convertFormatAttributesToTextStyle(attributes);
                                        textStyle && (textRun.textStyle = textStyle);
                                    }
                                    paragraph.textRuns.push(textRun);
                                }
                                newParagraph && (0 === paragraph.textRuns.length && paragraph.textRuns.push({
                                    value: ""
                                }), paragraphs.push(paragraph), paragraph = {
                                    textRuns: []
                                }), start = end + 1;
                            } while (start < text.length);
                        }
                    }
                    return paragraph.textRuns.length > 0 && paragraph.textRuns[0].value.length > 0 && paragraphs.push(paragraph), 
                    paragraphs;
                }
                function convertParagraphsToHtml(paragraphs) {
                    for (var $paragraphs = $(), paragraphIndex = 0, len = paragraphs.length; len > paragraphIndex; ++paragraphIndex) {
                        var paragraphDef = paragraphs[paragraphIndex], isParagraphEmpty = !0, $paragraph = $("<div>");
                        paragraphDef.horizontalTextAlignment && $paragraph.css("text-align", paragraphDef.horizontalTextAlignment);
                        for (var textRunIndex = 0, jlen = paragraphDef.textRuns.length; jlen > textRunIndex; ++textRunIndex) {
                            var textRunDef = paragraphDef.textRuns[textRunIndex], $textRun = $("<span>"), styleDef = textRunDef.textStyle;
                            if (styleDef) {
                                var css = {};
                                styleDef.fontFamily && (css["font-family"] = RichText.getCssFontFamily(removeQuotes(styleDef.fontFamily))), 
                                styleDef.fontSize && (css["font-size"] = styleDef.fontSize), styleDef.fontStyle && (css["font-style"] = styleDef.fontStyle), 
                                styleDef.fontWeight && (css["font-weight"] = styleDef.fontWeight), styleDef.textDecoration && (css["text-decoration"] = styleDef.textDecoration), 
                                $textRun.css(css);
                            }
                            var text = textRunDef.value;
                            if (_.isEmpty(text) || (isParagraphEmpty = !1), void 0 !== textRunDef.url) {
                                var $link = void 0;
                                $link = UrlUtils.isValidUrl(textRunDef.url) ? $("<a>").attr("href", textRunDef.url).attr("target", "_blank").text(text) : $("<span>").text(text), 
                                $textRun.append($link);
                            } else $textRun.text(text);
                            $paragraph.append($textRun);
                        }
                        isParagraphEmpty && $paragraph.append($("<br>")), $paragraphs = $paragraphs.add($paragraph);
                    }
                    return $paragraphs;
                }
                function convertParagraphsToOps(paragraphs) {
                    for (var ops = [], paragraphIndex = 0, len = paragraphs.length; len > paragraphIndex; ++paragraphIndex) for (var paragraphDef = paragraphs[paragraphIndex], textRunIndex = 0, jlen = paragraphDef.textRuns.length; jlen > textRunIndex; ++textRunIndex) {
                        var textRunDef = paragraphDef.textRuns[textRunIndex], formats = {};
                        paragraphDef.horizontalTextAlignment && (formats.align = paragraphDef.horizontalTextAlignment);
                        var styleDef = textRunDef.textStyle;
                        styleDef && (styleDef.fontFamily && (formats.font = RichText.getCssFontFamily(removeQuotes(styleDef.fontFamily))), 
                        styleDef.fontSize && (formats.size = styleDef.fontSize), formats.italic = "italic" === styleDef.fontStyle, 
                        formats.bold = "bold" === styleDef.fontWeight, formats.underline = "underline" === styleDef.textDecoration);
                        var text = textRunDef.value;
                        textRunDef.url && UrlUtils.isValidUrl(textRunDef.url) && (formats.link = textRunDef.url);
                        var op = {
                            insert: text,
                            attributes: formats
                        };
                        ops.push(op), textRunIndex !== jlen - 1 || StringExtensions.endsWith(text, "\n") || ops.push({
                            insert: "\n",
                            attributes: formats
                        });
                    }
                    return ops;
                }
                function convertFormatAttributesToTextStyle(attributes) {
                    var style = {};
                    if (attributes.bold && (style.fontWeight = "bold"), attributes.font) {
                        var font = removeQuotes(attributes.font);
                        font = RichText.getFontFamilyForBuiltInFont(font), style.fontFamily = font;
                    }
                    return attributes.italic && (style.fontStyle = "italic"), attributes.size && (style.fontSize = attributes.size), 
                    attributes.underline && (style.textDecoration = "underline"), style;
                }
                function removeQuotes(text) {
                    return !StringExtensions.startsWith(text, "'") || StringExtensions.containsIgnoreCase(text, ",") ? text : text.slice(1, text.length - 1);
                }
                RichTextConversion.convertDeltaToParagraphs = convertDeltaToParagraphs, RichTextConversion.convertParagraphsToHtml = convertParagraphsToHtml, 
                RichTextConversion.convertParagraphsToOps = convertParagraphsToOps;
            }(RichTextConversion || (RichTextConversion = {}));
            var RichText;
            !function(RichText) {
                function getCssFontFamily(font) {
                    var family = fontMap[font];
                    return null == family && (family = font), family;
                }
                function getFontFamilyForBuiltInFont(font) {
                    var fontFamily = _.findKey(fontMap, function(value) {
                        return value === font || value.indexOf(font) > 0;
                    });
                    return fontFamily || font;
                }
                var fontMap = {
                    "Segoe (Bold)": visuals.Font.Family.bold.css,
                    "Segoe UI": visuals.Font.Family.regular.css,
                    "Segoe UI Light": visuals.Font.Family.light.css,
                    Heading: visuals.Font.Family.light.css,
                    Body: visuals.Font.Family.regular.css
                }, fonts = [ "Arial", "Arial Black", "Arial Unicode MS", "Calibri", "Cambria", "Cambria Math", "Candara", "Comic Sans MS", "Consolas", "Constantia", "Corbel", "Courier New", "Georgia", "Lucida Sans Unicode", "Segoe (Bold)", "Segoe UI", "Segoe UI Light", "Symbol", "Tahoma", "Times New Roman", "Trebuchet MS", "Verdana", "Wingdings" ].map(function(font) {
                    return {
                        label: font,
                        value: getCssFontFamily(font)
                    };
                });
                RichText.defaultFont = getCssFontFamily("Segoe UI Light");
                var fontSizes = [ "8", "9", "10", "10.5", "11", "12", "14", "16", "18", "20", "24", "28", "32", "36", "40", "42", "44", "54", "60", "66", "72", "80", "88", "96" ].map(function(size) {
                    return {
                        label: size,
                        value: size + "px"
                    };
                });
                RichText.defaultFontSize = "14px";
                var textAlignments = [ "Left", "Center", "Right" ].map(function(alignment) {
                    return {
                        label: alignment,
                        value: alignment.toLowerCase()
                    };
                });
                RichText.getCssFontFamily = getCssFontFamily, RichText.getFontFamilyForBuiltInFont = getFontFamilyForBuiltInFont;
                var QuillWrapper = function() {
                    function QuillWrapper(readOnly, host) {
                        var _this = this;
                        this.QuillPackage = {
                            javaScriptFiles: QuillWrapper.quillJsFiles,
                            cssFiles: QuillWrapper.quillCssFiles
                        }, this.textChanged = function(d, s) {}, this.host = host, this.$container = $("<div>"), 
                        this.readOnly = readOnly, this.localizationProvider = {
                            get: function(stringId) {
                                return _this.host.getLocalizedString(stringId);
                            },
                            getOptional: function(stringId) {
                                return _this.host.getLocalizedString(stringId);
                            }
                        }, this.dependenciesLoaded = $.Deferred(), QuillWrapper.loadQuillResources ? (this.initialized = !1, 
                        this.dependenciesLoaded.done(function() {
                            _this.rebuildQuillEditor(), _this.initialized = !0;
                        }), jsCommon.requires(this.QuillPackage, function() {
                            return _this.dependenciesLoaded.resolve();
                        })) : (this.rebuildQuillEditor(), this.initialized = !0, this.dependenciesLoaded.resolve());
                    }
                    return QuillWrapper.prototype.addModule = function(name, options) {
                        return this.editor ? this.editor.addModule(name, options) : void 0;
                    }, QuillWrapper.prototype.getElement = function() {
                        return this.$container;
                    }, QuillWrapper.prototype.getContents = function() {
                        return this.initialized ? this.editor.getContents() : void 0;
                    }, QuillWrapper.prototype.setContents = function(contents) {
                        var _this = this;
                        return this.initialized ? (this.editor.setHTML("", "api"), void (contents && this.editor.setContents(contents, "api"))) : void this.dependenciesLoaded.done(function() {
                            return _this.setContents(contents);
                        });
                    }, QuillWrapper.prototype.resize = function(viewport) {
                        this.$container.width(viewport.width), this.$container.height(viewport.height);
                    }, QuillWrapper.prototype.setReadOnly = function(readOnly) {
                        var readOnlyChanged = readOnly !== this.readOnly;
                        this.readOnly = readOnly, this.initialized && readOnlyChanged && this.rebuildQuillEditor();
                    }, QuillWrapper.prototype.setSelection = function(start, end) {
                        this.editor && this.editor.setSelection(start, end, "api");
                    }, QuillWrapper.prototype.getSelection = function() {
                        return this.editor ? this.editor.getSelection() : void 0;
                    }, QuillWrapper.prototype.focus = function() {
                        this.editor && 0 === $(document.activeElement).closest(this.$container).length && this.editor.focus();
                    }, QuillWrapper.prototype.destroy = function() {
                        this.host.setToolbar(null), this.$container.remove(), this.$container = null, this.$toolbarDiv = null, 
                        this.$editorDiv = null, this.editor = null;
                    }, QuillWrapper.prototype.getSelectionAtCursor = function() {
                        var text = this.getTextWithoutTrailingBreak();
                        this.editor.focus();
                        var selection = this.getSelection();
                        return selection && selection.start === selection.end ? jsCommon.WordBreaker.find(selection.start, text) : selection;
                    }, QuillWrapper.prototype.getWord = function() {
                        var selection = this.getSelectionAtCursor();
                        return this.getTextWithoutTrailingBreak().slice(selection.start, selection.end);
                    }, QuillWrapper.prototype.insertLinkAtCursor = function(link, index) {
                        var endIndex = index + link.length;
                        return this.editor.insertText(index, link, "api"), this.editor.formatText(index, endIndex, "link", link, "api"), 
                        this.setSelection(index, endIndex), this.onTextChanged(null, null), endIndex;
                    }, QuillWrapper.prototype.getEditorContainer = function() {
                        return this.editor ? $(this.editor.container) : void 0;
                    }, QuillWrapper.prototype.getTextWithoutTrailingBreak = function() {
                        return this.editor.getText().slice(0, -1);
                    }, QuillWrapper.prototype.rebuildQuillEditor = function() {
                        var _this = this, contents = null;
                        this.editor && (this.editor.removeAllListeners(), contents = this.editor.getContents()), 
                        this.$container.empty(), this.$container.keydown(function(e) {
                            var which = e.which;
                            e.ctrlKey && KeyUtils.isCtrlDefaultKey(which) && e.stopPropagation(), (KeyUtils.isArrowKey(which) || KeyUtils.isNudgeModifierKey(which)) && e.stopPropagation();
                        });
                        var $editorDiv = this.$editorDiv = $("<div>");
                        $editorDiv.css("font-family", RichText.defaultFont), $editorDiv.css("font-size", RichText.defaultFontSize);
                        var configs = {
                            readOnly: this.readOnly,
                            formats: [ "bold", "italic", "underline", "font", "size", "link", "align" ],
                            styles: !1
                        };
                        if (this.editor = new Quill($editorDiv.get(0), configs), !this.readOnly) {
                            var $toolbarDiv = this.$toolbarDiv;
                            $toolbarDiv || (this.$toolbarDiv = $toolbarDiv = Toolbar.buildToolbar(this, this.localizationProvider)), 
                            $toolbarDiv.addClass("unselectable"), this.host.setToolbar($toolbarDiv), this.editor.addModule("toolbar", {
                                container: $toolbarDiv.get(0)
                            }), $editorDiv.attr("drag-resize-disabled", "true");
                        }
                        this.$container.append($editorDiv), contents && this.setContents(contents);
                        var textChangeThrottler = new jsCommon.ThrottleUtility(QuillWrapper.textChangeThrottle);
                        this.editor.on("text-change", function(delta, source) {
                            "api" !== source && textChangeThrottler.run(function() {
                                return _this.onTextChanged(delta, source);
                            });
                        }), this.editor.root.addEventListener("blur", function(event) {
                            var target = event.relatedTarget || document.activeElement;
                            target && "SELECT" === target.tagName || "INPUT" === target.tagName || target.getAttribute("contentEditable") || _this.setSelection(null, null);
                        }, !1);
                    }, QuillWrapper.prototype.onTextChanged = function(delta, source) {
                        this.textChanged(delta, source);
                    }, QuillWrapper.textChangeThrottle = 200, QuillWrapper.loadQuillResources = !0, 
                    QuillWrapper.quillJsFiles = [ powerbi.build + "/externals/quill.min.js" ], QuillWrapper.quillCssFiles = [ powerbi.build + "/externals/quill.base.css" ], 
                    QuillWrapper;
                }();
                RichText.QuillWrapper = QuillWrapper;
                var Toolbar;
                !function(Toolbar) {
                    function buildToolbar(quillWrapper, localizationProvider) {
                        var linkTooltipTemplate = buildToolbarLinkInputTemplate(localizationProvider);
                        quillWrapper.addModule("link-tooltip", {
                            template: linkTooltipTemplate
                        });
                        var toolbarLinkInput = buildToolbarLinkInput(quillWrapper, getTooltip("Link", localizationProvider), localizationProvider.get("RichTextbox_Link_DefaultText")), fontPicker = picker(getTooltip("Font", localizationProvider), fonts, "font", RichText.defaultFont, function($option, option) {
                            return $option.css("font-family", option.value), $option;
                        }), $container = div().addClass("toolbar ql-toolbar").append(formatGroup().append(label(localizationProvider.get("RichTextbox_Font_Label"))).append(fontPicker).append(picker(getTooltip("Size", localizationProvider), fontSizes, "size", RichText.defaultFontSize))).append(formatGroup().append(formatButton(getTooltip("Bold", localizationProvider), "bold")).append(formatButton(getTooltip("Italic", localizationProvider), "italic")).append(formatButton(getTooltip("Underline", localizationProvider), "underline"))).append(formatGroup().append(toggleGroup("Text Alignment", textAlignments, "align", "Left", localizationProvider))).append(toolbarLinkInput);
                        return $container.on("mousedown", function(event) {
                            var target = event.target || document.activeElement;
                            "INPUT" !== target.tagName && "SELECT" !== target.tagName && event.preventDefault();
                        }), $container;
                    }
                    function setSelectValue($select, value) {
                        $select.val(value);
                        var evt = document.createEvent("UIEvent");
                        evt.initUIEvent("change", !1, !1, null, 0), $select.get(0).dispatchEvent(evt);
                    }
                    function linkTooltipTemplateGenerator(removeText, doneText) {
                        return $('\n                        <a href="#" class="url" target="_blank"></a>\n                        <input class="input" type="text">\n                        <span class="bar">&nbsp;|&nbsp;</span>\n                        <a class="change"></a>\n                        <a class="remove">' + removeText + '</a>\n                        <a class="done">' + doneText + "</a>\n                    ");
                    }
                    function buildToolbarLinkInputTemplate(localizationProvider) {
                        var template = div(), doneText = localizationProvider.get("RichTextbox_Link_Done"), removeText = localizationProvider.get("RichTextbox_Link_Remove");
                        return template.append(linkTooltipTemplateGenerator(removeText, doneText)), template.html();
                    }
                    function formatGroup() {
                        return span().addClass("ql-format-group").attr("drag-resize-disabled", "true");
                    }
                    function label(text) {
                        return $("<label>").text(text);
                    }
                    function div() {
                        return $("<div>");
                    }
                    function span() {
                        return $("<span>");
                    }
                    function toggleGroup(title, list, format, defaultValue, localizationProvider) {
                        var tooltip = getTooltip(title, localizationProvider), $group = span().attr("title", tooltip).addClass("ql-toggle-group"), $select = selector(tooltip, list, defaultValue).addClass("ql-picker ql-" + format).css("display", "none"), $buttons = list.map(function(option) {
                            var $button = formatButton(getTooltip(option.label, localizationProvider), "align" + option.value).attr("data-value", option.value).click(function(e) {
                                return setSelectValue($select, option.value);
                            });
                            return $button;
                        });
                        return $select.change(function(e) {
                            for (var newValue = $select.val(), i = 0; i < $buttons.length; i++) $buttons[i].toggleClass("ql-active", $buttons[i].attr("data-value") === newValue);
                        }), $group.append($select), $group.append($buttons), $group;
                    }
                    function picker(tooltip, list, format, defaultValue, optionModifier) {
                        var $selector = selector(tooltip, list, defaultValue, optionModifier).addClass("ql-picker ql-" + format);
                        return $selector;
                    }
                    function selector(tooltip, list, defaultValue, optionModifier) {
                        for (var $selector = $("<select>").attr("title", tooltip), i = 0; i < list.length; i++) {
                            var option = list[i], $option = $("<option>").attr("value", option.value).text(option.label);
                            option.value === defaultValue && $option.attr("selected", "selected"), void 0 !== optionModifier && ($option = optionModifier($option, option)), 
                            $selector.append($option);
                        }
                        return $selector;
                    }
                    function formatButton(tooltip, format) {
                        var $button = span().addClass("ql-format-button");
                        return null != tooltip && $button.attr("title", tooltip), null != format && ($button.addClass("ql-" + format), 
                        $button.addClass("powervisuals-glyph " + format)), $button;
                    }
                    function getTooltip(name, localizationProvider) {
                        return localizationProvider.get("RichTextbox_" + name + "_ToolTip");
                    }
                    function clearLinkInput(linkTooltip) {
                        linkTooltip.removeClass("editing"), linkTooltip.removeClass("blank-editing"), linkTooltip.find(".input").val(DefaultLinkInputValue);
                    }
                    function buildToolbarLinkInput(quillWrapper, buttonTooltip, defaultLinkText) {
                        var linkTooltip = quillWrapper.getEditorContainer().find(Toolbar.selectors.linkTooltip.selector), toolbarLinkInput = formatGroup().addClass(Toolbar.selectors.toolbarUrlInput["class"]).append(formatButton(buttonTooltip, "link").append("<div>")).append(linkTooltip);
                        return toolbarLinkInput.on("keydown mousedown", function(event) {
                            if (event.keyCode === jsCommon.DOMConstants.enterKeyCode || event.target.classList.contains("done")) {
                                if (!linkTooltip.hasClass("blank-editing")) return !0;
                                var link = toolbarLinkInput.find(".input").val(), selection = quillWrapper.getSelectionAtCursor(), word = quillWrapper.getWord();
                                if (!word) {
                                    var endCursor = quillWrapper.insertLinkAtCursor(link, selection.start);
                                    return clearLinkInput(linkTooltip), quillWrapper.setSelection(endCursor, endCursor), 
                                    !1;
                                }
                            }
                        }), toolbarLinkInput.find(".input").blur(function(event) {
                            var blurTarget = event.relatedTarget;
                            (null === blurTarget || blurTarget && !blurTarget.classList.contains("done")) && clearLinkInput(linkTooltip);
                        }), toolbarLinkInput.find(".ql-link div").click(function(event) {
                            var target = event.target.parentElement;
                            if (target && target.classList.contains("ql-active")) return toolbarLinkInput.find(".change")[0].click(), 
                            !1;
                            var word = quillWrapper.getWord();
                            if (!word) {
                                linkTooltip.addClass("editing blank-editing");
                                var inputElem = toolbarLinkInput.find(".input").get(0);
                                return inputElem.value = DefaultLinkInputValue, inputElem.selectionStart = inputElem.selectionEnd = DefaultLinkInputValue.length, 
                                inputElem.focus(), !1;
                            }
                        }).mousedown(function(event) {
                            var linkButton = event.target.parentElement;
                            if (linkButton && !linkButton.classList.contains("ql-active")) {
                                var selection = quillWrapper.getSelectionAtCursor();
                                quillWrapper.setSelection(selection.start, selection.end);
                            }
                        }), toolbarLinkInput;
                    }
                    var DefaultLinkInputValue = "http://";
                    Toolbar.selectors = {
                        linkTooltip: createClassAndSelector("ql-link-tooltip"),
                        toolbarUrlInput: createClassAndSelector("toolbar-url-input")
                    }, Toolbar.buildToolbar = buildToolbar, Toolbar.setSelectValue = setSelectValue;
                }(Toolbar || (Toolbar = {}));
            }(RichText = visuals.RichText || (visuals.RichText = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var SelectionManager = visuals.utility.SelectionManager;
            visuals.cheerMeterProps = {
                dataPoint: {
                    defaultColor: {
                        objectName: "dataPoint",
                        propertyName: "defaultColor"
                    },
                    fill: {
                        objectName: "dataPoint",
                        propertyName: "fill"
                    }
                }
            };
            var CheerMeter = function() {
                function CheerMeter() {
                    this.isFirstTime = !0;
                }
                return CheerMeter.converter = function(dataView) {
                    if (!dataView.categorical || !dataView.categorical.categories) return null;
                    var cat = dataView.categorical.categories[0];
                    if (!cat) return null;
                    var catValues = cat.values;
                    if (!catValues || _.isEmpty(dataView.categorical.values)) return null;
                    var values = dataView.categorical.values[0].values, objects = dataView.categorical.categories[0].objects, object1 = objects && objects.length > 0 ? objects[0] : void 0, object2 = objects && objects.length > 1 ? objects[1] : void 0, metadataObjects = dataView.metadata.objects, backgroundColor = CheerMeter.DefaultBackgroundColor;
                    if (metadataObjects) {
                        var general = metadataObjects.general;
                        if (general) {
                            var fill = general.fill;
                            fill && (backgroundColor = fill.solid.color);
                        }
                    }
                    var color1 = powerbi.DataViewObjects.getFillColor(object1, visuals.cheerMeterProps.dataPoint.fill, CheerMeter.DefaultFontColor), color2 = powerbi.DataViewObjects.getFillColor(object2, visuals.cheerMeterProps.dataPoint.fill, CheerMeter.DefaultFontColor), idn1 = visuals.SelectionIdBuilder.builder().withCategory(cat, 0).createSelectionId(), idn2 = visuals.SelectionIdBuilder.builder().withCategory(cat, 1).createSelectionId(), data = {
                        teamA: {
                            name: catValues[0],
                            value: values[0],
                            color: color1,
                            identity: idn1
                        },
                        teamB: {
                            name: catValues[1],
                            value: values[1],
                            color: color2,
                            identity: idn2
                        },
                        background: backgroundColor
                    };
                    return data;
                }, CheerMeter.prototype.init = function(options) {
                    this.selectionManager = new SelectionManager({
                        hostServices: options.host
                    });
                    var svg = this.svg = d3.select(options.element.get(0)).append("svg");
                    this.textOne = svg.append("text").style("font-family", CheerMeter.DefaultFontFamily), 
                    this.textTwo = svg.append("text").style("font-family", CheerMeter.DefaultFontFamily);
                }, CheerMeter.prototype.update = function(options) {
                    if (options.dataViews[0]) {
                        var data = this.data = CheerMeter.converter(options.dataViews[0]);
                        if (data) {
                            var duration = options.suppressAnimations ? 0 : visuals.AnimatorCommon.MinervaAnimationDuration;
                            this.draw(data, duration, options.viewport);
                        }
                    }
                }, CheerMeter.prototype.getRecomendedFontProperties = function(text1, text2, parentViewport) {
                    for (var i, textProperties = {
                        fontSize: "",
                        fontFamily: CheerMeter.DefaultFontFamily,
                        text: text1 + text2
                    }, min = 1, max = 1e3, maxWidth = parentViewport.width, width = 0; max >= min; ) if (i = (min + max) / 2 | 0, 
                    textProperties.fontSize = i + "px", width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties), 
                    maxWidth > width) min = i + 1; else {
                        if (!(width > maxWidth)) break;
                        max = i - 1;
                    }
                    return textProperties.fontSize = i + "px", width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties), 
                    width > maxWidth && (i--, textProperties.fontSize = i + "px"), textProperties;
                }, CheerMeter.prototype.calculateLayout = function(data, viewport) {
                    var text1 = data.teamA.name, text2 = data.teamB.name, avaliableViewport = {
                        height: viewport.height,
                        width: viewport.width - CheerMeter.PaddingBetweenText
                    }, recomendedFontProperties = this.getRecomendedFontProperties(text1, text2, avaliableViewport);
                    recomendedFontProperties.text = text1;
                    var width1 = 0 | powerbi.TextMeasurementService.measureSvgTextWidth(recomendedFontProperties);
                    recomendedFontProperties.text = text2;
                    var width2 = 0 | powerbi.TextMeasurementService.measureSvgTextWidth(recomendedFontProperties), padding = (viewport.width - width1 - width2 - CheerMeter.PaddingBetweenText) / 2 | 0;
                    recomendedFontProperties.text = text1 + text2;
                    var offsetHeight = 0 | powerbi.TextMeasurementService.measureSvgTextHeight(recomendedFontProperties), max = data.teamA.value + data.teamB.value, availableHeight = viewport.height - offsetHeight, y1 = (max - data.teamA.value) / max * availableHeight + offsetHeight / 2 | 0, y2 = (max - data.teamB.value) / max * availableHeight + offsetHeight / 2 | 0;
                    return {
                        x1: padding,
                        x2: padding + width1 + CheerMeter.PaddingBetweenText,
                        y1: y1,
                        y2: y2,
                        fontSize: recomendedFontProperties.fontSize
                    };
                }, CheerMeter.prototype.ensureStartState = function(layout, viewport) {
                    if (this.isFirstTime) {
                        this.isFirstTime = !1;
                        var startY = viewport.height / 2;
                        this.textOne.attr({
                            x: layout.x1,
                            y: startY
                        }), this.textTwo.attr({
                            x: layout.x2,
                            y: startY
                        });
                    }
                }, CheerMeter.prototype.clearSelection = function() {
                    var _this = this;
                    this.selectionManager.clear().then(function() {
                        _this.clearSelectionUI();
                    });
                }, CheerMeter.prototype.clearSelectionUI = function() {
                    this.textOne.style("stroke", "#FFF").style("stroke-width", 0), this.textTwo.style("stroke", "#FFF").style("stroke-width", 0);
                }, CheerMeter.prototype.updateSelectionUI = function(ids) {
                    this.textOne.style("stroke", "#FFF").style("stroke-width", SelectionManager.containsSelection(ids, this.data.teamA.identity) ? "2px" : "0px"), 
                    this.textTwo.style("stroke", "#FFF").style("stroke-width", SelectionManager.containsSelection(ids, this.data.teamB.identity) ? "2px" : "0px");
                }, CheerMeter.prototype.draw = function(data, duration, viewport) {
                    var _this = this, easeName = "back", textOne = this.textOne, textTwo = this.textTwo;
                    this.svg.attr({
                        height: viewport.height,
                        width: viewport.width
                    }).on("click", function() {
                        _this.clearSelection();
                    }).style("background-color", data.background);
                    var layout = this.calculateLayout(data, viewport);
                    this.ensureStartState(layout, viewport), textOne.style("font-size", layout.fontSize).style("fill", data.teamA.color).on("click", function() {
                        _this.selectionManager.select(data.teamA.identity, d3.event.ctrlKey).then(function(ids) {
                            _this.updateSelectionUI(ids);
                        }), d3.event.stopPropagation();
                    }).text(data.teamA.name), textTwo.style("font-size", layout.fontSize).style("fill", data.teamB.color).on("click", function() {
                        _this.selectionManager.select(data.teamB.identity, d3.event.ctrlKey).then(function(ids) {
                            _this.updateSelectionUI(ids);
                        }), d3.event.stopPropagation();
                    }).text(data.teamB.name), textOne.transition().duration(duration).ease(easeName).attr({
                        y: layout.y1,
                        x: layout.x1
                    }), textTwo.transition().duration(duration).ease(easeName).attr({
                        y: layout.y2,
                        x: layout.x2
                    });
                }, CheerMeter.prototype.destroy = function() {
                    this.svg = null, this.textOne = this.textTwo = null;
                }, CheerMeter.prototype.enumerateObjectInstances = function(options) {
                    var instances = [], data = this.data;
                    switch (options.objectName) {
                      case "dataPoint":
                        if (data) for (var teams = [ data.teamA, data.teamB ], i = 0; i < teams.length; i++) {
                            var slice = teams[i], color = slice.color, selector = slice.identity, dataPointInstance = {
                                objectName: "dataPoint",
                                displayName: slice.name,
                                selector: selector,
                                properties: {
                                    fill: {
                                        solid: {
                                            color: color
                                        }
                                    }
                                }
                            };
                            instances.push(dataPointInstance);
                        }
                        break;

                      case "general":
                        var general = {
                            objectName: "general",
                            displayName: "General",
                            selector: null,
                            properties: {
                                fill: {
                                    solid: {
                                        color: data ? data.background : CheerMeter.DefaultBackgroundColor
                                    }
                                }
                            }
                        };
                        instances.push(general);
                    }
                    return instances;
                }, CheerMeter.capabilities = {
                    dataRoles: [ {
                        displayName: "Category",
                        name: "Category",
                        kind: powerbi.VisualDataRoleKind.Grouping
                    }, {
                        displayName: "Noise Measure",
                        name: "Y",
                        kind: powerbi.VisualDataRoleKind.Measure
                    } ],
                    dataViewMappings: [ {
                        categorical: {
                            categories: {
                                "for": {
                                    "in": "Category"
                                }
                            },
                            values: {
                                select: [ {
                                    bind: {
                                        to: "Y"
                                    }
                                } ]
                            }
                        }
                    } ],
                    objects: {
                        dataPoint: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                            description: powerbi.data.createDisplayNameGetter("Visual_DataPointDescription"),
                            properties: {
                                fill: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                },
                                width: {
                                    displayName: "",
                                    type: {
                                        numeric: !0
                                    }
                                }
                            }
                        },
                        general: {
                            displayName: "General",
                            properties: {
                                fill: {
                                    displayName: "Background color",
                                    type: {
                                        fill: {
                                            solid: {
                                                color: !0
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }, CheerMeter.DefaultFontFamily = "cursive", CheerMeter.DefaultFontColor = "rgb(165, 172, 175)", 
                CheerMeter.DefaultBackgroundColor = "#243C18", CheerMeter.PaddingBetweenText = 15, 
                CheerMeter;
            }();
            visuals.CheerMeter = CheerMeter;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var Color = jsCommon.Color, createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, PixelConverter = jsCommon.PixelConverter, DataRoleHelper = powerbi.data.DataRoleHelper, ScatterChart = function() {
                function ScatterChart(options) {
                    options && (this.tooltipsEnabled = options.tooltipsEnabled, this.tooltipBucketEnabled = options.tooltipBucketEnabled, 
                    this.interactivityService = options.interactivityService, this.animator = options.animator), 
                    this.renderer = new SvgRenderer();
                }
                return ScatterChart.prototype.init = function(options) {
                    this.options = options, this.element = options.element, this.currentViewport = options.viewport, 
                    this.style = options.style, this.host = options.host, this.colors = this.style.colorPalette.dataColors, 
                    this.interactivity = options.interactivity, this.cartesianVisualHost = options.cartesianHost, 
                    this.isMobileChart = options.interactivity && options.interactivity.isInteractiveLegend;
                    var svg = this.svg = options.svg;
                    svg.classed(ScatterChart.ClassName + " " + visuals.PlayChart.ClassName, !0), this.renderer.init(svg, options.labelsContext, this.isMobileChart, this.tooltipsEnabled);
                }, ScatterChart.getAdditionalTelemetry = function(dataView) {
                    var telemetry = {
                        hasSize: DataRoleHelper.hasRoleInDataView(dataView, "Size"),
                        hasPlayAxis: DataRoleHelper.hasRoleInDataView(dataView, "Play")
                    };
                    return telemetry;
                }, ScatterChart.getObjectProperties = function(dataView, dataLabelsSettings) {
                    var objects;
                    objects = dataView && dataView.metadata && dataView.metadata.objects ? dataView.metadata.objects : {};
                    var objectProperties = {};
                    objectProperties.defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.columnChartProps.dataPoint.defaultColor), 
                    objectProperties.showAllDataPoints = powerbi.DataViewObjects.getValue(objects, visuals.columnChartProps.dataPoint.showAllDataPoints, !1);
                    var labelsObj = objects.categoryLabels;
                    labelsObj && dataLabelsSettings && visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, dataLabelsSettings);
                    var hasGradient = dataView && visuals.GradientUtils.hasGradientRole(dataView.categorical);
                    return objectProperties.fillPoint = powerbi.DataViewObjects.getValue(objects, visuals.scatterChartProps.fillPoint.show, hasGradient), 
                    objectProperties.colorBorder = powerbi.DataViewObjects.getValue(objects, visuals.scatterChartProps.colorBorder.show, !1), 
                    objectProperties.colorByCategory = powerbi.DataViewObjects.getValue(objects, visuals.scatterChartProps.colorByCategory.show, !1), 
                    objectProperties;
                }, ScatterChart.converter = function(dataView, options, playFrameInfo, tooltipsEnabled, tooltipBucketEnabled) {
                    void 0 === tooltipsEnabled && (tooltipsEnabled = !0);
                    var categoryValues, categoryFormatter, categoryObjects, categoryIdentities, categoryQueryName, reader = powerbi.data.createIDataViewCategoricalReader(dataView), currentViewport = options.viewport, colorPalette = options.colors, interactivityService = options.interactivityService, categoryAxisProperties = options.categoryAxisProperties, valueAxisProperties = options.valueAxisProperties, dataViewCategorical = dataView.categorical, gradientValueColumn = visuals.GradientUtils.getGradientValueColumn(dataViewCategorical);
                    dataViewCategorical.categories && dataViewCategorical.categories.length > 0 ? (categoryValues = dataViewCategorical.categories[0].values, 
                    categoryFormatter = visuals.valueFormatter.create({
                        format: visuals.valueFormatter.getFormatString(dataViewCategorical.categories[0].source, visuals.scatterChartProps.general.formatString),
                        value: categoryValues[0],
                        value2: categoryValues[categoryValues.length - 1]
                    }), categoryIdentities = dataViewCategorical.categories[0].identity, categoryObjects = dataViewCategorical.categories[0].objects, 
                    categoryQueryName = dataViewCategorical.categories[0].source.queryName) : (categoryValues = [ null ], 
                    categoryFormatter = visuals.valueFormatter.createDefaultFormatter(null));
                    var categories = dataViewCategorical.categories, dataValues = dataViewCategorical.values, hasDynamicSeries = !!dataValues.source, grouped = dataValues.grouped(), dvSource = dataValues.source, scatterMetadata = ScatterChart.getMetadata(grouped, dvSource), dataLabelsSettings = visuals.dataLabelUtils.getDefaultPointLabelSettings(), sizeRange = ScatterChart.getSizeRangeForGroups(grouped, scatterMetadata.idx.size), objProps = ScatterChart.getObjectProperties(dataView, dataLabelsSettings), dataPointSeries = ScatterChart.createDataPointSeries(reader, dataValues, scatterMetadata, categories, categoryValues, categoryFormatter, categoryIdentities, categoryObjects, colorPalette, currentViewport, hasDynamicSeries, dataLabelsSettings, gradientValueColumn, objProps.defaultDataPointColor, categoryQueryName, objProps.colorByCategory, playFrameInfo, tooltipsEnabled, tooltipBucketEnabled), dataPoints = _.reduce(dataPointSeries, function(a, s) {
                        return a.concat(s.dataPoints);
                    }, []), legendItems = hasDynamicSeries ? ScatterChart.createSeriesLegend(dataValues, colorPalette, dataValues, visuals.valueFormatter.getFormatString(dvSource, visuals.scatterChartProps.general.formatString), objProps.defaultDataPointColor) : [], legendTitle = dataValues && dvSource ? dvSource.displayName : "";
                    return legendTitle || (legendTitle = categories && categories.length > 0 && categories[0].source.displayName ? categories[0].source.displayName : ""), 
                    categoryAxisProperties && null !== categoryAxisProperties.showAxisTitle && categoryAxisProperties.showAxisTitle === !1 && (scatterMetadata.axesLabels.x = null), 
                    valueAxisProperties && null !== valueAxisProperties.showAxisTitle && valueAxisProperties.showAxisTitle === !1 && (scatterMetadata.axesLabels.y = null), 
                    interactivityService && (interactivityService.applySelectionStateToData(dataPoints), 
                    interactivityService.applySelectionStateToData(legendItems)), {
                        xCol: scatterMetadata.cols.x,
                        yCol: scatterMetadata.cols.y,
                        dataPoints: dataPoints,
                        dataPointSeries: dataPointSeries,
                        legendData: {
                            title: legendTitle,
                            dataPoints: legendItems,
                            grouped: hasDynamicSeries
                        },
                        axesLabels: scatterMetadata.axesLabels,
                        size: scatterMetadata.cols.size,
                        sizeRange: sizeRange,
                        dataLabelsSettings: dataLabelsSettings,
                        defaultDataPointColor: objProps.defaultDataPointColor,
                        hasDynamicSeries: hasDynamicSeries,
                        showAllDataPoints: objProps.showAllDataPoints,
                        fillPoint: objProps.fillPoint,
                        colorBorder: objProps.colorBorder,
                        colorByCategory: objProps.colorByCategory
                    };
                }, ScatterChart.getSizeRangeForGroups = function(dataViewValueGroups, sizeColumnIndex) {
                    var result = {};
                    return dataViewValueGroups && dataViewValueGroups.forEach(function(group) {
                        var sizeColumn = ScatterChart.getMeasureValue(sizeColumnIndex, group.values), currentRange = visuals.AxisHelper.getRangeForColumn(sizeColumn);
                        (null == result.min || result.min > currentRange.min) && (result.min = currentRange.min), 
                        (null == result.max || result.max < currentRange.max) && (result.max = currentRange.max);
                    }), result;
                }, ScatterChart.createDataPointSeries = function(reader, dataValues, metadata, categories, categoryValues, categoryFormatter, categoryIdentities, categoryObjects, colorPalette, viewport, hasDynamicSeries, labelSettings, gradientValueColumn, defaultDataPointColor, categoryQueryName, colorByCategory, playFrameInfo, tooltipsEnabled, tooltipBucketEnabled) {
                    var hasX = reader.hasValues("X"), hasY = reader.hasValues("Y");
                    if (!hasX && !hasY) return [];
                    for (var dataPointSeries = [], indicies = metadata.idx, formatStringProp = visuals.scatterChartProps.general.formatString, dataValueSource = dataValues.source, grouped = dataValues.grouped(), colorHelper = new visuals.ColorHelper(colorPalette, visuals.scatterChartProps.dataPoint.fill, defaultDataPointColor), seriesIndex = 0, len = grouped.length; len > seriesIndex; seriesIndex++) {
                        var grouping = grouped[seriesIndex], seriesValues = grouping.values, measureX = ScatterChart.getMeasureValue(indicies.x, seriesValues), measureY = ScatterChart.getMeasureValue(indicies.y, seriesValues), measureSize = ScatterChart.getMeasureValue(indicies.size, seriesValues), seriesColor = void 0;
                        if (hasDynamicSeries) seriesColor = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name); else if (!colorByCategory && !categoryObjects) {
                            var measureSource = null != measureSize ? measureSize.source.queryName : "";
                            seriesColor = colorHelper.getColorForMeasure(null, measureSource);
                        }
                        var series = {
                            identityKey: grouping && grouping.identity && grouping.identity.key || "",
                            dataPoints: [],
                            hasSize: !(!measureSize || !measureSize.values),
                            fill: seriesColor
                        };
                        dataPointSeries.push(series);
                        for (var categoryIndex = 0, ilen = categoryValues.length; ilen > categoryIndex; categoryIndex++) {
                            var categoryValue = categoryValues[categoryIndex], xVal = hasX ? visuals.AxisHelper.normalizeNonFiniteNumber(reader.getValue("X", categoryIndex, seriesIndex)) : 0, yVal = hasY ? visuals.AxisHelper.normalizeNonFiniteNumber(reader.getValue("Y", categoryIndex, seriesIndex)) : 0, size = visuals.AxisHelper.normalizeNonFiniteNumber(reader.getValue("Size", categoryIndex, seriesIndex));
                            if (null != xVal && null != yVal) {
                                var color = void 0;
                                if (hasDynamicSeries) color = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name); else if (colorByCategory) color = colorHelper.getColorForSeriesValue(categoryObjects && categoryObjects[categoryIndex], dataValues.identityFields, categoryValue); else {
                                    var measureSource = null != measureSize ? measureSize.source.queryName : "";
                                    color = colorHelper.getColorForMeasure(categoryObjects && categoryObjects[categoryIndex], measureSource);
                                }
                                var category = _.isEmpty(categories) ? null : categories[0], identity = visuals.SelectionIdBuilder.builder().withCategory(category, categoryIndex).withSeries(dataValues, grouping).createSelectionId(), tooltipInfo = void 0;
                                tooltipsEnabled && (tooltipInfo = [], category && tooltipInfo.push({
                                    displayName: category.source.displayName,
                                    value: visuals.converterHelper.formatFromMetadataColumn(categoryValue, category.source, formatStringProp)
                                }), hasDynamicSeries && (category && category.source === dataValueSource || tooltipInfo.push({
                                    displayName: dataValueSource.displayName,
                                    value: visuals.converterHelper.formatFromMetadataColumn(grouping.name, dataValueSource, formatStringProp)
                                })), measureX && null != xVal && tooltipInfo.push({
                                    displayName: measureX.source.displayName,
                                    value: visuals.converterHelper.formatFromMetadataColumn(xVal, measureX.source, formatStringProp)
                                }), measureY && null != yVal && tooltipInfo.push({
                                    displayName: measureY.source.displayName,
                                    value: visuals.converterHelper.formatFromMetadataColumn(yVal, measureY.source, formatStringProp)
                                }), measureSize && null != measureSize.values[categoryIndex] && tooltipInfo.push({
                                    displayName: measureSize.source.displayName,
                                    value: visuals.converterHelper.formatFromMetadataColumn(measureSize.values[categoryIndex], measureSize.source, formatStringProp)
                                }), gradientValueColumn && null != gradientValueColumn.values[categoryIndex] && tooltipInfo.push({
                                    displayName: gradientValueColumn.source.displayName,
                                    value: visuals.converterHelper.formatFromMetadataColumn(gradientValueColumn.values[categoryIndex], gradientValueColumn.source, formatStringProp)
                                }), playFrameInfo && tooltipInfo.push({
                                    displayName: playFrameInfo.column.displayName,
                                    value: visuals.converterHelper.formatFromMetadataColumn(playFrameInfo.label, playFrameInfo.column, formatStringProp)
                                }), tooltipBucketEnabled && visuals.TooltipBuilder.addTooltipBucketItem(reader, tooltipInfo, categoryIndex, seriesIndex));
                                var dataPoint = {
                                    x: xVal,
                                    y: yVal,
                                    size: size,
                                    radius: {
                                        sizeMeasure: measureSize,
                                        index: categoryIndex
                                    },
                                    fill: color,
                                    formattedCategory: ScatterChart.createLazyFormattedCategory(categoryFormatter, null != categories ? categoryValue : grouping.name),
                                    selected: !1,
                                    identity: identity,
                                    tooltipInfo: tooltipInfo,
                                    labelFill: labelSettings.labelColor
                                };
                                series.dataPoints.push(dataPoint);
                            }
                        }
                    }
                    return dataPointSeries;
                }, ScatterChart.createLazyFormattedCategory = function(formatter, value) {
                    return new jsCommon.Lazy(function() {
                        return formatter.format(value);
                    });
                }, ScatterChart.createSeriesLegend = function(dataValues, colorPalette, categorical, formatString, defaultDataPointColor) {
                    for (var grouped = dataValues.grouped(), colorHelper = new visuals.ColorHelper(colorPalette, visuals.scatterChartProps.dataPoint.fill, defaultDataPointColor), legendItems = [], i = 0, len = grouped.length; len > i; i++) {
                        var grouping = grouped[i], color = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name), identity = visuals.SelectionIdBuilder.builder().withSeries(categorical, grouped[i]).createSelectionId();
                        legendItems.push({
                            color: color,
                            icon: visuals.LegendIcon.Circle,
                            label: visuals.valueFormatter.format(grouping.name, formatString),
                            identity: identity,
                            selected: !1
                        });
                    }
                    return legendItems;
                }, ScatterChart.getBubbleRadius = function(radiusData, sizeRange, viewport) {
                    var actualSizeDataRange = null, bubblePixelAreaSizeRange = null, measureSize = radiusData.sizeMeasure;
                    if (!measureSize) return ScatterChart.BubbleRadius;
                    var minSize = sizeRange.min ? sizeRange.min : 0, maxSize = sizeRange.max ? sizeRange.max : 0, min = Math.min(minSize, 0), max = Math.max(maxSize, 0);
                    if (actualSizeDataRange = {
                        minRange: min,
                        maxRange: max,
                        delta: max - min
                    }, bubblePixelAreaSizeRange = ScatterChart.getBubblePixelAreaSizeRange(viewport, ScatterChart.MinSizeRange, ScatterChart.MaxSizeRange), 
                    measureSize.values) {
                        var sizeValue = measureSize.values[radiusData.index];
                        if (null != sizeValue) return ScatterChart.projectSizeToPixels(sizeValue, actualSizeDataRange, bubblePixelAreaSizeRange) / 2;
                    }
                    return ScatterChart.BubbleRadius;
                }, ScatterChart.getMeasureValue = function(measureIndex, seriesValues) {
                    return measureIndex >= 0 ? seriesValues[measureIndex] : null;
                }, ScatterChart.getMetadata = function(grouped, source) {
                    var xCol, yCol, sizeCol, xIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "X"), yIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Y"), sizeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Size"), xAxisLabel = "", yAxisLabel = "";
                    if (grouped && grouped.length) {
                        var firstGroup = grouped[0];
                        xIndex >= 0 && (xCol = firstGroup.values[xIndex].source, xAxisLabel = firstGroup.values[xIndex].source.displayName), 
                        yIndex >= 0 && (yCol = firstGroup.values[yIndex].source, yAxisLabel = firstGroup.values[yIndex].source.displayName), 
                        sizeIndex >= 0 && (sizeCol = firstGroup.values[sizeIndex].source);
                    }
                    return {
                        idx: {
                            x: xIndex,
                            y: yIndex,
                            size: sizeIndex
                        },
                        cols: {
                            x: xCol,
                            y: yCol,
                            size: sizeCol
                        },
                        axesLabels: {
                            x: xAxisLabel,
                            y: yAxisLabel
                        }
                    };
                }, ScatterChart.getDefaultData = function() {
                    return {
                        xCol: void 0,
                        yCol: void 0,
                        dataPoints: [],
                        dataPointSeries: [],
                        legendData: {
                            dataPoints: []
                        },
                        axesLabels: {
                            x: "",
                            y: ""
                        },
                        sizeRange: [],
                        dataLabelsSettings: visuals.dataLabelUtils.getDefaultPointLabelSettings(),
                        defaultDataPointColor: null,
                        hasDynamicSeries: !1
                    };
                }, ScatterChart.prototype.renderAtFrame = function(data) {
                    this.data = data, this.cartesianVisualHost.triggerRender(!1);
                }, ScatterChart.prototype.setData = function(dataViews) {
                    var _this = this;
                    if (this.data = ScatterChart.getDefaultData(), this.playAxis && this.playAxis.isCurrentlyPlaying() && this.playAxis.stop(), 
                    dataViews.length > 0) {
                        var dataView = dataViews[0] || dataViews[1];
                        if (dataView) {
                            this.categoryAxisProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataView.metadata, !0), 
                            this.valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataView.metadata, !0), 
                            this.dataView = dataView;
                            var converterOptions_1 = {
                                viewport: this.currentViewport,
                                colors: this.colors,
                                interactivityService: this.interactivityService,
                                categoryAxisProperties: this.categoryAxisProperties,
                                valueAxisProperties: this.valueAxisProperties
                            };
                            if (visuals.PlayChart.isDataViewPlayable(dataView)) {
                                this.playAxis || (this.playAxis = new visuals.PlayAxis({
                                    animator: this.animator,
                                    interactivityService: this.interactivityService,
                                    isScrollable: !1
                                }), this.playAxis.init(this.options));
                                var playData = this.playAxis.setData(dataView, function(dataView, playFrameInfo) {
                                    return ScatterChart.converter(dataView, converterOptions_1, playFrameInfo, _this.tooltipsEnabled, _this.tooltipBucketEnabled);
                                });
                                this.mergeSizeRanges(playData), this.data = playData.currentViewModel, this.playAxis.setRenderFunction(function(data) {
                                    return _this.renderAtFrame(data);
                                });
                            } else this.playAxis && (this.playAxis.remove(), this.playAxis = null), dataView.categorical && dataView.categorical.values && (this.data = ScatterChart.converter(dataView, converterOptions_1, void 0, this.tooltipsEnabled, this.tooltipBucketEnabled));
                        }
                    } else this.playAxis && (this.playAxis.remove(), this.playAxis = null);
                }, ScatterChart.prototype.mergeSizeRanges = function(playData) {
                    if (playData && playData.currentViewModel) {
                        for (var mergedSizeRange = playData.currentViewModel.sizeRange, _i = 0, _a = playData.allViewModels; _i < _a.length; _i++) {
                            var data_1 = _a[_i], sizeRange = data_1.sizeRange;
                            null != sizeRange.min && (mergedSizeRange.min = Math.min(mergedSizeRange.min, sizeRange.min)), 
                            null != sizeRange.max && (mergedSizeRange.max = Math.max(mergedSizeRange.max, sizeRange.max));
                        }
                        for (var _b = 0, _c = playData.allViewModels; _b < _c.length; _b++) {
                            var data_2 = _c[_b];
                            data_2.sizeRange = mergedSizeRange;
                        }
                    }
                }, ScatterChart.prototype.calculateLegend = function() {
                    return this.data && this.data.legendData;
                }, ScatterChart.prototype.hasLegend = function() {
                    return this.data && this.data.hasDynamicSeries;
                }, ScatterChart.prototype.enumerateObjectInstances = function(enumeration, options) {
                    switch (options.objectName) {
                      case "colorByCategory":
                        this.data && (this.data.hasDynamicSeries || enumeration.pushInstance({
                            objectName: "colorByCategory",
                            selector: null,
                            properties: {
                                show: this.data.colorByCategory
                            }
                        }));
                        break;

                      case "dataPoint":
                        if (!this.playAxis) {
                            var categoricalDataView = this.dataView && this.dataView.categorical ? this.dataView.categorical : null;
                            if (!visuals.GradientUtils.hasGradientRole(categoricalDataView)) return this.enumerateDataPoints(enumeration);
                        }
                        break;

                      case "categoryAxis":
                        enumeration.pushInstance({
                            selector: null,
                            properties: {
                                showAxisTitle: this.categoryAxisProperties && null != this.categoryAxisProperties.showAxisTitle ? this.categoryAxisProperties.showAxisTitle : !0
                            },
                            objectName: "categoryAxis"
                        });
                        break;

                      case "valueAxis":
                        enumeration.pushInstance({
                            selector: null,
                            properties: {
                                showAxisTitle: this.valueAxisProperties && null != this.valueAxisProperties.showAxisTitle ? this.valueAxisProperties.showAxisTitle : !0
                            },
                            objectName: "valueAxis"
                        });
                        break;

                      case "categoryLabels":
                        this.data ? visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, this.data.dataLabelsSettings, !0) : visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, null, !0);
                        break;

                      case "fillPoint":
                        if (this.hasSizeMeasure()) return;
                        enumeration.pushInstance({
                            objectName: "fillPoint",
                            selector: null,
                            properties: {
                                show: this.data.fillPoint
                            }
                        });
                        break;

                      case "colorBorder":
                        this.hasSizeMeasure() && enumeration.pushInstance({
                            objectName: "colorBorder",
                            selector: null,
                            properties: {
                                show: this.data.colorBorder
                            }
                        });
                    }
                }, ScatterChart.prototype.hasSizeMeasure = function() {
                    var sizeRange = this.data.sizeRange;
                    return sizeRange && void 0 !== sizeRange.min;
                }, ScatterChart.prototype.enumerateDataPoints = function(enumeration) {
                    var data = this.data;
                    if (data) {
                        var seriesCount = data.dataPoints.length;
                        if (data.hasDynamicSeries) for (var legendDataPointLength = data.legendData.dataPoints.length, i = 0; legendDataPointLength > i; i++) {
                            var series = data.legendData.dataPoints[i];
                            enumeration.pushInstance({
                                objectName: "dataPoint",
                                displayName: series.label,
                                selector: visuals.ColorHelper.normalizeSelector(series.identity.getSelector()),
                                properties: {
                                    fill: {
                                        solid: {
                                            color: series.color
                                        }
                                    }
                                }
                            });
                        } else {
                            enumeration.pushInstance({
                                objectName: "dataPoint",
                                selector: null,
                                properties: {
                                    defaultColor: {
                                        solid: {
                                            color: data.defaultDataPointColor || this.colors.getColorByIndex(0).value
                                        }
                                    }
                                }
                            }).pushInstance({
                                objectName: "dataPoint",
                                selector: null,
                                properties: {
                                    showAllDataPoints: !!data.showAllDataPoints
                                }
                            });
                            for (var i = 0; seriesCount > i; i++) {
                                var seriesDataPoints = data.dataPoints[i];
                                enumeration.pushInstance({
                                    objectName: "dataPoint",
                                    displayName: seriesDataPoints.formattedCategory.getValue(),
                                    selector: visuals.ColorHelper.normalizeSelector(seriesDataPoints.identity.getSelector(), !0),
                                    properties: {
                                        fill: {
                                            solid: {
                                                color: seriesDataPoints.fill
                                            }
                                        }
                                    }
                                });
                            }
                        }
                    }
                }, ScatterChart.prototype.supportsTrendLine = function() {
                    var data = this.data;
                    if (!data) return !1;
                    var dataView = this.dataView, reader = powerbi.data.createIDataViewCategoricalReader(dataView);
                    return !this.hasSizeMeasure() && data.dataPointSeries.length > 0 && reader.hasValues("X") && reader.hasValues("Y");
                }, ScatterChart.getExtents = function(data) {
                    var dps = data.dataPoints;
                    return _.isEmpty(dps) ? {
                        minY: 0,
                        maxY: 0,
                        minX: 0,
                        maxX: 0
                    } : {
                        minY: d3.min(dps, function(d) {
                            return d.y;
                        }),
                        maxY: d3.max(dps, function(d) {
                            return d.y;
                        }),
                        minX: d3.min(dps, function(d) {
                            return d.x;
                        }),
                        maxX: d3.max(dps, function(d) {
                            return d.x;
                        })
                    };
                }, ScatterChart.prototype.calculateAxesProperties = function(options) {
                    var data = this.data, viewport = this.currentViewport = options.viewport, margin = options.margin;
                    this.currentViewport = viewport, this.margin = margin;
                    var width = viewport.width - (margin.left + margin.right), height = viewport.height - (margin.top + margin.bottom), extents = {
                        minY: 0,
                        maxY: 10,
                        minX: 0,
                        maxX: 10
                    };
                    this.playAxis ? (extents = this.playAxis.getCartesianExtents(extents, ScatterChart.getExtents), 
                    this.playAxis.setPlayControlPosition(options.playAxisControlLayout)) : _.isEmpty(data.dataPoints) || (extents = ScatterChart.getExtents(data));
                    var xDomain = [ extents.minX, extents.maxX ], combinedXDomain = visuals.AxisHelper.combineDomain(options.forcedXDomain, xDomain, options.ensureXDomain);
                    this.xAxisProperties = visuals.AxisHelper.createAxis({
                        pixelSpan: width,
                        dataDomain: combinedXDomain,
                        metaDataColumn: data.xCol,
                        formatString: visuals.valueFormatter.getFormatString(data.xCol, visuals.scatterChartProps.general.formatString),
                        outerPadding: 0,
                        isScalar: !0,
                        isVertical: !1,
                        forcedTickCount: options.forcedTickCount,
                        useTickIntervalForDisplayUnits: !0,
                        isCategoryAxis: !0,
                        scaleType: options.categoryAxisScaleType,
                        axisDisplayUnits: options.categoryAxisDisplayUnits,
                        axisPrecision: options.categoryAxisPrecision
                    }), this.xAxisProperties.axis.tickSize(-height, 0), this.xAxisProperties.axisLabel = this.data.axesLabels.x;
                    var combinedDomain = visuals.AxisHelper.combineDomain(options.forcedYDomain, [ extents.minY, extents.maxY ], options.ensureYDomain);
                    return this.yAxisProperties = visuals.AxisHelper.createAxis({
                        pixelSpan: height,
                        dataDomain: combinedDomain,
                        metaDataColumn: data.yCol,
                        formatString: visuals.valueFormatter.getFormatString(data.yCol, visuals.scatterChartProps.general.formatString),
                        outerPadding: 0,
                        isScalar: !0,
                        isVertical: !0,
                        forcedTickCount: options.forcedTickCount,
                        useTickIntervalForDisplayUnits: !0,
                        isCategoryAxis: !1,
                        scaleType: options.valueAxisScaleType,
                        axisDisplayUnits: options.valueAxisDisplayUnits,
                        axisPrecision: options.valueAxisPrecision
                    }), this.yAxisProperties.axisLabel = this.data.axesLabels.y, [ this.xAxisProperties, this.yAxisProperties ];
                }, ScatterChart.prototype.overrideXScale = function(xProperties) {
                    this.xAxisProperties = xProperties;
                }, ScatterChart.prototype.shouldSuppressAnimation = function() {
                    return this.data && this.data.dataPoints && this.data.dataPoints.length > ScatterChart.NoAnimationThreshold;
                }, ScatterChart.prototype.render = function(suppressAnimations, resizeMode) {
                    if (this.data) {
                        var data = this.data, margin = this.margin, viewport = this.currentViewport, hasSelection = this.interactivityService && this.interactivityService.hasSelection(), plotArea = {
                            width: viewport.width - (margin.left + margin.right),
                            height: viewport.height - (margin.top + margin.bottom)
                        }, duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                        this.playAxis && this.playAxis.isCurrentlyPlaying() && (this.isMobileChart || duration > 0) && (duration = visuals.PlayChart.FrameAnimationDuration);
                        var easeType = this.playAxis ? "linear" : "cubic-in-out", fillMarkers = (!data.sizeRange || !data.sizeRange.min) && data.fillPoint, drawBubbles = this.hasSizeMeasure(), suppressDataPointRendering = 1 === resizeMode && data.dataPoints && data.dataPoints.length > ScatterChart.NoRenderResizeThreshold, viewModel = {
                            data: data,
                            drawBubbles: drawBubbles,
                            isPlay: !!this.playAxis,
                            xAxisProperties: this.xAxisProperties,
                            yAxisProperties: this.yAxisProperties,
                            viewport: plotArea,
                            hasSelection: hasSelection,
                            animationDuration: duration,
                            animationOptions: this.options.animation,
                            fillMarkers: fillMarkers,
                            easeType: easeType,
                            suppressDataPointRendering: suppressDataPointRendering
                        };
                        if (drawBubbles) {
                            var sortedData = data.dataPoints.sort(ScatterChart.sortBubbles);
                            viewModel.data = powerbi.Prototype.inherit(viewModel.data), viewModel.data.dataPoints = sortedData;
                        }
                        var labelDataPoints = [];
                        (data.dataLabelsSettings && data.dataLabelsSettings.show || data.dataLabelsSettings.showCategory) && (labelDataPoints = ScatterChartDataLabels.createLabelDataPoints(viewModel));
                        var behaviorOptions = this.renderer.render(viewModel, this.interactivityService);
                        this.isMobileChart && (behaviorOptions = {
                            data: behaviorOptions.data,
                            dataPointsSelection: behaviorOptions.dataPointsSelection,
                            eventGroup: behaviorOptions.eventGroup,
                            plotContext: behaviorOptions.plotContext,
                            host: this.cartesianVisualHost,
                            root: this.svg,
                            visualInitOptions: this.options,
                            xAxisProperties: this.xAxisProperties,
                            yAxisProperties: this.yAxisProperties,
                            background: d3.select(this.element.get(0))
                        });
                        var playRenderResult;
                        if (this.playAxis && (playRenderResult = this.playAxis.render(suppressAnimations, viewModel, viewport, margin), 
                        this.interactivityService)) {
                            var playBehaviorOptions = {
                                traceLineRenderer: this.renderer.createTraceLineRenderer(playRenderResult.viewModel)
                            };
                            hasSelection && visuals.PlayChart.renderTraceLines(playRenderResult.allDataPoints, playBehaviorOptions.traceLineRenderer, !suppressAnimations), 
                            behaviorOptions.playOptions = playBehaviorOptions;
                        }
                        return {
                            dataPoints: playRenderResult ? playRenderResult.allDataPoints : data.dataPoints,
                            behaviorOptions: behaviorOptions,
                            labelDataPoints: labelDataPoints,
                            labelsAreNumeric: !1
                        };
                    }
                }, ScatterChart.getStrokeFill = function(d, colorBorder) {
                    if (null != d.size && colorBorder) {
                        var colorRgb = Color.parseColorString(d.fill);
                        return Color.hexString(Color.darken(colorRgb, ScatterChart.StrokeDarkenColorValue));
                    }
                    return d.fill;
                }, ScatterChart.getBubblePixelAreaSizeRange = function(viewPort, minSizeRange, maxSizeRange) {
                    var ratio = 1;
                    if (viewPort.height > 0 && viewPort.width > 0) {
                        var minSize = Math.min(viewPort.height, viewPort.width);
                        ratio = minSize * minSize / ScatterChart.AreaOf300By300Chart;
                    }
                    var minRange = Math.round(minSizeRange * ratio), maxRange = Math.round(maxSizeRange * ratio);
                    return {
                        minRange: minRange,
                        maxRange: maxRange,
                        delta: maxRange - minRange
                    };
                }, ScatterChart.project = function(value, actualSizeDataRange, bubblePixelAreaSizeRange) {
                    if (0 === actualSizeDataRange.delta || 0 === bubblePixelAreaSizeRange.delta) return ScatterChart.rangeContains(actualSizeDataRange, value) ? bubblePixelAreaSizeRange.minRange : null;
                    var relativeX = (value - actualSizeDataRange.minRange) / actualSizeDataRange.delta;
                    return bubblePixelAreaSizeRange.minRange + relativeX * bubblePixelAreaSizeRange.delta;
                }, ScatterChart.projectSizeToPixels = function(size, actualSizeDataRange, bubblePixelAreaSizeRange) {
                    var projectedSize = 0;
                    if (actualSizeDataRange) {
                        if (projectedSize = bubblePixelAreaSizeRange.maxRange, 0 !== actualSizeDataRange.delta) {
                            var value = Math.min(Math.max(size, actualSizeDataRange.minRange), actualSizeDataRange.maxRange);
                            projectedSize = ScatterChart.project(value, actualSizeDataRange, bubblePixelAreaSizeRange);
                        }
                        projectedSize = 2 * Math.sqrt(projectedSize / Math.PI);
                    }
                    return Math.round(projectedSize);
                }, ScatterChart.rangeContains = function(range, value) {
                    return range.minRange <= value && value <= range.maxRange;
                }, ScatterChart.getMarkerFillOpacity = function(hasSize, shouldEnableFill, hasSelection, isSelected) {
                    return hasSize || shouldEnableFill ? hasSelection && !isSelected ? ScatterChart.DimmedBubbleOpacity : ScatterChart.DefaultBubbleOpacity : 0;
                }, ScatterChart.getMarkerStrokeOpacity = function(hasSize, colorBorder, hasSelection, isSelected) {
                    return hasSize && colorBorder ? 1 : hasSelection && !isSelected ? ScatterChart.DimmedBubbleOpacity : ScatterChart.DefaultBubbleOpacity;
                }, ScatterChart.getMarkerStrokeFill = function(hasSize, colorBorder, fill) {
                    if (hasSize && colorBorder) {
                        var colorRgb = Color.parseColorString(fill);
                        return Color.hexString(Color.darken(colorRgb, ScatterChart.StrokeDarkenColorValue));
                    }
                    return fill;
                }, ScatterChart.getMarkerStyle = function(d, colorBorder, hasSelection, fillMarkers) {
                    return {
                        "stroke-opacity": ScatterChart.getMarkerStrokeOpacity(null != d.size, colorBorder, hasSelection, d.selected),
                        stroke: ScatterChart.getMarkerStrokeFill(null != d.size, colorBorder, d.fill),
                        fill: d.fill,
                        "fill-opacity": ScatterChart.getMarkerFillOpacity(null != d.size, fillMarkers, hasSelection, d.selected)
                    };
                }, ScatterChart.getSeriesStyle = function(hasSize, colorBorder, hasSelection, fillMarkers, fill) {
                    return {
                        "stroke-opacity": ScatterChart.getMarkerStrokeOpacity(hasSize, colorBorder, hasSelection, !1),
                        stroke: ScatterChart.getMarkerStrokeFill(hasSize, colorBorder, fill),
                        fill: fill,
                        "fill-opacity": ScatterChart.getMarkerFillOpacity(hasSize, fillMarkers, hasSelection, !1)
                    };
                }, ScatterChart.getBubbleOpacity = function(d, hasSelection) {
                    return hasSelection && !d.selected ? ScatterChart.DimmedBubbleOpacity : ScatterChart.DefaultBubbleOpacity;
                }, ScatterChart.prototype.onClearSelection = function() {
                    this.interactivityService && this.interactivityService.clearSelection();
                }, ScatterChart.prototype.getSupportedCategoryAxisType = function() {
                    return visuals.axisType.scalar;
                }, ScatterChart.sortBubbles = function(a, b) {
                    var diff = b.radius.sizeMeasure.values[b.radius.index] - a.radius.sizeMeasure.values[a.radius.index];
                    return 0 !== diff ? diff : b.identity.getKey().localeCompare(a.identity.getKey());
                }, ScatterChart.BubbleRadius = 6, ScatterChart.DefaultBubbleOpacity = .85, ScatterChart.DimmedBubbleOpacity = .4, 
                ScatterChart.StrokeDarkenColorValue = 63.75, ScatterChart.dataLabelLayoutStartingOffset = 2, 
                ScatterChart.dataLabelLayoutOffsetIterationDelta = 6, ScatterChart.dataLabelLayoutMaximumOffset = ScatterChart.dataLabelLayoutStartingOffset + 2 * ScatterChart.dataLabelLayoutOffsetIterationDelta, 
                ScatterChart.AreaOf300By300Chart = 9e4, ScatterChart.MinSizeRange = 200, ScatterChart.MaxSizeRange = 3e3, 
                ScatterChart.ClassName = "scatterChart", ScatterChart.NoAnimationThreshold = 1e3, 
                ScatterChart.NoRenderResizeThreshold = 1e3, ScatterChart;
            }();
            visuals.ScatterChart = ScatterChart;
            var ScatterChartDataLabels, SvgRenderer = function() {
                function SvgRenderer() {}
                return SvgRenderer.prototype.init = function(element, labelsContext, isMobileChart, tooltipsEnabled) {
                    this.mainGraphicsG = element.append("g").classed(SvgRenderer.MainGraphicsContext["class"], !0), 
                    this.isMobileChart = isMobileChart, isMobileChart && (this.mainGraphicsBackgroundRect = this.mainGraphicsG.append("rect").classed("backgroundRect", !0).attr({
                        width: "100%",
                        height: "100%"
                    })), this.mainGraphicsContext = this.mainGraphicsG.append("svg"), this.labelGraphicsContext = labelsContext, 
                    this.tooltipsEnabled = tooltipsEnabled, this.mainGraphicsContext.attr("stroke-width", "1");
                }, SvgRenderer.prototype.render = function(viewModel, interactivityService) {
                    var viewport = viewModel.viewport;
                    this.mainGraphicsContext.attr({
                        width: viewport.width,
                        height: viewport.height
                    });
                    var scatterMarkers;
                    return scatterMarkers = viewModel.suppressDataPointRendering ? this.removeScatterMarkers() : viewModel.animationDuration > 0 ? this.drawScatterMarkers(viewModel) : this.drawScatterMarkersNoAnimation(viewModel, viewModel.drawBubbles), 
                    viewModel.drawBubbles && scatterMarkers.order(), this.tooltipsEnabled && visuals.TooltipManager.addTooltip(this.mainGraphicsContext, function(tooltipEvent) {
                        return tooltipEvent.data.tooltipInfo;
                    }), visuals.SVGUtil.flushAllD3TransitionsIfNeeded(viewModel.animationOptions), {
                        dataPointsSelection: scatterMarkers,
                        eventGroup: this.mainGraphicsG,
                        data: viewModel.data,
                        plotContext: this.mainGraphicsContext
                    };
                }, SvgRenderer.prototype.createTraceLineRenderer = function(viewModel) {
                    return new ScatterTraceLineRenderer(viewModel, this.mainGraphicsContext, this.tooltipsEnabled);
                }, SvgRenderer.prototype.removeScatterMarkers = function() {
                    return this.mainGraphicsContext.selectAll(SvgRenderer.ScatterMarkerSeriesGroup.selector).remove(), 
                    this.mainGraphicsContext.selectAll(SvgRenderer.DotClass.selector);
                }, SvgRenderer.prototype.drawScatterMarkers = function(viewModel) {
                    var data = viewModel.data, xScale = viewModel.xAxisProperties.scale, yScale = viewModel.yAxisProperties.scale, fakeDataPointSeries = [ {
                        identityKey: "",
                        dataPoints: data.dataPoints
                    } ], fakeSeriesGroups = this.mainGraphicsContext.selectAll(SvgRenderer.ScatterMarkerSeriesGroup.selector).data(fakeDataPointSeries, function(s) {
                        return s.identityKey;
                    });
                    fakeSeriesGroups.enter().append("g").classed(SvgRenderer.ScatterMarkerSeriesGroup["class"], !0), 
                    fakeSeriesGroups.exit().remove();
                    var markers = fakeSeriesGroups.selectAll(SvgRenderer.DotClass.selector).data(function(s) {
                        return s.dataPoints;
                    }, function(d) {
                        return d.identity.getKey();
                    });
                    return markers.enter().append("circle").classed(SvgRenderer.DotClass["class"], !0).style("opacity", 0).attr("r", 0), 
                    markers.style({
                        "stroke-opacity": function(d) {
                            return ScatterChart.getMarkerStrokeOpacity(null != d.size, data.colorBorder, viewModel.hasSelection, d.selected);
                        },
                        stroke: function(d) {
                            return ScatterChart.getStrokeFill(d, data.colorBorder);
                        },
                        fill: function(d) {
                            return d.fill;
                        },
                        "fill-opacity": function(d) {
                            return ScatterChart.getMarkerFillOpacity(null != d.size, viewModel.fillMarkers, viewModel.hasSelection, d.selected);
                        }
                    }).transition().ease(viewModel.easeType).duration(viewModel.animationDuration).style("opacity", 1).attr({
                        r: function(d) {
                            return ScatterChart.getBubbleRadius(d.radius, data.sizeRange, viewModel.viewport);
                        },
                        cx: function(d) {
                            return xScale(d.x);
                        },
                        cy: function(d) {
                            return yScale(d.y);
                        }
                    }), markers.exit().transition().ease(viewModel.easeType).duration(viewModel.animationDuration).style("opacity", 0).attr("r", 0).remove(), 
                    markers;
                }, SvgRenderer.prototype.drawScatterMarkersNoAnimation = function(viewModel, isBubble) {
                    var seriesGroups, data = viewModel.data, xScale = viewModel.xAxisProperties.scale, yScale = viewModel.yAxisProperties.scale;
                    if (isBubble) {
                        var fakeDataPointSeries = [ {
                            identityKey: "",
                            dataPoints: data.dataPoints
                        } ];
                        seriesGroups = this.mainGraphicsContext.selectAll(SvgRenderer.ScatterMarkerSeriesGroup.selector).data(fakeDataPointSeries, function(s) {
                            return s.identityKey;
                        });
                    } else seriesGroups = this.mainGraphicsContext.selectAll(SvgRenderer.ScatterMarkerSeriesGroup.selector).data(data.dataPointSeries, function(s) {
                        return s.identityKey;
                    });
                    return seriesGroups.enter().append("g").classed(SvgRenderer.ScatterMarkerSeriesGroup["class"], !0), 
                    seriesGroups.exit().remove(), seriesGroups.each(function(s) {
                        var seriesStyle = ScatterChart.getSeriesStyle(s.hasSize, data.colorBorder, viewModel.hasSelection, viewModel.fillMarkers, s.fill), g = d3.select(this);
                        SvgRenderer.applyStyle(this, seriesStyle);
                        var markers = g.selectAll(SvgRenderer.DotClass.selector).data(s.dataPoints, function(m) {
                            return m.identity.getKey();
                        });
                        markers.interrupt(), markers.enter().append("circle").classed(SvgRenderer.DotClass["class"], !0), 
                        markers.exit().remove(), markers.each(function(d) {
                            var style = ScatterChart.getMarkerStyle(d, data.colorBorder, viewModel.hasSelection, viewModel.fillMarkers);
                            SvgRenderer.styleException(style, seriesStyle), SvgRenderer.applyStyle(this, style);
                        }), markers.attr({
                            r: function(d) {
                                return ScatterChart.getBubbleRadius(d.radius, data.sizeRange, viewModel.viewport);
                            },
                            cx: function(d) {
                                return xScale(d.x);
                            },
                            cy: function(d) {
                                return yScale(d.y);
                            }
                        });
                    }), this.mainGraphicsContext.selectAll(SvgRenderer.DotClass.selector);
                }, SvgRenderer.styleException = function(elementStyle, seriesStyle) {
                    if (seriesStyle) for (var name_1 in elementStyle) elementStyle[name_1] === seriesStyle[name_1] && (elementStyle[name_1] = null);
                }, SvgRenderer.applyStyle = function(element, style) {
                    for (var name_2 in style) {
                        var elementValue = element.style[name_2], styleValue = style[name_2];
                        if (null == styleValue) {
                            if ("" === elementValue) continue;
                        } else if (styleValue = styleValue.toString(), styleValue === elementValue) continue;
                        element.style[name_2] = styleValue;
                    }
                }, SvgRenderer.DotClass = createClassAndSelector("dot"), SvgRenderer.MainGraphicsContext = createClassAndSelector("mainGraphicsContext"), 
                SvgRenderer.ScatterMarkerSeriesGroup = createClassAndSelector("scatterMarkerSeriesGroup"), 
                SvgRenderer;
            }();
            !function(ScatterChartDataLabels) {
                function createLabelDataPoints(viewModel) {
                    for (var xScale = viewModel.xAxisProperties.scale, yScale = viewModel.yAxisProperties.scale, sizeRange = viewModel.data.sizeRange, labelDataPoints = [], dataPoints = viewModel.data.dataPoints, labelSettings = viewModel.data.dataLabelsSettings, preferredLabelsKeys = getPreferredLabelsKeys(viewModel), _i = 0, dataPoints_1 = dataPoints; _i < dataPoints_1.length; _i++) {
                        var dataPoint = dataPoints_1[_i], text = dataPoint.formattedCategory.getValue(), properties = {
                            text: text,
                            fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                            fontSize: PixelConverter.fromPoint(labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt),
                            fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight
                        }, textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties), textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
                        labelDataPoints.push({
                            isPreferred: preferredLabelsKeys ? isLabelPreferred(dataPoint.identity.getKey(), preferredLabelsKeys) : !1,
                            text: text,
                            textSize: {
                                width: textWidth,
                                height: textHeight
                            },
                            outsideFill: labelSettings.labelColor ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultLabelColor,
                            insideFill: visuals.NewDataLabelUtils.defaultInsideLabelColor,
                            parentType: 0,
                            parentShape: {
                                point: {
                                    x: xScale(dataPoint.x),
                                    y: yScale(dataPoint.y)
                                },
                                radius: ScatterChart.getBubbleRadius(dataPoint.radius, sizeRange, viewModel.viewport),
                                validPositions: validLabelPositions
                            },
                            identity: dataPoint.identity,
                            fontSize: labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt
                        });
                    }
                    return labelDataPoints;
                }
                function getPreferredLabelsKeys(viewModel) {
                    var width = viewModel.viewport.width, height = viewModel.viewport.height, visualCenter = new visuals.Point(width / 2, height / 2), quadrantsCenters = getQuadrantsCenters(width, height);
                    return getCandidateLabels(visualCenter, quadrantsCenters, viewModel);
                }
                function getQuadrantsCenters(visualWidth, visualHeight) {
                    var quadrantsCenters = [], quarterWidth = visualWidth / 4, quarterHeight = visualHeight / 4;
                    return quadrantsCenters.push(new visuals.Point(quarterWidth, quarterHeight)), quadrantsCenters.push(new visuals.Point(3 * quarterWidth, quarterHeight)), 
                    quadrantsCenters.push(new visuals.Point(quarterWidth, 3 * quarterHeight)), quadrantsCenters.push(new visuals.Point(3 * quarterWidth, 3 * quarterHeight)), 
                    quadrantsCenters;
                }
                function getCandidateLabels(visualCenter, quadrantsCenters, viewModel) {
                    for (var distance, minDistances = [ Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE ], ids = [], xScale = viewModel.xAxisProperties.scale, yScale = viewModel.yAxisProperties.scale, _i = 0, _a = viewModel.data.dataPoints; _i < _a.length; _i++) {
                        var dp = _a[_i], x = xScale(dp.x), y = yScale(dp.y), quadrantNumber = getPointQuadrantNumber(x, y, visualCenter);
                        viewModel.drawBubbles ? ids[quadrantNumber] || (ids[quadrantNumber] = dp.identity) : (distance = getDistanceBetweenPoints(quadrantsCenters[quadrantNumber].x, quadrantsCenters[quadrantNumber].y, x, y), 
                        distance < minDistances[quadrantNumber] && (ids[quadrantNumber] = dp.identity, minDistances[quadrantNumber] = distance));
                    }
                    for (var preferredLabelsKeys = [], _b = 0, ids_1 = ids; _b < ids_1.length; _b++) {
                        var id = ids_1[_b];
                        id && preferredLabelsKeys.push(id.getKey());
                    }
                    return preferredLabelsKeys;
                }
                function getPointQuadrantNumber(x, y, centerPoint) {
                    return x > centerPoint.x && y <= centerPoint.y ? 0 : x <= centerPoint.x && y <= centerPoint.y ? 1 : x <= centerPoint.x && y > centerPoint.y ? 2 : 3;
                }
                function getDistanceBetweenPoints(x1, y1, x2, y2) {
                    return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
                }
                function isLabelPreferred(key, preferredLabelsKeys) {
                    for (var _i = 0, preferredLabelsKeys_1 = preferredLabelsKeys; _i < preferredLabelsKeys_1.length; _i++) {
                        var preferredLabel = preferredLabelsKeys_1[_i];
                        if (0 === key.localeCompare(preferredLabel)) return !0;
                    }
                    return !1;
                }
                var validLabelPositions = [ 2, 1, 8, 4, 16, 32, 64, 128 ];
                ScatterChartDataLabels.createLabelDataPoints = createLabelDataPoints;
            }(ScatterChartDataLabels || (ScatterChartDataLabels = {}));
            var ScatterTraceLineRenderer = function() {
                function ScatterTraceLineRenderer(viewModel, element, tooltipsEnabled) {
                    this.viewModel = viewModel, this.element = element, this.tooltipsEnabled = tooltipsEnabled;
                }
                return ScatterTraceLineRenderer.prototype.remove = function() {
                    this.element.selectAll(ScatterTraceLineRenderer.TraceLine.selector).remove(), this.element.selectAll(ScatterTraceLineRenderer.TraceBubble.selector).remove();
                }, ScatterTraceLineRenderer.prototype.render = function(selectedPoints, shouldAnimate) {
                    var viewModel = this.viewModel, scatterViewModel = viewModel.viewModel, seriesPoints = [];
                    if (_.isEmpty(selectedPoints) || scatterViewModel.suppressDataPointRendering) this.remove(); else {
                        for (var currentFrameIndex_1 = viewModel.data.currentFrameIndex, hasBubbleAtCurrentFrame = [], selectedIndex = 0, selectedLen = selectedPoints.length; selectedLen > selectedIndex; selectedIndex++) {
                            seriesPoints[selectedIndex] = [], hasBubbleAtCurrentFrame[selectedIndex] = !1;
                            for (var frameIndex = 0, frameLen = viewModel.data.allViewModels.length; frameLen > frameIndex && currentFrameIndex_1 >= frameIndex; frameIndex++) {
                                var value = _.find(viewModel.data.allViewModels[frameIndex].dataPoints, function(value, index) {
                                    return value.identity.getKey() === selectedPoints[selectedIndex].identity.getKey();
                                });
                                null != value && (value.frameIndex = frameIndex, seriesPoints[selectedIndex].push(value), 
                                frameIndex === currentFrameIndex_1 && (hasBubbleAtCurrentFrame[selectedIndex] = !0));
                            }
                        }
                        var xScale_1 = scatterViewModel.xAxisProperties.scale, yScale_1 = scatterViewModel.yAxisProperties.scale, line_1 = d3.svg.line().x(function(d) {
                            return xScale_1(d.x);
                        }).y(function(d) {
                            return yScale_1(d.y);
                        }).defined(function(d) {
                            return null !== d.x && null !== d.y;
                        }), traceLines = this.element.selectAll(ScatterTraceLineRenderer.TraceLine.selector).data(selectedPoints, function(sp) {
                            return sp.identity.getKey();
                        });
                        traceLines.enter().append("path").classed(ScatterTraceLineRenderer.TraceLine["class"], !0);
                        var previousLengths_1 = [], newLengths_1 = [], reverse_1 = !1;
                        traceLines.each(function(d, i) {
                            var existingPath = this, previousLength = existingPath.hasAttribute("d") ? existingPath.getTotalLength() : 0;
                            previousLengths_1.push(previousLength);
                            var tempSvgPath = $("<svg><path></path></svg>"), tempPath = $("path", tempSvgPath);
                            tempPath.attr("d", line_1(seriesPoints[i]));
                            var newLength = seriesPoints[i].length > 0 ? tempPath.get()[0].getTotalLength() : 0;
                            newLengths_1.push(newLength), reverse_1 = reverse_1 || previousLength > newLength;
                        }), reverse_1 ? shouldAnimate ? traceLines.transition().ease("linear").duration(visuals.PlayChart.FrameAnimationDuration).attr("stroke-dashoffset", function(d, i) {
                            return previousLengths_1[i] - newLengths_1[i];
                        }).transition().ease("linear").duration(1).delay(visuals.PlayChart.FrameAnimationDuration).style("stroke", function(d) {
                            return ScatterChart.getStrokeFill(d, !0);
                        }).attr({
                            d: function(d, i) {
                                return line_1(seriesPoints[i]);
                            },
                            "stroke-dasharray": function(d, i) {
                                return newLengths_1[i] + " " + newLengths_1[i];
                            },
                            "stroke-dashoffset": 0
                        }) : traceLines.style("stroke", function(d) {
                            return ScatterChart.getStrokeFill(d, !0);
                        }).attr({
                            d: function(d, i) {
                                return line_1(seriesPoints[i]);
                            },
                            "stroke-dasharray": function(d, i) {
                                return newLengths_1[i] + " " + newLengths_1[i];
                            },
                            "stroke-dashoffset": 0
                        }) : (traceLines.style("stroke", function(d) {
                            return ScatterChart.getStrokeFill(d, !0);
                        }).attr({
                            d: function(d, i) {
                                return line_1(seriesPoints[i]);
                            },
                            "stroke-dasharray": function(d, i) {
                                return newLengths_1[i] + " " + newLengths_1[i];
                            },
                            "stroke-dashoffset": function(d, i) {
                                return newLengths_1[i] - previousLengths_1[i];
                            }
                        }), shouldAnimate ? traceLines.transition().ease("linear").duration(visuals.PlayChart.FrameAnimationDuration).attr("stroke-dashoffset", 0) : traceLines.attr("stroke-dashoffset", 0)), 
                        traceLines.exit().remove();
                        for (var circlePoints = [], selectedIndex_1 = 0; selectedIndex_1 < seriesPoints.length; selectedIndex_1++) {
                            var points = seriesPoints[selectedIndex_1], newPoints = hasBubbleAtCurrentFrame[selectedIndex_1] ? points.slice(0, points.length - 1) : points;
                            circlePoints = circlePoints.concat(newPoints);
                        }
                        var circles = this.element.selectAll(ScatterTraceLineRenderer.TraceBubble.selector).data(circlePoints, function(d) {
                            return d.identity.getKey() + d.x + d.y + d.size;
                        });
                        circles.enter().append("circle").style("opacity", 0).classed(ScatterTraceLineRenderer.TraceBubble["class"], !0), 
                        circles.attr("cx", function(d) {
                            return xScale_1(d.x);
                        }).attr("cy", function(d) {
                            return yScale_1(d.y);
                        }).attr("r", function(d) {
                            return ScatterChart.getBubbleRadius(d.radius, viewModel.data.currentViewModel.sizeRange, viewModel.viewport);
                        }).style({
                            "stroke-opacity": function(d) {
                                return ScatterChart.getBubbleOpacity(d, !0);
                            },
                            stroke: function(d) {
                                return ScatterChart.getStrokeFill(d, viewModel.data.currentViewModel.colorBorder);
                            },
                            fill: function(d) {
                                return d.fill;
                            },
                            "fill-opacity": function(d) {
                                return null != d.size ? .2 + d.frameIndex / currentFrameIndex_1 * .6 : 0;
                            }
                        }).transition().ease("linear").duration(visuals.PlayChart.FrameAnimationDuration).style("opacity", 1), 
                        circles.exit().transition().ease("linear").duration(visuals.PlayChart.FrameAnimationDuration).style("opacity", 0).remove(), 
                        this.tooltipsEnabled && visuals.TooltipManager.addTooltip(circles, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        }), circles.sort(function(d1, d2) {
                            return d2.size - d1.size;
                        });
                    }
                }, ScatterTraceLineRenderer.TraceLine = createClassAndSelector("traceLine"), ScatterTraceLineRenderer.TraceBubble = createClassAndSelector("traceBubble"), 
                ScatterTraceLineRenderer;
            }();
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, createDataViewScopeIdentity = powerbi.data.createDataViewScopeIdentity, DataViewConcatenateCategoricalColumns = powerbi.data.DataViewConcatenateCategoricalColumns, DataViewMatrixUtils = powerbi.data.DataViewMatrixUtils, SQExprBuilder = powerbi.data.SQExprBuilder, PlayAxis = function() {
                function PlayAxis(options) {
                    options && (this.interactivityService = options.interactivityService);
                }
                return PlayAxis.prototype.init = function(options) {
                    var _this = this;
                    this.element = options.element, this.svg = options.svg, this.host = options.host, 
                    this.isMobileChart = options.interactivity && options.interactivity.isInteractiveLegend, 
                    this.interactivityService && (this.playControl = new PlayControl(this.element, function(frameIndex) {
                        return _this.moveToFrameAndRender(frameIndex);
                    }, this.isMobileChart), this.playControl.onPlay(function() {
                        return _this.play();
                    }));
                }, PlayAxis.prototype.setData = function(dataView, visualConverter) {
                    if (dataView) {
                        if (this.ridiculousFlagForPersistProperties && dataView.metadata) return this.ridiculousFlagForPersistProperties = !1, 
                        this.playData;
                        dataView.matrix || dataView.categorical ? this.playData = PlayChart.converter(dataView, visualConverter) : this.playData = PlayChart.getDefaultPlayData();
                    } else this.playData = PlayChart.getDefaultPlayData();
                    return this.lastViewport = void 0, this.playData;
                }, PlayAxis.prototype.render = function(suppressAnimations, viewModel, viewport, margin) {
                    var playData = this.playData, resized = !this.lastViewport || this.lastViewport.height !== viewport.height || this.lastViewport.width !== viewport.width;
                    if (this.lastViewport = viewport, resized && this.stop(), playData) {
                        var playViewModel = {
                            data: this.playData,
                            viewModel: viewModel,
                            viewport: viewport
                        }, hasSelection = !1;
                        if (this.interactivityService) {
                            var data_1 = playData.currentViewModel;
                            this.interactivityService.applySelectionStateToData(data_1.dataPoints), hasSelection = this.interactivityService.hasSelection();
                        }
                        this.updateCallout(viewport, margin), this.playControl && resized && this.playControl.rebuild(playData, viewport);
                        var allDataPoints = playData.allViewModels.map(function(vm) {
                            return vm.dataPoints;
                        }), flatAllDataPoints = _.flatten(allDataPoints);
                        return {
                            allDataPoints: flatAllDataPoints,
                            viewModel: playViewModel
                        };
                    }
                }, PlayAxis.prototype.updateCallout = function(viewport, margin) {
                    var playData = this.playData, frameData = playData.frameData, currentFrameIndex = playData.currentFrameIndex, height = viewport.height, plotAreaHeight = height - margin.top - margin.bottom, width = viewport.width, plotAreaWidth = width - margin.left - margin.right, calloutDimension = Math.min(height, 1.3 * width), fontSize = Math.max(12, Math.round(calloutDimension / 7));
                    fontSize = Math.min(fontSize, 70);
                    var textProperties = {
                        fontSize: jsCommon.PixelConverter.toString(fontSize),
                        text: frameData[currentFrameIndex].text || "",
                        fontFamily: visuals.Font.Family.regular.css
                    }, textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties) - powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(textProperties), calloutData = [];
                    if (currentFrameIndex < frameData.length && currentFrameIndex >= 0 && plotAreaHeight > textHeight) {
                        var maxTextWidth = plotAreaWidth - 2 * PlayAxis.calloutOffsetMultiplier * textHeight, calloutText = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, maxTextWidth);
                        calloutData = [ calloutText ];
                    }
                    var callout = this.svg.selectAll(PlayAxis.PlayCallout.selector).data(calloutData);
                    callout.enter().append("text").classed(PlayAxis.PlayCallout["class"], !0), callout.text(function(d) {
                        return d;
                    }).attr({
                        x: plotAreaWidth - PlayAxis.calloutOffsetMultiplier * textHeight,
                        y: function() {
                            return textHeight;
                        }
                    }).style({
                        "font-size": fontSize + "px",
                        "text-anchor": "end"
                    }), callout.exit().remove();
                }, PlayAxis.prototype.play = function() {
                    var playData = this.playData;
                    if (this.isPlaying) this.stop(); else if (this.playControl) {
                        this.isPlaying = !0, this.playControl.play();
                        var indexToShow = Math.round(this.playControl.getCurrentIndex());
                        indexToShow >= playData.allViewModels.length - 1 ? playData.currentFrameIndex = -1 : playData.currentFrameIndex = indexToShow - 1, 
                        this.playNextFrame(playData);
                    }
                }, PlayAxis.prototype.playNextFrame = function(playData, startFrame, endFrame) {
                    var _this = this;
                    if (!this.isPlaying) return void this.stop();
                    var nextFrame = playData.currentFrameIndex + 1;
                    null != startFrame && null != endFrame && (nextFrame = Math.abs(endFrame - startFrame + 1), 
                    startFrame = nextFrame), nextFrame < playData.allViewModels.length && nextFrame > -1 ? (playData.currentFrameIndex = nextFrame, 
                    playData.currentViewModel = playData.allViewModels[nextFrame], this.renderDelegate(playData.currentViewModel), 
                    this.playControl.setFrame(nextFrame), nextFrame < playData.allViewModels.length && window.setTimeout(function() {
                        _this.playNextFrame(playData, startFrame, endFrame);
                    }, PlayChart.FrameStepDuration)) : this.stop();
                }, PlayAxis.prototype.stop = function() {
                    this.playControl && this.playControl.pause(), this.isPlaying = !1;
                }, PlayAxis.prototype.remove = function() {
                    this.playControl && this.playControl.remove(), d3.selectAll(PlayAxis.PlayCallout.selector).remove();
                }, PlayAxis.prototype.setRenderFunction = function(fn) {
                    this.renderDelegate = fn;
                }, PlayAxis.prototype.getCartesianExtents = function(existingExtents, getExtents) {
                    return this.playData && this.playData.allViewModels && this.playData.allViewModels.length > 0 ? PlayChart.getMinMaxForAllFrames(this.playData, getExtents) : existingExtents;
                }, PlayAxis.prototype.setPlayControlPosition = function(playControlLayout) {
                    if (this.playControl) {
                        var container = this.playControl.getContainer();
                        container.css("left", playControlLayout.left ? playControlLayout.left + "px" : ""), 
                        container.css("top", playControlLayout.top ? playControlLayout.top + "px" : "");
                    }
                }, PlayAxis.prototype.moveToFrameAndRender = function(frameIndex) {
                    var playData = this.playData;
                    if (this.isPlaying = !0, playData && frameIndex >= 0 && frameIndex < playData.allViewModels.length && frameIndex !== playData.currentFrameIndex) {
                        playData.currentFrameIndex = frameIndex;
                        var data_2 = playData.allViewModels[frameIndex];
                        playData.currentViewModel = data_2, this.renderDelegate(data_2);
                    }
                    this.isPlaying = !1;
                }, PlayAxis.prototype.isCurrentlyPlaying = function() {
                    return this.isPlaying;
                }, PlayAxis.PlayCallout = createClassAndSelector("play-callout"), PlayAxis.calloutOffsetMultiplier = .3, 
                PlayAxis;
            }();
            visuals.PlayAxis = PlayAxis;
            var PlayChart, PlayControl = function() {
                function PlayControl(element, renderDelegate, isMobileChart) {
                    this.isMobileChart = isMobileChart, this.createSliderDOM(element), this.renderDelegate = renderDelegate;
                }
                return PlayControl.prototype.getContainer = function() {
                    return this.playAxisContainer;
                }, PlayControl.prototype.remove = function() {
                    this.playAxisContainer && this.playAxisContainer.remove();
                }, PlayControl.prototype.pause = function() {
                    this.playButton.removeClass("pause").addClass("play");
                }, PlayControl.prototype.play = function() {
                    this.playButton.removeClass("play").addClass("pause");
                }, PlayControl.prototype.getCurrentIndex = function() {
                    return Math.round(this.noUiSlider.get());
                }, PlayControl.prototype.onPlay = function(handler) {
                    this.playButtonCircle.off("click"), this.playButtonCircle.on("click", handler);
                }, PlayControl.prototype.setFrame = function(frameIndex) {
                    this.noUiSlider.set([ frameIndex ]);
                }, PlayControl.prototype.rebuild = function(playData, viewport) {
                    var _this = this, slider = this.slider;
                    this.noUiSlider && this.noUiSlider.destroy();
                    var labelData = playData.labelData, sliderSize = PlayControl.calucalateSliderSize(labelData, viewport.width), container = this.getContainer();
                    sliderSize.marginLeft > PlayControl.SliderMarginLeft && (container.css("padding-left", sliderSize.marginLeft - PlayControl.SliderMarginLeft + "px"), 
                    container.css("box-sizing", "border-box"));
                    var skipStep = this.updateSliderControl(playData, sliderSize.width), width = PlayControl.adjustWidthRegardingLastItem(labelData, skipStep, sliderSize.width);
                    this.slider.css("width", width + "px"), this.noUiSlider.on("slide", function() {
                        var indexToShow = _this.getCurrentIndex();
                        _this.renderDelegate(indexToShow);
                    });
                    var nextLabelIndex = 0;
                    $(".noUi-value", slider).each(function(idx, elem) {
                        var actualWidth = labelData.labelInfo[nextLabelIndex].labelWidth;
                        $(elem).width(actualWidth), $(elem).css("margin-left", -actualWidth / 2 + "px"), 
                        nextLabelIndex += skipStep;
                    });
                }, PlayControl.prototype.updateSliderControl = function(playData, sliderWidth) {
                    var labelData = playData.labelData, sliderElement = this.slider.get(0), numFrames = playData.frameData.length, options = {
                        start: 0 === numFrames ? 0 : playData.currentFrameIndex,
                        step: 1,
                        range: {
                            min: 0,
                            max: 0 === numFrames ? 0 : numFrames - 1
                        }
                    }, pipOptions = null, skipMode = 0;
                    if (numFrames > 0) {
                        var filterPipLabels = PlayControl.createPipsFilterFn(playData, sliderWidth, labelData);
                        skipMode = filterPipLabels.skipStep, pipOptions = {
                            mode: "steps",
                            density: Math.ceil(100 / numFrames),
                            format: {
                                to: function(index) {
                                    return playData.frameData[index].escapedText;
                                },
                                from: function(value) {
                                    return playData.frameData.indexOf(value);
                                }
                            },
                            filter: filterPipLabels.filter
                        };
                    }
                    return options.pips = pipOptions, noUiSlider.create(sliderElement, options), this.noUiSlider = sliderElement.noUiSlider, 
                    skipMode;
                }, PlayControl.createPipsFilterFn = function(playData, sliderWidth, labelData) {
                    var maxLabelWidth = _.max(_.map(labelData.labelInfo, function(l) {
                        return l.labelWidth;
                    })), pipSize = 1, skipMode = 1, maxAllowedLabelWidth = playData.frameData.length > 1 ? sliderWidth / (playData.frameData.length - 1) : sliderWidth, widthRatio = maxLabelWidth / maxAllowedLabelWidth;
                    widthRatio > 1.25 ? (skipMode = Math.ceil(widthRatio), pipSize = 2) : (widthRatio > 1 || labelData.anyWordBreaks) && (pipSize = 2);
                    var filterPipLabels = function(index, type) {
                        return index % skipMode === 0 ? pipSize : 0;
                    };
                    return {
                        filter: filterPipLabels,
                        skipStep: skipMode
                    };
                }, PlayControl.adjustWidthRegardingLastItem = function(labelData, skipMode, sliderWidth) {
                    var labelLenth = labelData.labelInfo.length, lastVisibleItemIndex = Math.floor((labelLenth - 1) / skipMode) * skipMode, distanceToEnd = sliderWidth + PlayControl.SliderMarginRight - sliderWidth / labelLenth * (lastVisibleItemIndex + 1), lastItemWidth = labelData.labelInfo[lastVisibleItemIndex].labelWidth, requiredWidth = lastItemWidth / 2 - distanceToEnd;
                    if (requiredWidth > 0) {
                        var maxMargin = PlayControl.SliderMaxMargin - PlayControl.SliderMarginRight;
                        return requiredWidth = requiredWidth > maxMargin ? maxMargin : requiredWidth, sliderWidth - requiredWidth;
                    }
                    return sliderWidth;
                }, PlayControl.prototype.createSliderDOM = function(element) {
                    this.playAxisContainer = $('<div class="play-axis-container"></div>').appendTo(element).css("height", PlayControl.PlayControlHeight + "px"), 
                    this.playButtonCircle = $('<div class="button-container"></div>').appendTo(this.playAxisContainer), 
                    this.isMobileChart && this.playButtonCircle.addClass("mobile-button-container"), 
                    this.playButton = $('<div class="play"></div>').appendTo(this.playButtonCircle), 
                    this.slider = $('<div class="sliders"></div>').appendTo(this.playAxisContainer);
                }, PlayControl.calucalateSliderSize = function(labelData, viewportWidth) {
                    var leftMargin = 0;
                    _.isEmpty(labelData.labelInfo) || (leftMargin = _.first(labelData.labelInfo).labelWidth / 2);
                    var sliderLeftMargin = Math.max(leftMargin, PlayControl.SliderMarginLeft);
                    sliderLeftMargin = Math.min(PlayControl.SliderMaxMargin, sliderLeftMargin);
                    var sliderWidth = Math.max(viewportWidth - sliderLeftMargin - PlayControl.SliderMarginRight, 1);
                    return {
                        width: sliderWidth,
                        marginLeft: sliderLeftMargin
                    };
                }, PlayControl.SliderMarginLeft = 44, PlayControl.SliderMarginRight = 20, PlayControl.SliderMaxMargin = 100, 
                PlayControl.PlayControlHeight = 80, PlayControl;
            }();
            !function(PlayChart) {
                function convertMatrixToCategorical(sourceDataView, frame) {
                    var matrix = sourceDataView.matrix, categorical = {
                        categories: [],
                        values: powerbi.data.DataViewTransform.createValueColumns()
                    };
                    if (_.isEmpty(matrix.columns.levels) || matrix.rows.levels.length < 2 && matrix.columns.levels.length < 2) return {
                        metadata: sourceDataView.metadata,
                        categorical: categorical
                    };
                    for (var CategoryRowLevelsStartingIndex = 1, categories = [], i_1 = CategoryRowLevelsStartingIndex, ilen = matrix.rows.levels.length; ilen > i_1; i_1++) {
                        var sourceColumn = matrix.rows.levels[i_1].sources[0];
                        categories.push({
                            source: sourceColumn,
                            values: [],
                            identity: [],
                            objects: void 0
                        });
                    }
                    var hasRowChildren = !_.isEmpty(matrix.rows.root.children), hasColChildren = !_.isEmpty(matrix.columns.root.children), hasSeries = matrix.columns.levels.length > 1 && hasColChildren, hasPlayAndCategory = matrix.rows.levels.length > 1 && hasRowChildren;
                    if (hasSeries && !hasPlayAndCategory) {
                        categorical.categories = void 0;
                        var node = matrix.columns.root;
                        categorical.values.source = matrix.columns.levels[0].sources[0];
                        for (var columnLength_1 = matrix.valueSources.length, i_2 = 0, len_1 = node.children.length; len_1 > i_2; i_2++) for (var columnNode = node.children[i_2], j = 0; columnLength_1 > j; j++) {
                            var source = _.create(matrix.valueSources[j], {
                                groupName: void 0 === columnNode.value ? null : columnNode.value
                            }), dataViewColumn = {
                                identity: columnNode.identity,
                                values: [],
                                source: source
                            };
                            categorical.values.push(dataViewColumn);
                        }
                        for (var playFrameNode = matrix.rows.root.children[frame], matrixIntersectionValues = playFrameNode.values, i = 0, len = node.children.length; len > i; i++) for (var j = 0; columnLength_1 > j; j++) categorical.values[i * columnLength_1 + j].values.push(matrixIntersectionValues[i * columnLength_1 + j].value);
                    } else if (hasSeries && hasRowChildren) {
                        var playFrameNode = matrix.rows.root.children[frame];
                        DataViewMatrixUtils.forEachLeafNode(playFrameNode.children, function(categoryGroupLeafNode, index, categoryHierarchicalGroupNodes) {
                            addMatrixHierarchicalGroupToCategories(categoryHierarchicalGroupNodes, categories);
                        }), categorical.categories = categories, categorical.values.source = matrix.columns.levels[0].sources[0];
                        for (var nodeQueue = [], columnNode = matrix.columns.root, seriesIndex_1 = -1; columnNode; ) {
                            if (columnNode.children && columnNode.children[0].children) for (var j = 0, jlen = columnNode.children.length; jlen > j; j++) nodeQueue.push(columnNode.children[j]); else if (columnNode.children && playFrameNode.children) {
                                for (var columnLength = columnNode.children.length, j = 0; columnLength > j; j++) {
                                    var source = _.create(matrix.valueSources[j], {
                                        groupName: columnNode.value
                                    }), dataViewColumn = {
                                        identity: columnNode.identity,
                                        values: [],
                                        source: source
                                    };
                                    categorical.values.push(dataViewColumn);
                                }
                                DataViewMatrixUtils.forEachLeafNode(playFrameNode.children, function(leafNode) {
                                    for (var j = 0; columnLength > j; j++) categorical.values[seriesIndex_1 * columnLength + j].values.push(leafNode.values[seriesIndex_1 * columnLength + j].value);
                                });
                            }
                            nodeQueue.length > 0 ? (columnNode = nodeQueue[0], nodeQueue = nodeQueue.splice(1), 
                            seriesIndex_1++) : columnNode = void 0;
                        }
                    } else if (hasPlayAndCategory) {
                        for (var playFrameNode = matrix.rows.root.children[frame], measureLength_1 = matrix.valueSources.length, j = 0; measureLength_1 > j; j++) {
                            var dataViewColumn = {
                                identity: void 0,
                                values: [],
                                source: matrix.valueSources[j]
                            };
                            categorical.values.push(dataViewColumn);
                        }
                        DataViewMatrixUtils.forEachLeafNode(playFrameNode.children, function(categoryGroupLeafNode, index, categoryHierarchicalGroupNodes) {
                            addMatrixHierarchicalGroupToCategories(categoryHierarchicalGroupNodes, categories);
                            for (var j = 0; measureLength_1 > j; j++) categorical.values[j].values.push(categoryGroupLeafNode.values[j].value);
                        }), categorical.categories = categories;
                    }
                    return DataViewConcatenateCategoricalColumns.applyToPlayChartCategorical(sourceDataView.metadata, visuals.scatterChartCapabilities.objects, "Category", categorical);
                }
                function addMatrixHierarchicalGroupToCategories(sourceCategoryHierarchicalGroupNodes, destinationCategories) {
                    var identity = sourceCategoryHierarchicalGroupNodes[0].identity;
                    if (sourceCategoryHierarchicalGroupNodes.length > 1) {
                        for (var identityExpr = identity.expr, i = 1, ilen = sourceCategoryHierarchicalGroupNodes.length; ilen > i; i++) {
                            var identityExprToAdd = sourceCategoryHierarchicalGroupNodes[i].identity.expr;
                            identityExpr = SQExprBuilder.and(identityExpr, identityExprToAdd);
                        }
                        identity = createDataViewScopeIdentity(identityExpr);
                    }
                    for (var j = 0, jlen = destinationCategories.length; jlen > j; j++) {
                        destinationCategories[j].identity.push(identity);
                        var node = sourceCategoryHierarchicalGroupNodes[j];
                        destinationCategories[j].values.push(node.value);
                    }
                }
                function getObjectProperties(dataViewMetadata, dataLabelsSettings) {
                    var objectProperties = {};
                    if (dataViewMetadata && dataViewMetadata.objects) {
                        var objects = dataViewMetadata.objects;
                        objectProperties.currentFrameIndex = powerbi.DataViewObjects.getValue(objects, visuals.scatterChartProps.currentFrameIndex.index, null);
                    }
                    return objectProperties;
                }
                function converter(dataView, visualConverter) {
                    var keySourceColumn, dataViewMetadata = dataView.metadata, dataLabelsSettings = visuals.dataLabelUtils.getDefaultPointLabelSettings(), objectProperties = getObjectProperties(dataViewMetadata, dataLabelsSettings), allViewModels = [], frameKeys = [], convertedData = void 0, matrixRows = dataView.matrix.rows, rowChildrenLength = matrixRows.root.children ? matrixRows.root.children.length : 0;
                    if (dataView.matrix && rowChildrenLength > 0 && !_.isEmpty(matrixRows.levels) && !_.isEmpty(matrixRows.levels[0].sources)) {
                        keySourceColumn = matrixRows.levels[0].sources[0];
                        var formatString = visuals.valueFormatter.getFormatString(keySourceColumn, visuals.scatterChartProps.general.formatString), keyFormatter = void 0;
                        if (keySourceColumn.type.numeric) {
                            var valueRange = Math.abs(matrixRows.root.children[rowChildrenLength - 1].value - matrixRows.root.children[0].value);
                            keyFormatter = visuals.valueFormatter.create({
                                format: formatString,
                                value: valueRange,
                                value2: 0
                            });
                        } else keyFormatter = visuals.valueFormatter.createDefaultFormatter(formatString, !0);
                        for (var i = 0, len = rowChildrenLength; len > i; i++) {
                            var key = matrixRows.root.children[i], frameLabelText = keyFormatter.format(key.value), frameLabelHtml = $("<div/>").text(frameLabelText).html();
                            frameKeys.push({
                                escapedText: frameLabelHtml,
                                text: frameLabelText
                            });
                            var dataViewCategorical = convertMatrixToCategorical(dataView, i), frameInfo = {
                                label: frameLabelHtml,
                                column: keySourceColumn
                            };
                            convertedData = visualConverter(dataViewCategorical, frameInfo), allViewModels.push(convertedData);
                        }
                    } else {
                        var dataViewCategorical = convertMatrixToCategorical(dataView, 0);
                        convertedData = visualConverter(dataViewCategorical), allViewModels.push(convertedData);
                    }
                    return objectProperties.currentFrameIndex = frameKeys.length - 1, {
                        allViewModels: allViewModels,
                        currentViewModel: convertedData,
                        frameData: frameKeys,
                        currentFrameIndex: objectProperties.currentFrameIndex,
                        labelData: getLabelData(frameKeys, keySourceColumn)
                    };
                }
                function getDefaultPlayData() {
                    var defaultData = {
                        frameData: [],
                        allViewModels: [],
                        currentFrameIndex: 0,
                        currentViewModel: void 0,
                        labelData: {
                            anyWordBreaks: !1,
                            labelInfo: []
                        }
                    };
                    return defaultData;
                }
                function getMinMaxForAllFrames(playData, getExtents) {
                    var extents = {
                        minY: 0,
                        maxY: 10,
                        minX: 0,
                        maxX: 10
                    };
                    if (playData.allViewModels && playData.allViewModels.length > 0) {
                        extents.minY = extents.minX = Number.MAX_VALUE, extents.maxY = extents.maxX = Number.MIN_VALUE;
                        for (var i = 0, len = playData.allViewModels.length; len > i; i++) {
                            var data_3 = playData.allViewModels[i], e = getExtents(data_3);
                            extents = {
                                minY: d3.min([ e.minY, extents.minY ]),
                                maxY: d3.max([ e.maxY, extents.maxY ]),
                                minX: d3.min([ e.minX, extents.minX ]),
                                maxX: d3.max([ e.maxX, extents.maxX ])
                            };
                        }
                    }
                    return extents;
                }
                function getLabelData(keys, keyColumn) {
                    for (var textProperties = {
                        fontFamily: visuals.Font.Family.regular.css,
                        fontSize: jsCommon.PixelConverter.toString(14)
                    }, labelInfo = [], anyWordBreaks = !1, _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
                        var key = keys_1[_i], labelWidth = jsCommon.WordBreaker.getMaxWordWidth(key.escapedText, powerbi.TextMeasurementService.measureSvgTextWidth, textProperties);
                        anyWordBreaks = anyWordBreaks || jsCommon.WordBreaker.hasBreakers(key.escapedText) || key.escapedText.indexOf("-") > -1, 
                        labelInfo.push({
                            label: key.escapedText,
                            labelWidth: labelWidth
                        });
                    }
                    return {
                        labelInfo: labelInfo,
                        anyWordBreaks: anyWordBreaks,
                        labelFieldName: keyColumn && keyColumn.displayName
                    };
                }
                function isDataViewPlayable(dataView, playRole) {
                    void 0 === playRole && (playRole = "Play");
                    var firstRowSourceRoles = dataView.matrix && dataView.matrix.rows && dataView.matrix.rows.levels && dataView.matrix.rows.levels[0] && dataView.matrix.rows.levels[0].sources && dataView.matrix.rows.levels[0].sources[0] && dataView.matrix.rows.levels[0].sources[0].roles;
                    return firstRowSourceRoles && firstRowSourceRoles[playRole];
                }
                function renderTraceLines(allDataPoints, traceLineRenderer, shouldAnimate) {
                    var selectedDataPoints = _.filter(allDataPoints, function(d) {
                        return d.selected;
                    });
                    selectedDataPoints = _.uniq(selectedDataPoints, function(d) {
                        return d.identity.getKey();
                    }), traceLineRenderer.render(selectedDataPoints, shouldAnimate);
                }
                PlayChart.FrameStepDuration = 800, PlayChart.FrameAnimationDuration = 750, PlayChart.ClassName = "playChart", 
                PlayChart.convertMatrixToCategorical = convertMatrixToCategorical, PlayChart.converter = converter, 
                PlayChart.getDefaultPlayData = getDefaultPlayData, PlayChart.getMinMaxForAllFrames = getMinMaxForAllFrames, 
                PlayChart.isDataViewPlayable = isDataViewPlayable, PlayChart.renderTraceLines = renderTraceLines;
            }(PlayChart = visuals.PlayChart || (visuals.PlayChart = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var PixelConverter = jsCommon.PixelConverter, VerticalSlicerRenderer = function() {
                function VerticalSlicerRenderer(options) {
                    this.textProperties = {
                        fontFamily: visuals.Font.Family.regular.css,
                        fontSize: "14px"
                    }, options && (this.behavior = options.behavior), this.domHelper = options.domHelper;
                }
                return VerticalSlicerRenderer.prototype.getDefaultValue = function() {
                    return this.data && this.data.defaultValue ? this.data.defaultValue.value : void 0;
                }, VerticalSlicerRenderer.prototype.getIdentityFields = function() {
                    return visuals.SlicerUtil.DefaultValueHandler.getIdentityFields(this.dataView);
                }, VerticalSlicerRenderer.prototype.getUpdatedSelfFilter = function(searchKey) {
                    var metadata = this.dataView && this.dataView.metadata;
                    if (this.data.searchKey !== searchKey) return visuals.SlicerUtil.getUpdatedSelfFilter(searchKey, metadata);
                }, VerticalSlicerRenderer.prototype.init = function(slicerInitOptions) {
                    var _this = this;
                    this.element = slicerInitOptions.visualInitOptions.element, this.currentViewport = slicerInitOptions.visualInitOptions.viewport;
                    var interactivityService, hostServices = this.hostServices = slicerInitOptions.visualInitOptions.host, settings = this.settings = visuals.Slicer.DefaultStyleProperties(), domHelper = this.domHelper, bodyViewport = domHelper.getSlicerBodyViewport(this.currentViewport, settings, this.textProperties);
                    this.behavior && (interactivityService = visuals.createInteractivityService(hostServices));
                    var containerDiv = document.createElement("div");
                    containerDiv.className = Selectors.Container["class"];
                    var container = this.container = d3.select(containerDiv), header = domHelper.createSlicerHeader(hostServices);
                    containerDiv.appendChild(header), this.header = d3.select(header), this.body = container.append("div").classed(visuals.SlicerUtil.Selectors.Body["class"], !0).style({
                        height: PixelConverter.toString(bodyViewport.height),
                        width: PixelConverter.toString(bodyViewport.width)
                    });
                    var rowEnter = function(rowSelection) {
                        _this.onEnterSelection(rowSelection);
                    }, rowUpdate = function(rowSelection) {
                        _this.onUpdateSelection(rowSelection, interactivityService);
                    }, rowExit = function(rowSelection) {
                        rowSelection.remove();
                    }, listViewOptions = {
                        rowHeight: domHelper.getRowHeight(settings, this.textProperties),
                        enter: rowEnter,
                        exit: rowExit,
                        update: rowUpdate,
                        loadMoreData: function() {
                            return slicerInitOptions.loadMoreData();
                        },
                        scrollEnabled: !0,
                        viewport: domHelper.getSlicerBodyViewport(this.currentViewport, settings, this.textProperties),
                        baseContainer: this.body,
                        isReadMode: function() {
                            return 1 !== _this.hostServices.getViewMode();
                        }
                    };
                    return this.listView = visuals.ListViewFactory.createListView(listViewOptions), 
                    this.element.get(0).appendChild(containerDiv), interactivityService;
                }, VerticalSlicerRenderer.prototype.render = function(options) {
                    var data = this.data = options.data;
                    this.currentViewport = options.viewport;
                    var dataView = options.dataView;
                    if (!dataView || !data) return void this.listView.empty();
                    this.dataView = dataView;
                    var settings = this.settings = data.slicerSettings, domHelper = this.domHelper;
                    domHelper.updateSlicerBodyDimensions(this.currentViewport, this.body, settings), 
                    this.updateSelectionStyle(), this.listView.viewport(domHelper.getSlicerBodyViewport(this.currentViewport, settings, this.textProperties)).rowHeight(domHelper.getRowHeight(settings, this.textProperties)).data(data.slicerDataPoints, function(d) {
                        return $.inArray(d, data.slicerDataPoints);
                    }, options.resetScrollbarPosition);
                }, VerticalSlicerRenderer.prototype.updateSelectionStyle = function() {
                    var settings = this.settings;
                    this.container.classed("isMultiSelectEnabled", settings && settings.selection && !settings.selection.singleSelect);
                }, VerticalSlicerRenderer.prototype.onEnterSelection = function(rowSelection) {
                    var settings = this.settings, listItemElement = rowSelection.append("ul").append("li").classed(Selectors.ItemContainer["class"], !0), labelElement = listItemElement.append("div").classed(Selectors.Input["class"], !0);
                    labelElement.append("input").attr("type", "checkbox"), labelElement.append("span").classed(Selectors.Checkbox["class"], !0), 
                    listItemElement.each(function(d, i) {
                        var item = d3.select(this);
                        d.isImage ? item.append("img").classed(visuals.SlicerUtil.Selectors.LabelImage["class"], !0) : item.append("span").classed(visuals.SlicerUtil.Selectors.LabelText["class"], !0), 
                        null != d.count && item.append("span").classed(visuals.SlicerUtil.Selectors.CountText["class"], !0).style("font-size", PixelConverter.fromPoint(settings.slicerText.textSize));
                    });
                }, VerticalSlicerRenderer.prototype.onUpdateSelection = function(rowSelection, interactivityService) {
                    var settings = this.settings, data = this.data;
                    if (data && settings) {
                        var domHelper = this.domHelper;
                        domHelper.styleSlicerHeader(this.header, settings, data.categorySourceName);
                        var headerText = this.header.select(visuals.SlicerUtil.Selectors.TitleHeader.selector);
                        headerText.attr("title", data.categorySourceName);
                        var labelText = rowSelection.selectAll(visuals.SlicerUtil.Selectors.LabelText.selector);
                        labelText.text(function(d) {
                            return d.value;
                        }).attr("title", function(d) {
                            return d.tooltip;
                        }), domHelper.setSlicerTextStyle(labelText, settings);
                        var labelImage = rowSelection.selectAll(visuals.SlicerUtil.Selectors.LabelImage.selector);
                        labelImage.empty() || labelImage.attr("src", function(d) {
                            return d.value;
                        });
                        var countText = rowSelection.selectAll(visuals.SlicerUtil.Selectors.CountText.selector);
                        if (countText.empty() || (countText.text(function(d) {
                            return d.count;
                        }), domHelper.setSlicerTextStyle(countText, settings)), interactivityService && this.body) {
                            var body = this.body.attr("width", this.currentViewport.width), slicerItemContainers = body.selectAll(Selectors.ItemContainer.selector), slicerItemLabels = body.selectAll(visuals.SlicerUtil.Selectors.LabelText.selector), slicerItemInputs = body.selectAll(Selectors.Input.selector), slicerClear = this.header.select(visuals.SlicerUtil.Selectors.Clear.selector), searchInput = this.header.select("input");
                            if (!searchInput.empty()) {
                                var element = searchInput.node(), exisingSearchKey = element && element.value;
                                (_.isEmpty(exisingSearchKey) || _.isEmpty(data.searchKey)) && searchInput.property("value", data.searchKey);
                            }
                            var behaviorOptions = {
                                dataPoints: data.slicerDataPoints,
                                slicerContainer: this.container,
                                itemContainers: slicerItemContainers,
                                itemLabels: slicerItemLabels,
                                itemInputs: slicerItemInputs,
                                clear: slicerClear,
                                interactivityService: interactivityService,
                                settings: data.slicerSettings,
                                searchInput: searchInput,
                                slicerValueHandler: this
                            }, orientationBehaviorOptions = {
                                behaviorOptions: behaviorOptions,
                                orientation: 0
                            };
                            interactivityService.bind(data.slicerDataPoints, this.behavior, orientationBehaviorOptions, {
                                overrideSelectionFromData: !0,
                                hasSelectionOverride: data.hasSelectionOverride,
                                slicerValueHandler: this
                            }), visuals.SlicerWebBehavior.styleSlicerItems(rowSelection.select(Selectors.Input.selector), data.hasSelectionOverride, interactivityService.isSelectionModeInverted());
                        } else visuals.SlicerWebBehavior.styleSlicerItems(rowSelection.select(Selectors.Input.selector), !1, !1);
                    }
                }, VerticalSlicerRenderer;
            }();
            visuals.VerticalSlicerRenderer = VerticalSlicerRenderer;
            var Selectors;
            !function(Selectors) {
                var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
                Selectors.Container = createClassAndSelector("slicerContainer"), Selectors.ItemContainer = createClassAndSelector("slicerItemContainer"), 
                Selectors.Input = createClassAndSelector("slicerCheckbox"), Selectors.Checkbox = createClassAndSelector("checkbox");
            }(Selectors || (Selectors = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var PixelConverter = jsCommon.PixelConverter, ItemWidthSampleSize = 50, MinTextWidth = 80, LoadMoreDataThreshold = .8, DefaultStyleProperties = {
                labelText: {
                    marginRight: 2,
                    paddingLeft: 8,
                    paddingRight: 8
                }
            }, HorizontalSlicerRenderer = function() {
                function HorizontalSlicerRenderer(options) {
                    this.textProperties = {
                        fontFamily: visuals.Font.Family.regular.css,
                        fontSize: "14px"
                    }, options && (this.behavior = options.behavior), this.domHelper = options.domHelper, 
                    this.dataStartIndex = 0;
                }
                return HorizontalSlicerRenderer.prototype.getDefaultValue = function() {
                    return this.data && this.data.defaultValue ? this.data.defaultValue.value : void 0;
                }, HorizontalSlicerRenderer.prototype.getIdentityFields = function() {
                    return visuals.SlicerUtil.DefaultValueHandler.getIdentityFields(this.dataView);
                }, HorizontalSlicerRenderer.prototype.getUpdatedSelfFilter = function(searchKey) {
                    var metadata = this.dataView && this.dataView.metadata;
                    if (this.data.searchKey !== searchKey) return visuals.SlicerUtil.getUpdatedSelfFilter(searchKey, metadata);
                }, HorizontalSlicerRenderer.prototype.init = function(slicerInitOptions) {
                    this.element = slicerInitOptions.visualInitOptions.element, this.currentViewport = slicerInitOptions.visualInitOptions.viewport;
                    var hostServices = this.hostServices = slicerInitOptions.visualInitOptions.host;
                    this.behavior && (this.interactivityService = visuals.createInteractivityService(hostServices)), 
                    this.loadMoreData = function() {
                        return slicerInitOptions.loadMoreData();
                    };
                    var containerDiv = document.createElement("div");
                    containerDiv.className = Selectors.container["class"];
                    var container = this.container = d3.select(containerDiv), header = this.domHelper.createSlicerHeader(this.hostServices);
                    containerDiv.appendChild(header), this.header = d3.select(header);
                    var body = this.body = container.append("div").classed(visuals.SlicerUtil.Selectors.Body["class"] + " " + Selectors.FlexDisplay["class"], !0);
                    return this.leftNavigationArrow = body.append("button").classed(Selectors.NavigationArrow["class"] + " " + Selectors.LeftNavigationArrow["class"], !0), 
                    this.itemsContainer = body.append("div").classed(Selectors.ItemsContainer["class"] + " " + Selectors.FlexDisplay["class"], !0), 
                    this.rightNavigationArrow = body.append("button").classed(Selectors.NavigationArrow["class"] + " " + Selectors.RightNavigationArrow["class"], !0), 
                    this.element.get(0).appendChild(containerDiv), this.bindNavigationEvents(), this.interactivityService;
                }, HorizontalSlicerRenderer.prototype.render = function(options) {
                    var data = options.data, dataView = options.dataView;
                    if (!dataView || !data) return void this.itemsContainer.selectAll("*").remove();
                    this.data = data, this.dataView = dataView;
                    var resized = this.currentViewport && options.viewport && (this.currentViewport.height !== options.viewport.height || this.currentViewport.width !== options.viewport.width);
                    this.isMaxWidthCalculated() && resized || (this.calculateAndSetMaxItemWidth(), this.calculateAndSetTotalItemWidth()), 
                    this.currentViewport = options.viewport, this.updateStyle();
                    var availableWidthForItemsContainer = this.element.find(Selectors.ItemsContainer.selector).width();
                    this.itemsToDisplay = this.getNumberOfItemsToDisplay(availableWidthForItemsContainer), 
                    0 !== this.itemsToDisplay && this.renderCore();
                }, HorizontalSlicerRenderer.prototype.renderCore = function() {
                    var data = this.data;
                    if (data && data.slicerDataPoints) {
                        this.normalizePosition(data.slicerDataPoints);
                        var itemsToDisplay = this.itemsToDisplay, dataStartIndex = this.dataStartIndex;
                        this.container.classed(Selectors.CanScrollRight["class"], dataStartIndex + this.itemsToDisplay <= data.slicerDataPoints.length - 1), 
                        this.container.classed(Selectors.CanScrollLeft["class"], dataStartIndex > 0), this.renderItems(data.slicerSettings), 
                        this.bindInteractivityService(), dataStartIndex + itemsToDisplay >= data.slicerDataPoints.length * LoadMoreDataThreshold && this.loadMoreData();
                    }
                }, HorizontalSlicerRenderer.prototype.updateStyle = function() {
                    var viewport = this.currentViewport, data = this.data, defaultSettings = data.slicerSettings, domHelper = this.domHelper;
                    this.container.classed(Selectors.MultiSelectEnabled["class"], !defaultSettings.selection.singleSelect).style({
                        width: PixelConverter.toString(viewport.width),
                        height: PixelConverter.toString(viewport.height)
                    }), domHelper.styleSlicerHeader(this.header, defaultSettings, data.categorySourceName);
                    var headerTextProperties = domHelper.getHeaderTextProperties(defaultSettings);
                    this.header.attr("title", data.categorySourceName);
                    var bodyViewport = this.bodyViewport = domHelper.getSlicerBodyViewport(viewport, defaultSettings, headerTextProperties);
                    this.body.style({
                        height: PixelConverter.toString(bodyViewport.height),
                        width: PixelConverter.toString(bodyViewport.width)
                    });
                }, HorizontalSlicerRenderer.prototype.renderItems = function(defaultSettings) {
                    var _this = this, itemsToDisplay = this.itemsToDisplay, dataStartIndex = this.dataStartIndex, materializedDataPoints = this.data.slicerDataPoints.slice(dataStartIndex, dataStartIndex + itemsToDisplay), items = this.itemsContainer.selectAll(visuals.SlicerUtil.Selectors.LabelText.selector).data(materializedDataPoints, function(d) {
                        return _.indexOf(_this.data.slicerDataPoints, d);
                    });
                    items.enter().append("div").classed(visuals.SlicerUtil.Selectors.LabelText["class"] + " " + Selectors.FlexDisplay["class"], !0), 
                    items.order(), items.style({
                        "font-family": this.textProperties.fontFamily,
                        "padding-left": PixelConverter.toString(DefaultStyleProperties.labelText.paddingLeft),
                        "padding-right": PixelConverter.toString(DefaultStyleProperties.labelText.paddingRight),
                        "margin-right": function(d, i) {
                            return _this.isLastRowItem(i, itemsToDisplay) ? "0px" : PixelConverter.toString(DefaultStyleProperties.labelText.marginRight);
                        }
                    }), this.domHelper.setSlicerTextStyle(items, defaultSettings), items.exit().remove(), 
                    window.setTimeout(function() {
                        items.attr("title", function(d) {
                            return d.tooltip;
                        }).text(function(d) {
                            return d.value;
                        });
                        var labels = _this.element.find(visuals.SlicerUtil.Selectors.LabelText.selector), item = labels.first(), itemWidth = item.width(), itemHeight = item.height();
                        labels.each(function(i, element) {
                            powerbi.TextMeasurementService.wordBreakOverflowingText(element, itemWidth, itemHeight);
                        });
                    });
                }, HorizontalSlicerRenderer.prototype.bindInteractivityService = function() {
                    if (this.interactivityService && this.body) {
                        var body = this.body, itemsContainer = body.selectAll(Selectors.ItemsContainer.selector), itemLabels = body.selectAll(visuals.SlicerUtil.Selectors.LabelText.selector), clear = this.header.select(visuals.SlicerUtil.Selectors.Clear.selector), data_1 = this.data, searchInput = this.header.select("input");
                        if (!searchInput.empty()) {
                            var element = searchInput.node(), existingSearchKey = element.value;
                            (_.isEmpty(existingSearchKey) || _.isEmpty(data_1.searchKey)) && searchInput.property("value", data_1.searchKey);
                        }
                        var behaviorOptions = {
                            dataPoints: data_1.slicerDataPoints,
                            slicerContainer: this.container,
                            itemsContainer: itemsContainer,
                            itemLabels: itemLabels,
                            clear: clear,
                            interactivityService: this.interactivityService,
                            settings: data_1.slicerSettings,
                            slicerValueHandler: this,
                            searchInput: searchInput
                        }, orientationBehaviorOptions = {
                            behaviorOptions: behaviorOptions,
                            orientation: 1
                        };
                        this.interactivityService.bind(data_1.slicerDataPoints, this.behavior, orientationBehaviorOptions, {
                            overrideSelectionFromData: !0,
                            hasSelectionOverride: data_1.hasSelectionOverride
                        }), visuals.SlicerWebBehavior.styleSlicerItems(this.itemsContainer.selectAll(visuals.SlicerUtil.Selectors.LabelText.selector), this.interactivityService.hasSelection(), this.interactivityService.isSelectionModeInverted());
                    } else visuals.SlicerWebBehavior.styleSlicerItems(this.itemsContainer.selectAll(visuals.SlicerUtil.Selectors.LabelText.selector), !1, !1);
                }, HorizontalSlicerRenderer.prototype.normalizePosition = function(points) {
                    var dataStartIndex = this.dataStartIndex;
                    dataStartIndex = Math.min(dataStartIndex, points.length - 1), this.dataStartIndex = Math.max(dataStartIndex, 0);
                }, HorizontalSlicerRenderer.prototype.bindNavigationEvents = function() {
                    this.registerMouseWheelScrollEvents(), this.registerMouseClickEvents();
                }, HorizontalSlicerRenderer.prototype.registerMouseClickEvents = function() {
                    var _this = this, rightNavigationArrow = this.container.selectAll(Selectors.RightNavigationArrow.selector), leftNavigationArrow = this.container.selectAll(Selectors.LeftNavigationArrow.selector);
                    rightNavigationArrow.on("click", function() {
                        _this.scrollRight();
                    }), leftNavigationArrow.on("click", function() {
                        _this.scrollLeft();
                    });
                }, HorizontalSlicerRenderer.prototype.registerMouseWheelScrollEvents = function() {
                    var _this = this, scrollableElement = this.body.node();
                    scrollableElement.addEventListener("mousewheel", function(e) {
                        _this.onMouseWheel(e.wheelDelta);
                    }), scrollableElement.addEventListener("DOMMouseScroll", function(e) {
                        _this.onMouseWheel(e.detail);
                    });
                }, HorizontalSlicerRenderer.prototype.onMouseWheel = function(wheelDelta) {
                    0 > wheelDelta ? this.scrollRight() : wheelDelta > 0 && this.scrollLeft();
                }, HorizontalSlicerRenderer.prototype.scrollRight = function() {
                    var itemsToDisplay = this.itemsToDisplay, startIndex = this.dataStartIndex, dataPointsLength = this.data.slicerDataPoints.length, lastItemIndex = dataPointsLength - 1;
                    itemsToDisplay + startIndex > lastItemIndex || (startIndex += 1 === itemsToDisplay ? itemsToDisplay : itemsToDisplay - 1, 
                    itemsToDisplay + startIndex > lastItemIndex && (startIndex = lastItemIndex - itemsToDisplay + 1), 
                    this.dataStartIndex = startIndex, this.renderCore());
                }, HorizontalSlicerRenderer.prototype.scrollLeft = function() {
                    var itemsToDisplay = this.itemsToDisplay, startIndex = this.dataStartIndex, firstItemIndex = 0;
                    0 !== startIndex && (1 === itemsToDisplay && (startIndex -= itemsToDisplay), startIndex = firstItemIndex > startIndex - itemsToDisplay ? firstItemIndex : startIndex - itemsToDisplay + 1, 
                    this.dataStartIndex = startIndex, this.renderCore());
                }, HorizontalSlicerRenderer.prototype.isLastRowItem = function(fieldIndex, columnsToDisplay) {
                    return fieldIndex === columnsToDisplay - 1;
                }, HorizontalSlicerRenderer.prototype.getScaledTextWidth = function(textSize) {
                    return textSize / jsCommon.TextSizeDefaults.TextSizeMin * MinTextWidth;
                }, HorizontalSlicerRenderer.prototype.isMaxWidthCalculated = function() {
                    return void 0 !== this.maxItemWidth;
                }, HorizontalSlicerRenderer.prototype.calculateAndSetMaxItemWidth = function() {
                    var dataPointsLength = this.getDataPointsCount(), maxItemWidth = 0;
                    if (0 === dataPointsLength) return void (this.maxItemWidth = maxItemWidth);
                    var data = this.data, dataPoints = data.slicerDataPoints, sampleSize = Math.min(dataPointsLength, ItemWidthSampleSize), properties = jQuery.extend(!0, {}, this.textProperties), textSize = data.slicerSettings.slicerText.textSize;
                    properties.fontSize = PixelConverter.fromPoint(textSize);
                    for (var getMaxWordWidth = jsCommon.WordBreaker.getMaxWordWidth, i = 0; sampleSize > i; i++) {
                        var itemText = dataPoints[i].value;
                        properties.text = itemText, maxItemWidth = Math.max(maxItemWidth, getMaxWordWidth(itemText, powerbi.TextMeasurementService.measureSvgTextWidth, properties));
                    }
                    this.maxItemWidth = Math.min(maxItemWidth, this.getScaledTextWidth(textSize));
                }, HorizontalSlicerRenderer.prototype.calculateAndSetTotalItemWidth = function() {
                    var data = this.data, itemPadding = DefaultStyleProperties.labelText.paddingLeft + DefaultStyleProperties.labelText.paddingRight + DefaultStyleProperties.labelText.marginRight, borderWidth = this.domHelper.getRowsOutlineWidth(data.slicerSettings.slicerText.outline, data.slicerSettings.general.outlineWeight);
                    this.totalItemWidth = this.maxItemWidth + itemPadding + borderWidth;
                }, HorizontalSlicerRenderer.prototype.getNumberOfItemsToDisplay = function(widthAvailable) {
                    var totalItemWidth = this.totalItemWidth;
                    if (0 === totalItemWidth) return 0;
                    var dataPointsLength = this.getDataPointsCount(), numberOfItems = Math.min(dataPointsLength, Math.round(widthAvailable / totalItemWidth));
                    return Math.max(numberOfItems, 1);
                }, HorizontalSlicerRenderer.prototype.getDataPointsCount = function() {
                    return _.size(this.data.slicerDataPoints);
                }, HorizontalSlicerRenderer;
            }();
            visuals.HorizontalSlicerRenderer = HorizontalSlicerRenderer;
            var Selectors;
            !function(Selectors) {
                var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
                Selectors.container = createClassAndSelector("horizontalSlicerContainer"), Selectors.ItemsContainer = createClassAndSelector("slicerItemsContainer"), 
                Selectors.NavigationArrow = createClassAndSelector("navigationArrow"), Selectors.LeftNavigationArrow = createClassAndSelector("left"), 
                Selectors.RightNavigationArrow = createClassAndSelector("right"), Selectors.MultiSelectEnabled = createClassAndSelector("isMultiSelectEnabled"), 
                Selectors.FlexDisplay = createClassAndSelector("flexDisplay"), Selectors.CanScrollRight = createClassAndSelector("canScrollRight"), 
                Selectors.CanScrollLeft = createClassAndSelector("canScrollLeft");
            }(Selectors || (Selectors = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var DisplayNameKeys = visuals.SlicerUtil.DisplayNameKeys, DOMHelper = visuals.SlicerUtil.DOMHelper, SettingsHelper = visuals.SlicerUtil.SettingsHelper, Slicer = function() {
                function Slicer(options) {
                    options && (this.behavior = options.behavior), this.domHelper = new DOMHelper();
                }
                return Slicer.DefaultStyleProperties = function() {
                    return {
                        general: {
                            outlineColor: "#808080",
                            outlineWeight: 1,
                            orientation: 0
                        },
                        header: {
                            borderBottomWidth: 1,
                            show: !0,
                            outline: visuals.outline.bottomOnly,
                            fontColor: "#000000",
                            textSize: 10
                        },
                        slicerText: {
                            color: "#666666",
                            outline: visuals.outline.none,
                            textSize: 10
                        },
                        selection: {
                            selectAllCheckboxEnabled: !1,
                            singleSelect: !0
                        },
                        search: {
                            enabled: !1
                        }
                    };
                }, Slicer.prototype.init = function(options) {
                    this.initOptions = options, this.element = options.element, this.currentViewport = options.viewport, 
                    this.hostServices = options.host;
                    var settings = this.settings = Slicer.DefaultStyleProperties();
                    this.slicerOrientation = settings.general.orientation, this.waitingForData = !1, 
                    this.initializeSlicerRenderer(this.slicerOrientation);
                }, Slicer.prototype.onDataChanged = function(options) {
                    var dataViews = options.dataViews;
                    if (!_.isEmpty(dataViews)) {
                        var existingDataView = this.dataView;
                        this.dataView = dataViews[0];
                        var resetScrollbarPosition = options.operationKind !== powerbi.VisualDataChangeOperationKind.Append && !powerbi.DataViewAnalysis.hasSameCategoryIdentity(existingDataView, this.dataView);
                        this.render(resetScrollbarPosition, !0);
                    }
                }, Slicer.prototype.onResizing = function(finalViewport) {
                    this.currentViewport = finalViewport, this.render(!1);
                }, Slicer.prototype.enumerateObjectInstances = function(options) {
                    return ObjectEnumerator.enumerateObjectInstances(options, this.slicerData, this.settings, this.dataView);
                }, Slicer.prototype.loadMoreData = function() {
                    var dataView = this.dataView;
                    if (dataView) {
                        var dataViewMetadata = dataView.metadata;
                        !this.waitingForData && dataViewMetadata && dataViewMetadata.segment && (this.hostServices.loadMoreData(), 
                        this.waitingForData = !0);
                    }
                }, Slicer.prototype.onClearSelection = function() {
                    this.interactivityService && (this.interactivityService.clearSelection(), this.render(!1));
                }, Slicer.prototype.render = function(resetScrollbarPosition, stopWaitingForData) {
                    var localizedSelectAllText = this.hostServices.getLocalizedString(DisplayNameKeys.SelectAll);
                    if (this.slicerData = visuals.DataConversion.convert(this.dataView, localizedSelectAllText, this.interactivityService, this.hostServices), 
                    this.slicerData) {
                        this.slicerData.slicerSettings.general.outlineWeight = Math.max(this.slicerData.slicerSettings.general.outlineWeight, 0), 
                        this.settings = this.slicerData.slicerSettings;
                        var slicerOrientation_1 = SettingsHelper.areSettingsDefined(this.slicerData) && this.slicerData.slicerSettings.general && this.slicerData.slicerSettings.general.orientation ? this.slicerData.slicerSettings.general.orientation : Slicer.DefaultStyleProperties().general.orientation, orientationHasChanged = this.orientationHasChanged(slicerOrientation_1);
                        orientationHasChanged && (this.slicerOrientation = slicerOrientation_1, this.element.empty(), 
                        this.initializeSlicerRenderer(slicerOrientation_1));
                    }
                    this.slicerRenderer.render({
                        dataView: this.dataView,
                        data: this.slicerData,
                        viewport: this.currentViewport,
                        resetScrollbarPosition: resetScrollbarPosition
                    }), stopWaitingForData && (this.waitingForData = !1);
                }, Slicer.prototype.orientationHasChanged = function(slicerOrientation) {
                    return this.slicerOrientation !== slicerOrientation;
                }, Slicer.prototype.initializeSlicerRenderer = function(slicerOrientation) {
                    switch (slicerOrientation) {
                      case 1:
                        this.initializeHorizontalSlicer();
                        break;

                      case 0:
                        this.initializeVerticalSlicer();
                    }
                }, Slicer.prototype.initializeVerticalSlicer = function() {
                    var verticalSlicerRenderer = this.slicerRenderer = new visuals.VerticalSlicerRenderer({
                        domHelper: this.domHelper,
                        behavior: this.behavior
                    }), options = this.createInitOptions();
                    this.interactivityService = verticalSlicerRenderer.init(options);
                }, Slicer.prototype.initializeHorizontalSlicer = function() {
                    var horizontalSlicerRenderer = this.slicerRenderer = new visuals.HorizontalSlicerRenderer({
                        domHelper: this.domHelper,
                        behavior: this.behavior
                    }), options = this.createInitOptions();
                    this.interactivityService = horizontalSlicerRenderer.init(options);
                }, Slicer.prototype.createInitOptions = function() {
                    var _this = this;
                    return {
                        visualInitOptions: this.initOptions,
                        loadMoreData: function() {
                            return _this.loadMoreData();
                        }
                    };
                }, Slicer;
            }();
            visuals.Slicer = Slicer;
            var ObjectEnumerator;
            !function(ObjectEnumerator) {
                function enumerateObjectInstances(options, data, settings, dataView) {
                    if (data) switch (options.objectName) {
                      case "items":
                        return enumerateItems(data, settings);

                      case "header":
                        return enumerateHeader(data, settings);

                      case "general":
                        return enumerateGeneral(data, settings);

                      case "selection":
                        if (shouldShowSelectionOption(dataView)) return enumerateSelection(data, settings);
                    }
                }
                function shouldShowSelectionOption(dataView) {
                    return !(dataView && dataView.metadata && dataView.metadata.columns && _.some(dataView.metadata.columns, function(column) {
                        return column.discourageAggregationAcrossGroups;
                    }));
                }
                function enumerateSelection(data, settings) {
                    var slicerSettings = settings, areSelectionSettingsDefined = SettingsHelper.areSettingsDefined(data) && data.slicerSettings.selection, selectAllCheckboxEnabled = areSelectionSettingsDefined && data.slicerSettings.selection.selectAllCheckboxEnabled ? data.slicerSettings.selection.selectAllCheckboxEnabled : slicerSettings.selection.selectAllCheckboxEnabled, singleSelect = data && data.slicerSettings && data.slicerSettings.selection && void 0 !== data.slicerSettings.selection.singleSelect ? data.slicerSettings.selection.singleSelect : slicerSettings.selection.singleSelect;
                    return [ {
                        selector: null,
                        objectName: "selection",
                        properties: {
                            selectAllCheckboxEnabled: selectAllCheckboxEnabled,
                            singleSelect: singleSelect
                        }
                    } ];
                }
                function enumerateHeader(data, settings) {
                    var slicerSettings = settings, areHeaderSettingsDefined = SettingsHelper.areSettingsDefined(data) && data.slicerSettings.header, fontColor = areHeaderSettingsDefined && data.slicerSettings.header.fontColor ? data.slicerSettings.header.fontColor : slicerSettings.header.fontColor, background = areHeaderSettingsDefined && data.slicerSettings.header.background ? data.slicerSettings.header.background : slicerSettings.header.background;
                    return [ {
                        selector: null,
                        objectName: "header",
                        properties: {
                            show: slicerSettings.header.show,
                            fontColor: fontColor,
                            background: background,
                            outline: slicerSettings.header.outline,
                            textSize: slicerSettings.header.textSize
                        }
                    } ];
                }
                function enumerateItems(data, settings) {
                    var slicerSettings = settings, areTextSettingsDefined = SettingsHelper.areSettingsDefined(data) && data.slicerSettings.slicerText, fontColor = areTextSettingsDefined && data.slicerSettings.slicerText.color ? data.slicerSettings.slicerText.color : slicerSettings.slicerText.color, background = areTextSettingsDefined && data.slicerSettings.slicerText.background ? data.slicerSettings.slicerText.background : slicerSettings.slicerText.background;
                    return [ {
                        selector: null,
                        objectName: "items",
                        properties: {
                            fontColor: fontColor,
                            background: background,
                            outline: slicerSettings.slicerText.outline,
                            textSize: slicerSettings.slicerText.textSize
                        }
                    } ];
                }
                function enumerateGeneral(data, settings) {
                    var slicerSettings = settings, areGeneralSettingsDefined = SettingsHelper.areSettingsDefined(data) && null != data.slicerSettings.general, outlineColor = areGeneralSettingsDefined && data.slicerSettings.general.outlineColor ? data.slicerSettings.general.outlineColor : slicerSettings.general.outlineColor, outlineWeight = areGeneralSettingsDefined && data.slicerSettings.general.outlineWeight ? data.slicerSettings.general.outlineWeight : slicerSettings.general.outlineWeight, orientation = areGeneralSettingsDefined && null != data.slicerSettings.general.orientation ? data.slicerSettings.general.orientation : slicerSettings.general.orientation;
                    return [ {
                        selector: null,
                        objectName: "general",
                        properties: {
                            outlineColor: outlineColor,
                            outlineWeight: outlineWeight,
                            orientation: orientation
                        }
                    } ];
                }
                ObjectEnumerator.enumerateObjectInstances = enumerateObjectInstances;
            }(ObjectEnumerator || (ObjectEnumerator = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var TablixUtils = visuals.controls.internal.TablixUtils, TablixObjects = visuals.controls.internal.TablixObjects, EdgeSettings = TablixUtils.EdgeSettings, EdgeType = TablixUtils.EdgeType, TableHierarchyNavigator = function() {
                function TableHierarchyNavigator(tableDataView, isDataComplete, formatter) {
                    this.tableDataView = tableDataView, this.isDataComplete = isDataComplete, this.formatter = formatter;
                }
                return TableHierarchyNavigator.prototype.getColumnHierarchyDepth = function() {
                    return 1;
                }, TableHierarchyNavigator.prototype.getRowHierarchyDepth = function() {
                    return 1;
                }, TableHierarchyNavigator.prototype.getLeafCount = function(hierarchy) {
                    return hierarchy.length;
                }, TableHierarchyNavigator.prototype.getLeafAt = function(hierarchy, index) {
                    return hierarchy[index];
                }, TableHierarchyNavigator.prototype.getParent = function(item) {
                    return null;
                }, TableHierarchyNavigator.prototype.getIndex = function(item) {
                    return item ? this.isRow(item) ? item.index : this.getColumnIndex(item) : -1;
                }, TableHierarchyNavigator.prototype.isRow = function(item) {
                    if (!item) return !1;
                    var row = item;
                    return void 0 !== row.index && void 0 !== row.values;
                }, TableHierarchyNavigator.prototype.getColumnIndex = function(item) {
                    return TableHierarchyNavigator.getIndex(this.tableDataView.columns, item);
                }, TableHierarchyNavigator.prototype.isLeaf = function(item) {
                    return !0;
                }, TableHierarchyNavigator.prototype.isRowHierarchyLeaf = function(cornerItem) {
                    return !1;
                }, TableHierarchyNavigator.prototype.isColumnHierarchyLeaf = function(cornerItem) {
                    return !0;
                }, TableHierarchyNavigator.prototype.isFirstItem = function(item, items) {
                    return item === items[0];
                }, TableHierarchyNavigator.prototype.areAllParentsFirst = function(item, items) {
                    return this.isFirstItem(item, items);
                }, TableHierarchyNavigator.prototype.isLastItem = function(item, items) {
                    return (items === this.tableDataView.columns || this.isDataComplete) && item === _.last(items);
                }, TableHierarchyNavigator.prototype.areAllParentsLast = function(item, items) {
                    return this.isLastItem(item, items);
                }, TableHierarchyNavigator.prototype.getChildren = function(item) {
                    return null;
                }, TableHierarchyNavigator.prototype.getChildrenLevelDifference = function(item) {
                    return 1 / 0;
                }, TableHierarchyNavigator.prototype.getCount = function(items) {
                    return items.length;
                }, TableHierarchyNavigator.prototype.getAt = function(items, index) {
                    return items[index];
                }, TableHierarchyNavigator.prototype.getLevel = function(item) {
                    return 0;
                }, TableHierarchyNavigator.prototype.getIntersection = function(rowItem, columnItem) {
                    var value, isTotal = !1, position = new TablixUtils.CellPosition(), columnIndex = TableHierarchyNavigator.getIndex(this.tableDataView.columns, columnItem);
                    position.column.index = columnIndex, position.column.isFirst = 0 === columnIndex, 
                    position.column.isLast = columnIndex === this.tableDataView.columns.length - 1;
                    var totalRow = rowItem;
                    if (null != totalRow.totalCells) isTotal = !0, value = totalRow.totalCells[columnIndex]; else {
                        var row = rowItem, rowIndex = row.index;
                        position.row.index = rowIndex, position.row.isFirst = 0 === rowIndex, position.row.isLast = this.isDataComplete && rowIndex === this.tableDataView.rows.length - 1, 
                        value = row.values[columnIndex];
                    }
                    var cellItem = new TablixUtils.TablixVisualCell(value, isTotal, columnItem, this.formatter, !1);
                    cellItem.position = position;
                    var tableRow = rowItem;
                    if (tableRow && tableRow.values) {
                        var rowObjects = tableRow.values.objects;
                        if (rowObjects) {
                            var cellObject = rowObjects[columnIndex];
                            cellObject && (cellItem.backColor = TablixObjects.PropValuesBackColor.getValue(cellObject));
                        }
                    }
                    return cellItem;
                }, TableHierarchyNavigator.prototype.getCorner = function(rowLevel, columnLevel) {
                    return null;
                }, TableHierarchyNavigator.prototype.headerItemEquals = function(item1, item2) {
                    if (item1 === item2) return !0;
                    if (item1.displayName && item2.displayName) {
                        var column1 = item1, column2 = item2;
                        return powerbi.DataViewAnalysis.areMetadataColumnsEquivalent(column1, column2);
                    }
                    return this.isRow(item1) && this.isRow(item2) ? item1.index === item2.index : !1;
                }, TableHierarchyNavigator.prototype.bodyCellItemEquals = function(item1, item2) {
                    return item1.isMatch(item2);
                }, TableHierarchyNavigator.prototype.cornerCellItemEquals = function(item1, item2) {
                    return !0;
                }, TableHierarchyNavigator.prototype.update = function(table, isDataComplete) {
                    this.tableDataView = table, this.isDataComplete = isDataComplete;
                }, TableHierarchyNavigator.getIndex = function(items, item) {
                    for (var index = 0, len = items.length; len > index; index++) {
                        var arrayItem = items[index];
                        if (null != arrayItem.index && null != item.index && arrayItem.index === item.index) return index;
                        if (item === items[index]) return index;
                    }
                    return -1;
                }, TableHierarchyNavigator;
            }();
            visuals.TableHierarchyNavigator = TableHierarchyNavigator;
            var TableBinder = function() {
                function TableBinder(options, dataView) {
                    this.options = options, dataView && this.updateDataView(dataView);
                }
                return TableBinder.prototype.updateDataView = function(dataView) {
                    this.tableDataView = dataView, this.formattingProperties = dataView.formattingProperties, 
                    this.updateTextHeights(), this.hasImage() ? this.rowHeight = Math.max(this.textHeightValue, this.formattingProperties.grid.imageHeight) : this.rowHeight = this.textHeightValue;
                }, TableBinder.prototype.updateTextHeights = function() {
                    this.fontSizeHeader = jsCommon.PixelConverter.fromPointToPixel(this.formattingProperties.general.textSize), 
                    this.textPropsHeader = {
                        fontFamily: TablixUtils.FontFamilyHeader,
                        fontSize: jsCommon.PixelConverter.toString(this.fontSizeHeader)
                    }, this.textHeightHeader = Math.ceil(powerbi.TextMeasurementService.measureSvgTextHeight(this.textPropsHeader, "a")), 
                    this.fontSizeValue = jsCommon.PixelConverter.fromPointToPixel(this.formattingProperties.general.textSize), 
                    this.textPropsValue = {
                        fontFamily: TablixUtils.FontFamilyCell,
                        fontSize: jsCommon.PixelConverter.toString(this.fontSizeValue)
                    }, this.textHeightValue = Math.ceil(powerbi.TextMeasurementService.measureSvgTextHeight(this.textPropsValue, "a")), 
                    this.fontSizeTotal = jsCommon.PixelConverter.fromPointToPixel(this.formattingProperties.general.textSize), 
                    this.textPropsTotal = {
                        fontFamily: TablixUtils.FontFamilyTotal,
                        fontSize: jsCommon.PixelConverter.toString(this.fontSizeTotal)
                    }, this.textHeightTotal = Math.ceil(powerbi.TextMeasurementService.measureSvgTextHeight(this.textPropsTotal, "a"));
                }, TableBinder.prototype.hasImage = function() {
                    return _.any(this.tableDataView.columns, function(col) {
                        return visuals.converterHelper.isImageUrlColumn(col);
                    });
                }, TableBinder.prototype.onStartRenderingSession = function() {}, TableBinder.prototype.onEndRenderingSession = function() {}, 
                TableBinder.prototype.bindRowHeader = function(item, cell) {
                    item.totalCells ? cell.contentHeight = this.textHeightTotal : cell.contentHeight = this.rowHeight, 
                    TablixUtils.clearCellStyle(cell), this.options.onBindRowHeader && this.options.onBindRowHeader(item);
                }, TableBinder.prototype.unbindRowHeader = function(item, cell) {}, TableBinder.prototype.bindColumnHeader = function(item, cell) {
                    var _this = this;
                    cell.extension.disableDragResize(), TablixUtils.resetCellCssClass(cell), TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixHeader), 
                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixColumnHeaderLeaf);
                    var cellStyle = new TablixUtils.CellStyle();
                    cellStyle.fontFamily = TablixUtils.FontFamilyHeader, cellStyle.fontColor = TablixUtils.FontColorHeaders, 
                    cellStyle.borders.bottom = new EdgeSettings(TablixObjects.PropGridOutlineWeight.defaultValue, TablixObjects.PropGridOutlineColor.defaultValue), 
                    cell.contentHeight = this.textHeightHeader;
                    var element = cell.extension.contentHost;
                    if (this.sortIconsEnabled() && (element = TablixUtils.addSortIconToColumnHeader(item.sort, element), 
                    item.sort && (cell.contentWidth = this.fontSizeHeader + TablixUtils.SortIconPadding)), 
                    TablixUtils.setCellTextAndTooltip(item.displayName, element, cell.extension.contentHost), 
                    cell.contentWidth += powerbi.TextMeasurementService.measureSvgTextWidth(this.textPropsHeader, item.displayName), 
                    cell.contentWidth = Math.ceil(cell.contentWidth), this.options.onColumnHeaderClick) {
                        var handler = function(e) {
                            if (TablixUtils.isValidSortClick(e)) {
                                var sortDirection = TablixUtils.reverseSort(item.sort);
                                _this.options.onColumnHeaderClick(item.queryName ? item.queryName : item.displayName, sortDirection);
                            }
                        };
                        cell.extension.registerClickHandler(handler);
                    }
                    this.setColumnHeaderStyle(cell, cellStyle), cell.applyStyle(cellStyle);
                }, TableBinder.prototype.setColumnHeaderStyle = function(cell, style) {
                    var propsGrid = this.formattingProperties.grid, props = this.formattingProperties.columnHeaders, propsTotal = this.formattingProperties.total, propsValues = this.formattingProperties.values;
                    style.borders.top = new EdgeSettings(), style.borders.top.applyParams(visuals.outline.showTop(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline), 
                    style.borders.bottom = new EdgeSettings(), style.borders.bottom.applyParams(visuals.outline.showBottom(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline), 
                    style.borders.left = new EdgeSettings(), cell.position.column.isFirst && (style.borders.left.applyParams(visuals.outline.showLeft(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline), 
                    visuals.outline.showLeft(props.outline) || !visuals.outline.showLeft(propsTotal.outline) && !visuals.outline.showLeft(propsValues.outline) || (style.paddings.left += propsGrid.outlineWeight)), 
                    style.borders.right = new EdgeSettings(), cell.position.column.isLast ? (style.borders.right.applyParams(visuals.outline.showRight(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline), 
                    visuals.outline.showRight(props.outline) || !visuals.outline.showRight(propsTotal.outline) && !visuals.outline.showRight(propsValues.outline) || (style.paddings.right += propsGrid.outlineWeight)) : style.borders.right.applyParams(propsGrid.gridVertical, propsGrid.gridVerticalWeight, propsGrid.gridVerticalColor, EdgeType.Gridline), 
                    style.fontColor = props.fontColor, style.backColor = props.backColor, style.paddings.top = style.paddings.bottom = propsGrid.rowPadding;
                }, TableBinder.prototype.unbindColumnHeader = function(item, cell) {
                    TablixUtils.clearCellStyle(cell), TablixUtils.clearCellTextAndTooltip(cell), this.sortIconsEnabled() && TablixUtils.removeSortIcons(cell), 
                    this.options.onColumnHeaderClick && cell.extension.unregisterClickHandler();
                }, TableBinder.prototype.bindBodyCell = function(item, cell) {
                    TablixUtils.resetCellCssClass(cell), this.setBodyContent(item, cell), cell.contentWidth = Math.ceil(cell.contentWidth);
                    var cellStyle = new TablixUtils.CellStyle();
                    item.isTotal ? (TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixValueTotal), 
                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTableFooter), cellStyle.fontFamily = TablixUtils.FontFamilyTotal, 
                    cellStyle.borders.top = new EdgeSettings(TablixObjects.PropGridOutlineWeight.defaultValue, TablixObjects.PropGridOutlineColor.defaultValue)) : item.position.row.isLast ? TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTableBodyCellBottom) : (TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTableBodyCell), 
                    cellStyle.borders.bottom = new EdgeSettings(TablixObjects.PropGridHorizontalWeight.defaultValue, TablixObjects.PropGridHorizontalColor.defaultValue)), 
                    item.isNumeric && TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixValueNumeric), 
                    item.isTotal ? this.setFooterStyle(cell, cellStyle) : this.setBodyStyle(item, cell, cellStyle), 
                    cell.applyStyle(cellStyle);
                }, TableBinder.prototype.setBodyContent = function(item, cell) {
                    var element = cell.extension.contentHost, imgHeight = this.formattingProperties.grid.imageHeight, text = item.textContent;
                    if (item.isTotal ? cell.contentHeight = this.textHeightTotal : item.isImage ? cell.contentHeight = imgHeight : cell.contentHeight = this.textHeightValue, 
                    item.isUrl && item.isValidUrl) {
                        var showUrlIcon = this.formattingProperties.values.urlIcon;
                        return TablixUtils.appendATagToBodyCell(text, element, showUrlIcon), void (showUrlIcon ? cell.contentWidth = this.fontSizeValue : cell.contentWidth = powerbi.TextMeasurementService.measureSvgTextWidth(this.textPropsValue, text));
                    }
                    if (item.isImage && item.isValidUrl) return TablixUtils.appendImgTagToBodyCell(text, element, imgHeight), 
                    void (cell.contentWidth = imgHeight * TablixUtils.ImageDefaultAspectRatio);
                    var kpi = item.kpiContent;
                    return kpi ? ($(element).append(kpi), void (cell.contentWidth = this.fontSizeValue)) : text ? (TablixUtils.setCellTextAndTooltip(text, element), 
                    void (item.isTotal ? cell.contentWidth = powerbi.TextMeasurementService.measureSvgTextWidth(this.textPropsTotal, text) : cell.contentWidth = powerbi.TextMeasurementService.measureSvgTextWidth(this.textPropsValue, text))) : (TablixUtils.setCellTextAndTooltip(" ", element), 
                    void (cell.contentWidth = 0));
                }, TableBinder.prototype.setBodyStyle = function(item, cell, style) {
                    var propsGrid = this.formattingProperties.grid, props = this.formattingProperties.values, propsTotal = this.formattingProperties.total, propsColumns = this.formattingProperties.columnHeaders;
                    style.borders.top = new EdgeSettings(), cell.position.row.isFirst && style.borders.top.applyParams(visuals.outline.showTop(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline), 
                    style.borders.bottom = new EdgeSettings(), cell.position.row.isLast ? style.borders.bottom.applyParams(visuals.outline.showBottom(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline) : style.borders.bottom.applyParams(propsGrid.gridHorizontal, propsGrid.gridHorizontalWeight, propsGrid.gridHorizontalColor, EdgeType.Gridline), 
                    style.borders.left = new EdgeSettings(), cell.position.column.isFirst && (style.borders.left.applyParams(visuals.outline.showLeft(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline), 
                    visuals.outline.showLeft(props.outline) || !visuals.outline.showLeft(propsTotal.outline) && !visuals.outline.showLeft(propsColumns.outline) || (style.paddings.left += propsGrid.outlineWeight)), 
                    style.borders.right = new EdgeSettings(), cell.position.column.isLast ? (style.borders.right.applyParams(visuals.outline.showRight(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline), 
                    visuals.outline.showRight(props.outline) || !visuals.outline.showRight(propsTotal.outline) && !visuals.outline.showRight(propsColumns.outline) || (style.paddings.right += propsGrid.outlineWeight)) : style.borders.right.applyParams(propsGrid.gridVertical, propsGrid.gridVerticalWeight, propsGrid.gridVerticalColor, EdgeType.Gridline), 
                    style.fontColor = cell.position.row.index % 2 === 0 ? props.fontColorPrimary : props.fontColorSecondary, 
                    item.backColor ? style.backColor = item.backColor : style.backColor = cell.position.row.index % 2 === 0 ? props.backColorPrimary : props.backColorSecondary, 
                    style.paddings.top = style.paddings.bottom = propsGrid.rowPadding;
                }, TableBinder.prototype.setFooterStyle = function(cell, style) {
                    var props = this.formattingProperties.total, propsGrid = this.formattingProperties.grid, propsValues = this.formattingProperties.values, propsColumns = this.formattingProperties.columnHeaders;
                    style.borders.top = new EdgeSettings(), style.borders.top.applyParams(visuals.outline.showTop(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline), 
                    style.borders.bottom = new EdgeSettings(), style.borders.bottom.applyParams(visuals.outline.showBottom(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline), 
                    style.borders.left = new EdgeSettings(), cell.position.column.isFirst && (style.borders.left.applyParams(visuals.outline.showLeft(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline), 
                    visuals.outline.showLeft(props.outline) || !visuals.outline.showLeft(propsValues.outline) && !visuals.outline.showLeft(propsColumns.outline) || (style.paddings.left += propsGrid.outlineWeight)), 
                    style.borders.right = new EdgeSettings(), cell.position.column.isLast ? (style.borders.right.applyParams(visuals.outline.showRight(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline), 
                    visuals.outline.showRight(props.outline) || !visuals.outline.showRight(propsValues.outline) && !visuals.outline.showRight(propsColumns.outline) || (style.paddings.right += propsGrid.outlineWeight)) : style.borders.right.applyParams(propsGrid.gridVertical, propsGrid.gridVerticalWeight, propsGrid.gridVerticalColor, EdgeType.Gridline), 
                    style.fontColor = props.fontColor, style.backColor = props.backColor, style.paddings.top = style.paddings.bottom = propsGrid.rowPadding;
                }, TableBinder.prototype.unbindBodyCell = function(item, cell) {
                    TablixUtils.clearCellStyle(cell), TablixUtils.clearCellTextAndTooltip(cell);
                }, TableBinder.prototype.bindCornerCell = function(item, cell) {
                    cell.contentWidth = 0;
                }, TableBinder.prototype.unbindCornerCell = function(item, cell) {}, TableBinder.prototype.bindEmptySpaceHeaderCell = function(cell) {}, 
                TableBinder.prototype.unbindEmptySpaceHeaderCell = function(cell) {}, TableBinder.prototype.bindEmptySpaceFooterCell = function(cell) {}, 
                TableBinder.prototype.unbindEmptySpaceFooterCell = function(cell) {}, TableBinder.prototype.getHeaderLabel = function(item) {
                    return item ? item.displayName : "";
                }, TableBinder.prototype.getCellContent = function(item) {
                    return item;
                }, TableBinder.prototype.hasRowGroups = function() {
                    return !1;
                }, TableBinder.prototype.sortIconsEnabled = function() {
                    return 0 === this.options.layoutKind;
                }, TableBinder;
            }();
            visuals.TableBinder = TableBinder;
            var Table = function() {
                function Table(options) {
                    options && (this.isTouchEnabled = options.isTouchEnabled);
                }
                return Table.customizeQuery = function(options) {
                    var dataViewMapping = options.dataViewMappings[0];
                    if (dataViewMapping && dataViewMapping.table && dataViewMapping.metadata) {
                        var dataViewTableRows = dataViewMapping.table.rows, objects = dataViewMapping.metadata.objects;
                        dataViewTableRows["for"]["in"].subtotalType = TablixObjects.shouldShowTableTotals(objects) ? 1 : 0;
                    }
                }, Table.getSortableRoles = function() {
                    return [ "Values" ];
                }, Table.prototype.init = function(options) {
                    this.element = options.element, this.style = options.style, this.updateViewport(options.viewport), 
                    this.formatter = visuals.valueFormatter.formatVariantMeasureValue, this.isInteractive = options.interactivity && null != options.interactivity.selection, 
                    this.getLocalizedString = options.host.getLocalizedString, this.hostServices = options.host, 
                    this.persistingObjects = !1, this.waitingForData = !1, this.lastAllowHeaderResize = !0, 
                    this.waitingForSort = !1;
                }, Table.converter = function(dataView) {
                    var table = dataView.table, visualTable = powerbi.Prototype.inherit(table);
                    visualTable.visualRows = [];
                    for (var i = 0; i < table.rows.length; i++) {
                        var visualRow = {
                            index: i,
                            values: table.rows[i]
                        };
                        visualTable.visualRows.push(visualRow);
                    }
                    return visualTable.formattingProperties = TablixObjects.getTableObjects(dataView), 
                    visualTable;
                }, Table.prototype.onResizing = function(finalViewport) {
                    this.updateViewport(finalViewport);
                }, Table.prototype.getColumnWidthManager = function() {
                    return this.columnWidthManager;
                }, Table.prototype.onDataChanged = function(options) {
                    var dataViews = options.dataViews;
                    if (dataViews && dataViews.length > 0) {
                        var previousDataView = this.dataView;
                        if (this.dataView = dataViews[0], this.persistingObjects) return void (this.persistingObjects = !1);
                        var visualTable = Table.converter(this.dataView);
                        options.operationKind === powerbi.VisualDataChangeOperationKind.Append ? (this.createOrUpdateHierarchyNavigator(visualTable), 
                        this.tablixControl.updateModels(!1, visualTable.visualRows, visualTable.columns), 
                        this.refreshControl(!1)) : (this.createOrUpdateHierarchyNavigator(visualTable), 
                        this.createColumnWidthManager(), this.createTablixControl(visualTable), this.updateInternal(previousDataView, visualTable));
                    }
                    this.waitingForData = !1, this.waitingForSort = !1;
                }, Table.prototype.createColumnWidthManager = function() {
                    var _this = this;
                    this.columnWidthManager ? this.columnWidthManager.updateDataView(this.dataView) : this.columnWidthManager = new visuals.controls.TablixColumnWidthManager(this.dataView, !1, function(objectInstances) {
                        return _this.persistColumnWidths(objectInstances);
                    });
                }, Table.prototype.persistColumnWidths = function(objectInstances) {
                    this.persistingObjects = !0, this.hostServices.persistProperties(objectInstances);
                }, Table.prototype.updateViewport = function(newViewport) {
                    this.currentViewport = newViewport, this.tablixControl && (this.tablixControl.viewport = this.currentViewport, 
                    this.verifyHeaderResize(), this.refreshControl(!1));
                }, Table.prototype.refreshControl = function(clear) {
                    (visuals.visibilityHelper.partiallyVisible(this.element) || 1 === this.getLayoutKind()) && this.tablixControl.refresh(clear);
                }, Table.prototype.getLayoutKind = function() {
                    return this.isInteractive ? 0 : 1;
                }, Table.prototype.createOrUpdateHierarchyNavigator = function(visualTable) {
                    var isDataComplete = !this.dataView.metadata.segment;
                    if (this.tablixControl) this.hierarchyNavigator.update(visualTable, isDataComplete); else {
                        var dataNavigator = new TableHierarchyNavigator(visualTable, isDataComplete, this.formatter);
                        this.hierarchyNavigator = dataNavigator;
                    }
                }, Table.prototype.createTablixControl = function(visualTable) {
                    if (this.tablixControl) {
                        var binder = this.tablixControl.getBinder();
                        binder.updateDataView(visualTable);
                    } else this.tablixControl = this.createControl(this.hierarchyNavigator, visualTable);
                }, Table.prototype.createControl = function(dataNavigator, visualTable) {
                    var _this = this, layoutKind = this.getLayoutKind(), textSize = visualTable.formattingProperties.general.textSize, tableBinderOptions = {
                        onBindRowHeader: function(item) {
                            return _this.onBindRowHeader(item);
                        },
                        onColumnHeaderClick: function(queryName, sortDirection) {
                            return _this.onColumnHeaderClick(queryName, sortDirection);
                        },
                        layoutKind: layoutKind
                    }, tableBinder = new TableBinder(tableBinderOptions, visualTable), layoutManager = 1 === layoutKind ? visuals.controls.internal.DashboardTablixLayoutManager.createLayoutManager(tableBinder) : visuals.controls.internal.CanvasTablixLayoutManager.createLayoutManager(tableBinder, this.columnWidthManager), tablixContainer = document.createElement("div");
                    this.element.append(tablixContainer);
                    var tablixOptions = {
                        interactive: this.isInteractive,
                        enableTouchSupport: this.isTouchEnabled,
                        layoutKind: layoutKind,
                        fontSize: TablixObjects.getTextSizeInPx(textSize)
                    };
                    return new visuals.controls.TablixControl(dataNavigator, layoutManager, tableBinder, tablixContainer, tablixOptions);
                }, Table.prototype.updateInternal = function(previousDataView, visualTable) {
                    var _this = this, textSize = visualTable.formattingProperties.general.textSize;
                    1 === this.getLayoutKind() && this.tablixControl.layoutManager.adjustContentSize(visuals.converterHelper.hasImageUrlColumn(this.dataView)), 
                    this.tablixControl.fontSize = TablixObjects.getTextSizeInPx(textSize), this.verifyHeaderResize(), 
                    this.tablixControl.updateModels(!0, visualTable.visualRows, visualTable.columns);
                    var totals = this.createTotalsRow(this.dataView);
                    this.tablixControl.rowDimension.setFooter(totals), this.tablixControl.viewport = this.currentViewport;
                    var shouldClearControl = this.shouldClearControl(previousDataView, this.dataView);
                    setTimeout(function() {
                        _this.refreshControl(shouldClearControl);
                        var widthChanged = _this.columnWidthManager.onColumnsRendered(_this.tablixControl.layoutManager.columnWidthsToPersist);
                        _this.persistingObjects && !widthChanged && (_this.persistingObjects = !1);
                    }, 0);
                }, Table.prototype.shouldClearControl = function(previousDataView, newDataView) {
                    return this.waitingForSort && previousDataView && newDataView ? !powerbi.DataViewAnalysis.isMetadataEquivalent(previousDataView.metadata, newDataView.metadata) : !0;
                }, Table.prototype.createTotalsRow = function(dataView) {
                    if (!TablixObjects.shouldShowTableTotals(dataView.metadata.objects)) return null;
                    var totals = dataView.table.totals;
                    if (!totals || 0 === totals.length) return null;
                    for (var totalRow = [], columns = dataView.table.columns, i = 0, len = columns.length; len > i; ++i) {
                        var column = columns[i], totalValue = totals[column.index];
                        null != totalValue ? totalRow.push(totalValue) : totalRow.push(0 === i ? this.getLocalizedString("TableTotalLabel") : "");
                    }
                    return {
                        totalCells: totalRow
                    };
                }, Table.prototype.onBindRowHeader = function(item) {
                    this.needsMoreData(item) && (this.hostServices.loadMoreData(), this.waitingForData = !0);
                }, Table.prototype.onColumnHeaderClick = function(queryName, sortDirection) {
                    this.waitingForSort = !0, this.hostServices.onCustomSort(TablixUtils.getCustomSortEventArgs(queryName, sortDirection));
                }, Table.prototype.needsMoreData = function(item) {
                    if (this.waitingForData || !this.dataView.metadata || !this.dataView.metadata.segment) return !1;
                    var leafCount = this.tablixControl.rowDimension.getItemsCount(), loadMoreThreshold = leafCount * Table.preferredLoadMoreThreshold;
                    return this.hierarchyNavigator.getIndex(item) >= loadMoreThreshold;
                }, Table.prototype.enumerateObjectInstances = function(options) {
                    var enumeration = new visuals.ObjectEnumerationBuilder();
                    return this.dataView && TablixObjects.enumerateObjectInstances(options, enumeration, this.dataView, visuals.controls.TablixType.Table), 
                    enumeration.complete();
                }, Table.prototype.enumerateObjectRepetition = function() {
                    var enumeration = [];
                    return this.dataView && TablixObjects.enumerateObjectRepetition(enumeration, this.dataView, visuals.controls.TablixType.Table), 
                    enumeration;
                }, Table.prototype.shouldAllowHeaderResize = function() {
                    return 1 === this.hostServices.getViewMode();
                }, Table.prototype.onViewModeChanged = function(viewMode) {
                    this.updateViewport(this.currentViewport);
                }, Table.prototype.verifyHeaderResize = function() {
                    var currentAllowHeaderResize = this.shouldAllowHeaderResize();
                    currentAllowHeaderResize !== this.lastAllowHeaderResize && (this.lastAllowHeaderResize = currentAllowHeaderResize, 
                    this.tablixControl.layoutManager.setAllowHeaderResize(currentAllowHeaderResize));
                }, Table.preferredLoadMoreThreshold = .8, Table;
            }();
            visuals.Table = Table;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi, __extends = (window.powerbitests, 
    window.InJs, window.debug, window.jasmine, window.Microsoft, this && this.__extends || function(d, b) {
        function __() {
            this.constructor = d;
        }
        for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
    });
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            function createMatrixHierarchyNavigator(matrix, isDataComplete, formatter, compositeGroupSeparator) {
                return new MatrixHierarchyNavigator(matrix, isDataComplete, formatter, compositeGroupSeparator);
            }
            var TablixUtils = visuals.controls.internal.TablixUtils, TablixObjects = visuals.controls.internal.TablixObjects, UrlUtils = jsCommon.UrlUtils, EdgeSettings = TablixUtils.EdgeSettings, EdgeType = TablixUtils.EdgeType, MatrixVisualBodyItem = function(_super) {
                function MatrixVisualBodyItem() {
                    _super.apply(this, arguments);
                }
                return __extends(MatrixVisualBodyItem, _super), Object.defineProperty(MatrixVisualBodyItem.prototype, "isMeasure", {
                    get: function() {
                        return !0;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(MatrixVisualBodyItem.prototype, "isValidUrl", {
                    get: function() {
                        return !1;
                    },
                    enumerable: !0,
                    configurable: !0
                }), Object.defineProperty(MatrixVisualBodyItem.prototype, "isValidImage", {
                    get: function() {
                        return !1;
                    },
                    enumerable: !0,
                    configurable: !0
                }), MatrixVisualBodyItem;
            }(TablixUtils.TablixVisualCell);
            visuals.MatrixVisualBodyItem = MatrixVisualBodyItem, visuals.createMatrixHierarchyNavigator = createMatrixHierarchyNavigator;
            var MatrixHierarchyNavigator = function() {
                function MatrixHierarchyNavigator(matrix, isDataComplete, formatter, compositeGroupSeparator) {
                    this.matrix = matrix, this.rowHierarchy = MatrixHierarchyNavigator.wrapMatrixHierarchy(matrix.rows), 
                    this.columnHierarchy = MatrixHierarchyNavigator.wrapMatrixHierarchy(matrix.columns), 
                    this.formatter = formatter, this.compositeGroupSeparator = compositeGroupSeparator, 
                    this.isDataComplete = isDataComplete, this.update();
                }
                return MatrixHierarchyNavigator.prototype.getDataViewMatrix = function() {
                    return this.matrix;
                }, MatrixHierarchyNavigator.prototype.getColumnHierarchyDepth = function() {
                    return Math.max(this.columnHierarchy.levels.length, 1);
                }, MatrixHierarchyNavigator.prototype.getRowHierarchyDepth = function() {
                    return Math.max(this.rowHierarchy.levels.length, 1);
                }, MatrixHierarchyNavigator.prototype.getLeafCount = function(hierarchy) {
                    var matrixHierarchy = this.getMatrixHierarchy(hierarchy);
                    return matrixHierarchy ? matrixHierarchy.leafNodes.length : 0;
                }, MatrixHierarchyNavigator.prototype.getLeafAt = function(hierarchy, index) {
                    var matrixHierarchy = this.getMatrixHierarchy(hierarchy);
                    return matrixHierarchy ? matrixHierarchy.leafNodes[index] : null;
                }, MatrixHierarchyNavigator.prototype.getLeafIndex = function(item) {
                    return item.leafIndex;
                }, MatrixHierarchyNavigator.prototype.getParent = function(item) {
                    return 0 === item.level ? null : item.parent;
                }, MatrixHierarchyNavigator.prototype.getIndex = function(item) {
                    return item ? item.index : -1;
                }, MatrixHierarchyNavigator.prototype.isLeaf = function(item) {
                    return !item.children || 0 === item.children.length;
                }, MatrixHierarchyNavigator.prototype.isRowHierarchyLeaf = function(item) {
                    return !0;
                }, MatrixHierarchyNavigator.prototype.isColumnHierarchyLeaf = function(item) {
                    return !1;
                }, MatrixHierarchyNavigator.prototype.isFirstItem = function(item, items) {
                    return item === _.first(items);
                }, MatrixHierarchyNavigator.prototype.areAllParentsFirst = function(item, items) {
                    if (!item) return !1;
                    var parent = this.getParent(item);
                    return parent ? this.isFirstItem(item, item.siblings) && this.areAllParentsFirst(parent, parent.siblings) : this.isFirstItem(item, item.siblings);
                }, MatrixHierarchyNavigator.prototype.isLastItem = function(item, items) {
                    return item !== _.last(items) ? !1 : !this.isItemRow(item) || this.isDataComplete;
                }, MatrixHierarchyNavigator.prototype.isItemRow = function(item) {
                    if (!item) return !1;
                    for (var firstLevelParent = item; firstLevelParent.parent; ) firstLevelParent = firstLevelParent.parent;
                    return firstLevelParent.siblings === this.rowHierarchy.root.children;
                }, MatrixHierarchyNavigator.prototype.areAllParentsLast = function(item, items) {
                    if (!item) return !1;
                    var parent = this.getParent(item);
                    return parent ? this.isLastItem(item, item.siblings) && this.areAllParentsLast(parent, parent.siblings) : this.isLastItem(item, item.siblings);
                }, MatrixHierarchyNavigator.prototype.getChildren = function(item) {
                    return item.children;
                }, MatrixHierarchyNavigator.prototype.getChildrenLevelDifference = function(item) {
                    for (var diff = 1 / 0, children = this.getChildren(item), i = 0, ilen = children.length; ilen > i; i++) diff = Math.min(diff, children[i].level - item.level);
                    return diff;
                }, MatrixHierarchyNavigator.prototype.getCount = function(items) {
                    return items.length;
                }, MatrixHierarchyNavigator.prototype.getAt = function(items, index) {
                    return items[index];
                }, MatrixHierarchyNavigator.prototype.getLevel = function(item) {
                    return item.level;
                }, MatrixHierarchyNavigator.prototype.getIntersection = function(rowItem, columnItem) {
                    var node, valueSource, bodyCell, isSubtotalItem = rowItem.isSubtotal === !0 || columnItem.isSubtotal === !0, rowIndex = rowItem.leafIndex, colIndex = columnItem.leafIndex;
                    return node = rowItem.values ? rowItem.values[columnItem.leafIndex] : void 0, node ? (valueSource = this.matrix.valueSources[node.valueSourceIndex || 0], 
                    bodyCell = new MatrixVisualBodyItem(node.value, isSubtotalItem, valueSource, this.formatter, !1)) : bodyCell = new MatrixVisualBodyItem(void 0, isSubtotalItem, void 0, this.formatter, !1), 
                    bodyCell.position.row.index = rowIndex, bodyCell.position.row.indexInSiblings = rowItem.siblings.indexOf(rowItem), 
                    bodyCell.position.row.isFirst = 0 === rowIndex, bodyCell.position.row.isLast = this.isDataComplete && rowIndex === this.rowHierarchy.leafNodes.length - 1, 
                    bodyCell.position.column.index = colIndex, bodyCell.position.column.indexInSiblings = columnItem.siblings.indexOf(columnItem), 
                    bodyCell.position.column.isFirst = 0 === colIndex, bodyCell.position.column.isLast = colIndex === this.columnHierarchy.leafNodes.length - 1, 
                    bodyCell;
                }, MatrixHierarchyNavigator.prototype.getCorner = function(rowLevel, columnLevel) {
                    var columnLevels = this.columnHierarchy.levels, rowLevels = this.rowHierarchy.levels;
                    if (columnLevel === columnLevels.length - 1 || 0 === columnLevels.length) {
                        var levelSource = rowLevels[rowLevel];
                        if (levelSource) return {
                            metadata: 1 === levelSource.sources.length ? levelSource.sources[0] : null,
                            displayName: _.map(levelSource.sources, function(source) {
                                return source.displayName;
                            }).join(this.compositeGroupSeparator),
                            isColumnHeaderLeaf: !0,
                            isRowHeaderLeaf: rowLevel === rowLevels.length - 1
                        };
                    }
                    if (rowLevel === rowLevels.length - 1) {
                        var levelSource = columnLevels[columnLevel];
                        if (levelSource) return {
                            metadata: 1 === levelSource.sources.length ? levelSource.sources[0] : null,
                            displayName: _.map(levelSource.sources, function(source) {
                                return source.displayName;
                            }).join(this.compositeGroupSeparator),
                            isColumnHeaderLeaf: !1,
                            isRowHeaderLeaf: !0
                        };
                    }
                    return {
                        metadata: null,
                        displayName: "",
                        isColumnHeaderLeaf: !1,
                        isRowHeaderLeaf: !1
                    };
                }, MatrixHierarchyNavigator.prototype.headerItemEquals = function(item1, item2) {
                    return item1 && item2 ? item1 === item2 : !1;
                }, MatrixHierarchyNavigator.prototype.bodyCellItemEquals = function(item1, item2) {
                    return item1.position.isMatch(item2.position);
                }, MatrixHierarchyNavigator.prototype.cornerCellItemEquals = function(item1, item2) {
                    var corner1 = item1, corner2 = item2;
                    return corner1 && corner2 ? corner1.displayName === corner2.displayName && corner1.isColumnHeaderLeaf === corner2.isColumnHeaderLeaf && corner1.isRowHeaderLeaf === corner2.isRowHeaderLeaf && corner1.metadata === corner2.metadata : !1;
                }, MatrixHierarchyNavigator.prototype.getMatrixColumnHierarchy = function() {
                    return this.columnHierarchy;
                }, MatrixHierarchyNavigator.prototype.getMatrixRowHierarchy = function() {
                    return this.rowHierarchy;
                }, MatrixHierarchyNavigator.prototype.update = function(dataViewMatrix, isDataComplete, updateColumns) {
                    void 0 === updateColumns && (updateColumns = !0), dataViewMatrix && (this.matrix = dataViewMatrix, 
                    null != isDataComplete && (this.isDataComplete = isDataComplete), this.rowHierarchy = MatrixHierarchyNavigator.wrapMatrixHierarchy(dataViewMatrix.rows), 
                    updateColumns && (this.columnHierarchy = MatrixHierarchyNavigator.wrapMatrixHierarchy(dataViewMatrix.columns))), 
                    this.updateHierarchy(this.rowHierarchy), updateColumns && (this.updateHierarchy(this.columnHierarchy), 
                    MatrixHierarchyNavigator.updateStaticColumnHeaders(this.columnHierarchy));
                }, MatrixHierarchyNavigator.wrapMatrixHierarchy = function(hierarchy) {
                    var matrixHierarchy = powerbi.Prototype.inherit(hierarchy);
                    return matrixHierarchy.leafNodes = [], matrixHierarchy;
                }, MatrixHierarchyNavigator.prototype.updateHierarchy = function(hierarchy) {
                    hierarchy.leafNodes.length > 0 && (hierarchy.leafNodes.length = 0), hierarchy.root.children && this.updateRecursive(hierarchy, hierarchy.root.children, null, hierarchy.leafNodes);
                }, MatrixHierarchyNavigator.prototype.updateRecursive = function(hierarchy, nodes, parent, cache) {
                    for (var level, _this = this, formatStringPropID = TablixObjects.PropColumnFormatString.getPropertyID(), i = 0, ilen = nodes.length; ilen > i; i++) {
                        var node = nodes[i];
                        if (node.siblings = nodes, parent && (node.parent = parent), level || (level = hierarchy.levels[node.level]), 
                        level) if (node.levelValues) {
                            var displayNames = _.map(node.levelValues, function(component) {
                                var source = level.sources[component.levelSourceIndex || 0];
                                return _this.formatter(component.value, source, formatStringPropID, !1);
                            });
                            node.valueFormatted = displayNames.join(this.compositeGroupSeparator), node.queryName = 1 !== level.sources.length ? void 0 : level.sources[0].queryName;
                        } else {
                            var source = level.sources[node.levelSourceIndex || 0];
                            node.valueFormatted = source.displayName, node.queryName = source.queryName;
                        }
                        node.index = i, node.children && node.children.length > 0 ? this.updateRecursive(hierarchy, node.children, node, cache) : (node.leafIndex = cache.length, 
                        cache.push(node));
                    }
                }, MatrixHierarchyNavigator.updateStaticColumnHeaders = function(columnHierarchy) {
                    var columnLeafNodes = columnHierarchy.leafNodes;
                    if (columnLeafNodes && columnLeafNodes.length > 0) for (var columnLeafSources = columnHierarchy.levels[columnLeafNodes[0].level].sources, i = 0, ilen = columnLeafNodes.length; ilen > i; i++) {
                        var columnLeafNode = columnLeafNodes[i];
                        if (!columnLeafNode.identity && _.isEmpty(columnLeafNode.levelValues)) {
                            var source = columnLeafSources[columnLeafNode.levelSourceIndex ? columnLeafNode.levelSourceIndex : 0];
                            source && (columnLeafNode.valueFormatted = source.displayName);
                        }
                    }
                }, MatrixHierarchyNavigator.prototype.getMatrixHierarchy = function(rootNodes) {
                    var rowHierarchyRootNodes = this.rowHierarchy.root.children;
                    if (rowHierarchyRootNodes && rootNodes === rowHierarchyRootNodes) return this.rowHierarchy;
                    var columnHierarchyRootNodes = this.columnHierarchy.root.children;
                    return columnHierarchyRootNodes && rootNodes === columnHierarchyRootNodes ? this.columnHierarchy : null;
                }, MatrixHierarchyNavigator;
            }(), MatrixBinder = function() {
                function MatrixBinder(hierarchyNavigator, options) {
                    this.hierarchyNavigator = hierarchyNavigator, this.options = options;
                }
                return MatrixBinder.prototype.onDataViewChanged = function(formattingProperties) {
                    this.formattingProperties = formattingProperties, this.updateTextHeights();
                }, MatrixBinder.prototype.updateTextHeights = function() {
                    this.fontSizeHeader = jsCommon.PixelConverter.fromPointToPixel(this.formattingProperties.general.textSize), 
                    this.textPropsHeader = {
                        fontFamily: TablixUtils.FontFamilyHeader,
                        fontSize: jsCommon.PixelConverter.toString(this.fontSizeHeader)
                    }, this.textHeightHeader = Math.ceil(powerbi.TextMeasurementService.measureSvgTextHeight(this.textPropsHeader, "a")), 
                    this.fontSizeValue = jsCommon.PixelConverter.fromPointToPixel(this.formattingProperties.general.textSize), 
                    this.textPropsValue = {
                        fontFamily: TablixUtils.FontFamilyCell,
                        fontSize: jsCommon.PixelConverter.toString(this.fontSizeValue)
                    }, this.textHeightValue = Math.ceil(powerbi.TextMeasurementService.measureSvgTextHeight(this.textPropsValue, "a")), 
                    this.fontSizeTotal = jsCommon.PixelConverter.fromPointToPixel(this.formattingProperties.general.textSize), 
                    this.textPropsTotal = {
                        fontFamily: TablixUtils.FontFamilyTotal,
                        fontSize: jsCommon.PixelConverter.toString(this.fontSizeTotal)
                    }, this.textHeightTotal = Math.ceil(powerbi.TextMeasurementService.measureSvgTextHeight(this.textPropsTotal, "a"));
                }, MatrixBinder.prototype.onStartRenderingSession = function() {}, MatrixBinder.prototype.onEndRenderingSession = function() {}, 
                MatrixBinder.prototype.bindRowHeader = function(item, cell) {
                    TablixUtils.resetCellCssClass(cell);
                    var cellStyle = new TablixUtils.CellStyle(), isLeaf = this.hierarchyNavigator && this.hierarchyNavigator.isLeaf(item);
                    isLeaf && (TablixUtils.addCellCssClass(cell, TablixUtils.CssClassMatrixRowHeaderLeaf), 
                    cellStyle.borders.right = new EdgeSettings(TablixObjects.PropGridOutlineWeight.defaultValue, TablixObjects.PropGridOutlineColor.defaultValue)), 
                    item.isSubtotal && (cellStyle.paddings.left = TablixUtils.CellPaddingLeftMatrixTotal), 
                    cell.contentWidth = 0, this.bindHeader(item, cell, cell.extension.contentHost, this.getRowHeaderMetadata(item), cellStyle), 
                    cell.contentWidth = Math.ceil(cell.contentWidth), this.options.onBindRowHeader && this.options.onBindRowHeader(item), 
                    this.setRowHeaderStyle(cell, cellStyle), cell.applyStyle(cellStyle);
                }, MatrixBinder.prototype.setRowHeaderStyle = function(cell, style) {
                    var propsGrid = this.formattingProperties.grid, props = this.formattingProperties.rowHeaders, propsValues = this.formattingProperties.values, propsCols = this.formattingProperties.columnHeaders;
                    style.borders.top = new EdgeSettings(), cell.position.row.isFirst && (style.borders.top.applyParams(visuals.outline.showTop(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline), 
                    !visuals.outline.showTop(props.outline) && visuals.outline.showTop(propsValues.outline) && (style.paddings.top += propsGrid.outlineWeight)), 
                    style.borders.bottom = new EdgeSettings(), cell.position.row.isLast ? (style.borders.bottom.applyParams(visuals.outline.showBottom(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline), 
                    !visuals.outline.showBottom(props.outline) && visuals.outline.showBottom(propsValues.outline) && (style.paddings.bottom += propsGrid.outlineWeight)) : style.borders.bottom.applyParams(propsGrid.gridHorizontal, propsGrid.gridHorizontalWeight, propsGrid.gridHorizontalColor, EdgeType.Gridline), 
                    style.borders.left = new EdgeSettings(), cell.position.column.isFirst && (style.borders.left.applyParams(visuals.outline.showLeft(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline), 
                    !visuals.outline.showLeft(props.outline) && visuals.outline.showLeft(propsCols.outline) && (style.paddings.left += propsGrid.outlineWeight)), 
                    style.borders.right = new EdgeSettings(), cell.position.column.isLast ? style.borders.right.applyParams(visuals.outline.showRight(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline) : style.borders.right.applyParams(propsGrid.gridVertical, propsGrid.gridVerticalWeight, propsGrid.gridVerticalColor, EdgeType.Gridline), 
                    style.fontColor = props.fontColor, style.backColor = props.backColor, style.paddings.top = style.paddings.bottom = propsGrid.rowPadding;
                }, MatrixBinder.prototype.unbindRowHeader = function(item, cell) {
                    TablixUtils.clearCellStyle(cell), TablixUtils.clearCellTextAndTooltip(cell);
                }, MatrixBinder.prototype.bindColumnHeader = function(item, cell) {
                    TablixUtils.resetCellCssClass(cell);
                    var cellStyle = new TablixUtils.CellStyle(), overwriteTotalLabel = !1, cellElement = cell.extension.contentHost;
                    cell.contentWidth = 0;
                    var isLeaf = this.hierarchyNavigator && this.hierarchyNavigator.isLeaf(item);
                    if (isLeaf) {
                        if (cellStyle.borders.bottom = new EdgeSettings(TablixObjects.PropGridOutlineWeight.defaultValue, TablixObjects.PropGridOutlineColor.defaultValue), 
                        TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixColumnHeaderLeaf), TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixValueNumeric), 
                        this.options.showSortIcons) {
                            var sortableHeaderColumnMetadata = this.getSortableHeaderColumnMetadata(item);
                            sortableHeaderColumnMetadata && (this.registerColumnHeaderClickHandler(sortableHeaderColumnMetadata, cell), 
                            cellElement = TablixUtils.addSortIconToColumnHeader(sortableHeaderColumnMetadata.sort, cellElement), 
                            sortableHeaderColumnMetadata.sort && (cell.contentWidth = this.fontSizeHeader + TablixUtils.SortIconPadding));
                        }
                        item.isSubtotal && item.parent && item.parent.children.length > 1 && item.parent.children[0].isSubtotal && (overwriteTotalLabel = !0);
                    }
                    cell.extension.disableDragResize(), this.bindHeader(item, cell, cellElement, this.getColumnHeaderMetadata(item), cellStyle, overwriteTotalLabel), 
                    cell.contentWidth = Math.ceil(cell.contentWidth), this.setColumnHeaderStyle(cell, cellStyle), 
                    cell.applyStyle(cellStyle);
                }, MatrixBinder.prototype.setColumnHeaderStyle = function(cell, style) {
                    var propsGrid = this.formattingProperties.grid, props = this.formattingProperties.columnHeaders, propsValues = this.formattingProperties.values;
                    style.fontColor = props.fontColor, style.backColor = props.backColor, style.paddings.top = style.paddings.bottom = propsGrid.rowPadding, 
                    style.borders.top = new EdgeSettings(), cell.position.row.isFirst && style.borders.top.applyParams(visuals.outline.showTop(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline), 
                    style.borders.bottom = new EdgeSettings(), cell.position.row.isLast ? style.borders.bottom.applyParams(visuals.outline.showBottom(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline) : style.borders.bottom.applyParams(propsGrid.gridHorizontal, propsGrid.gridHorizontalWeight, propsGrid.gridHorizontalColor, EdgeType.Gridline), 
                    style.borders.left = new EdgeSettings(), cell.position.column.isFirst && !visuals.outline.showLeft(props.outline) && visuals.outline.showLeft(propsValues.outline) && (style.paddings.left += propsGrid.outlineWeight), 
                    style.borders.right = new EdgeSettings(), cell.position.column.isLast ? (style.borders.right.applyParams(visuals.outline.showRight(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline), 
                    !visuals.outline.showRight(props.outline) && visuals.outline.showRight(propsValues.outline) && (style.paddings.right += propsGrid.outlineWeight)) : style.borders.right.applyParams(propsGrid.gridVertical, propsGrid.gridVerticalWeight, propsGrid.gridVerticalColor, EdgeType.Gridline);
                }, MatrixBinder.prototype.unbindColumnHeader = function(item, cell) {
                    TablixUtils.clearCellStyle(cell), TablixUtils.clearCellTextAndTooltip(cell);
                    var sortableHeaderColumnMetadata = this.getSortableHeaderColumnMetadata(item);
                    sortableHeaderColumnMetadata && this.unregisterColumnHeaderClickHandler(cell), this.options.showSortIcons && TablixUtils.removeSortIcons(cell);
                }, MatrixBinder.prototype.bindHeader = function(item, cell, cellElement, metadata, style, overwriteSubtotalLabel) {
                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixHeader), style.fontFamily = TablixUtils.FontFamilyHeader, 
                    style.fontColor = TablixUtils.FontColorHeaders;
                    var imgHeight = this.formattingProperties.grid.imageHeight;
                    if (visuals.converterHelper.isImageUrlColumn(metadata) ? cell.contentHeight = imgHeight : item.isSubtotal ? cell.contentHeight = this.textHeightTotal : cell.contentHeight = this.textHeightValue, 
                    item.isSubtotal && (TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixValueTotal), 
                    style.fontFamily = TablixUtils.FontFamilyTotal, !overwriteSubtotalLabel)) return TablixUtils.setCellTextAndTooltip(this.options.totalLabel, cellElement, cell.extension.contentHost), 
                    void (cell.contentWidth = powerbi.TextMeasurementService.measureSvgTextWidth(this.textPropsTotal, this.options.totalLabel));
                    var value = this.getHeaderLabel(item);
                    return value ? visuals.converterHelper.isWebUrlColumn(metadata) && UrlUtils.isValidUrl(value) ? (TablixUtils.appendATagToBodyCell(value, cellElement), 
                    void (cell.contentWidth += powerbi.TextMeasurementService.measureSvgTextWidth(this.textPropsHeader, value))) : visuals.converterHelper.isImageUrlColumn(metadata) && UrlUtils.isValidImageUrl(value) ? (TablixUtils.appendImgTagToBodyCell(item.valueFormatted, cellElement, imgHeight), 
                    void (cell.contentWidth += imgHeight * TablixUtils.ImageDefaultAspectRatio)) : (TablixUtils.setCellTextAndTooltip(value, cellElement, cell.extension.contentHost), 
                    void (cell.contentWidth += powerbi.TextMeasurementService.measureSvgTextWidth(item.isSubtotal ? this.textPropsTotal : this.textPropsHeader, value))) : void (cellElement.innerHTML = TablixUtils.StringNonBreakingSpace);
                }, MatrixBinder.prototype.registerColumnHeaderClickHandler = function(columnMetadata, cell) {
                    var _this = this;
                    if (this.options.onColumnHeaderClick) {
                        var handler = function(e) {
                            if (TablixUtils.isValidSortClick(e)) {
                                var sortDirection = TablixUtils.reverseSort(columnMetadata.sort);
                                _this.options.onColumnHeaderClick(columnMetadata.queryName ? columnMetadata.queryName : columnMetadata.displayName, sortDirection);
                            }
                        };
                        cell.extension.registerClickHandler(handler);
                    }
                }, MatrixBinder.prototype.unregisterColumnHeaderClickHandler = function(cell) {
                    this.options.onColumnHeaderClick && cell.extension.unregisterClickHandler();
                }, MatrixBinder.prototype.bindBodyCell = function(item, cell) {
                    TablixUtils.resetCellCssClass(cell);
                    var cellStyle = new TablixUtils.CellStyle();
                    cell.contentHeight = this.textHeightValue;
                    var kpi = item.kpiContent;
                    if (kpi) $(cell.extension.contentHost).append(kpi), cell.contentWidth = this.fontSizeValue; else {
                        var textProps = this.textPropsValue;
                        TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixValueNumeric), item.isTotal && (TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixValueTotal), 
                        cellStyle.fontFamily = TablixUtils.FontFamilyTotal, cell.contentHeight = this.textHeightTotal, 
                        textProps = this.textPropsTotal);
                        var textContent = item.textContent;
                        textContent && (TablixUtils.setCellTextAndTooltip(textContent, cell.extension.contentHost), 
                        cell.contentWidth = powerbi.TextMeasurementService.measureSvgTextWidth(textProps, textContent));
                    }
                    cell.contentWidth = Math.ceil(cell.contentWidth), this.setBodyCellStyle(cell, item, cellStyle), 
                    cell.applyStyle(cellStyle);
                }, MatrixBinder.prototype.setBodyCellStyle = function(cell, item, style) {
                    var propsGrid = this.formattingProperties.grid, props = this.formattingProperties.values, propsTotal = this.formattingProperties.subtotals, propsRows = this.formattingProperties.rowHeaders, propsColumns = this.formattingProperties.columnHeaders;
                    style.paddings.top = style.paddings.bottom = propsGrid.rowPadding, style.borders.top = new EdgeSettings(), 
                    cell.position.row.isFirst && (style.borders.top.applyParams(visuals.outline.showTop(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline), 
                    !visuals.outline.showTop(props.outline) && visuals.outline.showTop(propsRows.outline) && (style.paddings.top += propsGrid.outlineWeight)), 
                    style.borders.bottom = new EdgeSettings(), cell.position.row.isLast ? (style.borders.bottom.applyParams(visuals.outline.showBottom(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline), 
                    !visuals.outline.showBottom(props.outline) && visuals.outline.showBottom(propsRows.outline) && (style.paddings.bottom += propsGrid.outlineWeight)) : style.borders.bottom.applyParams(propsGrid.gridHorizontal, propsGrid.gridHorizontalWeight, propsGrid.gridHorizontalColor), 
                    style.borders.left = new EdgeSettings(), cell.position.column.isFirst && style.borders.left.applyParams(visuals.outline.showLeft(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline), 
                    style.borders.right = new EdgeSettings(), cell.position.column.isLast ? (style.borders.right.applyParams(visuals.outline.showRight(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline), 
                    !visuals.outline.showRight(props.outline) && visuals.outline.showRight(propsColumns.outline) && (style.paddings.right += propsGrid.outlineWeight)) : style.borders.right.applyParams(propsGrid.gridVertical, propsGrid.gridVerticalWeight, propsGrid.gridVerticalColor, EdgeType.Gridline);
                    var rowBandingIndex;
                    rowBandingIndex = this.formattingProperties.general.rowSubtotals && propsTotal.backColor ? item.position.row.indexInSiblings : item.position.row.index, 
                    item.isTotal && propsTotal.fontColor ? style.fontColor = propsTotal.fontColor : style.fontColor = rowBandingIndex % 2 === 0 ? props.fontColorPrimary : props.fontColorSecondary, 
                    item.isTotal && propsTotal.backColor ? style.backColor = propsTotal.backColor : style.backColor = rowBandingIndex % 2 === 0 ? props.backColorPrimary : props.backColorSecondary;
                }, MatrixBinder.prototype.unbindBodyCell = function(item, cell) {
                    TablixUtils.clearCellStyle(cell), TablixUtils.clearCellTextAndTooltip(cell);
                }, MatrixBinder.prototype.bindCornerCell = function(item, cell) {
                    TablixUtils.resetCellCssClass(cell);
                    var cellStyle = new TablixUtils.CellStyle();
                    cellStyle.fontFamily = TablixUtils.FontFamilyHeader, cellStyle.fontColor = TablixUtils.FontColorHeaders, 
                    cell.contentHeight = this.textHeightHeader, cell.contentWidth = 0;
                    var cellElement = cell.extension.contentHost;
                    if (item.isColumnHeaderLeaf && (TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixColumnHeaderLeaf), 
                    cellStyle.borders.bottom = new EdgeSettings(TablixObjects.PropGridOutlineWeight.defaultValue, TablixObjects.PropGridOutlineColor.defaultValue), 
                    this.options.showSortIcons)) {
                        var cornerHeaderMetadata = this.getSortableCornerColumnMetadata(item);
                        cornerHeaderMetadata && (this.registerColumnHeaderClickHandler(cornerHeaderMetadata, cell), 
                        cellElement = TablixUtils.addSortIconToColumnHeader(cornerHeaderMetadata ? cornerHeaderMetadata.sort : void 0, cellElement), 
                        cornerHeaderMetadata.sort && (cell.contentWidth = this.fontSizeHeader + TablixUtils.SortIconPadding));
                    }
                    TablixUtils.setCellTextAndTooltip(item.displayName, cellElement, cell.extension.contentHost), 
                    cell.contentWidth += powerbi.TextMeasurementService.measureSvgTextWidth(this.textPropsHeader, item.displayName), 
                    cell.contentWidth = Math.ceil(cell.contentWidth), item.isRowHeaderLeaf && TablixUtils.addCellCssClass(cell, TablixUtils.CssClassMatrixRowHeaderLeaf), 
                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixHeader), this.setCornerCellsStyle(cell, cellStyle), 
                    cell.applyStyle(cellStyle), cell.extension.disableDragResize();
                }, MatrixBinder.prototype.setCornerCellsStyle = function(cell, style) {
                    var propsGrid = this.formattingProperties.grid, propsCol = this.formattingProperties.columnHeaders, propsRow = this.formattingProperties.rowHeaders;
                    style.fontColor = propsCol.fontColor || propsRow.fontColor, style.backColor = propsCol.backColor || propsRow.backColor, 
                    style.paddings.top = style.paddings.bottom = propsGrid.rowPadding, style.borders.top = new EdgeSettings(), 
                    cell.position.row.isFirst && style.borders.top.applyParams(visuals.outline.showTop(propsCol.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline), 
                    style.borders.bottom = new EdgeSettings(), cell.position.row.isLast ? style.borders.bottom.applyParams(visuals.outline.showBottom(propsCol.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline) : style.borders.bottom.applyParams(propsGrid.gridHorizontal, propsGrid.gridHorizontalWeight, propsGrid.gridHorizontalColor, EdgeType.Gridline), 
                    style.borders.left = new EdgeSettings(), cell.position.column.isFirst && (style.borders.left.applyParams(visuals.outline.showLeft(propsCol.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline), 
                    !visuals.outline.showLeft(propsCol.outline) && visuals.outline.showLeft(propsRow.outline) && (style.paddings.left += propsGrid.outlineWeight)), 
                    style.borders.right = new EdgeSettings(), style.borders.right.applyParams(propsGrid.gridVertical, propsGrid.gridVerticalWeight, propsGrid.gridVerticalColor, EdgeType.Gridline);
                }, MatrixBinder.prototype.unbindCornerCell = function(item, cell) {
                    TablixUtils.clearCellStyle(cell), TablixUtils.clearCellTextAndTooltip(cell), this.options.showSortIcons && TablixUtils.removeSortIcons(cell), 
                    item.isColumnHeaderLeaf && this.unregisterColumnHeaderClickHandler(cell);
                }, MatrixBinder.prototype.bindEmptySpaceHeaderCell = function(cell) {}, MatrixBinder.prototype.unbindEmptySpaceHeaderCell = function(cell) {}, 
                MatrixBinder.prototype.bindEmptySpaceFooterCell = function(cell) {}, MatrixBinder.prototype.unbindEmptySpaceFooterCell = function(cell) {}, 
                MatrixBinder.prototype.getHeaderLabel = function(item) {
                    return item.valueFormatted;
                }, MatrixBinder.prototype.getCellContent = function(item) {
                    return item.textContent || "";
                }, MatrixBinder.prototype.hasRowGroups = function() {
                    var dataView = this.hierarchyNavigator.getDataViewMatrix();
                    return !!(dataView && dataView.rows && dataView.rows.levels && 0 !== dataView.rows.levels.length);
                }, MatrixBinder.prototype.getSortableCornerColumnMetadata = function(item) {
                    return item.isColumnHeaderLeaf ? item.metadata : void 0;
                }, MatrixBinder.prototype.getRowHeaderMetadata = function(item) {
                    if (this.hierarchyNavigator && item) {
                        var dataView = this.hierarchyNavigator.getDataViewMatrix();
                        if (dataView && dataView.rows) return this.getHierarchyMetadata(dataView.rows, item.level);
                    }
                }, MatrixBinder.prototype.getColumnHeaderMetadata = function(item) {
                    if (this.hierarchyNavigator && item) {
                        var dataView = this.hierarchyNavigator.getDataViewMatrix();
                        if (dataView && dataView.columns) return this.getHierarchyMetadata(dataView.columns, item.level);
                    }
                }, MatrixBinder.prototype.getHierarchyMetadata = function(hierarchy, level) {
                    if (hierarchy && hierarchy.levels && !(hierarchy.levels.length < level)) {
                        var levelInfo = hierarchy.levels[level];
                        if (levelInfo && levelInfo.sources && 0 !== levelInfo.sources.length) return levelInfo.sources[0];
                    }
                }, MatrixBinder.prototype.getSortableHeaderColumnMetadata = function(item) {
                    var dataView = this.hierarchyNavigator.getDataViewMatrix();
                    if (!dataView.rows || !dataView.rows.levels || 0 === dataView.rows.levels.length) return null;
                    var isMultiMeasure = dataView.valueSources && dataView.valueSources.length > 1, columnGroupCount = dataView.columns ? dataView.columns.levels.length : 0;
                    isMultiMeasure ? columnGroupCount-- : 1 === columnGroupCount && dataView.columns.levels[0] && dataView.columns.levels[0].sources && dataView.columns.levels[0].sources[0] && dataView.columns.levels[0].sources[0].roles && dataView.columns.levels[0].sources[0].roles.Values && (columnGroupCount = 0);
                    var valueIndex = -1;
                    return 0 === columnGroupCount ? valueIndex = item.levelSourceIndex : item.isSubtotal && (isMultiMeasure ? item.parent && 0 === item.parent.level && (valueIndex = item.levelSourceIndex) : 0 === item.level && (valueIndex = item.levelSourceIndex)), 
                    -1 !== valueIndex ? (valueIndex = valueIndex ? valueIndex : 0, dataView.valueSources[valueIndex]) : null;
                }, MatrixBinder;
            }();
            visuals.MatrixBinder = MatrixBinder;
            var Matrix = function() {
                function Matrix(options) {
                    options && (this.isTouchEnabled = options.isTouchEnabled);
                }
                return Matrix.customizeQuery = function(options) {
                    var dataViewMapping = options.dataViewMappings[0];
                    if (dataViewMapping && dataViewMapping.matrix && dataViewMapping.metadata) {
                        var dataViewMatrix = dataViewMapping.matrix;
                        _.isEmpty(dataViewMatrix.columns["for"]["in"].items) || (dataViewMatrix.rows.dataReductionAlgorithm.window.count = 100);
                        var objects = dataViewMapping.metadata.objects;
                        dataViewMatrix.rows["for"]["in"].subtotalType = TablixObjects.shouldShowRowSubtotals(objects) ? 2 : 0, 
                        dataViewMatrix.columns["for"]["in"].subtotalType = TablixObjects.shouldShowColumnSubtotals(objects) ? 2 : 0;
                    }
                }, Matrix.getSortableRoles = function() {
                    return [ "Rows", "Values" ];
                }, Matrix.prototype.init = function(options) {
                    this.element = options.element, this.style = options.style, this.updateViewport(options.viewport), 
                    this.formatter = visuals.valueFormatter.formatVariantMeasureValue, this.isInteractive = options.interactivity && null != options.interactivity.selection, 
                    this.hostServices = options.host, this.persistingObjects = !1, this.waitingForData = !1, 
                    this.lastAllowHeaderResize = !0, this.waitingForSort = !1;
                }, Matrix.converter = function(dataView) {
                    return TablixObjects.getMatrixObjects(dataView);
                }, Matrix.prototype.onResizing = function(finalViewport) {
                    this.updateViewport(finalViewport);
                }, Matrix.prototype.getColumnWidthManager = function() {
                    return this.columnWidthManager;
                }, Matrix.prototype.onDataChanged = function(options) {
                    var dataViews = options.dataViews;
                    if (dataViews && dataViews.length > 0) {
                        var previousDataView = this.dataView;
                        this.dataView = dataViews[0];
                        var formattingProperties = Matrix.converter(this.dataView), textSize = formattingProperties.general.textSize;
                        if (options.operationKind === powerbi.VisualDataChangeOperationKind.Append) {
                            var rootChanged = previousDataView.matrix.rows.root !== this.dataView.matrix.rows.root;
                            this.createOrUpdateHierarchyNavigator(rootChanged), rootChanged && this.tablixControl.updateModels(!1, this.dataView.matrix.rows.root.children, this.dataView.matrix.columns.root.children), 
                            this.refreshControl(!1);
                        } else {
                            this.createOrUpdateHierarchyNavigator(!0), this.createColumnWidthManager(), this.createTablixControl(textSize);
                            var binder = this.tablixControl.getBinder();
                            binder.onDataViewChanged(formattingProperties), this.updateInternal(textSize, previousDataView);
                        }
                    }
                    this.waitingForData = !1, this.waitingForSort = !1;
                }, Matrix.prototype.createColumnWidthManager = function() {
                    var _this = this, columnHierarchy = this.hierarchyNavigator.getMatrixColumnHierarchy();
                    this.columnWidthManager ? this.persistingObjects || this.columnWidthManager.updateDataView(this.dataView, columnHierarchy.leafNodes) : this.columnWidthManager = new visuals.controls.TablixColumnWidthManager(this.dataView, !0, function(objectInstances) {
                        return _this.persistColumnWidths(objectInstances);
                    }, columnHierarchy.leafNodes);
                }, Matrix.prototype.persistColumnWidths = function(objectInstances) {
                    this.persistingObjects = !0, this.hostServices.persistProperties(objectInstances);
                }, Matrix.prototype.updateViewport = function(newViewport) {
                    this.currentViewport = newViewport, this.tablixControl && (this.tablixControl.viewport = this.currentViewport, 
                    this.verifyHeaderResize(), this.refreshControl(!1));
                }, Matrix.prototype.refreshControl = function(clear) {
                    (visuals.visibilityHelper.partiallyVisible(this.element) || 1 === this.getLayoutKind()) && this.tablixControl.refresh(clear);
                }, Matrix.prototype.getLayoutKind = function() {
                    return this.isInteractive ? 0 : 1;
                }, Matrix.prototype.createOrUpdateHierarchyNavigator = function(rootChanged) {
                    var isDataComplete = !this.dataView.metadata.segment;
                    if (this.tablixControl) this.hierarchyNavigator.update(this.dataView.matrix, isDataComplete, rootChanged); else {
                        var matrixNavigator = createMatrixHierarchyNavigator(this.dataView.matrix, isDataComplete, this.formatter, this.hostServices.getLocalizedString("ListJoin_Separator"));
                        this.hierarchyNavigator = matrixNavigator;
                    }
                }, Matrix.prototype.createTablixControl = function(textSize) {
                    this.tablixControl || (this.tablixControl = this.createControl(this.hierarchyNavigator, textSize));
                }, Matrix.prototype.createControl = function(matrixNavigator, textSize) {
                    var _this = this, layoutKind = this.getLayoutKind(), matrixBinderOptions = {
                        onBindRowHeader: function(item) {
                            _this.onBindRowHeader(item);
                        },
                        totalLabel: this.hostServices.getLocalizedString(Matrix.TotalLabel),
                        onColumnHeaderClick: function(queryName, sortDirection) {
                            return _this.onColumnHeaderClick(queryName, sortDirection);
                        },
                        showSortIcons: 0 === layoutKind
                    }, matrixBinder = new MatrixBinder(this.hierarchyNavigator, matrixBinderOptions), layoutManager = 1 === layoutKind ? visuals.controls.internal.DashboardTablixLayoutManager.createLayoutManager(matrixBinder) : visuals.controls.internal.CanvasTablixLayoutManager.createLayoutManager(matrixBinder, this.columnWidthManager), tablixContainer = document.createElement("div");
                    this.element.append(tablixContainer);
                    var tablixOptions = {
                        interactive: this.isInteractive,
                        enableTouchSupport: this.isTouchEnabled,
                        layoutKind: layoutKind,
                        fontSize: TablixObjects.getTextSizeInPx(textSize)
                    };
                    return new visuals.controls.TablixControl(matrixNavigator, layoutManager, matrixBinder, tablixContainer, tablixOptions);
                }, Matrix.prototype.updateInternal = function(textSize, previousDataView) {
                    var _this = this;
                    1 === this.getLayoutKind() && this.tablixControl.layoutManager.adjustContentSize(visuals.converterHelper.hasImageUrlColumn(this.dataView)), 
                    this.tablixControl.fontSize = TablixObjects.getTextSizeInPx(textSize), this.verifyHeaderResize(), 
                    this.tablixControl.updateModels(!this.persistingObjects, this.dataView.matrix.rows.root.children, this.dataView.matrix.columns.root.children), 
                    this.tablixControl.viewport = this.currentViewport;
                    var shouldClearControl = this.shouldClearControl(previousDataView, this.dataView);
                    setTimeout(function() {
                        _this.refreshControl(shouldClearControl);
                        var widthChanged = _this.columnWidthManager.onColumnsRendered(_this.tablixControl.layoutManager.columnWidthsToPersist);
                        _this.persistingObjects && !widthChanged && (_this.persistingObjects = !1);
                    }, 0);
                }, Matrix.prototype.shouldClearControl = function(previousDataView, newDataView) {
                    return this.waitingForSort && previousDataView && newDataView ? !powerbi.DataViewAnalysis.isMetadataEquivalent(previousDataView.metadata, newDataView.metadata) : !0;
                }, Matrix.prototype.onBindRowHeader = function(item) {
                    this.needsMoreData(item) && (this.hostServices.loadMoreData(), this.waitingForData = !0);
                }, Matrix.prototype.onColumnHeaderClick = function(queryName, sortDirection) {
                    this.waitingForSort = !0, this.hostServices.onCustomSort(TablixUtils.getCustomSortEventArgs(queryName, sortDirection));
                }, Matrix.prototype.needsMoreData = function(item) {
                    if (this.waitingForData || !this.hierarchyNavigator.isLeaf(item) || !this.dataView.metadata || !this.dataView.metadata.segment) return !1;
                    var leafCount = this.tablixControl.rowDimension.getItemsCount(), loadMoreThreshold = leafCount * Matrix.preferredLoadMoreThreshold;
                    return this.hierarchyNavigator.getLeafIndex(item) >= loadMoreThreshold;
                }, Matrix.prototype.enumerateObjectInstances = function(options) {
                    var enumeration = new visuals.ObjectEnumerationBuilder();
                    return this.dataView && TablixObjects.enumerateObjectInstances(options, enumeration, this.dataView, visuals.controls.TablixType.Matrix), 
                    enumeration.complete();
                }, Matrix.prototype.shouldAllowHeaderResize = function() {
                    return 1 === this.hostServices.getViewMode();
                }, Matrix.prototype.onViewModeChanged = function(viewMode) {
                    this.updateViewport(this.currentViewport);
                }, Matrix.prototype.verifyHeaderResize = function() {
                    var currentAllowHeaderResize = this.shouldAllowHeaderResize();
                    currentAllowHeaderResize !== this.lastAllowHeaderResize && (this.lastAllowHeaderResize = currentAllowHeaderResize, 
                    this.tablixControl.layoutManager.setAllowHeaderResize(currentAllowHeaderResize));
                }, Matrix.preferredLoadMoreThreshold = .8, Matrix.TotalLabel = "TableTotalLabel", 
                Matrix;
            }();
            visuals.Matrix = Matrix;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var CssConstants = jsCommon.CssConstants, Treemap = function() {
                function Treemap(options) {
                    this.tooltipsEnabled = options && options.tooltipsEnabled, this.tooltipBucketEnabled = options && options.tooltipBucketEnabled, 
                    options && options.animator && (this.animator = options.animator, this.isScrollable = options.isScrollable ? options.isScrollable : !1, 
                    this.behavior = options.behavior);
                }
                return Treemap.getLayout = function(labelsSettings, alternativeScale) {
                    var formattersCache = visuals.dataLabelUtils.createColumnFormatterCacheManager(), majorLabelsEnabled = labelsSettings.showCategory, minorLabelsEnabled = labelsSettings.show || labelsSettings.showCategory;
                    return {
                        shapeClass: function(d) {
                            return Treemap.getNodeClass(d, !1);
                        },
                        shapeLayout: Treemap.createTreemapShapeLayout(!1),
                        highlightShapeClass: function(d) {
                            return Treemap.getNodeClass(d, !0);
                        },
                        highlightShapeLayout: Treemap.createTreemapShapeLayout(!0),
                        zeroShapeLayout: Treemap.createTreemapZeroShapeLayout(),
                        majorLabelClass: function(d) {
                            return Treemap.MajorLabelClassName;
                        },
                        majorLabelLayout: {
                            x: function(d) {
                                return d.x + Treemap.TextMargin;
                            },
                            y: function(d) {
                                return d.y + Treemap.TextMargin + Treemap.MajorLabelTextSize;
                            }
                        },
                        majorLabelText: function(d) {
                            return Treemap.createMajorLabelText(d, labelsSettings, alternativeScale, formattersCache);
                        },
                        minorLabelClass: function(d) {
                            return Treemap.MinorLabelClassName;
                        },
                        minorLabelLayout: {
                            x: function(d) {
                                return d.x + Treemap.TextMargin;
                            },
                            y: function(d) {
                                return d.y + d.dy - Treemap.TextMargin;
                            }
                        },
                        minorLabelText: function(d) {
                            return Treemap.createMinorLabelText(d, labelsSettings, alternativeScale, formattersCache);
                        },
                        areMajorLabelsEnabled: function() {
                            return majorLabelsEnabled;
                        },
                        areMinorLabelsEnabled: function() {
                            return minorLabelsEnabled;
                        }
                    };
                }, Treemap.prototype.init = function(options) {
                    this.options = options;
                    var element = options.element;
                    element.empty(), this.svg = d3.select(element.get(0)).append("svg").style("position", "absolute").classed(Treemap.ClassName, !0), 
                    this.shapeGraphicsContext = this.svg.append("g").classed(Treemap.ShapesClassName, !0), 
                    this.labelGraphicsContext = this.svg.append("g").classed(Treemap.LabelsGroupClassName, !0), 
                    this.element = element, this.currentViewport = {
                        height: options.viewport.height,
                        width: options.viewport.width
                    }, this.style = options.style, this.treemap = d3.layout.treemap().sticky(!1).sort(function(a, b) {
                        return a.size - b.size;
                    }).value(function(d) {
                        return d.size;
                    }).round(!1), this.behavior && (this.interactivityService = visuals.createInteractivityService(options.host)), 
                    this.legend = visuals.createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, this.interactivityService, this.isScrollable), 
                    this.colors = this.style.colorPalette.dataColors, this.hostService = options.host;
                }, Treemap.converter = function(dataView, colors, labelSettings, interactivityService, viewport, legendObjectProperties, tooltipsEnabled, tooltipBucketEnabled) {
                    void 0 === tooltipsEnabled && (tooltipsEnabled = !0);
                    var hasNegativeValues, allValuesAreNegative, hasHighlights, reader = powerbi.data.createIDataViewCategoricalReader(dataView), rootNode = {
                        key: "root",
                        name: "root",
                        originalValue: void 0,
                        children: [],
                        selected: !1,
                        highlightMultiplier: 0,
                        identity: visuals.SelectionId.createNull(),
                        color: void 0
                    }, allNodes = [], legendDataPoints = [], legendTitle = "", colorHelper = new visuals.ColorHelper(colors, visuals.treemapProps.dataPoint.fill), dataWasCulled = void 0;
                    if (dataView && dataView.metadata && dataView.metadata.objects) {
                        var objects = dataView.metadata.objects;
                        labelSettings.show = powerbi.DataViewObjects.getValue(objects, visuals.treemapProps.labels.show, labelSettings.show), 
                        labelSettings.labelColor = powerbi.DataViewObjects.getFillColor(objects, visuals.treemapProps.labels.color, labelSettings.labelColor), 
                        labelSettings.displayUnits = powerbi.DataViewObjects.getValue(objects, visuals.treemapProps.labels.labelDisplayUnits, labelSettings.displayUnits), 
                        labelSettings.precision = powerbi.DataViewObjects.getValue(objects, visuals.treemapProps.labels.labelPrecision, labelSettings.precision), 
                        labelSettings.showCategory = powerbi.DataViewObjects.getValue(objects, visuals.treemapProps.categoryLabels.show, labelSettings.showCategory);
                    }
                    if (reader.hasValues(visuals.treemapRoles.values) || reader.hasValues(visuals.treemapRoles.gradient)) {
                        var valueColumnRoleName = reader.hasValues(visuals.treemapRoles.values) ? visuals.treemapRoles.values : visuals.treemapRoles.gradient, categorical = dataView.categorical;
                        hasHighlights = reader.hasHighlights(valueColumnRoleName);
                        var formatStringProp = visuals.treemapProps.general.formatString, result = Treemap.getValuesFromCategoricalDataView(dataView, hasHighlights, valueColumnRoleName), values = result.values, highlights = result.highlights, totalValue = result.totalValue;
                        result.highlightsOverflow && (hasHighlights = !1, values = highlights), hasNegativeValues = result.hasNegativeValues, 
                        allValuesAreNegative = result.allValuesAreNegative;
                        var cullableValue = Treemap.getCullableValue(totalValue, viewport), hasDynamicSeries = reader.hasDynamicSeries();
                        dataWasCulled = !1;
                        var gradientValueColumn = reader.getValueColumn(visuals.treemapRoles.gradient, 0);
                        if (null != categorical.categories || _.isEmpty(values)) {
                            if (categorical.categories && categorical.categories.length > 0) {
                                var seriesCount = reader.getSeriesCount(valueColumnRoleName), omitSecondLevel = 1 === seriesCount, categoryColumn = categorical.categories[0];
                                legendTitle = categoryColumn.source.displayName;
                                for (var categoryFormat = visuals.valueFormatter.getFormatString(categoryColumn.source, formatStringProp), categoryIndex = 0, categoryLen = values.length; categoryLen > categoryIndex; categoryIndex++) {
                                    var objects = categoryColumn.objects && categoryColumn.objects[categoryIndex], color = colorHelper.getColorForSeriesValue(objects, categoryColumn.identityFields, categoryColumn.values[categoryIndex]), categoryValue = visuals.valueFormatter.format(categoryColumn.values[categoryIndex], categoryFormat), currentValues = values[categoryIndex], seriesIndex = 0, value = currentValues[seriesIndex], highlightValue = hasHighlights && highlights ? highlights[categoryIndex][seriesIndex] : void 0, tooltipInfo = void 0, categoryTooltipItem = void 0;
                                    if (tooltipsEnabled) {
                                        tooltipInfo = [], categoryTooltipItem = {
                                            displayName: categoryColumn.source.displayName,
                                            value: categoryValue
                                        }, tooltipInfo.push(categoryTooltipItem);
                                        var valueColumnMetadata = reader.getValueMetadataColumn(valueColumnRoleName, seriesIndex);
                                        null != value && tooltipInfo.push({
                                            displayName: valueColumnMetadata.displayName,
                                            value: visuals.converterHelper.formatFromMetadataColumn(value, valueColumnMetadata, formatStringProp)
                                        }), null != highlightValue && tooltipInfo.push({
                                            displayName: visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName,
                                            value: visuals.converterHelper.formatFromMetadataColumn(highlightValue, valueColumnMetadata, formatStringProp)
                                        });
                                        var gradientValueColumnMetadata = gradientValueColumn ? gradientValueColumn.source : void 0;
                                        omitSecondLevel && gradientValueColumnMetadata && gradientValueColumnMetadata !== valueColumnMetadata && null != gradientValueColumn.values[categoryIndex] && tooltipInfo.push({
                                            displayName: gradientValueColumnMetadata.displayName,
                                            value: visuals.converterHelper.formatFromMetadataColumn(gradientValueColumn.values[categoryIndex], gradientValueColumnMetadata, formatStringProp)
                                        }), tooltipBucketEnabled && visuals.TooltipBuilder.addTooltipBucketItem(reader, tooltipInfo, categoryIndex, seriesIndex);
                                    }
                                    var identity = visuals.SelectionIdBuilder.builder().withCategory(categoryColumn, categoryIndex).withMeasure(omitSecondLevel ? reader.getValueMetadataColumn(valueColumnRoleName, seriesIndex).queryName : void 0).createSelectionId(), key = JSON.stringify({
                                        nodeKey: identity.getKey(),
                                        depth: 1
                                    }), node = {
                                        key: key,
                                        name: categoryValue,
                                        originalValue: void 0,
                                        color: color,
                                        selected: !1,
                                        identity: identity,
                                        tooltipInfo: tooltipInfo,
                                        highlightedTooltipInfo: tooltipInfo,
                                        labelFormatString: 1 === seriesCount ? visuals.valueFormatter.getFormatString(reader.getValueMetadataColumn(valueColumnRoleName, seriesIndex), formatStringProp) : categoryFormat
                                    };
                                    hasHighlights && (node.highlightMultiplier = 0 !== value ? highlightValue / value : 0, 
                                    node.highlightValue = allValuesAreNegative && null != highlightValue ? Math.abs(highlightValue) : highlightValue, 
                                    node.originalHighlightValue = highlightValue), legendDataPoints.push({
                                        label: categoryValue,
                                        color: color,
                                        icon: visuals.LegendIcon.Box,
                                        identity: identity,
                                        selected: !1
                                    });
                                    for (var total = 0, highlightTotal = 0; seriesCount > seriesIndex; seriesIndex++) {
                                        var valueColumn = reader.getValueColumn(valueColumnRoleName, seriesIndex), value_1 = currentValues[seriesIndex], highlight = void 0, valueShape = Treemap.checkValueForShape(value_1, cullableValue, allValuesAreNegative, dataWasCulled);
                                        if (dataWasCulled = valueShape.dataWasCulled, valueShape.validShape && (total += value_1, 
                                        hasHighlights && (highlight = highlights[categoryIndex][seriesIndex], highlightTotal += highlight), 
                                        !omitSecondLevel)) {
                                            var childName = null;
                                            childName = reader.hasDynamicSeries() ? visuals.converterHelper.formatFromMetadataColumn(reader.getSeriesName(seriesIndex), reader.getSeriesMetadataColumn(), formatStringProp) : visuals.converterHelper.formatFromMetadataColumn(reader.getValueDisplayName(valueColumnRoleName, seriesIndex), reader.getValueMetadataColumn(valueColumnRoleName, seriesIndex), formatStringProp);
                                            var categoricalValues = categorical ? categorical.values : null, measureId = valueColumn.source.queryName, childIdentity = visuals.SelectionIdBuilder.builder().withCategory(categoryColumn, categoryIndex).withSeries(categoricalValues, valueColumn).withMeasure(measureId).createSelectionId(), childKey = JSON.stringify({
                                                nodeKey: childIdentity.getKey(),
                                                depth: 2
                                            }), highlightedValue = hasHighlights && 0 !== highlight ? highlight : void 0, tooltipInfo_1 = void 0;
                                            tooltipsEnabled && (tooltipInfo_1 = [], tooltipInfo_1.push(categoryTooltipItem), 
                                            hasDynamicSeries && (categoryColumn && categoryColumn.source === categoricalValues.source || tooltipInfo_1.push({
                                                displayName: categoricalValues.source.displayName,
                                                value: visuals.converterHelper.formatFromMetadataColumn(reader.getSeriesName(seriesIndex), categoricalValues.source, formatStringProp)
                                            })), null != value_1 && tooltipInfo_1.push({
                                                displayName: valueColumn.source.displayName,
                                                value: visuals.converterHelper.formatFromMetadataColumn(value_1, valueColumn.source, formatStringProp)
                                            }), null != highlightValue && tooltipInfo_1.push({
                                                displayName: visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName,
                                                value: visuals.converterHelper.formatFromMetadataColumn(highlightedValue, valueColumn.source, formatStringProp)
                                            }), tooltipBucketEnabled && visuals.TooltipBuilder.addTooltipBucketItem(reader, tooltipInfo_1, categoryIndex, hasDynamicSeries ? seriesIndex : void 0));
                                            var childNode = {
                                                key: childKey,
                                                name: childName,
                                                size: allValuesAreNegative ? Math.abs(value_1) : value_1,
                                                originalValue: value_1,
                                                color: color,
                                                selected: !1,
                                                identity: childIdentity,
                                                tooltipInfo: tooltipInfo_1,
                                                highlightedTooltipInfo: tooltipInfo_1,
                                                labelFormatString: visuals.valueFormatter.getFormatString(valueColumn.source, formatStringProp)
                                            };
                                            hasHighlights && (childNode.highlightMultiplier = 0 !== value_1 ? highlight / value_1 : 0, 
                                            childNode.highlightValue = allValuesAreNegative && null != highlight ? Math.abs(highlight) : null, 
                                            childNode.originalHighlightValue = highlight), null == node.children && (node.children = []), 
                                            node.children.push(childNode), allNodes.push(childNode);
                                        }
                                    }
                                    total && (node.size = allValuesAreNegative ? Math.abs(total) : total, node.originalValue = total, 
                                    rootNode.children.push(node), allNodes.push(node)), hasHighlights && (node.highlightMultiplier = total ? highlightTotal / total : 0);
                                }
                            }
                        } else for (var seriesIndex = 0, seriesCount = reader.getSeriesCount(valueColumnRoleName); seriesCount > seriesIndex; seriesIndex++) {
                            var valueColumn = reader.getValueColumn(valueColumnRoleName, seriesIndex), value = values[0][seriesIndex], valueShape = Treemap.checkValueForShape(value, cullableValue, allValuesAreNegative, dataWasCulled);
                            if (dataWasCulled = valueShape.dataWasCulled, valueShape.validShape) {
                                var nodeName = hasDynamicSeries ? visuals.converterHelper.formatFromMetadataColumn(reader.getSeriesValueColumnGroup(seriesIndex).name, reader.getSeriesMetadataColumn(), formatStringProp) : visuals.converterHelper.formatFromMetadataColumn(reader.getValueDisplayName(valueColumnRoleName, seriesIndex), valueColumn.source, formatStringProp), identity = new visuals.SelectionIdBuilder().withSeries(dataView.categorical.values, hasDynamicSeries ? valueColumn : void 0).withMeasure(valueColumn.source.queryName).createSelectionId(), key = identity.getKey(), color = hasDynamicSeries ? colorHelper.getColorForSeriesValue(reader.getSeriesObjects(seriesIndex), categorical.values.identityFields, visuals.converterHelper.getSeriesName(valueColumn.source)) : colorHelper.getColorForMeasure(valueColumn.source.objects, valueColumn.source.queryName), highlightedValue = hasHighlights ? highlights[0][seriesIndex] : void 0, tooltipInfo = void 0;
                                if (tooltipsEnabled) {
                                    if (tooltipInfo = [], hasDynamicSeries) {
                                        var seriesMetadataColumn = reader.getSeriesMetadataColumn(), seriesValue = reader.getSeriesValueColumnGroup(seriesIndex).name;
                                        tooltipInfo.push({
                                            displayName: seriesMetadataColumn.displayName,
                                            value: visuals.converterHelper.formatFromMetadataColumn(seriesValue, seriesMetadataColumn, formatStringProp)
                                        });
                                    }
                                    null != value && tooltipInfo.push({
                                        displayName: valueColumn.source.displayName,
                                        value: visuals.converterHelper.formatFromMetadataColumn(value, valueColumn.source, formatStringProp)
                                    }), null != highlightedValue && tooltipInfo.push({
                                        displayName: visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName,
                                        value: visuals.converterHelper.formatFromMetadataColumn(highlightedValue, valueColumn.source, formatStringProp)
                                    }), tooltipBucketEnabled && visuals.TooltipBuilder.addTooltipBucketItem(reader, tooltipInfo, 0, hasDynamicSeries ? seriesIndex : void 0);
                                }
                                var node = {
                                    key: key,
                                    name: nodeName,
                                    size: allValuesAreNegative ? Math.abs(value) : value,
                                    originalValue: value,
                                    color: color,
                                    selected: !1,
                                    identity: identity,
                                    tooltipInfo: tooltipInfo,
                                    highlightedTooltipInfo: tooltipInfo,
                                    labelFormatString: visuals.valueFormatter.getFormatString(valueColumn.source, formatStringProp)
                                };
                                hasHighlights && highlights && (node.highlightMultiplier = 0 !== value ? highlightedValue / value : 0, 
                                node.highlightValue = allValuesAreNegative && null != highlightedValue ? Math.abs(highlightedValue) : highlightedValue, 
                                node.originalHighlightValue = highlightedValue), rootNode.children.push(node), allNodes.push(node), 
                                legendDataPoints.push({
                                    label: nodeName,
                                    color: color,
                                    icon: visuals.LegendIcon.Box,
                                    identity: identity,
                                    selected: !1
                                });
                            }
                        }
                    }
                    return interactivityService && (interactivityService.applySelectionStateToData(allNodes), 
                    interactivityService.applySelectionStateToData(legendDataPoints)), {
                        root: rootNode,
                        hasHighlights: hasHighlights,
                        legendData: {
                            title: legendTitle,
                            dataPoints: legendDataPoints,
                            fontSize: visuals.SVGLegend.DefaultFontSizeInPt
                        },
                        dataLabelsSettings: labelSettings,
                        legendObjectProperties: legendObjectProperties,
                        dataWasCulled: dataWasCulled,
                        hasNegativeValues: hasNegativeValues,
                        allValuesAreNegative: allValuesAreNegative
                    };
                }, Treemap.normalizedValue = function(value, allValuesAreNegative) {
                    return null == value || isNaN(value) ? 0 : value === Number.POSITIVE_INFINITY ? Number.MAX_VALUE : value === Number.NEGATIVE_INFINITY ? -Number.MAX_VALUE : allValuesAreNegative ? Math.abs(value) : 0 > value ? 0 : value;
                }, Treemap.getValuesFromCategoricalDataView = function(dataView, hasHighlights, valueColumnRoleName) {
                    for (var reader = powerbi.data.createIDataViewCategoricalReader(dataView), categoryCount = reader.getCategoryCount() || 1, seriesCount = reader.getSeriesCount(valueColumnRoleName), values = [], highlights = [], totalValue = 0, i = 0; categoryCount > i; i++) values.push([]), 
                    hasHighlights && highlights.push([]);
                    for (var hasNegativeValues, highlightsOverflow, allValuesAreNegative = void 0, seriesIndex = 0; seriesCount > seriesIndex; seriesIndex++) for (var categoryIndex = 0; categoryCount > categoryIndex; categoryIndex++) {
                        var value = reader.getValue(valueColumnRoleName, categoryIndex, seriesIndex);
                        values[categoryIndex].push(value);
                        var highlight = void 0;
                        hasHighlights && (highlight = reader.getHighlight(valueColumnRoleName, categoryIndex, seriesIndex), 
                        highlights[categoryIndex].push(highlight), null == highlight && (highlight = 0)), 
                        allValuesAreNegative = void 0 === allValuesAreNegative ? (hasHighlights ? 0 >= highlight : !0) && 0 >= value : allValuesAreNegative && (hasHighlights ? 0 >= highlight : !0) && 0 >= value, 
                        hasNegativeValues || (hasNegativeValues = 0 > value || (hasHighlights ? 0 > highlight : !1));
                    }
                    allValuesAreNegative = !!allValuesAreNegative;
                    for (var seriesIndex = 0; seriesCount > seriesIndex; seriesIndex++) for (var categoryIndex = 0; categoryCount > categoryIndex; categoryIndex++) {
                        var value = values[categoryIndex][seriesIndex];
                        if (value = Treemap.normalizedValue(value, allValuesAreNegative), totalValue += value, 
                        hasHighlights) {
                            var highlight = highlights[categoryIndex][seriesIndex];
                            highlight = Treemap.normalizedValue(highlight, allValuesAreNegative), !highlightsOverflow && highlight > value && (highlightsOverflow = !0);
                        }
                    }
                    return {
                        values: values,
                        highlights: hasHighlights ? highlights : void 0,
                        highlightsOverflow: hasHighlights ? highlightsOverflow : void 0,
                        totalValue: allValuesAreNegative ? Math.abs(totalValue) : totalValue,
                        hasNegativeValues: hasNegativeValues,
                        allValuesAreNegative: allValuesAreNegative
                    };
                }, Treemap.getCullableValue = function(totalValue, viewport) {
                    var totalArea = viewport.width * viewport.height, culledPercent = Treemap.CullableArea / totalArea;
                    return culledPercent * totalValue;
                }, Treemap.prototype.update = function(options) {
                    var dataViews = this.dataViews = options.dataViews;
                    this.currentViewport = options.viewport;
                    var dataViewCategorical = dataViews && dataViews.length > 0 && dataViews[0].categorical ? dataViews[0].categorical : void 0, labelSettings = visuals.dataLabelUtils.getDefaultTreemapLabelSettings(), legendObjectProperties = null;
                    if (dataViewCategorical) {
                        var dataView = dataViews[0], dataViewMetadata = dataView.metadata, objects = void 0;
                        dataViewMetadata && (objects = dataViewMetadata.objects), objects && (legendObjectProperties = objects.legend), 
                        this.data = Treemap.converter(dataView, this.colors, labelSettings, this.interactivityService, this.currentViewport, legendObjectProperties, this.tooltipsEnabled, this.tooltipBucketEnabled);
                    } else {
                        var rootNode = {
                            key: "root",
                            name: "root",
                            originalValue: void 0,
                            children: [],
                            selected: !1,
                            highlightMultiplier: 0,
                            identity: visuals.SelectionId.createNull(),
                            color: void 0
                        }, legendData = {
                            title: "",
                            dataPoints: []
                        }, treeMapData = {
                            root: rootNode,
                            hasHighlights: !1,
                            legendData: legendData,
                            dataLabelsSettings: labelSettings,
                            dataWasCulled: !1,
                            hasNegativeValues: !1,
                            allValuesAreNegative: !1
                        };
                        this.data = treeMapData;
                    }
                    if (this.updateInternal(options.suppressAnimations), dataViews) {
                        var warnings = visuals.getInvalidValueWarnings(dataViews, !1, !1, !1);
                        this.data.allValuesAreNegative ? warnings.push(new visuals.AllNegativeValuesWarning()) : this.data.hasNegativeValues && warnings.push(new visuals.NegativeValuesNotSupportedWarning()), 
                        this.hostService.setWarnings(warnings);
                    }
                }, Treemap.prototype.onDataChanged = function(options) {
                    this.update({
                        suppressAnimations: options.suppressAnimations,
                        dataViews: options.dataViews,
                        viewport: this.currentViewport
                    });
                }, Treemap.prototype.onResizing = function(viewport) {
                    this.update({
                        suppressAnimations: !0,
                        dataViews: this.dataViews,
                        viewport: viewport
                    });
                }, Treemap.prototype.onClearSelection = function() {
                    this.interactivityService && this.interactivityService.clearSelection();
                }, Treemap.prototype.enumerateObjectInstances = function(options) {
                    var data = this.data;
                    if (data) {
                        var objectName = options.objectName, enumeration = new visuals.ObjectEnumerationBuilder(), dataLabelsSettings = this.data.dataLabelsSettings ? this.data.dataLabelsSettings : visuals.dataLabelUtils.getDefaultTreemapLabelSettings();
                        switch (objectName) {
                          case "dataPoint":
                            var dataViewCat = this.dataViews && this.dataViews.length > 0 && this.dataViews[0] && this.dataViews[0].categorical, hasGradientRole = visuals.GradientUtils.hasGradientRole(dataViewCat);
                            hasGradientRole || this.enumerateDataPoints(enumeration, data);
                            break;

                          case "legend":
                            return this.enumerateLegend(data);

                          case "labels":
                            var labelSettingOptions = {
                                enumeration: enumeration,
                                dataLabelsSettings: dataLabelsSettings,
                                show: !0,
                                displayUnits: !0,
                                precision: !0
                            };
                            visuals.dataLabelUtils.enumerateDataLabels(labelSettingOptions);
                            break;

                          case "categoryLabels":
                            visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, dataLabelsSettings, !1, !0);
                        }
                        return enumeration.complete();
                    }
                }, Treemap.prototype.enumerateDataPoints = function(enumeration, data) {
                    var rootChildren = data.root.children;
                    if (!_.isEmpty(rootChildren)) for (var y = 0; y < rootChildren.length; y++) {
                        var treemapNode = rootChildren[y];
                        enumeration.pushInstance({
                            displayName: treemapNode.name,
                            selector: visuals.ColorHelper.normalizeSelector(treemapNode.identity.getSelector()),
                            properties: {
                                fill: {
                                    solid: {
                                        color: treemapNode.color
                                    }
                                }
                            },
                            objectName: "dataPoint"
                        });
                    }
                }, Treemap.prototype.enumerateLegend = function(data) {
                    var legendObjectProperties = {
                        legend: data.legendObjectProperties
                    }, show = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.treemapProps.legend.show, this.legend.isVisible()), showTitle = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.treemapProps.legend.showTitle, !0), titleText = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.treemapProps.legend.titleText, this.data.legendData.title), labelColor = powerbi.DataViewObject.getValue(legendObjectProperties, visuals.legendProps.labelColor, this.data.legendData ? this.data.legendData.labelColor : visuals.LegendData.DefaultLegendLabelFillColor), labelFontSize = powerbi.DataViewObject.getValue(legendObjectProperties, visuals.legendProps.fontSize, this.data.legendData && this.data.legendData.fontSize ? this.data.legendData.fontSize : visuals.SVGLegend.DefaultFontSizeInPt), position = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.treemapProps.legend.position, visuals.legendPosition.top);
                    return [ {
                        selector: null,
                        objectName: "legend",
                        properties: {
                            show: show,
                            position: position,
                            showTitle: showTitle,
                            titleText: titleText,
                            labelColor: labelColor,
                            fontSize: labelFontSize
                        }
                    } ];
                }, Treemap.checkValueForShape = function(value, cullableValue, allValuesAreNegative, dataWasCulled) {
                    var shouldCullValue = void 0;
                    return value ? (shouldCullValue = allValuesAreNegative ? Math.abs(value) < cullableValue : cullableValue > value, 
                    shouldCullValue ? (dataWasCulled = dataWasCulled || shouldCullValue, {
                        validShape: !1,
                        dataWasCulled: dataWasCulled
                    }) : {
                        validShape: !0,
                        dataWasCulled: dataWasCulled
                    }) : {
                        validShape: !1,
                        dataWasCulled: dataWasCulled
                    };
                }, Treemap.prototype.calculateTreemapSize = function() {
                    var legendMargins = this.legend.getMargins();
                    return {
                        height: this.currentViewport.height - legendMargins.height,
                        width: this.currentViewport.width - legendMargins.width
                    };
                }, Treemap.prototype.initViewportDependantProperties = function(duration) {
                    void 0 === duration && (duration = 0);
                    var viewport = this.calculateTreemapSize();
                    this.svg.attr({
                        width: viewport.width,
                        height: viewport.height
                    }), visuals.Legend.positionChartArea(this.svg, this.legend), visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
                }, Treemap.hasChildrenWithIdentity = function(node) {
                    var children = node.children;
                    if (!children) return !1;
                    var count = children.length;
                    if (0 === count) return !1;
                    for (var i = count - 1; i >= 0; i--) if (children[i].identity.hasIdentity()) return !0;
                    return !1;
                }, Treemap.canDisplayMajorLabel = function(node) {
                    if (1 !== node.depth) return !1;
                    if (_.isEmpty(node.name)) return !1;
                    var availableWidth = node.dx - 2 * Treemap.TextMargin;
                    if (availableWidth < Treemap.MinTextWidthForMajorLabel) return !1;
                    var textHeightWithMargin = Treemap.MajorLabelTextSize + 2 * Treemap.TextMargin;
                    return !(node.dy < textHeightWithMargin);
                }, Treemap.canDisplayMinorLabel = function(node, labelSettings) {
                    if (node.depth < 1 || node.depth > 2) return !1;
                    if (1 === node.depth && (node.children || !labelSettings.show)) return !1;
                    if (_.isEmpty(node.name)) return !1;
                    var availableWidth = node.dx - 2 * Treemap.TextMargin;
                    if (availableWidth < Treemap.MinTextWidthForMinorLabel) return !1;
                    var textHeightWithMargin = Treemap.MinorLabelTextSize + 2 * Treemap.TextMargin;
                    if (node.dy < textHeightWithMargin) return !1;
                    if (1 === node.depth) {
                        var roomTop = node.y + Treemap.MajorLabelTextSize + 2 * Treemap.TextMargin;
                        if (node.y + node.dy - roomTop < textHeightWithMargin) return !1;
                    } else if (2 === node.depth) {
                        var parent_1 = node.parent, roomTop = Math.max(parent_1.y + Treemap.MajorLabelTextSize + 2 * Treemap.TextMargin, node.y);
                        if (node.y + node.dy - roomTop < textHeightWithMargin) return !1;
                    }
                    return !0;
                }, Treemap.createMajorLabelText = function(node, labelsSettings, alternativeScale, formattersCache) {
                    var spaceAvaliableForLabels = node.dx - 2 * Treemap.TextMargin, baseTextProperties = Treemap.MajorLabelTextProperties, textProperties = {
                        text: node.name,
                        fontFamily: baseTextProperties.fontFamily,
                        fontSize: baseTextProperties.fontSize
                    };
                    return powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, spaceAvaliableForLabels);
                }, Treemap.createMinorLabelText = function(node, labelsSettings, alternativeScale, formattersCache) {
                    var spaceAvaliableForLabels = node.dx - 2 * Treemap.TextMargin, label = node.name;
                    if (labelsSettings.show) {
                        var measureFormatter = formattersCache.getOrCreate(node.labelFormatString, labelsSettings, alternativeScale);
                        label = visuals.dataLabelUtils.getLabelFormattedText({
                            label: null != node.originalHighlightValue ? node.originalHighlightValue : node.originalValue,
                            maxWidth: spaceAvaliableForLabels,
                            formatter: measureFormatter
                        }), labelsSettings.showCategory && 2 === node.depth && (label = visuals.dataLabelUtils.getLabelFormattedText({
                            label: node.name,
                            maxWidth: spaceAvaliableForLabels
                        }) + " " + label);
                    }
                    return visuals.dataLabelUtils.getLabelFormattedText({
                        label: label,
                        maxWidth: spaceAvaliableForLabels,
                        fontSize: labelsSettings.fontSize
                    });
                }, Treemap.getFill = function(d, isHighlightRect) {
                    return d.depth > 1 && !d.identity.hasIdentity() && !isHighlightRect ? CssConstants.noneValue : Treemap.hasChildrenWithIdentity(d) ? CssConstants.noneValue : d.color;
                }, Treemap.getFillOpacity = function(d, hasSelection, hasHighlights, isHighlightRect) {
                    return hasHighlights ? isHighlightRect ? null : Treemap.DimmedShapeOpacity.toString() : !hasSelection || d.selected ? null : d.depth > 1 && d.parent.selected ? null : Treemap.hasChildrenWithIdentity(d) ? null : Treemap.DimmedShapeOpacity.toString();
                }, Treemap.prototype.updateInternal = function(suppressAnimations) {
                    var data = this.data, hasHighlights = data && data.hasHighlights, labelSettings = data ? data.dataLabelsSettings : null, duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                    this.options.interactivity && this.options.interactivity.isInteractiveLegend || !this.data || this.renderLegend(), 
                    this.initViewportDependantProperties(duration);
                    var viewport = this.calculateTreemapSize();
                    this.treemap.size([ viewport.width, viewport.height ]);
                    var nodes = data && data.root ? this.treemap.nodes(data.root) : [], highlightNodes = nodes.filter(function(value) {
                        return null != value.highlightMultiplier && (!value.children || 0 === value.children.length);
                    }), majorLabeledNodes = [], minorLabeledNodes = [], alternativeScale = null;
                    labelSettings.showCategory && (majorLabeledNodes = nodes.filter(function(d) {
                        return Treemap.canDisplayMajorLabel(d);
                    })), (labelSettings.show || labelSettings.showCategory) && (minorLabeledNodes = nodes.filter(function(d) {
                        return Treemap.canDisplayMinorLabel(d, labelSettings);
                    }), 0 === labelSettings.displayUnits && (alternativeScale = d3.max(minorLabeledNodes, function(d) {
                        return Math.abs(d.value);
                    })));
                    var shapes, highlightShapes, majorLabels, minorLabels, result, treemapLayout = Treemap.getLayout(labelSettings, alternativeScale);
                    if (this.animator && !suppressAnimations) {
                        var options = {
                            viewModel: data,
                            nodes: nodes,
                            highlightNodes: highlightNodes,
                            majorLabeledNodes: majorLabeledNodes,
                            minorLabeledNodes: minorLabeledNodes,
                            shapeGraphicsContext: this.shapeGraphicsContext,
                            labelGraphicsContext: this.labelGraphicsContext,
                            interactivityService: this.interactivityService,
                            layout: treemapLayout,
                            labelSettings: labelSettings
                        };
                        result = this.animator.animate(options), shapes = result.shapes, highlightShapes = result.highlightShapes, 
                        majorLabels = result.majorLabels, minorLabels = result.minorLabels;
                    }
                    if (!this.animator || suppressAnimations || result.failed) {
                        var hasSelection = this.interactivityService && this.interactivityService.hasSelection(), shapeGraphicsContext = this.shapeGraphicsContext;
                        shapes = Treemap.drawDefaultShapes(shapeGraphicsContext, nodes, hasSelection, hasHighlights, treemapLayout), 
                        highlightShapes = Treemap.drawDefaultHighlightShapes(shapeGraphicsContext, highlightNodes, hasSelection, hasHighlights, treemapLayout);
                        var labelGraphicsContext = this.labelGraphicsContext;
                        majorLabels = Treemap.drawDefaultMajorLabels(labelGraphicsContext, majorLabeledNodes, labelSettings, treemapLayout), 
                        minorLabels = Treemap.drawDefaultMinorLabels(labelGraphicsContext, minorLabeledNodes, labelSettings, treemapLayout);
                    }
                    if (this.interactivityService) {
                        var behaviorOptions = {
                            shapes: shapes,
                            highlightShapes: highlightShapes,
                            majorLabels: majorLabels,
                            minorLabels: minorLabels,
                            nodes: nodes,
                            hasHighlights: data.hasHighlights
                        };
                        this.interactivityService.bind(nodes, this.behavior, behaviorOptions);
                    }
                    this.tooltipsEnabled && (visuals.TooltipManager.addTooltip(shapes, function(tooltipEvent) {
                        return tooltipEvent.data.highlightedTooltipInfo ? tooltipEvent.data.highlightedTooltipInfo : tooltipEvent.data.tooltipInfo;
                    }), visuals.TooltipManager.addTooltip(highlightShapes, function(tooltipEvent) {
                        return tooltipEvent.data.highlightedTooltipInfo;
                    })), visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
                }, Treemap.prototype.renderLegend = function() {
                    var legendObjectProperties = this.data.legendObjectProperties;
                    if (legendObjectProperties) {
                        var legendData = this.data.legendData;
                        visuals.LegendData.update(legendData, legendObjectProperties);
                        var position = legendObjectProperties[visuals.legendProps.position];
                        position && this.legend.changeOrientation(visuals.LegendPosition[position]), this.legend.drawLegend(legendData, this.currentViewport);
                    } else this.legend.changeOrientation(visuals.LegendPosition.Top), this.legend.drawLegend({
                        dataPoints: []
                    }, this.currentViewport);
                }, Treemap.getNodeClass = function(d, highlight) {
                    var nodeClass;
                    switch (d.depth) {
                      case 1:
                        nodeClass = Treemap.ParentGroupClassName;
                        break;

                      case 2:
                        nodeClass = Treemap.NodeGroupClassName;
                        break;

                      case 0:
                        nodeClass = Treemap.RootNodeClassName;
                    }
                    return nodeClass += " " + (highlight ? Treemap.HighlightNodeClassName : Treemap.TreemapNodeClassName);
                }, Treemap.createTreemapShapeLayout = function(isHighlightRect) {
                    return void 0 === isHighlightRect && (isHighlightRect = !1), {
                        x: function(d) {
                            return d.x;
                        },
                        y: function(d) {
                            return d.y + (isHighlightRect ? d.dy * (1 - d.highlightMultiplier) : 0);
                        },
                        width: function(d) {
                            return Math.max(0, d.dx);
                        },
                        height: function(d) {
                            return Math.max(0, d.dy * (isHighlightRect ? d.highlightMultiplier : 1));
                        }
                    };
                }, Treemap.createTreemapZeroShapeLayout = function() {
                    return {
                        x: function(d) {
                            return d.x;
                        },
                        y: function(d) {
                            return d.y + d.dy;
                        },
                        width: function(d) {
                            return Math.max(0, d.dx);
                        },
                        height: function(d) {
                            return 0;
                        }
                    };
                }, Treemap.drawDefaultShapes = function(context, nodes, hasSelection, hasHighlights, layout) {
                    var isHighlightShape = !1, shapes = context.selectAll("." + Treemap.TreemapNodeClassName).data(nodes, function(d) {
                        return d.key;
                    });
                    return shapes.enter().append("rect").attr("class", layout.shapeClass), shapes.style("fill", function(d) {
                        return Treemap.getFill(d, isHighlightShape);
                    }).style("fill-opacity", function(d) {
                        return Treemap.getFillOpacity(d, hasSelection, hasHighlights, isHighlightShape);
                    }).attr(layout.shapeLayout), shapes.exit().remove(), shapes;
                }, Treemap.drawDefaultHighlightShapes = function(context, nodes, hasSelection, hasHighlights, layout) {
                    var isHighlightShape = !0, highlightShapes = context.selectAll("." + Treemap.HighlightNodeClassName).data(nodes, function(d) {
                        return d.key + "highlight";
                    });
                    return highlightShapes.enter().append("rect").attr("class", layout.highlightShapeClass), 
                    highlightShapes.style("fill", function(d) {
                        return Treemap.getFill(d, isHighlightShape);
                    }).style("fill-opacity", function(d) {
                        return Treemap.getFillOpacity(d, hasSelection, hasHighlights, isHighlightShape);
                    }).attr(layout.highlightShapeLayout), highlightShapes.exit().remove(), highlightShapes;
                }, Treemap.drawDefaultMajorLabels = function(context, nodes, labelSettings, layout) {
                    var labels = context.selectAll("." + Treemap.MajorLabelClassName).data(nodes, function(d) {
                        return d.key;
                    });
                    return labels.enter().append("text").attr("class", layout.majorLabelClass), labels.attr(layout.majorLabelLayout).text(layout.majorLabelText).style("fill", function() {
                        return labelSettings.labelColor;
                    }), labels.exit().remove(), labels;
                }, Treemap.drawDefaultMinorLabels = function(context, nodes, labelSettings, layout) {
                    var labels = context.selectAll("." + Treemap.MinorLabelClassName).data(nodes, function(d) {
                        return d.key;
                    });
                    return labels.enter().append("text").attr("class", layout.minorLabelClass), labels.attr(layout.minorLabelLayout).text(layout.minorLabelText).style("fill", function() {
                        return labelSettings.labelColor;
                    }), labels.exit().remove(), labels;
                }, Treemap.cleanMinorLabels = function(context) {
                    var empty = [], labels = context.selectAll("." + Treemap.LabelsGroupClassName).selectAll("." + Treemap.MinorLabelClassName).data(empty);
                    labels.exit().remove();
                }, Treemap.DimmedShapeOpacity = .4, Treemap.ClassName = "treemap", Treemap.LabelsGroupClassName = "labels", 
                Treemap.MajorLabelClassName = "majorLabel", Treemap.MinorLabelClassName = "minorLabel", 
                Treemap.ShapesClassName = "shapes", Treemap.TreemapNodeClassName = "treemapNode", 
                Treemap.RootNodeClassName = "rootNode", Treemap.ParentGroupClassName = "parentGroup", 
                Treemap.NodeGroupClassName = "nodeGroup", Treemap.HighlightNodeClassName = "treemapNodeHighlight", 
                Treemap.TextMargin = 5, Treemap.MinorLabelTextSize = 10, Treemap.MinTextWidthForMinorLabel = 18, 
                Treemap.MajorLabelTextSize = 12, Treemap.MinTextWidthForMajorLabel = 22, Treemap.MajorLabelTextProperties = {
                    fontFamily: visuals.Font.Family.regular.css,
                    fontSize: Treemap.MajorLabelTextSize + "px"
                }, Treemap.CullableArea = 9, Treemap;
            }();
            visuals.Treemap = Treemap;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi, __extends = (window.powerbitests, 
    window.InJs, window.debug, window.jasmine, window.Microsoft, this && this.__extends || function(d, b) {
        function __() {
            this.constructor = d;
        }
        for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
    });
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var getKpiImageMetadata = powerbi.visuals.KpiUtil.getKpiImageMetadata, createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, Card = function(_super) {
                function Card(options) {
                    _super.call(this, Card.cardClassName), this.isScrollable = !1, this.displayUnitSystemType = powerbi.DisplayUnitSystemType.WholeUnits, 
                    options && (this.isScrollable = !!options.isScrollable, options.animator && (this.animator = options.animator), 
                    null != options.displayUnitSystemType && (this.displayUnitSystemType = options.displayUnitSystemType), 
                    options.cardSmallViewportProperties && (this.cardSmallViewportProperties = options.cardSmallViewportProperties));
                }
                return __extends(Card, _super), Card.prototype.init = function(options) {
                    this.animationOptions = options.animation;
                    var element = options.element;
                    this.kpiImage = d3.select(element.get(0)).append("div").classed(Card.KPIImage["class"], !0);
                    var svg = this.svg = d3.select(element.get(0)).append("svg");
                    this.graphicsContext = svg.append("g"), this.currentViewport = options.viewport, 
                    this.hostServices = options.host, this.style = options.style, this.updateViewportProperties(), 
                    this.isScrollable && (svg.attr("class", Card.cardClassName), this.labelContext = svg.append("g"));
                }, Card.prototype.onDataChanged = function(options) {
                    var value, dataView = options.dataViews[0];
                    if (dataView) {
                        this.getMetaDataColumn(dataView), dataView.single && (value = dataView.single.value), 
                        this.cardFormatSetting = this.getDefaultFormatSettings();
                        var dataViewMetadata = dataView.metadata;
                        if (dataViewMetadata) {
                            var objects = dataViewMetadata.objects;
                            if (objects) {
                                var labelSettings = this.cardFormatSetting.labelSettings;
                                labelSettings.labelColor = powerbi.DataViewObjects.getFillColor(objects, visuals.cardProps.labels.color, labelSettings.labelColor), 
                                labelSettings.precision = powerbi.DataViewObjects.getValue(objects, visuals.cardProps.labels.labelPrecision, labelSettings.precision), 
                                labelSettings.fontSize = powerbi.DataViewObjects.getValue(objects, visuals.cardProps.labels.fontSize, labelSettings.fontSize), 
                                labelSettings.precision !== visuals.dataLabelUtils.defaultLabelPrecision && labelSettings.precision < 0 && (labelSettings.precision = 0), 
                                labelSettings.displayUnits = powerbi.DataViewObjects.getValue(objects, visuals.cardProps.labels.labelDisplayUnits, labelSettings.displayUnits), 
                                labelSettings.showCategory = powerbi.DataViewObjects.getValue(objects, visuals.cardProps.categoryLabels.show, labelSettings.showCategory), 
                                labelSettings.categoryLabelColor = powerbi.DataViewObjects.getFillColor(objects, visuals.cardProps.categoryLabels.color, labelSettings.categoryLabelColor), 
                                this.cardFormatSetting.wordWrap = powerbi.DataViewObjects.getValue(objects, visuals.cardProps.wordWrap.show, this.cardFormatSetting.wordWrap), 
                                this.cardFormatSetting.textSize = powerbi.DataViewObjects.getValue(objects, visuals.cardProps.categoryLabels.fontSize, this.cardFormatSetting.textSize);
                            }
                        }
                    }
                    this.updateInternal(value, !0, !0);
                }, Card.prototype.onResizing = function(viewport) {
                    this.currentViewport = viewport, this.updateViewportProperties(), this.updateInternal(this.value, !0, !0);
                }, Card.prototype.updateViewportProperties = function() {
                    var viewport = this.currentViewport;
                    this.svg.attr("width", viewport.width).attr("height", viewport.height);
                }, Card.prototype.setTextProperties = function(text, fontSize) {
                    Card.cardTextProperties.fontSize = jsCommon.PixelConverter.fromPoint(fontSize), 
                    Card.cardTextProperties.text = text;
                }, Card.prototype.getCardFormatTextSize = function() {
                    return this.cardFormatSetting.textSize;
                }, Card.prototype.isSmallViewport = function() {
                    return !!(this.cardSmallViewportProperties && this.currentViewport.width < this.cardSmallViewportProperties.cardSmallViewportWidth);
                }, Card.prototype.getCardPrecision = function(isSmallViewport) {
                    return void 0 === isSmallViewport && (isSmallViewport = !1), isSmallViewport ? visuals.dataLabelUtils.defaultLabelPrecision : this.cardFormatSetting.labelSettings.precision;
                }, Card.prototype.getCardDisplayUnits = function(isSmallViewport) {
                    return void 0 === isSmallViewport && (isSmallViewport = !1), isSmallViewport ? 0 : this.cardFormatSetting.labelSettings.displayUnits;
                }, Card.prototype.getAdjustedFontHeight = function(availableWidth, textToMeasure, seedFontHeight) {
                    var adjustedFontHeight = _super.prototype.getAdjustedFontHeight.call(this, availableWidth, textToMeasure, seedFontHeight);
                    return Math.min(adjustedFontHeight, Card.DefaultStyle.card.maxFontSize);
                }, Card.prototype.clear = function(valueOnly) {
                    void 0 === valueOnly && (valueOnly = !1), this.svg.select(Card.Value.selector).text(""), 
                    valueOnly || this.svg.select(Card.Label.selector).text(""), _super.prototype.clear.call(this);
                }, Card.prototype.updateInternal = function(target, suppressAnimations, forceUpdate) {
                    void 0 === forceUpdate && (forceUpdate = !1);
                    var start = this.value, duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                    if (void 0 === target) return void (void 0 !== start && this.clear());
                    var metaDataColumn = this.metaDataColumn, labelSettings = this.cardFormatSetting.labelSettings, isSmallViewport = this.isSmallViewport(), precision = this.getCardPrecision(isSmallViewport), displayUnits = this.getCardDisplayUnits(isSmallViewport), isDefaultDisplayUnit = 0 === displayUnits, format = this.getFormatString(metaDataColumn), formatter = visuals.valueFormatter.create({
                        format: format,
                        value: isDefaultDisplayUnit ? target : displayUnits,
                        precision: visuals.dataLabelUtils.getLabelPrecision(precision, format),
                        displayUnitSystemType: isDefaultDisplayUnit && precision === visuals.dataLabelUtils.defaultLabelPrecision ? this.displayUnitSystemType : powerbi.DisplayUnitSystemType.WholeUnits,
                        formatSingleValues: !!isDefaultDisplayUnit,
                        allowFormatBeautification: !0,
                        columnType: metaDataColumn ? metaDataColumn.type : void 0
                    }), formatSettings = this.cardFormatSetting, valueTextHeightInPx = jsCommon.PixelConverter.fromPointToPixel(labelSettings.fontSize), valueStyles = Card.DefaultStyle.value;
                    this.setTextProperties(target, this.getCardFormatTextSize());
                    var labelTextHeightInPx = labelSettings.showCategory ? powerbi.TextMeasurementService.estimateSvgTextHeight(Card.cardTextProperties) : 0, labelHeightWithPadding = labelTextHeightInPx + Card.DefaultStyle.label.paddingTop, width = this.currentViewport.width, height = this.currentViewport.height, translateX = this.getTranslateX(width), translateY = (height - labelHeightWithPadding - valueTextHeightInPx) / 2, statusGraphicInfo = getKpiImageMetadata(metaDataColumn, target, 1);
                    if (this.isScrollable) {
                        if (!forceUpdate && start === target) return;
                        if (start === target || !_.isEmpty(target) && "string" == typeof target || (target = formatter.format(target)), 
                        statusGraphicInfo) this.graphicsContext.selectAll("text").remove(), this.displayStatusGraphic(statusGraphicInfo, translateX, translateY, valueTextHeightInPx); else {
                            this.kpiImage.selectAll("div").remove();
                            var translatedValueY = this.getTranslateY(valueTextHeightInPx + translateY), valueElement = this.graphicsContext.attr("transform", visuals.SVGUtil.translate(translateX, translatedValueY)).selectAll("text").data([ target ]);
                            if (valueElement.enter().append("text").attr("class", Card.Value["class"]), valueElement.text(function(d) {
                                return d;
                            }).style({
                                "font-size": jsCommon.PixelConverter.fromPoint(labelSettings.fontSize),
                                fill: labelSettings.labelColor,
                                "font-family": valueStyles.fontFamily,
                                "text-anchor": this.getTextAnchor()
                            }), formatSettings.wordWrap) {
                                var valueElementNode = valueElement.node();
                                powerbi.TextMeasurementService.wordBreak(valueElementNode, width, height - labelHeightWithPadding);
                                var numLines = valueElementNode.childElementCount;
                                if (numLines > 1) {
                                    var valueTextLineHeight = valueTextHeightInPx;
                                    valueTextHeightInPx *= numLines, translateY = (height - labelHeightWithPadding - valueTextHeightInPx) / 2, 
                                    translatedValueY = this.getTranslateY(valueTextLineHeight + translateY), this.graphicsContext.attr("transform", visuals.SVGUtil.translate(translateX, translatedValueY));
                                }
                            } else valueElement.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width, powerbi.TextMeasurementService.svgEllipsis);
                            valueElement.append("title").text(function(d) {
                                return d;
                            }), valueElement.exit().remove();
                        }
                        if (labelSettings.showCategory && metaDataColumn && metaDataColumn.displayName) {
                            var labelData = [ metaDataColumn.displayName ], translatedLabelY = this.getTranslateY(valueTextHeightInPx + labelHeightWithPadding + translateY), labelElement = this.labelContext.attr("transform", visuals.SVGUtil.translate(translateX, translatedLabelY)).selectAll("text").data(labelData);
                            labelElement.enter().append("text").attr("class", Card.Label["class"]), labelElement.text(function(d) {
                                return d;
                            }).style({
                                "font-size": jsCommon.PixelConverter.fromPoint(this.getCardFormatTextSize()),
                                fill: labelSettings.categoryLabelColor,
                                "text-anchor": this.getTextAnchor()
                            });
                            var labelElementNode = labelElement.node();
                            labelElementNode && (formatSettings.wordWrap ? powerbi.TextMeasurementService.wordBreak(labelElementNode, width / 2, height - translatedLabelY) : labelElement.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width, powerbi.TextMeasurementService.svgEllipsis)), 
                            labelElement.append("title").text(function(d) {
                                return d;
                            }), labelElement.exit().remove();
                        } else this.labelContext.selectAll("text").remove();
                    } else statusGraphicInfo ? (this.graphicsContext.selectAll("text").remove(), this.displayStatusGraphic(statusGraphicInfo, translateX, translateY, valueTextHeightInPx)) : (this.kpiImage.selectAll("div").remove(), 
                    this.doValueTransition(start, target, this.displayUnitSystemType, this.animationOptions, duration, forceUpdate, formatter), 
                    this.graphicsContext.call(visuals.tooltipUtils.tooltipUpdate, [ target ]));
                    this.value = target;
                }, Card.prototype.displayStatusGraphic = function(statusGraphicInfo, translateX, translateY, labelTextSizeInPx) {
                    this.graphicsContext.selectAll("text").remove();
                    var kpiImageDiv = this.kpiImage.select("div");
                    kpiImageDiv && !kpiImageDiv.empty() || (kpiImageDiv = this.kpiImage.append("div")), 
                    kpiImageDiv.attr("class", statusGraphicInfo["class"]).style("position", "absolute").style("font-size", labelTextSizeInPx + "px");
                    var imageWidth = kpiImageDiv.node().offsetWidth, imageHeight = kpiImageDiv.node().offsetHeight;
                    kpiImageDiv.style("transform", visuals.SVGUtil.translateWithPixels(translateX - imageWidth / 2, this.getTranslateY(labelTextSizeInPx + translateY) - imageHeight));
                }, Card.prototype.getDefaultFormatSettings = function() {
                    return {
                        labelSettings: visuals.dataLabelUtils.getDefaultCardLabelSettings(Card.DefaultStyle.value.color, Card.DefaultStyle.label.color, Card.DefaultStyle.value.textSize),
                        wordWrap: !1,
                        textSize: Card.DefaultStyle.label.textSize
                    };
                }, Card.prototype.enumerateObjectInstances = function(options) {
                    this.cardFormatSetting || (this.cardFormatSetting = this.getDefaultFormatSettings());
                    var formatSettings = this.cardFormatSetting, enumeration = new visuals.ObjectEnumerationBuilder();
                    switch (options.objectName) {
                      case "categoryLabels":
                        visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, formatSettings.labelSettings, !0, !0, formatSettings.textSize);
                        break;

                      case "labels":
                        var labelSettingOptions = {
                            enumeration: enumeration,
                            dataLabelsSettings: formatSettings.labelSettings,
                            show: !0,
                            displayUnits: !0,
                            precision: !0,
                            fontSize: !0
                        };
                        visuals.dataLabelUtils.enumerateDataLabels(labelSettingOptions);
                        break;

                      case "wordWrap":
                        enumeration.pushInstance({
                            objectName: "wordWrap",
                            selector: null,
                            properties: {
                                show: formatSettings.wordWrap
                            }
                        });
                    }
                    return enumeration.complete();
                }, Card.cardClassName = "card", Card.Label = createClassAndSelector("label"), Card.Value = createClassAndSelector("value"), 
                Card.KPIImage = createClassAndSelector("caption"), Card.cardTextProperties = {
                    fontSize: null,
                    text: null,
                    fontFamily: visuals.dataLabelUtils.LabelTextProperties.fontFamily
                }, Card.DefaultStyle = {
                    card: {
                        maxFontSize: 200
                    },
                    label: {
                        textSize: 12,
                        color: "#a6a6a6",
                        paddingTop: 8
                    },
                    value: {
                        textSize: 27,
                        color: "#333333",
                        fontFamily: visuals.Font.Family.regularSecondary.css
                    }
                }, Card;
            }(visuals.AnimatedText);
            visuals.Card = Card;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var OwlHappiness;
            !function(OwlHappiness) {
                OwlHappiness[OwlHappiness.Sad = 0] = "Sad", OwlHappiness[OwlHappiness.Meh = 1] = "Meh", 
                OwlHappiness[OwlHappiness.Happy = 2] = "Happy";
            }(OwlHappiness || (OwlHappiness = {}));
            var OwlGauge = function() {
                function OwlGauge() {}
                return OwlGauge.converter = function(dataView) {
                    return {};
                }, OwlGauge.getGaugeData = function(dataView) {
                    var settings = {
                        max: 100,
                        min: 0,
                        target: void 0,
                        value: 0,
                        tooltipItems: []
                    };
                    if (dataView && dataView.categorical && dataView.categorical.values && dataView.metadata && dataView.metadata.columns) for (var values = dataView.categorical.values, metadataColumns = dataView.metadata.columns, i = 0; i < values.length; i++) {
                        var col = metadataColumns[i], value = values[i].values[0] || 0;
                        col && col.roles && (col.roles[visuals.gaugeRoleNames.y] ? (settings.value = value, 
                        value && settings.tooltipItems.push({
                            displayName: values[i].source.displayName,
                            value: visuals.converterHelper.formatFromMetadataColumn(value, values[i].source, visuals.Gauge.formatStringProp)
                        })) : col.roles[visuals.gaugeRoleNames.minValue] ? settings.min = value : col.roles[visuals.gaugeRoleNames.maxValue] ? settings.max = value : col.roles[visuals.gaugeRoleNames.targetValue] && (settings.target = value, 
                        value && settings.tooltipItems.push({
                            displayName: values[i].source.displayName,
                            value: visuals.converterHelper.formatFromMetadataColumn(value, values[i].source, visuals.Gauge.formatStringProp)
                        })));
                    }
                    return settings;
                }, OwlGauge.prototype.init = function(options) {
                    var _this = this;
                    this.rootElem = options.element, this.rootElem.addClass("owlGaugeVisual"), this.svgTailElem = $(OwlGauge.owlTailSvg), 
                    this.svgBgElem = $(OwlGauge.visualBgSvg), this.svgBodyElem = $(OwlGauge.owlBodySvg), 
                    this.rootElem.append(this.svgBgElem).append(this.svgTailElem).append(this.svgBodyElem), 
                    OwlGauge.OwlDemoMode && window.setInterval(function() {
                        var randomPercentage = 100 * Math.random() + 1;
                        _this.updateGauge(randomPercentage);
                    }, 2e3), this.updateViewportSize(options.viewport.width, options.viewport.height);
                }, OwlGauge.prototype.update = function(options) {
                    this.updateViewportSize(options.viewport.width, options.viewport.height);
                    var dataView = options.dataViews.length > 0 ? options.dataViews[0] : null;
                    if (dataView) {
                        var gaugeData = OwlGauge.getGaugeData(options.dataViews[0]), percentage = (gaugeData.value - gaugeData.min) / (gaugeData.max - gaugeData.min);
                        this.updateGauge(100 * percentage | 0);
                    } else this.updateGauge(0);
                }, OwlGauge.prototype.updateGauge = function(percentage) {
                    if (percentage >= 0 && 100 >= percentage) {
                        var rotationDeg = -180 + 180 * percentage / 100;
                        this.svgBgElem.css({
                            transform: "rotate(" + rotationDeg + "deg)"
                        }), percentage >= 66 ? this.happinessLevel = OwlHappiness.Happy : percentage >= 33 ? this.happinessLevel = OwlHappiness.Meh : this.happinessLevel = OwlHappiness.Sad;
                    }
                }, Object.defineProperty(OwlGauge.prototype, "happinessLevel", {
                    set: function(level) {
                        switch (this.rootElem.removeClass("sad").removeClass("meh").removeClass("happy"), 
                        level) {
                          case OwlHappiness.Sad:
                            this.rootElem.addClass("sad");
                            break;

                          case OwlHappiness.Meh:
                            this.rootElem.addClass("meh");
                            break;

                          case OwlHappiness.Happy:
                            this.rootElem.addClass("happy");
                        }
                    },
                    enumerable: !0,
                    configurable: !0
                }), OwlGauge.prototype.updateViewportSize = function(width, height) {
                    var _this = this, smoothingFn = window.setImmediate || window.requestAnimationFrame;
                    smoothingFn(function() {
                        _this.rootElem.css({
                            height: height,
                            width: width
                        }), _this.svgBodyElem.height(_this.svgBodyElem.width() * OwlGauge.owlBodyHeightMultiplier), 
                        _this.svgBgElem.height(_this.svgBgElem.width() * OwlGauge.visualBgHeightMultiplier), 
                        _this.svgTailElem.height(_this.svgTailElem.width() * OwlGauge.owlTailHeightMultiplier);
                    });
                }, OwlGauge.owlBodySvg = '<svg version="1.1" class="owlGaugeBody" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 267.7 291.2" style="enable-background:new 0 0 267.7 291.2;" xml:space="preserve"> <style type="text/css"> .owlGaugeBody .st0{fill:#A87D50;} .owlGaugeBody .st1{fill:#C2B59B;} .owlGaugeBody .st2{fill:#EB2227;} .owlGaugeBody .st3{fill:#FFFFFF;} .owlGaugeBody .st4{fill:#F9D018;} .owlGaugeBody .st5{fill:none;} .owlGaugeBody .st6{fill:#83381B;} .owlGaugeBody .st7{fill:#231F20;} </style> <g id="XMLID_31_"> <g id="XMLID_34_"> <ellipse id="XMLID_21_" transform="matrix(0.9998 1.947640e-02 -1.947640e-02 0.9998 2.8614 -2.5802)" class="st0" cx="133.9" cy="145.6" rx="133.9" ry="145.6"/> <polygon id="XMLID_20_" class="st0" points="199.2,32.8 184,11.3 209,9.7 "/> <polygon id="XMLID_19_" class="st0" points="73.9,31.2 62.1,7.7 87.1,9.8 "/> <circle id="XMLID_18_" class="st1" cx="134.8" cy="189.2" r="89.8"/> <path id="XMLID_17_" class="st2" d="M140.1,88c-2.7,3.8-7.9,4.7-11.7,2c-2.7-1.9-3.9-5.1-3.4-8.1c0,0,9.6-41.8,9.6-41.8l6.9,40.8 C142,83.2,141.6,85.8,140.1,88z"/> <path id="XMLID_16_" class="st3" d="M164.6,16.2c-14.2,0-26.3,9.2-30.6,21.9c-4.1-13.1-16.3-22.6-30.8-22.6 C85.4,15.6,71,30,71,47.8s14.4,32.3,32.3,32.3c14.2,0,26.3-9.2,30.6-21.9c4.1,13.1,16.3,22.6,30.8,22.6 c17.8,0,32.3-14.4,32.3-32.3S182.4,16.2,164.6,16.2z"/> <path id="XMLID_15_" class="st4" d="M122,58.7l23.3-0.1c0,0-9,14.8-10.2,16.6c-1.2,1.9-2.2,0.1-2.2,0.1L122,58.7z"/> <rect id="XMLID_14_" x="-11.4" y="-68.8" class="st5" width="288.3" height="259.7"/> <g id="XMLID_37_"> <path id="XMLID_13_" class="st6" d="M121.6,125.5c0,3.7-3.5,6.6-7.7,6.6c-4.2,0-7.7-3-7.7-6.6"/> <path id="XMLID_12_" class="st6" d="M160.1,126.5c0,3.7-3.5,6.6-7.7,6.6s-7.7-3-7.7-6.6"/> <path id="XMLID_11_" class="st6" d="M142.4,148.1c0,3.7-3.5,6.6-7.7,6.6c-4.2,0-7.7-3-7.7-6.6"/> <path id="XMLID_10_" class="st6" d="M183.1,148.8c0,3.7-3.5,6.6-7.7,6.6c-4.2,0-7.7-3-7.7-6.6"/> <path id="XMLID_9_" class="st6" d="M160.9,177.4c0,3.7-3.5,6.6-7.7,6.6s-7.7-3-7.7-6.6"/> <path id="XMLID_8_" class="st6" d="M201.6,178c0,3.7-3.5,6.6-7.7,6.6s-7.7-3-7.7-6.6"/> <path id="XMLID_7_" class="st6" d="M76.4,177.4c0,3.7-3.5,6.6-7.7,6.6c-4.2,0-7.7-3-7.7-6.6"/> <path id="XMLID_6_" class="st6" d="M117,178c0,3.7-3.5,6.6-7.7,6.6s-7.7-3-7.7-6.6"/> <path id="XMLID_5_" class="st6" d="M98.6,148.1c0,3.7-3.5,6.6-7.7,6.6c-4.2,0-7.7-3-7.7-6.6"/> </g> <circle id="XMLID_4_" class="st7" cx="164.1" cy="49" r="6.4"/> <circle id="XMLID_3_" class="st7" cx="102.7" cy="47.7" r="6.4"/> </g> <path id="XMLID_2_" class="st0" d="M160.1,140.9c11.1-8.4,55.6-36,55.6-36l4.7,0.8l10.2,38.8c0,0-3,3-9.2,3.1 c-5.1,0.1-45.9-2.6-60.2-3.5C158.1,143.9,157.7,142.7,160.1,140.9z"/> <path id="XMLID_1_" class="st0" d="M110.6,140.8c-11.1-8.4-55.6-36-55.6-36l-4.7,0.8L40,144.4c0,0,3,3,9.2,3.1 c5.1,0.1,45.9-2.6,60.2-3.5C112.5,143.8,113,142.6,110.6,140.8z"/> </g> </svg>', 
                OwlGauge.owlTailSvg = '<svg version="1.1" class="owlGaugeTail" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 587.8 295.5" style="enable-background:new 0 0 587.8 295.5;" xml:space="preserve"> <style type="text/css"> .owlGaugeTail .st0{fill:#3B2416;} .owlGaugeTail .st1{fill:#5B4B43;} .owlGaugeTail .st2{fill:#603A17;} .owlGaugeTail .st3{fill:#726659;} </style> <g id="XMLID_55_"> <path id="XMLID_29_" class="st0" d="M85.2,106.2c-27.1,0-49.2,22-49.2,49.2c0,19.1,10.9,35.7,26.9,43.8c0,0,231.2,95.9,231.2,95.9 l-171-171C114.1,113.2,100.5,106.2,85.2,106.2z"/> <g id="XMLID_56_"> <path id="XMLID_28_" class="st1" d="M482.5,86.4c0-27.1-22-49.2-49.2-49.2c-19.1,0-35.7,10.9-43.8,26.9c0,0-95.9,231.2-95.9,231.2 l171-171C475.5,115.3,482.5,101.7,482.5,86.4z"/> <path id="XMLID_27_" class="st2" d="M573.5,281.3c19.2-19.2,19.2-50.3,0-69.5c-13.5-13.5-33-17.5-50-12c0,0-231.3,95.7-231.3,95.7 l241.8,0C548,296.9,562.6,292.1,573.5,281.3z"/> <path id="XMLID_26_" class="st3" d="M279.9,14.4c-19.2-19.2-50.3-19.2-69.5,0c-13.5,13.5-17.5,33-12,50c0,0,95.7,231.3,95.7,231.3 L294,54C295.4,39.8,290.7,25.2,279.9,14.4z"/> <path id="XMLID_25_" class="st2" d="M105.3,86.4c0-27.1,22-49.2,49.2-49.2c19.1,0,35.7,10.9,43.8,26.9c0,0,95.9,231.2,95.9,231.2 l-171-171C112.3,115.3,105.3,101.7,105.3,86.4z"/> <path id="XMLID_24_" class="st2" d="M14.4,281.4c-19.2-19.2-19.2-50.3,0-69.5c13.5-13.5,33-17.5,50-12c0,0,231.3,95.7,231.3,95.7 l-241.8,0C39.8,297,25.2,292.3,14.4,281.4z"/> <path id="XMLID_23_" class="st2" d="M308.2,14c19.2-19.2,50.3-19.2,69.5,0c13.5,13.5,17.5,33,12,50c0,0-95.7,231.3-95.7,231.3 l0-241.8C292.6,39.4,297.4,24.8,308.2,14z"/> <path id="XMLID_22_" class="st0" d="M503.2,106c27.1,0,49.2,22,49.2,49.2c0,19.1-10.9,35.7-26.9,43.8c0,0-231.2,95.9-231.2,95.9 l171-171C474.2,113,487.8,106,503.2,106z"/> </g> </g> </svg>', 
                OwlGauge.visualBgSvg = '<svg version="1.1" class="owlGaugeBg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="123.8 94.9 349.1 175.3" style="enable-background:new 123.8 94.9 349.1 175.3;" xml:space="preserve"> <style type="text/css"> .owlGaugeBg .st0{fill:#EF4137;} .owlGaugeBg .st1{fill:#FAAF42;} .owlGaugeBg .st2{fill:#F15B2A;} .owlGaugeBg .st3{fill:#F69321;} </style> <g id="XMLID_10_"> <path id="XMLID_8_" class="st0" d="M174.3,158c-16.1,0-29.2,13.1-29.2,29.2c0,11.4,6.5,21.2,16,26.1l137.3,57L196.9,168.7 C191.5,162.2,183.4,158,174.3,158z"/> <g id="XMLID_11_"> <path id="XMLID_7_" class="st1" d="M410.2,146.3c0-16.1-13.1-29.2-29.2-29.2c-11.4,0-21.2,6.5-26,16l-57,137.5L399.5,169 C406.1,163.5,410.2,155.4,410.2,146.3z"/> <path id="XMLID_6_" class="st0" d="M464.3,262.2c11.4-11.4,11.4-29.9,0-41.3c-8-8-19.6-10.4-29.7-7.1l-137.4,56.9h143.6 C449.2,271.4,457.9,268.6,464.3,262.2z"/> <path id="XMLID_5_" class="st2" d="M290,103.5c-11.4-11.4-29.9-11.4-41.3,0c-8,8-10.4,19.6-7.1,29.7l56.8,137.5V127 C299.2,118.6,296.4,109.9,290,103.5z"/> <path id="XMLID_4_" class="st3" d="M186.3,146.3c0-16.1,13.1-29.2,29.2-29.2c11.4,0,21.2,6.5,26,16l57,137.5L197,168.8 C190.5,163.5,186.3,155.4,186.3,146.3z"/> <path id="XMLID_3_" class="st2" d="M132.3,262.2c-11.4-11.4-11.4-29.9,0-41.3c8-8,19.6-10.4,29.7-7.1l137.4,56.9H155.8 C147.4,271.5,138.7,268.7,132.3,262.2z"/> <path id="XMLID_2_" class="st3" d="M306.8,103.2c11.4-11.4,29.9-11.4,41.3,0c8,8,10.4,19.6,7.1,29.7l-56.8,137.5V126.7 C297.5,118.3,300.3,109.7,306.8,103.2z"/> <path id="XMLID_1_" class="st2" d="M422.5,157.9c16.1,0,29.2,13.1,29.2,29.2c0,11.4-6.5,21.2-16,26.1l-137.3,57L400,168.6 C405.3,162.1,413.4,157.9,422.5,157.9z"/> </g> </g> </svg>', 
                OwlGauge.owlBodyHeightMultiplier = 291.2 / 267.7, OwlGauge.owlTailHeightMultiplier = 295.5 / 587.8, 
                OwlGauge.visualBgHeightMultiplier = 295.5 / 587.8, OwlGauge.OwlDemoMode = !1, OwlGauge.capabilities = {
                    dataRoles: [ {
                        displayName: "Category",
                        name: "Category",
                        kind: powerbi.VisualDataRoleKind.Grouping
                    }, {
                        displayName: "Y Axis",
                        name: "Y",
                        kind: powerbi.VisualDataRoleKind.Measure
                    } ],
                    dataViewMappings: [ {
                        categorical: {
                            categories: {
                                "for": {
                                    "in": "Category"
                                },
                                dataReductionAlgorithm: {
                                    top: {}
                                }
                            },
                            values: {
                                select: [ {
                                    bind: {
                                        to: "Y"
                                    }
                                } ]
                            }
                        }
                    } ]
                }, OwlGauge;
            }();
            visuals.OwlGauge = OwlGauge;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var NoMapLocationWarning = function() {
                function NoMapLocationWarning() {}
                return Object.defineProperty(NoMapLocationWarning.prototype, "code", {
                    get: function() {
                        return "NoMapLocation";
                    },
                    enumerable: !0,
                    configurable: !0
                }), NoMapLocationWarning.prototype.getMessages = function(resourceProvider) {
                    var messageKey = "NoMapLocationMessage", titleKey = "NoMapLocationKey", detailKey = "NoMapLocationValue", visualMessage = {
                        message: resourceProvider.get(messageKey),
                        title: resourceProvider.get(titleKey),
                        detail: resourceProvider.get(detailKey)
                    };
                    return visualMessage;
                }, NoMapLocationWarning;
            }();
            visuals.NoMapLocationWarning = NoMapLocationWarning;
            var FilledMapWithoutValidGeotagCategoryWarning = function() {
                function FilledMapWithoutValidGeotagCategoryWarning() {}
                return Object.defineProperty(FilledMapWithoutValidGeotagCategoryWarning.prototype, "code", {
                    get: function() {
                        return "NoValidGeotaggedCategory";
                    },
                    enumerable: !0,
                    configurable: !0
                }), FilledMapWithoutValidGeotagCategoryWarning.prototype.getMessages = function(resourceProvider) {
                    var messageKey = "NoValidGeotaggedCategoryMessage", titleKey = "NoValidGeotaggedCategoryKey", detailKey = "NoValidGeotaggedCategoryValue", visualMessage = {
                        message: resourceProvider.get(messageKey),
                        title: resourceProvider.get(titleKey),
                        detail: resourceProvider.get(detailKey)
                    };
                    return visualMessage;
                }, FilledMapWithoutValidGeotagCategoryWarning;
            }();
            visuals.FilledMapWithoutValidGeotagCategoryWarning = FilledMapWithoutValidGeotagCategoryWarning;
            var GeometryCulledWarning = function() {
                function GeometryCulledWarning() {}
                return Object.defineProperty(GeometryCulledWarning.prototype, "code", {
                    get: function() {
                        return "GeometryCulledWarning";
                    },
                    enumerable: !0,
                    configurable: !0
                }), GeometryCulledWarning.prototype.getMessages = function(resourceProvider) {
                    var messageKey = "GeometryCulledWarningMessage", titleKey = "GeometryCulledWarningKey", detailKey = "GeometryCulledWarningVal", visualMessage = {
                        message: resourceProvider.get(messageKey),
                        title: resourceProvider.get(titleKey),
                        detail: resourceProvider.get(detailKey)
                    };
                    return visualMessage;
                }, GeometryCulledWarning;
            }();
            visuals.GeometryCulledWarning = GeometryCulledWarning;
            var NegativeValuesNotSupportedWarning = function() {
                function NegativeValuesNotSupportedWarning() {}
                return Object.defineProperty(NegativeValuesNotSupportedWarning.prototype, "code", {
                    get: function() {
                        return "NegativeValuesNotSupported";
                    },
                    enumerable: !0,
                    configurable: !0
                }), NegativeValuesNotSupportedWarning.prototype.getMessages = function(resourceProvider) {
                    var messageKey = "VisualWarning_NegativeValues", visualMessage = {
                        message: resourceProvider.get(messageKey),
                        title: "",
                        detail: ""
                    };
                    return visualMessage;
                }, NegativeValuesNotSupportedWarning;
            }();
            visuals.NegativeValuesNotSupportedWarning = NegativeValuesNotSupportedWarning;
            var AllNegativeValuesWarning = function() {
                function AllNegativeValuesWarning() {}
                return Object.defineProperty(AllNegativeValuesWarning.prototype, "code", {
                    get: function() {
                        return "AllNegativeValuesNotSupported";
                    },
                    enumerable: !0,
                    configurable: !0
                }), AllNegativeValuesWarning.prototype.getMessages = function(resourceProvider) {
                    var messageKey = "VisualWarning_AllNegativeValues", visualMessage = {
                        message: resourceProvider.get(messageKey),
                        title: "",
                        detail: ""
                    };
                    return visualMessage;
                }, AllNegativeValuesWarning;
            }();
            visuals.AllNegativeValuesWarning = AllNegativeValuesWarning;
            var NaNNotSupportedWarning = function() {
                function NaNNotSupportedWarning() {}
                return Object.defineProperty(NaNNotSupportedWarning.prototype, "code", {
                    get: function() {
                        return "NaNNotSupported";
                    },
                    enumerable: !0,
                    configurable: !0
                }), NaNNotSupportedWarning.prototype.getMessages = function(resourceProvider) {
                    var messageKey = "VisualWarning_NanValues", visualMessage = {
                        message: resourceProvider.get(messageKey),
                        title: "",
                        detail: ""
                    };
                    return visualMessage;
                }, NaNNotSupportedWarning;
            }();
            visuals.NaNNotSupportedWarning = NaNNotSupportedWarning;
            var InfinityValuesNotSupportedWarning = function() {
                function InfinityValuesNotSupportedWarning() {}
                return Object.defineProperty(InfinityValuesNotSupportedWarning.prototype, "code", {
                    get: function() {
                        return "InfinityValuesNotSupported";
                    },
                    enumerable: !0,
                    configurable: !0
                }), InfinityValuesNotSupportedWarning.prototype.getMessages = function(resourceProvider) {
                    var messageKey = "VisualWarning_InfinityValues", visualMessage = {
                        message: resourceProvider.get(messageKey),
                        title: "",
                        detail: ""
                    };
                    return visualMessage;
                }, InfinityValuesNotSupportedWarning;
            }();
            visuals.InfinityValuesNotSupportedWarning = InfinityValuesNotSupportedWarning;
            var ValuesOutOfRangeWarning = function() {
                function ValuesOutOfRangeWarning() {}
                return Object.defineProperty(ValuesOutOfRangeWarning.prototype, "code", {
                    get: function() {
                        return "ValuesOutOfRange";
                    },
                    enumerable: !0,
                    configurable: !0
                }), ValuesOutOfRangeWarning.prototype.getMessages = function(resourceProvider) {
                    var messageKey = "VisualWarning_VisualizationOutOfRange", visualMessage = {
                        message: resourceProvider.get(messageKey),
                        title: "",
                        detail: ""
                    };
                    return visualMessage;
                }, ValuesOutOfRangeWarning;
            }();
            visuals.ValuesOutOfRangeWarning = ValuesOutOfRangeWarning;
            var ZeroValueWarning = function() {
                function ZeroValueWarning() {}
                return Object.defineProperty(ZeroValueWarning.prototype, "code", {
                    get: function() {
                        return "ZeroValuesNotSupported";
                    },
                    enumerable: !0,
                    configurable: !0
                }), ZeroValueWarning.prototype.getMessages = function(resourceProvider) {
                    var messageKey = "VisualWarning_ZeroValues", visualMessage = {
                        message: resourceProvider.get(messageKey),
                        title: "",
                        detail: ""
                    };
                    return visualMessage;
                }, ZeroValueWarning;
            }();
            visuals.ZeroValueWarning = ZeroValueWarning;
            var VisualKPIDataMissingWarning = function() {
                function VisualKPIDataMissingWarning() {}
                return Object.defineProperty(VisualKPIDataMissingWarning.prototype, "code", {
                    get: function() {
                        return "VisualKPIDataMissing";
                    },
                    enumerable: !0,
                    configurable: !0
                }), VisualKPIDataMissingWarning.prototype.getMessages = function(resourceProvider) {
                    var messageKey = "Visual_KPI_DataMissing", visualMessage = {
                        message: resourceProvider.get(messageKey),
                        title: "",
                        detail: ""
                    };
                    return visualMessage;
                }, VisualKPIDataMissingWarning;
            }();
            visuals.VisualKPIDataMissingWarning = VisualKPIDataMissingWarning;
            var ScriptVisualRefreshWarning = function() {
                function ScriptVisualRefreshWarning() {}
                return Object.defineProperty(ScriptVisualRefreshWarning.prototype, "code", {
                    get: function() {
                        return "ScriptVisualNotRefreshed";
                    },
                    enumerable: !0,
                    configurable: !0
                }), ScriptVisualRefreshWarning.prototype.getMessages = function(resourceProvider) {
                    var messageKey = "ScriptVisualRefreshWarningMessage", detailKey = "ScriptVisualRefreshWarningValue", visualMessage = {
                        message: resourceProvider.get(messageKey),
                        title: resourceProvider.get(messageKey),
                        detail: resourceProvider.get(detailKey)
                    };
                    return visualMessage;
                }, ScriptVisualRefreshWarning;
            }();
            visuals.ScriptVisualRefreshWarning = ScriptVisualRefreshWarning;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var PixelConverter = jsCommon.PixelConverter, createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, WaterfallChart = function() {
                function WaterfallChart(options) {
                    this.isScrollable = options.isScrollable, this.tooltipsEnabled = options.tooltipsEnabled, 
                    this.tooltipBucketEnabled = options.tooltipBucketEnabled, this.interactivityService = options.interactivityService;
                }
                return WaterfallChart.prototype.init = function(options) {
                    this.svg = options.svg, this.svg.classed(WaterfallChart.WaterfallClassName, !0), 
                    this.style = options.style, this.currentViewport = options.viewport, this.hostServices = options.host, 
                    this.interactivity = options.interactivity, this.cartesianVisualHost = options.cartesianHost, 
                    this.options = options, this.element = options.element, this.colors = this.style.colorPalette.dataColors, 
                    this.mainGraphicsSVG = this.svg.append("svg"), this.mainGraphicsContext = this.mainGraphicsSVG.append("g").classed(WaterfallChart.MainGraphicsContextClassName, !0), 
                    this.labelGraphicsContext = this.mainGraphicsSVG.append("g").classed(visuals.NewDataLabelUtils.labelGraphicsContextClass["class"], !0);
                }, WaterfallChart.converter = function(dataView, palette, hostServices, dataLabelSettings, sentimentColors, interactivityService, tooltipsEnabled, tooltipBucketEnabled) {
                    void 0 === tooltipsEnabled && (tooltipsEnabled = !0);
                    var categoryMetadata, totalTooltips, tooltipsCount, tooltipMetadataColumns, reader = powerbi.data.createIDataViewCategoricalReader(dataView), formatStringProp = WaterfallChart.formatStringProp, categories = dataView.categorical.categories || [], increaseColor = sentimentColors.increaseFill.solid.color, decreaseColor = sentimentColors.decreaseFill.solid.color, totalColor = sentimentColors.totalFill.solid.color, totalLabel = hostServices.getLocalizedString(WaterfallChart.TotalLabel), increaseLabel = hostServices.getLocalizedString(WaterfallChart.IncreaseLabel), decreaseLabel = hostServices.getLocalizedString(WaterfallChart.DecreaseLabel), legend = [ {
                        label: increaseLabel,
                        color: increaseColor,
                        icon: visuals.LegendIcon.Box,
                        identity: visuals.SelectionIdBuilder.builder().withMeasure("increase").createSelectionId(),
                        selected: !1
                    }, {
                        label: decreaseLabel,
                        color: decreaseColor,
                        icon: visuals.LegendIcon.Box,
                        identity: visuals.SelectionIdBuilder.builder().withMeasure("decrease").createSelectionId(),
                        selected: !1
                    }, {
                        label: totalLabel,
                        color: totalColor,
                        icon: visuals.LegendIcon.Box,
                        identity: visuals.SelectionIdBuilder.builder().withMeasure("total").createSelectionId(),
                        selected: !1
                    } ], pos = 0, posMin = 0, posMax = 0, dataPoints = [], categoryValues = [], valuesMetadata = void 0;
                    if (reader.hasValues("Tooltips") && (tooltipMetadataColumns = reader.getAllValueMetadataColumnsForRole("Tooltips", void 0)), 
                    reader.hasValues("Y")) {
                        valuesMetadata = reader.getValueMetadataColumn("Y");
                        var labelFormatString = valuesMetadata.format;
                        if (_.isEmpty(categories)) pos = posMax = reader.getValue("Y", 0), posMin = 0; else {
                            var categoryColumn = categories[0];
                            categoryMetadata = categoryColumn.source, categoryValues = categoryColumn.values.slice(), 
                            categoryValues.push(totalLabel), reader.hasValues("Tooltips") && (tooltipsCount = reader.getSeriesCount("Tooltips"), 
                            totalTooltips = _.map(new Array(tooltipsCount), function() {
                                return 0;
                            }));
                            for (var categoryIndex = 0, catLen = reader.getCategoryCount(); catLen > categoryIndex; categoryIndex++) {
                                var category = categoryValues[categoryIndex], value = reader.getValue("Y", categoryIndex) || 0, identity = visuals.SelectionIdBuilder.builder().withCategory(categoryColumn, categoryIndex).withMeasure(valuesMetadata.queryName).createSelectionId(), tooltipInfo_1 = void 0;
                                if (tooltipsEnabled && (tooltipInfo_1 = [], tooltipInfo_1.push({
                                    displayName: categoryMetadata.displayName,
                                    value: visuals.converterHelper.formatFromMetadataColumn(category, categoryMetadata, formatStringProp)
                                }), null != value && tooltipInfo_1.push({
                                    displayName: valuesMetadata.displayName,
                                    value: visuals.converterHelper.formatFromMetadataColumn(value, valuesMetadata, formatStringProp)
                                }), tooltipBucketEnabled)) {
                                    var tooltipValues = reader.getAllValuesForRole("Tooltips", categoryIndex);
                                    if (tooltipValues && tooltipMetadataColumns) {
                                        for (var i = 0; i < tooltipValues.length; i++) totalTooltips[i] += tooltipValues[i];
                                        for (var j = 0; j < tooltipValues.length; j++) null != tooltipValues[j] && tooltipMetadataColumns[j] && tooltipInfo_1.push({
                                            displayName: tooltipMetadataColumns[j].displayName,
                                            value: visuals.converterHelper.formatFromMetadataColumn(tooltipValues[j], tooltipMetadataColumns[j], formatStringProp)
                                        });
                                    }
                                }
                                var color = value > 0 ? increaseColor : decreaseColor;
                                dataPoints.push({
                                    value: value,
                                    position: pos,
                                    color: color,
                                    categoryValue: category,
                                    categoryIndex: categoryIndex,
                                    seriesIndex: 0,
                                    selected: !1,
                                    identity: identity,
                                    highlight: !1,
                                    key: identity.getKey(),
                                    tooltipInfo: tooltipInfo_1,
                                    labelFill: dataLabelSettings.labelColor,
                                    labelFormatString: labelFormatString
                                }), pos += value, pos > posMax && (posMax = pos), posMin > pos && (posMin = pos);
                            }
                        }
                        var tooltipInfo = void 0;
                        if (tooltipsEnabled && (tooltipInfo = [], categoryMetadata && tooltipInfo.push({
                            displayName: categoryMetadata.displayName,
                            value: totalLabel
                        }), null != pos && tooltipInfo.push({
                            displayName: valuesMetadata.displayName,
                            value: visuals.converterHelper.formatFromMetadataColumn(pos, valuesMetadata, formatStringProp)
                        }), tooltipBucketEnabled)) {
                            var tooltipValues = reader.getAllValuesForRole("Tooltips", 0, void 0);
                            if (totalTooltips = totalTooltips ? totalTooltips : tooltipValues, tooltipValues && tooltipMetadataColumns) for (var j = 0; j < totalTooltips.length; j++) null != totalTooltips[j] && tooltipInfo.push({
                                displayName: tooltipMetadataColumns[j].displayName,
                                value: visuals.converterHelper.formatFromMetadataColumn(totalTooltips[j], tooltipMetadataColumns[j], formatStringProp)
                            });
                        }
                        var totalIdentity = visuals.SelectionId.createNull();
                        dataPoints.push({
                            value: pos,
                            position: 0,
                            color: totalColor,
                            categoryValue: totalLabel,
                            categoryIndex: categoryIndex,
                            identity: totalIdentity,
                            seriesIndex: 0,
                            selected: !1,
                            highlight: !1,
                            key: totalIdentity.getKey(),
                            tooltipInfo: tooltipInfo,
                            labelFill: dataLabelSettings.labelColor,
                            labelFormatString: labelFormatString,
                            isTotal: !0
                        });
                    }
                    interactivityService && interactivityService.applySelectionStateToData(dataPoints);
                    var xAxisProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataView.metadata), yAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataView.metadata), axesLabels = visuals.converterHelper.createAxesLabels(xAxisProperties, yAxisProperties, categoryMetadata, [ valuesMetadata ]);
                    return {
                        series: [ {
                            data: dataPoints
                        } ],
                        categories: categoryValues,
                        categoryMetadata: categoryMetadata,
                        valuesMetadata: valuesMetadata,
                        legend: {
                            dataPoints: legend
                        },
                        hasHighlights: !1,
                        positionMin: posMin,
                        positionMax: posMax,
                        dataLabelsSettings: dataLabelSettings,
                        sentimentColors: sentimentColors,
                        axesLabels: {
                            x: axesLabels.xAxisLabel,
                            y: axesLabels.yAxisLabel
                        }
                    };
                }, WaterfallChart.prototype.setData = function(dataViews) {
                    var sentimentColors = this.getSentimentColorsFromObjects(null), dataView = dataViews.length > 0 ? dataViews[0] : void 0;
                    if (this.data = {
                        series: [ {
                            data: []
                        } ],
                        categories: [],
                        valuesMetadata: null,
                        legend: {
                            dataPoints: []
                        },
                        hasHighlights: !1,
                        categoryMetadata: null,
                        scalarCategoryAxis: !1,
                        positionMax: 0,
                        positionMin: 0,
                        dataLabelsSettings: visuals.dataLabelUtils.getDefaultLabelSettings(!1, void 0),
                        sentimentColors: sentimentColors,
                        axesLabels: {
                            x: null,
                            y: null
                        }
                    }, dataView) {
                        if (dataView.metadata && dataView.metadata.objects) {
                            var objects = dataView.metadata.objects, labelsObj = objects.labels;
                            labelsObj && visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, this.data.dataLabelsSettings), 
                            sentimentColors = this.getSentimentColorsFromObjects(objects);
                        }
                        dataView.categorical && (this.data = WaterfallChart.converter(dataView, this.colors, this.hostServices, this.data.dataLabelsSettings, sentimentColors, this.interactivityService, this.tooltipsEnabled, this.tooltipBucketEnabled));
                    }
                }, WaterfallChart.prototype.enumerateObjectInstances = function(enumeration, options) {
                    switch (options.objectName) {
                      case "sentimentColors":
                        this.enumerateSentimentColors(enumeration);
                        break;

                      case "labels":
                        var labelSettingOptions = {
                            enumeration: enumeration,
                            dataLabelsSettings: this.data.dataLabelsSettings,
                            show: !0,
                            displayUnits: !0,
                            precision: !0,
                            fontSize: !0
                        };
                        visuals.dataLabelUtils.enumerateDataLabels(labelSettingOptions);
                    }
                }, WaterfallChart.prototype.enumerateSentimentColors = function(enumeration) {
                    var sentimentColors = this.data.sentimentColors;
                    enumeration.pushInstance({
                        selector: null,
                        properties: {
                            increaseFill: sentimentColors.increaseFill,
                            decreaseFill: sentimentColors.decreaseFill,
                            totalFill: sentimentColors.totalFill
                        },
                        objectName: "sentimentColors"
                    });
                }, WaterfallChart.prototype.calculateLegend = function() {
                    return this.data.legend;
                }, WaterfallChart.prototype.hasLegend = function() {
                    return !0;
                }, WaterfallChart.createClippedDataIfOverflowed = function(data, renderableDataCount) {
                    var clipped = data, dataPoints = data.series[0].data;
                    return data && renderableDataCount < dataPoints.length && (clipped = powerbi.Prototype.inherit(data), 
                    clipped.series = [ {
                        data: dataPoints.slice(0, renderableDataCount)
                    } ], clipped.categories = data.categories.slice(0, renderableDataCount)), clipped;
                }, WaterfallChart.prototype.calculateAxesProperties = function(options) {
                    var _this = this;
                    this.currentViewport = options.viewport, this.margin = options.margin;
                    var data = this.clippedData = this.data, categoryCount = data.categories.length, preferredPlotArea = this.getPreferredPlotArea(!1, categoryCount, visuals.CartesianChart.MinOrdinalRectThickness), cartesianLayout = visuals.CartesianChart.getLayout(null, {
                        availableWidth: preferredPlotArea.width,
                        categoryCount: categoryCount,
                        domain: null,
                        isScalar: !1,
                        isScrollable: this.isScrollable,
                        trimOrdinalDataOnOverflow: options.trimOrdinalDataOnOverflow
                    });
                    this.isScrollable || (data = this.clippedData = WaterfallChart.createClippedDataIfOverflowed(data, cartesianLayout.categoryCount));
                    var xAxisCreationOptions = WaterfallChart.getXAxisCreationOptions(data, preferredPlotArea.width, cartesianLayout, options), yAxisCreationOptions = WaterfallChart.getYAxisCreationOptions(data, preferredPlotArea.height, options), xAxisProperties = this.xAxisProperties = visuals.AxisHelper.createAxis(xAxisCreationOptions), yAxisProperties = this.yAxisProperties = visuals.AxisHelper.createAxis(yAxisCreationOptions), categoryWidth = this.xAxisProperties.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio), formattersCache = visuals.dataLabelUtils.createColumnFormatterCacheManager(), labelSettings = data.dataLabelsSettings, value2 = WaterfallChart.getDisplayUnitValueFromAxisFormatter(yAxisProperties, labelSettings);
                    return this.layout = {
                        categoryCount: cartesianLayout.categoryCount,
                        categoryThickness: cartesianLayout.categoryThickness,
                        isScalar: cartesianLayout.isScalar,
                        outerPaddingRatio: cartesianLayout.outerPaddingRatio,
                        categoryWidth: categoryWidth,
                        labelText: function(d) {
                            var formatter = formattersCache.getOrCreate(d.labelFormatString, labelSettings, value2);
                            return visuals.dataLabelUtils.getLabelFormattedText({
                                label: formatter.format(d.value)
                            });
                        },
                        labelLayout: visuals.dataLabelUtils.getLabelLayoutXYForWaterfall(xAxisProperties, categoryWidth, yAxisProperties, yAxisCreationOptions.dataDomain),
                        filter: function(d) {
                            return visuals.dataLabelUtils.doesDataLabelFitInShape(d, yAxisProperties, _this.layout);
                        },
                        style: {
                            fill: function(d) {
                                return d.isLabelInside ? visuals.dataLabelUtils.defaultInsideLabelColor : d.labelFill;
                            }
                        }
                    }, this.xAxisProperties.axisLabel = options.showCategoryAxisLabel ? data.axesLabels.x : null, 
                    this.yAxisProperties.axisLabel = options.showValueAxisLabel ? data.axesLabels.y : null, 
                    [ xAxisProperties, yAxisProperties ];
                }, WaterfallChart.getDisplayUnitValueFromAxisFormatter = function(yAxisProperties, labelSettings) {
                    return yAxisProperties.formatter && yAxisProperties.formatter.displayUnit && 0 === labelSettings.displayUnits ? yAxisProperties.formatter.displayUnit.value : null;
                }, WaterfallChart.lookupXValue = function(data, index, type) {
                    var dataPoints = data.series[0].data;
                    return index === dataPoints.length - 1 ? dataPoints[index].categoryValue : visuals.CartesianHelper.lookupXValue(data, index, type, !1);
                }, WaterfallChart.getXAxisCreationOptions = function(data, width, layout, options) {
                    var categoryDataType = visuals.AxisHelper.getCategoryValueType(data.categoryMetadata), domain = visuals.AxisHelper.createDomain(data.series, categoryDataType, !1, options.forcedXDomain, options.ensureXDomain), categoryThickness = layout.categoryThickness, outerPadding = categoryThickness * layout.outerPaddingRatio;
                    return {
                        pixelSpan: width,
                        dataDomain: domain,
                        metaDataColumn: data.categoryMetadata,
                        formatString: visuals.valueFormatter.getFormatString(data.categoryMetadata, WaterfallChart.formatStringProp),
                        isScalar: !1,
                        outerPadding: outerPadding,
                        categoryThickness: categoryThickness,
                        getValueFn: function(index, type) {
                            return WaterfallChart.lookupXValue(data, index, type);
                        },
                        forcedTickCount: options.forcedTickCount,
                        isCategoryAxis: !0,
                        axisDisplayUnits: options.categoryAxisDisplayUnits,
                        axisPrecision: options.categoryAxisPrecision
                    };
                }, WaterfallChart.getYAxisCreationOptions = function(data, height, options) {
                    var combinedDomain = visuals.AxisHelper.combineDomain(options.forcedYDomain, [ data.positionMin, data.positionMax ], options.ensureYDomain);
                    return {
                        pixelSpan: height,
                        dataDomain: combinedDomain,
                        isScalar: !0,
                        isVertical: !0,
                        metaDataColumn: data.valuesMetadata,
                        formatString: visuals.valueFormatter.getFormatString(data.valuesMetadata, WaterfallChart.formatStringProp),
                        outerPadding: 0,
                        forcedTickCount: options.forcedTickCount,
                        useTickIntervalForDisplayUnits: !0,
                        isCategoryAxis: !1,
                        axisDisplayUnits: options.valueAxisDisplayUnits,
                        axisPrecision: options.valueAxisPrecision
                    };
                }, WaterfallChart.prototype.getPreferredPlotArea = function(isScalar, categoryCount, categoryThickness) {
                    return visuals.CartesianChart.getPreferredPlotArea(categoryCount, categoryThickness, this.currentViewport, this.isScrollable, isScalar, this.margin);
                }, WaterfallChart.prototype.getVisualCategoryAxisIsScalar = function() {
                    return !1;
                }, WaterfallChart.prototype.overrideXScale = function(xProperties) {
                    this.xAxisProperties = xProperties;
                }, WaterfallChart.prototype.setFilteredData = function(startIndex, endIndex) {
                    var data = this.clippedData = powerbi.Prototype.inherit(this.data);
                    return data.series = [ {
                        data: data.series[0].data.slice(startIndex, endIndex)
                    } ], data.categories = data.categories.slice(startIndex, endIndex), data;
                }, WaterfallChart.prototype.createRects = function(data) {
                    var mainGraphicsContext = this.mainGraphicsContext, colsSelection = mainGraphicsContext.selectAll(WaterfallChart.CategoryValueClasses.selector), cols = colsSelection.data(data, function(d) {
                        return d.key;
                    });
                    return cols.enter().append("rect").attr("class", function(d) {
                        return WaterfallChart.CategoryValueClasses["class"].concat(d.highlight ? "highlight" : "");
                    }), cols.exit().remove(), cols;
                }, WaterfallChart.prototype.createConnectors = function(data) {
                    var mainGraphicsContext = this.mainGraphicsContext, connectorSelection = mainGraphicsContext.selectAll(WaterfallChart.WaterfallConnectorClasses.selector), connectors = connectorSelection.data(data.slice(0, data.length - 1), function(d) {
                        return d.key;
                    });
                    return connectors.enter().append("line").classed(WaterfallChart.WaterfallConnectorClasses["class"], !0), 
                    connectors.exit().remove(), connectors;
                }, WaterfallChart.prototype.render = function(suppressAnimations) {
                    var _this = this, dataPoints = this.clippedData.series[0].data, bars = this.createRects(dataPoints), connectors = this.createConnectors(dataPoints);
                    this.tooltipsEnabled && visuals.TooltipManager.addTooltip(bars, function(tooltipEvent) {
                        return tooltipEvent.data.tooltipInfo;
                    });
                    var hasSelection = this.interactivityService && this.interactivityService.hasSelection(), xScale = this.xAxisProperties.scale, yScale = this.yAxisProperties.scale, y0 = yScale(0);
                    this.mainGraphicsSVG.attr("height", this.getAvailableHeight()).attr("width", this.getAvailableWidth()), 
                    bars.style("fill", function(d) {
                        return d.color;
                    }).style("fill-opacity", function(d) {
                        return d.isTotal ? visuals.ColumnUtil.DefaultOpacity : visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, _this.data.hasHighlights);
                    }).attr("width", this.layout.categoryWidth).attr("x", function(d) {
                        return xScale(d.categoryIndex);
                    }).attr("y", function(d) {
                        return WaterfallChart.getRectTop(yScale, d.position, d.value);
                    }).attr("height", function(d) {
                        return y0 - yScale(Math.abs(d.value));
                    }), connectors.attr({
                        x1: function(d) {
                            return xScale(d.categoryIndex);
                        },
                        y1: function(d) {
                            return yScale(d.position + d.value);
                        },
                        x2: function(d) {
                            return xScale(d.categoryIndex + 1) + _this.layout.categoryWidth;
                        },
                        y2: function(d) {
                            return yScale(d.position + d.value);
                        }
                    });
                    var labelSettings = this.data.dataLabelsSettings, labelDataPoints = [];
                    (labelSettings && labelSettings.show || labelSettings.showCategory) && (labelDataPoints = this.createLabelDataPoints());
                    var behaviorOptions = void 0;
                    return this.interactivityService && (behaviorOptions = {
                        bars: bars
                    }), visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options), {
                        dataPoints: dataPoints,
                        behaviorOptions: behaviorOptions,
                        labelDataPoints: labelDataPoints,
                        labelsAreNumeric: !0
                    };
                }, WaterfallChart.prototype.onClearSelection = function() {
                    this.interactivityService && this.interactivityService.clearSelection();
                }, WaterfallChart.prototype.getSupportedCategoryAxisType = function() {
                    return visuals.axisType.categorical;
                }, WaterfallChart.getRectTop = function(scale, pos, value) {
                    return 0 > value ? scale(pos) : scale(pos) - (scale(0) - scale(value));
                }, WaterfallChart.prototype.getAvailableWidth = function() {
                    return this.currentViewport.width - (this.margin.left + this.margin.right);
                }, WaterfallChart.prototype.getAvailableHeight = function() {
                    return this.currentViewport.height - (this.margin.top + this.margin.bottom);
                }, WaterfallChart.prototype.getSentimentColorsFromObjects = function(objects) {
                    var defaultSentimentColors = this.colors.getSentimentColors(), increaseColor = powerbi.DataViewObjects.getFillColor(objects, visuals.waterfallChartProps.sentimentColors.increaseFill, defaultSentimentColors[2].value), decreaseColor = powerbi.DataViewObjects.getFillColor(objects, visuals.waterfallChartProps.sentimentColors.decreaseFill, defaultSentimentColors[0].value), totalColor = powerbi.DataViewObjects.getFillColor(objects, visuals.waterfallChartProps.sentimentColors.totalFill, WaterfallChart.defaultTotalColor);
                    return {
                        increaseFill: {
                            solid: {
                                color: increaseColor
                            }
                        },
                        decreaseFill: {
                            solid: {
                                color: decreaseColor
                            }
                        },
                        totalFill: {
                            solid: {
                                color: totalColor
                            }
                        }
                    };
                }, WaterfallChart.prototype.createLabelDataPoints = function() {
                    for (var labelDataPoints = [], data = this.data, xScale = this.xAxisProperties.scale, yScale = this.yAxisProperties.scale, y0 = yScale(0), series = data.series, formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager(), axisFormatter = visuals.NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yAxisProperties.formatter, data.dataLabelsSettings), labelSettings = this.data.dataLabelsSettings, _i = 0, series_1 = series; _i < series_1.length; _i++) for (var currentSeries = series_1[_i], _a = 0, _b = currentSeries.data; _a < _b.length; _a++) {
                        var dataPoint = _b[_a], parentRect = {
                            left: xScale(dataPoint.categoryIndex),
                            top: WaterfallChart.getRectTop(yScale, dataPoint.position, dataPoint.value),
                            width: this.layout.categoryWidth,
                            height: y0 - yScale(Math.abs(dataPoint.value))
                        }, formatString = dataPoint.labelFormatString, formatter = formattersCache.getOrCreate(formatString, this.data.dataLabelsSettings, axisFormatter), text = visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(dataPoint.value)), properties = {
                            text: text,
                            fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                            fontSize: PixelConverter.fromPoint(labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt),
                            fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight
                        }, textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties), textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, !0);
                        labelDataPoints.push({
                            isPreferred: !0,
                            text: text,
                            textSize: {
                                width: textWidth,
                                height: textHeight
                            },
                            outsideFill: labelSettings.labelColor ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultLabelColor,
                            insideFill: visuals.NewDataLabelUtils.defaultInsideLabelColor,
                            parentType: 1,
                            parentShape: {
                                rect: parentRect,
                                orientation: dataPoint.value >= 0 ? 1 : 2,
                                validPositions: 0 === dataPoint.value ? WaterfallChart.validZeroLabelPosition : WaterfallChart.validLabelPositions
                            },
                            fontSize: labelSettings.fontSize,
                            identity: void 0
                        });
                    }
                    return labelDataPoints;
                }, WaterfallChart.formatStringProp = {
                    objectName: "general",
                    propertyName: "formatString"
                }, WaterfallChart.WaterfallClassName = "waterfallChart", WaterfallChart.MainGraphicsContextClassName = "mainGraphicsContext", 
                WaterfallChart.IncreaseLabel = "Waterfall_IncreaseLabel", WaterfallChart.DecreaseLabel = "Waterfall_DecreaseLabel", 
                WaterfallChart.TotalLabel = "Waterfall_TotalLabel", WaterfallChart.CategoryValueClasses = createClassAndSelector("column"), 
                WaterfallChart.WaterfallConnectorClasses = createClassAndSelector("waterfall-connector"), 
                WaterfallChart.defaultTotalColor = "#00b8aa", WaterfallChart.validLabelPositions = [ 16, 4 ], 
                WaterfallChart.validZeroLabelPosition = [ 16, 8 ], WaterfallChart;
            }();
            visuals.WaterfallChart = WaterfallChart;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var TouchUtils = powerbi.visuals.controls.TouchUtils, createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, ContainerClassName = createClassAndSelector("tooltip-container"), ContentContainerClassName = createClassAndSelector("tooltip-content-container"), ArrowClassName = createClassAndSelector("arrow"), TooltipHeaderClassName = createClassAndSelector("tooltip-header"), TooltipRowClassName = createClassAndSelector("tooltip-row"), TooltipColorCellClassName = createClassAndSelector("tooltip-color-cell"), TooltipTitleCellClassName = createClassAndSelector("tooltip-title-cell"), TooltipValueCellClassName = createClassAndSelector("tooltip-value-cell"), ToolTipComponent = function() {
                function ToolTipComponent(tooltipOptions) {
                    this.tooltipOptions = tooltipOptions, this.isTooltipVisible = !1, tooltipOptions || (this.tooltipOptions = ToolTipComponent.DefaultTooltipOptions);
                }
                return ToolTipComponent.prototype.isTooltipComponentVisible = function() {
                    return this.isTooltipVisible;
                }, ToolTipComponent.prototype.setTestScreenSize = function(width, height) {
                    this.customScreenWidth = width, this.customScreenHeight = height;
                }, ToolTipComponent.prototype.show = function(tooltipData, clickedArea) {
                    this.isTooltipVisible = !0, this.tooltipContainer || (this.tooltipContainer = this.createTooltipContainer()), 
                    this.setTooltipContent(tooltipData), this.tooltipContainer.style("visibility", "visible").transition().duration(0).style("opacity", this.tooltipOptions.opacity), 
                    this.setPosition(clickedArea);
                }, ToolTipComponent.prototype.move = function(tooltipData, clickedArea) {
                    this.isTooltipVisible && (tooltipData && this.setTooltipContent(tooltipData), this.setPosition(clickedArea));
                }, ToolTipComponent.prototype.hide = function() {
                    this.isTooltipVisible && (this.isTooltipVisible = !1, this.tooltipContainer.transition().duration(this.tooltipOptions.animationDuration).style("opacity", 0).each("end", function() {
                        this.style.visibility = "hidden";
                    }));
                }, ToolTipComponent.prototype.createTooltipContainer = function() {
                    var container = d3.select(ToolTipComponent.parentContainerSelector).append("div").attr("class", ContainerClassName["class"]);
                    return container.append("div").attr("class", ArrowClassName["class"]), container.append("div").attr("class", ContentContainerClassName["class"]), 
                    container;
                }, ToolTipComponent.prototype.setTooltipContent = function(tooltipData) {
                    if (!_.isEqual(tooltipData, this.currentTooltipData)) {
                        this.currentTooltipData = tooltipData;
                        var rowsSelector = TooltipRowClassName.selector, contentContainer = this.tooltipContainer.select(ContentContainerClassName.selector);
                        if (contentContainer.selectAll(TooltipHeaderClassName.selector).remove(), contentContainer.selectAll(TooltipRowClassName.selector).remove(), 
                        0 !== tooltipData.length) {
                            tooltipData[0].header && contentContainer.append("div").attr("class", TooltipHeaderClassName["class"]).text(tooltipData[0].header);
                            var tooltipRow = contentContainer.selectAll(rowsSelector).data(tooltipData), newRow = tooltipRow.enter().append("div").attr("class", TooltipRowClassName["class"]);
                            if (_.any(tooltipData, function(tooltipItem) {
                                return tooltipItem.color;
                            })) {
                                var newColorCell = newRow.filter(function(d) {
                                    return d.color;
                                }).append("div").attr("class", TooltipColorCellClassName["class"]);
                                newColorCell.append("svg").attr({
                                    width: "100%",
                                    height: "15px"
                                }).append("circle").attr({
                                    cx: "5",
                                    cy: "8",
                                    r: "5"
                                }).style({
                                    fill: function(d) {
                                        return d.color;
                                    },
                                    "fill-opacity": function(d) {
                                        return null != d.opacity ? d.opacity : 1;
                                    }
                                });
                            }
                            var newTitleCell = newRow.append("div").attr("class", TooltipTitleCellClassName["class"]), newValueCell = newRow.append("div").attr("class", TooltipValueCellClassName["class"]);
                            newTitleCell.text(function(d) {
                                return d.displayName;
                            }), newValueCell.text(function(d) {
                                return d.value;
                            });
                        }
                    }
                }, ToolTipComponent.prototype.getTooltipPosition = function(clickedArea, clickedScreenArea) {
                    var tooltipContainerBounds = this.tooltipContainer.node().getBoundingClientRect(), centerPointOffset = Math.floor(clickedArea.width / 2), offsetX = 0, offsetY = 0, centerPoint = new TouchUtils.Point(clickedArea.x + centerPointOffset, clickedArea.y + centerPointOffset), arrowOffset = 7;
                    return 0 === clickedScreenArea ? (offsetX += 3 * arrowOffset + centerPointOffset, 
                    offsetY -= 2 * arrowOffset + centerPointOffset) : 1 === clickedScreenArea ? (offsetX -= 2 * arrowOffset + tooltipContainerBounds.width + centerPointOffset, 
                    offsetY -= 2 * arrowOffset + centerPointOffset) : 3 === clickedScreenArea ? (offsetX += 3 * arrowOffset + centerPointOffset, 
                    offsetY -= tooltipContainerBounds.height - 2 * arrowOffset + centerPointOffset) : 2 === clickedScreenArea && (offsetX -= 2 * arrowOffset + tooltipContainerBounds.width + centerPointOffset, 
                    offsetY -= tooltipContainerBounds.height - 2 * arrowOffset + centerPointOffset), 
                    centerPoint.offset(offsetX, offsetY), centerPoint;
                }, ToolTipComponent.prototype.setPosition = function(clickedArea) {
                    var clickedScreenArea = this.getClickedScreenArea(clickedArea), tooltipPosition = this.getTooltipPosition(clickedArea, clickedScreenArea);
                    this.setTooltipContainerClass(clickedScreenArea), this.tooltipContainer.style({
                        left: tooltipPosition.x + "px",
                        top: tooltipPosition.y + "px"
                    }), this.setArrowPosition(clickedScreenArea);
                }, ToolTipComponent.prototype.setTooltipContainerClass = function(clickedScreenArea) {
                    var tooltipContainerClassName;
                    switch (clickedScreenArea) {
                      case 0:
                      case 3:
                        tooltipContainerClassName = "left";
                        break;

                      case 1:
                      case 2:
                        tooltipContainerClassName = "right";
                    }
                    this.tooltipContainer.attr("class", ContainerClassName["class"]).classed(tooltipContainerClassName, !0);
                }, ToolTipComponent.prototype.setArrowPosition = function(clickedScreenArea) {
                    var arrowClassName, arrow = this.getArrowElement();
                    arrowClassName = 0 === clickedScreenArea ? "top left" : 1 === clickedScreenArea ? "top right" : 3 === clickedScreenArea ? "bottom left" : "bottom right", 
                    arrow.attr("class", "arrow").classed(arrowClassName, !0);
                }, ToolTipComponent.prototype.getArrowElement = function() {
                    return this.tooltipContainer.select(ArrowClassName.selector);
                }, ToolTipComponent.prototype.getClickedScreenArea = function(clickedArea) {
                    var screenWidth = this.customScreenWidth || window.innerWidth, screenHeight = this.customScreenHeight || window.innerHeight, centerPointOffset = clickedArea.width / 2, centerPoint = new TouchUtils.Point(clickedArea.x + centerPointOffset, clickedArea.y + centerPointOffset), halfWidth = screenWidth / 2, halfHeight = screenHeight / 2;
                    return centerPoint.x < halfWidth && centerPoint.y < halfHeight ? 0 : centerPoint.x >= halfWidth && centerPoint.y < halfHeight ? 1 : centerPoint.x < halfWidth && centerPoint.y >= halfHeight ? 3 : centerPoint.x >= halfWidth && centerPoint.y >= halfHeight ? 2 : void 0;
                }, ToolTipComponent.DefaultTooltipOptions = {
                    opacity: 1,
                    animationDuration: 250,
                    offsetX: 10,
                    offsetY: 10
                }, ToolTipComponent.parentContainerSelector = "body", ToolTipComponent.highlightedValueDisplayNameResorceKey = "Tooltip_HighlightedValueDisplayName", 
                ToolTipComponent;
            }();
            visuals.ToolTipComponent = ToolTipComponent;
            var TooltipManager;
            !function(TooltipManager) {
                function addTooltip(selection, getTooltipInfoDelegate, reloadTooltipDataOnMouseMove, onMouseOutDelegate) {
                    if (TooltipManager.ShowTooltips) {
                        var rootNode = d3.select(ToolTipComponent.parentContainerSelector).node();
                        selection.on("mouseover", function() {
                            var target = d3.event.target, data = d3.select(target).datum();
                            if (!handleTouchTimeoutId && canDisplayTooltip(d3.event)) {
                                mouseCoordinates = getCoordinates(rootNode, !0);
                                var elementCoordinates = getCoordinates(target, !0), tooltipEvent = {
                                    data: data,
                                    coordinates: mouseCoordinates,
                                    elementCoordinates: elementCoordinates,
                                    context: target,
                                    isTouchEvent: !1
                                };
                                clearTooltipTimeout();
                                var delay = TooltipManager.ToolTipInstance.isTooltipComponentVisible() ? 16 : tooltipMouseOverDelay;
                                tooltipTimeoutId = showDelayedTooltip(tooltipEvent, getTooltipInfoDelegate, delay);
                            }
                        }), selection.on("mouseout", function() {
                            handleTouchTimeoutId || (clearTooltipTimeout(), tooltipTimeoutId = hideDelayedTooltip()), 
                            onMouseOutDelegate && onMouseOutDelegate();
                        }), selection.on("mousemove", function() {
                            var target = d3.event.target, data = d3.select(target).datum();
                            if (!handleTouchTimeoutId && canDisplayTooltip(d3.event)) {
                                mouseCoordinates = getCoordinates(rootNode, !0);
                                var elementCoordinates = getCoordinates(target, !0), tooltipEvent = {
                                    data: data,
                                    coordinates: mouseCoordinates,
                                    elementCoordinates: elementCoordinates,
                                    context: target,
                                    isTouchEvent: !1
                                };
                                moveTooltipEventHandler(tooltipEvent, getTooltipInfoDelegate, reloadTooltipDataOnMouseMove);
                            }
                        });
                        var touchStartEventName = getTouchStartEventName(), touchEndEventName = getTouchEndEventName(), isPointerEvent = "pointerdown" === touchStartEventName || "MSPointerDown" === touchStartEventName;
                        GlobalTooltipEventsAttached || (attachGlobalEvents(touchStartEventName), GlobalTooltipEventsAttached = !0), 
                        selection.on(touchStartEventName, function() {
                            var target = d3.event.target, data = d3.select(target).datum();
                            hideTooltipEventHandler();
                            var coordinates = getCoordinates(rootNode, isPointerEvent), elementCoordinates = getCoordinates(target, isPointerEvent), tooltipEvent = {
                                data: data,
                                coordinates: coordinates,
                                elementCoordinates: elementCoordinates,
                                context: target,
                                isTouchEvent: !0
                            };
                            clearTooltipTimeout(), tooltipTimeoutId = showDelayedTooltip(tooltipEvent, getTooltipInfoDelegate, tooltipTouchDelay);
                        }), selection.on(touchEndEventName, function() {
                            clearTooltipTimeout(), handleTouchTimeoutId && clearTimeout(handleTouchTimeoutId), 
                            handleTouchTimeoutId = setTimeout(function() {
                                handleTouchTimeoutId = 0;
                            }, handleTouchDelay);
                        });
                    }
                }
                function showDelayedTooltip(tooltipEvent, getTooltipInfoDelegate, delayInMs) {
                    return setTimeout(function() {
                        return showTooltipEventHandler(tooltipEvent, getTooltipInfoDelegate);
                    }, delayInMs);
                }
                function hideDelayedTooltip() {
                    return setTimeout(function() {
                        return hideTooltipEventHandler();
                    }, tooltipMouseOutDelay);
                }
                function setLocalizedStrings(localizationOptions) {
                    ToolTipComponent.localizationOptions = localizationOptions;
                }
                function showTooltipEventHandler(tooltipEvent, getTooltipInfoDelegate) {
                    var tooltipInfo = tooltipData || getTooltipInfoDelegate(tooltipEvent);
                    if (!_.isEmpty(tooltipInfo)) {
                        var coordinates = mouseCoordinates || tooltipEvent.coordinates, clickedArea = getClickedArea(coordinates[0], coordinates[1], tooltipEvent.isTouchEvent);
                        TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
                    }
                }
                function moveTooltipEventHandler(tooltipEvent, getTooltipInfoDelegate, reloadTooltipDataOnMouseMove) {
                    tooltipData = void 0, reloadTooltipDataOnMouseMove && (tooltipData = getTooltipInfoDelegate(tooltipEvent));
                    var clickedArea = getClickedArea(tooltipEvent.coordinates[0], tooltipEvent.coordinates[1], tooltipEvent.isTouchEvent);
                    TooltipManager.ToolTipInstance.move(tooltipData, clickedArea);
                }
                function hideTooltipEventHandler() {
                    TooltipManager.ToolTipInstance.hide();
                }
                function clearTooltipTimeout() {
                    tooltipTimeoutId && clearTimeout(tooltipTimeoutId);
                }
                function canDisplayTooltip(d3Event) {
                    var cadDisplay = !0, mouseEvent = d3Event;
                    if (void 0 !== mouseEvent.buttons) {
                        var hasMouseButtonPressed = 0 !== mouseEvent.buttons;
                        cadDisplay = !hasMouseButtonPressed;
                    }
                    return cadDisplay;
                }
                function getTouchStartEventName() {
                    var eventName = "touchstart";
                    return window.PointerEvent ? eventName = "pointerdown" : window.MSPointerEvent && (eventName = "MSPointerDown"), 
                    eventName;
                }
                function getTouchEndEventName() {
                    var eventName = "touchend";
                    return window.PointerEvent ? eventName = "pointerup" : window.MSPointerEvent && (eventName = "MSPointerUp"), 
                    eventName;
                }
                function getCoordinates(rootNode, isPointerEvent) {
                    var coordinates;
                    if (isPointerEvent) {
                        for (var e = d3.event, s = void 0; s = e.sourceEvent; ) e = s;
                        var rect = rootNode.getBoundingClientRect();
                        coordinates = [ e.clientX - rect.left - rootNode.clientLeft, e.clientY - rect.top - rootNode.clientTop ];
                    } else {
                        var touchCoordinates = d3.touches(rootNode);
                        touchCoordinates && touchCoordinates.length > 0 && (coordinates = touchCoordinates[0]);
                    }
                    return coordinates;
                }
                function attachGlobalEvents(touchStartEventName) {
                    d3.select(ToolTipComponent.parentContainerSelector).on(touchStartEventName, function(d, i) {
                        TooltipManager.ToolTipInstance.hide();
                    });
                }
                function getClickedArea(x, y, isTouchEvent) {
                    var width = 0, pointX = x, pointY = y;
                    if (isTouchEvent) {
                        width = 12;
                        var offset = width / 2;
                        pointX = Math.max(x - offset, 0), pointY = Math.max(y - offset, 0);
                    }
                    return new TouchUtils.Rectangle(pointX, pointY, width, width);
                }
                TooltipManager.ShowTooltips = !0, TooltipManager.ToolTipInstance = new ToolTipComponent();
                var tooltipTimeoutId, mouseCoordinates, tooltipData, GlobalTooltipEventsAttached = !1, tooltipMouseOverDelay = 350, tooltipMouseOutDelay = 500, tooltipTouchDelay = 350, handleTouchDelay = 1e3, handleTouchTimeoutId = 0;
                TooltipManager.addTooltip = addTooltip, TooltipManager.showDelayedTooltip = showDelayedTooltip, 
                TooltipManager.hideDelayedTooltip = hideDelayedTooltip, TooltipManager.setLocalizedStrings = setLocalizedStrings;
            }(TooltipManager = visuals.TooltipManager || (visuals.TooltipManager = {}));
            var TooltipBuilder;
            !function(TooltipBuilder) {
                function createTooltipInfo(formatStringProp, dataViewCat, categoryValue, value, categories, seriesData, seriesIndex, categoryIndex, highlightedValue, gradientValueColumn) {
                    var categorySource, seriesSource = [], valuesSource = void 0;
                    seriesIndex = 0 | seriesIndex;
                    var categoriesData = dataViewCat ? dataViewCat.categories : categories;
                    if (categoriesData && categoriesData.length > 0) if (categoriesData.length > 1) {
                        for (var compositeCategoriesData = [], i = 0, ilen = categoriesData.length; ilen > i; i++) compositeCategoriesData.push(categoriesData[i].source);
                        categorySource = {
                            value: categoryValue,
                            metadata: compositeCategoriesData
                        };
                    } else categorySource = {
                        value: categoryValue,
                        metadata: [ categoriesData[0].source ]
                    };
                    if (dataViewCat && dataViewCat.values) {
                        if (categorySource && categorySource.metadata[0] === dataViewCat.values.source || (valuesSource = dataViewCat.values.source), 
                        dataViewCat.values.length > 0) {
                            var valueColumn = dataViewCat.values[seriesIndex], isAutoGeneratedColumn = !!(valueColumn && valueColumn.source && valueColumn.source.isAutoGeneratedColumn);
                            isAutoGeneratedColumn || seriesSource.push({
                                value: value,
                                highlightedValue: highlightedValue,
                                metadata: valueColumn
                            });
                        }
                        var gradientToolTipData = createGradientToolTipData(gradientValueColumn, categoryIndex);
                        null != gradientToolTipData && seriesSource.push(gradientToolTipData);
                    }
                    if (seriesData) for (var i = 0, len = seriesData.length; len > i; i++) {
                        var singleSeriesData = seriesData[i];
                        categorySource && categorySource.metadata[0] === singleSeriesData.metadata.source || seriesSource.push({
                            value: singleSeriesData.value,
                            metadata: singleSeriesData.metadata
                        });
                    }
                    var tooltipInfo = createTooltipData(formatStringProp, categorySource, valuesSource, seriesSource);
                    return tooltipInfo;
                }
                function createGradientToolTipData(gradientValueColumn, categoryIndex) {
                    return gradientValueColumn ? {
                        value: gradientValueColumn.values[categoryIndex],
                        metadata: {
                            source: gradientValueColumn.source,
                            values: []
                        }
                    } : null;
                }
                function createTooltipData(formatStringProp, categoryValue, valuesSource, seriesValues) {
                    var items = [];
                    if (categoryValue) if (categoryValue.metadata.length > 1) {
                        for (var displayName = "", i = 0, ilen = categoryValue.metadata.length; ilen > i; i++) 0 !== i && (displayName += "/"), 
                        displayName += categoryValue.metadata[i].displayName;
                        var categoryFormattedValue = getFormattedValue(categoryValue.metadata[0], formatStringProp, categoryValue.value);
                        items.push({
                            displayName: displayName,
                            value: categoryFormattedValue
                        });
                    } else {
                        var categoryFormattedValue = getFormattedValue(categoryValue.metadata[0], formatStringProp, categoryValue.value);
                        items.push({
                            displayName: categoryValue.metadata[0].displayName,
                            value: categoryFormattedValue
                        });
                    }
                    if (valuesSource) {
                        var dynamicValue = void 0;
                        if (seriesValues.length > 0) {
                            var dynamicValueMetadata = seriesValues[0].metadata.source;
                            dynamicValue = getFormattedValue(valuesSource, formatStringProp, dynamicValueMetadata.groupName);
                        }
                        items.push({
                            displayName: valuesSource.displayName,
                            value: dynamicValue
                        });
                    }
                    for (var i = 0; i < seriesValues.length; i++) {
                        var seriesData = seriesValues[i];
                        if (seriesData && seriesData.metadata) {
                            var seriesMetadataColumn = seriesData.metadata.source, value = seriesData.value, highlightedValue = seriesData.highlightedValue;
                            if (value || 0 === value) {
                                var formattedValue = getFormattedValue(seriesMetadataColumn, formatStringProp, value);
                                items.push({
                                    displayName: seriesMetadataColumn.displayName,
                                    value: formattedValue
                                });
                            }
                            if (highlightedValue || 0 === highlightedValue) {
                                var formattedHighlightedValue = getFormattedValue(seriesMetadataColumn, formatStringProp, highlightedValue), displayName = ToolTipComponent.localizationOptions.highlightedValueDisplayName;
                                items.push({
                                    displayName: displayName,
                                    value: formattedHighlightedValue
                                });
                            }
                        }
                    }
                    return items;
                }
                function addTooltipBucketItem(reader, tooltipInfo, categoryIndex, seriesIndex) {
                    var tooltipValues = reader.getAllValuesForRole("Tooltips", categoryIndex, seriesIndex), tooltipMetadataColumns = reader.getAllValueMetadataColumnsForRole("Tooltips", seriesIndex);
                    if (tooltipValues && tooltipMetadataColumns) for (var j = 0; j < tooltipValues.length; j++) null != tooltipValues[j] && tooltipMetadataColumns[j] && tooltipInfo.push({
                        displayName: tooltipMetadataColumns[j].displayName,
                        value: visuals.converterHelper.formatFromMetadataColumn(tooltipValues[j], tooltipMetadataColumns[j], visuals.Gauge.formatStringProp)
                    });
                }
                function getFormattedValue(column, formatStringProp, value) {
                    var formatString = getFormatStringFromColumn(column, formatStringProp);
                    return visuals.valueFormatter.format(value, formatString);
                }
                function getFormatStringFromColumn(column, formatStringProp) {
                    if (column) {
                        var formatString = visuals.valueFormatter.getFormatString(column, formatStringProp, !0);
                        return formatString || column.format;
                    }
                    return null;
                }
                TooltipBuilder.createTooltipInfo = createTooltipInfo, TooltipBuilder.createGradientToolTipData = createGradientToolTipData, 
                TooltipBuilder.addTooltipBucketItem = addTooltipBucketItem;
            }(TooltipBuilder = visuals.TooltipBuilder || (visuals.TooltipBuilder = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var visualStyles;
            !function(visualStyles) {
                function create(dataColors) {
                    return void 0 === dataColors && (dataColors = new visuals.DataColorPalette()), {
                        titleText: {
                            color: {
                                value: "#333"
                            }
                        },
                        subTitleText: {
                            color: {
                                value: "#919191"
                            }
                        },
                        colorPalette: {
                            foreground: {
                                value: "#333"
                            },
                            background: {
                                value: "#fff"
                            },
                            tableAccent: {
                                value: dataColors.getColorByIndex(0).value
                            },
                            dataColors: dataColors
                        },
                        labelText: {
                            color: {
                                value: "#333"
                            },
                            fontSize: "11px"
                        },
                        isHighContrast: !1
                    };
                }
                visualStyles.create = create;
            }(visualStyles = visuals.visualStyles || (visuals.visualStyles = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, DonutChart = function() {
                function DonutChart(options) {
                    options && (this.sliceWidthRatio = options.sliceWidthRatio, this.animator = options.animator, 
                    this.isScrollable = options.isScrollable ? options.isScrollable : !1, this.disableGeometricCulling = options.disableGeometricCulling ? options.disableGeometricCulling : !1, 
                    this.behavior = options.behavior, this.tooltipsEnabled = options.tooltipsEnabled, 
                    this.tooltipBucketEnabled = options.tooltipBucketEnabled, options.smallViewPortProperties && (this.maxHeightToScaleDonutLegend = options.smallViewPortProperties.maxHeightToScaleDonutLegend)), 
                    null == this.sliceWidthRatio && (this.sliceWidthRatio = DonutChart.defaultSliceWidthRatio);
                }
                return DonutChart.converter = function(dataView, colors, defaultDataPointColor, viewport, disableGeometricCulling, interactivityService, tooltipsEnabled, tooltipBucketEnabled) {
                    void 0 === tooltipsEnabled && (tooltipsEnabled = !0);
                    var converter = new DonutChartConversion.DonutChartConverter(dataView, colors, defaultDataPointColor, tooltipsEnabled, tooltipBucketEnabled);
                    converter.convert();
                    var d3PieLayout = d3.layout.pie().sort(null).value(function(d) {
                        return d.percentage;
                    });
                    interactivityService && (interactivityService.applySelectionStateToData(converter.dataPoints), 
                    interactivityService.applySelectionStateToData(converter.legendData.dataPoints));
                    var culledDataPoints = !disableGeometricCulling && viewport ? DonutChart.cullDataByViewport(converter.dataPoints, converter.maxValue, viewport) : converter.dataPoints;
                    return {
                        dataPointsToDeprecate: culledDataPoints,
                        dataPoints: d3PieLayout(culledDataPoints),
                        unCulledDataPoints: converter.dataPoints,
                        dataPointsToEnumerate: converter.legendData.dataPoints,
                        legendData: converter.legendData,
                        hasHighlights: converter.hasHighlights,
                        highlightsOverflow: converter.highlightsOverflow,
                        dataLabelsSettings: converter.dataLabelsSettings,
                        legendObjectProperties: converter.legendObjectProperties,
                        maxValue: converter.maxValue,
                        visibleGeometryCulled: converter.dataPoints.length !== culledDataPoints.length,
                        hasNegativeValues: converter.hasNegativeValues,
                        allValuesAreNegative: converter.allValuesAreNegative
                    };
                }, DonutChart.prototype.init = function(options) {
                    this.options = options;
                    var element = options.element;
                    element.empty(), this.parentViewport = options.viewport, this.currentViewport = {
                        height: options.viewport.height,
                        width: options.viewport.width
                    }, this.formatter = visuals.valueFormatter.format, this.data = {
                        dataPointsToDeprecate: [],
                        dataPointsToEnumerate: [],
                        dataPoints: [],
                        unCulledDataPoints: [],
                        legendData: {
                            title: "",
                            dataPoints: [],
                            fontSize: visuals.SVGLegend.DefaultFontSizeInPt
                        },
                        hasHighlights: !1,
                        highlightsOverflow: !1,
                        dataLabelsSettings: visuals.dataLabelUtils.getDefaultDonutLabelSettings(),
                        hasNegativeValues: !1,
                        allValuesAreNegative: !1
                    }, this.drilled = !1, this.allowDrilldown = !1, this.style = options.style, this.colors = this.style.colorPalette.dataColors, 
                    this.radius = 0, this.isInteractive = options.interactivity && options.interactivity.isInteractiveLegend;
                    var donutChartSettings = this.settings;
                    if (this.behavior && (this.interactivityService = visuals.createInteractivityService(options.host)), 
                    this.legend = visuals.createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, this.interactivityService, this.isScrollable), 
                    this.hostService = options.host, this.isInteractive) {
                        this.chartRotationAnimationDuration = donutChartSettings && donutChartSettings.chartRotationAnimationDuration ? donutChartSettings.chartRotationAnimationDuration : 0;
                        var legendContainer = this.legendContainer = d3.select(element.get(0)).append("div").classed(DonutChart.InteractiveLegendClassName, !0);
                        this.interactivityState = {
                            interactiveLegend: new DonutChartInteractiveLegend(this, legendContainer, this.colors, options, this.settings),
                            valueToAngleFactor: 0,
                            sliceAngles: [],
                            currentRotate: 0,
                            interactiveChosenSliceFinishedSetting: !1,
                            lastChosenInteractiveSliceIndex: 0,
                            totalDragAngleDifference: 0,
                            currentIndexDrag: 0,
                            previousIndexDrag: 0,
                            previousDragAngle: 0,
                            donutCenter: {
                                x: 0,
                                y: 0
                            }
                        };
                    }
                    this.svg = d3.select(element.get(0)).append("svg").style("position", "absolute").classed(DonutChart.ClassName, !0), 
                    this.behavior && (this.clearCatcher = visuals.appendClearCatcher(this.svg)), this.mainGraphicsContext = this.svg.append("g"), 
                    this.mainGraphicsContext.append("g").classed("slices", !0), this.labelGraphicsContext = this.svg.append("g").classed(visuals.NewDataLabelUtils.labelGraphicsContextClass["class"], !0), 
                    this.pie = d3.layout.pie().sort(null).value(function(d) {
                        return d.percentage;
                    });
                }, DonutChart.prototype.update = function(options) {
                    var viewport = options.viewport;
                    this.parentViewport = viewport;
                    var dataViews = this.dataViews = options.dataViews;
                    if (dataViews && dataViews.length > 0 && dataViews[0].categorical) {
                        var dataViewMetadata = dataViews[0].metadata, defaultDataPointColor = void 0;
                        if (dataViewMetadata) {
                            var objects = dataViewMetadata.objects;
                            objects && (defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.donutChartProps.dataPoint.defaultColor));
                        }
                        this.data = DonutChart.converter(dataViews[0], this.colors, defaultDataPointColor, this.currentViewport, this.disableGeometricCulling, this.interactivityService, this.tooltipsEnabled, this.tooltipBucketEnabled), 
                        this.data.defaultDataPointColor = defaultDataPointColor, this.options.interactivity && this.options.interactivity.isInteractiveLegend || this.renderLegend();
                    } else this.data = {
                        dataPointsToDeprecate: [],
                        dataPointsToEnumerate: [],
                        dataPoints: [],
                        unCulledDataPoints: [],
                        legendData: {
                            title: "",
                            dataPoints: []
                        },
                        hasHighlights: !1,
                        highlightsOverflow: !1,
                        dataLabelsSettings: visuals.dataLabelUtils.getDefaultDonutLabelSettings(),
                        hasNegativeValues: !1,
                        allValuesAreNegative: !1
                    };
                    if (this.initViewportDependantProperties(), this.initDonutProperties(), this.updateInternal(this.data, options.suppressAnimations), 
                    this.hasSetData = !0, dataViews) {
                        var warnings = visuals.getInvalidValueWarnings(dataViews, !1, !1, !1);
                        this.data.allValuesAreNegative ? warnings.push(new visuals.AllNegativeValuesWarning()) : this.data.hasNegativeValues && warnings.push(new visuals.NegativeValuesNotSupportedWarning()), 
                        this.hostService.setWarnings(warnings);
                    }
                }, DonutChart.prototype.onDataChanged = function(options) {
                    this.update({
                        dataViews: options.dataViews,
                        suppressAnimations: options.suppressAnimations,
                        viewport: this.currentViewport
                    });
                }, DonutChart.prototype.onResizing = function(viewport) {
                    this.update({
                        dataViews: this.dataViews,
                        suppressAnimations: !0,
                        viewport: viewport
                    });
                }, DonutChart.prototype.enumerateObjectInstances = function(options) {
                    var enumeration = new visuals.ObjectEnumerationBuilder(), dataLabelsSettings = this.data && this.data.dataLabelsSettings ? this.data.dataLabelsSettings : visuals.dataLabelUtils.getDefaultDonutLabelSettings();
                    switch (options.objectName) {
                      case "legend":
                        this.enumerateLegend(enumeration);
                        break;

                      case "dataPoint":
                        this.enumerateDataPoints(enumeration);
                        break;

                      case "labels":
                        var labelSettingOptions = {
                            enumeration: enumeration,
                            dataLabelsSettings: dataLabelsSettings,
                            show: !0,
                            displayUnits: !0,
                            precision: !0,
                            fontSize: !0,
                            labelStyle: !0
                        };
                        visuals.dataLabelUtils.enumerateDataLabels(labelSettingOptions);
                    }
                    return enumeration.complete();
                }, DonutChart.prototype.enumerateDataPoints = function(enumeration) {
                    var data = this.data;
                    if (data) for (var dataPoints = data.dataPointsToEnumerate, dataPointsLength = dataPoints.length, i = 0; dataPointsLength > i; i++) {
                        var dataPoint = dataPoints[i];
                        enumeration.pushInstance({
                            objectName: "dataPoint",
                            displayName: dataPoint.label,
                            selector: visuals.ColorHelper.normalizeSelector(dataPoint.identity.getSelector()),
                            properties: {
                                fill: {
                                    solid: {
                                        color: dataPoint.color
                                    }
                                }
                            }
                        });
                    }
                }, DonutChart.prototype.enumerateLegend = function(enumeration) {
                    var data = this.data;
                    if (data) {
                        var legendObjectProperties = {
                            legend: data.legendObjectProperties
                        }, show = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.donutChartProps.legend.show, this.legend.isVisible()), showTitle = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.donutChartProps.legend.showTitle, !0), titleText = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.donutChartProps.legend.titleText, this.data.legendData.title), labelColor = powerbi.DataViewObject.getValue(legendObjectProperties, visuals.legendProps.labelColor, this.data.legendData.labelColor), labelFontSize = powerbi.DataViewObject.getValue(legendObjectProperties, visuals.legendProps.fontSize, this.data.legendData.fontSize), position = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.donutChartProps.legend.position, visuals.legendPosition.top);
                        enumeration.pushInstance({
                            selector: null,
                            objectName: "legend",
                            properties: {
                                show: show,
                                position: position,
                                showTitle: showTitle,
                                titleText: titleText,
                                labelColor: labelColor,
                                fontSize: labelFontSize
                            }
                        });
                    }
                }, DonutChart.prototype.setInteractiveChosenSlice = function(sliceIndex) {
                    var _this = this;
                    if (0 !== this.interactivityState.sliceAngles.length) {
                        this.interactivityState.lastChosenInteractiveSliceIndex = sliceIndex, this.interactivityState.interactiveChosenSliceFinishedSetting = !1;
                        var viewport = this.currentViewport, moduledIndex = sliceIndex % this.data.dataPoints.length, angle = this.interactivityState.sliceAngles[moduledIndex];
                        this.svg.select("g").transition().duration(this.chartRotationAnimationDuration).ease("elastic").attr("transform", visuals.SVGUtil.translateAndRotate(viewport.width / 2, viewport.height / 2, 0, 0, angle)).each("end", function() {
                            _this.interactivityState.interactiveChosenSliceFinishedSetting = !0;
                        }), this.interactivityState.currentRotate = angle, this.interactivityState.interactiveLegend.updateLegend(moduledIndex), 
                        this.svg.selectAll(".slice").attr("opacity", function(d, index) {
                            return index === moduledIndex ? 1 : .6;
                        }), visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
                    }
                }, DonutChart.prototype.calculateRadius = function() {
                    var viewport = this.currentViewport;
                    if (!this.isInteractive && this.data && this.data.dataLabelsSettings.show) {
                        var hw = viewport.height / viewport.width, denom = 2 + 1 / (1 + Math.exp(-5 * (hw - 1)));
                        return Math.min(viewport.height, viewport.width) / denom;
                    }
                    return Math.min(viewport.height, viewport.width) / 2;
                }, DonutChart.prototype.getScaleForLegendArrow = function() {
                    var ratio = 1;
                    return this.maxHeightToScaleDonutLegend && this.currentViewport.height < this.maxHeightToScaleDonutLegend && (ratio = this.currentViewport.height / this.maxHeightToScaleDonutLegend), 
                    ratio;
                }, DonutChart.prototype.initViewportDependantProperties = function(duration) {
                    void 0 === duration && (duration = 0), this.currentViewport.height = this.parentViewport.height, 
                    this.currentViewport.width = this.parentViewport.width;
                    var viewport = this.currentViewport;
                    if (this.isInteractive) viewport.height -= DonutChart.InteractiveLegendContainerHeight; else {
                        var legendMargins = this.legend.getMargins();
                        viewport.height -= legendMargins.height, viewport.width -= legendMargins.width;
                    }
                    this.svg.attr({
                        width: viewport.width,
                        height: viewport.height
                    }), this.isInteractive ? (this.legendContainer.style({
                        width: "100%",
                        height: DonutChart.InteractiveLegendContainerHeight + "px",
                        overflow: "hidden",
                        top: 0
                    }), this.svg.style("top", DonutChart.InteractiveLegendContainerHeight)) : visuals.Legend.positionChartArea(this.svg, this.legend), 
                    this.previousRadius = this.radius;
                    var radius = this.radius = this.calculateRadius(), halfViewportWidth = viewport.width / 2, halfViewportHeight = viewport.height / 2;
                    this.arc = d3.svg.arc(), this.outerArc = d3.svg.arc().innerRadius(radius * DonutChart.OuterArcRadiusRatio).outerRadius(radius * DonutChart.OuterArcRadiusRatio), 
                    this.isInteractive ? (this.mainGraphicsContext.attr("transform", visuals.SVGUtil.translate(halfViewportWidth, halfViewportHeight)), 
                    this.labelGraphicsContext.attr("transform", visuals.SVGUtil.translate(halfViewportWidth, halfViewportHeight))) : (this.mainGraphicsContext.transition().duration(duration).attr("transform", visuals.SVGUtil.translate(halfViewportWidth, halfViewportHeight)), 
                    this.labelGraphicsContext.transition().duration(duration).attr("transform", visuals.SVGUtil.translate(halfViewportWidth, halfViewportHeight))), 
                    visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
                }, DonutChart.prototype.initDonutProperties = function() {
                    this.donutProperties = {
                        viewport: this.currentViewport,
                        radius: this.radius,
                        arc: this.arc.innerRadius(0).outerRadius(this.radius * DonutChart.InnerArcRadiusRatio),
                        outerArc: this.outerArc,
                        innerArcRadiusRatio: DonutChart.InnerArcRadiusRatio,
                        outerArcRadiusRatio: DonutChart.OuterArcRadiusRatio,
                        dataLabelsSettings: this.data.dataLabelsSettings
                    };
                }, DonutChart.prototype.mergeDatasets = function(first, second) {
                    var secondSet = d3.set();
                    second.forEach(function(d) {
                        secondSet.add(d.identity ? d.identity.getKey() : d.data.identity.getKey());
                    });
                    var onlyFirst = first.filter(function(d) {
                        return !secondSet.has(d.identity ? d.identity.getKey() : d.data.identity.getKey());
                    }).map(function(d) {
                        var derived = powerbi.Prototype.inherit(d);
                        return void 0 === derived.percentage ? derived.data.percentage = 0 : derived.percentage = 0, 
                        derived;
                    });
                    return d3.merge([ second, onlyFirst ]);
                }, DonutChart.prototype.updateInternal = function(data, suppressAnimations, duration) {
                    void 0 === duration && (duration = 0);
                    var viewport = this.currentViewport;
                    if (duration = duration || visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations), 
                    this.animator) {
                        var shapes_1, layout = DonutChart.getLayout(this.radius, this.sliceWidthRatio, viewport), result = void 0, highlightShapes = void 0, labelSettings = data.dataLabelsSettings, labels = [];
                        if (labelSettings && labelSettings.show && (labels = this.createLabels()), !suppressAnimations) {
                            var animationOptions = {
                                viewModel: data,
                                colors: this.colors,
                                graphicsContext: this.mainGraphicsContext,
                                labelGraphicsContext: this.labelGraphicsContext,
                                interactivityService: this.interactivityService,
                                layout: layout,
                                radius: this.radius,
                                sliceWidthRatio: this.sliceWidthRatio,
                                viewport: viewport,
                                labels: labels,
                                innerArcRadiusRatio: DonutChart.InnerArcRadiusRatio
                            };
                            result = this.animator.animate(animationOptions), shapes_1 = result.shapes, highlightShapes = result.highlightShapes;
                        }
                        (suppressAnimations || result.failed) && (shapes_1 = DonutChart.drawDefaultShapes(this.svg, data, layout, this.colors, this.radius, this.interactivityService && this.interactivityService.hasSelection(), this.sliceWidthRatio, this.data.defaultDataPointColor), 
                        highlightShapes = DonutChart.drawDefaultHighlightShapes(this.svg, data, layout, this.colors, this.radius, this.sliceWidthRatio), 
                        visuals.NewDataLabelUtils.drawDefaultLabels(this.labelGraphicsContext, labels, !1, !0, !0), 
                        visuals.NewDataLabelUtils.drawLabelLeaderLines(this.labelGraphicsContext, labels)), 
                        this.assignInteractions(shapes_1, highlightShapes, data), this.tooltipsEnabled && (visuals.TooltipManager.addTooltip(shapes_1, function(tooltipEvent) {
                            return tooltipEvent.data.data.tooltipInfo;
                        }), visuals.TooltipManager.addTooltip(highlightShapes, function(tooltipEvent) {
                            return tooltipEvent.data.data.tooltipInfo;
                        }));
                    } else this.updateInternalToMove(data, duration);
                    visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
                }, DonutChart.prototype.createLabels = function() {
                    var labelLayout = new powerbi.DonutLabelLayout({
                        maximumOffset: visuals.NewDataLabelUtils.maxLabelOffset,
                        startingOffset: visuals.NewDataLabelUtils.startingLabelOffset
                    }, this.donutProperties), labelDataPoints = this.createLabelDataPoints();
                    return labelLayout.layout(labelDataPoints);
                }, DonutChart.prototype.createLabelDataPoints = function() {
                    var data = this.data, labelDataPoints = [], measureFormatterCache = visuals.dataLabelUtils.createColumnFormatterCacheManager(), alternativeScale = null;
                    0 === data.dataLabelsSettings.displayUnits && (alternativeScale = d3.max(data.dataPoints, function(d) {
                        return Math.abs(d.data.measure);
                    }));
                    for (var i = 0; i < this.data.dataPoints.length; i++) {
                        var label = this.createLabelDataPoint(data.dataPoints[i], alternativeScale, measureFormatterCache);
                        labelDataPoints.push(label);
                    }
                    return labelDataPoints;
                }, DonutChart.prototype.createLabelDataPoint = function(d, alternativeScale, measureFormatterCache) {
                    var dataLabel, dataLabelSize, categoryLabel, categoryLabelSize, textSize, labelPoint = this.outerArc.centroid(d), labelX = visuals.DonutLabelUtils.getXPositionForDonutLabel(labelPoint[0]), labelY = labelPoint[1], labelSettings = this.data.dataLabelsSettings, measureFormatter = measureFormatterCache.getOrCreate(d.data.labelFormatString, labelSettings, alternativeScale), position = 0 > labelX ? 4 : 8, pointPosition = {
                        point: {
                            x: labelX,
                            y: labelY
                        },
                        validPositions: [ position ],
                        radius: 0
                    }, outsideFill = labelSettings.labelColor ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultLabelColor, labelSettingsStyle = labelSettings.labelStyle, fontSize = labelSettings.fontSize, tooltip = "";
                    switch (labelSettingsStyle !== visuals.labelStyle.both && labelSettingsStyle !== visuals.labelStyle.data || (dataLabel = measureFormatter.format(null != d.data.originalHighlightValue ? d.data.originalHighlightValue : d.data.originalMeasure), 
                    dataLabelSize = visuals.NewDataLabelUtils.getTextSize(dataLabel, fontSize)), labelSettingsStyle !== visuals.labelStyle.both && labelSettingsStyle !== visuals.labelStyle.category || (categoryLabel = d.data.label, 
                    categoryLabelSize = visuals.NewDataLabelUtils.getTextSize(categoryLabel, fontSize)), 
                    labelSettingsStyle) {
                      case visuals.labelStyle.both:
                        var text = categoryLabel + " (" + dataLabel + ")";
                        tooltip = text, textSize = visuals.NewDataLabelUtils.getTextSize(text, fontSize);
                        break;

                      case visuals.labelStyle.category:
                        textSize = _.clone(categoryLabelSize), tooltip = categoryLabel;
                        break;

                      case visuals.labelStyle.data:
                        textSize = _.clone(dataLabelSize), tooltip = dataLabel;
                    }
                    var leaderLinePoints = visuals.DonutLabelUtils.getLabelLeaderLineForDonutChart(d, this.donutProperties, pointPosition.point), leaderLinesSize = visuals.DonutLabelUtils.getLabelLeaderLinesSizeForDonutChart(leaderLinePoints);
                    return {
                        isPreferred: !0,
                        text: "",
                        tooltip: tooltip,
                        textSize: textSize,
                        outsideFill: outsideFill,
                        fontSize: fontSize,
                        identity: d.data.identity,
                        parentShape: pointPosition,
                        insideFill: visuals.NewDataLabelUtils.defaultInsideLabelColor,
                        parentType: 0,
                        alternativeScale: alternativeScale,
                        donutArcDescriptor: d,
                        angle: (d.startAngle + d.endAngle) / 2 - Math.PI / 2,
                        dataLabel: dataLabel,
                        dataLabelSize: dataLabelSize,
                        categoryLabel: categoryLabel,
                        categoryLabelSize: categoryLabelSize,
                        leaderLinePoints: leaderLinePoints,
                        linesSize: leaderLinesSize
                    };
                }, DonutChart.prototype.renderLegend = function() {
                    if (!this.isInteractive) {
                        var legendObjectProperties = this.data.legendObjectProperties;
                        if (legendObjectProperties) {
                            var legendData = this.data.legendData;
                            visuals.LegendData.update(legendData, legendObjectProperties);
                            var position = legendObjectProperties[visuals.legendProps.position];
                            position && this.legend.changeOrientation(visuals.LegendPosition[position]), this.legend.drawLegend(legendData, this.parentViewport);
                        } else this.legend.changeOrientation(visuals.LegendPosition.Top), this.legend.drawLegend({
                            dataPoints: []
                        }, this.parentViewport);
                    }
                }, DonutChart.prototype.addInteractiveLegendArrow = function() {
                    if (this.data && this.data.dataPoints && 0 !== this.data.dataPoints.length) {
                        var arrowHeightOffset = 11, arrowWidthOffset = 16.5;
                        if (!this.interactiveLegendArrow) {
                            var interactiveLegendArrow = this.svg.append("g");
                            interactiveLegendArrow.append("path").classed(DonutChart.InteractiveLegendArrowClassName, !0).attr("d", "M1.5,2.6C0.65,1.15,1.85,0,3,0l27,0c1.65,0,2.35,1.15,1.5,2.6L18,26.45c-0.8,1.45-2.15,1.45-2.95,0L1.95,2.6z"), 
                            this.interactiveLegendArrow = interactiveLegendArrow;
                        }
                        var viewport = this.currentViewport, scaleRatio = this.getScaleForLegendArrow(), distanceBetweenLegendAndArrow = (viewport.height - 2 * this.radius) / 2 + arrowHeightOffset * scaleRatio, middleOfChart = viewport.width / 2 - arrowWidthOffset * scaleRatio;
                        this.interactiveLegendArrow.attr("transform", visuals.SVGUtil.translateAndScale(middleOfChart, distanceBetweenLegendAndArrow, scaleRatio));
                    }
                }, DonutChart.prototype.calculateSliceAngles = function() {
                    var angles = [], data = this.data.dataPoints;
                    if (0 === data.length) return this.interactivityState.valueToAngleFactor = 0, void (this.interactivityState.sliceAngles = []);
                    for (var sum = 0, i = 0, ilen = data.length; ilen > i; i++) sum += data[i].data.percentage;
                    this.interactivityState.valueToAngleFactor = 360 / sum;
                    for (var currentAngle = 0, i = 0, ilen = data.length; ilen > i; i++) {
                        var relativeAngle = data[i].data.percentage * this.interactivityState.valueToAngleFactor;
                        currentAngle += relativeAngle, angles.push(relativeAngle / 2 - currentAngle);
                    }
                    this.interactivityState.sliceAngles = angles;
                }, DonutChart.prototype.assignInteractions = function(slices, highlightSlices, data) {
                    if (this.isInteractive) this.assignInteractiveChartInteractions(slices); else if (this.interactivityService) {
                        var dataPoints = data.dataPoints.map(function(value) {
                            return value.data;
                        }), behaviorOptions = {
                            clearCatcher: this.clearCatcher,
                            slices: slices,
                            highlightSlices: highlightSlices,
                            allowDrilldown: this.allowDrilldown,
                            visual: this,
                            hasHighlights: data.hasHighlights
                        };
                        this.interactivityService.bind(dataPoints, this.behavior, behaviorOptions);
                    }
                }, DonutChart.prototype.assignInteractiveChartInteractions = function(slice) {
                    var _this = this, svg = this.svg;
                    this.interactivityState.interactiveChosenSliceFinishedSetting = !0;
                    var svgRect = svg.node().getBoundingClientRect();
                    this.interactivityState.donutCenter = {
                        x: svgRect.left + svgRect.width / 2,
                        y: svgRect.top + svgRect.height / 2
                    }, this.interactivityState.totalDragAngleDifference = 0, this.interactivityState.currentRotate = 0, 
                    this.calculateSliceAngles(), slice.on("click", function(d, clickedIndex) {
                        d3.event.defaultPrevented || _this.setInteractiveChosenSlice(clickedIndex);
                    });
                    var drag = d3.behavior.drag().origin(Object).on("dragstart", function() {
                        return _this.interactiveDragStart();
                    }).on("drag", function() {
                        return _this.interactiveDragMove();
                    }).on("dragend", function() {
                        return _this.interactiveDragEnd();
                    });
                    svg.style("touch-action", "none").call(drag);
                }, DonutChart.prototype.getAngleFromDragEvent = function() {
                    var pageX, pageY, interactivityState = this.interactivityState, sourceEvent = d3.event.sourceEvent;
                    if (-1 !== sourceEvent.type.toLowerCase().indexOf("touch")) {
                        if (1 !== sourceEvent.touches.length) return null;
                        var touch = sourceEvent.touches[0];
                        pageX = touch.pageX, pageY = touch.pageY;
                    } else pageX = sourceEvent.pageX, pageY = sourceEvent.pageY;
                    var adjustedCoordinates = {
                        x: pageX - interactivityState.donutCenter.x,
                        y: -pageY + interactivityState.donutCenter.y
                    }, angleToThePlane = 180 * Math.atan2(adjustedCoordinates.y, adjustedCoordinates.x) / Math.PI;
                    return angleToThePlane;
                }, DonutChart.prototype.interactiveDragStart = function() {
                    this.interactivityState.totalDragAngleDifference = 0, this.interactivityState.previousDragAngle = this.getAngleFromDragEvent();
                }, DonutChart.prototype.interactiveDragMove = function() {
                    var data = this.data.dataPoints, viewport = this.currentViewport, interactivityState = this.interactivityState;
                    if (interactivityState.interactiveChosenSliceFinishedSetting === !0) {
                        var currentDragAngle = this.getAngleFromDragEvent();
                        if (!currentDragAngle) return;
                        var angleDragDiff = interactivityState.previousDragAngle - currentDragAngle;
                        interactivityState.totalDragAngleDifference += angleDragDiff, interactivityState.previousDragAngle = currentDragAngle, 
                        interactivityState.currentRotate += angleDragDiff, this.svg.select("g").attr("transform", visuals.SVGUtil.translateAndRotate(viewport.width / 2, viewport.height / 2, 0, 0, this.interactivityState.currentRotate));
                        var currentHigherLimit = data[0].data.percentage * interactivityState.valueToAngleFactor, currentAngle = interactivityState.currentRotate <= 0 ? -1 * interactivityState.currentRotate % 360 : 360 - interactivityState.currentRotate % 360;
                        interactivityState.currentIndexDrag = 0;
                        for (var dataLength = data.length; interactivityState.currentIndexDrag < dataLength && currentAngle > currentHigherLimit; ) interactivityState.currentIndexDrag < dataLength - 1 && (currentHigherLimit += data[interactivityState.currentIndexDrag + 1].data.percentage * interactivityState.valueToAngleFactor), 
                        interactivityState.currentIndexDrag++;
                        interactivityState.currentIndexDrag !== interactivityState.previousIndexDrag && (interactivityState.interactiveLegend.updateLegend(interactivityState.currentIndexDrag), 
                        this.svg.selectAll(".slice").attr("opacity", function(d, index) {
                            return index === interactivityState.currentIndexDrag ? DonutChart.OpaqueOpacity : DonutChart.SemiTransparentOpacity;
                        }), interactivityState.previousIndexDrag = interactivityState.currentIndexDrag);
                    }
                }, DonutChart.prototype.interactiveDragEnd = function() {
                    0 !== this.interactivityState.totalDragAngleDifference && (this.setInteractiveChosenSlice(this.interactivityState.currentIndexDrag), 
                    d3.event.sourceEvent.stopPropagation());
                }, DonutChart.prototype.updateInternalToMove = function(data, duration) {
                    void 0 === duration && (duration = 0);
                    var svg = this.svg, pie = this.pie, key = this.key, arc = this.arc, radius = this.radius, previousRadius = this.previousRadius, sliceWidthRatio = this.sliceWidthRatio, existingData = this.svg.select(".slices").selectAll("path" + DonutChart.sliceClass.selector).data().map(function(d) {
                        return d.data;
                    });
                    0 === existingData.length && (existingData = data.dataPointsToDeprecate);
                    var is = this.mergeDatasets(existingData, data.dataPointsToDeprecate), slice = svg.select(".slices").selectAll("path" + DonutChart.sliceClass.selector).data(pie(data.dataPointsToDeprecate), key);
                    slice.enter().insert("path").classed(DonutChart.sliceClass["class"], !0).each(function(d) {
                        this._current = d;
                    }), slice = svg.select(".slices").selectAll("path" + DonutChart.sliceClass.selector).data(pie(is), key);
                    var innerRadius = radius * sliceWidthRatio;
                    if (DonutChart.isSingleColor(data.dataPoints), slice.style("fill", function(d) {
                        return d.data.color;
                    }).style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.data.selected, !1, !1, data.hasHighlights);
                    }).style("stroke", "white").style("stroke-dasharray", function(d) {
                        return DonutChart.drawStrokeForDonutChart(radius, DonutChart.InnerArcRadiusRatio, d, sliceWidthRatio);
                    }).style("stroke-width", function(d) {
                        return d.data.strokeWidth;
                    }).transition().duration(duration).attrTween("d", function(d) {
                        var i = d3.interpolate(this._current, d), k = d3.interpolate(previousRadius * DonutChart.InnerArcRadiusRatio, radius * DonutChart.InnerArcRadiusRatio);
                        return this._current = i(0), function(t) {
                            return arc.innerRadius(innerRadius).outerRadius(k(t))(i(t));
                        };
                    }), slice = svg.select(".slices").selectAll("path" + DonutChart.sliceClass.selector).data(pie(data.dataPointsToDeprecate), key), 
                    slice.exit().transition().delay(duration).duration(0).remove(), !this.isInteractive) {
                        var labelSettings = data.dataLabelsSettings, labels = [];
                        labelSettings && labelSettings.show && (labels = this.createLabels()), visuals.NewDataLabelUtils.drawDefaultLabels(this.labelGraphicsContext, labels, !1, !0), 
                        visuals.NewDataLabelUtils.drawLabelLeaderLines(this.labelGraphicsContext, labels);
                    }
                    var highlightSlices = void 0;
                    data.hasHighlights ? (highlightSlices = svg.select(".slices").selectAll("path" + DonutChart.sliceHighlightClass.selector).data(pie(data.dataPointsToDeprecate), key), 
                    highlightSlices.enter().insert("path").classed(DonutChart.sliceHighlightClass["class"], !0).each(function(d) {
                        this._current = d;
                    }), DonutChart.isSingleColor(data.dataPoints), highlightSlices.style("fill", function(d) {
                        return d.data.color;
                    }).style("fill-opacity", 1).style("stroke", "white").style("stroke-dasharray", function(d) {
                        return DonutChart.drawStrokeForDonutChart(radius, DonutChart.InnerArcRadiusRatio, d, sliceWidthRatio, d.data.highlightRatio);
                    }).style("stroke-width", function(d) {
                        return 0 === d.data.highlightRatio ? 0 : d.data.strokeWidth;
                    }).transition().duration(duration).attrTween("d", function(d) {
                        var i = d3.interpolate(this._current, d), k = d3.interpolate(previousRadius * DonutChart.InnerArcRadiusRatio, DonutChart.getHighlightRadius(radius, sliceWidthRatio, d.data.highlightRatio));
                        return this._current = i(0), function(t) {
                            return arc.innerRadius(innerRadius).outerRadius(k(t))(i(t));
                        };
                    }), highlightSlices.exit().transition().delay(duration).duration(0).remove()) : svg.selectAll("path" + DonutChart.sliceHighlightClass.selector).transition().delay(duration).duration(0).remove(), 
                    this.assignInteractions(slice, highlightSlices, data), this.tooltipsEnabled && (visuals.TooltipManager.addTooltip(slice, function(tooltipEvent) {
                        return tooltipEvent.data.data.tooltipInfo;
                    }), data.hasHighlights && visuals.TooltipManager.addTooltip(highlightSlices, function(tooltipEvent) {
                        return tooltipEvent.data.data.tooltipInfo;
                    })), visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options), this.isInteractive && (this.addInteractiveLegendArrow(), 
                    this.interactivityState.interactiveLegend.drawLegend(this.data.dataPointsToDeprecate), 
                    this.setInteractiveChosenSlice(this.interactivityState.lastChosenInteractiveSliceIndex ? this.interactivityState.lastChosenInteractiveSliceIndex : 0));
                }, DonutChart.drawDefaultShapes = function(graphicsContext, donutData, layout, colors, radius, hasSelection, sliceWidthRatio, defaultColor) {
                    var shapes = graphicsContext.select(".slices").selectAll("path" + DonutChart.sliceClass.selector).data(donutData.dataPoints, function(d) {
                        return d.data.identity.getKey();
                    });
                    return shapes.enter().insert("path").classed(DonutChart.sliceClass["class"], !0), 
                    DonutChart.isSingleColor(donutData.dataPoints), shapes.style("fill", function(d) {
                        return d.data.color;
                    }).style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.data.selected, !1, hasSelection, donutData.hasHighlights);
                    }).style("stroke-dasharray", function(d) {
                        return DonutChart.drawStrokeForDonutChart(radius, DonutChart.InnerArcRadiusRatio, d, sliceWidthRatio);
                    }).style("stroke-width", function(d) {
                        return d.data.strokeWidth;
                    }).attr(layout.shapeLayout), shapes.exit().remove(), shapes;
                }, DonutChart.drawDefaultHighlightShapes = function(graphicsContext, donutData, layout, colors, radius, sliceWidthRatio) {
                    var shapes = graphicsContext.select(".slices").selectAll("path" + DonutChart.sliceHighlightClass.selector).data(donutData.dataPoints.filter(function(value) {
                        return null != value.data.highlightRatio;
                    }), function(d) {
                        return d.data.identity.getKey();
                    });
                    return shapes.enter().insert("path").classed(DonutChart.sliceHighlightClass["class"], !0).each(function(d) {
                        this._current = d;
                    }), DonutChart.isSingleColor(donutData.dataPoints), shapes.style("fill", function(d) {
                        return d.data.color;
                    }).style("fill-opacity", function(d) {
                        return visuals.ColumnUtil.getFillOpacity(d.data.selected, !0, !1, donutData.hasHighlights);
                    }).style("stroke", "white").style("stroke-dasharray", function(d) {
                        return DonutChart.drawStrokeForDonutChart(radius, DonutChart.InnerArcRadiusRatio, d, sliceWidthRatio, d.data.highlightRatio);
                    }).style("stroke-width", function(d) {
                        return 0 === d.data.highlightRatio ? 0 : d.data.strokeWidth;
                    }).attr(layout.highlightShapeLayout), shapes.exit().remove(), shapes;
                }, DonutChart.isSingleColor = function(dataPoints) {
                    if (dataPoints.length > 1) {
                        var lastPoint = dataPoints.length - 1;
                        dataPoints[lastPoint].data.isLastInDonut = dataPoints[lastPoint].data.color === dataPoints[0].data.color;
                    }
                }, DonutChart.drawStrokeForDonutChart = function(radius, innerArcRadiusRatio, d, sliceWidthRatio, highlightRatio) {
                    void 0 === highlightRatio && (highlightRatio = 1);
                    var sectionWithoutStroke, sectionWithStroke, sliceRadius = radius * innerArcRadiusRatio * highlightRatio, sliceArc = (d.endAngle - d.startAngle) * sliceRadius;
                    if (sliceWidthRatio) {
                        var innerRadius = radius * sliceWidthRatio, outerRadius = highlightRatio * radius * (DonutChart.InnerArcRadiusRatio - sliceWidthRatio), innerSliceArc = (d.endAngle - d.startAngle) * innerRadius;
                        if (d.data.highlightRatio && (sliceArc = (d.endAngle - d.startAngle) * (outerRadius + innerRadius)), 
                        d.data.isLastInDonut) return "0 " + sliceArc + " " + outerRadius + " " + innerSliceArc + " " + outerRadius;
                        sectionWithoutStroke = sliceArc + outerRadius + innerSliceArc, sectionWithStroke = outerRadius;
                    } else d.data.isLastInDonut ? (sectionWithoutStroke = sliceArc, sectionWithStroke = 2 * sliceRadius) : (sectionWithoutStroke = sliceArc + sliceRadius, 
                    sectionWithStroke = sliceRadius);
                    return "0 " + sectionWithoutStroke + " " + sectionWithStroke;
                }, DonutChart.prototype.onClearSelection = function() {
                    this.interactivityService && this.interactivityService.clearSelection();
                }, DonutChart.getLayout = function(radius, sliceWidthRatio, viewport) {
                    var innerRadius = radius * sliceWidthRatio, arc = d3.svg.arc().innerRadius(innerRadius), arcWithRadius = arc.outerRadius(radius * DonutChart.InnerArcRadiusRatio);
                    return {
                        shapeLayout: {
                            d: function(d) {
                                return arcWithRadius(d);
                            }
                        },
                        highlightShapeLayout: {
                            d: function(d) {
                                var highlightArc = arc.outerRadius(DonutChart.getHighlightRadius(radius, sliceWidthRatio, d.data.highlightRatio));
                                return highlightArc(d);
                            }
                        },
                        zeroShapeLayout: {
                            d: function(d) {
                                var zeroWithZeroRadius = arc.outerRadius(innerRadius || DonutChart.EffectiveZeroValue);
                                return zeroWithZeroRadius(d);
                            }
                        }
                    };
                }, DonutChart.getHighlightRadius = function(radius, sliceWidthRatio, highlightRatio) {
                    var innerRadius = radius * sliceWidthRatio;
                    return innerRadius + highlightRatio * radius * (DonutChart.InnerArcRadiusRatio - sliceWidthRatio);
                }, DonutChart.cullDataByViewport = function(dataPoints, maxValue, viewport) {
                    for (var prevPointColor, estimatedRadius = Math.min(viewport.width, viewport.height) / 2, cullRatio = this.invisibleArcLengthInPixels / (estimatedRadius * DonutChart.twoPi), cullableValue = cullRatio * maxValue, culledDataPoints = [], _i = 0, dataPoints_1 = dataPoints; _i < dataPoints_1.length; _i++) {
                        var datapoint = dataPoints_1[_i];
                        datapoint.measure >= cullableValue && (datapoint.strokeWidth = prevPointColor === datapoint.color ? 1 : 0, 
                        prevPointColor = datapoint.color, culledDataPoints.push(datapoint));
                    }
                    return culledDataPoints;
                }, DonutChart.ClassName = "donutChart", DonutChart.InteractiveLegendClassName = "donutLegend", 
                DonutChart.InteractiveLegendArrowClassName = "donutLegendArrow", DonutChart.OuterArcRadiusRatio = .9, 
                DonutChart.InnerArcRadiusRatio = .8, DonutChart.OpaqueOpacity = 1, DonutChart.SemiTransparentOpacity = .6, 
                DonutChart.defaultSliceWidthRatio = .48, DonutChart.invisibleArcLengthInPixels = 3, 
                DonutChart.sliceClass = createClassAndSelector("slice"), DonutChart.sliceHighlightClass = createClassAndSelector("slice-highlight"), 
                DonutChart.twoPi = 2 * Math.PI, DonutChart.InteractiveLegendContainerHeight = 70, 
                DonutChart.EffectiveZeroValue = 1e-9, DonutChart.PolylineOpacity = .5, DonutChart;
            }();
            visuals.DonutChart = DonutChart;
            var DonutChartConversion, DonutChartInteractiveLegend = function() {
                function DonutChartInteractiveLegend(donutChart, legendContainer, colors, visualInitOptions, settings) {
                    this.legendContainerParent = legendContainer, this.colors = colors, this.donutChart = donutChart, 
                    this.visualInitOptions = visualInitOptions, this.legendItemsPositions = [], this.legendTransitionAnimationDuration = settings && settings.legendTransitionAnimationDuration ? settings.legendTransitionAnimationDuration : 0;
                }
                return DonutChartInteractiveLegend.prototype.drawLegend = function(data) {
                    var _this = this;
                    this.data = data, this.currentNumberOfLegendItems = data.length, this.currentIndex = 0, 
                    this.leftMostIndex = 0, this.rightMostIndex = data.length - 1, this.legendContainerParent.select(DonutChartInteractiveLegend.LegendContainerSelector).empty() && (this.legendContainer = this.legendContainerParent.append("div").classed(DonutChartInteractiveLegend.LegendContainerClassName, !0));
                    var legendItems = this.legendContainer.selectAll(DonutChartInteractiveLegend.LegendItemSelector).data(data), legendContainerWidth = this.legendContainerWidth = this.legendContainer.node().getBoundingClientRect().width, initialXOffset = legendContainerWidth / 2 - .4 * legendContainerWidth / 2 + DonutChartInteractiveLegend.ItemMargin, currX = initialXOffset;
                    this.currentXOffset = initialXOffset;
                    var createLegendItem = function(itemDiv, datum) {
                        itemDiv.attr("data-legend-index", datum.index).css({
                            position: "absolute",
                            left: currX
                        });
                        var itemCategory = visuals.valueFormatter.format(datum.label), itemValue = visuals.valueFormatter.format(datum.originalMeasure, datum.measureFormat), itemPercentage = visuals.valueFormatter.format(datum.percentage, "0.00 %;-0.00 %;0.00 %"), itemColor = datum.color, itemValueSpan = DonutChartInteractiveLegend.createBasicLegendItemSpan(DonutChartInteractiveLegend.LegendItemValueClassName, itemValue, 11), itemCategorySpan = DonutChartInteractiveLegend.createBasicLegendItemSpan(DonutChartInteractiveLegend.LegendItemCategoryClassName, itemCategory, 11), itemPercentageSpan = DonutChartInteractiveLegend.createBasicLegendItemSpan(DonutChartInteractiveLegend.LegendItemPercentageClassName, itemPercentage, 20), valueSpanWidth = DonutChartInteractiveLegend.spanWidth(itemValueSpan), categorySpanWidth = DonutChartInteractiveLegend.spanWidth(itemCategorySpan), precentageSpanWidth = DonutChartInteractiveLegend.spanWidth(itemPercentageSpan), currentLegendBoxWidth = DonutChartInteractiveLegend.legendBoxSize(valueSpanWidth, categorySpanWidth, precentageSpanWidth);
                        itemDiv.css("width", currentLegendBoxWidth);
                        var getLeftValue = function(spanWidth) {
                            return currentLegendBoxWidth - spanWidth > 0 ? (currentLegendBoxWidth - spanWidth) / 2 : 0;
                        }, marginLeftValue = getLeftValue(valueSpanWidth), marginLeftCategory = getLeftValue(categorySpanWidth), marginLeftPrecentage = getLeftValue(precentageSpanWidth);
                        DonutChartInteractiveLegend.createLegendItemSpan(itemCategorySpan, marginLeftCategory), 
                        DonutChartInteractiveLegend.createLegendItemSpan(itemValueSpan, marginLeftValue), 
                        DonutChartInteractiveLegend.createLegendItemSpan(itemPercentageSpan, marginLeftPrecentage).css("color", itemColor), 
                        itemDiv.append(itemCategorySpan), itemDiv.append(itemPercentageSpan), itemDiv.append(itemValueSpan), 
                        _this.legendItemsPositions.push({
                            startX: currX,
                            boxWidth: currentLegendBoxWidth
                        }), currX += currentLegendBoxWidth + DonutChartInteractiveLegend.ItemMargin;
                    };
                    legendItems.enter().insert("div").classed(DonutChartInteractiveLegend.LegendItemClassName, !0).each(function(d) {
                        createLegendItem($(this), d);
                    }), legendItems.exit().remove(), this.assignInteractions();
                }, DonutChartInteractiveLegend.prototype.updateLegend = function(sliceIndex) {
                    var _this = this, legendContainerWidth = this.legendContainerWidth;
                    this.currentIndex = sliceIndex, this.updateLabelBlocks(sliceIndex);
                    var legendTransitionAnimationDuration = this.legendTransitionAnimationDuration, nextXOffset = -1 * (this.legendItemsPositions[sliceIndex].startX + this.legendItemsPositions[sliceIndex].boxWidth / 2 - legendContainerWidth / 2);
                    this.legendContainer.transition().styleTween("-webkit-transform", function(d, i, a) {
                        return d3.interpolate(visuals.SVGUtil.translateWithPixels(_this.currentXOffset, 0), visuals.SVGUtil.translateWithPixels(nextXOffset, 0));
                    }).styleTween("transform", function(d, i, a) {
                        return d3.interpolate(visuals.SVGUtil.translateWithPixels(_this.currentXOffset, 0), visuals.SVGUtil.translateWithPixels(nextXOffset, 0));
                    }).duration(legendTransitionAnimationDuration).ease("bounce").each("end", function() {
                        _this.currentXOffset = nextXOffset;
                    }), visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.visualInitOptions);
                }, DonutChartInteractiveLegend.prototype.assignInteractions = function() {
                    var _this = this, currentDX = 0, hasChanged = !1, dragStart = function() {
                        currentDX = 0, hasChanged = !1;
                    }, dragMove = function() {
                        if (currentDX += d3.event.dx, !(hasChanged || Math.abs(currentDX) < DonutChartInteractiveLegend.MinimumSwipeDX)) {
                            var dragDirectionLeft = 0 > currentDX;
                            _this.dragLegend(dragDirectionLeft), hasChanged = !0;
                        }
                    }, drag = d3.behavior.drag().origin(Object).on("drag", dragMove).on("dragstart", dragStart);
                    this.legendContainer.style({
                        "touch-action": "none",
                        cursor: "pointer"
                    }).call(drag);
                }, DonutChartInteractiveLegend.prototype.dragLegend = function(dragDirectionLeft) {
                    this.currentNumberOfLegendItems > DonutChartInteractiveLegend.MinimumItemsInLegendForCycled - 1 ? this.currentIndex = this.getCyclingCurrentIndex(dragDirectionLeft) : this.shouldChangeIndexInNonCycling(dragDirectionLeft) && (dragDirectionLeft ? this.currentIndex++ : this.currentIndex--), 
                    this.donutChart.setInteractiveChosenSlice(this.currentIndex);
                }, DonutChartInteractiveLegend.prototype.shouldChangeIndexInNonCycling = function(dragDirectionLeft) {
                    return !(0 === this.currentIndex && !dragDirectionLeft || this.currentIndex === this.currentNumberOfLegendItems - 1 && dragDirectionLeft);
                }, DonutChartInteractiveLegend.prototype.getCyclingCurrentIndex = function(dragDirectionLeft) {
                    var dataLen = this.data.length, delta = dragDirectionLeft ? 1 : -1, newIndex = (this.currentIndex + delta) % (dataLen || 1);
                    return 0 > newIndex ? newIndex + dataLen : newIndex;
                }, DonutChartInteractiveLegend.prototype.updateLegendItemsBlocks = function(rightSidedShift, numberOfLegendItemsBlocksToShift) {
                    var legendContainer$ = $(this.legendContainer[0]);
                    if (rightSidedShift) {
                        var smallestItem = legendContainer$.find("[data-legend-index=" + this.leftMostIndex + "]");
                        smallestItem.remove().insertAfter(legendContainer$.find("[data-legend-index=" + this.rightMostIndex + "]"));
                        var newX = this.legendItemsPositions[this.rightMostIndex].startX + this.legendItemsPositions[this.rightMostIndex].boxWidth + DonutChartInteractiveLegend.ItemMargin;
                        this.legendItemsPositions[this.leftMostIndex].startX = newX, smallestItem.css("left", newX), 
                        this.rightMostIndex = this.leftMostIndex, this.leftMostIndex = (this.leftMostIndex + 1) % this.data.length;
                    } else {
                        var highestItem = legendContainer$.find("[data-legend-index=" + this.rightMostIndex + "]");
                        highestItem.remove().insertBefore(legendContainer$.find("[data-legend-index=" + this.leftMostIndex + "]"));
                        var newX = this.legendItemsPositions[this.leftMostIndex].startX - this.legendItemsPositions[this.rightMostIndex].boxWidth - DonutChartInteractiveLegend.ItemMargin;
                        this.legendItemsPositions[this.rightMostIndex].startX = newX, highestItem.css("left", newX), 
                        this.leftMostIndex = this.rightMostIndex, this.rightMostIndex = this.rightMostIndex - 1 === -1 ? this.legendItemsPositions.length - 1 : this.rightMostIndex - 1;
                    }
                    numberOfLegendItemsBlocksToShift - 1 !== 0 && this.updateLegendItemsBlocks(rightSidedShift, numberOfLegendItemsBlocksToShift - 1);
                }, DonutChartInteractiveLegend.prototype.updateLabelBlocks = function(index) {
                    this.currentNumberOfLegendItems > DonutChartInteractiveLegend.MinimumItemsInLegendForCycled ? (this.rightMostIndex === index && this.updateLegendItemsBlocks(!0, 2), 
                    this.leftMostIndex === index && this.updateLegendItemsBlocks(!1, 2), (this.rightMostIndex === index + 1 || 0 === this.rightMostIndex && index === this.currentNumberOfLegendItems - 1) && this.updateLegendItemsBlocks(!0, 1), 
                    (this.leftMostIndex === index - 1 || this.leftMostIndex === this.currentNumberOfLegendItems - 1 && 0 === index) && this.updateLegendItemsBlocks(!1, 1)) : this.currentNumberOfLegendItems === DonutChartInteractiveLegend.MinimumItemsInLegendForCycled && (this.rightMostIndex === index && this.updateLegendItemsBlocks(!0, 1), 
                    this.leftMostIndex === index && this.updateLegendItemsBlocks(!1, 1));
                }, DonutChartInteractiveLegend.createBasicLegendItemSpan = function(spanClass, text, fontSize) {
                    return $("<span/>").addClass(spanClass).css({
                        "white-space": "nowrap",
                        "font-size": fontSize + "px"
                    }).text(text);
                }, DonutChartInteractiveLegend.createLegendItemSpan = function(existingSpan, marginLeft) {
                    return existingSpan.css({
                        overflow: "hidden",
                        "text-overflow": "ellipsis",
                        display: "inline-block",
                        width: "100%",
                        "margin-left": marginLeft
                    }), existingSpan;
                }, DonutChartInteractiveLegend.legendBoxSize = function(valueSpanWidth, categorySpanWidth, precentageSpanWidth) {
                    var boxSize = valueSpanWidth > categorySpanWidth ? valueSpanWidth : categorySpanWidth;
                    return boxSize = boxSize > precentageSpanWidth ? boxSize : precentageSpanWidth, 
                    boxSize = boxSize > DonutChartInteractiveLegend.MaxLegendItemBoxSize ? DonutChartInteractiveLegend.MaxLegendItemBoxSize : boxSize + 2;
                }, DonutChartInteractiveLegend.spanWidth = function(span) {
                    return this.FakeElementSpan || (this.FakeElementSpan = $("<span>").hide().appendTo(document.body)), 
                    this.FakeElementSpan.empty(), this.FakeElementSpan.append(span), this.FakeElementSpan.width();
                }, DonutChartInteractiveLegend.LegendContainerClassName = "legend-container", DonutChartInteractiveLegend.LegendContainerSelector = ".legend-container", 
                DonutChartInteractiveLegend.LegendItemClassName = "legend-item", DonutChartInteractiveLegend.LegendItemSelector = ".legend-item", 
                DonutChartInteractiveLegend.LegendItemCategoryClassName = "category", DonutChartInteractiveLegend.LegendItemPercentageClassName = "percentage", 
                DonutChartInteractiveLegend.LegendItemValueClassName = "value", DonutChartInteractiveLegend.MaxLegendItemBoxSize = 160, 
                DonutChartInteractiveLegend.ItemMargin = 30, DonutChartInteractiveLegend.MinimumSwipeDX = 15, 
                DonutChartInteractiveLegend.MinimumItemsInLegendForCycled = 3, DonutChartInteractiveLegend;
            }();
            !function(DonutChartConversion) {
                var DonutChartConverter = function() {
                    function DonutChartConverter(dataView, colors, defaultDataPointColor, tooltipsEnabled, tooltipBucketEnabled) {
                        void 0 === tooltipsEnabled && (tooltipsEnabled = !0);
                        var reader = this.reader = powerbi.data.createIDataViewCategoricalReader(dataView), dataViewCategorical = dataView.categorical;
                        if (this.dataViewCategorical = dataViewCategorical, this.dataViewMetadata = dataView.metadata, 
                        this.tooltipsEnabled = tooltipsEnabled, this.tooltipBucketEnabled = tooltipBucketEnabled, 
                        this.colorHelper = new visuals.ColorHelper(colors, visuals.donutChartProps.dataPoint.fill, defaultDataPointColor), 
                        this.maxValue = 0, this.hasNegativeValues = !1, this.allValuesAreNegative = !1, 
                        dataViewCategorical.categories && dataViewCategorical.categories.length > 0) {
                            var category = dataViewCategorical.categories[0];
                            this.categoryIdentities = category.identity, this.categoryValues = category.values, 
                            this.allCategoryObjects = category.objects, this.categoryColumnRef = category.identityFields, 
                            this.categoryFormatString = visuals.valueFormatter.getFormatString(category.source, visuals.donutChartProps.general.formatString);
                        }
                        if (this.isDynamicSeries = reader.hasDynamicSeries(), this.highlightsOverflow = !1, 
                        this.total = 0, this.highlightTotal = 0, this.dataPoints = [], this.legendDataPoints = [], 
                        this.dataLabelsSettings = null, reader.hasValues("Y")) {
                            var seriesCount = this.seriesCount = reader.getSeriesCount("Y");
                            this.hasHighlights = reader.hasHighlights("Y");
                            var categoryCount = reader.getCategoryCount() || 1;
                            this.allValuesAreNegative = void 0;
                            for (var categoryIndex = 0; categoryCount > categoryIndex; categoryIndex++) for (var seriesIndex = 0; seriesCount > seriesIndex; seriesIndex++) {
                                var value = reader.getValue("Y", categoryIndex, seriesIndex), highlight = void 0;
                                this.hasHighlights && (highlight = reader.getHighlight("Y", categoryIndex, seriesIndex), 
                                null == highlight && (highlight = 0)), void 0 === this.allValuesAreNegative ? this.allValuesAreNegative = (this.hasHighlights ? 0 >= highlight : !0) && 0 >= value : this.allValuesAreNegative = this.allValuesAreNegative && (this.hasHighlights ? 0 >= highlight : !0) && 0 >= value, 
                                this.hasNegativeValues || (this.hasNegativeValues = 0 > value || (this.hasHighlights ? 0 > highlight : !1));
                            }
                            this.allValuesAreNegative = !!this.allValuesAreNegative;
                            for (var categoryIndex = 0; categoryCount > categoryIndex; categoryIndex++) for (var seriesIndex = 0; seriesCount > seriesIndex; seriesIndex++) {
                                var value = reader.getValue("Y", categoryIndex, seriesIndex);
                                if (value = DonutChartConverter.normalizedValue(value, this.allValuesAreNegative), 
                                this.total += value, this.hasHighlights) {
                                    var highlight = reader.getHighlight("Y", categoryIndex, seriesIndex);
                                    highlight = DonutChartConverter.normalizedValue(highlight, this.allValuesAreNegative), 
                                    this.highlightTotal += highlight, !this.highlightsOverflow && highlight > value && (this.highlightsOverflow = !0);
                                }
                            }
                        }
                    }
                    return DonutChartConverter.normalizedValue = function(value, allValuesAreNegative) {
                        return null == value || isNaN(value) ? 0 : value === Number.POSITIVE_INFINITY ? Number.MAX_VALUE : value === Number.NEGATIVE_INFINITY ? -Number.MAX_VALUE : allValuesAreNegative ? Math.abs(value) : 0 > value ? 0 : value;
                    }, DonutChartConverter.prototype.convert = function() {
                        var convertedData, reader = this.reader;
                        convertedData = 0 !== this.total ? this.categoryValues ? this.convertCategoricalWithSlicing() : this.isDynamicSeries ? this.convertSeries() : this.convertMeasures() : [], 
                        this.dataLabelsSettings = this.convertDataLabelSettings();
                        var dataViewMetadata = this.dataViewMetadata;
                        if (dataViewMetadata) {
                            var objects = dataViewMetadata.objects;
                            objects && (this.legendObjectProperties = objects.legend);
                        }
                        var category = _.isEmpty(this.dataViewCategorical.categories) ? null : this.dataViewCategorical.categories[0];
                        this.dataPoints = [];
                        for (var prevPointColor, formatStringProp = visuals.donutChartProps.general.formatString, pctFormatString = visuals.valueFormatter.getLocalizedString("Percentage"), i = 0, dataPointCount = convertedData.length; dataPointCount > i; i++) {
                            var point = convertedData[i], originalMeasure = point.measure, normalizedMeasure = DonutChartConverter.normalizedValue(point.measure, this.allValuesAreNegative), originalHighlight = point.highlightMeasure, normalizedHighlight = DonutChartConverter.normalizedValue(point.highlightMeasure, this.allValuesAreNegative), percentage = this.total > 0 ? normalizedMeasure / this.total : 0, highlightRatio = void 0, highlightPercentage = void 0;
                            normalizedMeasure > this.maxValue && (this.maxValue = normalizedMeasure), normalizedHighlight > this.maxValue && (this.maxValue = normalizedHighlight), 
                            this.hasHighlights && (this.highlightsOverflow ? (originalMeasure = originalHighlight, 
                            normalizedMeasure = normalizedHighlight, percentage = this.highlightTotal > 0 ? normalizedHighlight / this.highlightTotal : 0, 
                            highlightRatio = 1) : highlightRatio = 0 !== normalizedMeasure ? normalizedHighlight / normalizedMeasure : 0, 
                            highlightRatio || (highlightRatio = DonutChart.EffectiveZeroValue), highlightPercentage = percentage * highlightRatio);
                            var categoryValue = point.categoryLabel, categorical = this.dataViewCategorical, valueIndex = void 0;
                            valueIndex = null != point.seriesIndex ? point.seriesIndex : i;
                            var valuesMetadata = reader.getValueMetadataColumn("Y", valueIndex), value = this.hasHighlights && this.highlightsOverflow ? originalHighlight : originalMeasure, highlightValue = this.hasHighlights && !this.highlightsOverflow ? originalHighlight : void 0, formatString = visuals.valueFormatter.getFormatString(valuesMetadata, formatStringProp), pct = visuals.valueFormatter.format(percentage, pctFormatString), valueAndPct = void 0;
                            null != value && null != pct && (valueAndPct = visuals.valueFormatter.format(value, formatString) + " (" + pct + ")");
                            var highlightValueAndPct = void 0;
                            if (null != highlightValue && null != highlightPercentage) {
                                var highlightedPct = visuals.valueFormatter.format(highlightPercentage, pctFormatString);
                                highlightValueAndPct = visuals.valueFormatter.format(highlightValue, formatString) + " (" + highlightedPct + ")";
                            }
                            var tooltipInfo = void 0;
                            this.tooltipsEnabled && (tooltipInfo = [], category && tooltipInfo.push({
                                displayName: category.source.displayName,
                                value: categoryValue
                            }), this.isDynamicSeries && (category && category.source === categorical.values.source || tooltipInfo.push({
                                displayName: categorical.values.source.displayName,
                                value: point.label
                            })), null != valueAndPct && tooltipInfo.push({
                                displayName: valuesMetadata.displayName,
                                value: valueAndPct
                            }), null != highlightValueAndPct && tooltipInfo.push({
                                displayName: visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName,
                                value: highlightValueAndPct
                            }), this.tooltipBucketEnabled && visuals.TooltipBuilder.addTooltipBucketItem(reader, tooltipInfo, this.categoryValues ? point.categoryIndex : 0, this.isDynamicSeries ? point.seriesIndex : void 0));
                            var strokeWidth = prevPointColor === point.color && percentage && percentage > 0 ? 1 : 0;
                            prevPointColor = percentage && percentage > 0 ? point.color : prevPointColor, this.dataPoints.push({
                                identity: point.identity,
                                measure: normalizedMeasure,
                                originalMeasure: originalMeasure,
                                measureFormat: point.measureFormat,
                                percentage: percentage,
                                index: point.index,
                                label: point.label,
                                highlightRatio: highlightRatio,
                                highlightValue: this.hasHighlights && !this.highlightsOverflow ? normalizedHighlight : void 0,
                                originalHighlightValue: this.hasHighlights && !this.highlightsOverflow ? originalHighlight : void 0,
                                selected: !1,
                                tooltipInfo: tooltipInfo,
                                color: point.color,
                                strokeWidth: strokeWidth,
                                labelFormatString: valuesMetadata.format
                            });
                        }
                        this.legendData = this.convertLegendData();
                    }, DonutChartConverter.prototype.getLegendTitle = function() {
                        if (0 !== this.total) {
                            var dvValuesSourceName = this.dataViewCategorical.values && this.dataViewCategorical.values.source ? this.dataViewCategorical.values.source.displayName : "", dvCategorySourceName = this.dataViewCategorical.categories && this.dataViewCategorical.categories.length > 0 && this.dataViewCategorical.categories[0].source ? this.dataViewCategorical.categories[0].source.displayName : "";
                            return this.categoryValues ? dvCategorySourceName : dvValuesSourceName;
                        }
                        return "";
                    }, DonutChartConverter.prototype.convertCategoricalWithSlicing = function() {
                        for (var reader = this.reader, dataViewCategorical = this.dataViewCategorical, formatStringProp = visuals.donutChartProps.general.formatString, dataPoints = [], categoryIndex = 0, categoryCount = this.categoryValues.length; categoryCount > categoryIndex; categoryIndex++) {
                            for (var categoryValue = this.categoryValues[categoryIndex], thisCategoryObjects = this.allCategoryObjects ? this.allCategoryObjects[categoryIndex] : void 0, legendIdentity = visuals.SelectionId.createWithId(this.categoryIdentities[categoryIndex]), color = this.colorHelper.getColorForSeriesValue(thisCategoryObjects, this.categoryColumnRef, categoryValue), categoryLabel = visuals.valueFormatter.format(categoryValue, this.categoryFormatString), seriesIndex = 0; seriesIndex < this.seriesCount; seriesIndex++) {
                                var value = reader.getValue("Y", categoryIndex, seriesIndex), highlightValue = this.hasHighlights ? reader.getHighlight("Y", categoryIndex, seriesIndex) : void 0, valueColumn = reader.getValueColumn("Y", seriesIndex), label = categoryLabel;
                                (this.isDynamicSeries || reader.getSeriesCount("Y") > 1) && (label = visuals.converterHelper.getFormattedLegendLabel(valueColumn.source, dataViewCategorical.values, formatStringProp));
                                var measure = valueColumn.source.queryName, identity = visuals.SelectionIdBuilder.builder().withCategory(dataViewCategorical.categories[0], categoryIndex).withSeries(dataViewCategorical.values, this.isDynamicSeries ? valueColumn : void 0).withMeasure(measure).createSelectionId(), dataPoint = {
                                    identity: identity,
                                    measureFormat: visuals.valueFormatter.getFormatString(valueColumn.source, formatStringProp, !0),
                                    measure: value,
                                    highlightMeasure: highlightValue,
                                    index: categoryIndex * this.seriesCount + seriesIndex,
                                    label: label,
                                    categoryLabel: categoryLabel,
                                    color: color,
                                    categoryIndex: categoryIndex,
                                    seriesIndex: seriesIndex
                                };
                                dataPoints.push(dataPoint);
                            }
                            this.legendDataPoints.push({
                                label: categoryLabel,
                                color: color,
                                icon: visuals.LegendIcon.Box,
                                identity: legendIdentity,
                                selected: !1
                            });
                        }
                        return dataPoints;
                    }, DonutChartConverter.prototype.convertMeasures = function() {
                        for (var reader = this.reader, dataPoints = [], formatStringProp = visuals.donutChartProps.general.formatString, measureIndex = 0; measureIndex < this.seriesCount; measureIndex++) {
                            var value = reader.getValue("Y", 0, measureIndex), highlightValue = this.hasHighlights ? reader.getHighlight("Y", 0, measureIndex) : void 0, valueColumn = reader.getValueColumn("Y", measureIndex), measureFormat = visuals.valueFormatter.getFormatString(valueColumn.source, formatStringProp, !0), measureLabel = valueColumn.source.displayName, identity = visuals.SelectionId.createWithMeasure(valueColumn.source.queryName), color = this.colorHelper.getColorForMeasure(valueColumn.source.objects, valueColumn.source.queryName), dataPoint = {
                                identity: identity,
                                measureFormat: measureFormat,
                                measure: value,
                                highlightMeasure: highlightValue,
                                index: measureIndex,
                                label: measureLabel,
                                categoryLabel: measureLabel,
                                color: color
                            };
                            dataPoints.push(dataPoint), this.legendDataPoints.push({
                                label: dataPoint.label,
                                color: dataPoint.color,
                                icon: visuals.LegendIcon.Box,
                                identity: dataPoint.identity,
                                selected: !1
                            });
                        }
                        return dataPoints;
                    }, DonutChartConverter.prototype.convertSeries = function() {
                        for (var reader = this.reader, dataViewCategorical = this.dataViewCategorical, dataPoints = [], formatStringProp = visuals.donutChartProps.general.formatString, seriesIndex = 0; seriesIndex < this.seriesCount; seriesIndex++) {
                            var value = reader.getValue("Y", 0, seriesIndex), highlightValue = this.hasHighlights ? reader.getHighlight("Y", 0, seriesIndex) : void 0, valueColumn = reader.getValueColumn("Y", seriesIndex), seriesFormat = visuals.valueFormatter.getFormatString(valueColumn.source, formatStringProp, !0), label = visuals.converterHelper.getFormattedLegendLabel(valueColumn.source, dataViewCategorical.values, formatStringProp), identity = new visuals.SelectionIdBuilder().withSeries(dataViewCategorical.values, valueColumn).withMeasure(valueColumn.source.queryName).createSelectionId(), seriesName = visuals.converterHelper.getSeriesName(valueColumn.source), objects = reader.getSeriesObjects(seriesIndex), color = this.colorHelper.getColorForSeriesValue(objects, dataViewCategorical.values.identityFields, seriesName), dataPoint = {
                                identity: identity,
                                measureFormat: seriesFormat,
                                measure: value,
                                highlightMeasure: highlightValue,
                                index: seriesIndex,
                                label: label,
                                categoryLabel: label,
                                color: color,
                                seriesIndex: seriesIndex
                            };
                            dataPoints.push(dataPoint), this.legendDataPoints.push({
                                label: dataPoint.label,
                                color: dataPoint.color,
                                icon: visuals.LegendIcon.Box,
                                identity: dataPoint.identity,
                                selected: !1
                            });
                        }
                        return dataPoints;
                    }, DonutChartConverter.prototype.convertDataLabelSettings = function() {
                        var dataViewMetadata = this.dataViewMetadata, dataLabelsSettings = visuals.dataLabelUtils.getDefaultDonutLabelSettings();
                        if (dataViewMetadata) {
                            var objects = dataViewMetadata.objects;
                            if (objects) {
                                var labelsObj = objects.labels;
                                labelsObj && visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, dataLabelsSettings);
                            }
                        }
                        return dataLabelsSettings;
                    }, DonutChartConverter.prototype.convertLegendData = function() {
                        return {
                            dataPoints: this.legendDataPoints,
                            labelColor: visuals.LegendData.DefaultLegendLabelFillColor,
                            title: this.getLegendTitle(),
                            fontSize: visuals.SVGLegend.DefaultFontSizeInPt
                        };
                    }, DonutChartConverter;
                }();
                DonutChartConversion.DonutChartConverter = DonutChartConverter;
            }(DonutChartConversion || (DonutChartConversion = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var ScriptVisual = function() {
                function ScriptVisual(options) {
                    this.canRefresh = options.canRefresh;
                }
                return ScriptVisual.prototype.init = function(options) {
                    this.element = options.element, this.hostServices = options.host, this.canRefresh || this.hostServices.setWarnings([ new visuals.ScriptVisualRefreshWarning() ]);
                }, ScriptVisual.prototype.update = function(options) {
                    var dataViews = options.dataViews;
                    if (dataViews && 0 !== dataViews.length) {
                        var dataView = dataViews[0];
                        if (dataView && dataView.metadata) {
                            var imageUrl = null;
                            dataView.scriptResult && dataView.scriptResult.imageBase64 && (imageUrl = "data:image/png;base64," + dataView.scriptResult.imageBase64), 
                            this.ensureHtmlElement();
                            var img = this.ensureImageElement();
                            imageUrl ? img.attr("src", imageUrl) : img.removeAttr("src"), this.onResizing(options.viewport, options.resizeMode || 2);
                        }
                    }
                }, ScriptVisual.prototype.onResizing = function(finalViewport, resizeMode) {
                    var div = this.ensureHtmlElement();
                    div.css({
                        height: finalViewport.height,
                        width: finalViewport.width
                    });
                }, ScriptVisual.prototype.ensureHtmlElement = function() {
                    var div = this.imageBackgroundElement;
                    return div || (div = $("<div class='autoScaleImageContainer'/>"), this.imageBackgroundElement = div, 
                    this.imageBackgroundElement.appendTo(this.element)), div;
                }, ScriptVisual.prototype.ensureImageElement = function() {
                    var img = this.imageElement;
                    return img || (img = $("<img class='autoScaleImage'/>"), this.imageElement = img, 
                    this.imageElement.appendTo(this.imageBackgroundElement)), img;
                }, ScriptVisual;
            }();
            visuals.ScriptVisual = ScriptVisual;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var system;
            !function(system) {
                var DebugVisual = function() {
                    function DebugVisual() {}
                    return DebugVisual.prototype.reloadAdapter = function(auto) {
                        var _this = this;
                        if (void 0 === auto && (auto = !1), this.dataViewShowing) {
                            if (auto) return;
                            this.toggleDataview(!1);
                        }
                        var developerMode = powerbi.localStorageService.getData("DEVELOPER_MODE_ENABLED");
                        if (!developerMode) {
                            this.toggleAutoReload(!1);
                            var errorMessage = this.buildErrorMessage({
                                message: this.host.getLocalizedString("DebugVisual_Enabled_Error_Message"),
                                moreMessage: this.host.getLocalizedString("DebugVisual_Enabled_Error_Learn_More"),
                                moreLinkHref: "https://aka.ms/powerbideveloperenablederror",
                                moreLinkText: this.host.getLocalizedString("DebugVisual_Enabled_Error_Learn_More_Link"),
                                type: "blockedsite"
                            });
                            return this.container.html(errorMessage), void this.setCapabilities();
                        }
                        var baseUrl = powerbi.localStorageService.getData("DEVELOPMENT_SERVER_URL") || "https://localhost:8080/assets/";
                        this.statusLoading || (this.statusLoading = !0, $.get(baseUrl + "status").done(function(status) {
                            if (status && (!auto || _this.lastUpdateStatus !== status)) {
                                if (_this.lastUpdateStatus = status, "error" === status) {
                                    var errorMessage = _this.buildErrorMessage({
                                        message: _this.host.getLocalizedString("DebugVisual_Compile_Error_Message"),
                                        moreMessage: _this.host.getLocalizedString("DebugVisual_Compile_Error_Learn_More"),
                                        moreLinkHref: "https://aka.ms/powerbideveloperpbivizcompileerror",
                                        moreLinkText: _this.host.getLocalizedString("DebugVisual_Compile_Error_Learn_More_Link"),
                                        type: "repair"
                                    });
                                    return _this.container.html(errorMessage), void _this.setCapabilities();
                                }
                                $.getJSON(baseUrl + "pbiviz.json").done(function(pbivizJson) {
                                    pbivizJson.capabilities && pbivizJson.visual && pbivizJson.visual.guid && (_this.visualGuid !== pbivizJson.visual.guid && (_this.visualGuid = pbivizJson.visual.guid), 
                                    $.getScript(baseUrl + "visual.js").done(function() {
                                        visuals.plugins[_this.visualGuid] && (visuals.plugins[_this.visualGuid].capabilities = pbivizJson.capabilities, 
                                        powerbi.extensibility.translateVisualPlugin(visuals.plugins[_this.visualGuid]), 
                                        $.get(baseUrl + "visual.css").done(function(data) {
                                            $("#css-DEBUG").remove(), $("<style/>", {
                                                id: "css-DEBUG",
                                                html: data
                                            }).appendTo($("head")), _this.loadVisual(_this.visualGuid), _this.setCapabilities(visuals.plugins[_this.visualGuid].capabilities);
                                        }));
                                    }));
                                });
                            }
                        }).fail(function() {
                            _this.toggleAutoReload(!1);
                            var errorMessage = _this.buildErrorMessage({
                                message: _this.host.getLocalizedString("DebugVisual_Server_Error_Message"),
                                moreMessage: _this.host.getLocalizedString("DebugVisual_Server_Error_Learn_More"),
                                moreLinkHref: "https://aka.ms/powerbideveloperpbivizservererror",
                                moreLinkText: _this.host.getLocalizedString("DebugVisual_Server_Error_Learn_More_Link"),
                                type: "error"
                            });
                            _this.container.html(errorMessage), _this.setCapabilities();
                        }).always(function() {
                            _this.statusLoading = !1;
                        }));
                    }, DebugVisual.prototype.loadVisual = function(guid) {
                        this.visualContainer.attr("class", "visual-" + guid), this.visualContainer.empty(), 
                        this.container.empty().append(this.visualContainer);
                        var adapter = this.adapter = powerbi.extensibility.createVisualAdapter(visuals.plugins[guid]);
                        if (adapter.init && adapter.init(this.optionsForVisual), adapter.update && this.lastUpdateOptions) {
                            var lastUpdateOptions = powerbi.Prototype.inherit(this.lastUpdateOptions);
                            lastUpdateOptions.type = powerbi.VisualUpdateType.All, adapter.update(lastUpdateOptions);
                        }
                    }, DebugVisual.prototype.toggleAutoReload = function(value) {
                        var _this = this;
                        this.autoReloadInterval && value !== !0 ? (this.autoRefreshBtn.addClass("pbi-glyph-play"), 
                        this.autoRefreshBtn.removeClass("pbi-glyph-stop"), this.refreshBtn.show(), clearInterval(this.autoReloadInterval), 
                        this.autoReloadInterval = void 0) : this.autoReloadInterval || value === !1 || (this.autoRefreshBtn.removeClass("pbi-glyph-play"), 
                        this.autoRefreshBtn.addClass("pbi-glyph-stop"), this.refreshBtn.hide(), this.autoReloadInterval = setInterval(function() {
                            return _this.reloadAdapter(!0);
                        }, DebugVisual.autoReloadPollTime));
                    }, DebugVisual.prototype.toggleDataview = function(value) {
                        this.dataViewShowing && value !== !0 ? (this.dataViewShowing = !1, this.dataBtn.toggleClass("active", !1), 
                        this.reloadAdapter()) : this.dataViewShowing || value === !1 || (this.dataViewShowing = !0, 
                        this.dataBtn.toggleClass("active", !0), this.loadVisual("dataViewer"));
                    }, DebugVisual.prototype.createRefreshBtn = function() {
                        var _this = this, label = this.host.getLocalizedString("DebugVisual_Reload_Visual_Button_Title"), refreshBtn = this.refreshBtn = $('<i title="' + label + '" class="controlBtn glyphicon pbi-glyph-refresh"></i>');
                        return refreshBtn.on("click", function() {
                            return _this.reloadAdapter();
                        }), refreshBtn;
                    }, DebugVisual.prototype.createAutoRefreshBtn = function() {
                        var _this = this, label = this.host.getLocalizedString("DebugVisual_Toggle_Auto_Reload_Button_Title"), autoRefreshBtn = this.autoRefreshBtn = $('<i title="' + label + '" class="controlBtn glyphicon pbi-glyph-play"></i>');
                        return autoRefreshBtn.on("click", function() {
                            return _this.toggleAutoReload();
                        }), autoRefreshBtn;
                    }, DebugVisual.prototype.createDataBtn = function() {
                        var _this = this, label = this.host.getLocalizedString("DebugVisual_Show_Dataview_Button_Title"), dataBtn = this.dataBtn = $('<i title="' + label + '" class="controlBtn glyphicon pbi-glyph-seedata"></i>');
                        return dataBtn.on("click", function() {
                            return _this.toggleDataview();
                        }), dataBtn;
                    }, DebugVisual.prototype.createHelpBtn = function() {
                        var label = this.host.getLocalizedString("DebugVisual_Help_Button_Title"), helpBtn = $('<a href="https://aka.ms/powerbideveloperhelp" target="_blank"><i title="' + label + '" class="controlBtn glyphicon pbi-glyph-question"></i></a>');
                        return helpBtn;
                    }, DebugVisual.prototype.createSmilyBtn = function() {
                        var label = this.host.getLocalizedString("DebugVisual_Feedback_Button_Title"), smilyBtn = $('<a href="https://aka.ms/powerbideveloperfeedback" target="_blank"><i title="' + label + '" class="controlBtn glyphicon pbi-glyph-smiley"></i></a>');
                        return smilyBtn;
                    }, DebugVisual.prototype.buildControls = function() {
                        var controlsContainer = $('<div class="debugVisual-controlsContainer"></div>');
                        return controlsContainer.append(this.createRefreshBtn(), this.createAutoRefreshBtn(), this.createDataBtn(), this.createHelpBtn(), this.createSmilyBtn()), 
                        controlsContainer;
                    }, DebugVisual.prototype.buildErrorMessage = function(options) {
                        return _.template(DebugVisual.errorMessageTemplate)(options);
                    }, DebugVisual.prototype.setCapabilities = function(capabilities) {
                        void 0 === capabilities && (capabilities = DebugVisual.defaultCapabilities), _.isEqual(capabilities, visuals.plugins.debugVisual.capabilities) || (visuals.plugins.debugVisual.capabilities = capabilities, 
                        this.host.visualCapabilitiesChanged());
                    }, DebugVisual.prototype.init = function(options) {
                        this.host = options.host;
                        var container = this.container = $('<div class="debugVisualContainer"></div>'), visualContainer = this.visualContainer = $('<div class="visual"></div>');
                        this.dataViewShowing = !1, container.append(visualContainer), options.element.append(container);
                        var optionsForVisual = this.optionsForVisual = powerbi.Prototype.inherit(options);
                        optionsForVisual.element = visualContainer, this.host.setToolbar(this.buildControls()), 
                        this.reloadAdapter();
                    }, DebugVisual.prototype.update = function(options) {
                        var visualOptions = this.lastUpdateOptions = powerbi.Prototype.inherit(options), height = options.viewport.height, width = options.viewport.width;
                        this.visualContainer.height(height).width(width), this.adapter && this.adapter.update && this.adapter.update(visualOptions);
                    }, DebugVisual.prototype.enumerateObjectInstances = function(options) {
                        return this.adapter && this.adapter.enumerateObjectInstances ? this.adapter.enumerateObjectInstances(options) : [];
                    }, DebugVisual.prototype.destroy = function() {
                        this.adapter && this.adapter.destroy && this.adapter.destroy(), this.toggleAutoReload(!1), 
                        this.container = null, this.visualContainer = null, this.host.setToolbar(null);
                    }, DebugVisual.defaultCapabilities = {
                        dataRoles: [ {
                            displayName: "Values",
                            name: "Values",
                            kind: powerbi.VisualDataRoleKind.Measure
                        } ],
                        dataViewMappings: [ {
                            table: {
                                rows: {
                                    "for": {
                                        "in": "Values"
                                    }
                                }
                            }
                        } ]
                    }, DebugVisual.capabilities = DebugVisual.defaultCapabilities, DebugVisual.autoReloadPollTime = 300, 
                    DebugVisual.errorMessageTemplate = '\n            <div class="errorContainer">\n                <div class="errorMessage">\n                    <div ng-switch="$ctrl.errorInfo.overlayType">\n                        <div class="glyphicon pbi-glyph-<%= type %> glyph-med"></div>\n                    </div>\n                    <div>\n                        <div class="errorSpan"><%= message %></div>\n                        <span class="errorSeeMore"><%= moreMessage %></span>\n                        <a class="errorSeeMore" href="<%= moreLinkHref %>" target="_blank"><%= moreLinkText %></a>\n                    </div>\n                </div>\n            </div>\n        ', 
                    DebugVisual;
                }();
                system.DebugVisual = DebugVisual;
            }(system = visuals.system || (visuals.system = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var plugins;
            !function(plugins) {
                plugins.animatedNumber = {
                    name: "animatedNumber",
                    capabilities: visuals.capabilities.animatedNumber,
                    create: function() {
                        return new visuals.AnimatedNumber();
                    }
                }, plugins.areaChart = {
                    name: "areaChart",
                    watermarkKey: "area",
                    capabilities: visuals.capabilities.lineChart,
                    create: function() {
                        return new visuals.CartesianChart({
                            chartType: 1
                        });
                    },
                    customizeQuery: visuals.LineChart.customizeQuery,
                    getSortableRoles: function(visualSortableOptions) {
                        return visuals.ColumnChart.getSortableRoles(visualSortableOptions);
                    },
                    getAdditionalTelemetry: function(dataView) {
                        return visuals.CartesianChart.getAdditionalTelemetry(dataView);
                    }
                }, plugins.barChart = {
                    name: "barChart",
                    watermarkKey: "bar",
                    capabilities: visuals.capabilities.barChart,
                    create: function() {
                        return new visuals.CartesianChart({
                            chartType: 6
                        });
                    },
                    customizeQuery: visuals.ColumnChart.customizeQuery,
                    getSortableRoles: function(visualSortableOptions) {
                        return visuals.ColumnChart.getSortableRoles(visualSortableOptions);
                    },
                    getAdditionalTelemetry: function(dataView) {
                        return visuals.CartesianChart.getAdditionalTelemetry(dataView);
                    }
                }, plugins.basicShape = {
                    name: "basicShape",
                    capabilities: visuals.basicShapeCapabilities,
                    create: function() {
                        return new visuals.BasicShapeVisual();
                    }
                }, plugins.card = {
                    name: "card",
                    watermarkKey: "card",
                    capabilities: visuals.capabilities.card,
                    create: function() {
                        return new visuals.Card();
                    }
                }, plugins.multiRowCard = {
                    name: "multiRowCard",
                    watermarkKey: "multiRowCard",
                    capabilities: visuals.capabilities.multiRowCard,
                    create: function() {
                        return new visuals.MultiRowCard();
                    },
                    getSortableRoles: function(visualSortableOptions) {
                        return visuals.MultiRowCard.getSortableRoles(visualSortableOptions);
                    }
                }, plugins.clusteredBarChart = {
                    name: "clusteredBarChart",
                    watermarkKey: "clusteredBar",
                    capabilities: visuals.capabilities.clusteredBarChart,
                    create: function() {
                        return new visuals.CartesianChart({
                            chartType: 5
                        });
                    },
                    customizeQuery: visuals.ColumnChart.customizeQuery,
                    getSortableRoles: function(visualSortableOptions) {
                        return visuals.ColumnChart.getSortableRoles(visualSortableOptions);
                    },
                    getAdditionalTelemetry: function(dataView) {
                        return visuals.CartesianChart.getAdditionalTelemetry(dataView);
                    }
                }, plugins.clusteredColumnChart = {
                    name: "clusteredColumnChart",
                    watermarkKey: "clusteredColumn",
                    capabilities: visuals.capabilities.clusteredColumnChart,
                    create: function() {
                        return new visuals.CartesianChart({
                            chartType: 3
                        });
                    },
                    customizeQuery: visuals.ColumnChart.customizeQuery,
                    getSortableRoles: function(visualSortableOptions) {
                        return visuals.ColumnChart.getSortableRoles(visualSortableOptions);
                    },
                    getAdditionalTelemetry: function(dataView) {
                        return visuals.CartesianChart.getAdditionalTelemetry(dataView);
                    }
                }, plugins.columnChart = {
                    name: "columnChart",
                    watermarkKey: "column",
                    capabilities: visuals.capabilities.columnChart,
                    create: function() {
                        return new visuals.CartesianChart({
                            chartType: 4
                        });
                    },
                    customizeQuery: visuals.ColumnChart.customizeQuery,
                    getSortableRoles: function(visualSortableOptions) {
                        return visuals.ColumnChart.getSortableRoles(visualSortableOptions);
                    },
                    getAdditionalTelemetry: function(dataView) {
                        return visuals.CartesianChart.getAdditionalTelemetry(dataView);
                    }
                }, plugins.comboChart = {
                    name: "comboChart",
                    watermarkKey: "combo",
                    capabilities: visuals.capabilities.comboChart,
                    customizeQuery: visuals.ComboChart.customizeQuery,
                    create: function() {
                        return new visuals.CartesianChart({
                            chartType: 10
                        });
                    },
                    getSortableRoles: function(visualSortableOptions) {
                        return visuals.ComboChart.getSortableRoles(visualSortableOptions);
                    },
                    getAdditionalTelemetry: function(dataView) {
                        return visuals.CartesianChart.getAdditionalTelemetry(dataView);
                    }
                }, plugins.dataDotChart = {
                    name: "dataDotChart",
                    capabilities: visuals.capabilities.dataDotChart,
                    create: function() {
                        return new visuals.CartesianChart({
                            chartType: 11
                        });
                    },
                    getAdditionalTelemetry: function(dataView) {
                        return visuals.CartesianChart.getAdditionalTelemetry(dataView);
                    }
                }, plugins.dataDotClusteredColumnComboChart = {
                    name: "dataDotClusteredColumnComboChart",
                    watermarkKey: "combo",
                    capabilities: visuals.capabilities.dataDotClusteredColumnComboChart,
                    customizeQuery: visuals.ComboChart.customizeQuery,
                    create: function() {
                        return new visuals.CartesianChart({
                            chartType: 15
                        });
                    },
                    getAdditionalTelemetry: function(dataView) {
                        return visuals.CartesianChart.getAdditionalTelemetry(dataView);
                    }
                }, plugins.dataDotStackedColumnComboChart = {
                    name: "dataDotStackedColumnComboChart",
                    watermarkKey: "combo",
                    capabilities: visuals.capabilities.dataDotStackedColumnComboChart,
                    customizeQuery: visuals.ComboChart.customizeQuery,
                    create: function() {
                        return new visuals.CartesianChart({
                            chartType: 16
                        });
                    },
                    getAdditionalTelemetry: function(dataView) {
                        return visuals.CartesianChart.getAdditionalTelemetry(dataView);
                    }
                }, plugins.donutChart = {
                    name: "donutChart",
                    watermarkKey: "donut",
                    capabilities: visuals.capabilities.donutChart,
                    create: function() {
                        return new visuals.DonutChart();
                    }
                }, plugins.funnel = {
                    name: "funnel",
                    watermarkKey: "funnel",
                    capabilities: visuals.capabilities.funnel,
                    create: function() {
                        return new visuals.FunnelChart();
                    }
                }, plugins.gauge = {
                    name: "gauge",
                    watermarkKey: "gauge",
                    capabilities: visuals.capabilities.gauge,
                    create: function() {
                        return new visuals.Gauge();
                    }
                }, plugins.hundredPercentStackedBarChart = {
                    name: "hundredPercentStackedBarChart",
                    watermarkKey: "100stackedbar",
                    capabilities: visuals.capabilities.hundredPercentStackedBarChart,
                    create: function() {
                        return new visuals.CartesianChart({
                            chartType: 7
                        });
                    },
                    customizeQuery: visuals.ColumnChart.customizeQuery,
                    getSortableRoles: function(visualSortableOptions) {
                        return visuals.ColumnChart.getSortableRoles(visualSortableOptions);
                    },
                    getAdditionalTelemetry: function(dataView) {
                        return visuals.CartesianChart.getAdditionalTelemetry(dataView);
                    }
                }, plugins.hundredPercentStackedColumnChart = {
                    name: "hundredPercentStackedColumnChart",
                    watermarkKey: "100stackedcolumn",
                    capabilities: visuals.capabilities.hundredPercentStackedColumnChart,
                    create: function() {
                        return new visuals.CartesianChart({
                            chartType: 8
                        });
                    },
                    customizeQuery: visuals.ColumnChart.customizeQuery,
                    getSortableRoles: function(visualSortableOptions) {
                        return visuals.ColumnChart.getSortableRoles(visualSortableOptions);
                    },
                    getAdditionalTelemetry: function(dataView) {
                        return visuals.CartesianChart.getAdditionalTelemetry(dataView);
                    }
                }, plugins.image = {
                    name: "image",
                    capabilities: visuals.capabilities.image,
                    create: function() {
                        return new visuals.ImageVisual();
                    }
                }, plugins.lineChart = {
                    name: "lineChart",
                    watermarkKey: "line",
                    capabilities: visuals.capabilities.lineChart,
                    create: function() {
                        return new visuals.CartesianChart({
                            chartType: 0
                        });
                    },
                    customizeQuery: visuals.LineChart.customizeQuery,
                    getSortableRoles: function(visualSortableOptions) {
                        return visuals.LineChart.getSortableRoles(visualSortableOptions);
                    },
                    getAdditionalTelemetry: function(dataView) {
                        return visuals.CartesianChart.getAdditionalTelemetry(dataView);
                    }
                }, plugins.lineStackedColumnComboChart = {
                    name: "lineStackedColumnComboChart",
                    watermarkKey: "combo",
                    capabilities: visuals.capabilities.lineStackedColumnComboChart,
                    customizeQuery: visuals.ComboChart.customizeQuery,
                    create: function() {
                        return new visuals.CartesianChart({
                            chartType: 14
                        });
                    },
                    getSortableRoles: function(visualSortableOptions) {
                        return visuals.ComboChart.getSortableRoles(visualSortableOptions);
                    },
                    getAdditionalTelemetry: function(dataView) {
                        return visuals.CartesianChart.getAdditionalTelemetry(dataView);
                    }
                }, plugins.lineClusteredColumnComboChart = {
                    name: "lineClusteredColumnComboChart",
                    watermarkKey: "combo",
                    capabilities: visuals.capabilities.lineClusteredColumnComboChart,
                    customizeQuery: visuals.ComboChart.customizeQuery,
                    create: function() {
                        return new visuals.CartesianChart({
                            chartType: 13
                        });
                    },
                    getSortableRoles: function(visualSortableOptions) {
                        return visuals.ComboChart.getSortableRoles(visualSortableOptions);
                    },
                    getAdditionalTelemetry: function(dataView) {
                        return visuals.CartesianChart.getAdditionalTelemetry(dataView);
                    }
                }, plugins.map = {
                    name: "map",
                    watermarkKey: "map",
                    capabilities: visuals.capabilities.map,
                    create: function() {
                        return new visuals.Map({
                            filledMap: !1
                        });
                    }
                }, plugins.filledMap = {
                    name: "filledMap",
                    watermarkKey: "filledMap",
                    capabilities: visuals.capabilities.filledMap,
                    create: function() {
                        return new visuals.Map({
                            filledMap: !0
                        });
                    }
                }, plugins.treemap = {
                    name: "treemap",
                    watermarkKey: "tree",
                    capabilities: visuals.capabilities.treemap,
                    create: function() {
                        return new visuals.Treemap();
                    }
                }, plugins.pieChart = {
                    name: "pieChart",
                    watermarkKey: "pie",
                    capabilities: visuals.capabilities.donutChart,
                    create: function() {
                        return new visuals.DonutChart({
                            sliceWidthRatio: 0
                        });
                    }
                }, plugins.scatterChart = {
                    name: "scatterChart",
                    watermarkKey: "scatterplot",
                    capabilities: visuals.capabilities.scatterChart,
                    create: function() {
                        return new visuals.CartesianChart({
                            chartType: 9
                        });
                    },
                    getAdditionalTelemetry: function(dataView) {
                        return visuals.ScatterChart.getAdditionalTelemetry(dataView);
                    }
                }, plugins.stackedAreaChart = {
                    name: "stackedAreaChart",
                    watermarkKey: "stackedarea",
                    capabilities: visuals.capabilities.lineChart,
                    create: function() {
                        return new visuals.CartesianChart({
                            chartType: 2
                        });
                    },
                    customizeQuery: visuals.LineChart.customizeQuery,
                    getSortableRoles: function(visualSortableOptions) {
                        return visuals.ColumnChart.getSortableRoles(visualSortableOptions);
                    },
                    getAdditionalTelemetry: function(dataView) {
                        return visuals.CartesianChart.getAdditionalTelemetry(dataView);
                    }
                }, plugins.table = {
                    name: "table",
                    watermarkKey: "table",
                    capabilities: visuals.capabilities.table,
                    create: function() {
                        return new visuals.Table();
                    },
                    customizeQuery: visuals.Table.customizeQuery,
                    getSortableRoles: function(visualSortableOptions) {
                        return visuals.Table.getSortableRoles();
                    }
                }, plugins.matrix = {
                    name: "matrix",
                    watermarkKey: "matrix",
                    capabilities: visuals.capabilities.matrix,
                    create: function() {
                        return new visuals.Matrix();
                    },
                    customizeQuery: visuals.Matrix.customizeQuery,
                    getSortableRoles: function(visualSortableOptions) {
                        return visuals.Matrix.getSortableRoles();
                    }
                }, plugins.slicer = {
                    name: "slicer",
                    watermarkKey: "slicer",
                    capabilities: visuals.capabilities.slicer,
                    create: function() {
                        return new visuals.Slicer();
                    }
                }, plugins.textbox = {
                    name: "textbox",
                    capabilities: visuals.capabilities.textbox,
                    create: function() {
                        return new visuals.Textbox();
                    }
                }, plugins.waterfallChart = {
                    name: "waterfallChart",
                    watermarkKey: "waterfall",
                    capabilities: visuals.capabilities.waterfallChart,
                    create: function() {
                        return new visuals.CartesianChart({
                            chartType: 12
                        });
                    },
                    getAdditionalTelemetry: function(dataView) {
                        return visuals.CartesianChart.getAdditionalTelemetry(dataView);
                    }
                }, plugins.cheerMeter = {
                    name: "cheerMeter",
                    capabilities: visuals.CheerMeter.capabilities,
                    create: function() {
                        return new visuals.CheerMeter();
                    }
                }, plugins.consoleWriter = {
                    name: "consoleWriter",
                    capabilities: visuals.samples.consoleWriterCapabilities,
                    create: function() {
                        return new visuals.samples.ConsoleWriter();
                    }
                }, plugins.helloIVisual = {
                    name: "helloIVisual",
                    capabilities: visuals.samples.HelloIVisual.capabilities,
                    create: function() {
                        return new visuals.samples.HelloIVisual();
                    }
                }, plugins.owlGauge = {
                    name: "owlGauge",
                    watermarkKey: "gauge",
                    capabilities: visuals.OwlGauge.capabilities,
                    create: function() {
                        return new visuals.OwlGauge();
                    }
                }, plugins.scriptVisual = {
                    name: "scriptVisual",
                    watermarkKey: "scriptvisual",
                    capabilities: visuals.capabilities.scriptVisual,
                    create: function() {
                        return new visuals.ScriptVisual({
                            canRefresh: !1
                        });
                    }
                }, plugins.kpi = {
                    name: "kpi",
                    watermarkKey: "kpi",
                    capabilities: visuals.capabilities.kpi,
                    create: function() {
                        return new visuals.KPIStatusWithHistory();
                    }
                }, plugins.debugVisual = {
                    name: "debugVisual",
                    watermarkKey: "kpi",
                    capabilities: visuals.system.DebugVisual.capabilities,
                    create: function() {
                        return new visuals.system.DebugVisual();
                    }
                };
            }(plugins = visuals.plugins || (visuals.plugins = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var CanvasBackgroundHelper;
            !function(CanvasBackgroundHelper) {
                function getDefaultColor() {
                    return "#FFFFFF";
                }
                function getDefaultValues() {
                    return {
                        color: getDefaultColor()
                    };
                }
                CanvasBackgroundHelper.getDefaultColor = getDefaultColor, CanvasBackgroundHelper.getDefaultValues = getDefaultValues;
            }(CanvasBackgroundHelper = visuals.CanvasBackgroundHelper || (visuals.CanvasBackgroundHelper = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var defaultMaxValue = 100, DateRange = function() {
                function DateRange(min, max, start, end) {
                    var interval = d3.time.day;
                    this.scale = d3.time.scale().domain([ min, max ]).range([ 0, defaultMaxValue ]).nice(interval), 
                    this.value = {
                        min: start || min,
                        max: end || max
                    }, this.setValue(this.value);
                }
                return DateRange.prototype.getScaledValue = function() {
                    return this.scaledValue;
                }, DateRange.prototype.setValue = function(original) {
                    this.value = original, this.scaledValue = {
                        min: this.scale(original.min),
                        max: this.scale(original.max)
                    };
                }, DateRange.prototype.getValue = function() {
                    return this.value;
                }, DateRange.prototype.setScaledValue = function(value) {
                    this.scaledValue = value, this.value = {
                        min: this.scale.invert(value.min),
                        max: this.scale.invert(value.max)
                    };
                }, DateRange;
            }();
            visuals.DateRange = DateRange;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            function wrapFormattingElements(elements) {
                return {
                    grid: [ {
                        properties: {
                            outlineColor: createSolidFillDefinition(elements.grid.outlineColor),
                            outlineWeight: SQExprBuilder.integer(valueOrDefault(elements.grid.outlineWeight, defaultOutlineWeight)),
                            gridVertical: SQExprBuilder["boolean"](elements.grid.gridVertical),
                            gridVerticalColor: createSolidFillDefinition(elements.grid.gridVerticalColor),
                            gridVerticalWeight: SQExprBuilder.integer(valueOrDefault(elements.grid.gridVerticalWeight, defaultGridlineVerticalWeight)),
                            gridHorizontal: SQExprBuilder["boolean"](elements.grid.gridHorizontal),
                            gridHorizontalColor: createSolidFillDefinition(elements.grid.gridHorizontalColor),
                            gridHorizontalWeight: SQExprBuilder.integer(valueOrDefault(elements.grid.gridHorizontalWeight, defaultGridlineHorizontalWeight)),
                            rowPadding: SQExprBuilder.integer(elements.grid.rowPadding)
                        }
                    } ],
                    columnHeaders: [ {
                        properties: {
                            outline: SQExprBuilder.text(elements.columnHeaders.outline),
                            fontColor: createSolidFillDefinition(elements.columnHeaders.fontColor),
                            backColor: createSolidFillDefinition(elements.columnHeaders.backColor)
                        }
                    } ],
                    values: [ {
                        properties: {
                            outline: SQExprBuilder.text(elements.values.outline),
                            fontColorPrimary: createSolidFillDefinition(elements.values.fontColorPrimary),
                            backColorPrimary: createSolidFillDefinition(elements.values.backColorPrimary),
                            fontColorSecondary: createSolidFillDefinition(elements.values.fontColorSecondary),
                            backColorSecondary: createSolidFillDefinition(elements.values.backColorSecondary)
                        }
                    } ],
                    total: [ {
                        properties: {
                            outline: SQExprBuilder.text(elements.total.outline),
                            fontColor: createSolidFillDefinition(elements.total.fontColor),
                            backColor: createSolidFillDefinition(elements.total.backColor)
                        }
                    } ]
                };
            }
            function tableStylePresets() {
                return {
                    sectionTitle: powerbi.data.createDisplayNameGetter("Visual_Table_StylePreset_SectionTitle"),
                    sliceTitle: powerbi.data.createDisplayNameGetter("Visual_Table_StylePreset_SliceTitle"),
                    defaultPresetName: "None",
                    presets: {
                        None: {
                            name: "None",
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Table_StylePreset_None"),
                            evaluate: function(theme) {
                                return wrapFormattingElements({
                                    grid: {
                                        outlineColor: TablixObjects.PropGridOutlineColor.defaultValue,
                                        gridVertical: TablixObjects.PropGridVertical.defaultValue,
                                        gridVerticalColor: TablixObjects.PropGridVerticalColor.defaultValue,
                                        gridHorizontal: TablixObjects.PropGridHorizontalTable.defaultValue,
                                        gridHorizontalColor: TablixObjects.PropGridHorizontalColor.defaultValue,
                                        rowPadding: TablixObjects.PropGridRowPadding.defaultValue
                                    },
                                    columnHeaders: {
                                        outline: defaultColumnsOutline,
                                        fontColor: TablixObjects.PropColumnsFontColor.defaultValue,
                                        backColor: TablixObjects.PropColumnsBackColor.defaultValue
                                    },
                                    values: {
                                        outline: defaultValuesOutline,
                                        fontColorPrimary: TablixObjects.PropValuesFontColorPrimary.defaultValue,
                                        backColorPrimary: TablixObjects.PropValuesBackColorPrimary.defaultValue,
                                        fontColorSecondary: TablixObjects.PropValuesFontColorSecondary.defaultValue,
                                        backColorSecondary: TablixObjects.PropValuesBackColorSecondary.defaultValue
                                    },
                                    total: {
                                        outline: defaultTotalOutline,
                                        fontColor: TablixObjects.PropTotalFontColor.defaultValue,
                                        backColor: TablixObjects.PropTotalBackColor.defaultValue
                                    }
                                });
                            }
                        },
                        Minimal: {
                            name: "Minimal",
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Table_StylePreset_Minimal"),
                            evaluate: function(theme) {
                                var backColor = theme.colorPalette.background.value, foreColor = theme.colorPalette.foreground.value, outlineColor = theme.colorPalette.tableAccent.value, gridColor = Color.hexBlend(foreColor, .12, backColor);
                                return wrapFormattingElements({
                                    grid: {
                                        outlineColor: outlineColor,
                                        gridVertical: !1,
                                        gridVerticalColor: gridColor,
                                        gridVerticalWeight: defaultGridlineVerticalWeight,
                                        gridHorizontal: !0,
                                        gridHorizontalColor: gridColor,
                                        gridHorizontalWeight: defaultGridlineHorizontalWeight,
                                        rowPadding: rowPaddingNormal
                                    },
                                    columnHeaders: {
                                        outline: defaultColumnsOutline,
                                        fontColor: foreColor,
                                        backColor: backColor
                                    },
                                    values: {
                                        outline: defaultValuesOutline,
                                        fontColorPrimary: foreColor,
                                        backColorPrimary: backColor,
                                        fontColorSecondary: foreColor,
                                        backColorSecondary: backColor
                                    },
                                    total: {
                                        outline: defaultTotalOutline,
                                        fontColor: foreColor,
                                        backColor: backColor
                                    }
                                });
                            }
                        },
                        BoldHeader: {
                            name: "BoldHeader",
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Table_StylePreset_BoldHeader"),
                            evaluate: function(theme) {
                                var backColor = theme.colorPalette.background.value, foreColor = theme.colorPalette.foreground.value, accent = theme.colorPalette.tableAccent.value, gridColor = Color.hexBlend(foreColor, .12, backColor);
                                return wrapFormattingElements({
                                    grid: {
                                        outlineColor: accent,
                                        gridVertical: !1,
                                        gridVerticalColor: gridColor,
                                        gridVerticalWeight: defaultGridlineVerticalWeight,
                                        gridHorizontal: !0,
                                        gridHorizontalColor: gridColor,
                                        gridHorizontalWeight: defaultGridlineHorizontalWeight,
                                        rowPadding: rowPaddingNormal
                                    },
                                    columnHeaders: {
                                        outline: defaultColumnsOutline,
                                        fontColor: backColor,
                                        backColor: foreColor
                                    },
                                    values: {
                                        outline: defaultValuesOutline,
                                        fontColorPrimary: foreColor,
                                        backColorPrimary: backColor,
                                        fontColorSecondary: foreColor,
                                        backColorSecondary: backColor
                                    },
                                    total: {
                                        outline: defaultTotalOutline,
                                        fontColor: foreColor,
                                        backColor: backColor
                                    }
                                });
                            }
                        },
                        AlternatingRows: {
                            name: "AlternatingRows",
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Table_StylePreset_AlternatingRows"),
                            evaluate: function(theme) {
                                var backColor = theme.colorPalette.background.value, foreColor = theme.colorPalette.foreground.value, accent = theme.colorPalette.tableAccent.value, gridColor = Color.hexBlend(foreColor, .12, backColor);
                                return wrapFormattingElements({
                                    grid: {
                                        outlineColor: accent,
                                        gridVertical: !1,
                                        gridVerticalColor: gridColor,
                                        gridVerticalWeight: defaultGridlineVerticalWeight,
                                        gridHorizontal: !0,
                                        gridHorizontalColor: gridColor,
                                        gridHorizontalWeight: defaultGridlineHorizontalWeight,
                                        rowPadding: rowPaddingNormal
                                    },
                                    columnHeaders: {
                                        outline: defaultColumnsOutline,
                                        fontColor: backColor,
                                        backColor: foreColor
                                    },
                                    values: {
                                        outline: defaultValuesOutline,
                                        fontColorPrimary: foreColor,
                                        backColorPrimary: backColor,
                                        fontColorSecondary: foreColor,
                                        backColorSecondary: Color.hexBlend(foreColor, .08, backColor)
                                    },
                                    total: {
                                        outline: defaultTotalOutline,
                                        fontColor: backColor,
                                        backColor: foreColor
                                    }
                                });
                            }
                        },
                        ContrastAlternatingRows: {
                            name: "ContrastAlternatingRows",
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Table_StylePreset_ContrastAlternatingRows"),
                            evaluate: function(theme) {
                                var backColor = theme.colorPalette.background.value, foreColor = theme.colorPalette.foreground.value, accent = theme.colorPalette.tableAccent.value, gridColor = Color.hexBlend(foreColor, .12, backColor);
                                return wrapFormattingElements({
                                    grid: {
                                        outlineColor: accent,
                                        gridVertical: !1,
                                        gridVerticalColor: gridColor,
                                        gridVerticalWeight: defaultGridlineVerticalWeight,
                                        gridHorizontal: !0,
                                        gridHorizontalColor: gridColor,
                                        gridHorizontalWeight: defaultGridlineHorizontalWeight,
                                        rowPadding: rowPaddingNormal
                                    },
                                    columnHeaders: {
                                        outline: defaultColumnsOutline,
                                        fontColor: backColor,
                                        backColor: foreColor
                                    },
                                    values: {
                                        outline: defaultValuesOutline,
                                        fontColorPrimary: backColor,
                                        backColorPrimary: Color.hexBlend(foreColor, .75, backColor),
                                        fontColorSecondary: foreColor,
                                        backColorSecondary: Color.hexBlend(foreColor, .25, backColor)
                                    },
                                    total: {
                                        outline: defaultTotalOutline,
                                        fontColor: backColor,
                                        backColor: foreColor
                                    }
                                });
                            }
                        },
                        FlashyRows: {
                            name: "FlashyRows",
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Table_StylePreset_FlashyRows"),
                            evaluate: function(theme) {
                                var backColor = theme.colorPalette.background.value, foreColor = theme.colorPalette.foreground.value, accent = theme.colorPalette.tableAccent.value;
                                return wrapFormattingElements({
                                    grid: {
                                        outlineColor: foreColor,
                                        gridVertical: !1,
                                        gridVerticalColor: backColor,
                                        gridVerticalWeight: defaultGridlineVerticalWeight,
                                        gridHorizontal: !1,
                                        gridHorizontalColor: backColor,
                                        gridHorizontalWeight: defaultGridlineHorizontalWeight,
                                        rowPadding: rowPaddingNormal
                                    },
                                    columnHeaders: {
                                        outline: defaultColumnsOutline,
                                        fontColor: foreColor,
                                        backColor: backColor
                                    },
                                    values: {
                                        outline: defaultValuesOutline,
                                        fontColorPrimary: foreColor,
                                        backColorPrimary: Color.hexBlend(accent, .4, backColor),
                                        fontColorSecondary: foreColor,
                                        backColorSecondary: Color.hexBlend(accent, .8, backColor)
                                    },
                                    total: {
                                        outline: defaultTotalOutline,
                                        fontColor: foreColor,
                                        backColor: backColor
                                    }
                                });
                            }
                        },
                        BoldHeaderFlashyRows: {
                            name: "BoldHeaderFlashyRows",
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Table_StylePreset_BoldHeaderFlashyRows"),
                            evaluate: function(theme) {
                                var backColor = theme.colorPalette.background.value, foreColor = theme.colorPalette.foreground.value, accent = theme.colorPalette.tableAccent.value;
                                return wrapFormattingElements({
                                    grid: {
                                        outlineColor: backColor,
                                        gridVertical: !1,
                                        gridVerticalColor: foreColor,
                                        gridVerticalWeight: defaultGridlineVerticalWeight,
                                        gridHorizontal: !1,
                                        gridHorizontalColor: foreColor,
                                        gridHorizontalWeight: defaultGridlineHorizontalWeight,
                                        rowPadding: rowPaddingNormal
                                    },
                                    columnHeaders: {
                                        outline: defaultColumnsOutline,
                                        fontColor: backColor,
                                        backColor: foreColor
                                    },
                                    values: {
                                        outline: defaultValuesOutline,
                                        fontColorPrimary: foreColor,
                                        backColorPrimary: Color.hexBlend(accent, .4, backColor),
                                        fontColorSecondary: foreColor,
                                        backColorSecondary: Color.hexBlend(accent, .8, backColor)
                                    },
                                    total: {
                                        outline: defaultTotalOutline,
                                        fontColor: backColor,
                                        backColor: foreColor
                                    }
                                });
                            }
                        },
                        Sparse: {
                            name: "Sparse",
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Table_StylePreset_Sparse"),
                            evaluate: function(theme) {
                                var backColor = theme.colorPalette.background.value, foreColor = theme.colorPalette.foreground.value, accent = theme.colorPalette.tableAccent.value, gridColor = Color.hexBlend(foreColor, .2, backColor);
                                return wrapFormattingElements({
                                    grid: {
                                        outlineColor: accent,
                                        gridVertical: !1,
                                        gridVerticalColor: gridColor,
                                        gridVerticalWeight: defaultGridlineVerticalWeight,
                                        gridHorizontal: !1,
                                        gridHorizontalColor: gridColor,
                                        gridHorizontalWeight: defaultGridlineHorizontalWeight,
                                        rowPadding: rowPaddingSparse
                                    },
                                    columnHeaders: {
                                        outline: defaultColumnsOutline,
                                        fontColor: backColor,
                                        backColor: foreColor
                                    },
                                    values: {
                                        outline: defaultValuesOutline,
                                        fontColorPrimary: foreColor,
                                        backColorPrimary: backColor,
                                        fontColorSecondary: foreColor,
                                        backColorSecondary: backColor
                                    },
                                    total: {
                                        outline: defaultTotalOutline,
                                        fontColor: backColor,
                                        backColor: foreColor
                                    }
                                });
                            }
                        },
                        Condensed: {
                            name: "Condensed",
                            displayName: powerbi.data.createDisplayNameGetter("Visual_Table_StylePreset_Condensed"),
                            evaluate: function(theme) {
                                var backColor = theme.colorPalette.background.value, foreColor = theme.colorPalette.foreground.value, accent = theme.colorPalette.tableAccent.value, gridColor = Color.hexBlend(foreColor, .2, backColor);
                                return wrapFormattingElements({
                                    grid: {
                                        outlineColor: accent,
                                        gridVertical: !0,
                                        gridVerticalColor: gridColor,
                                        gridVerticalWeight: defaultGridlineVerticalWeight,
                                        gridHorizontal: !0,
                                        gridHorizontalColor: gridColor,
                                        gridHorizontalWeight: defaultGridlineHorizontalWeight,
                                        rowPadding: rowPaddingCondensed
                                    },
                                    columnHeaders: {
                                        outline: defaultColumnsOutline,
                                        fontColor: backColor,
                                        backColor: foreColor
                                    },
                                    values: {
                                        outline: defaultValuesOutline,
                                        fontColorPrimary: foreColor,
                                        backColorPrimary: backColor,
                                        fontColorSecondary: foreColor,
                                        backColorSecondary: backColor
                                    },
                                    total: {
                                        outline: defaultTotalOutline,
                                        fontColor: backColor,
                                        backColor: foreColor
                                    }
                                });
                            }
                        }
                    }
                };
            }
            var TablixObjects = visuals.controls.internal.TablixObjects, Color = jsCommon.Color, SQExprBuilder = powerbi.data.SQExprBuilder, valueOrDefault = jsCommon.Utility.valueOrDefault, createSolidFillDefinition = powerbi.FillDefinitionHelpers.createSolidFillDefinition, defaultOutlineWeight = TablixObjects.PropGridOutlineWeight.defaultValue, defaultGridlineHorizontalWeight = TablixObjects.PropGridHorizontalWeight.defaultValue, defaultGridlineVerticalWeight = TablixObjects.PropGridVerticalWeight.defaultValue, defaultColumnsOutline = TablixObjects.PropColumnsOutline.defaultValue, defaultValuesOutline = TablixObjects.PropValuesOutline.defaultValue, defaultTotalOutline = TablixObjects.PropTotalOutline.defaultValue, rowPaddingCondensed = 0, rowPaddingNormal = 3, rowPaddingSparse = 6;
            visuals.tableStylePresets = tableStylePresets;
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
} ]);