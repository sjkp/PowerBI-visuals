/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(116);


/***/ },
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */,
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */,
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */,
/* 69 */,
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */,
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/// <reference path="./_references.ts"/>
	window.jsCommon = window.jsCommon || {};
	window.powerbi = window.powerbi || {};
	window.debug = window.debug || {};
	window.InJs = window.InJs || {};
	window.Microsoft = window.Microsoft || {};
	__webpack_require__(117);
	__webpack_require__(118);
	__webpack_require__(119);
	// Require all files from the `_references.ts`
	__webpack_require__(120);

	

/***/ },
/* 117 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 118 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "images/locationButton.svg";

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	__webpack_require__(121);
	/// <reference path="../VisualsContracts/_references.ts"/>
	/// <reference path="../VisualsCommon/_references.ts"/>
	/// <reference path="../VisualsData/_references.ts"/>
	/// <reference path="../VisualsExtensibility/_references.ts"/>
	/// <reference path="../../../src/Clients/Typedefs/webpack/webpack-env.d.ts"/>
	/// <reference path="../../../src/Clients/Typedefs/common/window.d.ts"/>
	__webpack_require__(122);
	__webpack_require__(123);
	__webpack_require__(124);
	__webpack_require__(125);
	__webpack_require__(126);
	__webpack_require__(127);
	__webpack_require__(128);
	__webpack_require__(129);
	__webpack_require__(130);
	__webpack_require__(131);
	__webpack_require__(132);
	__webpack_require__(133);
	__webpack_require__(134);
	__webpack_require__(135);
	__webpack_require__(136);
	__webpack_require__(137);
	__webpack_require__(138);
	__webpack_require__(139);
	__webpack_require__(140);
	__webpack_require__(141);
	__webpack_require__(142);
	__webpack_require__(143);
	__webpack_require__(144);
	__webpack_require__(145);
	__webpack_require__(146);
	__webpack_require__(147);
	__webpack_require__(148);
	__webpack_require__(149);
	__webpack_require__(150);
	__webpack_require__(151);
	__webpack_require__(152);
	__webpack_require__(153);
	__webpack_require__(154);
	__webpack_require__(155);
	__webpack_require__(156);
	__webpack_require__(157);
	__webpack_require__(158);
	__webpack_require__(159);
	__webpack_require__(160);
	__webpack_require__(161);
	__webpack_require__(162);
	__webpack_require__(163);
	__webpack_require__(164);
	__webpack_require__(165);
	__webpack_require__(166);
	__webpack_require__(167);
	__webpack_require__(168);
	__webpack_require__(169);
	__webpack_require__(170);
	__webpack_require__(171);
	__webpack_require__(172);
	__webpack_require__(173);
	__webpack_require__(174);
	__webpack_require__(175);
	__webpack_require__(176);
	__webpack_require__(177);
	__webpack_require__(178);
	__webpack_require__(179);
	__webpack_require__(180);
	__webpack_require__(181);
	__webpack_require__(182);
	__webpack_require__(183);
	__webpack_require__(184);
	__webpack_require__(185);
	__webpack_require__(186);
	__webpack_require__(187);
	__webpack_require__(188);
	__webpack_require__(189);
	__webpack_require__(190);
	__webpack_require__(191);
	__webpack_require__(192);
	__webpack_require__(193);
	__webpack_require__(194);
	__webpack_require__(195);
	__webpack_require__(196);
	__webpack_require__(197);
	__webpack_require__(198);
	__webpack_require__(199);
	__webpack_require__(200);
	__webpack_require__(201);
	__webpack_require__(202);
	__webpack_require__(203);
	__webpack_require__(204);
	__webpack_require__(205);
	__webpack_require__(206);
	__webpack_require__(207);
	__webpack_require__(208);
	__webpack_require__(209);
	__webpack_require__(210);
	__webpack_require__(211);
	__webpack_require__(212);
	__webpack_require__(213);
	__webpack_require__(214);
	__webpack_require__(215);
	__webpack_require__(216);
	__webpack_require__(217);
	__webpack_require__(218);
	__webpack_require__(219);
	__webpack_require__(220);
	__webpack_require__(221);
	__webpack_require__(222);
	__webpack_require__(223);
	__webpack_require__(224);
	__webpack_require__(225);
	__webpack_require__(226);
	__webpack_require__(227);
	__webpack_require__(228);
	__webpack_require__(229);
	__webpack_require__(230);
	__webpack_require__(231);
	__webpack_require__(232);
	__webpack_require__(233);
	__webpack_require__(234);
	__webpack_require__(235);
	__webpack_require__(236);
	__webpack_require__(237);
	__webpack_require__(238);
	__webpack_require__(239);
	__webpack_require__(240);
	__webpack_require__(241);
	__webpack_require__(242);
	__webpack_require__(243);
	__webpack_require__(244);
	__webpack_require__(245);
	__webpack_require__(246);
	__webpack_require__(247);
	__webpack_require__(248);
	__webpack_require__(249);
	__webpack_require__(250);
	__webpack_require__(251);
	__webpack_require__(252);
	__webpack_require__(253);
	__webpack_require__(254);
	__webpack_require__(255);
	__webpack_require__(256);
	__webpack_require__(257);
	__webpack_require__(258);
	__webpack_require__(259);
	__webpack_require__(260);
	__webpack_require__(261);
	__webpack_require__(262);
	__webpack_require__(263);
	__webpack_require__(264);
	__webpack_require__(265);
	__webpack_require__(266);
	__webpack_require__(267);
	__webpack_require__(268);
	__webpack_require__(269);
	__webpack_require__(270);
	__webpack_require__(271);
	__webpack_require__(272);
	__webpack_require__(273);
	__webpack_require__(274);
	__webpack_require__(275);
	__webpack_require__(276);
	__webpack_require__(277);
	__webpack_require__(278);
	__webpack_require__(279);
	__webpack_require__(280);
	__webpack_require__(281);
	__webpack_require__(282);
	__webpack_require__(283);
	__webpack_require__(284);
	__webpack_require__(285);
	__webpack_require__(286);
	__webpack_require__(287);
	__webpack_require__(288);
	__webpack_require__(289);
	__webpack_require__(290);



/***/ },
/* 121 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	///<reference path="../../Typedefs/d3/d3.d.ts"/>
	///<reference path="../../Typedefs/jquery-visible/jquery-visible.d.ts"/>
	///<reference path="../../Typedefs/jquery/jquery.d.ts"/>
	///<reference path="../../Typedefs/microsoftMaps/Microsoft.Maps.d.ts" />
	///<reference path="../../Typedefs/moment/moment.d.ts"/>
	///<reference path="../../Typedefs/velocity/velocity-animate.d.ts"/>
	///<reference path="../../Typedefs/lodash/lodash.d.ts"/>
	///<reference path="../../Typedefs/quill/quill.d.ts"/>
	///<reference path="../../Typedefs/ie/ie.d.ts"/>
	///<reference path="../../Typedefs/noUiSlider/noUiSlider.d.ts"/>
	///<reference path="../../Typedefs/jquery.scrollbar/jquery.scrollbar.d.ts"/>

	

/***/ },
/* 122 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var Point = (function () {
	            function Point(x, y) {
	                this.x = x || 0;
	                this.y = y || 0;
	            }
	            return Point;
	        }());
	        visuals.Point = Point;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 123 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var Rect = (function () {
	            // Constructor
	            function Rect(left, top, width, height) {
	                this.left = left || 0;
	                this.top = top || 0;
	                this.width = width || 0;
	                this.height = height || 0;
	            }
	            return Rect;
	        }());
	        visuals.Rect = Rect;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 124 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var Font;
	        (function (Font) {
	            var FamilyInfo = (function () {
	                function FamilyInfo(families) {
	                    this.families = families;
	                }
	                ;
	                Object.defineProperty(FamilyInfo.prototype, "family", {
	                    /**
	                     * Gets the first font "wf_" font family since it will always be loaded.
	                     */
	                    get: function () {
	                        return this.getFamily();
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                /**
	                * Gets the first font family that matches regex (if provided).
	                * Default regex looks for "wf_" fonts which are always loaded.
	                */
	                FamilyInfo.prototype.getFamily = function (regex) {
	                    if (regex === void 0) { regex = /^wf_/; }
	                    if (!this.families) {
	                        return null;
	                    }
	                    return regex ? _.find(this.families, function (fontFamily) { return regex.test(fontFamily); }) : this.families[0];
	                };
	                Object.defineProperty(FamilyInfo.prototype, "css", {
	                    /**
	                     * Gets the CSS string for the "font-family" CSS attribute.
	                     */
	                    get: function () {
	                        return this.getCSS();
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                /**
	                 * Gets the CSS string for the "font-family" CSS attribute.
	                 */
	                FamilyInfo.prototype.getCSS = function () {
	                    return this.families ? this.families.map((function (font) { return font.indexOf(' ') > 0 ? "'" + font + "'" : font; })).join(', ') : null;
	                };
	                return FamilyInfo;
	            }());
	            Font.FamilyInfo = FamilyInfo;
	            // These should map to the fonts in src\clients\StyleLibrary\less\fonts.less
	            Font.Family = {
	                light: new FamilyInfo(['Segoe UI Light', 'wf_segoe-ui_light', 'helvetica', 'arial', 'sans-serif']),
	                semilight: new FamilyInfo(['Segoe UI Semilight', 'wf_segoe-ui_semilight', 'helvetica', 'arial', 'sans-serif']),
	                regular: new FamilyInfo(['Segoe UI', 'wf_segoe-ui_normal', 'helvetica', 'arial', 'sans-serif']),
	                semibold: new FamilyInfo(['Segoe UI Semibold', 'wf_segoe-ui_semibold', 'helvetica', 'arial', 'sans-serif']),
	                bold: new FamilyInfo(['Segoe UI Bold', 'wf_segoe-ui_bold', 'helvetica', 'arial', 'sans-serif']),
	                lightSecondary: new FamilyInfo(['wf_standard-font_light', 'helvetica', 'arial', 'sans-serif']),
	                regularSecondary: new FamilyInfo(['wf_standard-font', 'helvetica', 'arial', 'sans-serif']),
	                boldSecondary: new FamilyInfo(['wf_standard-font_bold', 'helvetica', 'arial', 'sans-serif'])
	            };
	        })(Font = visuals.Font || (visuals.Font = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 125 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="./_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
	        var PixelConverter = jsCommon.PixelConverter;
	        (function (LegendIcon) {
	            LegendIcon[LegendIcon["Box"] = 0] = "Box";
	            LegendIcon[LegendIcon["Circle"] = 1] = "Circle";
	            LegendIcon[LegendIcon["Line"] = 2] = "Line";
	        })(visuals.LegendIcon || (visuals.LegendIcon = {}));
	        var LegendIcon = visuals.LegendIcon;
	        (function (LegendPosition) {
	            LegendPosition[LegendPosition["Top"] = 0] = "Top";
	            LegendPosition[LegendPosition["Bottom"] = 1] = "Bottom";
	            LegendPosition[LegendPosition["Right"] = 2] = "Right";
	            LegendPosition[LegendPosition["Left"] = 3] = "Left";
	            LegendPosition[LegendPosition["None"] = 4] = "None";
	            LegendPosition[LegendPosition["TopCenter"] = 5] = "TopCenter";
	            LegendPosition[LegendPosition["BottomCenter"] = 6] = "BottomCenter";
	            LegendPosition[LegendPosition["RightCenter"] = 7] = "RightCenter";
	            LegendPosition[LegendPosition["LeftCenter"] = 8] = "LeftCenter";
	        })(visuals.LegendPosition || (visuals.LegendPosition = {}));
	        var LegendPosition = visuals.LegendPosition;
	        visuals.legendProps = {
	            show: 'show',
	            position: 'position',
	            titleText: 'titleText',
	            showTitle: 'showTitle',
	            labelColor: 'labelColor',
	            fontSize: 'fontSize',
	        };
	        function createLegend(legendParentElement, interactive, interactivityService, isScrollable, legendPosition) {
	            if (isScrollable === void 0) { isScrollable = false; }
	            if (legendPosition === void 0) { legendPosition = LegendPosition.Top; }
	            if (interactive)
	                return new CartesianChartInteractiveLegend(legendParentElement);
	            else
	                return new SVGLegend(legendParentElement, legendPosition, interactivityService, isScrollable);
	        }
	        visuals.createLegend = createLegend;
	        var Legend;
	        (function (Legend) {
	            function isLeft(orientation) {
	                switch (orientation) {
	                    case LegendPosition.Left:
	                    case LegendPosition.LeftCenter:
	                        return true;
	                    default:
	                        return false;
	                }
	            }
	            Legend.isLeft = isLeft;
	            function isTop(orientation) {
	                switch (orientation) {
	                    case LegendPosition.Top:
	                    case LegendPosition.TopCenter:
	                        return true;
	                    default:
	                        return false;
	                }
	            }
	            Legend.isTop = isTop;
	            function positionChartArea(chartArea, legend) {
	                var legendMargins = legend.getMargins();
	                var legendOrientation = legend.getOrientation();
	                chartArea.style({
	                    'margin-left': Legend.isLeft(legendOrientation) ? legendMargins.width + 'px' : null,
	                    'margin-top': Legend.isTop(legendOrientation) ? legendMargins.height + 'px' : null,
	                });
	            }
	            Legend.positionChartArea = positionChartArea;
	        })(Legend = visuals.Legend || (visuals.Legend = {}));
	        var SVGLegend = (function () {
	            function SVGLegend(element, legendPosition, interactivityService, isScrollable) {
	                this.legendDataStartIndex = 0;
	                this.arrowPosWindow = 1;
	                this.lastCalculatedWidth = 0;
	                this.visibleLegendWidth = 0;
	                this.visibleLegendHeight = 0;
	                this.legendFontSizeMarginDifference = 0;
	                this.legendFontSizeMarginValue = 0;
	                this.svg = d3.select(element.get(0)).append('svg').style('position', 'absolute');
	                this.svg.style('display', 'inherit');
	                this.svg.classed('legend', true);
	                if (interactivityService)
	                    this.clearCatcher = visuals.appendClearCatcher(this.svg);
	                this.group = this.svg.append('g').attr('id', 'legendGroup');
	                this.interactivityService = interactivityService;
	                this.isScrollable = isScrollable;
	                this.element = element;
	                this.changeOrientation(legendPosition);
	                this.parentViewport = { height: 0, width: 0 };
	                this.calculateViewport();
	                this.updateLayout();
	            }
	            SVGLegend.prototype.updateLayout = function () {
	                var legendViewport = this.viewport;
	                var orientation = this.orientation;
	                this.svg.attr({
	                    'height': legendViewport.height || (orientation === LegendPosition.None ? 0 : this.parentViewport.height),
	                    'width': legendViewport.width || (orientation === LegendPosition.None ? 0 : this.parentViewport.width)
	                });
	                var isRight = orientation === LegendPosition.Right || orientation === LegendPosition.RightCenter;
	                var isBottom = orientation === LegendPosition.Bottom || orientation === LegendPosition.BottomCenter;
	                this.svg.style({
	                    'margin-left': isRight ? (this.parentViewport.width - legendViewport.width) + 'px' : null,
	                    'margin-top': isBottom ? (this.parentViewport.height - legendViewport.height) + 'px' : null,
	                });
	            };
	            SVGLegend.prototype.calculateViewport = function () {
	                switch (this.orientation) {
	                    case LegendPosition.Top:
	                    case LegendPosition.Bottom:
	                    case LegendPosition.TopCenter:
	                    case LegendPosition.BottomCenter:
	                        var pixelHeight = PixelConverter.fromPointToPixel(this.data && this.data.fontSize ? this.data.fontSize : SVGLegend.DefaultFontSizeInPt);
	                        var fontHeightSize = SVGLegend.TopLegendHeight + (pixelHeight - SVGLegend.DefaultFontSizeInPt);
	                        this.viewport = { height: fontHeightSize, width: 0 };
	                        return;
	                    case LegendPosition.Right:
	                    case LegendPosition.Left:
	                    case LegendPosition.RightCenter:
	                    case LegendPosition.LeftCenter:
	                        var width = this.lastCalculatedWidth ? this.lastCalculatedWidth : this.parentViewport.width * SVGLegend.LegendMaxWidthFactor;
	                        this.viewport = { height: 0, width: width };
	                        return;
	                    case LegendPosition.None:
	                        this.viewport = { height: 0, width: 0 };
	                }
	            };
	            SVGLegend.prototype.getMargins = function () {
	                return this.viewport;
	            };
	            SVGLegend.prototype.isVisible = function () {
	                return this.orientation !== LegendPosition.None;
	            };
	            SVGLegend.prototype.changeOrientation = function (orientation) {
	                if (orientation) {
	                    this.orientation = orientation;
	                }
	                else {
	                    this.orientation = LegendPosition.Top;
	                }
	                this.svg.attr('orientation', orientation);
	            };
	            SVGLegend.prototype.getOrientation = function () {
	                return this.orientation;
	            };
	            SVGLegend.prototype.drawLegend = function (data, viewport) {
	                // clone because we modify legend item label with ellipsis if it is truncated
	                var clonedData = powerbi.Prototype.inherit(data);
	                var newDataPoints = [];
	                for (var _i = 0, _a = data.dataPoints; _i < _a.length; _i++) {
	                    var dp = _a[_i];
	                    newDataPoints.push(powerbi.Prototype.inherit(dp));
	                }
	                clonedData.dataPoints = newDataPoints;
	                this.setTooltipToLegendItems(clonedData);
	                this.drawLegendInternal(clonedData, viewport, true /* perform auto width */);
	            };
	            SVGLegend.prototype.drawLegendInternal = function (data, viewport, autoWidth) {
	                this.parentViewport = viewport;
	                this.data = data;
	                if (this.interactivityService)
	                    this.interactivityService.applySelectionStateToData(data.dataPoints);
	                if (data.dataPoints.length === 0) {
	                    this.changeOrientation(LegendPosition.None);
	                }
	                if (this.getOrientation() === LegendPosition.None) {
	                    data.dataPoints = [];
	                }
	                // Adding back the workaround for Legend Left/Right position for Map
	                var mapControl = this.element.children(".mapControl");
	                if (mapControl.length > 0 && !this.isTopOrBottom(this.orientation)) {
	                    mapControl.css("display", "inline-block");
	                }
	                this.calculateViewport();
	                var layout = this.calculateLayout(data, autoWidth);
	                var titleLayout = layout.title;
	                var titleData = titleLayout ? [titleLayout] : [];
	                var hasSelection = this.interactivityService && powerbi.visuals.dataHasSelection(data.dataPoints);
	                var group = this.group;
	                //transform the wrapping group if position is centered
	                if (this.isCentered(this.orientation)) {
	                    var centerOffset = 0;
	                    if (this.isTopOrBottom(this.orientation)) {
	                        centerOffset = Math.max(0, (this.parentViewport.width - this.visibleLegendWidth) / 2);
	                        group.attr('transform', visuals.SVGUtil.translate(centerOffset, 0));
	                    }
	                    else {
	                        centerOffset = Math.max((this.parentViewport.height - this.visibleLegendHeight) / 2);
	                        group.attr('transform', visuals.SVGUtil.translate(0, centerOffset));
	                    }
	                }
	                else {
	                    group.attr('transform', null);
	                }
	                var legendTitle = group
	                    .selectAll(SVGLegend.LegendTitle.selector)
	                    .data(titleData);
	                legendTitle.enter()
	                    .append('text')
	                    .classed(SVGLegend.LegendTitle.class, true);
	                legendTitle
	                    .style({
	                    'fill': data.labelColor,
	                    'font-size': PixelConverter.fromPoint(data.fontSize),
	                    'font-family': SVGLegend.DefaultTitleFontFamily
	                })
	                    .text(function (d) { return d.text; })
	                    .attr({
	                    'x': function (d) { return d.x; },
	                    'y': function (d) { return d.y; }
	                })
	                    .append('title').text(data.title);
	                legendTitle.exit().remove();
	                var virtualizedDataPoints = data.dataPoints.slice(this.legendDataStartIndex, this.legendDataStartIndex + layout.numberOfItems);
	                var iconRadius = powerbi.TextMeasurementService.estimateSvgTextHeight(SVGLegend.getTextProperties(false, '', this.data.fontSize)) / SVGLegend.LegendIconRadiusFactor;
	                iconRadius = (this.legendFontSizeMarginValue > SVGLegend.DefaultTextMargin) && iconRadius > SVGLegend.LegendIconRadius
	                    ? iconRadius :
	                    SVGLegend.LegendIconRadius;
	                var legendItems = group
	                    .selectAll(SVGLegend.LegendItem.selector)
	                    .data(virtualizedDataPoints, function (d) { return d.identity.getKey() + (d.layerNumber != null ? d.layerNumber : ''); });
	                var itemsEnter = legendItems.enter()
	                    .append('g')
	                    .classed(SVGLegend.LegendItem.class, true);
	                itemsEnter
	                    .append('circle')
	                    .classed(SVGLegend.LegendIcon.class, true);
	                itemsEnter
	                    .append('text')
	                    .classed(SVGLegend.LegendText.class, true);
	                itemsEnter
	                    .append('title')
	                    .text(function (d) { return d.tooltip; });
	                legendItems
	                    .select(SVGLegend.LegendIcon.selector)
	                    .attr({
	                    'cx': function (d, i) { return d.glyphPosition.x; },
	                    'cy': function (d) { return d.glyphPosition.y; },
	                    'r': iconRadius,
	                })
	                    .style({
	                    'fill': function (d) {
	                        if (hasSelection && !d.selected)
	                            return visuals.LegendBehavior.dimmedLegendColor;
	                        else
	                            return d.color;
	                    }
	                });
	                legendItems
	                    .select('title')
	                    .text(function (d) { return d.tooltip; });
	                legendItems
	                    .select(SVGLegend.LegendText.selector)
	                    .attr({
	                    'x': function (d) { return d.textPosition.x; },
	                    'y': function (d) { return d.textPosition.y; },
	                })
	                    .text(function (d) { return d.label; })
	                    .style({
	                    'fill': data.labelColor,
	                    'font-size': PixelConverter.fromPoint(data.fontSize)
	                });
	                if (this.interactivityService) {
	                    var iconsSelection = legendItems.select(SVGLegend.LegendIcon.selector);
	                    var behaviorOptions = {
	                        legendItems: legendItems,
	                        legendIcons: iconsSelection,
	                        clearCatcher: this.clearCatcher,
	                    };
	                    this.interactivityService.bind(data.dataPoints, new visuals.LegendBehavior(), behaviorOptions, { isLegend: true });
	                }
	                legendItems.exit().remove();
	                this.drawNavigationArrows(layout.navigationArrows);
	                this.updateLayout();
	            };
	            SVGLegend.prototype.normalizePosition = function (points) {
	                if (this.legendDataStartIndex >= points.length) {
	                    this.legendDataStartIndex = points.length - 1;
	                }
	                if (this.legendDataStartIndex < 0) {
	                    this.legendDataStartIndex = 0;
	                }
	            };
	            SVGLegend.prototype.calculateTitleLayout = function (title) {
	                var width = 0;
	                var hasTitle = !_.isEmpty(title);
	                if (hasTitle) {
	                    var isHorizontal = this.isTopOrBottom(this.orientation);
	                    var maxMeasureLength = void 0;
	                    if (isHorizontal) {
	                        var fontSizeMargin = this.legendFontSizeMarginValue > SVGLegend.DefaultTextMargin ? SVGLegend.TextAndIconPadding + this.legendFontSizeMarginDifference : SVGLegend.TextAndIconPadding;
	                        var fixedHorizontalIconShift = SVGLegend.TextAndIconPadding + SVGLegend.LegendIconRadius;
	                        var fixedHorizontalTextShift = SVGLegend.LegendIconRadius + fontSizeMargin + fixedHorizontalIconShift;
	                        // TODO This can be negative for narrow viewports. May need to rework this logic.
	                        maxMeasureLength = this.parentViewport.width * SVGLegend.LegendMaxWidthFactor - fixedHorizontalTextShift - SVGLegend.LegendEdgeMariginWidth;
	                    }
	                    else {
	                        maxMeasureLength = this.legendFontSizeMarginValue < SVGLegend.DefaultTextMargin ? SVGLegend.MaxTitleLength :
	                            SVGLegend.MaxTitleLength + (SVGLegend.DefaultMaxLegendFactor * this.legendFontSizeMarginDifference);
	                    }
	                    var textProperties = SVGLegend.getTextProperties(true, title, this.data.fontSize);
	                    var text = title;
	                    width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
	                    if (width > maxMeasureLength) {
	                        text = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, maxMeasureLength);
	                        textProperties.text = text;
	                        // Remeasure the text since its measurement may be different than the max (ex. when the max is negative, the text will be ellipsis, and not have a negative width)
	                        width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
	                    }
	                    ;
	                    if (isHorizontal)
	                        width += SVGLegend.TitlePadding;
	                    else
	                        text = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, this.viewport.width);
	                    return {
	                        x: 0,
	                        y: 0,
	                        text: text,
	                        width: width,
	                        height: powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties)
	                    };
	                }
	                return null;
	            };
	            /** Performs layout offline for optimal perfomance */
	            SVGLegend.prototype.calculateLayout = function (data, autoWidth) {
	                var dataPoints = data.dataPoints;
	                if (data.dataPoints.length === 0) {
	                    return {
	                        numberOfItems: 0,
	                        title: null,
	                        navigationArrows: []
	                    };
	                }
	                this.legendFontSizeMarginValue = PixelConverter.fromPointToPixel(this.data && this.data.fontSize !== undefined ? this.data.fontSize : SVGLegend.DefaultFontSizeInPt);
	                this.legendFontSizeMarginDifference = (this.legendFontSizeMarginValue - SVGLegend.DefaultTextMargin);
	                this.normalizePosition(dataPoints);
	                if (this.legendDataStartIndex < dataPoints.length) {
	                    dataPoints = dataPoints.slice(this.legendDataStartIndex);
	                }
	                var title = this.calculateTitleLayout(data.title);
	                var navArrows;
	                var numberOfItems;
	                if (this.isTopOrBottom(this.orientation)) {
	                    navArrows = this.isScrollable ? this.calculateHorizontalNavigationArrowsLayout(title) : [];
	                    numberOfItems = this.calculateHorizontalLayout(dataPoints, title, navArrows);
	                }
	                else {
	                    navArrows = this.isScrollable ? this.calculateVerticalNavigationArrowsLayout(title) : [];
	                    numberOfItems = this.calculateVerticalLayout(dataPoints, title, navArrows, autoWidth);
	                }
	                return {
	                    numberOfItems: numberOfItems,
	                    title: title,
	                    navigationArrows: navArrows
	                };
	            };
	            SVGLegend.prototype.updateNavigationArrowLayout = function (navigationArrows, remainingDataLength, visibleDataLength) {
	                if (this.legendDataStartIndex === 0) {
	                    navigationArrows.shift();
	                }
	                var lastWindow = this.arrowPosWindow;
	                this.arrowPosWindow = visibleDataLength;
	                if (navigationArrows && navigationArrows.length > 0 && this.arrowPosWindow === remainingDataLength) {
	                    this.arrowPosWindow = lastWindow;
	                    navigationArrows.length = navigationArrows.length - 1;
	                }
	            };
	            SVGLegend.prototype.calculateHorizontalNavigationArrowsLayout = function (title) {
	                var height = SVGLegend.LegendArrowHeight;
	                var width = SVGLegend.LegendArrowWidth;
	                var translateY = (this.viewport.height / 2) - (height / 2);
	                var data = [];
	                var rightShift = title ? title.x + title.width : 0;
	                var arrowLeft = visuals.SVGUtil.createArrow(width, height, 180 /*angle*/);
	                var arrowRight = visuals.SVGUtil.createArrow(width, height, 0 /*angle*/);
	                data.push({
	                    x: rightShift,
	                    y: translateY,
	                    path: arrowLeft.path,
	                    rotateTransform: arrowLeft.transform,
	                    type: 1 /* Decrease */
	                });
	                data.push({
	                    x: this.parentViewport.width - width,
	                    y: translateY,
	                    path: arrowRight.path,
	                    rotateTransform: arrowRight.transform,
	                    type: 0 /* Increase */
	                });
	                return data;
	            };
	            SVGLegend.prototype.calculateVerticalNavigationArrowsLayout = function (title) {
	                var height = SVGLegend.LegendArrowHeight;
	                var width = SVGLegend.LegendArrowWidth;
	                var verticalCenter = this.viewport.height / 2;
	                var data = [];
	                var rightShift = verticalCenter + height / 2;
	                var arrowTop = visuals.SVGUtil.createArrow(width, height, 270 /*angle*/);
	                var arrowBottom = visuals.SVGUtil.createArrow(width, height, 90 /*angle*/);
	                var titleHeight = title ? title.height : 0;
	                data.push({
	                    x: rightShift,
	                    y: width + titleHeight,
	                    path: arrowTop.path,
	                    rotateTransform: arrowTop.transform,
	                    type: 1 /* Decrease */
	                });
	                data.push({
	                    x: rightShift,
	                    y: this.parentViewport.height - height,
	                    path: arrowBottom.path,
	                    rotateTransform: arrowBottom.transform,
	                    type: 0 /* Increase */
	                });
	                return data;
	            };
	            /**
	             * Calculates the widths for each horizontal legend item.
	             */
	            SVGLegend.calculateHorizontalLegendItemsWidths = function (dataPoints, availableWidth, iconPadding, fontSize) {
	                var dataPointsLength = dataPoints.length;
	                // Set the maximum amount of space available to each item. They can use less, but can't go over this number.
	                var maxItemWidth = dataPointsLength > 0 ? availableWidth / dataPointsLength | 0 : 0;
	                var maxItemTextWidth = maxItemWidth - iconPadding;
	                // Makes sure the amount of space available to each item is at least SVGLegend.MaxTextLength wide.
	                // If you had many items and/or a narrow amount of available width, the availableTextWidthPerItem would be small, essentially making everything ellipsis.
	                // This prevents that from happening by giving each item at least SVGLegend.MaxTextLength of space.
	                if (maxItemTextWidth < SVGLegend.MaxTextLength) {
	                    maxItemTextWidth = SVGLegend.MaxTextLength;
	                    maxItemWidth = maxItemTextWidth + iconPadding;
	                }
	                // Make sure the availableWidthPerItem is less than the availableWidth. This lets the long text properly add ellipsis when we're displaying one item at a time.
	                if (maxItemWidth > availableWidth) {
	                    maxItemWidth = availableWidth;
	                    maxItemTextWidth = maxItemWidth - iconPadding;
	                }
	                var occupiedWidth = 0;
	                var legendItems = [];
	                // Add legend items until we can't fit any more (the last one doesn't fit) or we've added all of them
	                for (var _i = 0, dataPoints_1 = dataPoints; _i < dataPoints_1.length; _i++) {
	                    var dataPoint = dataPoints_1[_i];
	                    var textProperties = SVGLegend.getTextProperties(false, dataPoint.label, fontSize);
	                    var itemTextWidth = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
	                    var desiredWidth = itemTextWidth + iconPadding;
	                    var overMaxWidth = desiredWidth > maxItemWidth;
	                    var actualWidth = overMaxWidth ? maxItemWidth : desiredWidth;
	                    occupiedWidth += actualWidth;
	                    if (occupiedWidth >= availableWidth) {
	                        // Always add at least 1 element
	                        if (legendItems.length === 0) {
	                            legendItems.push({
	                                dataPoint: dataPoint,
	                                textProperties: textProperties,
	                                desiredWidth: desiredWidth,
	                                desiredOverMaxWidth: true,
	                                width: desiredWidth
	                            });
	                            // Set the width to the amount of space we actually have
	                            occupiedWidth = availableWidth;
	                        }
	                        else {
	                            // Subtract the width from what was just added since it won't fit
	                            occupiedWidth -= actualWidth;
	                        }
	                        break;
	                    }
	                    legendItems.push({
	                        dataPoint: dataPoint,
	                        textProperties: textProperties,
	                        desiredWidth: desiredWidth,
	                        desiredOverMaxWidth: overMaxWidth,
	                        width: desiredWidth
	                    });
	                }
	                // If there are items at max width, evenly redistribute the extra space to them
	                var itemsOverMax = _.filter(legendItems, function (li) { return li.desiredOverMaxWidth; });
	                var numItemsOverMax = itemsOverMax.length;
	                if (numItemsOverMax > 0) {
	                    var extraWidth = availableWidth - occupiedWidth;
	                    for (var _a = 0, itemsOverMax_1 = itemsOverMax; _a < itemsOverMax_1.length; _a++) {
	                        var item = itemsOverMax_1[_a];
	                        // Divvy up the extra space and add it to the max
	                        // We need to do this calculation in every loop since the remainingWidth may not be changed by the same amount every time
	                        var extraWidthPerItem = extraWidth / numItemsOverMax;
	                        var newMaxItemWidth = maxItemWidth + extraWidthPerItem;
	                        var usedExtraWidth = void 0;
	                        if (item.desiredWidth <= newMaxItemWidth) {
	                            // If the item doesn't need all the extra space, it's not at max anymore
	                            item.desiredOverMaxWidth = false;
	                            usedExtraWidth = item.desiredWidth - maxItemWidth;
	                        }
	                        else {
	                            // Otherwise the item is taking up all the extra space so update the actual width to indicate that
	                            item.width = newMaxItemWidth;
	                            usedExtraWidth = newMaxItemWidth - maxItemWidth;
	                        }
	                        extraWidth -= usedExtraWidth;
	                        numItemsOverMax--;
	                    }
	                }
	                return legendItems;
	            };
	            SVGLegend.prototype.calculateHorizontalLayout = function (dataPoints, title, navigationArrows) {
	                debug.assertValue(navigationArrows, 'navigationArrows');
	                // calculate the text shift
	                var HorizontalTextShift = 4 + SVGLegend.LegendIconRadius;
	                // check if we need more space for the margin, or use the default text padding
	                var fontSizeBiggerThanDefault = this.legendFontSizeMarginDifference > 0;
	                var fontSizeMargin = fontSizeBiggerThanDefault ? SVGLegend.TextAndIconPadding + this.legendFontSizeMarginDifference : SVGLegend.TextAndIconPadding;
	                var fixedTextShift = (fontSizeMargin / (SVGLegend.LegendIconRadiusFactor / 2)) + HorizontalTextShift;
	                var occupiedWidth = 0;
	                // calculate the size of the space for both sides of the radius
	                var iconTotalItemPadding = SVGLegend.LegendIconRadius * 2 + fontSizeMargin * 1.5;
	                var numberOfItems = dataPoints.length;
	                // get the Y coordinate which is the middle of the container + the middle of the text height - the delta of the text 
	                var defaultTextProperties = SVGLegend.getTextProperties(false, '', this.data.fontSize);
	                var verticalCenter = this.viewport.height / 2;
	                var textYCoordinate = verticalCenter + powerbi.TextMeasurementService.estimateSvgTextHeight(defaultTextProperties) / 2
	                    - powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(defaultTextProperties);
	                if (title) {
	                    occupiedWidth += title.width;
	                    // get the Y coordinate which is the middle of the container + the middle of the text height - the delta of the text 
	                    title.y = verticalCenter + title.height / 2 - powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(SVGLegend.getTextProperties(true, title.text, this.data.fontSize));
	                }
	                // if an arrow should be added, we add space for it
	                if (this.legendDataStartIndex > 0) {
	                    occupiedWidth += SVGLegend.LegendArrowOffset;
	                }
	                // Calculate the width for each of the legend items
	                var dataPointsLength = dataPoints.length;
	                var availableWidth = this.parentViewport.width - occupiedWidth;
	                var legendItems = SVGLegend.calculateHorizontalLegendItemsWidths(dataPoints, availableWidth, iconTotalItemPadding, this.data.fontSize);
	                numberOfItems = legendItems.length;
	                // If we can't show all the legend items, subtract the "next" arrow space from the available space and re-run the width calculations 
	                if (numberOfItems !== dataPointsLength) {
	                    availableWidth -= SVGLegend.LegendArrowOffset;
	                    legendItems = SVGLegend.calculateHorizontalLegendItemsWidths(dataPoints, availableWidth, iconTotalItemPadding, this.data.fontSize);
	                    numberOfItems = legendItems.length;
	                }
	                for (var _i = 0, legendItems_1 = legendItems; _i < legendItems_1.length; _i++) {
	                    var legendItem = legendItems_1[_i];
	                    var dataPoint = legendItem.dataPoint;
	                    dataPoint.glyphPosition = {
	                        // the space taken so far + the radius + the margin / radiusFactor to prevent huge spaces
	                        x: occupiedWidth + SVGLegend.LegendIconRadius + (this.legendFontSizeMarginDifference / SVGLegend.LegendIconRadiusFactor),
	                        // The middle of the container but a bit lower due to text not being in the middle (qP for example making middle between q and P)
	                        y: (this.viewport.height * SVGLegend.LegendIconYRatio),
	                    };
	                    dataPoint.textPosition = {
	                        x: occupiedWidth + fixedTextShift,
	                        y: textYCoordinate,
	                    };
	                    // If we're over the max width, process it so it fits
	                    if (legendItem.desiredOverMaxWidth) {
	                        var textWidth = legendItem.width - iconTotalItemPadding;
	                        var text = powerbi.TextMeasurementService.getTailoredTextOrDefault(legendItem.textProperties, textWidth);
	                        dataPoint.label = text;
	                    }
	                    occupiedWidth += legendItem.width;
	                }
	                this.visibleLegendWidth = occupiedWidth;
	                this.updateNavigationArrowLayout(navigationArrows, dataPointsLength, numberOfItems);
	                return numberOfItems;
	            };
	            SVGLegend.prototype.calculateVerticalLayout = function (dataPoints, title, navigationArrows, autoWidth) {
	                var _this = this;
	                // check if we need more space for the margin, or use the default text padding
	                var fontSizeBiggerThenDefault = this.legendFontSizeMarginDifference > 0;
	                var fontFactor = fontSizeBiggerThenDefault ? this.legendFontSizeMarginDifference : 0;
	                // calculate the size needed after font size change
	                var verticalLegendHeight = 20 + fontFactor;
	                var spaceNeededByTitle = 15 + fontFactor;
	                var extraShiftForTextAlignmentToIcon = 4 + fontFactor;
	                var totalSpaceOccupiedThusFar = verticalLegendHeight;
	                // the default space for text and icon radius + the margin after the font size change
	                var fixedHorizontalIconShift = SVGLegend.TextAndIconPadding + SVGLegend.LegendIconRadius + (this.legendFontSizeMarginDifference / SVGLegend.LegendIconRadiusFactor);
	                var fixedHorizontalTextShift = fixedHorizontalIconShift * 2;
	                // check how much space is needed
	                var maxHorizontalSpaceAvaliable = autoWidth
	                    ? this.parentViewport.width * SVGLegend.LegendMaxWidthFactor
	                        - fixedHorizontalTextShift - SVGLegend.LegendEdgeMariginWidth
	                    : this.lastCalculatedWidth
	                        - fixedHorizontalTextShift - SVGLegend.LegendEdgeMariginWidth;
	                var numberOfItems = dataPoints.length;
	                var maxHorizontalSpaceUsed = 0;
	                var parentHeight = this.parentViewport.height;
	                if (title) {
	                    totalSpaceOccupiedThusFar += spaceNeededByTitle;
	                    title.x = SVGLegend.TextAndIconPadding;
	                    title.y = spaceNeededByTitle;
	                    maxHorizontalSpaceUsed = title.width || 0;
	                }
	                // if an arrow should be added, we add space for it
	                if (this.legendDataStartIndex > 0)
	                    totalSpaceOccupiedThusFar += SVGLegend.LegendArrowOffset;
	                var dataPointsLength = dataPoints.length;
	                for (var i = 0; i < dataPointsLength; i++) {
	                    var dp = dataPoints[i];
	                    var textProperties = SVGLegend.getTextProperties(false, dp.label, this.data.fontSize);
	                    dp.glyphPosition = {
	                        x: fixedHorizontalIconShift,
	                        y: (totalSpaceOccupiedThusFar + extraShiftForTextAlignmentToIcon) - powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(textProperties)
	                    };
	                    dp.textPosition = {
	                        x: fixedHorizontalTextShift,
	                        y: totalSpaceOccupiedThusFar + extraShiftForTextAlignmentToIcon
	                    };
	                    // TODO: [PERF] Get rid of this extra measurement, and modify
	                    // getTailoredTextToReturnWidth + Text
	                    var width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
	                    if (width > maxHorizontalSpaceUsed) {
	                        maxHorizontalSpaceUsed = width;
	                    }
	                    if (width > maxHorizontalSpaceAvaliable) {
	                        var text = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, maxHorizontalSpaceAvaliable);
	                        dp.label = text;
	                    }
	                    totalSpaceOccupiedThusFar += verticalLegendHeight;
	                    if (totalSpaceOccupiedThusFar > parentHeight) {
	                        numberOfItems = i;
	                        break;
	                    }
	                }
	                if (autoWidth) {
	                    if (maxHorizontalSpaceUsed < maxHorizontalSpaceAvaliable) {
	                        this.lastCalculatedWidth = this.viewport.width = Math.ceil(maxHorizontalSpaceUsed + fixedHorizontalTextShift + SVGLegend.LegendEdgeMariginWidth);
	                    }
	                    else {
	                        this.lastCalculatedWidth = this.viewport.width = Math.ceil(this.parentViewport.width * SVGLegend.LegendMaxWidthFactor);
	                    }
	                }
	                else {
	                    this.viewport.width = this.lastCalculatedWidth;
	                }
	                this.visibleLegendHeight = totalSpaceOccupiedThusFar;
	                navigationArrows.forEach(function (d) { return d.x = _this.lastCalculatedWidth / 2; });
	                this.updateNavigationArrowLayout(navigationArrows, dataPointsLength, numberOfItems);
	                return numberOfItems;
	            };
	            SVGLegend.prototype.drawNavigationArrows = function (layout) {
	                var _this = this;
	                var arrows = this.group.selectAll(SVGLegend.NavigationArrow.selector)
	                    .data(layout);
	                arrows
	                    .enter()
	                    .append('g')
	                    .on('click', function (d) {
	                    var pos = _this.legendDataStartIndex;
	                    _this.legendDataStartIndex = d.type === 0 /* Increase */
	                        ? pos + _this.arrowPosWindow : pos - _this.arrowPosWindow;
	                    _this.drawLegendInternal(_this.data, _this.parentViewport, false);
	                })
	                    .classed(SVGLegend.NavigationArrow.class, true)
	                    .append('path');
	                arrows
	                    .attr('transform', function (d) { return visuals.SVGUtil.translate(d.x, d.y); })
	                    .select('path')
	                    .attr({
	                    'd': function (d) { return d.path; },
	                    'transform': function (d) { return d.rotateTransform; }
	                });
	                arrows.exit().remove();
	            };
	            SVGLegend.prototype.isTopOrBottom = function (orientation) {
	                switch (orientation) {
	                    case LegendPosition.Top:
	                    case LegendPosition.Bottom:
	                    case LegendPosition.BottomCenter:
	                    case LegendPosition.TopCenter:
	                        return true;
	                    default:
	                        return false;
	                }
	            };
	            SVGLegend.prototype.isCentered = function (orientation) {
	                switch (orientation) {
	                    case LegendPosition.BottomCenter:
	                    case LegendPosition.LeftCenter:
	                    case LegendPosition.RightCenter:
	                    case LegendPosition.TopCenter:
	                        return true;
	                    default:
	                        return false;
	                }
	            };
	            SVGLegend.prototype.reset = function () {
	                // Intentionally left blank. 
	            };
	            SVGLegend.getTextProperties = function (isTitle, text, fontSize) {
	                return {
	                    text: text,
	                    fontFamily: isTitle ? SVGLegend.DefaultTitleFontFamily : SVGLegend.DefaultFontFamily,
	                    fontSize: PixelConverter.fromPoint(fontSize || SVGLegend.DefaultFontSizeInPt)
	                };
	            };
	            SVGLegend.prototype.setTooltipToLegendItems = function (data) {
	                //we save the values to tooltip before cut
	                for (var _i = 0, _a = data.dataPoints; _i < _a.length; _i++) {
	                    var dataPoint = _a[_i];
	                    dataPoint.tooltip = dataPoint.label;
	                }
	            };
	            SVGLegend.DefaultFontSizeInPt = 8;
	            SVGLegend.LegendIconRadius = 5;
	            SVGLegend.LegendIconRadiusFactor = 5;
	            SVGLegend.MaxTextLength = 60;
	            SVGLegend.MaxTitleLength = 80;
	            SVGLegend.TextAndIconPadding = 5;
	            SVGLegend.TitlePadding = 15;
	            SVGLegend.LegendEdgeMariginWidth = 10;
	            SVGLegend.LegendMaxWidthFactor = 0.3;
	            SVGLegend.TopLegendHeight = 24;
	            SVGLegend.DefaultTextMargin = PixelConverter.fromPointToPixel(SVGLegend.DefaultFontSizeInPt);
	            SVGLegend.DefaultMaxLegendFactor = SVGLegend.MaxTitleLength / SVGLegend.DefaultTextMargin;
	            SVGLegend.LegendIconYRatio = 0.52;
	            // Navigation Arrow constants
	            SVGLegend.LegendArrowOffset = 10;
	            SVGLegend.LegendArrowHeight = 15;
	            SVGLegend.LegendArrowWidth = 7.5;
	            SVGLegend.DefaultFontFamily = visuals.Font.Family.regular.css;
	            SVGLegend.DefaultTitleFontFamily = visuals.Font.Family.semibold.css;
	            SVGLegend.LegendItem = createClassAndSelector('legendItem');
	            SVGLegend.LegendText = createClassAndSelector('legendText');
	            SVGLegend.LegendIcon = createClassAndSelector('legendIcon');
	            SVGLegend.LegendTitle = createClassAndSelector('legendTitle');
	            SVGLegend.NavigationArrow = createClassAndSelector('navArrow');
	            return SVGLegend;
	        }());
	        visuals.SVGLegend = SVGLegend;
	        var CartesianChartInteractiveLegend = (function () {
	            function CartesianChartInteractiveLegend(element) {
	                this.legendContainerParent = d3.select(element.get(0));
	            }
	            CartesianChartInteractiveLegend.prototype.getMargins = function () {
	                return {
	                    height: CartesianChartInteractiveLegend.LegendHeight,
	                    width: 0
	                };
	            };
	            CartesianChartInteractiveLegend.prototype.drawLegend = function (legendData) {
	                debug.assertValue(legendData, 'legendData');
	                var data = legendData.dataPoints;
	                debug.assertValue(data, 'dataPoints');
	                if (data.length < 1)
	                    return;
	                var legendContainerDiv = this.legendContainerParent.select(CartesianChartInteractiveLegend.LegendContainerSelector);
	                if (legendContainerDiv.empty()) {
	                    if (!data.length)
	                        return;
	                    var divToPrepend = $('<div></div>')
	                        .height(this.getMargins().height)
	                        .addClass(CartesianChartInteractiveLegend.LegendContainerClass);
	                    // Prepending, as legend should always be on topmost visual.
	                    $(this.legendContainerParent[0]).prepend(divToPrepend);
	                    legendContainerDiv = d3.select(divToPrepend.get(0));
	                }
	                this.legendContainerDiv = legendContainerDiv;
	                // Construct the legend title and items.
	                this.drawTitle(data);
	                this.drawLegendItems(data);
	            };
	            CartesianChartInteractiveLegend.prototype.reset = function () {
	                if (this.legendContainerDiv) {
	                    this.legendContainerDiv.remove();
	                    this.legendContainerDiv = null;
	                }
	            };
	            CartesianChartInteractiveLegend.prototype.isVisible = function () {
	                return true;
	            };
	            CartesianChartInteractiveLegend.prototype.changeOrientation = function (orientation) {
	                // Not supported
	            };
	            CartesianChartInteractiveLegend.prototype.getOrientation = function () {
	                return LegendPosition.Top;
	            };
	            /**
	             * Draw the legend title
	             */
	            CartesianChartInteractiveLegend.prototype.drawTitle = function (data) {
	                debug.assert(data && data.length > 0, 'data is null or empty');
	                var titleDiv = this.legendContainerDiv.selectAll('div.' + CartesianChartInteractiveLegend.LegendTitleClass);
	                var item = titleDiv.data([data[0]]);
	                // Enter
	                var itemEnter = item.enter();
	                var titleDivEnter = itemEnter.append('div').attr('class', CartesianChartInteractiveLegend.LegendTitleClass);
	                titleDivEnter
	                    .filter(function (d) { return d.iconOnlyOnLabel; })
	                    .append('span')
	                    .attr('class', CartesianChartInteractiveLegend.legendIconClass)
	                    .html(CartesianChartInteractiveLegend.legendPlaceSelector);
	                titleDivEnter.append('span');
	                // Update
	                item.filter(function (d) { return d.iconOnlyOnLabel; })
	                    .select('span.' + CartesianChartInteractiveLegend.legendIconClass)
	                    .style(CartesianChartInteractiveLegend.legendColorCss, function (d) { return d.color; });
	                item.select('span:last-child').text(function (d) { return d.category; });
	            };
	            /**
	             * Draw the legend items
	             */
	            CartesianChartInteractiveLegend.prototype.drawLegendItems = function (data) {
	                // Add Mesaures - the items of the category in the legend
	                this.ensureLegendTableCreated();
	                var dataPointsMatrix = [data];
	                var legendItemsContainer = this.legendContainerDiv.select('tbody').selectAll('tr').data(dataPointsMatrix);
	                // Enter
	                var legendItemsEnter = legendItemsContainer.enter();
	                var rowEnter = legendItemsEnter.append('tr');
	                var cellEnter = rowEnter.selectAll('td')
	                    .data(function (d) { return d; }, function (d) { return d.label; })
	                    .enter()
	                    .append('td').attr('class', CartesianChartInteractiveLegend.LegendItem);
	                var cellSpanEnter = cellEnter.append('span');
	                cellSpanEnter.filter(function (d) { return !d.iconOnlyOnLabel; })
	                    .append('span')
	                    .html(CartesianChartInteractiveLegend.legendPlaceSelector)
	                    .attr('class', CartesianChartInteractiveLegend.legendIconClass)
	                    .attr('white-space', 'nowrap')
	                    .style({
	                    'font-size': '20px',
	                    'margin-bottom': '7px'
	                });
	                cellSpanEnter.append('span').attr('class', CartesianChartInteractiveLegend.legendItemNameClass);
	                cellSpanEnter.append('span').attr('class', CartesianChartInteractiveLegend.legendItemMeasureClass);
	                // Update
	                var legendCells = legendItemsContainer.selectAll('td').data(function (d) { return d; }, function (d) { return d.label; });
	                legendCells.select('span.' + CartesianChartInteractiveLegend.legendItemNameClass).html(function (d) { return powerbi.visuals.TextUtil.removeBreakingSpaces(d.label); });
	                legendCells.select('span.' + CartesianChartInteractiveLegend.legendItemMeasureClass).html(function (d) { return '&nbsp;' + d.measure; });
	                legendCells.select('span.' + CartesianChartInteractiveLegend.legendIconClass).style('color', function (d) { return d.color; });
	                // Exit
	                legendCells.exit().remove();
	            };
	            /**
	             * Ensure legend table is created and set horizontal pan gestures on it
	             */
	            CartesianChartInteractiveLegend.prototype.ensureLegendTableCreated = function () {
	                if (this.legendContainerDiv.select('div table').empty()) {
	                    var legendTable = this.legendContainerDiv.append('div').append('table');
	                    legendTable.style('table-layout', 'fixed').append('tbody');
	                    // Setup Pan Gestures of the legend
	                    this.setPanGestureOnLegend(legendTable);
	                }
	            };
	            /**
	             * Set Horizontal Pan gesture for the legend
	             */
	            CartesianChartInteractiveLegend.prototype.setPanGestureOnLegend = function (legendTable) {
	                var viewportWidth = $(this.legendContainerParent[0]).width();
	                var xscale = d3.scale.linear().domain([0, viewportWidth]).range([0, viewportWidth]);
	                var zoom = d3.behavior.zoom()
	                    .scaleExtent([1, 1]) // disable scaling
	                    .x(xscale)
	                    .on("zoom", function () {
	                    // horizontal pan is valid only in case the legend items width are bigger than the viewport width
	                    if ($(legendTable[0]).width() > viewportWidth) {
	                        var t = zoom.translate();
	                        var tx_1 = t[0];
	                        var ty = t[1];
	                        tx_1 = Math.min(tx_1, 0);
	                        tx_1 = Math.max(tx_1, viewportWidth - $(legendTable[0]).width());
	                        zoom.translate([tx_1, ty]);
	                        legendTable.style("-ms-transform", function () {
	                            return visuals.SVGUtil.translateXWithPixels(tx_1);
	                        });
	                        legendTable.style("-webkit-transform", function () {
	                            return visuals.SVGUtil.translateXWithPixels(tx_1);
	                        });
	                        legendTable.style("transform", function () {
	                            return visuals.SVGUtil.translateXWithPixels(tx_1);
	                        });
	                    }
	                });
	                if (this.legendContainerDiv) {
	                    this.legendContainerDiv.call(zoom);
	                }
	                else {
	                    legendTable.call(zoom);
	                }
	            };
	            CartesianChartInteractiveLegend.LegendHeight = 70;
	            CartesianChartInteractiveLegend.LegendContainerClass = 'interactive-legend';
	            CartesianChartInteractiveLegend.LegendContainerSelector = '.interactive-legend';
	            CartesianChartInteractiveLegend.LegendTitleClass = 'title';
	            CartesianChartInteractiveLegend.LegendItem = 'item';
	            CartesianChartInteractiveLegend.legendPlaceSelector = '\u25CF';
	            CartesianChartInteractiveLegend.legendIconClass = 'icon';
	            CartesianChartInteractiveLegend.legendColorCss = 'color';
	            CartesianChartInteractiveLegend.legendItemNameClass = 'itemName';
	            CartesianChartInteractiveLegend.legendItemMeasureClass = 'itemMeasure';
	            return CartesianChartInteractiveLegend;
	        }());
	        var LegendData;
	        (function (LegendData) {
	            LegendData.DefaultLegendLabelFillColor = '#666666';
	            function update(legendData, legendObject) {
	                debug.assertValue(legendData, 'legendData');
	                debug.assertValue(legendObject, 'legendObject');
	                if (legendObject[visuals.legendProps.show] == null) {
	                    legendObject[visuals.legendProps.show] = true;
	                }
	                if (legendObject[visuals.legendProps.show] === false)
	                    legendData.dataPoints = [];
	                if (legendObject[visuals.legendProps.show] === true && legendObject[visuals.legendProps.position] == null)
	                    legendObject[visuals.legendProps.position] = visuals.legendPosition.top;
	                if (legendObject[visuals.legendProps.fontSize] !== undefined)
	                    legendData.fontSize = legendObject[visuals.legendProps.fontSize];
	                if (legendObject[visuals.legendProps.labelColor] !== undefined) {
	                    var fillColor = legendObject[visuals.legendProps.labelColor];
	                    if (fillColor != null) {
	                        legendData.labelColor = fillColor.solid.color;
	                    }
	                }
	                if (legendObject[visuals.legendProps.showTitle] === false)
	                    legendData.title = "";
	                else if (legendObject[visuals.legendProps.titleText] !== undefined) {
	                    legendData.title = legendObject[visuals.legendProps.titleText];
	                }
	            }
	            LegendData.update = update;
	        })(LegendData = visuals.LegendData || (visuals.LegendData = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 126 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	*  Power BI Visualizations
	*
	*  Copyright (c) Microsoft Corporation
	*  All rights reserved.
	*  MIT License
	*
	*  Permission is hereby granted, free of charge, to any person obtaining a copy
	*  of this software and associated documentation files (the ""Software""), to deal
	*  in the Software without restriction, including without limitation the rights
	*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	*  copies of the Software, and to permit persons to whom the Software is
	*  furnished to do so, subject to the following conditions:
	*
	*  The above copyright notice and this permission notice shall be included in
	*  all copies or substantial portions of the Software.
	*
	*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	*  THE SOFTWARE.
	*/
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var axisScale;
	        (function (axisScale) {
	            axisScale.linear = 'linear';
	            axisScale.log = 'log';
	            axisScale.type = powerbi.createEnumType([
	                { value: axisScale.linear, displayName: function (resources) { return resources.get('Visual_Axis_Linear'); } },
	                { value: axisScale.log, displayName: function (resources) { return resources.get('Visual_Axis_Log'); } }
	            ]);
	        })(axisScale = visuals.axisScale || (visuals.axisScale = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 127 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var axisStyle;
	        (function (axisStyle) {
	            axisStyle.showBoth = 'showBoth';
	            axisStyle.showTitleOnly = 'showTitleOnly';
	            axisStyle.showUnitOnly = 'showUnitOnly';
	            axisStyle.type = powerbi.createEnumType([
	                { value: axisStyle.showTitleOnly, displayName: function (resources) { return resources.get('Visual_Axis_ShowTitleOnly'); } },
	                { value: axisStyle.showUnitOnly, displayName: function (resources) { return resources.get('Visual_Axis_ShowUnitOnly'); } },
	                { value: axisStyle.showBoth, displayName: function (resources) { return resources.get('Visual_Axis_ShowBoth'); } }
	            ]);
	        })(axisStyle = visuals.axisStyle || (visuals.axisStyle = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 128 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var axisType;
	        (function (axisType) {
	            axisType.scalar = 'Scalar';
	            axisType.categorical = 'Categorical';
	            axisType.both = 'Both';
	            axisType.type = powerbi.createEnumType([
	                { value: axisType.scalar, displayName: function (resources) { return resources.get('Visual_Axis_Scalar'); } },
	                { value: axisType.categorical, displayName: function (resources) { return resources.get('Visual_Axis_Categorical'); } },
	            ]);
	        })(axisType = visuals.axisType || (visuals.axisType = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 129 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var basicShapeType;
	        (function (basicShapeType) {
	            basicShapeType.rectangle = 'rectangle';
	            basicShapeType.oval = 'oval';
	            basicShapeType.line = 'line';
	            basicShapeType.arrow = 'arrow';
	            basicShapeType.triangle = 'triangle';
	            basicShapeType.type = powerbi.createEnumType([
	                { value: basicShapeType.rectangle, displayName: 'rectangle' },
	                { value: basicShapeType.oval, displayName: 'oval' },
	                { value: basicShapeType.line, displayName: 'line' },
	                { value: basicShapeType.arrow, displayName: 'arrow' },
	                { value: basicShapeType.triangle, displayName: 'triangle' }
	            ]);
	        })(basicShapeType = visuals.basicShapeType || (visuals.basicShapeType = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 130 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var confidenceBandStyle;
	        (function (confidenceBandStyle) {
	            confidenceBandStyle.fill = 'fill';
	            confidenceBandStyle.line = 'line';
	            confidenceBandStyle.none = 'none';
	            confidenceBandStyle.type = powerbi.createEnumType([
	                { value: confidenceBandStyle.fill, displayName: function (resources) { return resources.get('Visual_Confidence_Band_Style_Fill'); } },
	                { value: confidenceBandStyle.line, displayName: function (resources) { return resources.get('Visual_Confidence_Band_Style_Line'); } },
	                { value: confidenceBandStyle.none, displayName: function (resources) { return resources.get('Visual_Confidence_Band_Style_None'); } }
	            ]);
	        })(confidenceBandStyle = visuals.confidenceBandStyle || (visuals.confidenceBandStyle = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 131 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var imageScalingType;
	        (function (imageScalingType) {
	            imageScalingType.normal = 'Normal';
	            imageScalingType.fit = 'Fit';
	            imageScalingType.fill = 'Fill';
	            imageScalingType.type = powerbi.createEnumType([
	                { value: imageScalingType.normal, displayName: function (resources) { return resources.get('Visual_ImageScalingType_Normal'); } },
	                { value: imageScalingType.fit, displayName: function (resources) { return resources.get('Visual_ImageScalingType_Fit'); } },
	                { value: imageScalingType.fill, displayName: function (resources) { return resources.get('Visual_ImageScalingType_Fill'); } },
	            ]);
	        })(imageScalingType = visuals.imageScalingType || (visuals.imageScalingType = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 132 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var labelPosition;
	        (function (labelPosition) {
	            labelPosition.insideEnd = 'InsideEnd';
	            labelPosition.insideCenter = 'InsideCenter';
	            labelPosition.outsideEnd = 'OutsideEnd';
	            labelPosition.insideBase = 'InsideBase';
	            labelPosition.type = powerbi.createEnumType([
	                { value: labelPosition.insideEnd, displayName: function (resources) { return resources.get('Visual_LabelPosition_InsideEnd'); } },
	                { value: labelPosition.outsideEnd, displayName: function (resources) { return resources.get('Visual_LabelPosition_OutsideEnd'); } },
	                { value: labelPosition.insideCenter, displayName: function (resources) { return resources.get('Visual_LabelPosition_InsideCenter'); } },
	                { value: labelPosition.insideBase, displayName: function (resources) { return resources.get('Visual_LabelPosition_InsideBase'); } },
	            ]);
	        })(labelPosition = visuals.labelPosition || (visuals.labelPosition = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 133 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var labelStyle;
	        (function (labelStyle) {
	            labelStyle.category = 'Category';
	            labelStyle.data = 'Data';
	            labelStyle.both = 'Both';
	            labelStyle.type = powerbi.createEnumType([
	                { value: labelStyle.category, displayName: function (resources) { return resources.get('Visual_LabelStyle_Category'); } },
	                { value: labelStyle.data, displayName: function (resources) { return resources.get('Visual_LabelStyle_DataValue'); } },
	                { value: labelStyle.both, displayName: function (resources) { return resources.get('Visual_LabelStyle_Both'); } },
	            ]);
	        })(labelStyle = visuals.labelStyle || (visuals.labelStyle = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 134 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var legendPosition;
	        (function (legendPosition) {
	            legendPosition.top = 'Top';
	            legendPosition.bottom = 'Bottom';
	            legendPosition.left = 'Left';
	            legendPosition.right = 'Right';
	            legendPosition.topCenter = 'TopCenter';
	            legendPosition.bottomCenter = 'BottomCenter';
	            legendPosition.leftCenter = 'LeftCenter';
	            legendPosition.rightCenter = 'RightCenter';
	            legendPosition.type = powerbi.createEnumType([
	                { value: legendPosition.top, displayName: function (resources) { return resources.get('Visual_LegendPosition_Top'); } },
	                { value: legendPosition.bottom, displayName: function (resources) { return resources.get('Visual_LegendPosition_Bottom'); } },
	                { value: legendPosition.left, displayName: function (resources) { return resources.get('Visual_LegendPosition_Left'); } },
	                { value: legendPosition.right, displayName: function (resources) { return resources.get('Visual_LegendPosition_Right'); } },
	                { value: legendPosition.topCenter, displayName: function (resources) { return resources.get('Visual_LegendPosition_TopCenter'); } },
	                { value: legendPosition.bottomCenter, displayName: function (resources) { return resources.get('Visual_LegendPosition_BottomCenter'); } },
	                { value: legendPosition.leftCenter, displayName: function (resources) { return resources.get('Visual_LegendPosition_LeftCenter'); } },
	                { value: legendPosition.rightCenter, displayName: function (resources) { return resources.get('Visual_LegendPosition_RightCenter'); } },
	            ]);
	        })(legendPosition = visuals.legendPosition || (visuals.legendPosition = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 135 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var kpiDirection;
	        (function (kpiDirection) {
	            kpiDirection.positive = 'Positive';
	            kpiDirection.negative = 'Negative';
	            kpiDirection.type = powerbi.createEnumType([
	                { value: kpiDirection.positive, displayName: function (resources) { return resources.get('Visual_KPI_Direction_Positive'); } },
	                { value: kpiDirection.negative, displayName: function (resources) { return resources.get('Visual_KPI_Direction_Negative'); } }
	            ]);
	        })(kpiDirection = visuals.kpiDirection || (visuals.kpiDirection = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 136 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var lineStyle;
	        (function (lineStyle) {
	            lineStyle.dashed = 'dashed';
	            lineStyle.solid = 'solid';
	            lineStyle.dotted = 'dotted';
	            lineStyle.type = powerbi.createEnumType([
	                { value: lineStyle.dashed, displayName: function (resources) { return resources.get('Visual_LineStyle_Dashed'); } },
	                { value: lineStyle.solid, displayName: function (resources) { return resources.get('Visual_LineStyle_Solid'); } },
	                { value: lineStyle.dotted, displayName: function (resources) { return resources.get('Visual_LineStyle_Dotted'); } }
	            ]);
	        })(lineStyle = visuals.lineStyle || (visuals.lineStyle = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 137 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	*  Power BI Visualizations
	*
	*  Copyright (c) Microsoft Corporation
	*  All rights reserved.
	*  MIT License
	*
	*  Permission is hereby granted, free of charge, to any person obtaining a copy
	*  of this software and associated documentation files (the ""Software""), to deal
	*  in the Software without restriction, including without limitation the rights
	*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	*  copies of the Software, and to permit persons to whom the Software is
	*  furnished to do so, subject to the following conditions:
	*
	*  The above copyright notice and this permission notice shall be included in
	*  all copies or substantial portions of the Software.
	*
	*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	*  THE SOFTWARE.
	*/
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var outline;
	        (function (outline_1) {
	            outline_1.none = 'None';
	            outline_1.bottomOnly = 'BottomOnly';
	            outline_1.topOnly = 'TopOnly';
	            outline_1.leftOnly = 'LeftOnly';
	            outline_1.rightOnly = 'RightOnly';
	            outline_1.topBottom = 'TopBottom';
	            outline_1.leftRight = 'LeftRight';
	            outline_1.frame = 'Frame';
	            function showTop(outline) {
	                return [outline_1.topOnly, outline_1.topBottom, outline_1.frame].some(function (o) { return o === outline; });
	            }
	            outline_1.showTop = showTop;
	            function showRight(outline) {
	                return [outline_1.rightOnly, outline_1.leftRight, outline_1.frame].some(function (o) { return o === outline; });
	            }
	            outline_1.showRight = showRight;
	            function showBottom(outline) {
	                return [outline_1.bottomOnly, outline_1.topBottom, outline_1.frame].some(function (o) { return o === outline; });
	            }
	            outline_1.showBottom = showBottom;
	            function showLeft(outline) {
	                return [outline_1.leftOnly, outline_1.leftRight, outline_1.frame].some(function (o) { return o === outline; });
	            }
	            outline_1.showLeft = showLeft;
	            outline_1.type = powerbi.createEnumType([
	                { value: outline_1.none, displayName: function (resources) { return resources.get('Visual_Outline_none'); } },
	                { value: outline_1.bottomOnly, displayName: function (resources) { return resources.get('Visual_Outline_bottom_only'); } },
	                { value: outline_1.topOnly, displayName: function (resources) { return resources.get('Visual_Outline_top_only'); } },
	                { value: outline_1.leftOnly, displayName: function (resources) { return resources.get('Visual_Outline_LeftOnly'); } },
	                { value: outline_1.rightOnly, displayName: function (resources) { return resources.get('Visual_Outline_RightOnly'); } },
	                { value: outline_1.topBottom, displayName: function (resources) { return resources.get('Visual_Outline_top_Bottom'); } },
	                { value: outline_1.leftRight, displayName: function (resources) { return resources.get('Visual_Outline_leftRight'); } },
	                { value: outline_1.frame, displayName: function (resources) { return resources.get('Visual_Outline_frame'); } }
	            ]);
	        })(outline = visuals.outline || (visuals.outline = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 138 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var referenceLinePosition;
	        (function (referenceLinePosition) {
	            referenceLinePosition.back = 'back';
	            referenceLinePosition.front = 'front';
	            referenceLinePosition.type = powerbi.createEnumType([
	                { value: referenceLinePosition.back, displayName: function (resources) { return resources.get('Visual_Reference_Line_Behind'); } },
	                { value: referenceLinePosition.front, displayName: function (resources) { return resources.get('Visual_Reference_Line_InFront'); } },
	            ]);
	        })(referenceLinePosition = visuals.referenceLinePosition || (visuals.referenceLinePosition = {}));
	        var referenceLineDataLabelHorizontalPosition;
	        (function (referenceLineDataLabelHorizontalPosition) {
	            referenceLineDataLabelHorizontalPosition.left = 'left';
	            referenceLineDataLabelHorizontalPosition.right = 'right';
	            referenceLineDataLabelHorizontalPosition.type = powerbi.createEnumType([
	                { value: referenceLineDataLabelHorizontalPosition.left, displayName: function (resources) { return resources.get('Visual_Reference_Line_Data_Label_Left'); } },
	                { value: referenceLineDataLabelHorizontalPosition.right, displayName: function (resources) { return resources.get('Visual_Reference_Line_Data_Label_Right'); } },
	            ]);
	        })(referenceLineDataLabelHorizontalPosition = visuals.referenceLineDataLabelHorizontalPosition || (visuals.referenceLineDataLabelHorizontalPosition = {}));
	        var referenceLineDataLabelVerticalPosition;
	        (function (referenceLineDataLabelVerticalPosition) {
	            referenceLineDataLabelVerticalPosition.above = 'above';
	            referenceLineDataLabelVerticalPosition.under = 'under';
	            referenceLineDataLabelVerticalPosition.type = powerbi.createEnumType([
	                { value: referenceLineDataLabelVerticalPosition.above, displayName: function (resources) { return resources.get('Visual_Reference_Line_Data_Label_Above'); } },
	                { value: referenceLineDataLabelVerticalPosition.under, displayName: function (resources) { return resources.get('Visual_Reference_Line_Data_Label_Under'); } },
	            ]);
	        })(referenceLineDataLabelVerticalPosition = visuals.referenceLineDataLabelVerticalPosition || (visuals.referenceLineDataLabelVerticalPosition = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 139 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	*  Power BI Visualizations
	*
	*  Copyright (c) Microsoft Corporation
	*  All rights reserved.
	*  MIT License
	*
	*  Permission is hereby granted, free of charge, to any person obtaining a copy
	*  of this software and associated documentation files (the ""Software""), to deal
	*  in the Software without restriction, including without limitation the rights
	*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	*  copies of the Software, and to permit persons to whom the Software is
	*  furnished to do so, subject to the following conditions:
	*
	*  The above copyright notice and this permission notice shall be included in
	*  all copies or substantial portions of the Software.
	*
	*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	*  THE SOFTWARE.
	*/
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var slicerOrientation;
	        (function (slicerOrientation) {
	            slicerOrientation.type = powerbi.createEnumType([
	                { value: 0 /* Vertical */, displayName: function (resources) { return resources.get('Slicer_Orientation_Vertical'); } },
	                { value: 1 /* Horizontal */, displayName: function (resources) { return resources.get('Slicer_Orientation_Horizontal'); } },
	            ]);
	        })(slicerOrientation = visuals.slicerOrientation || (visuals.slicerOrientation = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 140 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var yAxisPosition;
	        (function (yAxisPosition) {
	            yAxisPosition.left = 'Left';
	            yAxisPosition.right = 'Right';
	            yAxisPosition.type = powerbi.createEnumType([
	                { value: yAxisPosition.left, displayName: function (resources) { return resources.get('Visual_yAxis_Left'); } },
	                { value: yAxisPosition.right, displayName: function (resources) { return resources.get('Visual_yAxis_Right'); } },
	            ]);
	        })(yAxisPosition = visuals.yAxisPosition || (visuals.yAxisPosition = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 141 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var sliderMode;
	        (function (sliderMode) {
	            sliderMode.before = 'Before';
	            sliderMode.after = 'After';
	            sliderMode.between = 'Between';
	            sliderMode.type = powerbi.createEnumType([
	                { value: sliderMode.between, displayName: function (resources) { return resources.get('Visual_SliderMode_Between'); } },
	                { value: sliderMode.before, displayName: function (resources) { return resources.get('Visual_SliderMode_Before'); } },
	                { value: sliderMode.after, displayName: function (resources) { return resources.get('Visual_SliderMode_After'); } }
	            ]);
	        })(sliderMode = visuals.sliderMode || (visuals.sliderMode = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 142 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var AnimatorCommon;
	        (function (AnimatorCommon) {
	            AnimatorCommon.MinervaAnimationDuration = 250;
	            // The maximum number of data points we can performantly animate with SVG. If we have more, turn off animations.
	            AnimatorCommon.MaxDataPointsToAnimate = 1000;
	            function GetAnimationDuration(animator, suppressAnimations) {
	                return (suppressAnimations || !animator) ? 0 : animator.getDuration();
	            }
	            AnimatorCommon.GetAnimationDuration = GetAnimationDuration;
	        })(AnimatorCommon = visuals.AnimatorCommon || (visuals.AnimatorCommon = {}));
	        /**
	         * We just need to have a non-null animator to allow axis animations in cartesianChart.
	         * Note: Use this temporarily for Line/Scatter until we add more animations (MinervaPlugins only).
	         */
	        var BaseAnimator = (function () {
	            function BaseAnimator(options) {
	                if (options && options.duration) {
	                    this.animationDuration = options.duration;
	                }
	                this.animationDuration = this.animationDuration >= 0 ? this.animationDuration : AnimatorCommon.MinervaAnimationDuration;
	            }
	            BaseAnimator.prototype.getDuration = function () {
	                return this.animationDuration;
	            };
	            BaseAnimator.prototype.animate = function (options) {
	                return null;
	            };
	            BaseAnimator.prototype.getEasing = function () {
	                return 'cubic-in-out';
	            };
	            return BaseAnimator;
	        }());
	        visuals.BaseAnimator = BaseAnimator;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 143 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var WebColumnChartAnimator = (function (_super) {
	            __extends(WebColumnChartAnimator, _super);
	            function WebColumnChartAnimator(options) {
	                _super.call(this, options);
	            }
	            WebColumnChartAnimator.prototype.animate = function (options) {
	                var result = {
	                    failed: true,
	                    shapes: null,
	                };
	                var viewModel = options.viewModel;
	                var previousViewModel = this.previousViewModel;
	                var dataPointCount = viewModel.categories.length * viewModel.series.length;
	                if (dataPointCount > visuals.AnimatorCommon.MaxDataPointsToAnimate) {
	                    // Too many data points to animate.
	                    return result;
	                }
	                if (!previousViewModel) {
	                }
	                else if (viewModel.hasHighlights && !previousViewModel.hasHighlights) {
	                    result = this.animateNormalToHighlighted(options);
	                }
	                else if (viewModel.hasHighlights && previousViewModel.hasHighlights) {
	                    result = this.animateHighlightedToHighlighted(options);
	                }
	                else if (!viewModel.hasHighlights && previousViewModel.hasHighlights) {
	                    result = this.animateHighlightedToNormal(options);
	                }
	                this.previousViewModel = viewModel;
	                return result;
	            };
	            WebColumnChartAnimator.prototype.animateNormalToHighlighted = function (options) {
	                var data = options.viewModel;
	                var itemCS = options.itemCS;
	                var shapeSelection = options.series.selectAll(itemCS.selector);
	                var shapes = shapeSelection.data(function (d) { return d.data; }, function (d) { return d.key; });
	                var hasHighlights = data.hasHighlights;
	                shapes
	                    .enter()
	                    .append('rect')
	                    .attr("class", function (d) { return itemCS.class.concat(d.highlight ? " highlight" : ""); })
	                    .attr(options.layout.shapeLayoutWithoutHighlights); // Start out at the non-highlight layout
	                shapes
	                    .style("fill", function (d) { return d.color; })
	                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, false, hasHighlights); })
	                    .transition()
	                    .duration(this.animationDuration)
	                    .attr(options.layout.shapeLayout);
	                shapes
	                    .exit()
	                    .remove();
	                return {
	                    failed: false,
	                    shapes: shapes,
	                };
	            };
	            WebColumnChartAnimator.prototype.animateHighlightedToHighlighted = function (options) {
	                var shapes = this.animateDefaultShapes(options.viewModel, options.series, options.layout, options.itemCS);
	                return {
	                    failed: false,
	                    shapes: shapes,
	                };
	            };
	            WebColumnChartAnimator.prototype.animateHighlightedToNormal = function (options) {
	                var itemCS = options.itemCS;
	                var shapeSelection = options.series.selectAll(itemCS.selector);
	                var shapes = shapeSelection.data(function (d) { return d.data; }, function (d) { return d.key; });
	                var hasSelection = options.interactivityService && options.interactivityService.hasSelection();
	                shapes
	                    .enter()
	                    .append('rect')
	                    .attr("class", function (d) { return itemCS.class.concat(d.highlight ? " highlight" : ""); });
	                shapes
	                    .style("fill", function (d) { return d.color; })
	                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, d.selected, !d.selected); })
	                    .transition()
	                    .duration(this.animationDuration)
	                    .attr(options.layout.shapeLayout)
	                    .transition()
	                    .duration(0)
	                    .delay(this.animationDuration)
	                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, false); });
	                shapes
	                    .exit()
	                    .transition()
	                    .duration(this.animationDuration)
	                    .attr(hasSelection ? options.layout.zeroShapeLayout : options.layout.shapeLayoutWithoutHighlights)
	                    .remove();
	                return {
	                    failed: false,
	                    shapes: shapes,
	                };
	            };
	            WebColumnChartAnimator.prototype.animateDefaultShapes = function (data, series, layout, itemCS) {
	                var shapeSelection = series.selectAll(itemCS.selector);
	                var shapes = shapeSelection.data(function (d) { return d.data; }, function (d) { return d.key; });
	                shapes
	                    .enter()
	                    .append('rect')
	                    .attr("class", function (d) { return itemCS.class.concat(d.highlight ? " highlight" : ""); });
	                shapes
	                    .style("fill", function (d) { return d.color; })
	                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, false, data.hasHighlights); })
	                    .transition()
	                    .duration(this.animationDuration)
	                    .attr(layout.shapeLayout);
	                shapes
	                    .exit()
	                    .remove();
	                return shapes;
	            };
	            return WebColumnChartAnimator;
	        }(visuals.BaseAnimator));
	        visuals.WebColumnChartAnimator = WebColumnChartAnimator;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 144 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var WebDonutChartAnimator = (function (_super) {
	            __extends(WebDonutChartAnimator, _super);
	            function WebDonutChartAnimator(options) {
	                _super.call(this, options);
	            }
	            WebDonutChartAnimator.prototype.animate = function (options) {
	                var result = {
	                    failed: true,
	                    shapes: null,
	                    highlightShapes: null,
	                };
	                var viewModel = options.viewModel;
	                var previousViewModel = this.previousViewModel;
	                if (viewModel.highlightsOverflow || (previousViewModel && previousViewModel.highlightsOverflow)) {
	                    // Do not animate when we have highlights but they are overflowing
	                    this.previousViewModel = viewModel;
	                    return result;
	                }
	                var previousHasHighlights = previousViewModel && previousViewModel.hasHighlights;
	                var currentHasHighlights = viewModel.hasHighlights;
	                if (!previousViewModel) {
	                }
	                else if (currentHasHighlights && !previousHasHighlights) {
	                    result = this.animateNormalToHighlighted(options);
	                }
	                else if (currentHasHighlights && previousHasHighlights) {
	                    result = this.animateHighlightedToHighlighted(options);
	                }
	                else if (!currentHasHighlights && previousHasHighlights) {
	                    result = this.animateHighlightedToNormal(options);
	                }
	                this.previousViewModel = viewModel;
	                return result;
	            };
	            WebDonutChartAnimator.prototype.animateNormalToHighlighted = function (options) {
	                var shapes = this.animateDefaultShapes(options);
	                var highlightShapes = options.graphicsContext.select('.slices')
	                    .selectAll('path.slice-highlight')
	                    .data(options.viewModel.dataPoints.filter(function (value) { return value.data.highlightRatio != null; }), function (d) { return d.data.identity.getKey(); });
	                highlightShapes.enter()
	                    .insert('path')
	                    .classed('slice-highlight', true)
	                    .each(function (d) { this._current = d; });
	                visuals.DonutChart.isSingleColor(options.viewModel.dataPoints.filter(function (value) { return value.data.highlightRatio != null; }));
	                highlightShapes
	                    .style('fill', function (d) { return d.data.color ? d.data.color : options.colors.getNewColorScale().getColor(d.data.identity.getKey()).value; })
	                    .style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, true, false, options.viewModel.hasHighlights); })
	                    .style("stroke-dasharray", function (d) { return visuals.DonutChart.drawStrokeForDonutChart(options.radius, options.innerArcRadiusRatio, d, options.sliceWidthRatio, d.data.highlightRatio); })
	                    .style("stroke-width", function (d) { return d.data.strokeWidth; })
	                    .attr(options.layout.shapeLayout) // Start at the non-highlight layout, then transition to the highlight layout.
	                    .transition()
	                    .duration(this.animationDuration)
	                    .attr(options.layout.highlightShapeLayout);
	                highlightShapes.exit()
	                    .remove();
	                visuals.NewDataLabelUtils.drawDefaultLabels(options.labelGraphicsContext, options.labels, false, true, true /*has tooltip */);
	                visuals.NewDataLabelUtils.drawLabelLeaderLines(options.labelGraphicsContext, options.labels);
	                return {
	                    failed: false,
	                    shapes: shapes,
	                    highlightShapes: highlightShapes,
	                };
	            };
	            WebDonutChartAnimator.prototype.animateHighlightedToHighlighted = function (options) {
	                var shapes = this.animateDefaultShapes(options);
	                var highlightShapes = this.animateDefaultHighlightShapes(options);
	                visuals.NewDataLabelUtils.drawDefaultLabels(options.labelGraphicsContext, options.labels, false, true, true /*has tooltip */);
	                visuals.NewDataLabelUtils.drawLabelLeaderLines(options.labelGraphicsContext, options.labels);
	                return {
	                    failed: false,
	                    shapes: shapes,
	                    highlightShapes: highlightShapes,
	                };
	            };
	            WebDonutChartAnimator.prototype.animateHighlightedToNormal = function (options) {
	                var hasSelection = options.interactivityService && options.interactivityService.hasSelection();
	                var duration = this.animationDuration;
	                var shapes = options.graphicsContext.select('.slices')
	                    .selectAll('path.slice')
	                    .data(options.viewModel.dataPoints, function (d) { return d.data.identity.getKey(); });
	                shapes.enter()
	                    .insert('path')
	                    .classed('slice', true)
	                    .each(function (d) { this._current = d; });
	                visuals.DonutChart.isSingleColor(options.viewModel.dataPoints);
	                // For any slice that is selected we want to keep showing it as dimmed (partially highlighted). After the highlight animation
	                // finishes we will set the opacity based on the selection state.
	                shapes
	                    .style('fill', function (d) { return d.data.color ? d.data.color : options.colors.getNewColorScale().getColor(d.data.identity.getKey()).value; })
	                    .style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, d.data.selected, !d.data.selected); })
	                    .style("stroke-dasharray", function (d) { return visuals.DonutChart.drawStrokeForDonutChart(options.radius, options.innerArcRadiusRatio, d, options.sliceWidthRatio); })
	                    .style("stroke-width", function (d) { return d.data.strokeWidth; })
	                    .transition()
	                    .duration(duration)
	                    .attr(options.layout.shapeLayout)
	                    .transition()
	                    .duration(0)
	                    .delay(duration)
	                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, hasSelection, false); });
	                ;
	                shapes.exit()
	                    .remove();
	                var highlightShapes = options.graphicsContext.select('.slices')
	                    .selectAll('path.slice-highlight')
	                    .data(options.viewModel.dataPoints.filter(function (value) { return value.data.highlightRatio != null; }), function (d) { return d.data.identity.getKey(); });
	                highlightShapes.enter()
	                    .insert('path')
	                    .classed('slice-highlight', true)
	                    .each(function (d) { this._current = d; });
	                visuals.DonutChart.isSingleColor(options.viewModel.dataPoints.filter(function (value) { return value.data.highlightRatio != null; }));
	                highlightShapes
	                    .style('fill', function (d) { return d.data.color ? d.data.color : options.colors.getNewColorScale().getColor(d.data.identity.getKey()).value; })
	                    .style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(false, true, false, true); })
	                    .style("stroke-dasharray", function (d) { return visuals.DonutChart.drawStrokeForDonutChart(options.radius, options.innerArcRadiusRatio, d, options.sliceWidthRatio, d.data.highlightRatio); })
	                    .style("stroke-width", function (d) { return d.data.strokeWidth; })
	                    .transition()
	                    .duration(duration)
	                    .attr(hasSelection ? options.layout.zeroShapeLayout : options.layout.shapeLayout) // Transition to the non-highlight layout
	                    .remove();
	                highlightShapes.exit()
	                    .remove();
	                visuals.NewDataLabelUtils.drawDefaultLabels(options.labelGraphicsContext, options.labels, false, true, true /*has tooltip */);
	                visuals.NewDataLabelUtils.drawLabelLeaderLines(options.labelGraphicsContext, options.labels);
	                return {
	                    failed: false,
	                    shapes: shapes,
	                    highlightShapes: highlightShapes,
	                };
	            };
	            WebDonutChartAnimator.prototype.animateDefaultShapes = function (options) {
	                var shapes = options.graphicsContext.select('.slices')
	                    .selectAll('path.slice')
	                    .data(options.viewModel.dataPoints, function (d) { return d.data.identity.getKey(); });
	                shapes.enter()
	                    .insert('path')
	                    .classed('slice', true)
	                    .each(function (d) { this._current = d; });
	                visuals.DonutChart.isSingleColor(options.viewModel.dataPoints);
	                shapes
	                    .style('fill', function (d) { return d.data.color ? d.data.color : options.colors.getNewColorScale().getColor(d.data.identity.getKey()).value; })
	                    .style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, false, options.viewModel.hasHighlights); })
	                    .style("stroke-dasharray", function (d) { return visuals.DonutChart.drawStrokeForDonutChart(options.radius, options.innerArcRadiusRatio, d, options.sliceWidthRatio); })
	                    .style("stroke-width", function (d) { return d.data.strokeWidth; })
	                    .transition()
	                    .duration(this.animationDuration)
	                    .attr(options.layout.shapeLayout);
	                shapes.exit()
	                    .remove();
	                return shapes;
	            };
	            WebDonutChartAnimator.prototype.animateDefaultHighlightShapes = function (options) {
	                var highlightShapes = options.graphicsContext.select('.slices')
	                    .selectAll('path.slice-highlight')
	                    .data(options.viewModel.dataPoints.filter(function (value) { return value.data.highlightRatio != null; }), function (d) { return d.data.identity.getKey(); });
	                highlightShapes.enter()
	                    .insert('path')
	                    .classed('slice-highlight', true)
	                    .each(function (d) { this._current = d; });
	                visuals.DonutChart.isSingleColor(options.viewModel.dataPoints.filter(function (value) { return value.data.highlightRatio != null; }));
	                highlightShapes
	                    .style('fill', function (d) { return d.data.color ? d.data.color : options.colors.getNewColorScale().getColor(d.data.identity.getKey()).value; })
	                    .style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, true, false, options.viewModel.hasHighlights); })
	                    .style("stroke-dasharray", function (d) { return visuals.DonutChart.drawStrokeForDonutChart(options.radius, options.innerArcRadiusRatio, d, options.sliceWidthRatio, d.data.highlightRatio); })
	                    .style("stroke-width", function (d) { return d.data.strokeWidth; })
	                    .transition()
	                    .duration(this.animationDuration)
	                    .attr(options.layout.highlightShapeLayout);
	                highlightShapes.exit()
	                    .remove();
	                return highlightShapes;
	            };
	            return WebDonutChartAnimator;
	        }(visuals.BaseAnimator));
	        visuals.WebDonutChartAnimator = WebDonutChartAnimator;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 145 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var WebFunnelAnimator = (function (_super) {
	            __extends(WebFunnelAnimator, _super);
	            function WebFunnelAnimator(options) {
	                _super.call(this, options);
	            }
	            WebFunnelAnimator.prototype.animate = function (options) {
	                var result = {
	                    failed: true,
	                    shapes: null,
	                    dataLabels: null,
	                };
	                var viewModel = options.viewModel;
	                var previousViewModel = this.previousViewModel;
	                if (!previousViewModel) {
	                }
	                else if (viewModel.hasHighlights && !previousViewModel.hasHighlights) {
	                    result = this.animateNormalToHighlighted(options);
	                }
	                else if (viewModel.hasHighlights && previousViewModel.hasHighlights) {
	                    result = this.animateHighlightedToHighlighted(options);
	                }
	                else if (!viewModel.hasHighlights && previousViewModel.hasHighlights) {
	                    result = this.animateHighlightedToNormal(options);
	                }
	                this.previousViewModel = viewModel;
	                return result;
	            };
	            WebFunnelAnimator.prototype.animateNormalToHighlighted = function (options) {
	                var data = options.viewModel;
	                var layout = options.layout;
	                var hasHighlights = true;
	                var hasSelection = false;
	                this.animateDefaultAxis(options.axisGraphicsContext, options.axisOptions, options.isHidingPercentBars);
	                var shapes = options.shapeGraphicsContext.selectAll(visuals.FunnelChart.Selectors.funnel.bars.selector).data(data.dataPoints, function (d) { return d.key; });
	                shapes.enter()
	                    .append('rect')
	                    .attr("class", function (d) { return d.highlight ? visuals.FunnelChart.FunnelBarHighlightClass : visuals.FunnelChart.Selectors.funnel.bars.class; })
	                    .attr(layout.shapeLayoutWithoutHighlights); // Start by laying out all rectangles ignoring highlights
	                shapes
	                    .style("fill", function (d) { return d.color; })
	                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, hasHighlights); })
	                    .transition()
	                    .duration(this.animationDuration)
	                    .attr(layout.shapeLayout); // Then transition to the layout that uses highlights
	                shapes.exit().remove();
	                this.animatePercentBars(options);
	                var dataLabels = visuals.NewDataLabelUtils.animateDefaultLabels(options.labelGraphicsContext, options.labelLayout, this.animationDuration);
	                return {
	                    failed: false,
	                    shapes: shapes,
	                    dataLabels: dataLabels,
	                };
	            };
	            WebFunnelAnimator.prototype.animateHighlightedToHighlighted = function (options) {
	                var data = options.viewModel;
	                var layout = options.layout;
	                this.animateDefaultAxis(options.axisGraphicsContext, options.axisOptions, options.isHidingPercentBars);
	                // Simply animate to the new shapes.
	                var shapes = this.animateDefaultShapes(data, data.dataPoints, options.shapeGraphicsContext, layout);
	                this.animatePercentBars(options);
	                var dataLabels = visuals.NewDataLabelUtils.animateDefaultLabels(options.labelGraphicsContext, options.labelLayout, this.animationDuration);
	                return {
	                    failed: false,
	                    shapes: shapes,
	                    dataLabels: dataLabels,
	                };
	            };
	            WebFunnelAnimator.prototype.animateHighlightedToNormal = function (options) {
	                var data = options.viewModel;
	                var layout = options.layout;
	                var hasSelection = options.interactivityService ? options.interactivityService.hasSelection() : false;
	                this.animateDefaultAxis(options.axisGraphicsContext, options.axisOptions, options.isHidingPercentBars);
	                var shapes = options.shapeGraphicsContext.selectAll(visuals.FunnelChart.Selectors.funnel.bars.selector).data(data.dataPoints, function (d) { return d.key; });
	                shapes.enter()
	                    .append('rect')
	                    .attr("class", function (d) { return d.highlight ? visuals.FunnelChart.FunnelBarHighlightClass : visuals.FunnelChart.Selectors.funnel.bars.class; });
	                shapes
	                    .style("fill", function (d) { return d.color; })
	                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, !d.selected); })
	                    .transition()
	                    .duration(this.animationDuration)
	                    .attr(layout.shapeLayoutWithoutHighlights) // Transition to layout without highlights
	                    .transition()
	                    .duration(0)
	                    .delay(this.animationDuration)
	                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, false); });
	                var exitShapes = shapes.exit();
	                exitShapes
	                    .transition()
	                    .duration(this.animationDuration)
	                    .attr(hasSelection ? layout.zeroShapeLayout : layout.shapeLayoutWithoutHighlights) // Transition to layout without highlights
	                    .remove();
	                this.animatePercentBars(options);
	                var dataLabels = visuals.NewDataLabelUtils.animateDefaultLabels(options.labelGraphicsContext, options.labelLayout, this.animationDuration);
	                return {
	                    failed: false,
	                    shapes: shapes,
	                    dataLabels: dataLabels,
	                };
	            };
	            WebFunnelAnimator.prototype.animateDefaultAxis = function (graphicsContext, axisOptions, isHidingPercentBars) {
	                var xScaleForAxis = d3.scale.ordinal()
	                    .domain(axisOptions.categoryLabels)
	                    .rangeBands([axisOptions.rangeStart, axisOptions.rangeEnd], axisOptions.barToSpaceRatio, isHidingPercentBars ? axisOptions.barToSpaceRatio : visuals.FunnelChart.PercentBarToBarRatio);
	                var xAxis = d3.svg.axis()
	                    .scale(xScaleForAxis)
	                    .orient("right")
	                    .tickPadding(visuals.FunnelChart.TickPadding)
	                    .innerTickSize(visuals.FunnelChart.InnerTickSize);
	                graphicsContext.classed('axis', true)
	                    .transition()
	                    .duration(this.animationDuration)
	                    .attr('transform', visuals.SVGUtil.translate(0, axisOptions.margin.top))
	                    .call(xAxis);
	            };
	            WebFunnelAnimator.prototype.animateDefaultShapes = function (data, dataPoints, graphicsContext, layout) {
	                var hasHighlights = data.hasHighlights;
	                var shapes = graphicsContext.selectAll(visuals.FunnelChart.Selectors.funnel.bars.selector).data(dataPoints, function (d) { return d.key; });
	                shapes.enter()
	                    .append('rect')
	                    .attr("class", function (d) { return d.highlight ? visuals.FunnelChart.FunnelBarHighlightClass : visuals.FunnelChart.Selectors.funnel.bars.class; });
	                shapes
	                    .style("fill", function (d) { return d.color; })
	                    .style("fill-opacity", function (d) { return function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, false, hasHighlights); }; })
	                    .transition()
	                    .duration(this.animationDuration)
	                    .attr(layout.shapeLayout);
	                shapes.exit().remove();
	                return shapes;
	            };
	            WebFunnelAnimator.prototype.animatePercentBars = function (options) {
	                var data = options.viewModel;
	                var isHidingPercentBars = options.isHidingPercentBars;
	                if (isHidingPercentBars || !data.dataPoints || (data.hasHighlights ? data.dataPoints.length / 2 : data.dataPoints.length) < 2) {
	                    // TODO: call percentBarComponents with flag with empty data to clear drawing smoothly
	                    this.animatePercentBarComponents([], options);
	                    return;
	                }
	                var dataPoints = [data.dataPoints[data.hasHighlights ? 1 : 0], data.dataPoints[data.dataPoints.length - 1]];
	                var baseline = visuals.FunnelChart.getValueFromDataPoint(dataPoints[0]);
	                if (baseline <= 0) {
	                    // TODO: call percentBarComponents with flag with empty data to clear drawing smoothly
	                    this.animatePercentBarComponents([], options);
	                    return;
	                }
	                var percentData = dataPoints.map(function (dataPoint, i) { return {
	                    value: visuals.FunnelChart.getValueFromDataPoint(dataPoint),
	                    percent: i === 0 ? 1 : visuals.FunnelChart.getValueFromDataPoint(dataPoint) / baseline,
	                    isTop: i === 0,
	                }; });
	                this.animatePercentBarComponents(percentData, options);
	            };
	            WebFunnelAnimator.prototype.animateToFunnelPercent = function (context, targetData, layout) {
	                return context
	                    .data(targetData)
	                    .transition()
	                    .duration(this.animationDuration)
	                    .attr(layout);
	            };
	            WebFunnelAnimator.prototype.animatePercentBarComponents = function (data, options) {
	                var graphicsContext = options.percentGraphicsContext;
	                var layout = options.layout;
	                var zeroData = [
	                    { percent: 0, value: 0, isTop: true },
	                    { percent: 0, value: 0, isTop: false },
	                ];
	                // Main line
	                var mainLine = graphicsContext.selectAll(visuals.FunnelChart.Selectors.percentBar.mainLine.selector).data(data);
	                this.animateToFunnelPercent(mainLine.exit(), zeroData, layout.percentBarLayout.mainLine)
	                    .remove();
	                mainLine.enter()
	                    .append('line')
	                    .classed(visuals.FunnelChart.Selectors.percentBar.mainLine.class, true)
	                    .data(zeroData)
	                    .attr(layout.percentBarLayout.mainLine);
	                this.animateToFunnelPercent(mainLine, data, layout.percentBarLayout.mainLine);
	                // Left tick
	                var leftTick = graphicsContext.selectAll(visuals.FunnelChart.Selectors.percentBar.leftTick.selector).data(data);
	                this.animateToFunnelPercent(leftTick.exit(), zeroData, layout.percentBarLayout.leftTick)
	                    .remove();
	                leftTick.enter()
	                    .append('line')
	                    .classed(visuals.FunnelChart.Selectors.percentBar.leftTick.class, true)
	                    .data(zeroData)
	                    .attr(layout.percentBarLayout.leftTick);
	                this.animateToFunnelPercent(leftTick, data, layout.percentBarLayout.leftTick);
	                // Right tick
	                var rightTick = graphicsContext.selectAll(visuals.FunnelChart.Selectors.percentBar.rightTick.selector).data(data);
	                this.animateToFunnelPercent(rightTick.exit(), zeroData, layout.percentBarLayout.rightTick)
	                    .remove();
	                rightTick.enter()
	                    .append('line')
	                    .classed(visuals.FunnelChart.Selectors.percentBar.rightTick.class, true)
	                    .data(zeroData)
	                    .attr(layout.percentBarLayout.rightTick);
	                this.animateToFunnelPercent(rightTick, data, layout.percentBarLayout.rightTick);
	                // Text
	                var text = graphicsContext.selectAll(visuals.FunnelChart.Selectors.percentBar.text.selector).data(data);
	                this.animateToFunnelPercent(text.exit(), zeroData, layout.percentBarLayout.text)
	                    .remove();
	                text.enter()
	                    .append('text')
	                    .classed(visuals.FunnelChart.Selectors.percentBar.text.class, true)
	                    .data(zeroData)
	                    .attr(layout.percentBarLayout.text);
	                this.animateToFunnelPercent(text, data, layout.percentBarLayout.text)
	                    .text(function (fp) {
	                    return powerbi.formattingService.formatValue(fp.percent, visuals.valueFormatter.getLocalizedString("Percentage1"));
	                });
	                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(options.visualInitOptions);
	            };
	            return WebFunnelAnimator;
	        }(visuals.BaseAnimator));
	        visuals.WebFunnelAnimator = WebFunnelAnimator;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 146 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var WebTreemapAnimator = (function (_super) {
	            __extends(WebTreemapAnimator, _super);
	            function WebTreemapAnimator(options) {
	                _super.call(this, options);
	            }
	            WebTreemapAnimator.prototype.animate = function (options) {
	                var result = {
	                    failed: true,
	                    shapes: null,
	                    highlightShapes: null,
	                    majorLabels: null,
	                    minorLabels: null,
	                };
	                var viewModel = options.viewModel;
	                var previousViewModel = this.previousViewModel;
	                if (!previousViewModel) {
	                }
	                else if (viewModel.hasHighlights && !previousViewModel.hasHighlights) {
	                    result = this.animateNormalToHighlighted(options);
	                }
	                else if (viewModel.hasHighlights && previousViewModel.hasHighlights) {
	                    result = this.animateHighlightedToHighlighted(options);
	                }
	                else if (!viewModel.hasHighlights && previousViewModel.hasHighlights) {
	                    result = this.animateHighlightedToNormal(options);
	                }
	                this.previousViewModel = viewModel;
	                return result;
	            };
	            WebTreemapAnimator.prototype.animateNormalToHighlighted = function (options) {
	                var hasSelection = false;
	                var hasHighlights = true;
	                var shapes = this.animateDefaultShapes(options.shapeGraphicsContext, options.nodes, hasSelection, hasHighlights, options.layout);
	                var highlightShapes = options.shapeGraphicsContext.selectAll('.' + visuals.Treemap.HighlightNodeClassName)
	                    .data(options.highlightNodes, function (d) { return d.key + "highlight"; });
	                highlightShapes.enter().append('rect')
	                    .attr('class', options.layout.highlightShapeClass)
	                    .attr(options.layout.shapeLayout); // Start using the normal shape layout
	                highlightShapes
	                    .style("fill", function (d) { return visuals.Treemap.getFill(d, true); })
	                    .style("fill-opacity", function (d) { return visuals.Treemap.getFillOpacity(d, hasSelection, hasHighlights, true); })
	                    .transition()
	                    .duration(this.animationDuration)
	                    .attr(options.layout.highlightShapeLayout); // Animate to the highlighted positions
	                highlightShapes.exit().remove();
	                var majorLabels = this.animateDefaultMajorLabels(options.labelGraphicsContext, options.majorLabeledNodes, options.labelSettings, options.layout);
	                var minorLabels = this.animateDefaultMinorLabels(options.labelGraphicsContext, options.minorLabeledNodes, options.labelSettings, options.layout);
	                return {
	                    failed: false,
	                    shapes: shapes,
	                    highlightShapes: highlightShapes,
	                    majorLabels: majorLabels,
	                    minorLabels: minorLabels,
	                };
	            };
	            WebTreemapAnimator.prototype.animateHighlightedToHighlighted = function (options) {
	                var hasSelection = false;
	                var hasHighlights = true;
	                var shapes = this.animateDefaultShapes(options.shapeGraphicsContext, options.nodes, hasSelection, hasHighlights, options.layout);
	                options.shapeGraphicsContext.selectAll('.' + visuals.Treemap.HighlightNodeClassName)
	                    .data(options.highlightNodes, function (d) { return d.key + "highlight"; });
	                var highlightShapes = this.animateDefaultHighlightShapes(options.shapeGraphicsContext, options.highlightNodes, hasSelection, hasHighlights, options.layout);
	                var majorLabels = this.animateDefaultMajorLabels(options.labelGraphicsContext, options.majorLabeledNodes, options.labelSettings, options.layout);
	                var minorLabels = this.animateDefaultMinorLabels(options.labelGraphicsContext, options.minorLabeledNodes, options.labelSettings, options.layout);
	                return {
	                    failed: false,
	                    shapes: shapes,
	                    highlightShapes: highlightShapes,
	                    majorLabels: majorLabels,
	                    minorLabels: minorLabels,
	                };
	            };
	            WebTreemapAnimator.prototype.animateHighlightedToNormal = function (options) {
	                var hasSelection = options.interactivityService ? options.interactivityService.hasSelection() : false;
	                var shapes = options.shapeGraphicsContext.selectAll('.' + visuals.Treemap.TreemapNodeClassName)
	                    .data(options.nodes, function (d) { return d.key; });
	                shapes.enter().append('rect')
	                    .attr('class', options.layout.shapeClass);
	                shapes
	                    .transition()
	                    .duration(this.animationDuration)
	                    .style("fill", function (d) { return visuals.Treemap.getFill(d, false); })
	                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, d.selected, !d.selected); })
	                    .attr(options.layout.shapeLayout)
	                    .transition()
	                    .duration(0)
	                    .delay(this.animationDuration)
	                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); });
	                shapes.exit().remove();
	                var highlightShapes = options.shapeGraphicsContext.selectAll('.' + visuals.Treemap.HighlightNodeClassName)
	                    .data(options.nodes, function (d) { return d.key + "highlight"; });
	                highlightShapes.enter().append('rect')
	                    .attr('class', options.layout.highlightShapeClass);
	                highlightShapes
	                    .style("fill", function (d) { return visuals.Treemap.getFill(d, true); })
	                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, true, d.selected, !d.selected); })
	                    .transition()
	                    .duration(this.animationDuration)
	                    .attr(hasSelection ? options.layout.zeroShapeLayout : options.layout.shapeLayout) // Animate to the normal shape layout or zero shape layout depending on whether we have a selection or not
	                    .remove();
	                highlightShapes.exit().remove();
	                var majorLabels = this.animateDefaultMajorLabels(options.labelGraphicsContext, options.majorLabeledNodes, options.labelSettings, options.layout);
	                var minorLabels = this.animateDefaultMinorLabels(options.labelGraphicsContext, options.minorLabeledNodes, options.labelSettings, options.layout);
	                return {
	                    failed: false,
	                    shapes: shapes,
	                    highlightShapes: highlightShapes,
	                    majorLabels: majorLabels,
	                    minorLabels: minorLabels,
	                };
	            };
	            WebTreemapAnimator.prototype.animateDefaultShapes = function (context, nodes, hasSelection, hasHighlights, layout) {
	                var isHighlightShape = false;
	                var shapes = context.selectAll('.' + visuals.Treemap.TreemapNodeClassName)
	                    .data(nodes, function (d) { return d.key; });
	                shapes.enter().append('rect')
	                    .attr('class', layout.shapeClass);
	                shapes
	                    .transition()
	                    .duration(this.animationDuration)
	                    .style("fill", function (d) { return visuals.Treemap.getFill(d, isHighlightShape); })
	                    .style("fill-opacity", function (d) { return visuals.Treemap.getFillOpacity(d, hasSelection, hasHighlights, isHighlightShape); })
	                    .attr(layout.shapeLayout);
	                shapes.exit().remove();
	                return shapes;
	            };
	            WebTreemapAnimator.prototype.animateDefaultHighlightShapes = function (context, nodes, hasSelection, hasHighlights, layout) {
	                var isHighlightShape = true;
	                var highlightShapes = context.selectAll('.' + visuals.Treemap.HighlightNodeClassName)
	                    .data(nodes, function (d) { return d.key + "highlight"; });
	                highlightShapes.enter().append('rect')
	                    .attr('class', layout.highlightShapeClass);
	                highlightShapes
	                    .transition()
	                    .duration(this.animationDuration)
	                    .style("fill", function (d) { return visuals.Treemap.getFill(d, isHighlightShape); })
	                    .style("fill-opacity", function (d) { return visuals.Treemap.getFillOpacity(d, hasSelection, hasHighlights, isHighlightShape); })
	                    .attr(layout.highlightShapeLayout);
	                highlightShapes.exit().remove();
	                return highlightShapes;
	            };
	            WebTreemapAnimator.prototype.animateDefaultMajorLabels = function (context, nodes, labelSettings, layout) {
	                var labels = context
	                    .selectAll('.' + visuals.Treemap.MajorLabelClassName)
	                    .data(nodes, function (d) { return d.key; });
	                labels.enter().append('text')
	                    .attr('class', layout.majorLabelClass);
	                labels
	                    .text(layout.majorLabelText)
	                    .style('fill', function () { return labelSettings.labelColor; })
	                    .transition()
	                    .duration(this.animationDuration)
	                    .attr(layout.majorLabelLayout);
	                labels.exit().remove();
	                return labels;
	            };
	            WebTreemapAnimator.prototype.animateDefaultMinorLabels = function (context, nodes, labelSettings, layout) {
	                var labels = context
	                    .selectAll('.' + visuals.Treemap.MinorLabelClassName)
	                    .data(nodes, function (d) { return d.key; });
	                labels.enter().append('text')
	                    .attr('class', layout.minorLabelClass);
	                labels
	                    .text(layout.minorLabelText)
	                    .style('fill', function () { return labelSettings.labelColor; })
	                    .transition()
	                    .duration(this.animationDuration)
	                    .attr(layout.minorLabelLayout);
	                labels.exit().remove();
	                return labels;
	            };
	            return WebTreemapAnimator;
	        }(visuals.BaseAnimator));
	        visuals.WebTreemapAnimator = WebTreemapAnimator;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 147 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        /**
	         * This is the baseline for some most common used object properties across visuals.
	         * When adding new properties, please try to reuse the existing ones.
	         */
	        visuals.StandardObjectProperties = {
	            axisEnd: {
	                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_End'),
	                description: powerbi.data.createDisplayNameGetter('Visual_Axis_EndDescription'),
	                placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
	                type: { numeric: true },
	                suppressFormatPainterCopy: true,
	            },
	            axisScale: {
	                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Scale'),
	                type: { enumeration: visuals.axisScale.type }
	            },
	            axisStart: {
	                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Start'),
	                description: powerbi.data.createDisplayNameGetter('Visual_Axis_StartDescription'),
	                placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
	                type: { numeric: true },
	                suppressFormatPainterCopy: true,
	            },
	            axisStyle: {
	                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),
	                type: { enumeration: visuals.axisStyle.type }
	            },
	            axisType: {
	                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Type'),
	                type: { enumeration: visuals.axisType.type },
	            },
	            backColor: {
	                displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColor'),
	                description: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColor_Desc'),
	                type: { fill: { solid: { color: true } } }
	            },
	            dataColor: {
	                displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
	                description: powerbi.data.createDisplayNameGetter('Visual_LabelsFillDescription'),
	                type: { fill: { solid: { color: true } } }
	            },
	            dataLabelColor: {
	                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Color"),
	                description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Data_Label_Color_Description'),
	                type: { fill: { solid: { color: true } } }
	            },
	            dataLabelDecimalPoints: {
	                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Decimal_Points"),
	                placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
	                type: { numeric: true }
	            },
	            dataLabelDisplayUnits: {
	                displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
	                description: powerbi.data.createDisplayNameGetter('Visual_DisplayUnitsDescription'),
	                type: { formatting: { labelDisplayUnits: true } },
	                suppressFormatPainterCopy: true,
	            },
	            dataLabelHorizontalPosition: {
	                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Horizontal_Position"),
	                description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Data_Label_Horizontal_Position_Description'),
	                type: { enumeration: visuals.referenceLineDataLabelHorizontalPosition.type }
	            },
	            dataLabelShow: {
	                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label"),
	                description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Data_Label_Show_Description'),
	                type: { bool: true }
	            },
	            dataLabelVerticalPosition: {
	                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Vertical_Position"),
	                description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Data_Label_Vertical_Position_Description'),
	                type: { enumeration: visuals.referenceLineDataLabelVerticalPosition.type }
	            },
	            defaultColor: {
	                displayName: powerbi.data.createDisplayNameGetter('Visual_DefaultColor'),
	                type: { fill: { solid: { color: true } } }
	            },
	            fill: {
	                displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
	                type: { fill: { solid: { color: true } } }
	            },
	            fontColor: {
	                displayName: powerbi.data.createDisplayNameGetter('Visual_FontColor'),
	                description: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColor_Desc'),
	                type: { fill: { solid: { color: true } } }
	            },
	            fontSize: {
	                displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
	                type: { formatting: { fontSize: true } }
	            },
	            formatString: {
	                type: { formatting: { formatString: true } },
	            },
	            image: {
	                type: { image: {} },
	            },
	            labelColor: {
	                displayName: powerbi.data.createDisplayNameGetter('Visual_LegendTitleColor'),
	                type: { fill: { solid: { color: true } } }
	            },
	            labelDisplayUnits: {
	                displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
	                description: powerbi.data.createDisplayNameGetter('Visual_DisplayUnitsDescription'),
	                type: { formatting: { labelDisplayUnits: true } }
	            },
	            labelPrecision: {
	                displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
	                description: powerbi.data.createDisplayNameGetter('Visual_PrecisionDescription'),
	                placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
	                type: { numeric: true }
	            },
	            legendPosition: {
	                displayName: powerbi.data.createDisplayNameGetter('Visual_LegendPosition'),
	                description: powerbi.data.createDisplayNameGetter('Visual_LegendPositionDescription'),
	                type: { enumeration: visuals.legendPosition.type },
	            },
	            legendTitle: {
	                displayName: powerbi.data.createDisplayNameGetter('Visual_LegendName'),
	                description: powerbi.data.createDisplayNameGetter('Visual_LegendNameDescription'),
	                type: { text: true },
	            },
	            lineColor: {
	                displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Color'),
	                description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Color_Description'),
	                type: { fill: { solid: { color: true } } }
	            },
	            outline: {
	                displayName: powerbi.data.createDisplayNameGetter('Visual_Outline'),
	                type: { enumeration: visuals.outline.type }
	            },
	            outlineColor: {
	                displayName: powerbi.data.createDisplayNameGetter('Visual_OutlineColor'),
	                description: powerbi.data.createDisplayNameGetter('Visual_OutlineColor_Desc'),
	                type: { fill: { solid: { color: true } } }
	            },
	            outlineWeight: {
	                displayName: powerbi.data.createDisplayNameGetter('Visual_OutlineWeight'),
	                description: powerbi.data.createDisplayNameGetter('Visual_OutlineWeight_Desc'),
	                type: { numeric: true }
	            },
	            show: {
	                displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
	                type: { bool: true }
	            },
	            showAllDataPoints: {
	                displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint_Show_All'),
	                type: { bool: true }
	            },
	            showLegendTitle: {
	                displayName: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitle'),
	                description: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitleDescription'),
	                type: { bool: true }
	            },
	            referenceLinePosition: {
	                displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Arrange'),
	                description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Arrange_Description'),
	                type: { enumeration: visuals.referenceLinePosition.type }
	            },
	            referenceLineStyle: {
	                displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Style'),
	                description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Style_Description'),
	                type: { enumeration: visuals.lineStyle.type }
	            },
	            transparency: {
	                displayName: powerbi.data.createDisplayNameGetter('Visual_Background_Transparency'),
	                description: powerbi.data.createDisplayNameGetter('Visual_Background_TransparencyDescription'),
	                type: { numeric: true }
	            },
	            yAxisPosition: {
	                displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_Position'),
	                description: powerbi.data.createDisplayNameGetter('Visual_YAxis_PositionDescription'),
	                type: { enumeration: visuals.yAxisPosition.type },
	            },
	        };
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 148 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        visuals.animatedTextObjectDescs = {
	            general: {
	                properties: {
	                    formatString: visuals.StandardObjectProperties.formatString,
	                },
	            }
	        };
	        visuals.animatedNumberCapabilities = {
	            objects: visuals.animatedTextObjectDescs,
	            dataViewMappings: [{
	                    single: { role: "Values" }
	                }],
	            supportsSelection: false,
	        };
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 149 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        visuals.basicShapeCapabilities = {
	            objects: {
	                line: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_BasicShape_Line'),
	                    properties: {
	                        lineColor: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_BasicShape_LineColor'),
	                            type: { fill: { solid: { color: true } } }
	                        },
	                        transparency: visuals.StandardObjectProperties.transparency,
	                        weight: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_BasicShape_Weight'),
	                            type: { numeric: true }
	                        },
	                        roundEdge: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_BasicShape_RoundEdges'),
	                            type: { numeric: true }
	                        }
	                    }
	                },
	                fill: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        fillColor: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_BasicShape_FillColor'),
	                            type: { fill: { solid: { color: true } } }
	                        },
	                        transparency: visuals.StandardObjectProperties.transparency,
	                    }
	                },
	                rotation: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_BasicShape_Rotate'),
	                    properties: {
	                        angle: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_BasicShape_Rotate'),
	                            type: { numeric: true }
	                        }
	                    }
	                },
	                general: {
	                    properties: {
	                        shapeType: {
	                            type: { text: true },
	                            suppressFormatPainterCopy: true,
	                        }
	                    }
	                }
	            },
	            suppressDefaultTitle: true,
	            suppressDefaultPadding: true,
	            canRotate: false,
	            supportsSelection: false,
	        };
	        visuals.basicShapeProps = {
	            general: {
	                shapeType: { objectName: 'general', propertyName: 'shapeType' },
	            },
	            line: {
	                transparency: { objectName: 'line', propertyName: 'transparency' },
	                weight: { objectName: 'line', propertyName: 'weight' },
	                roundEdge: { objectName: 'line', propertyName: 'roundEdge' },
	                lineColor: { objectName: 'line', propertyName: 'lineColor' }
	            },
	            fill: {
	                transparency: { objectName: 'fill', propertyName: 'transparency' },
	                fillColor: { objectName: 'fill', propertyName: 'fillColor' },
	                show: { objectName: 'fill', propertyName: 'show' }
	            },
	            rotation: {
	                angle: { objectName: 'rotation', propertyName: 'angle' }
	            }
	        };
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 150 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        function getColumnChartCapabilities(transposeAxes) {
	            if (transposeAxes === void 0) { transposeAxes = false; }
	            return {
	                dataRoles: [
	                    {
	                        name: 'Category',
	                        kind: powerbi.VisualDataRoleKind.Grouping,
	                        displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Axis'),
	                        description: powerbi.data.createDisplayNameGetter('Role_DisplayName_AxisDescription'),
	                        cartesianKind: 0 /* X */,
	                    }, {
	                        name: 'Series',
	                        kind: powerbi.VisualDataRoleKind.Grouping,
	                        displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Legend'),
	                        description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LegendDescription')
	                    }, {
	                        name: 'Y',
	                        kind: powerbi.VisualDataRoleKind.Measure,
	                        displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Value'),
	                        requiredTypes: [{ numeric: true }, { integer: true }],
	                        cartesianKind: 1 /* Y */,
	                    }, {
	                        name: 'Gradient',
	                        kind: powerbi.VisualDataRoleKind.Measure,
	                        displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Gradient'),
	                        description: powerbi.data.createDisplayNameGetter('Role_DisplayName_GradientDescription'),
	                        requiredTypes: [{ numeric: true }, { integer: true }],
	                        joinPredicate: 0 /* None */,
	                    }
	                ],
	                objects: {
	                    general: {
	                        displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
	                        properties: {
	                            formatString: visuals.StandardObjectProperties.formatString,
	                        },
	                    },
	                    legend: {
	                        displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
	                        description: powerbi.data.createDisplayNameGetter('Visual_LegendDescription'),
	                        properties: {
	                            show: visuals.StandardObjectProperties.show,
	                            position: visuals.StandardObjectProperties.legendPosition,
	                            showTitle: visuals.StandardObjectProperties.showLegendTitle,
	                            titleText: $.extend({}, visuals.StandardObjectProperties.legendTitle, {
	                                suppressFormatPainterCopy: true
	                            }),
	                            labelColor: visuals.StandardObjectProperties.labelColor,
	                            fontSize: visuals.StandardObjectProperties.fontSize,
	                        }
	                    },
	                    categoryAxis: {
	                        displayName: transposeAxes ? powerbi.data.createDisplayNameGetter('Visual_YAxis') : powerbi.data.createDisplayNameGetter('Visual_XAxis'),
	                        properties: {
	                            show: visuals.StandardObjectProperties.show,
	                            position: visuals.StandardObjectProperties.yAxisPosition,
	                            axisScale: visuals.StandardObjectProperties.axisScale,
	                            start: visuals.StandardObjectProperties.axisStart,
	                            end: visuals.StandardObjectProperties.axisEnd,
	                            axisType: visuals.StandardObjectProperties.axisType,
	                            showAxisTitle: {
	                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
	                                description: transposeAxes ? powerbi.data.createDisplayNameGetter('Visual_Axis_YTitleDescription') : powerbi.data.createDisplayNameGetter('Visual_Axis_XTitleDescription'),
	                                type: { bool: true }
	                            },
	                            axisStyle: visuals.StandardObjectProperties.axisStyle,
	                            labelColor: visuals.StandardObjectProperties.labelColor,
	                            labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
	                            labelPrecision: visuals.StandardObjectProperties.labelPrecision,
	                        }
	                    },
	                    valueAxis: {
	                        displayName: transposeAxes ? powerbi.data.createDisplayNameGetter('Visual_XAxis') : powerbi.data.createDisplayNameGetter('Visual_YAxis'),
	                        properties: {
	                            show: visuals.StandardObjectProperties.show,
	                            position: visuals.StandardObjectProperties.yAxisPosition,
	                            axisScale: visuals.StandardObjectProperties.axisScale,
	                            start: visuals.StandardObjectProperties.axisStart,
	                            end: visuals.StandardObjectProperties.axisEnd,
	                            intersection: {
	                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Intersection'),
	                                type: { numeric: true },
	                                placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
	                            },
	                            showAxisTitle: {
	                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
	                                description: transposeAxes ? powerbi.data.createDisplayNameGetter('Visual_Axis_YTitleDescription') : powerbi.data.createDisplayNameGetter('Visual_Axis_XTitleDescription'),
	                                type: { bool: true }
	                            },
	                            axisStyle: visuals.StandardObjectProperties.axisStyle,
	                            labelColor: visuals.StandardObjectProperties.labelColor,
	                            labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
	                            labelPrecision: visuals.StandardObjectProperties.labelPrecision,
	                        }
	                    },
	                    y1AxisReferenceLine: {
	                        displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line'),
	                        description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Description'),
	                        properties: {
	                            show: visuals.StandardObjectProperties.show,
	                            displayName: {
	                                displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_DisplayName'),
	                                description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_DisplayName_Description'),
	                                type: { text: true }
	                            },
	                            value: {
	                                displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value'),
	                                description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value_Description'),
	                                type: { numeric: true }
	                            },
	                            lineColor: visuals.StandardObjectProperties.lineColor,
	                            transparency: {
	                                displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency'),
	                                description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency_Description'),
	                                type: { numeric: true }
	                            },
	                            style: visuals.StandardObjectProperties.referenceLineStyle,
	                            position: visuals.StandardObjectProperties.referenceLinePosition,
	                            dataLabelShow: visuals.StandardObjectProperties.dataLabelShow,
	                            dataLabelColor: visuals.StandardObjectProperties.dataLabelColor,
	                            dataLabelDecimalPoints: visuals.StandardObjectProperties.dataLabelDecimalPoints,
	                            dataLabelHorizontalPosition: visuals.StandardObjectProperties.dataLabelHorizontalPosition,
	                            dataLabelVerticalPosition: visuals.StandardObjectProperties.dataLabelVerticalPosition,
	                            dataLabelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits,
	                        },
	                    },
	                    referenceLine: {
	                        displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line'),
	                        description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Description'),
	                        properties: {
	                            show: visuals.StandardObjectProperties.show,
	                            displayName: {
	                                displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_DisplayName'),
	                                description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_DisplayName_Description'),
	                                type: { text: true }
	                            },
	                            value: {
	                                displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value'),
	                                description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value_Description'),
	                                type: { numeric: true }
	                            },
	                            lineColor: visuals.StandardObjectProperties.lineColor,
	                            transparency: {
	                                displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency'),
	                                description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency_Description'),
	                                type: { numeric: true }
	                            },
	                            style: visuals.StandardObjectProperties.referenceLineStyle,
	                            position: visuals.StandardObjectProperties.referenceLinePosition,
	                            dataLabelShow: visuals.StandardObjectProperties.dataLabelShow,
	                            dataLabelColor: visuals.StandardObjectProperties.dataLabelColor,
	                            dataLabelDecimalPoints: visuals.StandardObjectProperties.dataLabelDecimalPoints,
	                            dataLabelHorizontalPosition: visuals.StandardObjectProperties.dataLabelHorizontalPosition,
	                            dataLabelVerticalPosition: visuals.StandardObjectProperties.dataLabelVerticalPosition,
	                            dataLabelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits,
	                        },
	                    },
	                    dataPoint: {
	                        displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
	                        description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
	                        properties: {
	                            defaultColor: visuals.StandardObjectProperties.defaultColor,
	                            showAllDataPoints: visuals.StandardObjectProperties.showAllDataPoints,
	                            fill: visuals.StandardObjectProperties.fill,
	                            fillRule: {
	                                displayName: powerbi.data.createDisplayNameGetter('Visual_Gradient'),
	                                type: { fillRule: {} },
	                                rule: {
	                                    inputRole: 'Gradient',
	                                    output: {
	                                        property: 'fill',
	                                        selector: ['Category'],
	                                    },
	                                },
	                            }
	                        }
	                    },
	                    trend: {
	                        displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line'),
	                        properties: {
	                            show: {
	                                type: { bool: true }
	                            },
	                            displayName: {
	                                displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_DisplayName'),
	                                description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_DisplayName_Description'),
	                                type: { text: true }
	                            },
	                            lineColor: {
	                                displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Color'),
	                                description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Color_Description'),
	                                type: { fill: { solid: { color: true } } }
	                            },
	                            transparency: {
	                                displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Transparency'),
	                                description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Transparency_Description'),
	                                type: { numeric: true }
	                            },
	                            style: {
	                                displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Style'),
	                                description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Style_Description'),
	                                type: { enumeration: visuals.lineStyle.type }
	                            },
	                            combineSeries: {
	                                displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Combine_Series'),
	                                description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Combine_Series_Description'),
	                                type: { bool: true }
	                            },
	                            useHighlightValues: {
	                                displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_UseHighlightValues'),
	                                description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_UseHighlightValues_Description'),
	                                type: { bool: true }
	                            },
	                        }
	                    },
	                    labels: {
	                        displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
	                        description: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabelsDescription'),
	                        properties: {
	                            show: visuals.StandardObjectProperties.show,
	                            showSeries: {
	                                displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
	                                type: { bool: true }
	                            },
	                            color: visuals.StandardObjectProperties.dataColor,
	                            labelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits,
	                            labelPrecision: $.extend({}, visuals.StandardObjectProperties.labelPrecision, {
	                                suppressFormatPainterCopy: true
	                            }),
	                            showAll: {
	                                displayName: powerbi.data.createDisplayNameGetter('Visual_LabelSeriesShowAll'),
	                                type: { bool: true }
	                            },
	                            fontSize: visuals.StandardObjectProperties.fontSize,
	                        },
	                    },
	                    plotArea: {
	                        displayName: powerbi.data.createDisplayNameGetter('Visual_Plot'),
	                        //description: data.createDisplayNameGetter('Visual_PlotDescription'),
	                        properties: {
	                            transparency: visuals.StandardObjectProperties.transparency,
	                            image: visuals.StandardObjectProperties.image,
	                        },
	                    },
	                },
	                dataViewMappings: [{
	                        conditions: [
	                            { 'Category': { max: 1 }, 'Series': { max: 0 }, 'Gradient': { max: 0 } },
	                            { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 }, 'Gradient': { max: 0 } },
	                            { 'Category': { max: 1 }, 'Series': { max: 0 }, 'Y': { min: 0, max: 1 }, 'Gradient': { max: 1 } },
	                        ],
	                        categorical: {
	                            categories: {
	                                for: { in: 'Category' },
	                                dataReductionAlgorithm: { window: { count: 100 } }
	                            },
	                            values: {
	                                group: {
	                                    by: 'Series',
	                                    select: [{ for: { in: 'Y' } }, { bind: { to: 'Gradient' } }],
	                                    dataReductionAlgorithm: { top: { count: 60 } }
	                                }
	                            },
	                            rowCount: { preferred: { min: 2 }, supported: { min: 0 } }
	                        },
	                    }, {
	                        conditions: [
	                            { 'Category': { max: 1 }, 'Series': { max: 0 }, 'Gradient': { max: 0 } },
	                            { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 }, 'Gradient': { max: 0 } },
	                            { 'Category': { max: 1 }, 'Series': { max: 0 }, 'Y': { min: 0, max: 1 }, 'Gradient': { max: 1 } },
	                        ],
	                        requiredProperties: [{ objectName: 'trend', propertyName: 'show' }],
	                        usage: {
	                            regression: {
	                                combineSeries: { objectName: 'trend', propertyName: 'combineSeries' }
	                            },
	                        },
	                        categorical: {
	                            categories: {
	                                for: { in: 'regression.X' },
	                            },
	                            values: {
	                                group: {
	                                    by: 'regression.Series',
	                                    select: [{ for: { in: 'regression.Y' } }],
	                                },
	                            }
	                        }
	                    }],
	                supportsHighlight: true,
	                sorting: {
	                    default: {},
	                },
	                drilldown: {
	                    roles: ['Category']
	                },
	            };
	        }
	        visuals.getColumnChartCapabilities = getColumnChartCapabilities;
	        visuals.columnChartProps = {
	            dataPoint: {
	                defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
	                fill: { objectName: 'dataPoint', propertyName: 'fill' },
	                showAllDataPoints: { objectName: 'dataPoint', propertyName: 'showAllDataPoints' },
	            },
	            general: {
	                formatString: { objectName: 'general', propertyName: 'formatString' },
	            },
	            categoryAxis: {
	                axisType: { objectName: 'categoryAxis', propertyName: 'axisType' },
	            },
	            legend: {
	                labelColor: { objectName: 'legend', propertyName: 'labelColor' },
	            },
	            plotArea: {
	                image: { objectName: 'plotArea', propertyName: 'image' },
	                transparency: { objectName: 'plotArea', propertyName: 'transparency' },
	            },
	        };
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 151 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        visuals.comboChartCapabilities = {
	            dataRoles: [
	                {
	                    name: 'Category',
	                    kind: powerbi.VisualDataRoleKind.Grouping,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_ComboChart_Category'),
	                    description: powerbi.data.createDisplayNameGetter('Role_ComboChart_CategoryDescription'),
	                    cartesianKind: 0 /* X */,
	                }, {
	                    name: 'Series',
	                    kind: powerbi.VisualDataRoleKind.Grouping,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_ComboChart_Series'),
	                }, {
	                    name: 'Y',
	                    kind: powerbi.VisualDataRoleKind.Measure,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_ComboChart_Y'),
	                    description: powerbi.data.createDisplayNameGetter('Role_ComboChart_YDescription'),
	                    requiredTypes: [{ numeric: true }, { integer: true }],
	                    cartesianKind: 1 /* Y */,
	                }, {
	                    name: 'Y2',
	                    kind: powerbi.VisualDataRoleKind.Measure,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_ComboChart_Y2'),
	                    description: powerbi.data.createDisplayNameGetter('Role_ComboChart_Y2Description'),
	                    requiredTypes: [{ numeric: true }, { integer: true }],
	                    cartesianKind: 1 /* Y */,
	                },
	            ],
	            objects: {
	                general: {
	                    properties: {
	                        formatString: visuals.StandardObjectProperties.formatString,
	                        visualType1: {
	                            type: { text: true }
	                        },
	                        visualType2: {
	                            type: { text: true }
	                        },
	                    },
	                },
	                legend: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
	                    description: powerbi.data.createDisplayNameGetter('Visual_LegendDescription'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        position: visuals.StandardObjectProperties.legendPosition,
	                        showTitle: visuals.StandardObjectProperties.showLegendTitle,
	                        titleText: $.extend({}, visuals.StandardObjectProperties.legendTitle, {
	                            suppressFormatPainterCopy: true
	                        }),
	                        labelColor: visuals.StandardObjectProperties.labelColor,
	                        fontSize: visuals.StandardObjectProperties.fontSize,
	                    }
	                },
	                categoryAxis: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_XAxis'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        axisScale: visuals.StandardObjectProperties.axisScale,
	                        start: visuals.StandardObjectProperties.axisStart,
	                        end: visuals.StandardObjectProperties.axisEnd,
	                        axisType: visuals.StandardObjectProperties.axisType,
	                        showAxisTitle: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_XTitleDescription'),
	                            type: { bool: true }
	                        },
	                        axisStyle: visuals.StandardObjectProperties.axisStyle,
	                        labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
	                        labelPrecision: visuals.StandardObjectProperties.labelPrecision,
	                    }
	                },
	                valueAxis: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        axisLabel: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_ColumnTitle'),
	                            type: { none: true },
	                        },
	                        position: visuals.StandardObjectProperties.yAxisPosition,
	                        axisScale: visuals.StandardObjectProperties.axisScale,
	                        start: visuals.StandardObjectProperties.axisStart,
	                        end: visuals.StandardObjectProperties.axisEnd,
	                        showAxisTitle: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_YTitleDescription'),
	                            type: { bool: true }
	                        },
	                        axisStyle: visuals.StandardObjectProperties.axisStyle,
	                        labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
	                        labelPrecision: visuals.StandardObjectProperties.labelPrecision,
	                        secShow: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_ShowSecondary'),
	                            type: { bool: true },
	                        },
	                        secAxisLabel: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_LineTitle'),
	                            type: { none: true },
	                        },
	                        secPosition: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_Position'),
	                            type: { enumeration: visuals.yAxisPosition.type },
	                        },
	                        secAxisScale: visuals.StandardObjectProperties.axisScale,
	                        secStart: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Start'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_StartDescription'),
	                            type: { numeric: true },
	                        },
	                        secEnd: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_End'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_EndDescription'),
	                            type: { numeric: true },
	                        },
	                        secShowAxisTitle: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_YTitleDescription'),
	                            type: { bool: true },
	                        },
	                        secAxisStyle: visuals.StandardObjectProperties.axisStyle,
	                        secLabelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
	                        secLabelPrecision: visuals.StandardObjectProperties.labelPrecision,
	                    }
	                },
	                dataPoint: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
	                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
	                    properties: {
	                        defaultColor: $.extend({}, visuals.StandardObjectProperties.defaultColor, {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_DefaultColumnColor'),
	                        }),
	                        showAllDataPoints: visuals.StandardObjectProperties.showAllDataPoints,
	                        fill: visuals.StandardObjectProperties.fill,
	                        fillRule: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Gradient'),
	                            type: { fillRule: {} },
	                            rule: {
	                                inputRole: 'Gradient',
	                                output: {
	                                    property: 'fill',
	                                    selector: ['Category'],
	                                },
	                            },
	                        }
	                    }
	                },
	                labels: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
	                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabelsDescription'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        color: visuals.StandardObjectProperties.dataColor,
	                        labelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits,
	                        labelPrecision: $.extend({}, visuals.StandardObjectProperties.labelPrecision, {
	                            suppressFormatPainterCopy: true,
	                        }),
	                        fontSize: visuals.StandardObjectProperties.fontSize,
	                        labelDensity: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_LabelDensity'),
	                            type: { formatting: { labelDensity: true } },
	                        },
	                    },
	                },
	                plotArea: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Plot'),
	                    properties: {
	                        transparency: visuals.StandardObjectProperties.transparency,
	                        image: visuals.StandardObjectProperties.image,
	                    },
	                },
	                trend: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line'),
	                    properties: {
	                        show: {
	                            type: { bool: true }
	                        },
	                        displayName: {
	                            type: { text: true }
	                        },
	                        lineColor: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Color'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Color_Description'),
	                            type: { fill: { solid: { color: true } } }
	                        },
	                        transparency: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Transparency'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Transparency_Description'),
	                            type: { numeric: true }
	                        },
	                        style: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Style'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Style_Description'),
	                            type: { enumeration: visuals.lineStyle.type }
	                        },
	                        combineSeries: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Combine_Series'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Combine_Series_Description'),
	                            type: { bool: true }
	                        },
	                        useHighlightValues: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_UseHighlightValues'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_UseHighlightValues_Description'),
	                            type: { bool: true }
	                        },
	                    }
	                },
	            },
	            dataViewMappings: [
	                {
	                    conditions: [
	                        { 'Category': { max: 1 }, 'Series': { max: 0 } },
	                        { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 } },
	                    ],
	                    categorical: {
	                        categories: {
	                            for: { in: 'Category' },
	                            dataReductionAlgorithm: { window: { count: 100 } }
	                        },
	                        values: {
	                            group: {
	                                by: 'Series',
	                                select: [
	                                    { for: { in: 'Y' } }
	                                ],
	                                dataReductionAlgorithm: { top: { count: 60 } }
	                            }
	                        },
	                        rowCount: { preferred: { min: 2 }, supported: { min: 0 } }
	                    }
	                }, {
	                    conditions: [
	                        { 'Category': { max: 1 }, 'Series': { max: 0 }, 'Y2': { min: 1 } },
	                        { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 }, 'Y2': { min: 1 } },
	                    ],
	                    categorical: {
	                        categories: {
	                            for: { in: 'Category' },
	                            dataReductionAlgorithm: { window: { count: 100 } }
	                        },
	                        values: {
	                            select: [
	                                { for: { in: 'Y2' } }
	                            ],
	                        },
	                        rowCount: { preferred: { min: 2 }, supported: { min: 0 } }
	                    },
	                }, {
	                    conditions: [
	                        { 'Category': { max: 1 }, 'Series': { max: 0 } },
	                        { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 } },
	                    ],
	                    requiredProperties: [{ objectName: 'trend', propertyName: 'show' }],
	                    usage: {
	                        regression: {
	                            combineSeries: { objectName: 'trend', propertyName: 'combineSeries' }
	                        },
	                    },
	                    categorical: {
	                        categories: {
	                            for: { in: 'regression.X' }
	                        },
	                        values: {
	                            group: {
	                                by: 'regression.Series',
	                                select: [{ for: { in: 'regression.Y' } }],
	                            },
	                        },
	                    }
	                },
	            ],
	            supportsHighlight: true,
	            sorting: {
	                default: {},
	            },
	            drilldown: {
	                roles: ['Category']
	            },
	        };
	        visuals.comboChartProps = {
	            general: {
	                formatString: { objectName: 'general', propertyName: 'formatString' },
	            },
	            valueAxis: {
	                secShow: { objectName: 'valueAxis', propertyName: 'secShow' },
	            },
	            legend: {
	                labelColor: { objectName: 'legend', propertyName: 'labelColor' },
	            },
	            dataPoint: {
	                showAllDataPoints: { objectName: 'dataPoint', propertyName: 'showAllDataPoints' },
	            },
	        };
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 152 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        visuals.donutChartCapabilities = {
	            dataRoles: [
	                {
	                    name: 'Category',
	                    kind: powerbi.VisualDataRoleKind.Grouping,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Legend'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LegendDescription')
	                }, {
	                    name: 'Series',
	                    kind: powerbi.VisualDataRoleKind.Grouping,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Details'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_DetailsDonutChartDescription'),
	                }, {
	                    name: 'Y',
	                    kind: powerbi.VisualDataRoleKind.Measure,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_ValuesDescription'),
	                    requiredTypes: [{ numeric: true }, { integer: true }],
	                }
	            ],
	            objects: {
	                general: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
	                    properties: {
	                        formatString: visuals.StandardObjectProperties.formatString,
	                    },
	                },
	                legend: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
	                    description: powerbi.data.createDisplayNameGetter('Visual_LegendDescription'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        position: visuals.StandardObjectProperties.legendPosition,
	                        showTitle: visuals.StandardObjectProperties.showLegendTitle,
	                        titleText: $.extend({}, visuals.StandardObjectProperties.legendTitle, {
	                            suppressFormatPainterCopy: true
	                        }),
	                        labelColor: visuals.StandardObjectProperties.labelColor,
	                        fontSize: visuals.StandardObjectProperties.fontSize,
	                    }
	                },
	                dataPoint: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
	                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
	                    properties: {
	                        defaultColor: visuals.StandardObjectProperties.defaultColor,
	                        fill: visuals.StandardObjectProperties.fill,
	                    }
	                },
	                labels: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_DetailLabels'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        color: visuals.StandardObjectProperties.dataColor,
	                        labelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits,
	                        labelPrecision: $.extend({}, visuals.StandardObjectProperties.labelPrecision, {
	                            suppressFormatPainterCopy: true,
	                        }),
	                        fontSize: $.extend({}, visuals.StandardObjectProperties.fontSize, {
	                            suppressFormatPainterCopy: true,
	                        }),
	                        labelStyle: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_LabelStyle'),
	                            type: { enumeration: visuals.labelStyle.type }
	                        },
	                    },
	                },
	            },
	            dataViewMappings: [{
	                    conditions: [
	                        { 'Category': { max: 1 }, 'Series': { max: 0 } },
	                        { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 } }
	                    ],
	                    categorical: {
	                        categories: {
	                            for: { in: 'Category' },
	                            dataReductionAlgorithm: { top: {} }
	                        },
	                        values: {
	                            group: {
	                                by: 'Series',
	                                select: [{ bind: { to: 'Y' } }],
	                                dataReductionAlgorithm: { top: {} }
	                            }
	                        },
	                        rowCount: { preferred: { min: 2 }, supported: { min: 1 } }
	                    },
	                }],
	            sorting: {
	                default: {},
	            },
	            supportsHighlight: true,
	            drilldown: {
	                roles: ['Category']
	            },
	        };
	        visuals.donutChartProps = {
	            general: {
	                formatString: { objectName: 'general', propertyName: 'formatString' },
	            },
	            dataPoint: {
	                defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
	                fill: { objectName: 'dataPoint', propertyName: 'fill' },
	            },
	            legend: {
	                show: { objectName: 'legend', propertyName: 'show' },
	                position: { objectName: 'legend', propertyName: 'position' },
	                showTitle: { objectName: 'legend', propertyName: 'showTitle' },
	                titleText: { objectName: 'legend', propertyName: 'titleText' },
	                labelColor: { objectName: 'legend', propertyName: 'labelColor' },
	            },
	        };
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 153 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        // I support a categorical (ordinal) X with measure Y for a single series
	        visuals.dataDotChartCapabilities = {
	            dataRoles: [
	                {
	                    name: 'Category',
	                    kind: powerbi.VisualDataRoleKind.Grouping,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Axis'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_AxisDescription')
	                }, {
	                    name: 'Y',
	                    kind: powerbi.VisualDataRoleKind.Measure,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Value'),
	                    requiredTypes: [{ numeric: true }, { integer: true }]
	                },
	            ],
	            objects: {
	                general: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
	                    properties: {
	                        formatString: visuals.StandardObjectProperties.formatString,
	                    },
	                },
	            },
	            dataViewMappings: [{
	                    conditions: [
	                        { 'Category': { max: 1 }, 'Y': { max: 1 } }
	                    ],
	                    categorical: {
	                        categories: {
	                            for: { in: 'Category' },
	                            dataReductionAlgorithm: { top: {} }
	                        },
	                        values: {
	                            select: [{
	                                    for: { in: 'Y' },
	                                }]
	                        },
	                    },
	                }]
	        };
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 154 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        visuals.filledMapCapabilities = {
	            dataRoles: [
	                {
	                    name: 'Category',
	                    kind: powerbi.VisualDataRoleKind.Grouping,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Location'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LocationFilledMapDescription'),
	                    preferredTypes: [
	                        { geography: { address: true } },
	                        { geography: { city: true } },
	                        { geography: { continent: true } },
	                        { geography: { country: true } },
	                        { geography: { county: true } },
	                        { geography: { place: true } },
	                        { geography: { postalCode: true } },
	                        { geography: { region: true } },
	                        { geography: { stateOrProvince: true } },
	                    ],
	                }, {
	                    name: 'Series',
	                    kind: powerbi.VisualDataRoleKind.Grouping,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Legend'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LegendDescription')
	                }, {
	                    name: 'Y',
	                    kind: powerbi.VisualDataRoleKind.Measure,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Latitude'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LatitudeFilledMapDescription'),
	                    preferredTypes: [
	                        { geography: { latitude: true } }
	                    ],
	                }, {
	                    name: 'X',
	                    kind: powerbi.VisualDataRoleKind.Measure,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Longitude'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LongitudeFilledMapDescription'),
	                    preferredTypes: [
	                        { geography: { longitude: true } }
	                    ],
	                }, {
	                    name: 'Size',
	                    kind: powerbi.VisualDataRoleKind.Measure,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Gradient'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_GradientDescription'),
	                    requiredTypes: [{ numeric: true }, { integer: true }],
	                }
	            ],
	            objects: {
	                general: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
	                    properties: {
	                        formatString: visuals.StandardObjectProperties.formatString,
	                    },
	                },
	                legend: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
	                    description: powerbi.data.createDisplayNameGetter('Visual_LegendDescription'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        position: visuals.StandardObjectProperties.legendPosition,
	                        showTitle: visuals.StandardObjectProperties.showLegendTitle,
	                        titleText: visuals.StandardObjectProperties.legendTitle,
	                        fontSize: visuals.StandardObjectProperties.fontSize,
	                    }
	                },
	                dataPoint: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
	                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
	                    properties: {
	                        defaultColor: visuals.StandardObjectProperties.defaultColor,
	                        showAllDataPoints: visuals.StandardObjectProperties.showAllDataPoints,
	                        fill: visuals.StandardObjectProperties.fill,
	                        fillRule: {
	                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),
	                            description: powerbi.data.createDisplayNameGetter('Role_DisplayName_ValuesDescription'),
	                            type: { fillRule: {} },
	                            rule: {
	                                inputRole: 'Size',
	                                output: {
	                                    property: 'fill',
	                                    selector: ['Category'],
	                                },
	                            },
	                        }
	                    }
	                },
	                labels: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        color: visuals.StandardObjectProperties.dataColor,
	                        labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
	                        labelPrecision: visuals.StandardObjectProperties.labelPrecision,
	                    },
	                },
	                categoryLabels: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_CategoryLabels'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                    },
	                }
	            },
	            dataViewMappings: [{
	                    conditions: [
	                        { 'Category': { max: 1 }, 'Series': { max: 1 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 1 } },
	                        { 'Category': { max: 1 }, 'Series': { max: 0 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 1 } }
	                    ],
	                    categorical: {
	                        categories: {
	                            for: { in: 'Category' },
	                            dataReductionAlgorithm: { top: {} }
	                        },
	                        values: {
	                            group: {
	                                by: 'Series',
	                                select: [
	                                    { bind: { to: 'X' } },
	                                    { bind: { to: 'Y' } },
	                                    { bind: { to: 'Size' } },
	                                ],
	                                dataReductionAlgorithm: { top: {} }
	                            }
	                        },
	                        rowCount: { preferred: { min: 2 } },
	                        dataVolume: 4,
	                    },
	                }],
	            sorting: {
	                custom: {},
	                implicit: {
	                    clauses: [{ role: 'Size', direction: 2 /* Descending */ }]
	                },
	            },
	            drilldown: {
	                roles: ['Category']
	            },
	        };
	        visuals.filledMapProps = {
	            general: {
	                formatString: { objectName: 'general', propertyName: 'formatString' },
	            },
	            dataPoint: {
	                defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
	                fill: { objectName: 'dataPoint', propertyName: 'fill' },
	                showAllDataPoints: { objectName: 'dataPoint', propertyName: 'showAllDataPoints' },
	            },
	            legend: {
	                show: { objectName: 'legend', propertyName: 'show' },
	                position: { objectName: 'legend', propertyName: 'position' },
	                showTitle: { objectName: 'legend', propertyName: 'showTitle' },
	                titleText: { objectName: 'legend', propertyName: 'titleText' },
	            },
	            labels: {
	                show: { objectName: 'labels', propertyName: 'show' },
	                color: { objectName: 'labels', propertyName: 'color' },
	                labelDisplayUnits: { objectName: 'labels', propertyName: 'labelDisplayUnits' },
	                labelPrecision: { objectName: 'labels', propertyName: 'labelPrecision' },
	            },
	            categoryLabels: {
	                show: { objectName: 'categoryLabels', propertyName: 'show' },
	            }
	        };
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 155 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        visuals.funnelChartCapabilities = {
	            dataRoles: [
	                {
	                    name: 'Category',
	                    kind: powerbi.VisualDataRoleKind.Grouping,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Group'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_GroupFunnelDescription')
	                }, {
	                    name: 'Y',
	                    kind: powerbi.VisualDataRoleKind.Measure,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_ValuesDescription'),
	                    requiredTypes: [{ numeric: true }, { integer: true }],
	                }, {
	                    name: 'Gradient',
	                    kind: powerbi.VisualDataRoleKind.Measure,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Gradient'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_GradientDescription'),
	                    requiredTypes: [{ numeric: true }, { integer: true }],
	                    joinPredicate: 0 /* None */,
	                }
	            ],
	            dataViewMappings: [{
	                    conditions: [
	                        // NOTE: Ordering of the roles prefers to add measures to Y before Gradient.
	                        { 'Category': { max: 0 }, 'Gradient': { max: 0 } },
	                        { 'Category': { max: 1 }, 'Y': { max: 1 }, 'Gradient': { max: 1 } },
	                    ],
	                    categorical: {
	                        categories: {
	                            for: { in: 'Category' },
	                            dataReductionAlgorithm: { top: {} }
	                        },
	                        values: {
	                            select: [{ for: { in: 'Y' } }, { bind: { to: 'Gradient' } }],
	                        },
	                        rowCount: { preferred: { min: 1 } }
	                    },
	                }],
	            objects: {
	                general: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
	                    properties: {
	                        formatString: visuals.StandardObjectProperties.formatString,
	                    },
	                },
	                dataPoint: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
	                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
	                    properties: {
	                        defaultColor: visuals.StandardObjectProperties.defaultColor,
	                        fill: visuals.StandardObjectProperties.fill,
	                        fillRule: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Gradient'),
	                            type: { fillRule: {} },
	                            rule: {
	                                inputRole: 'Gradient',
	                                output: {
	                                    property: 'fill',
	                                    selector: ['Category'],
	                                },
	                            },
	                        }
	                    }
	                },
	                labels: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
	                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabelsDescription'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        color: visuals.StandardObjectProperties.dataColor,
	                        labelPosition: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Position'),
	                            type: { enumeration: visuals.labelPosition.type },
	                            suppressFormatPainterCopy: true,
	                        },
	                        labelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits,
	                        labelPrecision: $.extend({}, visuals.StandardObjectProperties.labelPrecision, {
	                            suppressFormatPainterCopy: true,
	                        }),
	                        fontSize: visuals.StandardObjectProperties.fontSize,
	                    }
	                },
	                percentBarLabel: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_PercentBarLabel'),
	                    description: powerbi.data.createDisplayNameGetter('Visual_PercentBarLabelDescription'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        color: visuals.StandardObjectProperties.dataColor,
	                        fontSize: visuals.StandardObjectProperties.fontSize,
	                    }
	                },
	            },
	            supportsHighlight: true,
	            sorting: {
	                default: {},
	            },
	            drilldown: {
	                roles: ['Category']
	            },
	        };
	        visuals.funnelChartProps = {
	            general: {
	                formatString: { objectName: 'general', propertyName: 'formatString' },
	            },
	            dataPoint: {
	                defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
	                fill: { objectName: 'dataPoint', propertyName: 'fill' },
	            },
	        };
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 156 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        visuals.gaugeRoleNames = {
	            y: 'Y',
	            minValue: 'MinValue',
	            maxValue: 'MaxValue',
	            targetValue: 'TargetValue'
	        };
	        visuals.gaugeCapabilities = {
	            dataRoles: [
	                {
	                    name: visuals.gaugeRoleNames.y,
	                    kind: powerbi.VisualDataRoleKind.Measure,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Value'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_ValueDescription'),
	                    requiredTypes: [{ numeric: true }, { integer: true }],
	                }, {
	                    name: visuals.gaugeRoleNames.minValue,
	                    kind: powerbi.VisualDataRoleKind.Measure,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_MinValue'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_MinValueDescription'),
	                    requiredTypes: [{ numeric: true }, { integer: true }],
	                }, {
	                    name: visuals.gaugeRoleNames.maxValue,
	                    kind: powerbi.VisualDataRoleKind.Measure,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_MaxValue'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_MaxValueDescription'),
	                    requiredTypes: [{ numeric: true }, { integer: true }],
	                }, {
	                    name: visuals.gaugeRoleNames.targetValue,
	                    kind: powerbi.VisualDataRoleKind.Measure,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_TargetValue'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_TargetValueDescription'),
	                    requiredTypes: [{ numeric: true }, { integer: true }],
	                }
	            ],
	            objects: {
	                general: {
	                    properties: {
	                        formatString: visuals.StandardObjectProperties.formatString,
	                    },
	                },
	                axis: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Gauge_Axis'),
	                    properties: {
	                        min: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Gauge_Axis_Min'),
	                            type: { numeric: true }
	                        },
	                        max: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Gauge_Axis_Max'),
	                            type: { numeric: true }
	                        },
	                        target: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Gauge_Axis_Target'),
	                            type: { numeric: true }
	                        },
	                    },
	                },
	                labels: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        color: visuals.StandardObjectProperties.dataColor,
	                        labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
	                        labelPrecision: visuals.StandardObjectProperties.labelPrecision,
	                        fontSize: visuals.StandardObjectProperties.fontSize,
	                    },
	                },
	                calloutValue: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Gauge_CalloutValue'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        color: visuals.StandardObjectProperties.dataColor,
	                        labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
	                        labelPrecision: visuals.StandardObjectProperties.labelPrecision,
	                    },
	                },
	                dataPoint: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
	                    properties: {
	                        fill: visuals.StandardObjectProperties.fill,
	                        target: {
	                            // TODO find a better string
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Gauge_Axis_Target'),
	                            type: { fill: { solid: { color: true } } }
	                        }
	                    }
	                }
	            },
	            dataViewMappings: [{
	                    conditions: [
	                        { 'Y': { max: 1 }, 'MinValue': { max: 1 }, 'MaxValue': { max: 1 }, 'TargetValue': { max: 1 } },
	                    ],
	                    categorical: {
	                        values: {
	                            select: [
	                                { bind: { to: 'Y' } },
	                                { bind: { to: 'MinValue' } },
	                                { bind: { to: 'MaxValue' } },
	                                { bind: { to: 'TargetValue' } },
	                            ]
	                        },
	                    },
	                }],
	            supportsSelection: false,
	        };
	        visuals.gaugeProps = {
	            dataPoint: {
	                fill: { objectName: 'dataPoint', propertyName: 'fill' },
	                target: { objectName: 'dataPoint', propertyName: 'target' }
	            }
	        };
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 157 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        visuals.imageVisualCapabilities = {
	            objects: {
	                general: {
	                    properties: {
	                        imageUrl: {
	                            type: { misc: { imageUrl: true } },
	                            suppressFormatPainterCopy: true,
	                        }
	                    }
	                },
	                imageScaling: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Image_Scaling_Type'),
	                    properties: {
	                        imageScalingType: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Image_Scaling_Type'),
	                            type: { enumeration: visuals.imageScalingType.type }
	                        },
	                    }
	                },
	            },
	            suppressDefaultTitle: true,
	            supportsSelection: false,
	        };
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 158 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        visuals.scriptVisualCapabilities = {
	            dataRoles: [{
	                    name: 'Values',
	                    kind: powerbi.VisualDataRoleKind.GroupingOrMeasure,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),
	                }],
	            dataViewMappings: [{
	                    scriptResult: {
	                        dataInput: {
	                            table: {
	                                rows: {
	                                    for: {
	                                        in: 'Values'
	                                    },
	                                    dataReductionAlgorithm: {
	                                        top: {}
	                                    }
	                                },
	                            },
	                        },
	                        script: {
	                            source: {
	                                objectName: 'script',
	                                propertyName: 'source'
	                            },
	                            provider: {
	                                objectName: 'script',
	                                propertyName: 'provider'
	                            },
	                        }
	                    }
	                }],
	            objects: {
	                script: {
	                    properties: {
	                        provider: {
	                            type: { text: true }
	                        },
	                        source: {
	                            type: { scripting: { source: true }
	                            }
	                        },
	                    }
	                },
	            },
	        };
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 159 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	*  Power BI Visualizations
	*
	*  Copyright (c) Microsoft Corporation
	*  All rights reserved.
	*  MIT License
	*
	*  Permission is hereby granted, free of charge, to any person obtaining a copy
	*  of this software and associated documentation files (the ""Software""), to deal
	*  in the Software without restriction, including without limitation the rights
	*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	*  copies of the Software, and to permit persons to whom the Software is
	*  furnished to do so, subject to the following conditions:
	*
	*  The above copyright notice and this permission notice shall be included in
	*  all copies or substantial portions of the Software.
	*
	*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	*  THE SOFTWARE.
	*/
	/// <reference path="../../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var samples;
	        (function (samples) {
	            samples.consoleWriterCapabilities = {
	                dataRoles: [
	                    {
	                        name: 'Category',
	                        kind: powerbi.VisualDataRoleKind.Grouping,
	                        displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Axis'),
	                        description: powerbi.data.createDisplayNameGetter('Role_DisplayName_AxisDescription')
	                    },
	                    {
	                        name: 'Y',
	                        kind: powerbi.VisualDataRoleKind.Measure,
	                        displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Y'),
	                        description: powerbi.data.createDisplayNameGetter('Role_DisplayName_YDescription')
	                    },
	                ],
	                dataViewMappings: [{
	                        categorical: {
	                            categories: {
	                                for: { in: 'Category' },
	                            },
	                        },
	                    }],
	            };
	        })(samples = visuals.samples || (visuals.samples = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 160 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var samples;
	        (function (samples) {
	            var ConsoleWriter = (function () {
	                function ConsoleWriter() {
	                }
	                ConsoleWriter.converter = function (dataView) {
	                    window.console.log('converter');
	                    window.console.log(dataView);
	                    return {};
	                };
	                ConsoleWriter.prototype.init = function (options) {
	                    var div = d3.select(options.element.get(0)).append("div");
	                    div.append("h1").text("ConsoleWriter");
	                    div.append("p").text("This IVisual writes messages passed to it to the javscript console output. Check your console for the actual messages passed. For more information, click below");
	                    var anchor = div.append('a');
	                    anchor.attr('href', "http://microsoft.github.io/PowerBI-visuals/modules/powerbi.html")
	                        .text("Online help");
	                    window.console.log('init');
	                    window.console.log(options);
	                };
	                ConsoleWriter.prototype.onResizing = function (viewport) { };
	                ConsoleWriter.prototype.update = function (options) {
	                    window.console.log('update');
	                    window.console.log(options);
	                };
	                return ConsoleWriter;
	            }());
	            samples.ConsoleWriter = ConsoleWriter;
	        })(samples = visuals.samples || (visuals.samples = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 161 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        visuals.lineChartCapabilities = {
	            dataRoles: [
	                {
	                    name: 'Category',
	                    kind: powerbi.VisualDataRoleKind.Grouping,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Axis'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_AxisDescription'),
	                    cartesianKind: 0 /* X */,
	                }, {
	                    name: 'Series',
	                    kind: powerbi.VisualDataRoleKind.Grouping,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Legend'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LegendDescription')
	                }, {
	                    name: 'Y',
	                    kind: powerbi.VisualDataRoleKind.Measure,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_ValuesDescription'),
	                    requiredTypes: [{ numeric: true }, { integer: true }],
	                    cartesianKind: 1 /* Y */,
	                },
	            ],
	            objects: {
	                general: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
	                    properties: {
	                        formatString: visuals.StandardObjectProperties.formatString,
	                    },
	                },
	                legend: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
	                    description: powerbi.data.createDisplayNameGetter('Visual_LegendDescription'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        position: visuals.StandardObjectProperties.legendPosition,
	                        showTitle: visuals.StandardObjectProperties.showLegendTitle,
	                        titleText: $.extend({}, visuals.StandardObjectProperties.legendTitle, {
	                            suppressFormatPainterCopy: true
	                        }),
	                        labelColor: visuals.StandardObjectProperties.labelColor,
	                        fontSize: visuals.StandardObjectProperties.fontSize,
	                    }
	                },
	                dataPoint: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
	                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
	                    properties: {
	                        defaultColor: visuals.StandardObjectProperties.defaultColor,
	                        fill: visuals.StandardObjectProperties.fill,
	                    }
	                },
	                trend: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        displayName: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_DisplayName'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_DisplayName_Description'),
	                            type: { text: true }
	                        },
	                        lineColor: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Color'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Color_Description'),
	                            type: { fill: { solid: { color: true } } }
	                        },
	                        transparency: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Transparency'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Transparency_Description'),
	                            type: { numeric: true }
	                        },
	                        style: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Style'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Style_Description'),
	                            type: { enumeration: visuals.lineStyle.type }
	                        },
	                        combineSeries: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Combine_Series'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Combine_Series_Description'),
	                            type: { bool: true }
	                        },
	                        useHighlightValues: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_UseHighlightValues'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_UseHighlightValues_Description'),
	                            type: { bool: true }
	                        },
	                    }
	                },
	                scalarKey: {
	                    properties: {
	                        min: {
	                            type: { dateTime: true }
	                        },
	                    }
	                },
	                forecast: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Forecast'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        confidenceBandStyle: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Forecast_Confidence_Band_Style'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Forecast_Confidence_Band_Style_Description'),
	                            type: { enumeration: visuals.confidenceBandStyle.type }
	                        },
	                        lineColor: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Forecast_Line_Color'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Forecast_Line_Color_Description'),
	                            type: { fill: { solid: { color: true } } }
	                        },
	                        transparency: visuals.StandardObjectProperties.transparency,
	                        style: visuals.StandardObjectProperties.referenceLineStyle
	                    }
	                },
	                categoryAxis: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_XAxis'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        axisScale: visuals.StandardObjectProperties.axisScale,
	                        start: visuals.StandardObjectProperties.axisStart,
	                        end: visuals.StandardObjectProperties.axisEnd,
	                        axisType: visuals.StandardObjectProperties.axisType,
	                        showAxisTitle: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_XTitleDescription'),
	                            type: { bool: true }
	                        },
	                        axisStyle: visuals.StandardObjectProperties.axisStyle,
	                        labelColor: visuals.StandardObjectProperties.labelColor,
	                        labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
	                        labelPrecision: visuals.StandardObjectProperties.labelPrecision,
	                    }
	                },
	                valueAxis: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        position: visuals.StandardObjectProperties.yAxisPosition,
	                        axisScale: visuals.StandardObjectProperties.axisScale,
	                        start: visuals.StandardObjectProperties.axisStart,
	                        end: visuals.StandardObjectProperties.axisEnd,
	                        showAxisTitle: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_YTitleDescription'),
	                            type: { bool: true }
	                        },
	                        axisStyle: visuals.StandardObjectProperties.axisStyle,
	                        labelColor: visuals.StandardObjectProperties.labelColor,
	                        labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
	                        labelPrecision: visuals.StandardObjectProperties.labelPrecision,
	                    }
	                },
	                y1AxisReferenceLine: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line'),
	                    description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Description'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        displayName: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_DisplayName'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_DisplayName_Description'),
	                            type: { text: true }
	                        },
	                        value: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value_Description'),
	                            type: { numeric: true }
	                        },
	                        lineColor: visuals.StandardObjectProperties.lineColor,
	                        transparency: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency_Description'),
	                            type: { numeric: true }
	                        },
	                        style: visuals.StandardObjectProperties.referenceLineStyle,
	                        position: visuals.StandardObjectProperties.referenceLinePosition,
	                        dataLabelShow: visuals.StandardObjectProperties.dataLabelShow,
	                        dataLabelColor: visuals.StandardObjectProperties.dataLabelColor,
	                        dataLabelDecimalPoints: visuals.StandardObjectProperties.dataLabelDecimalPoints,
	                        dataLabelHorizontalPosition: visuals.StandardObjectProperties.dataLabelHorizontalPosition,
	                        dataLabelVerticalPosition: visuals.StandardObjectProperties.dataLabelVerticalPosition,
	                        dataLabelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits,
	                    },
	                },
	                referenceLine: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line'),
	                    description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Description'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        displayName: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_DisplayName'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_DisplayName_Description'),
	                            type: { text: true }
	                        },
	                        value: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value_Description'),
	                            type: { numeric: true }
	                        },
	                        lineColor: visuals.StandardObjectProperties.lineColor,
	                        transparency: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency_Description'),
	                            type: { numeric: true }
	                        },
	                        style: visuals.StandardObjectProperties.referenceLineStyle,
	                        position: visuals.StandardObjectProperties.referenceLinePosition,
	                        dataLabelShow: visuals.StandardObjectProperties.dataLabelShow,
	                        dataLabelColor: visuals.StandardObjectProperties.dataLabelColor,
	                        dataLabelDecimalPoints: visuals.StandardObjectProperties.dataLabelDecimalPoints,
	                        dataLabelHorizontalPosition: visuals.StandardObjectProperties.dataLabelHorizontalPosition,
	                        dataLabelVerticalPosition: visuals.StandardObjectProperties.dataLabelVerticalPosition,
	                        dataLabelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits,
	                    },
	                },
	                labels: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
	                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabelsDescription'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        showSeries: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
	                            type: { bool: true }
	                        },
	                        color: visuals.StandardObjectProperties.dataColor,
	                        labelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits,
	                        labelPrecision: $.extend({}, visuals.StandardObjectProperties.labelPrecision, {
	                            suppressFormatPainterCopy: true,
	                        }),
	                        showAll: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_LabelSeriesShowAll'),
	                            type: { bool: true }
	                        },
	                        fontSize: visuals.StandardObjectProperties.fontSize,
	                        labelDensity: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_LabelDensity'),
	                            type: { formatting: { labelDensity: true } },
	                        },
	                    },
	                },
	                plotArea: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Plot'),
	                    //description: data.createDisplayNameGetter('Visual_PlotDescription'),
	                    properties: {
	                        transparency: visuals.StandardObjectProperties.transparency,
	                        image: visuals.StandardObjectProperties.image,
	                    },
	                },
	            },
	            dataViewMappings: [{
	                    conditions: [
	                        { 'Category': { max: 1 }, 'Series': { max: 0 } },
	                        { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 } }
	                    ],
	                    categorical: {
	                        categories: {
	                            for: { in: 'Category' },
	                            dataReductionAlgorithm: { window: { count: 100 } }
	                        },
	                        values: {
	                            group: {
	                                by: 'Series',
	                                select: [{ for: { in: 'Y' } }],
	                                dataReductionAlgorithm: { top: { count: 60 } }
	                            }
	                        },
	                    },
	                }, {
	                    conditions: [
	                        { 'Category': { max: 1 }, 'Series': { max: 0 } },
	                        { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 } }
	                    ],
	                    requiredProperties: [{ objectName: 'trend', propertyName: 'show' }],
	                    usage: {
	                        regression: {
	                            combineSeries: { objectName: 'trend', propertyName: 'combineSeries' }
	                        },
	                    },
	                    categorical: {
	                        categories: {
	                            for: { in: 'regression.X' },
	                        },
	                        values: {
	                            group: {
	                                by: 'regression.Series',
	                                select: [{ for: { in: 'regression.Y' } }],
	                            },
	                        }
	                    }
	                }, {
	                    conditions: [
	                        { 'Category': { max: 1 }, 'Series': { max: 0 }, 'Y': { max: 1 } },
	                    ],
	                    requiredProperties: [{ objectName: 'forecast', propertyName: 'show' }],
	                    usage: {
	                        forecast: {},
	                    },
	                    categorical: {
	                        categories: {
	                            for: { in: 'Category' },
	                        },
	                        values: {
	                            group: {
	                                by: 'Series',
	                                select: [{ for: { in: 'forecast.ForecastValue' } }, { for: { in: 'forecast.ConfidenceHighBound' } }, { for: { in: 'forecast.ConfidenceLowBound' } }],
	                            },
	                        }
	                    }
	                }],
	            sorting: {
	                default: {},
	            },
	        };
	        visuals.lineChartProps = {
	            general: {
	                formatString: { objectName: 'general', propertyName: 'formatString' },
	            },
	            dataPoint: {
	                defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
	                fill: { objectName: 'dataPoint', propertyName: 'fill' },
	            },
	            trend: {
	                show: { objectName: 'trend', propertyName: 'show' },
	            },
	            scalarKey: {
	                scalarKeyMin: { objectName: 'scalarKey', propertyName: 'min' },
	            },
	            forecast: {
	                show: { objectName: 'forecast', propertyName: 'show' },
	            },
	            categoryAxis: {
	                axisType: { objectName: 'categoryAxis', propertyName: 'axisType' },
	            },
	            legend: {
	                labelColor: { objectName: 'legend', propertyName: 'labelColor' },
	            },
	            labels: {
	                labelDensity: { objectName: 'labels', propertyName: 'labelDensity' },
	            },
	            plotArea: {
	                image: { objectName: 'plotArea', propertyName: 'image' },
	                transparency: { objectName: 'plotArea', propertyName: 'transparency' },
	            },
	        };
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 162 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        visuals.mapCapabilities = {
	            dataRoles: [
	                {
	                    name: 'Category',
	                    kind: powerbi.VisualDataRoleKind.Grouping,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Location'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LocationMapDescription'),
	                    preferredTypes: [
	                        { geography: { address: true } },
	                        { geography: { city: true } },
	                        { geography: { continent: true } },
	                        { geography: { country: true } },
	                        { geography: { county: true } },
	                        { geography: { place: true } },
	                        { geography: { postalCode: true } },
	                        { geography: { region: true } },
	                        { geography: { stateOrProvince: true } },
	                    ],
	                }, {
	                    name: 'Series',
	                    kind: powerbi.VisualDataRoleKind.Grouping,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Legend'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LegendDescription')
	                }, {
	                    name: 'Y',
	                    kind: powerbi.VisualDataRoleKind.GroupingOrMeasure,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Latitude'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LatitudeMapDescription'),
	                    preferredTypes: [
	                        { geography: { latitude: true } }
	                    ],
	                }, {
	                    name: 'X',
	                    kind: powerbi.VisualDataRoleKind.GroupingOrMeasure,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Longitude'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LongitudeMapDescription'),
	                    preferredTypes: [
	                        { geography: { longitude: true } }
	                    ],
	                }, {
	                    name: 'Size',
	                    kind: powerbi.VisualDataRoleKind.Measure,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Size'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_SizeDescription'),
	                    requiredTypes: [{ numeric: true }, { integer: true }],
	                }, {
	                    name: 'Gradient',
	                    kind: powerbi.VisualDataRoleKind.Measure,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Gradient'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_GradientDescription'),
	                    requiredTypes: [{ numeric: true }, { integer: true }],
	                    joinPredicate: 0 /* None */,
	                }
	            ],
	            objects: {
	                general: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
	                    properties: {
	                        formatString: visuals.StandardObjectProperties.formatString,
	                    },
	                },
	                legend: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
	                    description: powerbi.data.createDisplayNameGetter('Visual_LegendDescription'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        position: visuals.StandardObjectProperties.legendPosition,
	                        showTitle: visuals.StandardObjectProperties.showLegendTitle,
	                        titleText: visuals.StandardObjectProperties.legendTitle,
	                        fontSize: visuals.StandardObjectProperties.fontSize,
	                    }
	                },
	                dataPoint: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
	                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
	                    properties: {
	                        defaultColor: visuals.StandardObjectProperties.defaultColor,
	                        showAllDataPoints: visuals.StandardObjectProperties.showAllDataPoints,
	                        fill: visuals.StandardObjectProperties.fill,
	                        fillRule: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Gradient'),
	                            type: { fillRule: {} },
	                            rule: {
	                                inputRole: 'Gradient',
	                                output: {
	                                    property: 'fill',
	                                    selector: ['Category', 'X', 'Y'],
	                                },
	                            },
	                        }
	                    }
	                },
	                categoryLabels: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_CategoryLabels'),
	                    description: powerbi.data.createDisplayNameGetter('Visual_CategoryLabelsDescription'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        color: visuals.StandardObjectProperties.dataColor,
	                        fontSize: visuals.StandardObjectProperties.fontSize,
	                    },
	                },
	            },
	            dataViewMappings: [{
	                    conditions: [
	                        { 'Category': { min: 1, max: 1 }, 'Series': { max: 1 }, 'X': { max: 1, kind: powerbi.VisualDataRoleKind.Measure }, 'Y': { max: 1, kind: powerbi.VisualDataRoleKind.Measure }, 'Size': { max: 1 }, 'Gradient': { max: 0 } },
	                        { 'Category': { min: 1, max: 1 }, 'Series': { max: 0 }, 'X': { max: 1, kind: powerbi.VisualDataRoleKind.Measure }, 'Y': { max: 1, kind: powerbi.VisualDataRoleKind.Measure }, 'Size': { max: 1 }, 'Gradient': { max: 1 } },
	                    ],
	                    categorical: {
	                        categories: {
	                            for: { in: 'Category' },
	                            dataReductionAlgorithm: { top: {} }
	                        },
	                        values: {
	                            group: {
	                                by: 'Series',
	                                select: [
	                                    { bind: { to: 'X' } },
	                                    { bind: { to: 'Y' } },
	                                    { bind: { to: 'Size' } },
	                                    { bind: { to: 'Gradient' } },
	                                ],
	                                dataReductionAlgorithm: { top: {} }
	                            }
	                        },
	                        rowCount: { preferred: { min: 2 } },
	                        dataVolume: 4,
	                    }
	                }, {
	                    conditions: [
	                        { 'Category': { max: 0 }, 'Series': { max: 1 }, 'X': { max: 1, kind: powerbi.VisualDataRoleKind.Grouping }, 'Y': { max: 1, kind: powerbi.VisualDataRoleKind.Grouping }, 'Size': { max: 1 }, 'Gradient': { max: 0 } },
	                        { 'Category': { max: 0 }, 'Series': { max: 0 }, 'X': { max: 1, kind: powerbi.VisualDataRoleKind.Grouping }, 'Y': { max: 1, kind: powerbi.VisualDataRoleKind.Grouping }, 'Size': { max: 1 }, 'Gradient': { max: 1 } }
	                    ],
	                    categorical: {
	                        categories: {
	                            select: [
	                                { bind: { to: 'X' } },
	                                { bind: { to: 'Y' } },
	                            ],
	                            dataReductionAlgorithm: { top: {} }
	                        },
	                        values: {
	                            group: {
	                                by: 'Series',
	                                select: [
	                                    { bind: { to: 'Size' } },
	                                    { bind: { to: 'Gradient' } },
	                                ],
	                                dataReductionAlgorithm: { top: {} }
	                            }
	                        },
	                        rowCount: { preferred: { min: 2 } },
	                        dataVolume: 4,
	                    },
	                }],
	            sorting: {
	                custom: {},
	                implicit: {
	                    clauses: [{ role: 'Size', direction: 2 /* Descending */ }]
	                },
	            },
	            drilldown: {
	                roles: ['Category']
	            },
	        };
	        visuals.mapProps = {
	            general: {
	                formatString: { objectName: 'general', propertyName: 'formatString' },
	            },
	            dataPoint: {
	                defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
	                fill: { objectName: 'dataPoint', propertyName: 'fill' },
	                showAllDataPoints: { objectName: 'dataPoint', propertyName: 'showAllDataPoints' },
	            },
	            legend: {
	                show: { objectName: 'legend', propertyName: 'show' },
	                position: { objectName: 'legend', propertyName: 'position' },
	                showTitle: { objectName: 'legend', propertyName: 'showTitle' },
	                titleText: { objectName: 'legend', propertyName: 'titleText' },
	            },
	        };
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 163 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        visuals.multiRowCardCapabilities = {
	            dataRoles: [
	                {
	                    name: 'Values',
	                    kind: powerbi.VisualDataRoleKind.GroupingOrMeasure,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Fields'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_FieldsDescription')
	                }
	            ],
	            objects: {
	                general: {
	                    properties: {
	                        formatString: visuals.StandardObjectProperties.formatString,
	                    },
	                },
	                cardTitle: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_CardTitle'),
	                    description: powerbi.data.createDisplayNameGetter('Visual_CardTitleDescription'),
	                    properties: {
	                        color: visuals.StandardObjectProperties.dataColor,
	                        fontSize: visuals.StandardObjectProperties.fontSize,
	                    }
	                },
	                dataLabels: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
	                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabelsDescription'),
	                    properties: {
	                        color: visuals.StandardObjectProperties.dataColor,
	                        fontSize: visuals.StandardObjectProperties.fontSize,
	                    }
	                },
	                categoryLabels: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_CategoryLabels'),
	                    description: powerbi.data.createDisplayNameGetter('Visual_CategoryLabelsDescription'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        color: visuals.StandardObjectProperties.dataColor,
	                        fontSize: visuals.StandardObjectProperties.fontSize,
	                    }
	                },
	                card: {
	                    displayName: powerbi.data.createDisplayNameGetter('Card_ToolTip'),
	                    properties: {
	                        outline: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Outline'),
	                            type: { enumeration: visuals.outline.type }
	                        },
	                        outlineColor: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_OutlineColor'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_OutlineColor_Desc'),
	                            type: { fill: { solid: { color: true } } }
	                        },
	                        outlineWeight: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_OutlineWeight'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_OutlineWeight_Desc'),
	                            type: { numeric: true }
	                        },
	                        barShow: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_MultiRowCard_BarShow'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_MultiRowCard_BarShow_Desc'),
	                            type: { bool: true }
	                        },
	                        barColor: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_MultiRowCard_BarColor'),
	                            type: { fill: { solid: { color: true } } }
	                        },
	                        barWeight: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_MultiRowCard_BarWeight'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_MultiRowCard_BarWeight_Desc'),
	                            type: { numeric: true }
	                        },
	                        cardPadding: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_MultiRowCard_CardPadding'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_MultiRowCard_CardBackground'),
	                            type: { numeric: true }
	                        },
	                        cardBackground: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Background'),
	                            type: { fill: { solid: { color: true } } }
	                        }
	                    }
	                }
	            },
	            dataViewMappings: [{
	                    table: {
	                        rows: {
	                            for: { in: 'Values' },
	                            dataReductionAlgorithm: { window: {} }
	                        },
	                        rowCount: { preferred: { min: 1 } }
	                    },
	                }],
	            sorting: {
	                default: {},
	            },
	            suppressDefaultTitle: true,
	            supportsSelection: false,
	            disableVisualDetails: true,
	        };
	        visuals.multiRowCardProps = {
	            card: {
	                outline: { objectName: 'card', propertyName: 'outline' },
	                outlineColor: { objectName: 'card', propertyName: 'outlineColor' },
	                outlineWeight: { objectName: 'card', propertyName: 'outlineWeight' },
	                barShow: { objectName: 'card', propertyName: 'barShow' },
	                barColor: { objectName: 'card', propertyName: 'barColor' },
	                barWeight: { objectName: 'card', propertyName: 'barWeight' },
	                cardPadding: { objectName: 'card', propertyName: 'cardPadding' },
	                cardBackground: { objectName: 'card', propertyName: 'cardBackground' },
	            }
	        };
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 164 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        visuals.textboxCapabilities = {
	            objects: {
	                general: {
	                    properties: {
	                        paragraphs: {
	                            type: { paragraphs: {} },
	                            suppressFormatPainterCopy: true,
	                        }
	                    }
	                }
	            },
	            suppressDefaultTitle: true,
	            supportsSelection: false,
	        };
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 165 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	*  Power BI Visualizations
	*
	*  Copyright (c) Microsoft Corporation
	*  All rights reserved.
	*  MIT License
	*
	*  Permission is hereby granted, free of charge, to any person obtaining a copy
	*  of this software and associated documentation files (the ""Software""), to deal
	*  in the Software without restriction, including without limitation the rights
	*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	*  copies of the Software, and to permit persons to whom the Software is
	*  furnished to do so, subject to the following conditions:
	*
	*  The above copyright notice and this permission notice shall be included in
	*  all copies or substantial portions of the Software.
	*
	*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	*  THE SOFTWARE.
	*/
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        visuals.cheerMeterCapabilities = {
	            dataRoles: [
	                {
	                    name: 'Category',
	                    kind: powerbi.VisualDataRoleKind.Grouping,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Axis'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_AxisDescription')
	                },
	                {
	                    name: 'Y',
	                    kind: powerbi.VisualDataRoleKind.Measure,
	                    requiredTypes: [{ numeric: true }, { integer: true }],
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Y'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_YDescription')
	                },
	            ],
	            dataViewMappings: [{
	                    categorical: {
	                        categories: {
	                            for: { in: 'Category' },
	                        },
	                    },
	                }],
	            objects: {
	                dataPoint: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
	                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
	                    properties: {
	                        fill: visuals.StandardObjectProperties.fill,
	                    }
	                }
	            }
	        };
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 166 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        visuals.scatterChartCapabilities = {
	            dataRoles: [
	                {
	                    name: 'Category',
	                    kind: powerbi.VisualDataRoleKind.Grouping,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Details'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_DetailsScatterChartDescription'),
	                }, {
	                    name: 'Series',
	                    kind: powerbi.VisualDataRoleKind.Grouping,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Legend'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LegendDescription')
	                }, {
	                    name: 'X',
	                    kind: powerbi.VisualDataRoleKind.Measure,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_X'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_XScatterChartDescription'),
	                    requiredTypes: [{ numeric: true }, { integer: true }],
	                    cartesianKind: 0 /* X */,
	                }, {
	                    name: 'Y',
	                    kind: powerbi.VisualDataRoleKind.Measure,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Y'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_YScatterChartDescription'),
	                    requiredTypes: [{ numeric: true }, { integer: true }],
	                    cartesianKind: 1 /* Y */,
	                }, {
	                    name: 'Size',
	                    kind: powerbi.VisualDataRoleKind.Measure,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Size'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_SizeDescription'),
	                    requiredTypes: [{ numeric: true }, { integer: true }],
	                }, {
	                    name: 'Gradient',
	                    kind: powerbi.VisualDataRoleKind.Measure,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Gradient'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_GradientDescription'),
	                    requiredTypes: [{ numeric: true }, { integer: true }],
	                    joinPredicate: 0 /* None */,
	                }, {
	                    name: 'Play',
	                    kind: powerbi.VisualDataRoleKind.Grouping,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Play'),
	                }
	            ],
	            objects: {
	                dataPoint: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
	                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
	                    properties: {
	                        defaultColor: visuals.StandardObjectProperties.defaultColor,
	                        showAllDataPoints: visuals.StandardObjectProperties.showAllDataPoints,
	                        fill: visuals.StandardObjectProperties.fill,
	                        fillRule: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Gradient'),
	                            type: { fillRule: {} },
	                            rule: {
	                                inputRole: 'Gradient',
	                                output: {
	                                    property: 'fill',
	                                    selector: ['Category'],
	                                },
	                            },
	                        }
	                    }
	                },
	                general: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
	                    properties: {
	                        formatString: visuals.StandardObjectProperties.formatString,
	                    },
	                },
	                trend: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        displayName: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_DisplayName'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_DisplayName_Description'),
	                            type: { text: true }
	                        },
	                        lineColor: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Color'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Color_Description'),
	                            type: { fill: { solid: { color: true } } }
	                        },
	                        transparency: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Transparency'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Transparency_Description'),
	                            type: { numeric: true }
	                        },
	                        style: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Style'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Style_Description'),
	                            type: { enumeration: visuals.lineStyle.type }
	                        },
	                        combineSeries: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Combine_Series'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Combine_Series_Description'),
	                            type: { bool: true }
	                        },
	                    }
	                },
	                categoryAxis: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_XAxis'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        axisScale: visuals.StandardObjectProperties.axisScale,
	                        start: visuals.StandardObjectProperties.axisStart,
	                        end: visuals.StandardObjectProperties.axisEnd,
	                        showAxisTitle: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_XTitleDescription'),
	                            type: { bool: true }
	                        },
	                        axisStyle: visuals.StandardObjectProperties.axisStyle,
	                        labelColor: visuals.StandardObjectProperties.labelColor,
	                        labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
	                        labelPrecision: visuals.StandardObjectProperties.labelPrecision,
	                    }
	                },
	                valueAxis: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        position: visuals.StandardObjectProperties.yAxisPosition,
	                        axisScale: visuals.StandardObjectProperties.axisScale,
	                        start: visuals.StandardObjectProperties.axisStart,
	                        end: visuals.StandardObjectProperties.axisEnd,
	                        showAxisTitle: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_YTitleDescription'),
	                            type: { bool: true }
	                        },
	                        axisStyle: visuals.StandardObjectProperties.axisStyle,
	                        labelColor: visuals.StandardObjectProperties.labelColor,
	                        labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
	                        labelPrecision: visuals.StandardObjectProperties.labelPrecision,
	                    }
	                },
	                xAxisReferenceLine: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_X'),
	                    description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Description'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        displayName: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_DisplayName'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_DisplayName_Description'),
	                            type: { text: true }
	                        },
	                        value: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value_Description'),
	                            type: { numeric: true }
	                        },
	                        lineColor: visuals.StandardObjectProperties.lineColor,
	                        transparency: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency_Description'),
	                            type: { numeric: true }
	                        },
	                        style: visuals.StandardObjectProperties.referenceLineStyle,
	                        position: visuals.StandardObjectProperties.referenceLinePosition,
	                        dataLabelShow: visuals.StandardObjectProperties.dataLabelShow,
	                        dataLabelColor: visuals.StandardObjectProperties.dataLabelColor,
	                        dataLabelDecimalPoints: visuals.StandardObjectProperties.dataLabelDecimalPoints,
	                        dataLabelHorizontalPosition: visuals.StandardObjectProperties.dataLabelHorizontalPosition,
	                        dataLabelVerticalPosition: visuals.StandardObjectProperties.dataLabelVerticalPosition,
	                        dataLabelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits,
	                    },
	                },
	                y1AxisReferenceLine: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Y'),
	                    description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Description'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        displayName: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_DisplayName'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_DisplayName_Description'),
	                            type: { text: true }
	                        },
	                        value: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value_Description'),
	                            type: { numeric: true }
	                        },
	                        lineColor: visuals.StandardObjectProperties.lineColor,
	                        transparency: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency_Description'),
	                            type: { numeric: true }
	                        },
	                        style: visuals.StandardObjectProperties.referenceLineStyle,
	                        position: visuals.StandardObjectProperties.referenceLinePosition,
	                        dataLabelShow: visuals.StandardObjectProperties.dataLabelShow,
	                        dataLabelColor: visuals.StandardObjectProperties.dataLabelColor,
	                        dataLabelDecimalPoints: visuals.StandardObjectProperties.dataLabelDecimalPoints,
	                        dataLabelHorizontalPosition: visuals.StandardObjectProperties.dataLabelHorizontalPosition,
	                        dataLabelVerticalPosition: visuals.StandardObjectProperties.dataLabelVerticalPosition,
	                        dataLabelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits,
	                    },
	                },
	                referenceLine: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line'),
	                    description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Description'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        displayName: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_DisplayName'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_DisplayName_Description'),
	                            type: { text: true }
	                        },
	                        value: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value_Description'),
	                            type: { numeric: true }
	                        },
	                        lineColor: visuals.StandardObjectProperties.lineColor,
	                        transparency: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency_Description'),
	                            type: { numeric: true }
	                        },
	                        style: visuals.StandardObjectProperties.referenceLineStyle,
	                        position: visuals.StandardObjectProperties.referenceLinePosition,
	                        dataLabelShow: visuals.StandardObjectProperties.dataLabelShow,
	                        dataLabelColor: visuals.StandardObjectProperties.dataLabelColor,
	                        dataLabelDecimalPoints: visuals.StandardObjectProperties.dataLabelDecimalPoints,
	                        dataLabelHorizontalPosition: visuals.StandardObjectProperties.dataLabelHorizontalPosition,
	                        dataLabelVerticalPosition: visuals.StandardObjectProperties.dataLabelVerticalPosition,
	                        dataLabelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits,
	                    },
	                },
	                legend: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
	                    description: powerbi.data.createDisplayNameGetter('Visual_LegendDescription'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        position: visuals.StandardObjectProperties.legendPosition,
	                        showTitle: visuals.StandardObjectProperties.showLegendTitle,
	                        titleText: $.extend({}, visuals.StandardObjectProperties.legendTitle, {
	                            suppressFormatPainterCopy: true
	                        }),
	                        labelColor: visuals.StandardObjectProperties.labelColor,
	                        fontSize: visuals.StandardObjectProperties.fontSize,
	                    }
	                },
	                categoryLabels: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_CategoryLabels'),
	                    description: powerbi.data.createDisplayNameGetter('Visual_CategoryLabelsDescription'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        color: visuals.StandardObjectProperties.dataColor,
	                        fontSize: visuals.StandardObjectProperties.fontSize,
	                    },
	                },
	                colorBorder: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_ColorBorder'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                    },
	                },
	                fillPoint: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_FillPoint'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                    },
	                },
	                colorByCategory: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_ColorByCategory'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                    }
	                },
	                currentFrameIndex: {
	                    properties: {
	                        index: {
	                            type: { numeric: true },
	                        }
	                    }
	                },
	                plotArea: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Plot'),
	                    //description: data.createDisplayNameGetter('Visual_PlotDescription'),
	                    properties: {
	                        transparency: visuals.StandardObjectProperties.transparency,
	                        image: visuals.StandardObjectProperties.image,
	                    },
	                },
	            },
	            dataViewMappings: [{
	                    conditions: [
	                        { 'Category': { max: 1 }, 'Series': { max: 1 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 1 }, 'Gradient': { max: 0 }, 'Play': { max: 0 } },
	                        { 'Category': { max: 1 }, 'Series': { max: 0 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 1 }, 'Gradient': { max: 1 }, 'Play': { max: 0 } },
	                    ],
	                    categorical: {
	                        categories: {
	                            for: { in: 'Category' },
	                        },
	                        values: {
	                            group: {
	                                by: 'Series',
	                                select: [
	                                    { bind: { to: 'X' } },
	                                    { bind: { to: 'Y' } },
	                                    { bind: { to: 'Size' } },
	                                    { bind: { to: 'Gradient' } },
	                                ],
	                            }
	                        },
	                        rowCount: { preferred: { min: 2 } },
	                        dataReductionAlgorithm: { sample: {} },
	                        dataVolume: 4,
	                    }
	                }, {
	                    conditions: [
	                        { 'Category': { max: 1 }, 'Series': { max: 1 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 1 }, 'Gradient': { max: 0 }, 'Play': { min: 1, max: 1 } },
	                    ],
	                    // Long term: consider adding the 'name' concept and have this be a reference to the other dataViewMapping above.
	                    // Then we'd also move the splitting logic of Matrix->Categorical[] into DataViewTransform, and other visuals would benefit.
	                    matrix: {
	                        rows: {
	                            select: [
	                                { bind: { to: 'Play' } },
	                                { bind: { to: 'Category' } },
	                            ],
	                            /* Explicitly override the server data reduction to make it appropriate for matrix/play. */
	                            dataReductionAlgorithm: { bottom: { count: 5000 } }
	                        },
	                        columns: {
	                            for: { in: 'Series' },
	                            /* Explicitly override the server data reduction to make it appropriate for matrix/play. */
	                            dataReductionAlgorithm: { top: { count: 60 } }
	                        },
	                        values: {
	                            select: [
	                                { bind: { to: 'X' } },
	                                { bind: { to: 'Y' } },
	                                { bind: { to: 'Size' } },
	                            ]
	                        }
	                    }
	                }, {
	                    conditions: [
	                        { 'Category': { max: 1 }, 'Series': { max: 1 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 0 }, 'Gradient': { max: 0 }, 'Play': { max: 0 } },
	                        { 'Category': { max: 1 }, 'Series': { max: 0 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 0 }, 'Gradient': { max: 1 }, 'Play': { max: 0 } },
	                    ],
	                    requiredProperties: [{ objectName: 'trend', propertyName: 'show' }],
	                    usage: {
	                        regression: {
	                            combineSeries: { objectName: 'trend', propertyName: 'combineSeries' }
	                        },
	                    },
	                    categorical: {
	                        categories: {
	                            for: { in: 'regression.X' }
	                        },
	                        values: {
	                            group: {
	                                by: 'regression.Series',
	                                select: [{ for: { in: 'regression.Y' } }],
	                            },
	                        },
	                        dataReductionAlgorithm: { sample: {} },
	                        dataVolume: 4,
	                    }
	                }],
	            sorting: {
	                custom: {},
	                implicit: {
	                    clauses: [{ role: 'Play', direction: 1 /* Ascending */ }] //typically a datetime field, sort asc
	                },
	            },
	            drilldown: {
	                roles: ['Category']
	            },
	        };
	        visuals.scatterChartProps = {
	            general: {
	                formatString: { objectName: 'general', propertyName: 'formatString' },
	            },
	            dataPoint: {
	                defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
	                fill: { objectName: 'dataPoint', propertyName: 'fill' },
	            },
	            trend: {
	                show: { objectName: 'trend', propertyName: 'show' },
	            },
	            colorBorder: {
	                show: { objectName: 'colorBorder', propertyName: 'show' },
	            },
	            fillPoint: {
	                show: { objectName: 'fillPoint', propertyName: 'show' },
	            },
	            colorByCategory: {
	                show: { objectName: 'colorByCategory', propertyName: 'show' },
	            },
	            currentFrameIndex: {
	                index: { objectName: 'currentFrameIndex', propertyName: 'index' },
	            },
	            legend: {
	                labelColor: { objectName: 'legend', propertyName: 'labelColor' },
	            },
	            plotArea: {
	                image: { objectName: 'plotArea', propertyName: 'image' },
	                transparency: { objectName: 'plotArea', propertyName: 'transparency' },
	            },
	        };
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 167 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        visuals.slicerCapabilities = {
	            dataRoles: [
	                {
	                    name: 'Values',
	                    kind: powerbi.VisualDataRoleKind.Grouping,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Field'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_FieldDescription')
	                }
	            ],
	            objects: {
	                general: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
	                    properties: {
	                        filter: {
	                            type: { filter: {} },
	                        },
	                        selfFilter: {
	                            type: { filter: { selfFilter: true } },
	                        },
	                        defaultValue: {
	                            type: { expression: { defaultValue: true } },
	                        },
	                        formatString: visuals.StandardObjectProperties.formatString,
	                        outlineColor: visuals.StandardObjectProperties.outlineColor,
	                        outlineWeight: visuals.StandardObjectProperties.outlineWeight,
	                        orientation: {
	                            displayName: powerbi.data.createDisplayNameGetter('Slicer_Orientation'),
	                            type: { enumeration: visuals.slicerOrientation.type }
	                        },
	                        count: {
	                            type: { integer: true }
	                        },
	                        selfFilterEnabled: {
	                            type: { operations: { searchEnabled: true } }
	                        },
	                    },
	                },
	                selection: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_SelectionControls'),
	                    properties: {
	                        selectAllCheckboxEnabled: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_SelectAll'),
	                            type: { bool: true }
	                        },
	                        singleSelect: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_SingleSelect'),
	                            type: { bool: true }
	                        }
	                    },
	                },
	                header: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Header'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        fontColor: visuals.StandardObjectProperties.fontColor,
	                        background: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Background'),
	                            type: { fill: { solid: { color: true } } }
	                        },
	                        outline: visuals.StandardObjectProperties.outline,
	                        textSize: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
	                            type: { numeric: true }
	                        },
	                    }
	                },
	                items: {
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Items'),
	                    properties: {
	                        fontColor: visuals.StandardObjectProperties.fontColor,
	                        background: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Background'),
	                            type: { fill: { solid: { color: true } } }
	                        },
	                        outline: visuals.StandardObjectProperties.outline,
	                        textSize: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
	                            type: { numeric: true }
	                        },
	                    }
	                }
	            },
	            dataViewMappings: [{
	                    conditions: [{ 'Values': { max: 1 } }],
	                    categorical: {
	                        categories: {
	                            for: { in: 'Values' },
	                            dataReductionAlgorithm: { window: {} }
	                        },
	                        includeEmptyGroups: true,
	                    }
	                }],
	            sorting: {
	                default: {},
	            },
	            suppressDefaultTitle: true,
	            disableVisualDetails: true,
	        };
	        // TODO: Generate these from above, defining twice just introduces potential for error
	        visuals.slicerProps = {
	            general: {
	                outlineColor: { objectName: 'general', propertyName: 'outlineColor' },
	                outlineWeight: { objectName: 'general', propertyName: 'outlineWeight' },
	                orientation: { objectName: 'general', propertyName: 'orientation' },
	                count: { objectName: 'general', propertyName: 'count' },
	                selfFilterEnabled: { objectName: 'general', propertyName: 'selfFilterEnabled' },
	            },
	            selection: {
	                selectAllCheckboxEnabled: { objectName: 'selection', propertyName: 'selectAllCheckboxEnabled' },
	                singleSelect: { objectName: 'selection', propertyName: 'singleSelect' }
	            },
	            header: {
	                show: { objectName: 'header', propertyName: 'show' },
	                fontColor: { objectName: 'header', propertyName: 'fontColor' },
	                background: { objectName: 'header', propertyName: 'background' },
	                outline: { objectName: 'header', propertyName: 'outline' },
	                textSize: { objectName: 'header', propertyName: 'textSize' },
	            },
	            items: {
	                fontColor: { objectName: 'items', propertyName: 'fontColor' },
	                background: { objectName: 'items', propertyName: 'background' },
	                outline: { objectName: 'items', propertyName: 'outline' },
	                textSize: { objectName: 'items', propertyName: 'textSize' },
	            },
	            filterPropertyIdentifier: { objectName: 'general', propertyName: 'filter' },
	            selfFilterPropertyIdentifier: { objectName: 'general', propertyName: 'selfFilter' },
	            formatString: { objectName: 'general', propertyName: 'formatString' },
	            defaultValue: { objectName: 'general', propertyName: 'defaultValue' },
	        };
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 168 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        visuals.tableCapabilities = {
	            dataRoles: [{
	                    name: 'Values',
	                    kind: powerbi.VisualDataRoleKind.GroupingOrMeasure,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),
	                }],
	            objects: {
	                general: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
	                    properties: {
	                        formatString: visuals.StandardObjectProperties.formatString,
	                        columnWidth: {
	                            type: { numeric: true }
	                        },
	                        totals: {
	                            type: { bool: true },
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Totals'),
	                            suppressFormatPainterCopy: true,
	                        },
	                        autoSizeColumnWidth: {
	                            type: { bool: true },
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Adjust_Column_Width'),
	                            suppressFormatPainterCopy: true,
	                        },
	                        textSize: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
	                            type: { numeric: true }
	                        },
	                    },
	                },
	                grid: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Grid'),
	                    properties: {
	                        outlineColor: visuals.StandardObjectProperties.outlineColor,
	                        outlineWeight: visuals.StandardObjectProperties.outlineWeight,
	                        gridVertical: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridVertical'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_GridVertical_Desc'),
	                            type: { bool: true }
	                        },
	                        gridVerticalColor: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridVertical_Color'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_GridVertical_Color_Desc'),
	                            type: { fill: { solid: { color: true } } }
	                        },
	                        gridVerticalWeight: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridVertical_Weight'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_GridVertical_Weight_Desc'),
	                            type: { numeric: true }
	                        },
	                        gridHorizontal: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal_Desc'),
	                            type: { bool: true }
	                        },
	                        gridHorizontalColor: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal_Color'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal_Color_Desc'),
	                            type: { fill: { solid: { color: true } } }
	                        },
	                        gridHorizontalWeight: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal_Weight'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal_Weight_Desc'),
	                            type: { numeric: true }
	                        },
	                        rowPadding: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_RowPadding'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_RowPadding_Desc'),
	                            type: { numeric: true }
	                        },
	                        imageHeight: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_ImageHeight'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_ImageHeight_Desc'),
	                            type: { numeric: true }
	                        },
	                    }
	                },
	                columnHeaders: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_ColumnHeaders'),
	                    properties: {
	                        outline: visuals.StandardObjectProperties.outline,
	                        fontColor: visuals.StandardObjectProperties.fontColor,
	                        backColor: visuals.StandardObjectProperties.backColor,
	                    }
	                },
	                values: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_Values'),
	                    properties: {
	                        outline: visuals.StandardObjectProperties.outline,
	                        // backColor overrides backColorPrimary and Secondary (e.g., in the case of conditional formatting)
	                        backColor: {
	                            type: { fill: { solid: { color: true } } }
	                        },
	                        fontColorPrimary: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColorPrimary'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColorPrimary_Desc'),
	                            type: { fill: { solid: { color: true } } }
	                        },
	                        backColorPrimary: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColorPrimary'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColorPrimary_Desc'),
	                            type: { fill: { solid: { color: true } } }
	                        },
	                        fontColorSecondary: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColorSecondary'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColorSecondary_Desc'),
	                            type: { fill: { solid: { color: true } } }
	                        },
	                        backColorSecondary: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColorSecondary'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColorSecondary_Desc'),
	                            type: { fill: { solid: { color: true } } }
	                        },
	                        urlIcon: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_UrlIcon'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_UrlIcon_Desc'),
	                            type: { bool: true }
	                        },
	                    }
	                },
	                total: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_TotalGrand'),
	                    properties: {
	                        outline: visuals.StandardObjectProperties.outline,
	                        fontColor: visuals.StandardObjectProperties.fontColor,
	                        backColor: visuals.StandardObjectProperties.backColor,
	                    }
	                },
	            },
	            dataViewMappings: [{
	                    table: {
	                        rows: {
	                            for: { in: 'Values' },
	                            dataReductionAlgorithm: { window: { count: 500 } }
	                        },
	                        rowCount: { preferred: { min: 1 } }
	                    },
	                }],
	            sorting: {
	                custom: {},
	            },
	            suppressDefaultTitle: true,
	            supportsSelection: false,
	            disableVisualDetails: true,
	        };
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 169 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        visuals.matrixRoleNames = {
	            rows: 'Rows',
	            columns: 'Columns',
	            values: 'Values',
	        };
	        visuals.matrixCapabilities = {
	            dataRoles: [
	                {
	                    name: visuals.matrixRoleNames.rows,
	                    kind: powerbi.VisualDataRoleKind.Grouping,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Rows'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_RowsDescription')
	                }, {
	                    name: visuals.matrixRoleNames.columns,
	                    kind: powerbi.VisualDataRoleKind.Grouping,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Columns'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_ColumnsDescription')
	                }, {
	                    name: visuals.matrixRoleNames.values,
	                    kind: powerbi.VisualDataRoleKind.Measure,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values')
	                }
	            ],
	            objects: {
	                general: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
	                    properties: {
	                        formatString: visuals.StandardObjectProperties.formatString,
	                        columnWidth: {
	                            type: { numeric: true }
	                        },
	                        rowSubtotals: {
	                            type: { bool: true },
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_TotalRow'),
	                            suppressFormatPainterCopy: true,
	                        },
	                        columnSubtotals: {
	                            type: { bool: true },
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_TotalColumn'),
	                            suppressFormatPainterCopy: true,
	                        },
	                        autoSizeColumnWidth: {
	                            type: { bool: true },
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Adjust_Column_Width'),
	                            suppressFormatPainterCopy: true,
	                        },
	                        textSize: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
	                            type: { numeric: true }
	                        },
	                    },
	                },
	                grid: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Grid'),
	                    properties: {
	                        outlineColor: visuals.StandardObjectProperties.outlineColor,
	                        outlineWeight: visuals.StandardObjectProperties.outlineWeight,
	                        gridVertical: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridVertical'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_GridVertical_Desc'),
	                            type: { bool: true }
	                        },
	                        gridVerticalColor: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridVertical_Color'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_GridVertical_Color_Desc'),
	                            type: { fill: { solid: { color: true } } }
	                        },
	                        gridVerticalWeight: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridVertical_Weight'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_GridVertical_Weight_Desc'),
	                            type: { numeric: true }
	                        },
	                        gridHorizontal: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal_Desc'),
	                            type: { bool: true }
	                        },
	                        gridHorizontalColor: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal_Color'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal_Color_Desc'),
	                            type: { fill: { solid: { color: true } } }
	                        },
	                        gridHorizontalWeight: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal_Weight'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal_Weight_Desc'),
	                            type: { numeric: true }
	                        },
	                        rowPadding: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_RowPadding'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_RowPadding_Desc'),
	                            type: { numeric: true }
	                        },
	                        imageHeight: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_ImageHeight'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_ImageHeight_Desc'),
	                            type: { numeric: true }
	                        },
	                    },
	                },
	                columnHeaders: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_ColumnHeaders'),
	                    properties: {
	                        outline: visuals.StandardObjectProperties.outline,
	                        fontColor: visuals.StandardObjectProperties.fontColor,
	                        backColor: visuals.StandardObjectProperties.backColor,
	                    }
	                },
	                rowHeaders: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_RowHeaders'),
	                    properties: {
	                        outline: visuals.StandardObjectProperties.outline,
	                        fontColor: visuals.StandardObjectProperties.fontColor,
	                        backColor: visuals.StandardObjectProperties.backColor,
	                    }
	                },
	                values: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_Values'),
	                    properties: {
	                        outline: visuals.StandardObjectProperties.outline,
	                        fontColorPrimary: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColorPrimary'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColorPrimary_Desc'),
	                            type: { fill: { solid: { color: true } } }
	                        },
	                        backColorPrimary: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColorPrimary'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColorPrimary_Desc'),
	                            type: { fill: { solid: { color: true } } }
	                        },
	                        fontColorSecondary: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColorSecondary'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColorSecondary_Desc'),
	                            type: { fill: { solid: { color: true } } }
	                        },
	                        backColorSecondary: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColorSecondary'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColorSecondary_Desc'),
	                            type: { fill: { solid: { color: true } } }
	                        },
	                    }
	                },
	                subTotals: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_TotalSub'),
	                    properties: {
	                        outline: visuals.StandardObjectProperties.outline,
	                        fontColor: visuals.StandardObjectProperties.fontColor,
	                        backColor: visuals.StandardObjectProperties.backColor,
	                    }
	                },
	            },
	            dataViewMappings: [{
	                    conditions: [
	                        { 'Rows': { max: 0 }, 'Columns': { max: 0 }, 'Values': { min: 1 } },
	                        { 'Rows': { min: 1 }, 'Columns': { min: 0 }, 'Values': { min: 0 } },
	                        { 'Rows': { min: 0 }, 'Columns': { min: 1 }, 'Values': { min: 0 } }
	                    ],
	                    matrix: {
	                        rows: {
	                            for: { in: 'Rows' },
	                            /* Explicitly override the server data reduction to make it appropriate for matrix. */
	                            dataReductionAlgorithm: { window: { count: 500 } }
	                        },
	                        columns: {
	                            for: { in: 'Columns' },
	                            /* Explicitly override the server data reduction to make it appropriate for matrix. */
	                            dataReductionAlgorithm: { top: { count: 100 } }
	                        },
	                        values: {
	                            for: { in: 'Values' }
	                        }
	                    }
	                }],
	            filterMappings: {
	                measureFilter: {
	                    targetRoles: [visuals.matrixRoleNames.rows]
	                }
	            },
	            sorting: {
	                custom: {},
	            },
	            suppressDefaultTitle: true,
	            supportsSelection: false,
	            disableVisualDetails: true,
	        };
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 170 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        visuals.treemapRoles = {
	            group: 'Group',
	            details: 'Details',
	            values: 'Values',
	            gradient: 'Gradient'
	        };
	        visuals.treemapCapabilities = {
	            dataRoles: [
	                {
	                    name: 'Group',
	                    kind: powerbi.VisualDataRoleKind.Grouping,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Group'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_GroupTreemapDescription')
	                }, {
	                    name: 'Details',
	                    kind: powerbi.VisualDataRoleKind.Grouping,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Details'),
	                }, {
	                    name: 'Values',
	                    kind: powerbi.VisualDataRoleKind.Measure,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_ValuesDescription'),
	                    requiredTypes: [{ numeric: true }, { integer: true }],
	                }, {
	                    name: 'Gradient',
	                    kind: powerbi.VisualDataRoleKind.Measure,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Gradient'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_GradientDescription'),
	                    requiredTypes: [{ numeric: true }, { integer: true }],
	                    joinPredicate: 0 /* None */,
	                }
	            ],
	            objects: {
	                general: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
	                    properties: {
	                        formatString: visuals.StandardObjectProperties.formatString,
	                    },
	                },
	                legend: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
	                    description: powerbi.data.createDisplayNameGetter('Visual_LegendDescription'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        position: visuals.StandardObjectProperties.legendPosition,
	                        showTitle: visuals.StandardObjectProperties.showLegendTitle,
	                        titleText: visuals.StandardObjectProperties.legendTitle,
	                        labelColor: visuals.StandardObjectProperties.labelColor,
	                        fontSize: visuals.StandardObjectProperties.fontSize,
	                    }
	                },
	                dataPoint: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
	                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
	                    properties: {
	                        fill: {
	                            type: { fill: { solid: { color: true } } }
	                        },
	                        fillRule: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Gradient'),
	                            type: { fillRule: {} },
	                            rule: {
	                                inputRole: 'Gradient',
	                                output: {
	                                    property: 'fill',
	                                    selector: ['Group'],
	                                }
	                            }
	                        }
	                    }
	                },
	                labels: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
	                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabelsDescription'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        color: visuals.StandardObjectProperties.dataColor,
	                        labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
	                        labelPrecision: visuals.StandardObjectProperties.labelPrecision,
	                    }
	                },
	                categoryLabels: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_CategoryLabels'),
	                    description: powerbi.data.createDisplayNameGetter('Visual_CategoryLabelsDescription'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                    },
	                },
	            },
	            dataViewMappings: [{
	                    conditions: [
	                        { 'Group': { max: 1 }, 'Details': { max: 0 }, 'Gradient': { max: 1 } },
	                        { 'Group': { max: 1 }, 'Details': { min: 1, max: 1 }, 'Values': { max: 1 }, 'Gradient': { max: 0 } }
	                    ],
	                    categorical: {
	                        categories: {
	                            for: { in: 'Group' },
	                            dataReductionAlgorithm: { top: {} }
	                        },
	                        values: {
	                            group: {
	                                by: 'Details',
	                                select: [{ bind: { to: 'Values' } }, { bind: { to: 'Gradient' } }],
	                                dataReductionAlgorithm: { top: {} }
	                            }
	                        },
	                        rowCount: { preferred: { min: 2 } }
	                    }
	                }],
	            supportsHighlight: true,
	            sorting: {
	                custom: {},
	                implicit: {
	                    clauses: [{ role: 'Values', direction: 2 /* Descending */ }]
	                },
	            },
	            drilldown: {
	                roles: ['Group']
	            },
	        };
	        visuals.treemapProps = {
	            general: {
	                formatString: { objectName: 'general', propertyName: 'formatString' },
	            },
	            dataPoint: {
	                fill: { objectName: 'dataPoint', propertyName: 'fill' },
	            },
	            legend: {
	                show: { objectName: 'legend', propertyName: 'show' },
	                position: { objectName: 'legend', propertyName: 'position' },
	                showTitle: { objectName: 'legend', propertyName: 'showTitle' },
	                titleText: { objectName: 'legend', propertyName: 'titleText' },
	                labelColor: { objectName: 'legend', propertyName: 'labelColor' },
	            },
	            labels: {
	                show: { objectName: 'labels', propertyName: 'show' },
	                color: { objectName: 'labels', propertyName: 'color' },
	                labelDisplayUnits: { objectName: 'labels', propertyName: 'labelDisplayUnits' },
	                labelPrecision: { objectName: 'labels', propertyName: 'labelPrecision' },
	            },
	            categoryLabels: {
	                show: { objectName: 'categoryLabels', propertyName: 'show' },
	            },
	        };
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 171 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        visuals.cardCapabilities = {
	            dataRoles: [
	                {
	                    name: 'Values',
	                    kind: powerbi.VisualDataRoleKind.Measure,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Fields'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_FieldsDescription'),
	                }
	            ],
	            objects: {
	                general: {
	                    properties: {
	                        formatString: visuals.StandardObjectProperties.formatString,
	                    },
	                },
	                labels: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointLabel'),
	                    properties: {
	                        color: visuals.StandardObjectProperties.dataColor,
	                        labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
	                        labelPrecision: visuals.StandardObjectProperties.labelPrecision,
	                        // NOTE: Consider adding a ValueType for fontSize.
	                        fontSize: visuals.StandardObjectProperties.fontSize,
	                    },
	                },
	                categoryLabels: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_CategoryLabel'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        color: visuals.StandardObjectProperties.dataColor,
	                        // NOTE: Consider adding a ValueType for fontSize.
	                        fontSize: visuals.StandardObjectProperties.fontSize,
	                    },
	                },
	                wordWrap: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_WordWrap'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                    },
	                },
	            },
	            dataViewMappings: [{
	                    conditions: [
	                        { 'Values': { max: 1 } }
	                    ],
	                    single: { role: "Values" }
	                }],
	            suppressDefaultTitle: true,
	            supportsSelection: false,
	        };
	        visuals.cardProps = {
	            categoryLabels: {
	                show: { objectName: 'categoryLabels', propertyName: 'show' },
	                color: { objectName: 'categoryLabels', propertyName: 'color' },
	                fontSize: { objectName: 'categoryLabels', propertyName: 'fontSize' },
	            },
	            labels: {
	                color: { objectName: 'labels', propertyName: 'color' },
	                labelPrecision: { objectName: 'labels', propertyName: 'labelPrecision' },
	                labelDisplayUnits: { objectName: 'labels', propertyName: 'labelDisplayUnits' },
	                fontSize: { objectName: 'labels', propertyName: 'fontSize' },
	            },
	            wordWrap: {
	                show: { objectName: 'wordWrap', propertyName: 'show' },
	            },
	        };
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 172 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        visuals.waterfallChartCapabilities = {
	            dataRoles: [
	                {
	                    name: 'Category',
	                    kind: powerbi.VisualDataRoleKind.Grouping,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Category'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_CategoryWaterfallDescription')
	                }, {
	                    name: 'Y',
	                    kind: powerbi.VisualDataRoleKind.Measure,
	                    requiredTypes: [{ numeric: true }, { integer: true }],
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Y'),
	                }
	            ],
	            objects: {
	                general: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
	                    properties: {
	                        formatString: visuals.StandardObjectProperties.formatString,
	                    },
	                },
	                legend: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
	                    description: powerbi.data.createDisplayNameGetter('Visual_LegendDescription'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        position: visuals.StandardObjectProperties.legendPosition,
	                        showTitle: visuals.StandardObjectProperties.showLegendTitle,
	                        titleText: $.extend({}, visuals.StandardObjectProperties.legendTitle, {
	                            suppressFormatPainterCopy: true,
	                        }),
	                        labelColor: visuals.StandardObjectProperties.labelColor,
	                        fontSize: visuals.StandardObjectProperties.fontSize,
	                    }
	                },
	                labels: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
	                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabelsDescription'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        color: visuals.StandardObjectProperties.dataColor,
	                        labelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits,
	                        labelPrecision: $.extend({}, visuals.StandardObjectProperties.labelPrecision, {
	                            suppressFormatPainterCopy: true,
	                        }),
	                        fontSize: visuals.StandardObjectProperties.fontSize,
	                    }
	                },
	                sentimentColors: {
	                    displayName: powerbi.data.createDisplayNameGetter('Waterfall_SentimentColors'),
	                    properties: {
	                        increaseFill: {
	                            displayName: powerbi.data.createDisplayNameGetter('Waterfall_IncreaseLabel'),
	                            type: { fill: { solid: { color: true } } }
	                        },
	                        decreaseFill: {
	                            displayName: powerbi.data.createDisplayNameGetter('Waterfall_DecreaseLabel'),
	                            type: { fill: { solid: { color: true } } }
	                        },
	                        totalFill: {
	                            displayName: powerbi.data.createDisplayNameGetter('Waterfall_TotalLabel'),
	                            type: { fill: { solid: { color: true } } }
	                        }
	                    },
	                },
	                categoryAxis: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_XAxis'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        showAxisTitle: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_XTitleDescription'),
	                            type: { bool: true }
	                        },
	                        axisStyle: visuals.StandardObjectProperties.axisStyle,
	                        labelColor: visuals.StandardObjectProperties.labelColor,
	                    }
	                },
	                valueAxis: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        position: visuals.StandardObjectProperties.yAxisPosition,
	                        start: visuals.StandardObjectProperties.axisStart,
	                        end: visuals.StandardObjectProperties.axisEnd,
	                        showAxisTitle: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_YTitleDescription'),
	                            type: { bool: true }
	                        },
	                        axisStyle: visuals.StandardObjectProperties.axisStyle,
	                        labelColor: visuals.StandardObjectProperties.labelColor,
	                        labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
	                        labelPrecision: visuals.StandardObjectProperties.labelPrecision,
	                    }
	                },
	                y1AxisReferenceLine: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line'),
	                    description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Description'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                        displayName: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_DisplayName'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_DisplayName_Description'),
	                            type: { text: true }
	                        },
	                        value: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value_Description'),
	                            type: { numeric: true }
	                        },
	                        lineColor: visuals.StandardObjectProperties.lineColor,
	                        transparency: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency_Description'),
	                            type: { numeric: true }
	                        },
	                        style: visuals.StandardObjectProperties.referenceLineStyle,
	                        position: visuals.StandardObjectProperties.referenceLinePosition,
	                        dataLabelShow: visuals.StandardObjectProperties.dataLabelShow,
	                        dataLabelColor: visuals.StandardObjectProperties.dataLabelColor,
	                        dataLabelDecimalPoints: visuals.StandardObjectProperties.dataLabelDecimalPoints,
	                        dataLabelHorizontalPosition: visuals.StandardObjectProperties.dataLabelHorizontalPosition,
	                        dataLabelVerticalPosition: visuals.StandardObjectProperties.dataLabelVerticalPosition,
	                        dataLabelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits,
	                    },
	                },
	                plotArea: {
	                    displayName: powerbi.data.createDisplayNameGetter('Visual_Plot'),
	                    properties: {
	                        transparency: visuals.StandardObjectProperties.transparency,
	                        image: visuals.StandardObjectProperties.image,
	                    },
	                },
	            },
	            dataViewMappings: [{
	                    conditions: [
	                        { 'Category': { max: 1 }, 'Y': { max: 1 } },
	                    ],
	                    categorical: {
	                        categories: {
	                            for: { in: 'Category' },
	                            dataReductionAlgorithm: { top: {} }
	                        },
	                        values: {
	                            select: [{ bind: { to: 'Y' } }]
	                        },
	                    },
	                }],
	            sorting: {
	                default: {},
	            },
	            drilldown: {
	                roles: ['Category']
	            },
	        };
	        visuals.waterfallChartProps = {
	            general: {
	                formatString: { objectName: 'general', propertyName: 'formatString' },
	            },
	            sentimentColors: {
	                increaseFill: { objectName: 'sentimentColors', propertyName: 'increaseFill' },
	                decreaseFill: { objectName: 'sentimentColors', propertyName: 'decreaseFill' },
	                totalFill: { objectName: 'sentimentColors', propertyName: 'totalFill' },
	            },
	            legend: {
	                labelColor: { objectName: 'legend', propertyName: 'labelColor' },
	            },
	        };
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 173 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        visuals.KPIStatusWithHistoryCapabilities = {
	            dataRoles: [
	                {
	                    name: 'Indicator',
	                    kind: powerbi.VisualDataRoleKind.Measure,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_Indicator'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_IndicatorDescription')
	                }, {
	                    name: 'TrendLine',
	                    kind: powerbi.VisualDataRoleKind.Grouping,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_TrendLine'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_Trendline_Description')
	                }, {
	                    name: 'Goal',
	                    kind: powerbi.VisualDataRoleKind.Measure,
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_Goal'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_GoalDescription')
	                }],
	            dataViewMappings: [{
	                    conditions: [
	                        { 'Indicator': { max: 1 }, 'TrendLine': { max: 1 }, 'Goal': { max: 2 } },
	                    ],
	                    categorical: {
	                        categories: {
	                            for: { in: 'TrendLine' },
	                            dataReductionAlgorithm: { top: {} }
	                        },
	                        values: {
	                            select: [
	                                { bind: { to: 'Indicator' } },
	                                { bind: { to: 'Goal' } }
	                            ]
	                        }
	                    },
	                }],
	            objects: {
	                general: {
	                    properties: {
	                        formatString: visuals.StandardObjectProperties.formatString,
	                    },
	                },
	                indicator: {
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_Indicator'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_IndicatorDescription'),
	                    properties: {
	                        indicatorDisplayUnits: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_DisplayUnitsDescription'),
	                            type: { formatting: { labelDisplayUnits: true } }
	                        },
	                        indicatorPrecision: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_PrecisionDescription'),
	                            placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
	                            type: { numeric: true }
	                        },
	                        kpiFormat: {
	                            displayName: powerbi.data.createDisplayNameGetter('TaskPane_Format'),
	                            type: { text: true },
	                        }
	                    }
	                },
	                trendline: {
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_TrendLine'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_Trendline_Description'),
	                    properties: {
	                        show: visuals.StandardObjectProperties.show,
	                    }
	                },
	                goals: {
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_Goals'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_Goals'),
	                    properties: {
	                        showGoal: {
	                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_Show_Goal'),
	                            type: { bool: true }
	                        },
	                        showDistance: {
	                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_Show_Distance'),
	                            type: { bool: true }
	                        },
	                    }
	                },
	                status: {
	                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_Status'),
	                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_Status'),
	                    properties: {
	                        direction: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_KPI_Direction'),
	                            type: { enumeration: visuals.kpiDirection.type }
	                        }
	                    }
	                }
	            },
	        };
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 174 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="./_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var capabilities;
	        (function (capabilities) {
	            // This file registers the built-in capabilities
	            // Please use this file to register the capabilities in the plugins.ts/pluginsNotForOSS.ts
	            capabilities.animatedNumber = powerbi.visuals.animatedNumberCapabilities;
	            capabilities.areaChart = powerbi.visuals.lineChartCapabilities;
	            capabilities.barChart = powerbi.visuals.getColumnChartCapabilities(true);
	            capabilities.card = powerbi.visuals.cardCapabilities;
	            capabilities.multiRowCard = powerbi.visuals.multiRowCardCapabilities;
	            capabilities.clusteredBarChart = powerbi.visuals.getColumnChartCapabilities(true);
	            capabilities.clusteredColumnChart = powerbi.visuals.getColumnChartCapabilities();
	            capabilities.columnChart = powerbi.visuals.getColumnChartCapabilities();
	            capabilities.comboChart = powerbi.visuals.comboChartCapabilities;
	            capabilities.dataDotChart = powerbi.visuals.dataDotChartCapabilities;
	            capabilities.dataDotClusteredColumnComboChart = powerbi.visuals.comboChartCapabilities;
	            capabilities.dataDotStackedColumnComboChart = powerbi.visuals.comboChartCapabilities;
	            capabilities.donutChart = powerbi.visuals.donutChartCapabilities;
	            capabilities.funnel = powerbi.visuals.funnelChartCapabilities;
	            capabilities.gauge = powerbi.visuals.gaugeCapabilities;
	            capabilities.hundredPercentStackedBarChart = powerbi.visuals.getColumnChartCapabilities(true);
	            capabilities.hundredPercentStackedColumnChart = powerbi.visuals.getColumnChartCapabilities();
	            capabilities.image = powerbi.visuals.imageVisualCapabilities;
	            capabilities.lineChart = powerbi.visuals.lineChartCapabilities;
	            capabilities.lineStackedColumnComboChart = powerbi.visuals.comboChartCapabilities;
	            capabilities.lineClusteredColumnComboChart = powerbi.visuals.comboChartCapabilities;
	            capabilities.map = powerbi.visuals.mapCapabilities;
	            capabilities.filledMap = powerbi.visuals.filledMapCapabilities;
	            capabilities.treemap = powerbi.visuals.treemapCapabilities;
	            capabilities.pieChart = powerbi.visuals.donutChartCapabilities;
	            capabilities.scatterChart = powerbi.visuals.scatterChartCapabilities;
	            capabilities.table = powerbi.visuals.tableCapabilities;
	            capabilities.matrix = powerbi.visuals.matrixCapabilities;
	            capabilities.slicer = powerbi.visuals.slicerCapabilities;
	            capabilities.textbox = powerbi.visuals.textboxCapabilities;
	            capabilities.waterfallChart = powerbi.visuals.waterfallChartCapabilities;
	            capabilities.cheerMeter = powerbi.visuals.cheerMeterCapabilities;
	            capabilities.scriptVisual = powerbi.visuals.scriptVisualCapabilities;
	            capabilities.kpi = powerbi.visuals.KPIStatusWithHistoryCapabilities;
	        })(capabilities = visuals.capabilities || (visuals.capabilities = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 175 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var ColumnChartWebBehavior = (function () {
	            function ColumnChartWebBehavior() {
	            }
	            ColumnChartWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
	                this.options = options;
	                var eventGroup = options.eventGroup;
	                eventGroup.on('click', function () {
	                    var d = ColumnChartWebBehavior.getDatumForLastInputEvent();
	                    selectionHandler.handleSelection(d, d3.event.ctrlKey);
	                });
	                eventGroup.on('contextmenu', function () {
	                    if (d3.event.ctrlKey)
	                        return;
	                    d3.event.preventDefault();
	                    var d = ColumnChartWebBehavior.getDatumForLastInputEvent();
	                    var position = visuals.InteractivityUtils.getPositionOfLastInputEvent();
	                    selectionHandler.handleContextMenu(d, position);
	                });
	            };
	            ColumnChartWebBehavior.prototype.renderSelection = function (hasSelection) {
	                var options = this.options;
	                options.bars.style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && options.hasHighlights); });
	            };
	            ColumnChartWebBehavior.getDatumForLastInputEvent = function () {
	                var target = d3.event.target;
	                return d3.select(target).datum();
	            };
	            return ColumnChartWebBehavior;
	        }());
	        visuals.ColumnChartWebBehavior = ColumnChartWebBehavior;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 176 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var DataDotChartWebBehavior = (function () {
	            function DataDotChartWebBehavior() {
	            }
	            DataDotChartWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
	                var dots = this.dots = options.dots;
	                var dotLabels = options.dotLabels;
	                visuals.InteractivityUtils.registerStandardInteractivityHandlers(dots, selectionHandler);
	                if (dotLabels) {
	                    visuals.InteractivityUtils.registerStandardInteractivityHandlers(dotLabels, selectionHandler);
	                }
	            };
	            DataDotChartWebBehavior.prototype.renderSelection = function (hasSelection) {
	                this.dots.style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, false); });
	            };
	            return DataDotChartWebBehavior;
	        }());
	        visuals.DataDotChartWebBehavior = DataDotChartWebBehavior;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 177 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var DonutChartWebBehavior = (function () {
	            function DonutChartWebBehavior() {
	            }
	            DonutChartWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
	                var slices = this.slices = options.slices;
	                var highlightSlices = this.highlightSlices = options.highlightSlices;
	                var clearCatcher = options.clearCatcher;
	                this.hasHighlights = options.hasHighlights;
	                var clickHandler = function (d) {
	                    selectionHandler.handleSelection(d.data, d3.event.ctrlKey);
	                };
	                var contextMenuHandler = function (d) {
	                    if (d3.event.ctrlKey)
	                        return;
	                    var position = visuals.InteractivityUtils.getPositionOfLastInputEvent();
	                    selectionHandler.handleContextMenu(d.data, position);
	                    d3.event.preventDefault();
	                };
	                slices.on('click', clickHandler);
	                slices.on('contextmenu', contextMenuHandler);
	                highlightSlices.on('click', clickHandler);
	                highlightSlices.on('contextmenu', contextMenuHandler);
	                clearCatcher.on('click', function () {
	                    selectionHandler.handleClearSelection();
	                });
	            };
	            DonutChartWebBehavior.prototype.renderSelection = function (hasSelection) {
	                var hasHighlights = this.hasHighlights;
	                this.slices.style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, hasSelection, hasHighlights && !d.data.selected); });
	                this.highlightSlices.style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, true, false, hasHighlights); });
	            };
	            return DonutChartWebBehavior;
	        }());
	        visuals.DonutChartWebBehavior = DonutChartWebBehavior;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 178 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var FunnelWebBehavior = (function () {
	            function FunnelWebBehavior() {
	            }
	            FunnelWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
	                var bars = this.bars = options.bars;
	                var interactors = this.interactors = options.interactors;
	                var clearCatcher = options.clearCatcher;
	                this.hasHighlights = options.hasHighlights;
	                visuals.InteractivityUtils.registerStandardInteractivityHandlers(bars, selectionHandler);
	                visuals.InteractivityUtils.registerStandardInteractivityHandlers(interactors, selectionHandler);
	                clearCatcher.on('click', function () {
	                    selectionHandler.handleClearSelection();
	                });
	            };
	            FunnelWebBehavior.prototype.renderSelection = function (hasSelection) {
	                var hasHighlights = this.hasHighlights;
	                this.bars.style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights); });
	            };
	            return FunnelWebBehavior;
	        }());
	        visuals.FunnelWebBehavior = FunnelWebBehavior;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 179 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>

	

/***/ },
/* 180 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var LineChartWebBehavior = (function () {
	            function LineChartWebBehavior() {
	            }
	            LineChartWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
	                var _this = this;
	                this.lines = options.lines;
	                var interactivityLines = options.interactivityLines;
	                var dots = this.dots = options.dots;
	                var areas = this.areas = options.areas;
	                var tooltipOverlay = this.tooltipOverlay = options.tooltipOverlay;
	                var getPointX = function (rootNode) { return _this.getPointX(rootNode); };
	                interactivityLines.on('click', function (d, index) {
	                    var categoryIndex = options.getCategoryIndex(d, getPointX(this));
	                    selectionHandler.handleSelection(d.data[categoryIndex], d3.event.ctrlKey);
	                });
	                visuals.InteractivityUtils.registerStandardInteractivityHandlers(dots, selectionHandler);
	                if (areas) {
	                    visuals.InteractivityUtils.registerStandardInteractivityHandlers(areas, selectionHandler);
	                }
	                if (tooltipOverlay) {
	                    if (options.categoryIdentities) {
	                        tooltipOverlay.on('click', function () {
	                            var categoryIndex = options.getCategoryIndex(undefined, getPointX(this));
	                            selectionHandler.handleSelection({
	                                selected: false,
	                                identity: undefined,
	                                specificIdentity: options.categoryIdentities[categoryIndex],
	                            }, d3.event.ctrlKey);
	                        });
	                    }
	                    else {
	                        tooltipOverlay.on('click', function () { return selectionHandler.handleClearSelection(); });
	                    }
	                }
	            };
	            LineChartWebBehavior.prototype.renderSelection = function (hasSelection) {
	                this.lines.style("stroke-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); });
	                this.dots.style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); });
	                if (this.areas)
	                    this.areas.style("fill-opacity", function (d) { return (hasSelection && !d.selected) ? visuals.LineChart.DimmedAreaFillOpacity : visuals.LineChart.AreaFillOpacity; });
	            };
	            LineChartWebBehavior.prototype.getPointX = function (rootNode) {
	                var e = d3.event, s;
	                while (s = e.sourceEvent)
	                    e = s;
	                var rect = rootNode.getBoundingClientRect();
	                return e.clientX - rect.left - rootNode.clientLeft;
	            };
	            return LineChartWebBehavior;
	        }());
	        visuals.LineChartWebBehavior = LineChartWebBehavior;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 181 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var MapBehavior = (function () {
	            function MapBehavior() {
	                this.mapPointerEventsDisabled = false;
	                this.mapPointerTimeoutSet = false;
	                this.viewChangedSinceLastClearMouseDown = false;
	                this.receivedZoomOrPanEvent = false;
	            }
	            MapBehavior.prototype.bindEvents = function (options, selectionHandler) {
	                var _this = this;
	                var bubbles = this.bubbles = options.bubbles;
	                var slices = this.slices = options.slices;
	                var shapes = this.shapes = options.shapes;
	                var clearCatcher = options.clearCatcher;
	                var clickHandler = function () {
	                    var target = d3.event.target;
	                    var d = d3.select(target).datum();
	                    if (bubbles)
	                        bubbles.style("pointer-events", "all");
	                    if (shapes)
	                        shapes.style("pointer-events", "all");
	                    selectionHandler.handleSelection(d, d3.event.ctrlKey);
	                };
	                if (!this.mapPointerEventsDisabled) {
	                    if (bubbles)
	                        bubbles.style("pointer-events", "all");
	                    if (slices)
	                        slices.style("pointer-events", "all");
	                    if (shapes)
	                        shapes.style("pointer-events", "all");
	                }
	                if (bubbles) {
	                    options.bubbleEventGroup.on('click', clickHandler);
	                    options.bubbleEventGroup.on('mousewheel', function () {
	                        if (!_this.mapPointerEventsDisabled)
	                            bubbles.style("pointer-events", "none");
	                        _this.mapPointerEventsDisabled = true;
	                        if (!_this.mapPointerTimeoutSet) {
	                            _this.mapPointerTimeoutSet = true;
	                            setTimeout(function () {
	                                if (bubbles)
	                                    bubbles.style("pointer-events", "all");
	                                _this.mapPointerEventsDisabled = false;
	                                _this.mapPointerTimeoutSet = false;
	                            }, 200);
	                        }
	                    });
	                    visuals.InteractivityUtils.registerGroupContextMenuHandler(options.bubbleEventGroup, selectionHandler);
	                }
	                if (slices) {
	                    options.sliceEventGroup.on('click', function () {
	                        slices.style("pointer-events", "all");
	                        _this.mapPointerEventsDisabled = false;
	                        var target = d3.event.target;
	                        var d = d3.select(target).datum();
	                        selectionHandler.handleSelection(d.data, d3.event.ctrlKey);
	                    });
	                    options.sliceEventGroup.on('mousewheel', function () {
	                        if (!_this.mapPointerEventsDisabled)
	                            slices.style("pointer-events", "none");
	                        _this.mapPointerEventsDisabled = true;
	                        if (!_this.mapPointerTimeoutSet) {
	                            _this.mapPointerTimeoutSet = true;
	                            setTimeout(function () {
	                                if (slices)
	                                    slices.style("pointer-events", "all");
	                                _this.mapPointerEventsDisabled = false;
	                                _this.mapPointerTimeoutSet = false;
	                            }, 200);
	                        }
	                    });
	                    options.sliceEventGroup.on('contextmenu', function () {
	                        if (d3.event.ctrlKey)
	                            return;
	                        d3.event.preventDefault();
	                        var position = visuals.InteractivityUtils.getPositionOfLastInputEvent();
	                        var target = d3.event.target;
	                        var d = d3.select(target).datum();
	                        selectionHandler.handleContextMenu(d.data, position);
	                    });
	                }
	                if (shapes) {
	                    options.shapeEventGroup.on('click', clickHandler);
	                    options.shapeEventGroup.on('mousewheel', function () {
	                        if (!_this.mapPointerEventsDisabled) {
	                            shapes.style("pointer-events", "none");
	                        }
	                        _this.mapPointerEventsDisabled = true;
	                        if (!_this.mapPointerTimeoutSet) {
	                            _this.mapPointerTimeoutSet = true;
	                            setTimeout(function () {
	                                if (shapes)
	                                    shapes.style("pointer-events", "all");
	                                _this.mapPointerEventsDisabled = false;
	                                _this.mapPointerTimeoutSet = false;
	                            }, 200);
	                        }
	                    });
	                    visuals.InteractivityUtils.registerGroupContextMenuHandler(options.shapeEventGroup, selectionHandler);
	                }
	                clearCatcher.on('mouseup', function () {
	                    if (!_this.viewChangedSinceLastClearMouseDown) {
	                        selectionHandler.handleClearSelection();
	                        _this.receivedZoomOrPanEvent = true;
	                    }
	                });
	                clearCatcher.on('mousedown', function () {
	                    _this.viewChangedSinceLastClearMouseDown = false;
	                });
	                clearCatcher.on('mousewheel', function () {
	                    _this.receivedZoomOrPanEvent = true;
	                });
	            };
	            MapBehavior.prototype.renderSelection = function (hasSelection) {
	                if (this.bubbles) {
	                    this.bubbles
	                        .style({
	                        'fill-opacity': function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); },
	                        'stroke-opacity': function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); },
	                    });
	                }
	                if (this.slices) {
	                    this.slices
	                        .style({
	                        "fill-opacity": function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, hasSelection, false); },
	                        "stroke-opacity": function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, hasSelection, false); },
	                    });
	                }
	                if (this.shapes) {
	                    this.shapes
	                        .style({
	                        "fill-opacity": function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); },
	                        "stroke-opacity": function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); },
	                    });
	                }
	            };
	            MapBehavior.prototype.viewChanged = function () {
	                this.viewChangedSinceLastClearMouseDown = true;
	            };
	            MapBehavior.prototype.resetZoomPan = function () {
	                this.receivedZoomOrPanEvent = false;
	            };
	            MapBehavior.prototype.hasReceivedZoomOrPanEvent = function () {
	                return this.receivedZoomOrPanEvent;
	            };
	            return MapBehavior;
	        }());
	        visuals.MapBehavior = MapBehavior;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 182 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
	        var ScatterChartWebBehavior = (function () {
	            function ScatterChartWebBehavior() {
	            }
	            ScatterChartWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
	                var bubbles = this.bubbles = options.dataPointsSelection;
	                var data = options.data;
	                var eventGroup = options.eventGroup;
	                // If we are removing play-axis, remove the trace lines as well
	                // TODO: revisit this design, I think ideally this is done when rendering scatter.
	                if (this.playOptions
	                    && this.playOptions.traceLineRenderer
	                    && (!options.playOptions || !options.playOptions.traceLineRenderer)) {
	                    this.playOptions.traceLineRenderer.remove();
	                }
	                this.playOptions = options.playOptions;
	                this.shouldEnableFill = (!data.sizeRange || !data.sizeRange.min) && data.fillPoint;
	                this.colorBorder = data.colorBorder;
	                if (eventGroup) {
	                    visuals.InteractivityUtils.registerGroupInteractivityHandlers(eventGroup, selectionHandler);
	                }
	                else {
	                    visuals.InteractivityUtils.registerStandardInteractivityHandlers(bubbles, selectionHandler);
	                }
	            };
	            ScatterChartWebBehavior.prototype.renderSelection = function (hasSelection) {
	                var shouldEnableFill = this.shouldEnableFill;
	                var colorBorder = this.colorBorder;
	                this.bubbles.style("fill-opacity", function (d) { return visuals.ScatterChart.getMarkerFillOpacity(d.size != null, shouldEnableFill, hasSelection, d.selected); });
	                this.bubbles.style("stroke-opacity", function (d) { return visuals.ScatterChart.getMarkerStrokeOpacity(d.size != null, colorBorder, hasSelection, d.selected); });
	                if (this.playOptions && this.bubbles) {
	                    var selectedPoints = this.bubbles.filter(function (d) { return d.selected; }).data();
	                    var traceLineRenderer = this.playOptions.traceLineRenderer;
	                    if (selectedPoints && selectedPoints.length > 0 && traceLineRenderer != null) {
	                        traceLineRenderer.render(selectedPoints, true);
	                    }
	                    else {
	                        traceLineRenderer.remove();
	                    }
	                }
	            };
	            return ScatterChartWebBehavior;
	        }());
	        visuals.ScatterChartWebBehavior = ScatterChartWebBehavior;
	        var ScatterChartMobileBehavior = (function () {
	            function ScatterChartMobileBehavior() {
	            }
	            ScatterChartMobileBehavior.prototype.bindEvents = function (options, selectionHandler) {
	                this.setOptions(options);
	                if (!options.visualInitOptions || !options.visualInitOptions.interactivity.isInteractiveLegend) {
	                    // Don't bind events if we are not in interactiveLegend mode
	                    // This case happend when on mobile we show the whole dashboard in still not on focus
	                    return;
	                }
	                this.makeDataPointsSelectable(options.dataPointsSelection);
	                this.makeRootSelectable(options.root);
	                this.makeDragable(options.root);
	                this.disableDefaultTouchInteractions(options.root);
	                this.selectRoot();
	            };
	            ScatterChartMobileBehavior.prototype.renderSelection = function (HasSelection) { };
	            ScatterChartMobileBehavior.prototype.setSelectionHandler = function (selectionHandler) { };
	            ScatterChartMobileBehavior.prototype.makeDataPointsSelectable = function () {
	                var _this = this;
	                var selection = [];
	                for (var _i = 0; _i < arguments.length; _i++) {
	                    selection[_i - 0] = arguments[_i];
	                }
	                for (var i = 0, len = selection.length; i < len; i++) {
	                    var sel = selection[i];
	                    sel.on('click', function (d, i) {
	                        _this.select(i);
	                    });
	                }
	            };
	            ScatterChartMobileBehavior.prototype.makeRootSelectable = function (selection) {
	                var _this = this;
	                selection.on('click', function (d, i) {
	                    _this.selectRoot();
	                });
	            };
	            ScatterChartMobileBehavior.prototype.makeDragable = function () {
	                var _this = this;
	                var selection = [];
	                for (var _i = 0; _i < arguments.length; _i++) {
	                    selection[_i - 0] = arguments[_i];
	                }
	                for (var i = 0, len = selection.length; i < len; i++) {
	                    var sel = selection[i];
	                    var drag = d3.behavior.drag()
	                        .on('drag', function (d) { _this.drag(0 /* Drag */); })
	                        .on('dragend', function (d) { _this.drag(1 /* DragEnd */); });
	                    sel.call(drag);
	                }
	            };
	            ScatterChartMobileBehavior.prototype.disableDefaultTouchInteractions = function (selection) {
	                selection.style('touch-action', 'none');
	            };
	            ScatterChartMobileBehavior.prototype.setOptions = function (options) {
	                this.data = options.data;
	                this.mainGraphicsContext = options.plotContext;
	                this.xAxisProperties = options.xAxisProperties;
	                this.yAxisProperties = options.yAxisProperties;
	                this.host = options.host;
	            };
	            ScatterChartMobileBehavior.prototype.select = function (index) {
	                this.selectDotByIndex(index);
	            };
	            ScatterChartMobileBehavior.prototype.selectRoot = function () {
	                var marker = jsCommon.PerformanceUtil.create('selectRoot');
	                this.onClick();
	                marker.end();
	            };
	            ScatterChartMobileBehavior.prototype.drag = function (t) {
	                switch (t) {
	                    case 0 /* Drag */:
	                        this.onDrag();
	                        break;
	                    case 1 /* DragEnd */:
	                        this.onClick();
	                        break;
	                    default:
	                        debug.assertFail('Unknown Drag Type');
	                }
	            };
	            ScatterChartMobileBehavior.prototype.onDrag = function () {
	                //find the current x and y position
	                var xy = this.getMouseCoordinates();
	                //move the crosshair to the current position
	                this.moveCrosshairToXY(xy.x, xy.y);
	                //update the style and the legend of the dots
	                var selectedIndex = this.findClosestDotIndex(xy.x, xy.y);
	                this.selectDot(selectedIndex);
	                this.updateLegend(selectedIndex);
	            };
	            ScatterChartMobileBehavior.prototype.onClick = function () {
	                //find the current x and y position
	                var xy = this.getMouseCoordinates();
	                var selectedIndex = this.findClosestDotIndex(xy.x, xy.y);
	                if (selectedIndex !== -1)
	                    this.selectDotByIndex(selectedIndex);
	            };
	            ScatterChartMobileBehavior.prototype.getMouseCoordinates = function () {
	                var mainGfxContext = this.mainGraphicsContext;
	                // select (0,0) in cartesian coordinates
	                var x = 0;
	                var y = parseInt(mainGfxContext.attr('height'), 10);
	                y = y || 0;
	                try {
	                    var mouse = d3.mouse(mainGfxContext.node());
	                    x = mouse[0];
	                    y = mouse[1];
	                }
	                catch (e) {
	                }
	                return { x: x, y: y, };
	            };
	            ScatterChartMobileBehavior.prototype.selectDotByIndex = function (index) {
	                this.selectDot(index);
	                this.moveCrosshairToIndexDot(index);
	                this.updateLegend(index);
	            };
	            ScatterChartMobileBehavior.prototype.selectDot = function (dotIndex) {
	                var _this = this;
	                var root = this.mainGraphicsContext;
	                root.selectAll(ScatterChartMobileBehavior.ScatterChartCircleTagName + ScatterChartMobileBehavior.DotClassSelector).classed({ selected: false, notSelected: true });
	                root.selectAll(ScatterChartMobileBehavior.ScatterChartCircleTagName + ScatterChartMobileBehavior.DotClassSelector).filter(function (d, i) {
	                    var dataPoints = _this.data.dataPoints;
	                    debug.assert(dataPoints.length > dotIndex, "dataPoints length:" + dataPoints.length + "is smaller than index:" + dotIndex);
	                    var currentPoint = dataPoints[dotIndex];
	                    return (d.x === currentPoint.x) && (d.y === currentPoint.y);
	                }).classed({ selected: true, notSelected: false });
	            };
	            ScatterChartMobileBehavior.prototype.moveCrosshairToIndexDot = function (index) {
	                var dataPoints = this.data.dataPoints;
	                var root = this.mainGraphicsContext;
	                debug.assert(dataPoints.length > index, "dataPoints length:" + dataPoints.length + "is smaller than index:" + index);
	                var x = this.xAxisProperties.scale(dataPoints[index].x);
	                var y = this.yAxisProperties.scale(dataPoints[index].y);
	                if (this.crosshair == null) {
	                    var width = +root.attr('width');
	                    var height = +root.attr('height');
	                    this.crosshair = this.drawCrosshair(root, x, y, width, height);
	                    this.crosshairHorizontal = this.crosshair.select(ScatterChartMobileBehavior.Horizontal.selector);
	                    this.crosshairVertical = this.crosshair.select(ScatterChartMobileBehavior.Vertical.selector);
	                }
	                else {
	                    this.moveCrosshairToXY(x, y);
	                }
	            };
	            ScatterChartMobileBehavior.prototype.moveCrosshairToXY = function (x, y) {
	                this.crosshairHorizontal.attr({ y1: y, y2: y });
	                this.crosshairVertical.attr({ x1: x, x2: x });
	            };
	            ScatterChartMobileBehavior.prototype.drawCrosshair = function (addTo, x, y, width, height) {
	                var crosshair = addTo.append("g");
	                crosshair.classed(ScatterChartMobileBehavior.CrosshairClassName, true);
	                crosshair.append('line').classed(ScatterChartMobileBehavior.Horizontal.class, true).attr({ x1: 0, x2: width, y1: y, y2: y });
	                crosshair.append('line').classed(ScatterChartMobileBehavior.Vertical.class, true).attr({ x1: x, x2: x, y1: height, y2: 0 });
	                return crosshair;
	            };
	            ScatterChartMobileBehavior.prototype.findClosestDotIndex = function (x, y) {
	                var selectedIndex = -1;
	                var minDistance = Number.MAX_VALUE;
	                var dataPoints = this.data.dataPoints;
	                var xAxisPropertiesScale = this.xAxisProperties.scale;
	                var yAxisPropertiesScale = this.yAxisProperties.scale;
	                for (var i in dataPoints) {
	                    var currentPoint = dataPoints[i];
	                    var circleX = xAxisPropertiesScale(currentPoint.x);
	                    var circleY = yAxisPropertiesScale(currentPoint.y);
	                    var horizontalDistance = circleX - x;
	                    var verticalDistance = circleY - y;
	                    var distanceSqrd = (horizontalDistance * horizontalDistance) + (verticalDistance * verticalDistance);
	                    if (minDistance === Number.MAX_VALUE) {
	                        selectedIndex = i;
	                        minDistance = distanceSqrd;
	                    }
	                    else if (minDistance && minDistance > distanceSqrd) {
	                        selectedIndex = i;
	                        minDistance = distanceSqrd;
	                    }
	                }
	                return selectedIndex;
	            };
	            ScatterChartMobileBehavior.prototype.updateLegend = function (dotIndex) {
	                if (this.lastDotIndex == null || this.lastDotIndex !== dotIndex) {
	                    var legendItems = this.createLegendDataPoints(dotIndex);
	                    this.host.updateLegend(legendItems);
	                    this.lastDotIndex = dotIndex;
	                }
	            };
	            ScatterChartMobileBehavior.prototype.createLegendDataPoints = function (dotIndex) {
	                var formatStringProp = visuals.scatterChartProps.general.formatString;
	                var legendItems = [];
	                var data = this.data;
	                debug.assert(data.dataPoints.length > dotIndex, "dataPoints length:" + data.dataPoints.length + "is smaller than index:" + dotIndex);
	                var point = data.dataPoints[dotIndex];
	                //set the title of the legend to be the category or radius or group or blank
	                var blank = visuals.valueFormatter.format(null);
	                var title = blank;
	                var legendData = data.legendData;
	                debug.assertValue(legendData, "legendData");
	                debug.assertValue(legendData.dataPoints, "legendData");
	                var legendDataPoints = legendData.dataPoints;
	                var category = point.formattedCategory.getValue();
	                if (category !== blank) {
	                    title = category;
	                    if (point != null && point.radius != null && point.radius.sizeMeasure != null) {
	                        title += "; " + visuals.valueFormatter.format(point.radius.sizeMeasure.source.groupName);
	                    }
	                }
	                else if (point.radius.sizeMeasure != null) {
	                    title = visuals.valueFormatter.format(point.radius.sizeMeasure.source.groupName);
	                }
	                else if (legendDataPoints.length >= dotIndex && legendDataPoints[dotIndex].label !== blank) {
	                    title = legendDataPoints[dotIndex].label;
	                }
	                if (data.xCol != null) {
	                    legendItems.push({
	                        category: title,
	                        color: point.fill,
	                        identity: visuals.SelectionIdBuilder.builder().withMeasure(data.xCol.queryName).createSelectionId(),
	                        selected: point.selected,
	                        icon: visuals.LegendIcon.Box,
	                        label: visuals.valueFormatter.format(this.data.axesLabels.x),
	                        measure: visuals.valueFormatter.format(point.x, visuals.valueFormatter.getFormatString(data.xCol, formatStringProp)),
	                        iconOnlyOnLabel: true,
	                    });
	                }
	                if (data.yCol != null) {
	                    legendItems.push({
	                        category: title,
	                        color: point.fill,
	                        identity: visuals.SelectionIdBuilder.builder().withMeasure(data.yCol.queryName).createSelectionId(),
	                        selected: point.selected,
	                        icon: visuals.LegendIcon.Box,
	                        label: visuals.valueFormatter.format(data.axesLabels.y),
	                        measure: visuals.valueFormatter.format(point.y, visuals.valueFormatter.getFormatString(data.yCol, formatStringProp)),
	                        iconOnlyOnLabel: true,
	                    });
	                }
	                if (data.size != null) {
	                    legendItems.push({
	                        category: title,
	                        color: point.fill,
	                        identity: visuals.SelectionIdBuilder.builder().withMeasure(data.size.queryName).createSelectionId(),
	                        selected: point.selected,
	                        icon: visuals.LegendIcon.Box,
	                        label: visuals.valueFormatter.format(data.size.displayName),
	                        measure: visuals.valueFormatter.format(point.radius.sizeMeasure.values[point.radius.index], visuals.valueFormatter.getFormatString(data.size, formatStringProp)),
	                        iconOnlyOnLabel: true
	                    });
	                }
	                return { dataPoints: legendItems };
	            };
	            ScatterChartMobileBehavior.CrosshairClassName = 'crosshair';
	            ScatterChartMobileBehavior.ScatterChartCircleTagName = 'circle';
	            ScatterChartMobileBehavior.DotClassName = 'dot';
	            ScatterChartMobileBehavior.DotClassSelector = '.' + ScatterChartMobileBehavior.DotClassName;
	            ScatterChartMobileBehavior.Horizontal = createClassAndSelector('horizontal');
	            ScatterChartMobileBehavior.Vertical = createClassAndSelector('vertical');
	            return ScatterChartMobileBehavior;
	        }());
	        visuals.ScatterChartMobileBehavior = ScatterChartMobileBehavior;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 183 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var HorizontalSlicerWebBehavior = (function () {
	            function HorizontalSlicerWebBehavior() {
	            }
	            HorizontalSlicerWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
	                this.itemLabels = options.itemLabels;
	                this.dataPoints = options.dataPoints;
	                this.interactivityService = options.interactivityService;
	                this.slicerSettings = options.settings;
	                visuals.SlicerWebBehavior.bindSlicerEvents(options, this.itemLabels, selectionHandler, this.slicerSettings, this.interactivityService);
	            };
	            HorizontalSlicerWebBehavior.prototype.renderSelection = function (hasSelection) {
	                visuals.SlicerWebBehavior.setSelectionOnSlicerItems(this.itemLabels, this.itemLabels, hasSelection, this.interactivityService, this.slicerSettings);
	            };
	            return HorizontalSlicerWebBehavior;
	        }());
	        visuals.HorizontalSlicerWebBehavior = HorizontalSlicerWebBehavior;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 184 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var VerticalSlicerWebBehavior = (function () {
	            function VerticalSlicerWebBehavior() {
	            }
	            VerticalSlicerWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
	                var slicers = options.itemContainers;
	                this.itemLabels = options.itemLabels;
	                this.itemInputs = options.itemInputs;
	                this.dataPoints = options.dataPoints;
	                this.interactivityService = options.interactivityService;
	                this.settings = options.settings;
	                visuals.SlicerWebBehavior.bindSlicerEvents(options, slicers, selectionHandler, this.settings, this.interactivityService);
	            };
	            VerticalSlicerWebBehavior.prototype.renderSelection = function (hasSelection) {
	                visuals.SlicerWebBehavior.setSelectionOnSlicerItems(this.itemInputs, this.itemLabels, hasSelection, this.interactivityService, this.settings);
	            };
	            return VerticalSlicerWebBehavior;
	        }());
	        visuals.VerticalSlicerWebBehavior = VerticalSlicerWebBehavior;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 185 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var DOMConstants = jsCommon.DOMConstants;
	        var KeyUtils = jsCommon.KeyUtils;
	        var SlicerWebBehavior = (function () {
	            function SlicerWebBehavior() {
	            }
	            SlicerWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
	                this.behavior = this.createWebBehavior(options);
	                this.behavior.bindEvents(options.behaviorOptions, selectionHandler);
	            };
	            SlicerWebBehavior.prototype.renderSelection = function (hasSelection) {
	                this.behavior.renderSelection(hasSelection);
	            };
	            SlicerWebBehavior.bindSlicerEvents = function (behaviorOptions, slicers, selectionHandler, slicerSettings, interactivityService) {
	                SlicerWebBehavior.bindSlicerItemSelectionEvent(slicers, selectionHandler, slicerSettings, interactivityService);
	                SlicerWebBehavior.bindSlicerClearEvent(behaviorOptions.clear, selectionHandler);
	                if (behaviorOptions.searchInput)
	                    SlicerWebBehavior.bindSlicerSearchEvent(behaviorOptions.searchInput, selectionHandler, behaviorOptions.slicerValueHandler);
	                SlicerWebBehavior.styleSlicerContainer(behaviorOptions.slicerContainer, interactivityService);
	            };
	            SlicerWebBehavior.setSelectionOnSlicerItems = function (selectableItems, itemLabel, hasSelection, interactivityService, slicerSettings) {
	                if (!hasSelection && !interactivityService.isSelectionModeInverted()) {
	                    selectableItems.filter('.selected').classed('selected', false);
	                    selectableItems.filter('.partiallySelected').classed('partiallySelected', false);
	                    var input = selectableItems.selectAll('input');
	                    if (input) {
	                        input.property('checked', false);
	                    }
	                    itemLabel.style('color', slicerSettings.slicerText.color);
	                }
	                else {
	                    SlicerWebBehavior.styleSlicerItems(selectableItems, hasSelection, interactivityService.isSelectionModeInverted());
	                }
	            };
	            SlicerWebBehavior.styleSlicerItems = function (slicerItems, hasSelection, isSelectionInverted) {
	                slicerItems.each(function (d) {
	                    var slicerItem = this;
	                    var shouldCheck = false;
	                    if (d.isSelectAllDataPoint) {
	                        if (hasSelection) {
	                            slicerItem.classList.add('partiallySelected');
	                            shouldCheck = false;
	                        }
	                        else {
	                            slicerItem.classList.remove('partiallySelected');
	                            shouldCheck = isSelectionInverted;
	                        }
	                    }
	                    else {
	                        shouldCheck = jsCommon.LogicExtensions.XOR(d.selected, isSelectionInverted);
	                    }
	                    if (shouldCheck)
	                        slicerItem.classList.add('selected');
	                    else
	                        slicerItem.classList.remove('selected');
	                    // Set input selected state to match selection
	                    var input = slicerItem.getElementsByTagName('input')[0];
	                    if (input)
	                        input.checked = shouldCheck;
	                });
	            };
	            SlicerWebBehavior.bindSlicerItemSelectionEvent = function (slicers, selectionHandler, slicerSettings, interactivityService) {
	                slicers.on("click", function (d) {
	                    d3.event.preventDefault();
	                    if (d.isSelectAllDataPoint) {
	                        selectionHandler.toggleSelectionModeInversion();
	                    }
	                    else {
	                        selectionHandler.handleSelection(d, SlicerWebBehavior.isMultiSelect(d3.event, slicerSettings, interactivityService));
	                    }
	                    selectionHandler.persistSelectionFilter(visuals.slicerProps.filterPropertyIdentifier);
	                });
	            };
	            SlicerWebBehavior.bindSlicerClearEvent = function (slicerClear, selectionHandler) {
	                if (slicerClear) {
	                    slicerClear.on("click", function () {
	                        selectionHandler.handleClearSelection();
	                        selectionHandler.persistSelectionFilter(visuals.slicerProps.filterPropertyIdentifier);
	                    });
	                }
	            };
	            SlicerWebBehavior.bindSlicerSearchEvent = function (slicerSearch, selectionHandler, slicerValueHandler) {
	                if (slicerSearch.empty())
	                    return;
	                slicerSearch.on(DOMConstants.keyDownEventName, function () {
	                    if (d3.event.ctrlKey && KeyUtils.isCtrlDefaultKey(d3.event.keyCode))
	                        d3.event.stopPropagation();
	                    else if (KeyUtils.isArrowKey(d3.event.keyCode) || d3.event.keyCode === DOMConstants.deleteKeyCode)
	                        d3.event.stopPropagation();
	                    else if (d3.event.keyCode === DOMConstants.escKeyCode) {
	                        // Clear search when ESC key is pressed
	                        selectionHandler.persistSelfFilter(visuals.slicerProps.selfFilterPropertyIdentifier, null);
	                        d3.event.stopPropagation();
	                    }
	                    else if (d3.event.keyCode === DOMConstants.enterKeyCode) {
	                        SlicerWebBehavior.startSearch(slicerSearch, selectionHandler, slicerValueHandler);
	                        d3.event.stopPropagation();
	                    }
	                }).on(DOMConstants.keyUpEventName, _.debounce(function () {
	                    SlicerWebBehavior.startSearch(slicerSearch, selectionHandler, slicerValueHandler);
	                }, SlicerWebBehavior.searchInputTimeoutDuration));
	            };
	            SlicerWebBehavior.startSearch = function (slicerSearch, selectionHandler, slicerValueHandler) {
	                var element = slicerSearch.node();
	                var searchKey = element && element.value;
	                searchKey = _.trim(searchKey);
	                // When searchKey is cleared.
	                if (_.isEmpty(searchKey)) {
	                    selectionHandler.persistSelfFilter(visuals.slicerProps.selfFilterPropertyIdentifier, null);
	                    return;
	                }
	                var updatedFilter = slicerValueHandler.getUpdatedSelfFilter(searchKey);
	                if (updatedFilter)
	                    selectionHandler.persistSelfFilter(visuals.slicerProps.selfFilterPropertyIdentifier, updatedFilter);
	            };
	            SlicerWebBehavior.styleSlicerContainer = function (slicerContainer, interactivityService) {
	                var hasSelection = (interactivityService.hasSelection() && interactivityService.isDefaultValueEnabled() === undefined)
	                    || interactivityService.isDefaultValueEnabled() === false;
	                slicerContainer.classed('hasSelection', hasSelection);
	            };
	            SlicerWebBehavior.isMultiSelect = function (event, settings, interactivityService) {
	                // If selection is inverted, assume we're always in multi-select mode;
	                // Also, Ctrl can be used to multi-select even in single-select mode.
	                return interactivityService.isSelectionModeInverted()
	                    || !settings.selection.singleSelect
	                    || event.ctrlKey;
	            };
	            SlicerWebBehavior.prototype.createWebBehavior = function (options) {
	                var behavior;
	                var orientation = options.orientation;
	                switch (orientation) {
	                    case 1 /* Horizontal */:
	                        behavior = new visuals.HorizontalSlicerWebBehavior();
	                        break;
	                    case 0 /* Vertical */:
	                    default:
	                        behavior = new visuals.VerticalSlicerWebBehavior();
	                        break;
	                }
	                return behavior;
	            };
	            SlicerWebBehavior.searchInputTimeoutDuration = 500;
	            return SlicerWebBehavior;
	        }());
	        visuals.SlicerWebBehavior = SlicerWebBehavior;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 186 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var LegendBehavior = (function () {
	            function LegendBehavior() {
	            }
	            LegendBehavior.prototype.bindEvents = function (options, selectionHandler) {
	                var legendItems = options.legendItems;
	                this.legendIcons = options.legendIcons;
	                var clearCatcher = options.clearCatcher;
	                visuals.InteractivityUtils.registerStandardSelectionHandler(legendItems, selectionHandler);
	                clearCatcher.on('click', function () {
	                    selectionHandler.handleClearSelection();
	                });
	            };
	            LegendBehavior.prototype.renderSelection = function (hasSelection) {
	                if (hasSelection) {
	                    this.legendIcons.style({
	                        'fill': function (d) {
	                            if (!d.selected)
	                                return LegendBehavior.dimmedLegendColor;
	                            else
	                                return d.color;
	                        }
	                    });
	                }
	                else {
	                    this.legendIcons.style({
	                        'fill': function (d) {
	                            return d.color;
	                        }
	                    });
	                }
	            };
	            LegendBehavior.dimmedLegendColor = '#A6A6A6';
	            return LegendBehavior;
	        }());
	        visuals.LegendBehavior = LegendBehavior;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 187 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var TreemapWebBehavior = (function () {
	            function TreemapWebBehavior() {
	            }
	            TreemapWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
	                var shapes = this.shapes = options.shapes;
	                var highlightShapes = this.highlightShapes = options.highlightShapes;
	                var majorLabels = options.majorLabels;
	                var minorLabels = options.minorLabels;
	                this.hasHighlights = options.hasHighlights;
	                visuals.InteractivityUtils.registerStandardInteractivityHandlers(shapes, selectionHandler);
	                visuals.InteractivityUtils.registerStandardInteractivityHandlers(highlightShapes, selectionHandler);
	                if (majorLabels) {
	                    visuals.InteractivityUtils.registerStandardInteractivityHandlers(majorLabels, selectionHandler);
	                }
	                if (minorLabels) {
	                    visuals.InteractivityUtils.registerStandardInteractivityHandlers(minorLabels, selectionHandler);
	                }
	            };
	            TreemapWebBehavior.prototype.renderSelection = function (hasSelection) {
	                var hasHighlights = this.hasHighlights;
	                this.shapes
	                    .style("fill", function (d) { return visuals.Treemap.getFill(d, /* isHighlightRect */ false); })
	                    .style("fill-opacity", function (d) { return visuals.Treemap.getFillOpacity(d, hasSelection, !d.selected && hasHighlights, /* isHighlightRect */ false); });
	                this.highlightShapes
	                    .style("fill", function (d) { return visuals.Treemap.getFill(d, /* isHighlightRect */ true); })
	                    .style("fill-opacity", function (d) { return visuals.Treemap.getFillOpacity(d, hasSelection, !d.selected && hasHighlights, /* isHighlightRect */ true); });
	            };
	            return TreemapWebBehavior;
	        }());
	        visuals.TreemapWebBehavior = TreemapWebBehavior;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 188 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var WaterfallChartWebBehavior = (function () {
	            function WaterfallChartWebBehavior() {
	            }
	            WaterfallChartWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
	                var bars = this.bars = options.bars;
	                bars.on('click', function (d) {
	                    if (!d.isTotal) {
	                        selectionHandler.handleSelection(d, d3.event.ctrlKey);
	                    }
	                });
	                bars.on('contextmenu', function (d) {
	                    if (d3.event.ctrlKey)
	                        return;
	                    d3.event.preventDefault();
	                    if (!d.isTotal) {
	                        var position = visuals.InteractivityUtils.getPositionOfLastInputEvent();
	                        selectionHandler.handleContextMenu(d, position);
	                    }
	                });
	            };
	            WaterfallChartWebBehavior.prototype.renderSelection = function (hasSelection) {
	                this.bars.style("fill-opacity", function (d) { return d.isTotal ? visuals.ColumnUtil.DefaultOpacity : visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, false); });
	            };
	            return WaterfallChartWebBehavior;
	        }());
	        visuals.WaterfallChartWebBehavior = WaterfallChartWebBehavior;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 189 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var LabelsBehavior = (function () {
	            function LabelsBehavior() {
	            }
	            LabelsBehavior.prototype.bindEvents = function (options, selectionHandler) {
	                this.labelItems = options.labelItems;
	                visuals.InteractivityUtils.registerStandardSelectionHandler(this.labelItems, selectionHandler);
	            };
	            LabelsBehavior.prototype.renderSelection = function (hasSelection) {
	                if (hasSelection) {
	                    this.labelItems.style({
	                        'opacity': function (d) {
	                            if (!d.selected)
	                                return LabelsBehavior.DimmedLabelOpacity;
	                            else
	                                return LabelsBehavior.DefaultLabelOpacity;
	                        }
	                    });
	                }
	                else {
	                    this.labelItems.style({
	                        'opacity': LabelsBehavior.DefaultLabelOpacity,
	                    });
	                }
	            };
	            LabelsBehavior.DefaultLabelOpacity = 1;
	            LabelsBehavior.DimmedLabelOpacity = 0.6;
	            return LabelsBehavior;
	        }());
	        visuals.LabelsBehavior = LabelsBehavior;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 190 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var CartesianChartBehavior = (function () {
	            function CartesianChartBehavior(behaviors) {
	                this.behaviors = behaviors;
	            }
	            CartesianChartBehavior.prototype.bindEvents = function (options, selectionHandler) {
	                var behaviors = this.behaviors;
	                for (var i = 0, ilen = behaviors.length; i < ilen; i++) {
	                    behaviors[i].bindEvents(options.layerOptions[i], selectionHandler);
	                }
	                options.clearCatcher.on('click', function () {
	                    selectionHandler.handleClearSelection();
	                });
	            };
	            CartesianChartBehavior.prototype.renderSelection = function (hasSelection) {
	                for (var _i = 0, _a = this.behaviors; _i < _a.length; _i++) {
	                    var behavior = _a[_i];
	                    behavior.renderSelection(hasSelection);
	                }
	            };
	            return CartesianChartBehavior;
	        }());
	        visuals.CartesianChartBehavior = CartesianChartBehavior;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 191 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>

	

/***/ },
/* 192 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        /**
	         * Default ranges are for when we have a field chosen for the axis,
	         * but no values are returned by the query.
	         */
	        visuals.emptyDomain = [0, 0];
	        var AxisHelper;
	        (function (AxisHelper) {
	            var XLabelMaxAllowedOverflow = 35;
	            var TextHeightConstant = 10;
	            var MinTickCount = 2;
	            var DefaultBestTickCount = 3;
	            var LeftPadding = 10;
	            var ScalarTickLabelPadding = 3;
	            function getRecommendedNumberOfTicksForXAxis(availableWidth) {
	                if (availableWidth < 300)
	                    return 3;
	                if (availableWidth < 500)
	                    return 5;
	                return 8;
	            }
	            AxisHelper.getRecommendedNumberOfTicksForXAxis = getRecommendedNumberOfTicksForXAxis;
	            function getRecommendedNumberOfTicksForYAxis(availableWidth) {
	                if (availableWidth < 150)
	                    return 3;
	                if (availableWidth < 300)
	                    return 5;
	                return 8;
	            }
	            AxisHelper.getRecommendedNumberOfTicksForYAxis = getRecommendedNumberOfTicksForYAxis;
	            /**
	             * Get the best number of ticks based on minimum value, maximum value,
	             * measure metadata and max tick count.
	             *
	             * @param min The minimum of the data domain.
	             * @param max The maximum of the data domain.
	             * @param valuesMetadata The measure metadata array.
	             * @param maxTickCount The max count of intervals.
	             * @param isDateTime - flag to show single tick when min is equal to max.
	             */
	            function getBestNumberOfTicks(min, max, valuesMetadata, maxTickCount, isDateTime) {
	                debug.assert(maxTickCount >= 0, "maxTickCount must be greater or equal to zero");
	                if (isNaN(min) || isNaN(max))
	                    return DefaultBestTickCount;
	                debug.assert(min <= max, "min value needs to be less or equal to max value");
	                if (maxTickCount <= 1 || (max <= 1 && min >= -1))
	                    return maxTickCount;
	                if (min === max) {
	                    // datetime needs to only show one tick value in this case so formatting works correctly
	                    if (!!isDateTime)
	                        return 1;
	                    return DefaultBestTickCount;
	                }
	                if (hasNonIntegerData(valuesMetadata))
	                    return maxTickCount;
	                // e.g. 5 - 2 + 1 = 4, => [2,3,4,5]
	                return Math.min(max - min + 1, maxTickCount);
	            }
	            AxisHelper.getBestNumberOfTicks = getBestNumberOfTicks;
	            function hasNonIntegerData(valuesMetadata) {
	                for (var i = 0, len = valuesMetadata.length; i < len; i++) {
	                    var currentMetadata = valuesMetadata[i];
	                    if (currentMetadata && currentMetadata.type && !currentMetadata.type.integer) {
	                        return true;
	                    }
	                }
	                return false;
	            }
	            AxisHelper.hasNonIntegerData = hasNonIntegerData;
	            function getRecommendedTickValues(maxTicks, scale, axisType, isScalar, minTickInterval) {
	                if (!isScalar || isOrdinalScale(scale)) {
	                    return getRecommendedTickValuesForAnOrdinalRange(maxTicks, scale.domain());
	                }
	                else if (isDateTime(axisType)) {
	                    return getRecommendedTickValuesForADateTimeRange(maxTicks, scale.domain());
	                }
	                return getRecommendedTickValuesForAQuantitativeRange(maxTicks, scale, minTickInterval);
	            }
	            AxisHelper.getRecommendedTickValues = getRecommendedTickValues;
	            function getRecommendedTickValuesForAnOrdinalRange(maxTicks, labels) {
	                var tickLabels = [];
	                // return no ticks in this case
	                if (maxTicks <= 0)
	                    return tickLabels;
	                var len = labels.length;
	                if (maxTicks > len)
	                    return labels;
	                for (var i = 0, step = Math.ceil(len / maxTicks); i < len; i += step) {
	                    tickLabels.push(labels[i]);
	                }
	                return tickLabels;
	            }
	            AxisHelper.getRecommendedTickValuesForAnOrdinalRange = getRecommendedTickValuesForAnOrdinalRange;
	            function getRecommendedTickValuesForAQuantitativeRange(maxTicks, scale, minInterval) {
	                var tickLabels = [];
	                //if maxticks is zero return none
	                if (maxTicks === 0)
	                    return tickLabels;
	                var quantitiveScale = scale;
	                if (quantitiveScale.ticks) {
	                    tickLabels = quantitiveScale.ticks(maxTicks);
	                    if (tickLabels.length > maxTicks && maxTicks > 1)
	                        tickLabels = quantitiveScale.ticks(maxTicks - 1);
	                    if (tickLabels.length < MinTickCount) {
	                        tickLabels = quantitiveScale.ticks(maxTicks + 1);
	                    }
	                    tickLabels = createTrueZeroTickLabel(tickLabels);
	                    if (minInterval && tickLabels.length > 1) {
	                        var tickInterval = tickLabels[1] - tickLabels[0];
	                        while (tickInterval > 0 && tickInterval < minInterval) {
	                            for (var i = 1; i < tickLabels.length; i++) {
	                                tickLabels.splice(i, 1);
	                            }
	                            tickInterval = tickInterval * 2;
	                        }
	                        // keep at least two labels - the loop above may trim all but one if we have odd # of tick labels and dynamic range < minInterval
	                        if (tickLabels.length === 1) {
	                            tickLabels.push(tickLabels[0] + minInterval);
	                        }
	                    }
	                    return tickLabels;
	                }
	                debug.assertFail('must pass a quantitative scale to this method');
	                return tickLabels;
	            }
	            AxisHelper.getRecommendedTickValuesForAQuantitativeRange = getRecommendedTickValuesForAQuantitativeRange;
	            /**
	             * Round out very small zero tick values (e.g. -1e-33 becomes 0).
	             *
	             * @param ticks Array of numbers (from d3.scale.ticks([maxTicks])).
	             * @param epsilon Max ratio of calculated tick interval which we will recognize as zero.
	             *
	             * e.g.
	             *     ticks = [-2, -1, 1e-10, 3, 4]; epsilon = 1e-5;
	             *     closeZero = 1e-5 * | 2 - 1 | = 1e-5
	             *     // Tick values <= 1e-5 replaced with 0
	             *     return [-2, -1, 0, 3, 4];
	             */
	            function createTrueZeroTickLabel(ticks, epsilon) {
	                if (epsilon === void 0) { epsilon = 1e-5; }
	                if (!ticks || ticks.length < 2)
	                    return ticks;
	                var closeZero = epsilon * Math.abs(ticks[1] - ticks[0]);
	                return ticks.map(function (tick) { return Math.abs(tick) <= closeZero ? 0 : tick; });
	            }
	            function getRecommendedTickValuesForADateTimeRange(maxTicks, dataDomain) {
	                var tickLabels = [];
	                if (dataDomain[0] === 0 && dataDomain[1] === 0)
	                    return [];
	                var dateTimeTickLabels = powerbi.DateTimeSequence.calculate(new Date(dataDomain[0]), new Date(dataDomain[1]), maxTicks).sequence;
	                tickLabels = dateTimeTickLabels.map(function (d) { return d.getTime(); });
	                tickLabels = ensureValuesInRange(tickLabels, dataDomain[0], dataDomain[1]);
	                return tickLabels;
	            }
	            function normalizeLinearDomain(domain) {
	                if (isNaN(domain.min) || isNaN(domain.max)) {
	                    domain.min = visuals.emptyDomain[0];
	                    domain.max = visuals.emptyDomain[1];
	                }
	                else if (domain.min === domain.max) {
	                    // d3 linear scale will give zero tickValues if max === min, so extend a little
	                    domain.min = domain.min < 0 ? domain.min * 1.2 : domain.min * 0.8;
	                    domain.max = domain.max < 0 ? domain.max * 0.8 : domain.max * 1.2;
	                }
	                else {
	                    // Check that min is very small and is a negligable portion of the whole domain.
	                    // (fix floating pt precision bugs)
	                    // sometimes highlight value math causes small negative numbers which makes the axis add
	                    // a large tick interval instead of just rendering at zero.
	                    if (Math.abs(domain.min) < 0.0001 && domain.min / (domain.max - domain.min) < 0.0001) {
	                        domain.min = 0;
	                    }
	                }
	                return domain;
	            }
	            function getMargin(availableWidth, availableHeight, xMargin, yMargin) {
	                if (getRecommendedNumberOfTicksForXAxis(availableWidth - xMargin) === 0
	                    || getRecommendedNumberOfTicksForYAxis(availableHeight - yMargin) === 0) {
	                    return {
	                        top: 0,
	                        right: xMargin,
	                        bottom: yMargin,
	                        left: 0
	                    };
	                }
	                return {
	                    top: 20,
	                    right: 30,
	                    bottom: 40,
	                    left: 30
	                };
	            }
	            AxisHelper.getMargin = getMargin;
	            // TODO: Put the parameters into one object
	            function getTickLabelMargins(viewport, yMarginLimit, textWidthMeasurer, textHeightMeasurer, axes, bottomMarginLimit, properties, scrollbarVisible, showOnRight, renderXAxis, renderY1Axis, renderY2Axis) {
	                debug.assertValue(axes, 'axes');
	                var xAxisProperties = axes.x;
	                var y1AxisProperties = axes.y1;
	                var y2AxisProperties = axes.y2;
	                debug.assertValue(viewport, 'viewport');
	                debug.assertValue(textWidthMeasurer, 'textWidthMeasurer');
	                debug.assertValue(textHeightMeasurer, 'textHeightMeasurer');
	                debug.assertValue(xAxisProperties, 'xAxis');
	                debug.assertValue(y1AxisProperties, 'yAxis');
	                var xLabels = xAxisProperties.values;
	                var y1Labels = y1AxisProperties.values;
	                var leftOverflow = 0;
	                var rightOverflow = 0;
	                var maxWidthY1 = 0;
	                var maxWidthY2 = 0;
	                var xMax = 0; // bottom margin
	                var ordinalLabelOffset = xAxisProperties.categoryThickness ? xAxisProperties.categoryThickness / 2 : 0;
	                var scaleIsOrdinal = isOrdinalScale(xAxisProperties.scale);
	                var xLabelOuterPadding = 0;
	                if (xAxisProperties.outerPadding !== undefined) {
	                    xLabelOuterPadding = xAxisProperties.outerPadding;
	                }
	                else if (xAxisProperties.xLabelMaxWidth !== undefined) {
	                    xLabelOuterPadding = Math.max(0, (viewport.width - xAxisProperties.xLabelMaxWidth * xLabels.length) / 2);
	                }
	                if (getRecommendedNumberOfTicksForXAxis(viewport.width) !== 0
	                    || getRecommendedNumberOfTicksForYAxis(viewport.height) !== 0) {
	                    var rotation = void 0;
	                    if (scrollbarVisible)
	                        rotation = LabelLayoutStrategy.DefaultRotationWithScrollbar;
	                    else
	                        rotation = LabelLayoutStrategy.DefaultRotation;
	                    if (renderY1Axis) {
	                        for (var i = 0, len = y1Labels.length; i < len; i++) {
	                            properties.text = y1Labels[i];
	                            maxWidthY1 = Math.max(maxWidthY1, textWidthMeasurer(properties));
	                        }
	                    }
	                    if (y2AxisProperties && renderY2Axis) {
	                        var y2Labels = y2AxisProperties.values;
	                        for (var i = 0, len = y2Labels.length; i < len; i++) {
	                            properties.text = y2Labels[i];
	                            maxWidthY2 = Math.max(maxWidthY2, textWidthMeasurer(properties));
	                        }
	                    }
	                    var textHeight = textHeightMeasurer(properties);
	                    var maxNumLines = Math.floor(bottomMarginLimit / textHeight);
	                    var xScale = xAxisProperties.scale;
	                    var xDomain = xScale.domain();
	                    if (renderXAxis && xLabels.length > 0) {
	                        for (var i = 0, len = xLabels.length; i < len; i++) {
	                            // find the max height of the x-labels, perhaps rotated or wrapped
	                            var height = void 0;
	                            properties.text = xLabels[i];
	                            var width = textWidthMeasurer(properties);
	                            if (xAxisProperties.willLabelsWordBreak) {
	                                // Split label and count rows
	                                var wordBreaks = jsCommon.WordBreaker.splitByWidth(properties.text, properties, textWidthMeasurer, xAxisProperties.xLabelMaxWidth, maxNumLines);
	                                height = wordBreaks.length * textHeight;
	                                // word wrapping will truncate at xLabelMaxWidth
	                                width = xAxisProperties.xLabelMaxWidth;
	                            }
	                            else if (!xAxisProperties.willLabelsFit && scaleIsOrdinal) {
	                                height = width * rotation.sine;
	                                width = width * rotation.cosine;
	                            }
	                            else {
	                                height = TextHeightConstant;
	                            }
	                            // calculate left and right overflow due to wide X labels
	                            // (Note: no right overflow when rotated)
	                            if (i === 0) {
	                                if (scaleIsOrdinal) {
	                                    if (!xAxisProperties.willLabelsFit /*rotated text*/)
	                                        leftOverflow = width - ordinalLabelOffset - xLabelOuterPadding;
	                                    else
	                                        leftOverflow = (width / 2) - ordinalLabelOffset - xLabelOuterPadding;
	                                    leftOverflow = Math.max(leftOverflow, 0);
	                                }
	                                else if (xDomain.length > 1) {
	                                    // Scalar - do some math
	                                    var xPos = xScale(xDomain[0]);
	                                    // xPos already incorporates xLabelOuterPadding, don't subtract it twice
	                                    leftOverflow = (width / 2) - xPos;
	                                    leftOverflow = Math.max(leftOverflow, 0);
	                                }
	                            }
	                            else if (i === len - 1) {
	                                if (scaleIsOrdinal) {
	                                    // if we are rotating text (!willLabelsFit) there won't be any right overflow
	                                    if (xAxisProperties.willLabelsFit || xAxisProperties.willLabelsWordBreak) {
	                                        // assume this label is placed near the edge
	                                        rightOverflow = (width / 2) - ordinalLabelOffset - xLabelOuterPadding;
	                                        rightOverflow = Math.max(rightOverflow, 0);
	                                    }
	                                }
	                                else if (xDomain.length > 1) {
	                                    // Scalar - do some math
	                                    var xPos = xScale(xDomain[1]);
	                                    // xPos already incorporates xLabelOuterPadding, don't subtract it twice
	                                    rightOverflow = (width / 2) - (viewport.width - xPos);
	                                    rightOverflow = Math.max(rightOverflow, 0);
	                                }
	                            }
	                            xMax = Math.max(xMax, height);
	                        }
	                        // trim any actual overflow to the limit
	                        leftOverflow = Math.min(leftOverflow, XLabelMaxAllowedOverflow);
	                        rightOverflow = Math.min(rightOverflow, XLabelMaxAllowedOverflow);
	                    }
	                }
	                var rightMargin = 0, leftMargin = 0, bottomMargin = Math.min(Math.ceil(xMax), bottomMarginLimit);
	                if (showOnRight) {
	                    leftMargin = Math.min(Math.max(leftOverflow, maxWidthY2), yMarginLimit);
	                    rightMargin = Math.min(Math.max(rightOverflow, maxWidthY1), yMarginLimit);
	                }
	                else {
	                    leftMargin = Math.min(Math.max(leftOverflow, maxWidthY1), yMarginLimit);
	                    rightMargin = Math.min(Math.max(rightOverflow, maxWidthY2), yMarginLimit);
	                }
	                return {
	                    xMax: Math.ceil(bottomMargin),
	                    yLeft: Math.ceil(leftMargin),
	                    yRight: Math.ceil(rightMargin),
	                };
	            }
	            AxisHelper.getTickLabelMargins = getTickLabelMargins;
	            function columnDataTypeHasValue(dataType) {
	                return dataType && (dataType.bool || dataType.numeric || dataType.text || dataType.dateTime);
	            }
	            AxisHelper.columnDataTypeHasValue = columnDataTypeHasValue;
	            function createOrdinalType() {
	                return powerbi.ValueType.fromDescriptor({ text: true });
	            }
	            AxisHelper.createOrdinalType = createOrdinalType;
	            function isOrdinal(type) {
	                return !!(type && (type.text || type.bool || (type.misc && type.misc.barcode) || (type.geography && type.geography.postalCode)));
	            }
	            AxisHelper.isOrdinal = isOrdinal;
	            function isOrdinalScale(scale) {
	                return typeof scale.invert === 'undefined';
	            }
	            AxisHelper.isOrdinalScale = isOrdinalScale;
	            function isDateTime(type) {
	                return !!(type && type.dateTime);
	            }
	            AxisHelper.isDateTime = isDateTime;
	            function invertScale(scale, x) {
	                if (isOrdinalScale(scale)) {
	                    return invertOrdinalScale(scale, x);
	                }
	                return scale.invert(x);
	            }
	            AxisHelper.invertScale = invertScale;
	            function extent(scale) {
	                if (isOrdinalScale(scale)) {
	                    return scale.rangeExtent();
	                }
	                return scale.range();
	            }
	            AxisHelper.extent = extent;
	            function invertOrdinalScale(scale, x) {
	                var leftEdges = scale.range();
	                if (leftEdges.length < 2)
	                    return 0;
	                var width = scale.rangeBand();
	                var halfInnerPadding = (leftEdges[1] - leftEdges[0] - width) / 2;
	                var j;
	                for (j = 0; x > (leftEdges[j] + width + halfInnerPadding) && j < (leftEdges.length - 1); j++)
	                    ;
	                return scale.domain()[j];
	            }
	            AxisHelper.invertOrdinalScale = invertOrdinalScale;
	            function findClosestXAxisIndex(categoryValue, categoryAxisValues) {
	                var closestValueIndex = -1;
	                var minDistance = Number.MAX_VALUE;
	                for (var i in categoryAxisValues) {
	                    var distance = Math.abs(categoryValue - categoryAxisValues[i].categoryValue);
	                    if (distance < minDistance) {
	                        minDistance = distance;
	                        closestValueIndex = parseInt(i, 10);
	                    }
	                }
	                return closestValueIndex;
	            }
	            AxisHelper.findClosestXAxisIndex = findClosestXAxisIndex;
	            function lookupOrdinalIndex(scale, pixelValue) {
	                var closestValueIndex = -1;
	                var minDistance = Number.MAX_VALUE;
	                var domain = scale.domain();
	                if (domain.length < 2)
	                    return 0;
	                var halfWidth = (scale(1) - scale(0)) / 2;
	                for (var idx in domain) {
	                    var leftEdgeInPixels = scale(idx);
	                    var midPoint = leftEdgeInPixels + halfWidth;
	                    var distance = Math.abs(pixelValue - midPoint);
	                    if (distance < minDistance) {
	                        minDistance = distance;
	                        closestValueIndex = parseInt(idx, 10);
	                    }
	                }
	                return closestValueIndex;
	            }
	            AxisHelper.lookupOrdinalIndex = lookupOrdinalIndex;
	            /** scale(value1) - scale(value2) with zero checking and min(+/-1, result) */
	            function diffScaled(scale, value1, value2) {
	                debug.assertValue(scale, 'scale');
	                var value = scale(value1) - scale(value2);
	                if (value === 0)
	                    return 0;
	                if (value < 0)
	                    return Math.min(value, -1);
	                return Math.max(value, 1);
	            }
	            AxisHelper.diffScaled = diffScaled;
	            function createDomain(data, axisType, isScalar, forcedScalarDomain, ensureDomain) {
	                if (isScalar && !isOrdinal(axisType)) {
	                    var userMin = void 0, userMax = void 0;
	                    if (forcedScalarDomain && forcedScalarDomain.length === 2) {
	                        userMin = forcedScalarDomain[0];
	                        userMax = forcedScalarDomain[1];
	                    }
	                    return createScalarDomain(data, userMin, userMax, axisType, ensureDomain);
	                }
	                return createOrdinalDomain(data);
	            }
	            AxisHelper.createDomain = createDomain;
	            function ensureValuesInRange(values, min, max) {
	                debug.assert(min <= max, "min must be less or equal to max");
	                var filteredValues = values.filter(function (v) { return v >= min && v <= max; });
	                if (filteredValues.length < 2)
	                    filteredValues = [min, max];
	                return filteredValues;
	            }
	            AxisHelper.ensureValuesInRange = ensureValuesInRange;
	            /**
	             * Gets the ValueType of a category column, defaults to Text if the type is not present.
	             */
	            function getCategoryValueType(metadataColumn, isScalar) {
	                if (metadataColumn && columnDataTypeHasValue(metadataColumn.type))
	                    return metadataColumn.type;
	                if (isScalar) {
	                    return powerbi.ValueType.fromDescriptor({ numeric: true });
	                }
	                return powerbi.ValueType.fromDescriptor({ text: true });
	            }
	            AxisHelper.getCategoryValueType = getCategoryValueType;
	            /**
	             * Create a D3 axis including scale. Can be vertical or horizontal, and either datetime, numeric, or text.
	             * @param options The properties used to create the axis.
	             */
	            function createAxis(options) {
	                var pixelSpan = options.pixelSpan, dataDomain = options.dataDomain, metaDataColumn = options.metaDataColumn, formatString = options.formatString, outerPadding = options.outerPadding || 0, isCategoryAxis = !!options.isCategoryAxis, isScalar = !!options.isScalar, isVertical = !!options.isVertical, useTickIntervalForDisplayUnits = !!options.useTickIntervalForDisplayUnits, // DEPRECATE: same meaning as isScalar?
	                getValueFn = options.getValueFn, categoryThickness = options.categoryThickness, axisDisplayUnits = options.axisDisplayUnits, axisPrecision = options.axisPrecision, is100Pct = !!options.is100Pct;
	                var dataType = AxisHelper.getCategoryValueType(metaDataColumn, isScalar);
	                // Create the Scale
	                var scaleResult = AxisHelper.createScale(options);
	                var scale = scaleResult.scale;
	                var bestTickCount = scaleResult.bestTickCount;
	                var scaleDomain = scale.domain();
	                var isLogScaleAllowed = AxisHelper.isLogScalePossible(dataDomain, dataType);
	                // fix categoryThickness if scalar and the domain was adjusted when making the scale "nice"
	                if (categoryThickness && isScalar && dataDomain && dataDomain.length === 2) {
	                    var oldSpan = dataDomain[1] - dataDomain[0];
	                    var newSpan = scaleDomain[1] - scaleDomain[0];
	                    if (oldSpan > 0 && newSpan > 0) {
	                        categoryThickness = categoryThickness * oldSpan / newSpan;
	                    }
	                }
	                // Prepare Tick Values for formatting
	                var tickValues;
	                if (isScalar && bestTickCount === 1) {
	                    tickValues = [dataDomain[0]];
	                }
	                else {
	                    var minTickInterval = isScalar ? getMinTickValueInterval(formatString, dataType, is100Pct) : undefined;
	                    tickValues = getRecommendedTickValues(bestTickCount, scale, dataType, isScalar, minTickInterval);
	                }
	                if (options.scaleType && options.scaleType === visuals.axisScale.log && isLogScaleAllowed) {
	                    tickValues = tickValues.filter(function (d) { return AxisHelper.powerOfTen(d); });
	                }
	                var formatter = createFormatter(scaleDomain, dataDomain, dataType, isScalar, formatString, bestTickCount, tickValues, getValueFn, useTickIntervalForDisplayUnits, axisDisplayUnits, axisPrecision);
	                // sets default orientation only, cartesianChart will fix y2 for comboChart
	                // tickSize(pixelSpan) is used to create gridLines
	                var axis = d3.svg.axis()
	                    .scale(scale)
	                    .tickSize(6, 0)
	                    .orient(isVertical ? 'left' : 'bottom')
	                    .ticks(bestTickCount)
	                    .tickValues(tickValues);
	                var formattedTickValues = [];
	                if (metaDataColumn)
	                    formattedTickValues = formatAxisTickValues(axis, tickValues, formatter, dataType, getValueFn);
	                var xLabelMaxWidth;
	                // Use category layout of labels if specified, otherwise use scalar layout of labels
	                if (!isScalar && categoryThickness) {
	                    xLabelMaxWidth = Math.max(1, categoryThickness - visuals.CartesianChart.TickLabelPadding * 2);
	                }
	                else {
	                    // When there are 0 or 1 ticks, then xLabelMaxWidth = pixelSpan       
	                    xLabelMaxWidth = tickValues.length > 1 ? getScalarLabelMaxWidth(scale, tickValues) : pixelSpan;
	                    xLabelMaxWidth = xLabelMaxWidth - ScalarTickLabelPadding * 2;
	                }
	                return {
	                    scale: scale,
	                    axis: axis,
	                    formatter: formatter,
	                    values: formattedTickValues,
	                    axisType: dataType,
	                    axisLabel: null,
	                    isCategoryAxis: isCategoryAxis,
	                    xLabelMaxWidth: xLabelMaxWidth,
	                    categoryThickness: categoryThickness,
	                    outerPadding: outerPadding,
	                    usingDefaultDomain: scaleResult.usingDefaultDomain,
	                    isLogScaleAllowed: isLogScaleAllowed,
	                    dataDomain: dataDomain,
	                };
	            }
	            AxisHelper.createAxis = createAxis;
	            function getScalarLabelMaxWidth(scale, tickValues) {
	                debug.assertValue(scale, "scale");
	                debug.assertNonEmpty(tickValues, "tickValues");
	                // find the distance between two ticks. scalar ticks can be anywhere, such as:
	                // |---50----------100--------|
	                if (scale && !_.isEmpty(tickValues)) {
	                    return Math.abs(scale(tickValues[1]) - scale(tickValues[0]));
	                }
	                return 1;
	            }
	            function createScale(options) {
	                var pixelSpan = options.pixelSpan, dataDomain = options.dataDomain, metaDataColumn = options.metaDataColumn, outerPadding = options.outerPadding || 0, isScalar = !!options.isScalar, isVertical = !!options.isVertical, forcedTickCount = options.forcedTickCount, categoryThickness = options.categoryThickness, shouldClamp = !!options.shouldClamp, maxTickCount = options.maxTickCount;
	                var dataType = AxisHelper.getCategoryValueType(metaDataColumn, isScalar);
	                var maxTicks = isVertical ? getRecommendedNumberOfTicksForYAxis(pixelSpan) : getRecommendedNumberOfTicksForXAxis(pixelSpan);
	                if (maxTickCount &&
	                    maxTicks > maxTickCount)
	                    maxTicks = maxTickCount;
	                var scalarDomain = dataDomain ? dataDomain.slice() : null;
	                var bestTickCount = maxTicks;
	                var scale;
	                var usingDefaultDomain = false;
	                if (dataDomain == null || (dataDomain.length === 2 && dataDomain[0] == null && dataDomain[1] == null) || (dataDomain.length !== 2 && isScalar)) {
	                    usingDefaultDomain = true;
	                    if (dataType.dateTime || !isOrdinal(dataType))
	                        dataDomain = visuals.emptyDomain;
	                    else
	                        dataDomain = [];
	                    if (isOrdinal(dataType)) {
	                        scale = createOrdinalScale(pixelSpan, dataDomain, categoryThickness ? outerPadding / categoryThickness : 0);
	                    }
	                    else {
	                        scale = createNumericalScale(options.scaleType, pixelSpan, dataDomain, dataType, outerPadding, bestTickCount);
	                    }
	                }
	                else {
	                    if (isScalar && dataDomain.length > 0) {
	                        bestTickCount = forcedTickCount !== undefined
	                            ? (maxTicks !== 0 ? forcedTickCount : 0)
	                            : AxisHelper.getBestNumberOfTicks(dataDomain[0], dataDomain[dataDomain.length - 1], [metaDataColumn], maxTicks, dataType.dateTime);
	                        var normalizedRange = normalizeLinearDomain({ min: dataDomain[0], max: dataDomain[dataDomain.length - 1] });
	                        scalarDomain = [normalizedRange.min, normalizedRange.max];
	                    }
	                    if (isScalar && dataType.numeric && !dataType.dateTime) {
	                        scale = createNumericalScale(options.scaleType, pixelSpan, scalarDomain, dataType, outerPadding, bestTickCount, shouldClamp);
	                    }
	                    else if (isScalar && dataType.dateTime) {
	                        // Use of a linear scale, instead of a D3.time.scale, is intentional since we want
	                        // to control the formatting of the time values, since d3's implementation isn't
	                        // in accordance to our design.
	                        //     scalarDomain: should already be in long-int time (via category.values[0].getTime())
	                        scale = createLinearScale(pixelSpan, scalarDomain, outerPadding, null, shouldClamp); // DO NOT PASS TICKCOUNT
	                    }
	                    else if (dataType.text || dataType.dateTime || dataType.numeric || dataType.bool) {
	                        scale = createOrdinalScale(pixelSpan, scalarDomain, categoryThickness ? outerPadding / categoryThickness : 0);
	                        bestTickCount = maxTicks === 0 ? 0
	                            : Math.min(scalarDomain.length, (pixelSpan - outerPadding * 2) / visuals.CartesianChart.MinOrdinalRectThickness);
	                    }
	                    else {
	                        debug.assertFail('unsupported dataType, something other than text or numeric');
	                    }
	                }
	                // vertical ordinal axis (e.g. categorical bar chart) does not need to reverse
	                if (isVertical && isScalar) {
	                    scale.range(scale.range().reverse());
	                }
	                visuals.ColumnUtil.normalizeInfinityInScale(scale);
	                return {
	                    scale: scale,
	                    bestTickCount: bestTickCount,
	                    usingDefaultDomain: usingDefaultDomain,
	                };
	            }
	            AxisHelper.createScale = createScale;
	            function createFormatter(scaleDomain, dataDomain, dataType, isScalar, formatString, bestTickCount, tickValues, getValueFn, useTickIntervalForDisplayUnits, axisDisplayUnits, axisPrecision) {
	                if (useTickIntervalForDisplayUnits === void 0) { useTickIntervalForDisplayUnits = false; }
	                var formatter;
	                if (dataType.dateTime) {
	                    if (isScalar) {
	                        var value = new Date(scaleDomain[0]);
	                        var value2 = new Date(scaleDomain[1]);
	                        // datetime with only one value needs to pass the same value
	                        // (from the original dataDomain value, not the adjusted scaleDomain)
	                        // so formatting works correctly.
	                        if (bestTickCount === 1)
	                            value = value2 = new Date(dataDomain[0]);
	                        // this will ignore the formatString and create one based on the smallest non-zero portion of the values supplied.
	                        formatter = visuals.valueFormatter.create({
	                            format: formatString,
	                            value: value,
	                            value2: value2,
	                            tickCount: bestTickCount,
	                        });
	                    }
	                    else {
	                        // Use the model formatString for ordinal datetime
	                        formatter = visuals.valueFormatter.createDefaultFormatter(formatString, true);
	                    }
	                }
	                else {
	                    if (getValueFn == null && !isScalar) {
	                        debug.assertFail('getValueFn must be supplied for ordinal tickValues');
	                    }
	                    if (useTickIntervalForDisplayUnits && isScalar && tickValues.length > 1) {
	                        var value1 = axisDisplayUnits ? axisDisplayUnits : tickValues[1] - tickValues[0];
	                        var options = {
	                            format: formatString,
	                            value: value1,
	                            value2: 0,
	                            allowFormatBeautification: true,
	                        };
	                        if (axisPrecision)
	                            options.precision = axisPrecision;
	                        else
	                            options.detectAxisPrecision = true;
	                        formatter = visuals.valueFormatter.create(options);
	                    }
	                    else {
	                        // do not use display units, just the basic value formatter
	                        // datetime is handled above, so we are ordinal and either boolean, numeric, or text.
	                        formatter = visuals.valueFormatter.createDefaultFormatter(formatString, true);
	                    }
	                }
	                return formatter;
	            }
	            AxisHelper.createFormatter = createFormatter;
	            /**
	             * Format the linear tick labels or the category labels.
	             */
	            function formatAxisTickValues(axis, tickValues, formatter, dataType, getValueFn) {
	                var formattedTickValues = [];
	                if (!getValueFn)
	                    getValueFn = function (data) { return data; };
	                if (formatter) {
	                    axis.tickFormat(function (d) { return formatter.format(getValueFn(d, dataType)); });
	                    formattedTickValues = tickValues.map(function (d) { return formatter.format(getValueFn(d, dataType)); });
	                }
	                else {
	                    formattedTickValues = tickValues.map(function (d) { return getValueFn(d, dataType); });
	                }
	                return formattedTickValues;
	            }
	            function getMinTickValueInterval(formatString, columnType, is100Pct) {
	                var isCustomFormat = formatString && !powerbi.NumberFormat.isStandardFormat(formatString);
	                if (isCustomFormat) {
	                    var precision = powerbi.NumberFormat.getCustomFormatMetadata(formatString, true /*calculatePrecision*/).precision;
	                    if (formatString.indexOf('%') > -1)
	                        precision += 2; //percent values are multiplied by 100 during formatting
	                    return Math.pow(10, -precision);
	                }
	                else if (is100Pct)
	                    return 0.01;
	                else if (columnType.integer)
	                    return 1;
	                return 0;
	            }
	            AxisHelper.getMinTickValueInterval = getMinTickValueInterval;
	            function createScalarDomain(data, userMin, userMax, axisType, ensureDomain) {
	                debug.assertValue(data, 'data');
	                if (data.length === 0) {
	                    return null;
	                }
	                var defaultMinX = d3.min(data, function (kv) { return d3.min(kv.data, function (d) { return d.categoryValue; }); });
	                var defaultMaxX = d3.max(data, function (kv) { return d3.max(kv.data, function (d) { return d.categoryValue; }); });
	                return combineDomain([userMin, userMax], [defaultMinX, defaultMaxX], ensureDomain);
	            }
	            /**
	             * Creates a [min,max] from your Cartiesian data values.
	             *
	             * @param data The series array of CartesianDataPoints.
	             * @param includeZero Columns and bars includeZero, line and scatter do not.
	             */
	            function createValueDomain(data, includeZero) {
	                debug.assertValue(data, 'data');
	                if (data.length === 0)
	                    return null;
	                var minY = d3.min(data, function (kv) { return d3.min(kv.data, function (d) { return d.value; }); });
	                var maxY = d3.max(data, function (kv) { return d3.max(kv.data, function (d) { return d.value; }); });
	                if (includeZero)
	                    return [Math.min(minY, 0), Math.max(maxY, 0)];
	                return [minY, maxY];
	            }
	            AxisHelper.createValueDomain = createValueDomain;
	            function createOrdinalDomain(data) {
	                if (_.isEmpty(data))
	                    return [];
	                // each series shares the same categories for oridinal axes (even if a series has some nulls)
	                var domain = [];
	                var firstSeries = data[0];
	                for (var _i = 0, _a = firstSeries.data; _i < _a.length; _i++) {
	                    var dp = _a[_i];
	                    if (!dp.highlight)
	                        domain.push(dp.categoryIndex);
	                }
	                return domain;
	            }
	            var LabelLayoutStrategy;
	            (function (LabelLayoutStrategy) {
	                function willLabelsFit(axisProperties, availableWidth, textMeasurer, properties) {
	                    var labels = axisProperties.values;
	                    if (labels.length === 0)
	                        return false;
	                    var labelMaxWidth = axisProperties.xLabelMaxWidth !== undefined
	                        ? axisProperties.xLabelMaxWidth
	                        : availableWidth / labels.length;
	                    return !labels.some(function (d) {
	                        properties.text = d;
	                        return textMeasurer(properties) > labelMaxWidth;
	                    });
	                }
	                LabelLayoutStrategy.willLabelsFit = willLabelsFit;
	                function willLabelsWordBreak(axisProperties, margin, availableWidth, textWidthMeasurer, textHeightMeasurer, textTruncator, properties) {
	                    var labels = axisProperties.values;
	                    var labelMaxWidth = axisProperties.xLabelMaxWidth !== undefined
	                        ? axisProperties.xLabelMaxWidth
	                        : availableWidth / labels.length;
	                    var maxRotatedLength = margin.bottom / LabelLayoutStrategy.DefaultRotation.sine;
	                    var height = textHeightMeasurer(properties);
	                    var maxNumLines = Math.max(1, Math.floor(margin.bottom / height)); // TODO: not taking axis label into account
	                    if (labels.length === 0)
	                        return false;
	                    // If no break character and exceeds max width, word breaking will not work, return false
	                    var mustRotate = labels.some(function (label) {
	                        // Detect must rotate and return immediately
	                        properties.text = label;
	                        return !jsCommon.WordBreaker.hasBreakers(label) && textWidthMeasurer(properties) > labelMaxWidth;
	                    });
	                    if (mustRotate)
	                        return false;
	                    var moreWordBreakChars = labels.filter(function (label, index) {
	                        // ...otherwise compare rotation versus word breaking
	                        var allowedLengthProjectedOnXAxis = 
	                        // Left margin is the width of Y axis.
	                        margin.left
	                            + axisProperties.outerPadding
	                            + axisProperties.categoryThickness * (index + 0.5)
	                            - LeftPadding;
	                        var allowedLength = allowedLengthProjectedOnXAxis / LabelLayoutStrategy.DefaultRotation.cosine;
	                        var rotatedLength = Math.min(allowedLength, maxRotatedLength);
	                        // Which shows more characters? Rotated or maxNumLines truncated to labelMaxWidth?
	                        var wordBreakChars = jsCommon.WordBreaker.splitByWidth(label, properties, textWidthMeasurer, labelMaxWidth, maxNumLines, textTruncator).join(' ');
	                        properties.text = label;
	                        var rotateChars = textTruncator(properties, rotatedLength);
	                        // prefer word break (>=) as it takes up less plot area
	                        return visuals.TextUtil.removeEllipses(wordBreakChars).length >= visuals.TextUtil.removeEllipses(rotateChars).length;
	                    });
	                    // prefer word break (>=) as it takes up less plot area
	                    return moreWordBreakChars.length >= Math.floor(labels.length / 2);
	                }
	                LabelLayoutStrategy.willLabelsWordBreak = willLabelsWordBreak;
	                LabelLayoutStrategy.DefaultRotation = {
	                    sine: Math.sin(Math.PI * (35 / 180)),
	                    cosine: Math.cos(Math.PI * (35 / 180)),
	                    tangent: Math.tan(Math.PI * (35 / 180)),
	                    transform: 'rotate(-35)',
	                    dy: '-0.5em',
	                };
	                LabelLayoutStrategy.DefaultRotationWithScrollbar = {
	                    sine: Math.sin(Math.PI * (90 / 180)),
	                    cosine: Math.cos(Math.PI * (90 / 180)),
	                    tangent: Math.tan(Math.PI * (90 / 180)),
	                    transform: 'rotate(-90)',
	                    dy: '-0.8em',
	                };
	                function rotate(labelSelection, maxBottomMargin, textTruncator, textProperties, needRotate, needEllipsis, axisProperties, margin, scrollbarVisible) {
	                    var rotatedLength;
	                    var defaultRotation;
	                    if (scrollbarVisible)
	                        defaultRotation = LabelLayoutStrategy.DefaultRotationWithScrollbar;
	                    else
	                        defaultRotation = LabelLayoutStrategy.DefaultRotation;
	                    if (needRotate) {
	                        rotatedLength = maxBottomMargin / defaultRotation.sine;
	                    }
	                    labelSelection.each(function () {
	                        var axisLabel = d3.select(this);
	                        var labelText = axisLabel.text();
	                        textProperties.text = labelText;
	                        if (needRotate) {
	                            var textContentIndex = axisProperties.values.indexOf(this.textContent);
	                            var allowedLengthProjectedOnXAxis = 
	                            // Left margin is the width of Y axis.
	                            margin.left
	                                + axisProperties.outerPadding
	                                + axisProperties.categoryThickness * (textContentIndex + 0.5);
	                            // Subtracting the left padding space from the allowed length.
	                            if (!scrollbarVisible)
	                                allowedLengthProjectedOnXAxis -= LeftPadding;
	                            // Truncate if scrollbar is visible or rotatedLength exceeds allowedLength
	                            var allowedLength = allowedLengthProjectedOnXAxis / defaultRotation.cosine;
	                            if (scrollbarVisible || needEllipsis || (allowedLength < rotatedLength)) {
	                                labelText = textTruncator(textProperties, Math.min(allowedLength, rotatedLength));
	                                axisLabel.text(labelText);
	                            }
	                            axisLabel.style('text-anchor', 'end')
	                                .attr({
	                                'dx': '-0.5em',
	                                'dy': defaultRotation.dy,
	                                'transform': defaultRotation.transform
	                            });
	                        }
	                        else {
	                            var newLabelText = textTruncator(textProperties, axisProperties.xLabelMaxWidth);
	                            if (newLabelText !== labelText)
	                                axisLabel.text(newLabelText);
	                            axisLabel.style('text-anchor', 'middle')
	                                .attr({
	                                'dx': '0em',
	                                'dy': '1em',
	                                'transform': 'rotate(0)'
	                            });
	                        }
	                    });
	                }
	                LabelLayoutStrategy.rotate = rotate;
	                function wordBreak(text, axisProperties, maxHeight) {
	                    var allowedLength = axisProperties.xLabelMaxWidth;
	                    text.each(function () {
	                        var node = d3.select(this);
	                        // Reset style of text node
	                        node
	                            .style('text-anchor', 'middle')
	                            .attr({
	                            'dx': '0em',
	                            'dy': '1em',
	                            'transform': 'rotate(0)'
	                        });
	                        powerbi.TextMeasurementService.wordBreak(this, allowedLength, maxHeight);
	                    });
	                }
	                LabelLayoutStrategy.wordBreak = wordBreak;
	                function clip(text, availableWidth, svgEllipsis) {
	                    if (text.size() === 0)
	                        return;
	                    text.each(function () {
	                        var text = d3.select(this);
	                        svgEllipsis(text[0][0], availableWidth);
	                    });
	                }
	                LabelLayoutStrategy.clip = clip;
	            })(LabelLayoutStrategy = AxisHelper.LabelLayoutStrategy || (AxisHelper.LabelLayoutStrategy = {}));
	            function createOrdinalScale(pixelSpan, dataDomain, outerPaddingRatio) {
	                if (outerPaddingRatio === void 0) { outerPaddingRatio = 0; }
	                debug.assert(outerPaddingRatio >= 0 && outerPaddingRatio < 4, 'outerPaddingRatio should be a value between zero and four');
	                var scale = d3.scale.ordinal()
	                    .rangeBands([0, pixelSpan], visuals.CartesianChart.InnerPaddingRatio, outerPaddingRatio)
	                    .domain(dataDomain);
	                return scale;
	            }
	            AxisHelper.createOrdinalScale = createOrdinalScale;
	            function isLogScalePossible(domain, axisType) {
	                if (domain == null)
	                    return false;
	                if (isDateTime(axisType))
	                    return false;
	                return (domain[0] > 0 && domain[1] > 0) || (domain[0] < 0 && domain[1] < 0); //doman must exclude 0
	            }
	            AxisHelper.isLogScalePossible = isLogScalePossible;
	            //this function can return different scales e.g. log, linear
	            // NOTE: export only for testing, do not access directly
	            function createNumericalScale(axisScaleType, pixelSpan, dataDomain, dataType, outerPadding, niceCount, shouldClamp) {
	                if (outerPadding === void 0) { outerPadding = 0; }
	                if (axisScaleType === visuals.axisScale.log && isLogScalePossible(dataDomain, dataType)) {
	                    return createLogScale(pixelSpan, dataDomain, outerPadding, niceCount);
	                }
	                else {
	                    return createLinearScale(pixelSpan, dataDomain, outerPadding, niceCount, shouldClamp);
	                }
	            }
	            AxisHelper.createNumericalScale = createNumericalScale;
	            function createLogScale(pixelSpan, dataDomain, outerPadding, niceCount) {
	                if (outerPadding === void 0) { outerPadding = 0; }
	                debug.assert(isLogScalePossible(dataDomain), "dataDomain cannot include 0");
	                var scale = d3.scale.log()
	                    .range([outerPadding, pixelSpan - outerPadding])
	                    .domain([dataDomain[0], dataDomain[1]])
	                    .clamp(true);
	                if (niceCount) {
	                    scale.nice(niceCount);
	                }
	                return scale;
	            }
	            // NOTE: export only for testing, do not access directly
	            function createLinearScale(pixelSpan, dataDomain, outerPadding, niceCount, shouldClamp) {
	                if (outerPadding === void 0) { outerPadding = 0; }
	                var scale = d3.scale.linear()
	                    .range([outerPadding, pixelSpan - outerPadding])
	                    .domain([dataDomain[0], dataDomain[1]])
	                    .clamp(shouldClamp);
	                // .nice(undefined) still modifies the scale boundaries, and for datetime this messes things up.
	                // we use millisecond ticks since epoch for datetime, so we don't want any "nice" with numbers like 17398203392.
	                if (niceCount) {
	                    scale.nice(niceCount);
	                }
	                return scale;
	            }
	            AxisHelper.createLinearScale = createLinearScale;
	            function getRangeForColumn(sizeColumn) {
	                var result = {};
	                if (sizeColumn) {
	                    result.min = (sizeColumn.min == null
	                        ? sizeColumn.minLocal == null ? d3.min(sizeColumn.values) : sizeColumn.minLocal
	                        : sizeColumn.min);
	                    result.max = (sizeColumn.max == null
	                        ? sizeColumn.maxLocal == null ? d3.max(sizeColumn.values) : sizeColumn.maxLocal
	                        : sizeColumn.max);
	                }
	                return result;
	            }
	            AxisHelper.getRangeForColumn = getRangeForColumn;
	            /**
	             * Set customized domain, but don't change when nothing is set
	             */
	            function applyCustomizedDomain(customizedDomain, forcedDomain) {
	                var domain = [undefined, undefined];
	                if (forcedDomain && forcedDomain.length === 2) {
	                    domain = [forcedDomain[0], forcedDomain[1]];
	                }
	                if (customizedDomain && customizedDomain.length === 2) {
	                    if (customizedDomain[0] != null) {
	                        domain[0] = customizedDomain[0];
	                    }
	                    if (customizedDomain[1] != null) {
	                        domain[1] = customizedDomain[1];
	                    }
	                }
	                if (domain[0] == null && domain[1] == null) {
	                    return forcedDomain; //return untouched object
	                }
	                //do extra check to see if the user input was valid with the merged axis values.
	                if (domain[0] != null && domain[1] != null) {
	                    if (domain[0] > domain[1]) {
	                        return forcedDomain;
	                    }
	                }
	                return domain;
	            }
	            AxisHelper.applyCustomizedDomain = applyCustomizedDomain;
	            /**
	             * Combine the forced domain with the actual domain if one of the values was set.
	             * The forcedDomain is in 1st priority. Extends the domain if the any reference point requires it.
	             */
	            function combineDomain(forcedDomain, domain, ensureDomain) {
	                var combinedDomain = domain ? [domain[0], domain[1]] : [];
	                if (ensureDomain) {
	                    if (combinedDomain[0] == null || ensureDomain.min < combinedDomain[0])
	                        combinedDomain[0] = ensureDomain.min;
	                    if (combinedDomain[1] == null || ensureDomain.max > combinedDomain[1])
	                        combinedDomain[1] = ensureDomain.max;
	                }
	                var domainBeforeForced = [combinedDomain[0], combinedDomain[1]];
	                if (forcedDomain && forcedDomain.length === 2) {
	                    if (forcedDomain[0] != null) {
	                        combinedDomain[0] = forcedDomain[0];
	                    }
	                    if (forcedDomain[1] != null) {
	                        combinedDomain[1] = forcedDomain[1];
	                    }
	                    if (combinedDomain[0] > combinedDomain[1]) {
	                        combinedDomain = domainBeforeForced; //this is invalid, so take the original domain considering the values and the reference line
	                    }
	                }
	                return combinedDomain;
	            }
	            AxisHelper.combineDomain = combineDomain;
	            function createAxisLabel(properties, label, unitType, y2) {
	                if (y2 === void 0) { y2 = false; }
	                var propertyName = y2 ? 'secAxisStyle' : 'axisStyle';
	                if (!properties || !properties[propertyName]) {
	                    return label;
	                }
	                var modifiedLabel;
	                if (properties[propertyName] === visuals.axisStyle.showBoth) {
	                    modifiedLabel = label + ' (' + unitType + ')'; //todo: localize
	                }
	                else if (properties[propertyName] === visuals.axisStyle.showUnitOnly) {
	                    modifiedLabel = unitType;
	                }
	                else {
	                    modifiedLabel = label;
	                }
	                return modifiedLabel;
	            }
	            AxisHelper.createAxisLabel = createAxisLabel;
	            function scaleShouldClamp(combinedDomain, domain) {
	                if (!combinedDomain || !domain || combinedDomain.length < 2 || domain.length < 2)
	                    return false;
	                //when the start or end is different, clamp it
	                return combinedDomain[0] !== domain[0] || combinedDomain[1] !== domain[1];
	            }
	            AxisHelper.scaleShouldClamp = scaleShouldClamp;
	            function normalizeNonFiniteNumber(value) {
	                if (isNaN(value))
	                    return null;
	                else if (value === Number.POSITIVE_INFINITY)
	                    return Number.MAX_VALUE;
	                else if (value === Number.NEGATIVE_INFINITY)
	                    return -Number.MAX_VALUE;
	                return value;
	            }
	            AxisHelper.normalizeNonFiniteNumber = normalizeNonFiniteNumber;
	            /**
	             * Indicates whether the number is power of 10.
	             */
	            function powerOfTen(d) {
	                var value = Math.abs(d);
	                // formula log2(Y)/log2(10) = log10(Y)
	                // because double issues this won't return exact value
	                // we need to ceil it to nearest number.
	                var log10 = Math.log(value) / Math.LN10;
	                log10 = Math.ceil(log10 - 1e-12);
	                return value / Math.pow(10, log10) === 1;
	            }
	            AxisHelper.powerOfTen = powerOfTen;
	        })(AxisHelper = visuals.AxisHelper || (visuals.AxisHelper = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 193 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	*  Power BI Visualizations
	*
	*  Copyright (c) Microsoft Corporation
	*  All rights reserved.
	*  MIT License
	*
	*  Permission is hereby granted, free of charge, to any person obtaining a copy
	*  of this software and associated documentation files (the ""Software""), to deal
	*  in the Software without restriction, including without limitation the rights
	*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	*  copies of the Software, and to permit persons to whom the Software is
	*  furnished to do so, subject to the following conditions:
	*
	*  The above copyright notice and this permission notice shall be included in
	*  all copies or substantial portions of the Software.
	*
	*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	*  THE SOFTWARE.
	*/
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var ShapeFactory;
	        (function (ShapeFactory) {
	            var ShapeFactoryConsts;
	            (function (ShapeFactoryConsts) {
	                ShapeFactoryConsts.PaddingConstRatio = 0.01;
	                ShapeFactoryConsts.TrianglePaddingConstRatio = 0.15;
	                ShapeFactoryConsts.TriangleEndPaddingConstRatio = 0.85;
	                ShapeFactoryConsts.ShapeConstRatio = 1.0 - (ShapeFactoryConsts.PaddingConstRatio * 2);
	                ShapeFactoryConsts.SmallPaddingConstValue = 10;
	                ShapeFactoryConsts.OvalRadiusConst = 2;
	                ShapeFactoryConsts.OvalRadiusConstPadding = 0.2;
	                ShapeFactoryConsts.ArrowLeftHeadPoint = { x: 0.05, y: 0.42 };
	                ShapeFactoryConsts.ArrowMiddleHeadPoint = { x: 0.5, y: 0.016 };
	                ShapeFactoryConsts.ArrowRightHeadPoint = { x: 0.95, y: 0.42 };
	                ShapeFactoryConsts.ArrowRightMiddleHeadPoint = { x: 0.764, y: 0.42 };
	                ShapeFactoryConsts.ArrowBottomRightPoint = { x: 0.764, y: 0.993 };
	                ShapeFactoryConsts.ArrowBottomLeftPoint = { x: 0.246, y: 0.993 };
	                ShapeFactoryConsts.ArrowLeftMiddleHeadPoint = { x: 0.246, y: 0.42 };
	            })(ShapeFactoryConsts = ShapeFactory.ShapeFactoryConsts || (ShapeFactory.ShapeFactoryConsts = {}));
	            /** this function creates a rectangle svg   */
	            function createRectangle(data, viewportHeight, viewportWidth, selectedElement, degrees) {
	                var x = (viewportWidth * ShapeFactoryConsts.PaddingConstRatio) + (data.lineWeight / 2);
	                var y = (viewportHeight * ShapeFactoryConsts.PaddingConstRatio) + (data.lineWeight / 2);
	                var width = (viewportWidth * ShapeFactoryConsts.ShapeConstRatio) - (data.lineWeight);
	                var height = (viewportHeight * ShapeFactoryConsts.ShapeConstRatio) - (data.lineWeight);
	                var attrs = { x: x, y: y, width: width, height: height, rx: data.roundEdge, ry: data.roundEdge };
	                var scale = getScale(width, height, degrees);
	                createShape(data, viewportHeight, viewportWidth, selectedElement, degrees, scale, 'rect', attrs);
	            }
	            ShapeFactory.createRectangle = createRectangle;
	            /** this function creates a oval svg   */
	            function createOval(data, viewportHeight, viewportWidth, selectedElement, degrees) {
	                var widthForCircle = (viewportWidth / ShapeFactoryConsts.OvalRadiusConst).toString();
	                var heightForCircle = (viewportHeight / ShapeFactoryConsts.OvalRadiusConst).toString();
	                var radiusXForCircle = ((viewportWidth / (ShapeFactoryConsts.OvalRadiusConst + ShapeFactoryConsts.OvalRadiusConstPadding)) - data.lineWeight);
	                var radiusYForCircle = ((viewportHeight / (ShapeFactoryConsts.OvalRadiusConst + ShapeFactoryConsts.OvalRadiusConstPadding)) - data.lineWeight);
	                var attrs = { cx: widthForCircle, cy: heightForCircle, rx: radiusXForCircle, ry: radiusYForCircle };
	                var scale = getScale(viewportWidth, viewportHeight, degrees);
	                createShape(data, viewportHeight, viewportWidth, selectedElement, degrees, scale, 'ellipse', attrs);
	            }
	            ShapeFactory.createOval = createOval;
	            /** this function creates a line svg   */
	            function createLine(data, viewportHeight, viewportWidth, selectedElement, degrees) {
	                var x1, y1, x2, y2;
	                var width = (viewportWidth - ShapeFactoryConsts.SmallPaddingConstValue) - ShapeFactoryConsts.SmallPaddingConstValue;
	                var height = (viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue) - ShapeFactoryConsts.SmallPaddingConstValue;
	                var ratio;
	                if (degrees <= 45) {
	                    ratio = degrees / 90;
	                    x1 = viewportWidth / 2 + width * ratio;
	                    y1 = ShapeFactoryConsts.SmallPaddingConstValue;
	                    x2 = viewportWidth / 2 - width * ratio;
	                    y2 = (viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue);
	                }
	                else if (degrees <= 135) {
	                    ratio = (degrees - 45) / 90;
	                    x1 = (viewportWidth - ShapeFactoryConsts.SmallPaddingConstValue);
	                    y1 = ShapeFactoryConsts.SmallPaddingConstValue + height * ratio;
	                    x2 = ShapeFactoryConsts.SmallPaddingConstValue;
	                    y2 = (viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue) - height * ratio;
	                }
	                else if (degrees <= 225) {
	                    ratio = (degrees - 135) / 90;
	                    x1 = (viewportWidth - ShapeFactoryConsts.SmallPaddingConstValue) - width * ratio;
	                    y1 = (viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue);
	                    x2 = ShapeFactoryConsts.SmallPaddingConstValue + width * ratio;
	                    y2 = ShapeFactoryConsts.SmallPaddingConstValue;
	                }
	                else if (degrees <= 315) {
	                    ratio = (degrees - 225) / 90;
	                    x1 = ShapeFactoryConsts.SmallPaddingConstValue;
	                    y1 = (viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue) - height * ratio;
	                    x2 = (viewportWidth - ShapeFactoryConsts.SmallPaddingConstValue);
	                    y2 = ShapeFactoryConsts.SmallPaddingConstValue + height * ratio;
	                }
	                else if (degrees <= 360) {
	                    ratio = (degrees - 315) / 90;
	                    x1 = ShapeFactoryConsts.SmallPaddingConstValue + width * ratio;
	                    y1 = ShapeFactoryConsts.SmallPaddingConstValue;
	                    x2 = (viewportWidth - ShapeFactoryConsts.SmallPaddingConstValue) - width * ratio;
	                    y2 = (viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue);
	                }
	                // create the inner path with the wanted shape
	                selectedElement
	                    .append('svg')
	                    .attr({
	                    width: viewportWidth,
	                    height: viewportHeight
	                })
	                    .append('line')
	                    .attr({
	                    x1: x1,
	                    y1: y1,
	                    x2: x2,
	                    y2: y2,
	                })
	                    .style({
	                    'vector-effect': 'non-scaling-stroke',
	                    'stroke-width': data.lineWeight + 'px',
	                    'stroke-opacity': (100 - data.lineTransparency) / 100,
	                    'stroke': data.lineColor
	                });
	            }
	            ShapeFactory.createLine = createLine;
	            /** this function creates a arrow svg   */
	            function createUpArrow(data, viewportHeight, viewportWidth, selectedElement, degrees) {
	                var lineWeight = data.lineWeight;
	                var viewportHeightWeight = viewportHeight - lineWeight;
	                var viewportWidthWeight = viewportWidth - lineWeight;
	                var arrowPoints = [
	                    { 'x': (viewportWidthWeight * ShapeFactoryConsts.ArrowLeftHeadPoint.x).toString(), 'y': (viewportHeightWeight * ShapeFactoryConsts.ArrowLeftHeadPoint.y).toString() },
	                    { 'x': (viewportWidthWeight * ShapeFactoryConsts.ArrowMiddleHeadPoint.x).toString(), 'y': (viewportHeightWeight * ShapeFactoryConsts.ArrowMiddleHeadPoint.y).toString() },
	                    { 'x': (viewportWidthWeight * ShapeFactoryConsts.ArrowRightHeadPoint.x).toString(), 'y': (viewportHeightWeight * ShapeFactoryConsts.ArrowRightHeadPoint.y).toString() },
	                    { 'x': (viewportWidthWeight * ShapeFactoryConsts.ArrowRightMiddleHeadPoint.x).toString(), 'y': (viewportHeightWeight * ShapeFactoryConsts.ArrowRightMiddleHeadPoint.y).toString() },
	                    { 'x': (viewportWidthWeight * ShapeFactoryConsts.ArrowBottomRightPoint.x).toString(), 'y': (viewportHeightWeight * ShapeFactoryConsts.ArrowBottomRightPoint.y).toString() },
	                    { 'x': (viewportWidthWeight * ShapeFactoryConsts.ArrowBottomLeftPoint.x).toString(), 'y': (viewportHeightWeight * ShapeFactoryConsts.ArrowBottomLeftPoint.y).toString() },
	                    { 'x': (viewportWidthWeight * ShapeFactoryConsts.ArrowLeftMiddleHeadPoint.x).toString(), 'y': (viewportHeightWeight * ShapeFactoryConsts.ArrowLeftMiddleHeadPoint.y).toString() },
	                ];
	                // create the inner path with the wanted shape
	                createPathFromArray(data, arrowPoints, selectedElement, viewportHeight, viewportWidth, degrees);
	            }
	            ShapeFactory.createUpArrow = createUpArrow;
	            /** this function creates a triangle svg   */
	            function createTriangle(data, viewportHeight, viewportWidth, selectedElement, degrees) {
	                var lineWeight = data.lineWeight;
	                // remove the basic line weight
	                if (lineWeight > 3) {
	                    lineWeight -= 3;
	                }
	                var firstPointX = ((viewportWidth + lineWeight) * ShapeFactoryConsts.TrianglePaddingConstRatio);
	                var firstPointY = (viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue - lineWeight) < 0 ?
	                    (viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue) : (viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue - lineWeight);
	                var secondPointY = ((viewportHeight + lineWeight) * ShapeFactoryConsts.TrianglePaddingConstRatio);
	                var thirdPointX = ((viewportWidth - lineWeight) * ShapeFactoryConsts.TriangleEndPaddingConstRatio) < 0 ?
	                    (viewportWidth * ShapeFactoryConsts.TriangleEndPaddingConstRatio) : ((viewportWidth - lineWeight) * ShapeFactoryConsts.TriangleEndPaddingConstRatio);
	                var thirdPointY = (viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue - lineWeight) < 0 ?
	                    (viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue) : (viewportHeight - lineWeight - ShapeFactoryConsts.SmallPaddingConstValue);
	                var secondPointX = ((firstPointX + thirdPointX) / 2);
	                if (firstPointX < 10) {
	                    firstPointX = ShapeFactoryConsts.SmallPaddingConstValue;
	                }
	                if (secondPointY < 10) {
	                    secondPointY = ShapeFactoryConsts.SmallPaddingConstValue;
	                }
	                var trianglePoints = [
	                    { 'x': firstPointX, 'y': firstPointY },
	                    { 'x': secondPointX, 'y': secondPointY },
	                    { 'x': thirdPointX, 'y': thirdPointY },
	                ];
	                createPathFromArray(data, trianglePoints, selectedElement, viewportHeight, viewportWidth, degrees);
	            }
	            ShapeFactory.createTriangle = createTriangle;
	            /** this funcion adds a path to an svg element from an array of points (x,y) */
	            function createPathFromArray(data, points, selectedElement, viewportHeight, viewportWidth, degrees) {
	                var lineFunction = d3.svg.line()
	                    .x(function (d) { return d.x; })
	                    .y(function (d) { return d.y; })
	                    .interpolate('linear');
	                var attrs = { d: lineFunction(points) + ' Z' };
	                var scale = getScale(viewportWidth, viewportHeight, degrees);
	                createShape(data, viewportHeight, viewportWidth, selectedElement, degrees, scale, 'path', attrs);
	            }
	            function createShape(data, viewportHeight, viewportWidth, selectedElement, degrees, scale, shapeType, shapeAttrs) {
	                selectedElement
	                    .append('div')
	                    .style({
	                    'transform': 'rotate(' + degrees + 'deg) scale(' + scale + ')',
	                    'transform-origin': 'center',
	                    // for testing with phantomjs we need the webkit prefix
	                    '-webkit-transform': 'rotate(' + degrees + 'deg) scale(' + scale + ')',
	                    '-webkit-transform-origin': 'center',
	                    'width': viewportWidth + 'px',
	                    'height': viewportHeight + 'px'
	                })
	                    .append('svg')
	                    .attr({
	                    width: viewportWidth,
	                    height: viewportHeight
	                })
	                    .append(shapeType)
	                    .attr(shapeAttrs)
	                    .style({
	                    'vector-effect': 'non-scaling-stroke',
	                    'stroke-width': data.lineWeight + 'px',
	                    'stroke': data.lineColor,
	                    'stroke-opacity': (100 - data.lineTransparency) / 100,
	                    'fill': data.fillColor,
	                    'fill-opacity': data.showFill === true ? ((100 - data.shapeTransparency) / 100) : 0
	                });
	            }
	            // this function return the scale to add to the shape. 
	            // it calculate it by the ratio of the original shape's diagonal and the shape's diagonal after rotate (the maximum diagonal that still fit to the container).
	            // it calculate the shape's diagonal by the rotate angle.
	            function getScale(width, height, degrees) {
	                var originalWidth = width;
	                var originalHeight = height;
	                var offsetAngle = Math.atan2(height, width);
	                var originalFactor = Math.sqrt(Math.pow(height, 2) + Math.pow(width, 2));
	                var radians = (degrees / 180) * Math.PI;
	                if (width >= height) {
	                    if (degrees < 90) {
	                        radians += offsetAngle;
	                    }
	                    else if (degrees < 180) {
	                        radians -= offsetAngle;
	                    }
	                    else if (degrees < 270) {
	                        radians += offsetAngle;
	                    }
	                    else {
	                        radians -= offsetAngle;
	                    }
	                    return (originalHeight / Math.abs(Math.sin(radians))) / originalFactor;
	                }
	                else {
	                    if (degrees < 90) {
	                        radians -= offsetAngle;
	                    }
	                    else if (degrees < 180) {
	                        radians += offsetAngle;
	                    }
	                    else if (degrees < 270) {
	                        radians -= offsetAngle;
	                    }
	                    else {
	                        radians += offsetAngle;
	                    }
	                    return (originalWidth / Math.abs(Math.cos(radians))) / originalFactor;
	                }
	            }
	        })(ShapeFactory = visuals.ShapeFactory || (visuals.ShapeFactory = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 194 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var CartesianHelper;
	        (function (CartesianHelper) {
	            function getCategoryAxisProperties(dataViewMetadata, axisTitleOnByDefault) {
	                var toReturn = {};
	                if (!dataViewMetadata)
	                    return toReturn;
	                var objects = dataViewMetadata.objects;
	                if (objects) {
	                    var categoryAxisObject = objects['categoryAxis'];
	                    if (categoryAxisObject) {
	                        toReturn = {
	                            show: categoryAxisObject['show'],
	                            axisType: categoryAxisObject['axisType'],
	                            axisScale: categoryAxisObject['axisScale'],
	                            start: categoryAxisObject['start'],
	                            end: categoryAxisObject['end'],
	                            showAxisTitle: categoryAxisObject['showAxisTitle'] == null ? axisTitleOnByDefault : categoryAxisObject['showAxisTitle'],
	                            axisStyle: categoryAxisObject['axisStyle'],
	                            labelColor: categoryAxisObject['labelColor'],
	                            labelDisplayUnits: categoryAxisObject['labelDisplayUnits'],
	                            labelPrecision: categoryAxisObject['labelPrecision'],
	                            duration: categoryAxisObject['duration'],
	                        };
	                    }
	                }
	                return toReturn;
	            }
	            CartesianHelper.getCategoryAxisProperties = getCategoryAxisProperties;
	            function getValueAxisProperties(dataViewMetadata, axisTitleOnByDefault) {
	                var toReturn = {};
	                if (!dataViewMetadata)
	                    return toReturn;
	                var objects = dataViewMetadata.objects;
	                if (objects) {
	                    var valueAxisObject = objects['valueAxis'];
	                    if (valueAxisObject) {
	                        toReturn = {
	                            show: valueAxisObject['show'],
	                            position: valueAxisObject['position'],
	                            axisScale: valueAxisObject['axisScale'],
	                            start: valueAxisObject['start'],
	                            end: valueAxisObject['end'],
	                            showAxisTitle: valueAxisObject['showAxisTitle'] == null ? axisTitleOnByDefault : valueAxisObject['showAxisTitle'],
	                            axisStyle: valueAxisObject['axisStyle'],
	                            labelColor: valueAxisObject['labelColor'],
	                            labelDisplayUnits: valueAxisObject['labelDisplayUnits'],
	                            labelPrecision: valueAxisObject['labelPrecision'],
	                            secShow: valueAxisObject['secShow'],
	                            secPosition: valueAxisObject['secPosition'],
	                            secAxisScale: valueAxisObject['secAxisScale'],
	                            secStart: valueAxisObject['secStart'],
	                            secEnd: valueAxisObject['secEnd'],
	                            secShowAxisTitle: valueAxisObject['secShowAxisTitle'],
	                            secAxisStyle: valueAxisObject['secAxisStyle'],
	                            secLabelColor: valueAxisObject['secLabelColor'],
	                            secLabelDisplayUnits: valueAxisObject['secLabelDisplayUnits'],
	                            secLabelPrecision: valueAxisObject['secLabelPrecision'],
	                        };
	                    }
	                }
	                return toReturn;
	            }
	            CartesianHelper.getValueAxisProperties = getValueAxisProperties;
	            function isScalar(isScalar, xAxisCardProperties) {
	                if (isScalar) {
	                    //now check what the user wants
	                    isScalar = xAxisCardProperties && xAxisCardProperties['axisType'] ? xAxisCardProperties['axisType'] === visuals.axisType.scalar : true;
	                }
	                return isScalar;
	            }
	            CartesianHelper.isScalar = isScalar;
	            function getPrecision(precision) {
	                if (precision != null) {
	                    if (precision < 0) {
	                        return 0;
	                    }
	                    return precision;
	                }
	                return null;
	            }
	            CartesianHelper.getPrecision = getPrecision;
	            function lookupXValue(data, index, type, isScalar) {
	                debug.assertValue(data, 'data');
	                debug.assertValue(type, 'type');
	                var isDateTime = visuals.AxisHelper.isDateTime(type);
	                if (isScalar) {
	                    if (isDateTime)
	                        return new Date(index);
	                    // index is the numeric value
	                    return index;
	                }
	                if (type.text) {
	                    debug.assert(index < data.categories.length, 'category index out of range');
	                    return data.categories[index];
	                }
	                if (data && data.series && data.series.length > 0) {
	                    var firstSeries = data.series[0];
	                    if (firstSeries) {
	                        var seriesValues = firstSeries.data;
	                        if (seriesValues) {
	                            if (data.hasHighlights)
	                                index = index * 2;
	                            var dataAtIndex = seriesValues[index];
	                            if (dataAtIndex) {
	                                if (isDateTime && dataAtIndex.categoryValue != null)
	                                    return new Date(dataAtIndex.categoryValue);
	                                return dataAtIndex.categoryValue;
	                            }
	                        }
	                    }
	                }
	                return index;
	            }
	            CartesianHelper.lookupXValue = lookupXValue;
	            function findMaxCategoryIndex(series) {
	                if (_.isEmpty(series)) {
	                    return 0;
	                }
	                var maxCategoryIndex = 0;
	                for (var _i = 0, series_1 = series; _i < series_1.length; _i++) {
	                    var singleSeries = series_1[_i];
	                    if (!_.isEmpty(singleSeries.data)) {
	                        var lastIndex = singleSeries.data[singleSeries.data.length - 1].categoryIndex;
	                        maxCategoryIndex = Math.max(lastIndex, maxCategoryIndex);
	                    }
	                }
	                return maxCategoryIndex;
	            }
	            CartesianHelper.findMaxCategoryIndex = findMaxCategoryIndex;
	        })(CartesianHelper = visuals.CartesianHelper || (visuals.CartesianHelper = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 195 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var SQExprShortSerializer = powerbi.data.SQExprShortSerializer;
	        var ColorHelper = (function () {
	            function ColorHelper(colors, fillProp, defaultDataPointColor) {
	                this.colors = colors;
	                this.fillProp = fillProp;
	                this.defaultDataPointColor = defaultDataPointColor;
	                this.defaultColorScale = colors.getNewColorScale();
	            }
	            /**
	             * Gets the color for the given series value.
	             * If no explicit color or default color has been set then the color is
	             * allocated from the color scale for this series.
	             */
	            ColorHelper.prototype.getColorForSeriesValue = function (objects, fieldIds, value) {
	                return (this.fillProp && powerbi.DataViewObjects.getFillColor(objects, this.fillProp))
	                    || this.defaultDataPointColor
	                    || this.getColorScaleForSeries(fieldIds).getColor(value).value;
	            };
	            /**
	             * Gets the color scale for the given series.
	             */
	            ColorHelper.prototype.getColorScaleForSeries = function (fieldIds) {
	                return this.colors.getColorScaleByKey(SQExprShortSerializer.serializeArray(fieldIds || []));
	            };
	            /**
	             * Gets the color for the given measure.
	             */
	            ColorHelper.prototype.getColorForMeasure = function (objects, measureKey) {
	                // Note, this allocates the color from the scale regardless of if we use it or not which helps keep colors stable.
	                var scaleColor = this.defaultColorScale.getColor(measureKey).value;
	                return (this.fillProp && powerbi.DataViewObjects.getFillColor(objects, this.fillProp))
	                    || this.defaultDataPointColor
	                    || scaleColor;
	            };
	            ColorHelper.normalizeSelector = function (selector, isSingleSeries) {
	                debug.assertAnyValue(selector, 'selector');
	                // For dynamic series charts, colors are set per category.  So, exclude any measure (metadata repetition) from the selector.
	                if (selector && (isSingleSeries || selector.data))
	                    return { data: selector.data };
	                return selector;
	            };
	            return ColorHelper;
	        }());
	        visuals.ColorHelper = ColorHelper;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 196 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var rectName = 'rect';
	        var ColumnUtil;
	        (function (ColumnUtil) {
	            ColumnUtil.DimmedOpacity = 0.4;
	            ColumnUtil.DefaultOpacity = 1.0;
	            function applyUserMinMax(isScalar, dataView, xAxisCardProperties) {
	                if (isScalar) {
	                    var min = xAxisCardProperties['start'];
	                    var max = xAxisCardProperties['end'];
	                    return ColumnUtil.transformDomain(dataView, min, max);
	                }
	                return dataView;
	            }
	            ColumnUtil.applyUserMinMax = applyUserMinMax;
	            function transformDomain(dataView, min, max) {
	                if (!dataView.categories || !dataView.values || dataView.categories.length === 0 || dataView.values.length === 0)
	                    return dataView; // no need to do something when there are no categories
	                if (typeof min !== "number" && typeof max !== "number")
	                    return dataView; //user did not set min max, nothing to do here
	                var category = dataView.categories[0]; //at the moment we only support one category
	                var categoryType = category ? category.source.type : null;
	                // Min/Max comparison won't work if category source is Ordinal
	                if (visuals.AxisHelper.isOrdinal(categoryType))
	                    return;
	                var categoryValues = category.values;
	                var categoryObjects = category.objects;
	                if (!categoryValues || !categoryObjects)
	                    return dataView;
	                var newcategoryValues = [];
	                var newValues = [];
	                var newObjects = [];
	                //get new min max
	                if (typeof min !== "number") {
	                    min = categoryValues[0];
	                }
	                if (typeof max !== "number") {
	                    max = categoryValues[categoryValues.length - 1];
	                }
	                //don't allow this
	                if (min > max)
	                    return dataView;
	                //build measure array
	                for (var j = 0, len = dataView.values.length; j < len; j++) {
	                    newValues.push([]);
	                }
	                for (var t = 0, len = categoryValues.length; t < len; t++) {
	                    if (categoryValues[t] >= min && categoryValues[t] <= max) {
	                        newcategoryValues.push(categoryValues[t]);
	                        if (categoryObjects) {
	                            newObjects.push(categoryObjects[t]);
	                        }
	                        //on each measure set the new range
	                        if (dataView.values) {
	                            for (var k = 0; k < dataView.values.length; k++) {
	                                newValues[k].push(dataView.values[k].values[t]);
	                            }
	                        }
	                    }
	                }
	                //don't write directly to dataview
	                var resultDataView = powerbi.Prototype.inherit(dataView);
	                var resultDataViewValues = resultDataView.values = powerbi.Prototype.inherit(resultDataView.values);
	                var resultDataViewCategories = resultDataView.categories = powerbi.Prototype.inherit(dataView.categories);
	                var resultDataViewCategories0 = resultDataView.categories[0] = powerbi.Prototype.inherit(resultDataViewCategories[0]);
	                resultDataViewCategories0.values = newcategoryValues;
	                //only if we had objects, then you set the new objects
	                if (resultDataViewCategories0.objects) {
	                    resultDataViewCategories0.objects = newObjects;
	                }
	                //update measure array
	                for (var t = 0, len = dataView.values.length; t < len; t++) {
	                    var measureArray = resultDataViewValues[t] = powerbi.Prototype.inherit(resultDataViewValues[t]);
	                    measureArray.values = newValues[t];
	                }
	                return resultDataView;
	            }
	            ColumnUtil.transformDomain = transformDomain;
	            function getCategoryAxis(data, size, layout, isVertical, forcedXMin, forcedXMax, axisScaleType, axisDisplayUnits, axisPrecision, ensureXDomain) {
	                var categoryThickness = layout.categoryThickness;
	                var isScalar = layout.isScalar;
	                var outerPaddingRatio = layout.outerPaddingRatio;
	                var domain = visuals.AxisHelper.createDomain(data.series, data.categoryMetadata ? data.categoryMetadata.type : powerbi.ValueType.fromDescriptor({ text: true }), isScalar, [forcedXMin, forcedXMax], ensureXDomain);
	                var axisProperties = visuals.AxisHelper.createAxis({
	                    pixelSpan: size,
	                    dataDomain: domain,
	                    metaDataColumn: data.categoryMetadata,
	                    formatString: visuals.valueFormatter.getFormatString(data.categoryMetadata, visuals.columnChartProps.general.formatString),
	                    outerPadding: categoryThickness * outerPaddingRatio,
	                    isCategoryAxis: true,
	                    isScalar: isScalar,
	                    isVertical: isVertical,
	                    categoryThickness: categoryThickness,
	                    useTickIntervalForDisplayUnits: true,
	                    getValueFn: function (index, type) { return visuals.CartesianHelper.lookupXValue(data, index, type, isScalar); },
	                    scaleType: axisScaleType,
	                    axisDisplayUnits: axisDisplayUnits,
	                    axisPrecision: axisPrecision
	                });
	                // intentionally updating the input layout by ref
	                layout.categoryThickness = axisProperties.categoryThickness;
	                return axisProperties;
	            }
	            ColumnUtil.getCategoryAxis = getCategoryAxis;
	            function applyInteractivity(columns, onDragStart) {
	                debug.assertValue(columns, 'columns');
	                if (onDragStart) {
	                    columns
	                        .attr('draggable', 'true')
	                        .on('dragstart', onDragStart);
	                }
	            }
	            ColumnUtil.applyInteractivity = applyInteractivity;
	            function getFillOpacity(selected, highlight, hasSelection, hasPartialHighlights) {
	                if ((hasPartialHighlights && !highlight) || (hasSelection && !selected))
	                    return ColumnUtil.DimmedOpacity;
	                return ColumnUtil.DefaultOpacity;
	            }
	            ColumnUtil.getFillOpacity = getFillOpacity;
	            function getClosestColumnIndex(coordinate, columnsCenters) {
	                var currentIndex = 0;
	                var distance = Number.MAX_VALUE;
	                for (var i = 0, ilen = columnsCenters.length; i < ilen; i++) {
	                    var currentDistance = Math.abs(coordinate - columnsCenters[i]);
	                    if (currentDistance < distance) {
	                        distance = currentDistance;
	                        currentIndex = i;
	                    }
	                }
	                return currentIndex;
	            }
	            ColumnUtil.getClosestColumnIndex = getClosestColumnIndex;
	            function setChosenColumnOpacity(mainGraphicsContext, columnGroupSelector, selectedColumnIndex, lastColumnIndex) {
	                var series = mainGraphicsContext.selectAll(visuals.ColumnChart.SeriesClasses.selector);
	                var lastColumnUndefined = typeof lastColumnIndex === 'undefined';
	                // find all columns that do not belong to the selected column and set a dimmed opacity with a smooth animation to those columns
	                series.selectAll(rectName + columnGroupSelector).filter(function (d) {
	                    return (d.categoryIndex !== selectedColumnIndex) && (lastColumnUndefined || d.categoryIndex === lastColumnIndex);
	                }).transition().style('fill-opacity', ColumnUtil.DimmedOpacity);
	                // set the default opacity for the selected column
	                series.selectAll(rectName + columnGroupSelector).filter(function (d) {
	                    return d.categoryIndex === selectedColumnIndex;
	                }).style('fill-opacity', ColumnUtil.DefaultOpacity);
	            }
	            ColumnUtil.setChosenColumnOpacity = setChosenColumnOpacity;
	            function drawSeries(data, graphicsContext, axisOptions) {
	                var colGroupSelection = graphicsContext.selectAll(visuals.ColumnChart.SeriesClasses.selector);
	                var series = colGroupSelection.data(data.series, function (d) { return d.key; });
	                series
	                    .enter()
	                    .append('g')
	                    .classed(visuals.ColumnChart.SeriesClasses.class, true);
	                series
	                    .style({
	                    fill: function (d) { return d.color; },
	                });
	                series
	                    .exit()
	                    .remove();
	                return series;
	            }
	            ColumnUtil.drawSeries = drawSeries;
	            function drawDefaultShapes(data, series, layout, itemCS, filterZeros, hasSelection) {
	                // We filter out invisible (0, null, etc.) values from the dataset
	                // based on whether animations are enabled or not, Dashboard and
	                // Exploration mode, respectively.
	                var dataSelector;
	                if (filterZeros) {
	                    dataSelector = function (d) {
	                        var filteredData = _.filter(d.data, function (datapoint) { return !!datapoint.value; });
	                        return filteredData;
	                    };
	                }
	                else {
	                    dataSelector = function (d) { return d.data; };
	                }
	                var shapeSelection = series.selectAll(itemCS.selector);
	                var shapes = shapeSelection.data(dataSelector, function (d) { return d.key; });
	                shapes.enter()
	                    .append(rectName)
	                    .attr("class", function (d) { return itemCS.class.concat(d.highlight ? " highlight" : ""); });
	                shapes
	                    .style("fill-opacity", function (d) { return ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, data.hasHighlights); })
	                    .style("fill", function (d) { return d.color !== data.series[d.seriesIndex].color ? d.color : null; }) // PERF: Only set the fill color if it is different than series.
	                    .attr(layout.shapeLayout);
	                shapes
	                    .exit()
	                    .remove();
	                return shapes;
	            }
	            ColumnUtil.drawDefaultShapes = drawDefaultShapes;
	            function drawDefaultLabels(series, context, layout, viewPort, isAnimator, animationDuration) {
	                if (isAnimator === void 0) { isAnimator = false; }
	                if (series) {
	                    var seriesData = series.data();
	                    var dataPoints = [];
	                    for (var i = 0, len = seriesData.length; i < len; i++) {
	                        Array.prototype.push.apply(dataPoints, seriesData[i].data);
	                    }
	                    return visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPoints, context, layout, viewPort, isAnimator, animationDuration);
	                }
	                else {
	                    visuals.dataLabelUtils.cleanDataLabels(context);
	                }
	            }
	            ColumnUtil.drawDefaultLabels = drawDefaultLabels;
	            function normalizeInfinityInScale(scale) {
	                // When large values (eg Number.MAX_VALUE) are involved, a call to scale.nice occasionally
	                // results in infinite values being included in the domain. To correct for that, we need to
	                // re-normalize the domain now to not include infinities.
	                var scaledDomain = scale.domain();
	                for (var i = 0, len = scaledDomain.length; i < len; ++i) {
	                    if (scaledDomain[i] === Number.POSITIVE_INFINITY)
	                        scaledDomain[i] = Number.MAX_VALUE;
	                    else if (scaledDomain[i] === Number.NEGATIVE_INFINITY)
	                        scaledDomain[i] = -Number.MAX_VALUE;
	                }
	                scale.domain(scaledDomain);
	            }
	            ColumnUtil.normalizeInfinityInScale = normalizeInfinityInScale;
	            function calculatePosition(d, axisOptions) {
	                var xScale = axisOptions.xScale;
	                var yScale = axisOptions.yScale;
	                var scaledY0 = yScale(0);
	                var scaledX0 = xScale(0);
	                switch (d.chartType) {
	                    case visuals.ColumnChartType.stackedBar:
	                    case visuals.ColumnChartType.hundredPercentStackedBar:
	                        return scaledX0 + Math.abs(visuals.AxisHelper.diffScaled(xScale, 0, d.valueAbsolute)) +
	                            visuals.AxisHelper.diffScaled(xScale, d.position - d.valueAbsolute, 0) + visuals.dataLabelUtils.defaultColumnLabelMargin;
	                    case visuals.ColumnChartType.clusteredBar:
	                        return scaledX0 + visuals.AxisHelper.diffScaled(xScale, Math.max(0, d.value), 0) + visuals.dataLabelUtils.defaultColumnLabelMargin;
	                    case visuals.ColumnChartType.stackedColumn:
	                    case visuals.ColumnChartType.hundredPercentStackedColumn:
	                        return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0) - visuals.dataLabelUtils.defaultColumnLabelMargin;
	                    case visuals.ColumnChartType.clusteredColumn:
	                        return scaledY0 + visuals.AxisHelper.diffScaled(yScale, Math.max(0, d.value), 0) - visuals.dataLabelUtils.defaultColumnLabelMargin;
	                }
	            }
	            ColumnUtil.calculatePosition = calculatePosition;
	        })(ColumnUtil = visuals.ColumnUtil || (visuals.ColumnUtil = {}));
	        var ClusteredUtil;
	        (function (ClusteredUtil) {
	            function clearColumns(mainGraphicsContext, itemCS) {
	                debug.assertValue(mainGraphicsContext, 'mainGraphicsContext');
	                debug.assertValue(itemCS, 'itemCS');
	                var cols = mainGraphicsContext.selectAll(itemCS.selector)
	                    .data([]);
	                cols.exit().remove();
	            }
	            ClusteredUtil.clearColumns = clearColumns;
	        })(ClusteredUtil = visuals.ClusteredUtil || (visuals.ClusteredUtil = {}));
	        var StackedUtil;
	        (function (StackedUtil) {
	            var PctRoundingError = 0.0001;
	            function getSize(scale, size, zeroVal) {
	                if (zeroVal === void 0) { zeroVal = 0; }
	                return visuals.AxisHelper.diffScaled(scale, zeroVal, size);
	            }
	            StackedUtil.getSize = getSize;
	            function calcValueDomain(data, is100pct) {
	                var defaultNumberRange = {
	                    min: 0,
	                    max: 10
	                };
	                if (data.length === 0)
	                    return defaultNumberRange;
	                // Can't use AxisHelper because Stacked layout has a slightly different calc, (position - valueAbs)
	                var min = d3.min(data, function (d) { return d3.min(d.data, function (e) { return e.position - e.valueAbsolute; }); });
	                var max = d3.max(data, function (d) { return d3.max(d.data, function (e) { return e.position; }); });
	                if (is100pct) {
	                    min = powerbi.Double.roundToPrecision(min, PctRoundingError);
	                    max = powerbi.Double.roundToPrecision(max, PctRoundingError);
	                }
	                return {
	                    min: min,
	                    max: max,
	                };
	            }
	            StackedUtil.calcValueDomain = calcValueDomain;
	            function getStackedMultiplier(dataView, rowIdx, seriesCount, categoryCount, converterStrategy) {
	                debug.assertValue(dataView, 'dataView');
	                debug.assertValue(rowIdx, 'rowIdx');
	                var pos = 0, neg = 0;
	                for (var i = 0; i < seriesCount; i++) {
	                    var value = converterStrategy.getValueBySeriesAndCategory(i, rowIdx);
	                    value = visuals.AxisHelper.normalizeNonFiniteNumber(value);
	                    if (value > 0)
	                        pos += value;
	                    else if (value < 0)
	                        neg -= value;
	                }
	                var absTotal = pos + neg;
	                return {
	                    pos: pos ? (pos / absTotal) / pos : 1,
	                    neg: neg ? (neg / absTotal) / neg : 1,
	                };
	            }
	            StackedUtil.getStackedMultiplier = getStackedMultiplier;
	            function clearColumns(mainGraphicsContext, itemCS) {
	                debug.assertValue(mainGraphicsContext, 'mainGraphicsContext');
	                debug.assertValue(itemCS, 'itemCS');
	                var bars = mainGraphicsContext.selectAll(itemCS.selector)
	                    .data([]);
	                bars.exit().remove();
	            }
	            StackedUtil.clearColumns = clearColumns;
	        })(StackedUtil = visuals.StackedUtil || (visuals.StackedUtil = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 197 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var DataRoleHelper = powerbi.data.DataRoleHelper;
	        var converterHelper;
	        (function (converterHelper) {
	            function categoryIsAlsoSeriesRole(dataView, seriesRoleName, categoryRoleName) {
	                if (dataView.categories && dataView.categories.length > 0) {
	                    // Need to pivot data if our category soure is a series role
	                    var category = dataView.categories[0];
	                    return category.source &&
	                        DataRoleHelper.hasRole(category.source, seriesRoleName) &&
	                        DataRoleHelper.hasRole(category.source, categoryRoleName);
	                }
	                return false;
	            }
	            converterHelper.categoryIsAlsoSeriesRole = categoryIsAlsoSeriesRole;
	            function getPivotedCategories(dataView, formatStringProp) {
	                if (dataView.categories && dataView.categories.length > 0) {
	                    var category = dataView.categories[0];
	                    var categoryValues = category.values;
	                    return category.values.length > 0
	                        ? {
	                            categories: categoryValues,
	                            categoryFormatter: visuals.valueFormatter.create({
	                                format: visuals.valueFormatter.getFormatString(category.source, formatStringProp),
	                                value: categoryValues[0],
	                                value2: categoryValues[categoryValues.length - 1],
	                                // Do not use display units such as K/M/bn etc. on the x-axis.
	                                // PowerView does not use units either as large ranges will make the x-axis indecipherable.
	                                displayUnitSystemType: powerbi.DisplayUnitSystemType.Verbose,
	                            }),
	                            categoryIdentities: category.identity,
	                            categoryObjects: category.objects,
	                        }
	                        : {
	                            categories: [],
	                            categoryFormatter: { format: visuals.valueFormatter.format },
	                        };
	                }
	                // For cases where the category source is just a series role, we are pivoting the data on the role which means we
	                // will have no categories.
	                return defaultCategories();
	            }
	            converterHelper.getPivotedCategories = getPivotedCategories;
	            function getSeriesName(source) {
	                debug.assertValue(source, 'source');
	                return (source.groupName !== undefined)
	                    ? source.groupName
	                    : source.queryName;
	            }
	            converterHelper.getSeriesName = getSeriesName;
	            function getFormattedLegendLabel(source, values, formatStringProp) {
	                debug.assertValue(source, 'source');
	                debug.assertValue(values, 'values');
	                var sourceForFormat = source;
	                var nameForFormat = source.displayName;
	                if (source.groupName !== undefined) {
	                    sourceForFormat = values.source;
	                    nameForFormat = source.groupName;
	                }
	                return visuals.valueFormatter.format(nameForFormat, visuals.valueFormatter.getFormatString(sourceForFormat, formatStringProp));
	            }
	            converterHelper.getFormattedLegendLabel = getFormattedLegendLabel;
	            function defaultCategories() {
	                return {
	                    categories: [null],
	                    categoryFormatter: { format: visuals.valueFormatter.format },
	                };
	            }
	            function createAxesLabels(categoryAxisProperties, valueAxisProperties, category, values) {
	                var xAxisLabel = null;
	                var yAxisLabel = null;
	                if (categoryAxisProperties) {
	                    // Take the value only if it's there
	                    if (category && category.displayName) {
	                        xAxisLabel = category.displayName;
	                    }
	                }
	                if (valueAxisProperties) {
	                    var valuesNames = [];
	                    if (values) {
	                        // Take the name from the values, and make it unique because there are sometimes duplications
	                        valuesNames = values.map(function (v) { return v ? v.displayName : ''; }).filter(function (value, index, self) { return value !== '' && self.indexOf(value) === index; });
	                        yAxisLabel = visuals.valueFormatter.formatListAnd(valuesNames);
	                    }
	                }
	                return { xAxisLabel: xAxisLabel, yAxisLabel: yAxisLabel };
	            }
	            converterHelper.createAxesLabels = createAxesLabels;
	            function isImageUrlColumn(column) {
	                var misc = getMiscellaneousTypeDescriptor(column);
	                return misc != null && misc.imageUrl === true;
	            }
	            converterHelper.isImageUrlColumn = isImageUrlColumn;
	            function isWebUrlColumn(column) {
	                var misc = getMiscellaneousTypeDescriptor(column);
	                return misc != null && misc.webUrl === true;
	            }
	            converterHelper.isWebUrlColumn = isWebUrlColumn;
	            function getMiscellaneousTypeDescriptor(column) {
	                return column
	                    && column.type
	                    && column.type.misc;
	            }
	            function hasImageUrlColumn(dataView) {
	                if (!dataView || !dataView.metadata || _.isEmpty(dataView.metadata.columns))
	                    return false;
	                return _.any(dataView.metadata.columns, function (column) { return isImageUrlColumn(column) === true; });
	            }
	            converterHelper.hasImageUrlColumn = hasImageUrlColumn;
	            function formatFromMetadataColumn(value, column, formatStringProp) {
	                debug.assertValue(column, 'column should exist');
	                var formatString = visuals.valueFormatter.getFormatString(column, formatStringProp, true);
	                if (!formatString && column) {
	                    formatString = column.format;
	                }
	                return visuals.valueFormatter.format(value, formatString);
	            }
	            converterHelper.formatFromMetadataColumn = formatFromMetadataColumn;
	        })(converterHelper = visuals.converterHelper || (visuals.converterHelper = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 198 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
	        var PixelConverter = jsCommon.PixelConverter;
	        var LabelStyle = visuals.labelStyle;
	        var dataLabelUtils;
	        (function (dataLabelUtils) {
	            dataLabelUtils.minLabelFontSize = 8;
	            dataLabelUtils.labelMargin = 8;
	            dataLabelUtils.maxLabelWidth = 50;
	            dataLabelUtils.defaultColumnLabelMargin = 5;
	            dataLabelUtils.defaultColumnHalfLabelHeight = 4;
	            dataLabelUtils.defaultLabelDensity = "50";
	            dataLabelUtils.DefaultDy = '-0.15em';
	            dataLabelUtils.DefaultFontSizeInPt = 9;
	            dataLabelUtils.StandardFontFamily = visuals.Font.Family.regular.css;
	            dataLabelUtils.LabelTextProperties = {
	                fontFamily: visuals.Font.Family.regularSecondary.css,
	                fontSize: PixelConverter.fromPoint(dataLabelUtils.DefaultFontSizeInPt),
	                fontWeight: 'normal',
	            };
	            dataLabelUtils.defaultLabelColor = "#777777";
	            dataLabelUtils.defaultInsideLabelColor = "#ffffff";
	            dataLabelUtils.hundredPercentFormat = "0.00 %;-0.00 %;0.00 %";
	            dataLabelUtils.defaultLabelPrecision = undefined;
	            var defaultCountLabelPrecision = 0;
	            var labelGraphicsContextClass = createClassAndSelector('labels');
	            var linesGraphicsContextClass = createClassAndSelector('lines');
	            var labelsClass = createClassAndSelector('data-labels');
	            var lineClass = createClassAndSelector('line-label');
	            function updateLabelSettingsFromLabelsObject(labelsObj, labelSettings) {
	                if (labelsObj) {
	                    if (labelsObj.show !== undefined)
	                        labelSettings.show = labelsObj.show;
	                    if (labelsObj.showSeries !== undefined)
	                        labelSettings.show = labelsObj.showSeries;
	                    if (labelsObj.color !== undefined)
	                        labelSettings.labelColor = labelsObj.color.solid.color;
	                    if (labelsObj.labelDisplayUnits !== undefined)
	                        labelSettings.displayUnits = labelsObj.labelDisplayUnits;
	                    if (labelsObj.labelPrecision !== undefined)
	                        labelSettings.precision = (labelsObj.labelPrecision >= 0) ? labelsObj.labelPrecision : dataLabelUtils.defaultLabelPrecision;
	                    if (labelsObj.fontSize !== undefined)
	                        labelSettings.fontSize = labelsObj.fontSize;
	                    if (labelsObj.showAll !== undefined)
	                        labelSettings.showLabelPerSeries = labelsObj.showAll;
	                    if (labelsObj.labelStyle !== undefined)
	                        labelSettings.labelStyle = labelsObj.labelStyle;
	                    if (labelsObj.labelPosition) {
	                        labelSettings.position = labelsObj.labelPosition;
	                    }
	                }
	            }
	            dataLabelUtils.updateLabelSettingsFromLabelsObject = updateLabelSettingsFromLabelsObject;
	            function updateLineChartLabelSettingsFromLabelsObject(labelsObj, labelSettings) {
	                updateLabelSettingsFromLabelsObject(labelsObj, labelSettings);
	                if (labelsObj && labelsObj.labelDensity !== undefined)
	                    labelSettings.labelDensity = labelsObj.labelDensity;
	            }
	            dataLabelUtils.updateLineChartLabelSettingsFromLabelsObject = updateLineChartLabelSettingsFromLabelsObject;
	            function getDefaultLabelSettings(show, labelColor, fontSize) {
	                if (show === void 0) { show = false; }
	                return {
	                    show: show,
	                    position: 0 /* Above */,
	                    displayUnits: 0,
	                    precision: dataLabelUtils.defaultLabelPrecision,
	                    labelColor: labelColor || dataLabelUtils.defaultLabelColor,
	                    fontSize: fontSize || dataLabelUtils.DefaultFontSizeInPt,
	                };
	            }
	            dataLabelUtils.getDefaultLabelSettings = getDefaultLabelSettings;
	            function getDefaultCardLabelSettings(labelColor, categoryLabelColor, fontSize) {
	                var labelSettings = getDefaultLabelSettings(true, labelColor, fontSize);
	                labelSettings.showCategory = true;
	                labelSettings.categoryLabelColor = categoryLabelColor;
	                return labelSettings;
	            }
	            dataLabelUtils.getDefaultCardLabelSettings = getDefaultCardLabelSettings;
	            function getDefaultTreemapLabelSettings() {
	                return {
	                    show: false,
	                    displayUnits: 0,
	                    precision: dataLabelUtils.defaultLabelPrecision,
	                    labelColor: dataLabelUtils.defaultInsideLabelColor,
	                    showCategory: true,
	                };
	            }
	            dataLabelUtils.getDefaultTreemapLabelSettings = getDefaultTreemapLabelSettings;
	            function getDefaultSunburstLabelSettings() {
	                return {
	                    show: false,
	                    labelColor: dataLabelUtils.defaultInsideLabelColor,
	                    fontSize: dataLabelUtils.DefaultFontSizeInPt,
	                    displayUnits: 0,
	                    precision: dataLabelUtils.defaultLabelPrecision,
	                    showCategory: true,
	                };
	            }
	            dataLabelUtils.getDefaultSunburstLabelSettings = getDefaultSunburstLabelSettings;
	            function getDefaultColumnLabelSettings(isLabelPositionInside) {
	                var labelSettings = getDefaultLabelSettings(false, undefined);
	                labelSettings.position = null;
	                labelSettings.labelColor = undefined;
	                return labelSettings;
	            }
	            dataLabelUtils.getDefaultColumnLabelSettings = getDefaultColumnLabelSettings;
	            function getDefaultPointLabelSettings() {
	                return {
	                    show: false,
	                    position: 0 /* Above */,
	                    displayUnits: 0,
	                    precision: dataLabelUtils.defaultLabelPrecision,
	                    labelColor: dataLabelUtils.defaultLabelColor,
	                    fontSize: dataLabelUtils.DefaultFontSizeInPt,
	                };
	            }
	            dataLabelUtils.getDefaultPointLabelSettings = getDefaultPointLabelSettings;
	            function getDefaultLineChartLabelSettings(isComboChart) {
	                return {
	                    show: false,
	                    position: 0 /* Above */,
	                    displayUnits: 0,
	                    precision: dataLabelUtils.defaultLabelPrecision,
	                    labelColor: dataLabelUtils.defaultLabelColor,
	                    fontSize: dataLabelUtils.DefaultFontSizeInPt,
	                    labelDensity: dataLabelUtils.defaultLabelDensity,
	                };
	            }
	            dataLabelUtils.getDefaultLineChartLabelSettings = getDefaultLineChartLabelSettings;
	            function getDefaultMapLabelSettings() {
	                return {
	                    show: false,
	                    showCategory: false,
	                    position: 0 /* Above */,
	                    displayUnits: 0,
	                    precision: dataLabelUtils.defaultLabelPrecision,
	                    labelColor: dataLabelUtils.defaultInsideLabelColor,
	                    fontSize: dataLabelUtils.DefaultFontSizeInPt,
	                };
	            }
	            dataLabelUtils.getDefaultMapLabelSettings = getDefaultMapLabelSettings;
	            function getDefaultDonutLabelSettings() {
	                var labelSettings = dataLabelUtils.getDefaultLabelSettings(true, dataLabelUtils.defaultLabelColor, dataLabelUtils.DefaultFontSizeInPt);
	                labelSettings.labelStyle = LabelStyle.category;
	                return labelSettings;
	            }
	            dataLabelUtils.getDefaultDonutLabelSettings = getDefaultDonutLabelSettings;
	            function getDefaultGaugeLabelSettings() {
	                return {
	                    show: true,
	                    displayUnits: 0,
	                    precision: dataLabelUtils.defaultLabelPrecision,
	                    labelColor: null,
	                    position: null,
	                    fontSize: dataLabelUtils.minLabelFontSize,
	                };
	            }
	            dataLabelUtils.getDefaultGaugeLabelSettings = getDefaultGaugeLabelSettings;
	            function getDefaultKpiLabelSettings() {
	                return {
	                    show: false,
	                    displayUnits: 0,
	                    precision: dataLabelUtils.defaultLabelPrecision,
	                    labelColor: dataLabelUtils.defaultLabelColor,
	                    position: null,
	                    showCategory: true,
	                };
	            }
	            dataLabelUtils.getDefaultKpiLabelSettings = getDefaultKpiLabelSettings;
	            function getLabelPrecision(precision, format) {
	                debug.assertAnyValue(format, 'format');
	                if (precision !== dataLabelUtils.defaultLabelPrecision)
	                    return precision;
	                if (format === 'g' || format === 'G')
	                    return;
	                if (format) {
	                    // Calculate precision from positive format by default
	                    var positiveFormat = powerbi.NumberFormat.getComponents(format).positive;
	                    var formatMetadata = powerbi.NumberFormat.getCustomFormatMetadata(positiveFormat, true /*calculatePrecision*/);
	                    if (formatMetadata.hasDots) {
	                        return formatMetadata.precision;
	                    }
	                }
	                // For count fields we do not want a precision by default
	                return defaultCountLabelPrecision;
	            }
	            dataLabelUtils.getLabelPrecision = getLabelPrecision;
	            function drawDefaultLabelsForDataPointChart(data, context, layout, viewport, isAnimator, animationDuration, hasSelection) {
	                if (isAnimator === void 0) { isAnimator = false; }
	                debug.assertValue(data, 'data cannot be null or undefined');
	                // Hide and reposition labels that overlap
	                var dataLabelManager = new powerbi.DataLabelManager();
	                var filteredData = dataLabelManager.hideCollidedLabels(viewport, data, layout);
	                var hasAnimation = isAnimator && !!animationDuration;
	                var labels = selectLabels(filteredData, context, false, hasAnimation);
	                if (!labels)
	                    return;
	                if (hasAnimation) {
	                    labels
	                        .text(function (d) { return d.labeltext; })
	                        .transition()
	                        .duration(animationDuration)
	                        .style(layout.style)
	                        .style('opacity', hasSelection ? function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); } : 1)
	                        .attr({ x: function (d) { return d.labelX; }, y: function (d) { return d.labelY; } });
	                    labels
	                        .exit()
	                        .transition()
	                        .duration(animationDuration)
	                        .style('opacity', 0) //fade out labels that are removed
	                        .remove();
	                }
	                else {
	                    labels
	                        .attr({ x: function (d) { return d.labelX; }, y: function (d) { return d.labelY; } })
	                        .text(function (d) { return d.labeltext; })
	                        .style(layout.style);
	                    labels
	                        .exit()
	                        .remove();
	                }
	                return labels;
	            }
	            dataLabelUtils.drawDefaultLabelsForDataPointChart = drawDefaultLabelsForDataPointChart;
	            function selectLabels(filteredData, context, isDonut, forAnimation) {
	                if (isDonut === void 0) { isDonut = false; }
	                if (forAnimation === void 0) { forAnimation = false; }
	                // Check for a case where resizing leaves no labels - then we need to remove the labels 'g'
	                if (filteredData.length === 0) {
	                    cleanDataLabels(context, true);
	                    return null;
	                }
	                if (context.select(labelGraphicsContextClass.selector).empty())
	                    context.append('g').classed(labelGraphicsContextClass.class, true);
	                // line chart ViewModel has a special 'key' property for point identification since the 'identity' field is set to the series identity
	                var hasKey = filteredData[0].key != null;
	                var hasDataPointIdentity = filteredData[0].identity != null;
	                var getIdentifier = hasKey ?
	                    function (d) { return d.key; }
	                    : hasDataPointIdentity ?
	                        function (d) { return d.identity.getKey(); }
	                        : undefined;
	                var labels = isDonut ?
	                    context.select(labelGraphicsContextClass.selector).selectAll(labelsClass.selector).data(filteredData, function (d) { return d.data.identity.getKey(); })
	                    : getIdentifier != null ?
	                        context.select(labelGraphicsContextClass.selector).selectAll(labelsClass.selector).data(filteredData, getIdentifier)
	                        : context.select(labelGraphicsContextClass.selector).selectAll(labelsClass.selector).data(filteredData);
	                var newLabels = labels.enter()
	                    .append('text')
	                    .classed(labelsClass.class, true);
	                if (forAnimation)
	                    newLabels.style('opacity', 0);
	                return labels;
	            }
	            function cleanDataLabels(context, removeLines) {
	                if (removeLines === void 0) { removeLines = false; }
	                var empty = [];
	                var labels = context.selectAll(labelsClass.selector).data(empty);
	                labels.exit().remove();
	                context.selectAll(labelGraphicsContextClass.selector).remove();
	                if (removeLines) {
	                    var lines = context.selectAll(lineClass.selector).data(empty);
	                    lines.exit().remove();
	                    context.selectAll(linesGraphicsContextClass.selector).remove();
	                }
	            }
	            dataLabelUtils.cleanDataLabels = cleanDataLabels;
	            function setHighlightedLabelsOpacity(context, hasSelection, hasHighlights) {
	                context.selectAll(labelsClass.selector).style("fill-opacity", function (d) {
	                    var labelOpacity = visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights) < 1 ? 0 : 1;
	                    return labelOpacity;
	                });
	            }
	            dataLabelUtils.setHighlightedLabelsOpacity = setHighlightedLabelsOpacity;
	            function getLabelFormattedText(options) {
	                var properties = {
	                    text: options.formatter
	                        ? options.formatter.format(options.label)
	                        : powerbi.formattingService.formatValue(options.label, options.format),
	                    fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
	                    fontSize: PixelConverter.fromPoint(options.fontSize),
	                    fontWeight: dataLabelUtils.LabelTextProperties.fontWeight,
	                };
	                return powerbi.TextMeasurementService.getTailoredTextOrDefault(properties, options.maxWidth ? options.maxWidth : dataLabelUtils.maxLabelWidth);
	            }
	            dataLabelUtils.getLabelFormattedText = getLabelFormattedText;
	            function getLabelLayoutXYForWaterfall(xAxisProperties, categoryWidth, yAxisProperties, dataDomain) {
	                return {
	                    x: function (d) { return xAxisProperties.scale(d.categoryIndex) + (categoryWidth / 2); },
	                    y: function (d) { return getWaterfallLabelYPosition(yAxisProperties.scale, d, dataDomain); }
	                };
	            }
	            dataLabelUtils.getLabelLayoutXYForWaterfall = getLabelLayoutXYForWaterfall;
	            function getWaterfallLabelYPosition(scale, d, dataDomain) {
	                var yValue = scale(0) - scale(Math.abs(d.value));
	                var yPos = scale(d.position);
	                var scaleMinDomain = scale(dataDomain[0]);
	                var endPosition = scale(d.position + d.value);
	                if (d.value < 0) {
	                    var properties = {
	                        text: d.labeltext,
	                        fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
	                        fontSize: dataLabelUtils.LabelTextProperties.fontSize,
	                        fontWeight: dataLabelUtils.LabelTextProperties.fontWeight,
	                    };
	                    var outsideBelowPosition = yPos + yValue + powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
	                    // Try to honor the position, but if the label doesn't fit where specified, then swap the position.
	                    if (scaleMinDomain > outsideBelowPosition) {
	                        return outsideBelowPosition;
	                    }
	                }
	                else {
	                    var outsideAbovePosition = yPos - yValue - dataLabelUtils.labelMargin;
	                    // Try to honor the position, but if the label doesn't fit where specified, then swap the position.
	                    if (outsideAbovePosition > 0) {
	                        return outsideAbovePosition;
	                    }
	                }
	                d.isLabelInside = true;
	                return getWaterfallInsideLabelYPosition(yPos, endPosition, scaleMinDomain);
	            }
	            function getWaterfallInsideLabelYPosition(startPosition, endPosition, scaleMinDomain) {
	                // Get the start and end position of the column
	                // If the start or end is outside of the visual because of clipping - adjust the position
	                startPosition = startPosition < 0 ? 0 : startPosition;
	                startPosition = startPosition > scaleMinDomain ? scaleMinDomain : startPosition;
	                endPosition = endPosition < 0 ? 0 : endPosition;
	                endPosition = endPosition > scaleMinDomain ? scaleMinDomain : endPosition;
	                return (Math.abs(endPosition - startPosition) / 2) + Math.min(startPosition, endPosition);
	            }
	            function doesDataLabelFitInShape(d, yAxisProperties, layout) {
	                if (d == null || d.value === null)
	                    return false;
	                var properties = {
	                    text: layout.labelText(d),
	                    fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
	                    fontSize: dataLabelUtils.LabelTextProperties.fontSize,
	                    fontWeight: dataLabelUtils.LabelTextProperties.fontWeight,
	                };
	                var outsidePosition = visuals.WaterfallChart.getRectTop(yAxisProperties.scale, d.position, d.value) - dataLabelUtils.labelMargin;
	                // The shape is fit to be outside
	                if (outsidePosition > 0)
	                    return true;
	                var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
	                var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
	                var shapeWidth = layout.categoryWidth;
	                var shapeHeight = Math.abs(visuals.AxisHelper.diffScaled(yAxisProperties.scale, Math.max(0, Math.abs(d.value)), 0));
	                //checking that labels aren't greater than shape
	                if ((textWidth > shapeWidth) || (textHeight > shapeHeight))
	                    return false;
	                return true;
	            }
	            dataLabelUtils.doesDataLabelFitInShape = doesDataLabelFitInShape;
	            function getMapLabelLayout(labelSettings) {
	                return {
	                    labelText: function (d) {
	                        return getLabelFormattedText({
	                            label: d.labeltext,
	                            fontSize: labelSettings.fontSize
	                        });
	                    },
	                    labelLayout: {
	                        x: function (d) { return d.x; },
	                        y: function (d) {
	                            var margin = d.radius + dataLabelUtils.labelMargin;
	                            return labelSettings.position === 0 /* Above */ ? d.y - margin : d.y + margin;
	                        },
	                    },
	                    filter: function (d) {
	                        return (d != null && d.labeltext != null);
	                    },
	                    style: {
	                        'fill': function (d) { return d.labelFill; },
	                        'font-size': PixelConverter.fromPoint(labelSettings.fontSize),
	                    },
	                };
	            }
	            dataLabelUtils.getMapLabelLayout = getMapLabelLayout;
	            function getColumnChartLabelLayout(data, labelLayoutXY, isColumn, isHundredPercent, axisFormatter, axisOptions, interactivityService, visualWidth) {
	                var formatOverride = (isHundredPercent) ? dataLabelUtils.hundredPercentFormat : null;
	                var formattersCache = createColumnFormatterCacheManager();
	                var hasSelection = interactivityService ? interactivityService.hasSelection() : false;
	                return {
	                    labelText: function (d) {
	                        var formatString = (formatOverride != null) ? formatOverride : d.labelFormatString;
	                        var value2 = getDisplayUnitValueFromAxisFormatter(axisFormatter, d.labelSettings);
	                        var formatter = formattersCache.getOrCreate(formatString, d.labelSettings, value2);
	                        return getLabelFormattedText({
	                            label: formatter.format(d.value),
	                            maxWidth: dataLabelUtils.maxLabelWidth
	                        });
	                    },
	                    labelLayout: labelLayoutXY,
	                    filter: function (d) { return dataLabelUtils.getColumnChartLabelFilter(d, hasSelection, data.hasHighlights, axisOptions, visualWidth); },
	                    style: {
	                        'fill': function (d) { return d.labelFill; },
	                        'text-anchor': isColumn ? 'middle' : 'start',
	                    },
	                };
	            }
	            dataLabelUtils.getColumnChartLabelLayout = getColumnChartLabelLayout;
	            /**
	             * Valide for stacked column/bar chart and 100% stacked column/bar chart,
	             * that labels that should to be inside the shape aren't bigger then shapes.
	             */
	            function validateLabelsSize(d, axisOptions, visualWidth) {
	                var xScale = axisOptions.xScale;
	                var yScale = axisOptions.yScale;
	                var columnWidth = axisOptions.columnWidth;
	                var properties = {
	                    text: d.labeltext,
	                    fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
	                    fontSize: dataLabelUtils.LabelTextProperties.fontSize,
	                    fontWeight: dataLabelUtils.LabelTextProperties.fontWeight,
	                };
	                var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
	                var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
	                var shapeWidth, shapeHeight;
	                var inside = false;
	                var outsidePosition = visuals.ColumnUtil.calculatePosition(d, axisOptions);
	                switch (d.chartType) {
	                    case visuals.ColumnChartType.stackedBar:
	                    case visuals.ColumnChartType.hundredPercentStackedBar:
	                        // if the series isn't last or the label doesn't fit where specified, then it should be inside 
	                        if (!d.lastSeries || (outsidePosition + textWidth > visualWidth) || d.chartType === visuals.ColumnChartType.hundredPercentStackedBar) {
	                            shapeWidth = -visuals.StackedUtil.getSize(xScale, d.valueAbsolute);
	                            shapeHeight = columnWidth;
	                            inside = true;
	                        }
	                        break;
	                    case visuals.ColumnChartType.clusteredBar:
	                        // if the label doesn't fit where specified, then it should be inside 
	                        if ((outsidePosition + textWidth) > visualWidth) {
	                            shapeWidth = Math.abs(visuals.AxisHelper.diffScaled(xScale, 0, d.value));
	                            shapeHeight = columnWidth;
	                            inside = true;
	                        }
	                        break;
	                    case visuals.ColumnChartType.stackedColumn:
	                    case visuals.ColumnChartType.hundredPercentStackedColumn:
	                        // if the series isn't last or the label doesn't fit where specified, then it should be inside 
	                        if (!d.lastSeries || outsidePosition <= 0 || d.chartType === visuals.ColumnChartType.hundredPercentStackedColumn) {
	                            shapeWidth = columnWidth;
	                            shapeHeight = visuals.StackedUtil.getSize(yScale, d.valueAbsolute);
	                            inside = true;
	                        }
	                        break;
	                    case visuals.ColumnChartType.clusteredColumn:
	                        // if the label doesn't fit where specified, then it should be inside 
	                        if (outsidePosition <= 0) {
	                            shapeWidth = columnWidth;
	                            shapeHeight = Math.abs(visuals.AxisHelper.diffScaled(yScale, 0, d.value));
	                            inside = true;
	                        }
	                        break;
	                    default:
	                        return true;
	                }
	                //checking that labels aren't greater than shape
	                if (inside && ((textWidth > shapeWidth) || textHeight > shapeHeight))
	                    return false;
	                return true;
	            }
	            function getColumnChartLabelFilter(d, hasSelection, hasHighlights, axisOptions, visualWidth) {
	                //labels of dimmed are hidden
	                var shapesOpacity = hasSelection ? visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights) :
	                    visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, hasHighlights);
	                return (d != null && d.value != null && validateLabelsSize(d, axisOptions, visualWidth) && shapesOpacity === 1);
	            }
	            dataLabelUtils.getColumnChartLabelFilter = getColumnChartLabelFilter;
	            function getScatterChartLabelLayout(xScale, yScale, labelSettings, viewport, sizeRange) {
	                return {
	                    labelText: function (d) {
	                        return getLabelFormattedText({
	                            label: d.formattedCategory.getValue(),
	                            maxWidth: dataLabelUtils.maxLabelWidth * 2.0
	                        });
	                    },
	                    labelLayout: {
	                        x: function (d) { return xScale(d.x); },
	                        y: function (d) {
	                            var margin = visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, viewport) + dataLabelUtils.labelMargin;
	                            return labelSettings.position === 0 /* Above */ ? yScale(d.y) - margin : yScale(d.y) + margin;
	                        },
	                    },
	                    filter: function (d) {
	                        return (d != null && d.formattedCategory.getValue() != null);
	                    },
	                    style: {
	                        'fill': function (d) { return d.labelFill; },
	                    },
	                };
	            }
	            dataLabelUtils.getScatterChartLabelLayout = getScatterChartLabelLayout;
	            function getLineChartLabelLayout(xScale, yScale, labelSettings, isScalar, axisFormatter) {
	                var formattersCache = createColumnFormatterCacheManager();
	                return {
	                    labelText: function (d) {
	                        var value2 = getDisplayUnitValueFromAxisFormatter(axisFormatter, d.labelSettings);
	                        var formatter = formattersCache.getOrCreate(d.labelFormatString, d.labelSettings, value2);
	                        return getLabelFormattedText({ label: formatter.format(d.value) });
	                    },
	                    labelLayout: {
	                        x: function (d) { return xScale(isScalar ? d.categoryValue : d.categoryIndex); },
	                        y: function (d) { return labelSettings.position === 0 /* Above */ ? yScale(d.value) - dataLabelUtils.labelMargin : yScale(d.value) + dataLabelUtils.labelMargin; },
	                    },
	                    filter: function (d) {
	                        return (d != null && d.value != null);
	                    },
	                    style: {
	                        'fill': function (d) { return d.labelFill; },
	                        'font-size': function (d) { return PixelConverter.fromPoint(d.labelSettings.fontSize); },
	                    },
	                };
	            }
	            dataLabelUtils.getLineChartLabelLayout = getLineChartLabelLayout;
	            function enumerateDataLabels(options) {
	                debug.assertValue(options, 'options');
	                debug.assertValue(options.enumeration, 'enumeration');
	                if (!options.dataLabelsSettings)
	                    return;
	                var instance = {
	                    objectName: 'labels',
	                    selector: options.selector,
	                    properties: {},
	                };
	                if (options.show && options.selector) {
	                    instance.properties['showSeries'] = options.dataLabelsSettings.show;
	                }
	                else if (options.show) {
	                    instance.properties['show'] = options.dataLabelsSettings.show;
	                }
	                instance.properties['color'] = options.dataLabelsSettings.labelColor || dataLabelUtils.defaultLabelColor;
	                if (options.displayUnits) {
	                    instance.properties['labelDisplayUnits'] = options.dataLabelsSettings.displayUnits;
	                }
	                if (options.precision) {
	                    var precision = options.dataLabelsSettings.precision;
	                    instance.properties['labelPrecision'] = precision === dataLabelUtils.defaultLabelPrecision ? null : precision;
	                }
	                if (options.position) {
	                    instance.properties['labelPosition'] = options.dataLabelsSettings.position;
	                    if (options.positionObject) {
	                        debug.assert(!instance.validValues, '!instance.validValues');
	                        instance.validValues = { 'labelPosition': options.positionObject };
	                    }
	                }
	                if (options.labelStyle)
	                    instance.properties['labelStyle'] = options.dataLabelsSettings.labelStyle;
	                if (options.fontSize)
	                    instance.properties['fontSize'] = options.dataLabelsSettings.fontSize;
	                if (options.labelDensity) {
	                    var lineChartSettings = options.dataLabelsSettings;
	                    if (lineChartSettings)
	                        instance.properties['labelDensity'] = lineChartSettings.labelDensity;
	                }
	                //Keep show all as the last property of the instance.
	                if (options.showAll)
	                    instance.properties['showAll'] = options.dataLabelsSettings.showLabelPerSeries;
	                return options.enumeration.pushInstance(instance);
	            }
	            dataLabelUtils.enumerateDataLabels = enumerateDataLabels;
	            function enumerateCategoryLabels(enumeration, dataLabelsSettings, withFill, isShowCategory, fontSize) {
	                if (isShowCategory === void 0) { isShowCategory = false; }
	                var labelSettings = (dataLabelsSettings)
	                    ? dataLabelsSettings
	                    : getDefaultPointLabelSettings();
	                var instance = {
	                    objectName: 'categoryLabels',
	                    selector: null,
	                    properties: {
	                        show: isShowCategory
	                            ? labelSettings.showCategory
	                            : labelSettings.show,
	                        fontSize: dataLabelsSettings ? dataLabelsSettings.fontSize : dataLabelUtils.DefaultFontSizeInPt,
	                    },
	                };
	                if (withFill) {
	                    instance.properties['color'] = labelSettings.categoryLabelColor
	                        ? labelSettings.categoryLabelColor
	                        : labelSettings.labelColor;
	                }
	                if (fontSize) {
	                    instance.properties['fontSize'] = fontSize;
	                }
	                enumeration.pushInstance(instance);
	            }
	            dataLabelUtils.enumerateCategoryLabels = enumerateCategoryLabels;
	            function getDisplayUnitValueFromAxisFormatter(axisFormatter, labelSettings) {
	                if (axisFormatter && axisFormatter.displayUnit && labelSettings.displayUnits === 0)
	                    return axisFormatter.displayUnit.value;
	                return null;
	            }
	            function createColumnFormatterCacheManager() {
	                return {
	                    cache: { defaultFormatter: null, },
	                    getOrCreate: function (formatString, labelSetting, value2) {
	                        if (formatString) {
	                            var cacheKeyObject = {
	                                formatString: formatString,
	                                displayUnits: labelSetting.displayUnits,
	                                precision: getLabelPrecision(labelSetting.precision, formatString),
	                                value2: value2
	                            };
	                            var cacheKey = JSON.stringify(cacheKeyObject);
	                            if (!this.cache[cacheKey])
	                                this.cache[cacheKey] = visuals.valueFormatter.create(getOptionsForLabelFormatter(labelSetting, formatString, value2, cacheKeyObject.precision));
	                            return this.cache[cacheKey];
	                        }
	                        if (!this.cache.defaultFormatter) {
	                            this.cache.defaultFormatter = visuals.valueFormatter.create(getOptionsForLabelFormatter(labelSetting, formatString, value2, labelSetting.precision));
	                        }
	                        return this.cache.defaultFormatter;
	                    }
	                };
	            }
	            dataLabelUtils.createColumnFormatterCacheManager = createColumnFormatterCacheManager;
	            function getOptionsForLabelFormatter(labelSetting, formatString, value2, precision) {
	                return {
	                    displayUnitSystemType: powerbi.DisplayUnitSystemType.DataLabels,
	                    format: formatString,
	                    precision: precision,
	                    value: labelSetting.displayUnits,
	                    value2: value2,
	                    allowFormatBeautification: true,
	                };
	            }
	            dataLabelUtils.getOptionsForLabelFormatter = getOptionsForLabelFormatter;
	            function isTextWidthOverflows(textWidth, maxTextWidth) {
	                return textWidth > maxTextWidth;
	            }
	            dataLabelUtils.isTextWidthOverflows = isTextWidthOverflows;
	            ;
	            function isTextHeightOverflows(textHeight, innerChordLength) {
	                return textHeight > innerChordLength;
	            }
	            dataLabelUtils.isTextHeightOverflows = isTextHeightOverflows;
	            ;
	        })(dataLabelUtils = visuals.dataLabelUtils || (visuals.dataLabelUtils = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 199 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var DonutLabelUtils;
	        (function (DonutLabelUtils) {
	            DonutLabelUtils.LineStrokeWidth = 1;
	            DonutLabelUtils.DiagonalLineIndex = 0;
	            DonutLabelUtils.HorizontalLineIndex = 1;
	            function getLabelLeaderLineForDonutChart(donutArcDescriptor, donutProperties, parentPoint, sliceArc) {
	                if (sliceArc === void 0) { sliceArc = 0; }
	                var innerLinePointMultiplier = 2.05;
	                var textPoint;
	                var midPoint;
	                var chartPoint;
	                // Label position has changed
	                if (sliceArc) {
	                    var arc = sliceArc;
	                    var outerRadius = donutProperties.radius * donutProperties.outerArcRadiusRatio;
	                    var innerRadius = (donutProperties.radius / 2) * donutProperties.innerArcRadiusRatio;
	                    midPoint = [Math.cos(arc) * outerRadius, Math.sin(arc) * outerRadius];
	                    chartPoint = [Math.cos(arc) * innerRadius, Math.sin(arc) * innerRadius];
	                }
	                else {
	                    midPoint = donutProperties.outerArc.centroid(donutArcDescriptor);
	                    chartPoint = donutProperties.arc.centroid(donutArcDescriptor);
	                }
	                var textPointX = parentPoint.x;
	                var lineMargin = visuals.NewDataLabelUtils.maxLabelOffset / 2;
	                textPointX += textPointX < 0 ? -lineMargin : lineMargin;
	                textPoint = [textPointX, parentPoint.y];
	                chartPoint[0] *= innerLinePointMultiplier;
	                chartPoint[1] *= innerLinePointMultiplier;
	                return [chartPoint, midPoint, textPoint];
	            }
	            DonutLabelUtils.getLabelLeaderLineForDonutChart = getLabelLeaderLineForDonutChart;
	            /** We calculate the rectangles of the leader lines for collision detection
	              *width: x2 - x1; height: y2 - y1 */
	            function getLabelLeaderLinesSizeForDonutChart(leaderLinePoints) {
	                if (leaderLinePoints && leaderLinePoints.length > 2) {
	                    var diagonalLineSize = {
	                        width: Math.abs(leaderLinePoints[1][0] - leaderLinePoints[0][0]),
	                        height: Math.abs(leaderLinePoints[1][1] - leaderLinePoints[0][1]),
	                    };
	                    // For horizontal line we set 1 in the height
	                    var horizontalLineSize = {
	                        width: Math.abs(leaderLinePoints[2][0] - leaderLinePoints[1][0]),
	                        height: DonutLabelUtils.LineStrokeWidth,
	                    };
	                    return [diagonalLineSize, horizontalLineSize];
	                }
	                return null;
	            }
	            DonutLabelUtils.getLabelLeaderLinesSizeForDonutChart = getLabelLeaderLinesSizeForDonutChart;
	            function getXPositionForDonutLabel(textPointX) {
	                var margin = textPointX < 0 ? -visuals.NewDataLabelUtils.maxLabelOffset : visuals.NewDataLabelUtils.maxLabelOffset;
	                return textPointX += margin;
	            }
	            DonutLabelUtils.getXPositionForDonutLabel = getXPositionForDonutLabel;
	            function getSpaceAvailableForDonutLabels(labelXPos, viewport) {
	                return viewport.width / 2 - Math.abs(labelXPos) - visuals.NewDataLabelUtils.maxLabelOffset;
	            }
	            DonutLabelUtils.getSpaceAvailableForDonutLabels = getSpaceAvailableForDonutLabels;
	        })(DonutLabelUtils = visuals.DonutLabelUtils || (visuals.DonutLabelUtils = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 200 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
	        var PixelConverter = jsCommon.PixelConverter;
	        var NewDataLabelUtils;
	        (function (NewDataLabelUtils) {
	            NewDataLabelUtils.DefaultLabelFontSizeInPt = 9;
	            NewDataLabelUtils.MapPolylineOpacity = 0.5;
	            NewDataLabelUtils.LabelDensityBufferFactor = 3;
	            NewDataLabelUtils.LabelDensityPadding = 6;
	            NewDataLabelUtils.startingLabelOffset = 8;
	            NewDataLabelUtils.maxLabelOffset = 8;
	            NewDataLabelUtils.maxLabelWidth = 50;
	            NewDataLabelUtils.hundredPercentFormat = '0.00 %;-0.00 %;0.00 %';
	            NewDataLabelUtils.LabelTextProperties = {
	                fontFamily: visuals.Font.Family.regularSecondary.css,
	                fontSize: PixelConverter.fromPoint(NewDataLabelUtils.DefaultLabelFontSizeInPt),
	                fontWeight: 'normal',
	            };
	            NewDataLabelUtils.defaultLabelColor = "#777777";
	            NewDataLabelUtils.defaultInsideLabelColor = "#ffffff"; //white
	            NewDataLabelUtils.horizontalLabelBackgroundPadding = 4;
	            NewDataLabelUtils.verticalLabelBackgroundPadding = 2;
	            var labelBackgroundRounding = 4;
	            var defaultLabelPrecision = undefined;
	            var defaultCountLabelPrecision = 0;
	            NewDataLabelUtils.labelGraphicsContextClass = createClassAndSelector('labelGraphicsContext');
	            NewDataLabelUtils.labelBackgroundGraphicsContextClass = createClassAndSelector('labelBackgroundGraphicsContext');
	            var labelsClass = createClassAndSelector('label');
	            var secondLineLabelClass = createClassAndSelector('label-second-line');
	            var linesGraphicsContextClass = createClassAndSelector('leader-lines');
	            var lineClass = createClassAndSelector('line-label');
	            function drawDefaultLabels(context, dataLabels, numeric, twoRows, hasTooltip) {
	                if (numeric === void 0) { numeric = false; }
	                if (twoRows === void 0) { twoRows = false; }
	                if (hasTooltip === void 0) { hasTooltip = false; }
	                var filteredDataLabels = _.filter(dataLabels, function (d) { return d.isVisible; });
	                var labels = context.selectAll(labelsClass.selector)
	                    .data(filteredDataLabels, labelKeyFunction);
	                labels.enter()
	                    .append("text")
	                    .classed(labelsClass.class, true);
	                var labelAttr = {
	                    x: function (d) {
	                        return (d.boundingBox.left + (d.boundingBox.width / 2));
	                    },
	                    y: function (d) {
	                        if (d.hasBackground)
	                            return d.boundingBox.top + d.boundingBox.height - NewDataLabelUtils.verticalLabelBackgroundPadding;
	                        else
	                            return d.boundingBox.top + d.boundingBox.height;
	                    },
	                    dy: "-0.15em",
	                };
	                if (numeric) {
	                    labelAttr.dy = undefined;
	                }
	                labels
	                    .interrupt()
	                    .text(function (d) { return d.text; })
	                    .attr(labelAttr)
	                    .style({
	                    'fill': function (d) { return d.fill; },
	                    'font-size': function (d) { return PixelConverter.fromPoint(d.fontSize || NewDataLabelUtils.DefaultLabelFontSizeInPt); },
	                    'text-anchor': function (d) { return d.textAnchor; },
	                });
	                labels.exit()
	                    .remove();
	                var filteredCategoryLabels = _.filter(twoRows ? dataLabels : [], function (d) { return d.isVisible && !_.isEmpty(d.secondRowText); });
	                var secondLineLabels = context.selectAll(secondLineLabelClass.selector)
	                    .data(filteredCategoryLabels, function (d, index) { return d.identity ? d.identity.getKeyWithoutHighlight() : index; });
	                secondLineLabels.enter()
	                    .append("text")
	                    .classed(secondLineLabelClass.class, true);
	                labelAttr = {
	                    x: function (d) {
	                        return (d.boundingBox.left + (d.boundingBox.width / 2));
	                    },
	                    y: function (d) {
	                        var boundingBoxHeight = (d.text !== undefined) ? d.boundingBox.height / 2 : d.boundingBox.height;
	                        if (d.hasBackground)
	                            return d.boundingBox.top + boundingBoxHeight - NewDataLabelUtils.verticalLabelBackgroundPadding;
	                        else
	                            return d.boundingBox.top + boundingBoxHeight;
	                    },
	                    dy: "-0.15em",
	                };
	                if (numeric) {
	                    labelAttr.dy = undefined;
	                }
	                secondLineLabels
	                    .interrupt()
	                    .text(function (d) { return d.secondRowText; })
	                    .attr(labelAttr)
	                    .style({
	                    'fill': function (d) { return d.fill; },
	                    'font-size': function (d) { return PixelConverter.fromPoint(d.fontSize || NewDataLabelUtils.DefaultLabelFontSizeInPt); },
	                    'text-anchor': function (d) { return d.textAnchor; },
	                });
	                secondLineLabels.exit()
	                    .remove();
	                if (hasTooltip) {
	                    labels.append('title').text(function (d) { return d.tooltip; });
	                    secondLineLabels.append('title').text(function (d) { return d.tooltip; });
	                    labels.style("pointer-events", "all");
	                    secondLineLabels.style("pointer-events", "all");
	                }
	                return labels;
	            }
	            NewDataLabelUtils.drawDefaultLabels = drawDefaultLabels;
	            function animateDefaultLabels(context, dataLabels, duration, numeric, easeType) {
	                if (numeric === void 0) { numeric = false; }
	                if (easeType === void 0) { easeType = 'cubic-in-out'; }
	                var labels = context.selectAll(labelsClass.selector)
	                    .data(_.filter(dataLabels, function (d) { return d.isVisible; }), labelKeyFunction);
	                labels.enter()
	                    .append("text")
	                    .classed(labelsClass.class, true)
	                    .style('opacity', 0);
	                var labelAttr = {
	                    x: function (d) {
	                        return (d.boundingBox.left + (d.boundingBox.width / 2));
	                    },
	                    y: function (d) {
	                        return d.boundingBox.top + d.boundingBox.height;
	                    },
	                    dy: "-0.15em",
	                };
	                if (numeric) {
	                    labelAttr.dy = undefined;
	                }
	                labels.text(function (d) { return d.text; })
	                    .style({
	                    'fill': function (d) { return d.fill; },
	                    'font-size': function (d) { return PixelConverter.fromPoint(d.fontSize || NewDataLabelUtils.DefaultLabelFontSizeInPt); },
	                })
	                    .transition()
	                    .ease(easeType)
	                    .duration(duration)
	                    .attr(labelAttr)
	                    .style('opacity', 1);
	                labels.exit()
	                    .transition()
	                    .duration(duration)
	                    .style('opacity', 0)
	                    .remove();
	                return labels;
	            }
	            NewDataLabelUtils.animateDefaultLabels = animateDefaultLabels;
	            /** Draws black rectangles based on the bounding bx of labels, to be used in debugging */
	            function drawLabelBackground(context, dataLabels, fill, fillOpacity) {
	                var labelRects = context.selectAll("rect")
	                    .data(_.filter(dataLabels, function (d) { return d.isVisible; }), labelKeyFunction);
	                labelRects.enter()
	                    .append("rect");
	                labelRects
	                    .attr({
	                    x: function (d) {
	                        return d.boundingBox.left - NewDataLabelUtils.horizontalLabelBackgroundPadding;
	                    },
	                    y: function (d) {
	                        return d.boundingBox.top - NewDataLabelUtils.verticalLabelBackgroundPadding;
	                    },
	                    rx: labelBackgroundRounding,
	                    ry: labelBackgroundRounding,
	                    width: function (d) {
	                        return d.boundingBox.width + 2 * NewDataLabelUtils.horizontalLabelBackgroundPadding;
	                    },
	                    height: function (d) {
	                        if (d.text === undefined && d.secondRowText === undefined) {
	                            return 0;
	                        }
	                        return d.boundingBox.height + 2 * NewDataLabelUtils.verticalLabelBackgroundPadding;
	                    },
	                })
	                    .style("fill", fill ? fill : "#000000")
	                    .style("fill-opacity", fillOpacity != null ? fillOpacity : 1);
	                labelRects.exit()
	                    .remove();
	                return labelRects;
	            }
	            NewDataLabelUtils.drawLabelBackground = drawLabelBackground;
	            function drawLabelLeaderLines(context, filteredDataLabels, key, leaderLineColor) {
	                if (context.select(linesGraphicsContextClass.selector).empty())
	                    context.append('g').classed(linesGraphicsContextClass.class, true);
	                var lines = context.select(linesGraphicsContextClass.selector).selectAll('polyline')
	                    .data(filteredDataLabels, key);
	                lines.enter()
	                    .append('polyline')
	                    .classed(lineClass.class, true);
	                lines
	                    .attr('points', function (d) {
	                    return d.leaderLinePoints;
	                }).
	                    style({
	                    'stroke': function (d) { return leaderLineColor ? leaderLineColor : d.fill; },
	                    'stroke-width': visuals.DonutLabelUtils.LineStrokeWidth,
	                });
	                lines
	                    .exit()
	                    .remove();
	            }
	            NewDataLabelUtils.drawLabelLeaderLines = drawLabelLeaderLines;
	            function getLabelFormattedText(label, format, formatter) {
	                return formatter ? formatter.format(label) : powerbi.formattingService.formatValue(label, format);
	            }
	            NewDataLabelUtils.getLabelFormattedText = getLabelFormattedText;
	            function getDisplayUnitValueFromAxisFormatter(axisFormatter, labelSettings) {
	                if (axisFormatter && axisFormatter.displayUnit && labelSettings.displayUnits === 0)
	                    return axisFormatter.displayUnit.value;
	                return null;
	            }
	            NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter = getDisplayUnitValueFromAxisFormatter;
	            function getLabelPrecision(precision, format) {
	                debug.assertAnyValue(format, 'format');
	                if (precision !== defaultLabelPrecision)
	                    return precision;
	                if (format) {
	                    // Calculate precision from positive format by default
	                    var positiveFormat = format.split(";")[0];
	                    var formatMetadata = powerbi.NumberFormat.getCustomFormatMetadata(positiveFormat, true /*calculatePrecision*/);
	                    if (formatMetadata.hasDots) {
	                        return formatMetadata.precision;
	                    }
	                }
	                // For count fields we do not want a precision by default
	                return defaultCountLabelPrecision;
	            }
	            function createColumnFormatterCacheManager() {
	                return {
	                    cache: { defaultFormatter: null, },
	                    getOrCreate: function (formatString, labelSetting, value2) {
	                        if (formatString) {
	                            var cacheKeyObject = {
	                                formatString: formatString,
	                                displayUnits: labelSetting.displayUnits,
	                                precision: getLabelPrecision(labelSetting.precision, formatString),
	                                value2: value2
	                            };
	                            var cacheKey = JSON.stringify(cacheKeyObject);
	                            if (!this.cache[cacheKey])
	                                this.cache[cacheKey] = visuals.valueFormatter.create(getOptionsForLabelFormatter(labelSetting, formatString, value2, cacheKeyObject.precision));
	                            return this.cache[cacheKey];
	                        }
	                        if (!this.cache.defaultFormatter) {
	                            this.cache.defaultFormatter = visuals.valueFormatter.create(getOptionsForLabelFormatter(labelSetting, formatString, value2, labelSetting.precision));
	                        }
	                        return this.cache.defaultFormatter;
	                    }
	                };
	            }
	            NewDataLabelUtils.createColumnFormatterCacheManager = createColumnFormatterCacheManager;
	            function getOptionsForLabelFormatter(labelSetting, formatString, value2, precision) {
	                return {
	                    displayUnitSystemType: powerbi.DisplayUnitSystemType.DataLabels,
	                    format: formatString,
	                    precision: precision,
	                    value: labelSetting.displayUnits,
	                    value2: value2,
	                    allowFormatBeautification: true,
	                };
	            }
	            function removeDuplicates(labelDataPoints) {
	                var uniqueLabelDataPoints = [];
	                var labelDataPointMap = {};
	                var sameParentIsInArray = function (newValue, array, parentIsRect) {
	                    return array.some(function (arrayValue) {
	                        if (parentIsRect) {
	                            return visuals.shapes.Rect.equals(newValue.parentShape.rect, arrayValue.rect);
	                        }
	                        else {
	                            return visuals.shapes.Point.equals(newValue.parentShape.point, arrayValue.point);
	                        }
	                    });
	                };
	                for (var _i = 0, labelDataPoints_1 = labelDataPoints; _i < labelDataPoints_1.length; _i++) {
	                    var dataPoint = labelDataPoints_1[_i];
	                    var parentIsRect = dataPoint.parentType === 1 /* Rectangle */;
	                    var resultsFromMap = labelDataPointMap[dataPoint.text];
	                    if (!resultsFromMap) {
	                        uniqueLabelDataPoints.push(dataPoint);
	                        labelDataPointMap[dataPoint.text] = [dataPoint.parentShape];
	                    }
	                    else {
	                        if (!sameParentIsInArray(dataPoint, resultsFromMap, parentIsRect)) {
	                            uniqueLabelDataPoints.push(dataPoint);
	                            resultsFromMap.push(dataPoint.parentShape);
	                        }
	                    }
	                }
	                return uniqueLabelDataPoints;
	            }
	            NewDataLabelUtils.removeDuplicates = removeDuplicates;
	            function getDataLabelLayoutOptions(type) {
	                switch (type) {
	                    case 9 /* Scatter */:
	                        return {
	                            maximumOffset: visuals.ScatterChart.dataLabelLayoutMaximumOffset,
	                            startingOffset: visuals.ScatterChart.dataLabelLayoutStartingOffset,
	                            offsetIterationDelta: visuals.ScatterChart.dataLabelLayoutOffsetIterationDelta,
	                            allowLeaderLines: true,
	                            attemptToMoveLabelsIntoViewport: true,
	                        };
	                    default:
	                        return {
	                            maximumOffset: NewDataLabelUtils.maxLabelOffset,
	                            startingOffset: NewDataLabelUtils.startingLabelOffset,
	                            attemptToMoveLabelsIntoViewport: true,
	                        };
	                }
	            }
	            NewDataLabelUtils.getDataLabelLayoutOptions = getDataLabelLayoutOptions;
	            function getTextSize(text, fontSize) {
	                var labelTextProperties = NewDataLabelUtils.LabelTextProperties;
	                var properties = {
	                    text: text,
	                    fontFamily: labelTextProperties.fontFamily,
	                    fontSize: jsCommon.PixelConverter.fromPoint(fontSize),
	                    fontWeight: labelTextProperties.fontWeight,
	                };
	                return {
	                    width: powerbi.TextMeasurementService.measureSvgTextWidth(properties),
	                    height: powerbi.TextMeasurementService.estimateSvgTextHeight(properties),
	                };
	            }
	            NewDataLabelUtils.getTextSize = getTextSize;
	            /**
	             * Obtains the key from the label.  Index is required to use as a backup in cases
	             * where labels have no key or identity.
	             */
	            function labelKeyFunction(label, index) {
	                if (label.key) {
	                    return label.key;
	                }
	                if (label.identity) {
	                    return label.identity.getKeyWithoutHighlight();
	                }
	                return index;
	            }
	        })(NewDataLabelUtils = visuals.NewDataLabelUtils || (visuals.NewDataLabelUtils = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 201 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var KpiUtil;
	        (function (KpiUtil) {
	            var KPIImageClassName = 'powervisuals-glyph';
	            var BigImageClassName = 'big-kpi';
	            var RYGStatusIconClassNames = ['kpi-red', 'kpi-yellow', 'kpi-green'];
	            var threeLights = {
	                kpiIconClass: 'circle',
	                statusValues: RYGStatusIconClassNames,
	            };
	            var roadSigns = {
	                kpiIconClass: '',
	                statusValues: ['circle-x kpi-red', 'circle-exclamation kpi-yellow', 'circle-checkmark kpi-green'],
	            };
	            var trafficLight = {
	                kpiIconClass: 'traffic-light',
	                statusValues: RYGStatusIconClassNames,
	            };
	            var shapes = {
	                kpiIconClass: '',
	                statusValues: ['rhombus kpi-red', 'triangle kpi-yellow', 'circle kpi-green'],
	            };
	            var gauge = {
	                kpiIconClass: '',
	                statusValues: ['circle-empty', 'circle-one-quarter', 'circle-half', 'circle-three-quarters', 'circle-full'],
	            };
	            var statusGraphicFormatStrings = {
	                'THREE CIRCLES COLORED': threeLights,
	                'TRAFFIC LIGHT - SINGLE': threeLights,
	                'THREE FLAGS COLORED': {
	                    kpiIconClass: 'flag',
	                    statusValues: RYGStatusIconClassNames,
	                },
	                'ROAD SIGNS': roadSigns,
	                'THREE SYMBOLS CIRCLED COLORED': roadSigns,
	                'TRAFFIC LIGHT': trafficLight,
	                'THREE TRAFFIC LIGHTS RIMMED COLORED': trafficLight,
	                'THREE SYMBOLS UNCIRCLED COLORED': {
	                    kpiIconClass: '',
	                    statusValues: ['x kpi-red', 'exclamation kpi-yellow', 'checkmark kpi-green'],
	                },
	                'SHAPES': shapes,
	                'SMILEY FACE': shapes,
	                'THERMOMETER': shapes,
	                'CYLINDER': shapes,
	                'THREE SIGNS COLORED': shapes,
	                'THREE STARS COLORED': {
	                    kpiIconClass: 'star-stacked',
	                    statusValues: ['star-empty', 'star-half-full', 'star-full'],
	                },
	                'FIVE BARS COLORED': {
	                    kpiIconClass: 'bars-stacked',
	                    statusValues: ['bars-zero', 'bars-one', 'bars-two', 'bars-three', 'bars-four'],
	                },
	                'FIVE BOXES COLORED': {
	                    kpiIconClass: 'boxes-stacked',
	                    statusValues: ['boxes-zero', 'boxes-one', 'boxes-two', 'boxes-three', 'boxes-four'],
	                },
	                'FIVE QUARTERS COLORED': gauge,
	                'GAUGE - ASCENDING': gauge,
	                'GAUGE - DESCENDING': {
	                    kpiIconClass: '',
	                    statusValues: ['circle-full', 'circle-three-quarters', 'circle-half', 'circle-one-quarter', 'circle-empty'],
	                },
	                'STANDARD ARROW': {
	                    kpiIconClass: '',
	                    statusValues: ['arrow-down', 'arrow-right-down', 'arrow-right', 'arrow-right-up', 'arrow-up'],
	                },
	                'VARIANCE ARROW': {
	                    kpiIconClass: '',
	                    statusValues: ['arrow-down kpi-red', 'arrow-right kpi-yellow', 'arrow-up kpi-green'],
	                },
	                'STATUS ARROW - ASCENDING': {
	                    kpiIconClass: '',
	                    statusValues: ['arrow-down kpi-red', 'arrow-right-down kpi-yellow', 'arrow-right kpi-yellow', 'arrow-right-up kpi-yellow', 'arrow-up kpi-green'],
	                },
	                'STATUS ARROW - DESCENDING': {
	                    kpiIconClass: '',
	                    statusValues: ['arrow-up kpi-green', 'arrow-right-up kpi-yellow', 'arrow-right kpi-yellow', 'arrow-right-down kpi-yellow', 'arrow-down kpi-red'],
	                },
	            };
	            function getKpiIcon(kpi, value) {
	                var numValue = parseFloat(value);
	                if (!kpi)
	                    return;
	                var statusGraphicFormat = statusGraphicFormatStrings[kpi.graphic.toUpperCase()];
	                if (!statusGraphicFormat || isNaN(numValue))
	                    return undefined;
	                var statusValues = statusGraphicFormat.statusValues;
	                // Normalize range of (-1, -0.5, 0, 0.5, 1) to (-2, -1, 0, 1, 2)
	                if (kpi.normalizedFiveStateKpiRange && statusValues.length === 5)
	                    numValue = numValue * 2;
	                // Convert values from the range of (-n/2, ..., 0, ..., n/2) to (0, 1, ..., n-1)
	                var num = numValue + Math.floor(statusValues.length / 2);
	                return [statusGraphicFormat.kpiIconClass, statusValues[num]].join(' ').trim();
	            }
	            function getKpiIconClassName(kpiIcon, kpiImageSize) {
	                if (!kpiIcon)
	                    return undefined;
	                if (kpiImageSize === 1 /* Big */)
	                    return [KPIImageClassName, BigImageClassName, kpiIcon].join(' ');
	                else
	                    return [KPIImageClassName, kpiIcon].join(' ');
	            }
	            function getClassForKpi(kpi, value, kpiImageSize) {
	                debug.assertValue(kpi, 'kpi');
	                debug.assertValue(value, 'value');
	                var kpiIcon = getKpiIcon(kpi, value);
	                return getKpiIconClassName(kpiIcon, kpiImageSize);
	            }
	            KpiUtil.getClassForKpi = getClassForKpi;
	            function getKpiImageMetadata(metaDataColumn, value, kpiImageSize) {
	                var kpi = metaDataColumn && metaDataColumn.kpi;
	                if (kpi) {
	                    var kpiIcon = getKpiIcon(kpi, value);
	                    if (kpiIcon) {
	                        return {
	                            caption: kpiIcon,
	                            statusGraphic: kpi.graphic,
	                            class: getKpiIconClassName(kpiIcon, kpiImageSize),
	                        };
	                    }
	                }
	            }
	            KpiUtil.getKpiImageMetadata = getKpiImageMetadata;
	        })(KpiUtil = visuals.KpiUtil || (visuals.KpiUtil = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 202 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var DateUtil;
	        (function (DateUtil) {
	            function isEqual(date1, date2) {
	                if (date1 == null && date2 == null) {
	                    return true;
	                }
	                else if (date1 == null || date2 == null) {
	                    return false;
	                }
	                return date1.getTime() === date2.getTime();
	            }
	            DateUtil.isEqual = isEqual;
	        })(DateUtil = visuals.DateUtil || (visuals.DateUtil = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 203 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var MinMaxType;
	        (function (MinMaxType) {
	            MinMaxType[MinMaxType["Minimum"] = 0] = "Minimum";
	            MinMaxType[MinMaxType["Maximum"] = 1] = "Maximum";
	            MinMaxType[MinMaxType["Neither"] = 2] = "Neither";
	        })(MinMaxType || (MinMaxType = {}));
	        var MinMaxLabelDataPointSorter = (function () {
	            function MinMaxLabelDataPointSorter(options) {
	                this.unsortedLabelDataPointGroups = options.unsortedLabelDataPointGroups;
	                this.series = options.series;
	                this.yScale = options.yAxisProperties.scale;
	                this.viewport = options.viewport;
	            }
	            MinMaxLabelDataPointSorter.prototype.getSortedDataLabels = function () {
	                var unsortedLabelDataPointGroups = this.unsortedLabelDataPointGroups;
	                var sortedLabelDataPointGroups = [];
	                for (var seriesIndex = 0, seriesCount = unsortedLabelDataPointGroups.length; seriesIndex < seriesCount; seriesIndex++) {
	                    var unsortedLabelDataPointGroup = unsortedLabelDataPointGroups[seriesIndex];
	                    var numberOfLabelsToSort = MinMaxLabelDataPointSorter.maxNumberToSortFactor * unsortedLabelDataPointGroup.maxNumberOfLabels;
	                    if (_.isEmpty(unsortedLabelDataPointGroup.labelDataPoints))
	                        continue;
	                    var unsortedLabelDataPoints = unsortedLabelDataPointGroup.labelDataPoints;
	                    var sortedLabelDataPoints = [];
	                    var data_1 = _.filter(this.series[seriesIndex].data, function (dataPoint) { return dataPoint.value != null; });
	                    // Iterate over the data points to find the min and max index and values
	                    var globalMinMaxInRange = MinMaxLabelDataPointSorter.getMinMaxInRange(0, data_1.length - 1, data_1);
	                    // Add first, last, max, and min
	                    var numberOfLabelsAdded = this.addFirstLastMaxMin(unsortedLabelDataPoints, sortedLabelDataPoints, globalMinMaxInRange.maxIndex, globalMinMaxInRange.minIndex);
	                    var unsortedWeightedLabelDataPoints = void 0;
	                    // If we have enough labels added, don't bother adding local min/maxes
	                    if (!(numberOfLabelsAdded >= numberOfLabelsToSort)) {
	                        // Prepare the data to calculate weights and find global min/max
	                        unsortedWeightedLabelDataPoints = this.calculateWeights(unsortedLabelDataPoints, data_1, numberOfLabelsToSort, globalMinMaxInRange);
	                        // Add all mins and maxes, sorted by weight (skipping first/last/min/max)
	                        var maximumnMinMaxesToAdd = Math.max(numberOfLabelsToSort - numberOfLabelsAdded, 0);
	                        numberOfLabelsAdded += this.addLocalMinMaxes(unsortedWeightedLabelDataPoints, sortedLabelDataPoints, globalMinMaxInRange.maxIndex, globalMinMaxInRange.minIndex, maximumnMinMaxesToAdd);
	                    }
	                    // If we have enough labels added, don't bother adding non-min/maxes
	                    if (!(numberOfLabelsAdded >= numberOfLabelsToSort)) {
	                        // Split the remaining array and add labels at the mid point of the largest sections until all labels
	                        //   are added or we've added maxNumber
	                        var maximumNonMinMaxesToAdd = Math.max(numberOfLabelsToSort - numberOfLabelsAdded, 0);
	                        this.addNonMinMaxes(unsortedWeightedLabelDataPoints, sortedLabelDataPoints, maximumNonMinMaxesToAdd);
	                    }
	                    sortedLabelDataPointGroups.push({ labelDataPoints: sortedLabelDataPoints, maxNumberOfLabels: unsortedLabelDataPointGroup.maxNumberOfLabels });
	                }
	                return sortedLabelDataPointGroups;
	            };
	            /**
	             * The weight for each min/max is made up of four values, which are averaged into
	             * a single weight.  You have a weight based on the value difference for both the
	             * left and right side and a weight for the index difference for both left and
	             * right.  These values are normalized as such:
	             *
	             * valueWeight = abs(scaledValueDifference / totalScaledValueDifference)
	             * indexWeight = abs(indexDifference / categoryCount)
	             *
	             * Since we don't care about the direction of these change, we take the absolute
	             * value for both.  We use scaled coordinates for the valueWeight because this
	             * will more accurately represent what the user sees (consider a log scale; small
	             * visual changes at the top would otherwise trump large visual changes at the
	             * bottom of the axis)
	             *
	             * In code, the averaging is done by averaging together the "current" value and
	             * index weights and then assigning it to the current dataPoint.  Then, when the
	             * "next" data point's weight is calculated, that weight (with respect to "current")
	             * is then averaged with the weight originally assigned.  Data points next to nulls
	             * or on the edge of the visual only have a weight associated with the one side that
	             * is non-null.
	             *
	             * Also note that weights are only calculated for minimums and maximums.
	             *
	             * @param labelDataPoints The labelDataPoints to apply the weighting to
	             */
	            MinMaxLabelDataPointSorter.prototype.calculateWeights = function (labelDataPoints, data, numberOfLabelsToSort, globalMinMax) {
	                var previousMinMaxPoint;
	                var currentMinMaxPoint;
	                var categoryCount = data.length;
	                var yScale = this.yScale;
	                // Obtain all maximums and minimums
	                var minMaxPoints = this.findMinMaxesBasedOnSmoothedValues(labelDataPoints, data);
	                // Iterate over the mins/maxes, calcuating the weight as you go.  "Current" weight is calcuated with
	                //   regard to previous, which is used for the "current" data point's left weight and the "previous"
	                //   data point's right weight.
	                var totalValueDifference = Math.abs(yScale(globalMinMax.maxValue) - yScale(globalMinMax.minValue));
	                for (var minMaxIndex = 0, minMaxCount = minMaxPoints.length; minMaxIndex < minMaxCount; minMaxIndex++) {
	                    currentMinMaxPoint = minMaxPoints[minMaxIndex];
	                    var weight = void 0;
	                    if (previousMinMaxPoint) {
	                        var valueWeight = Math.abs((yScale(previousMinMaxPoint.value) - yScale(currentMinMaxPoint.value)) / totalValueDifference);
	                        var indexWeight = Math.abs((previousMinMaxPoint.index - currentMinMaxPoint.index)) / (categoryCount - 1);
	                        weight = (valueWeight + indexWeight) / 2;
	                    } // Note: if there is no previous data point, do not calculate a weight because there is no left weight
	                    if (weight != null && previousMinMaxPoint) {
	                        var previousLabelDataPoint = labelDataPoints[previousMinMaxPoint.index];
	                        if (previousLabelDataPoint.weight != null) {
	                            // Previous has a left weight; average that with this weight which provides the right weight
	                            previousLabelDataPoint.weight = (previousLabelDataPoint.weight + weight) / 2;
	                        }
	                        else {
	                            // Previous has no left weight because it's the first of a line segment; just use the right weight
	                            previousLabelDataPoint.weight = weight;
	                        }
	                        // Current's left weight is set
	                        labelDataPoints[currentMinMaxPoint.index].weight = weight;
	                    } // Current's right weight will be applied by the next iteration unless it has none
	                    previousMinMaxPoint = currentMinMaxPoint;
	                }
	                // Cull min/maxes that are extremely low weight.
	                for (var _i = 0, labelDataPoints_1 = labelDataPoints; _i < labelDataPoints_1.length; _i++) {
	                    var labelDataPoint = labelDataPoints_1[_i];
	                    if (labelDataPoint.weight < MinMaxLabelDataPointSorter.minimumWeightToConsiderMinMax) {
	                        labelDataPoint.weight = undefined;
	                    }
	                }
	                return labelDataPoints;
	            };
	            MinMaxLabelDataPointSorter.prototype.findMinMaxesBasedOnSmoothedValues = function (labelDataPoints, data) {
	                var minMaxPoints = [];
	                var windowSize = this.getWindowSize(data);
	                var halfWindowSize = Math.floor(windowSize / 2);
	                var scaledSmoothedValues = this.calculateSmoothedValues(data, windowSize);
	                // Find mins and maxes based on the scaled and smooth values
	                for (var categoryIndex = 0, categoryCount = labelDataPoints.length; categoryIndex < categoryCount; categoryIndex++) {
	                    var minMaxType = this.getMinMaxType(categoryIndex, scaledSmoothedValues);
	                    if (minMaxType === MinMaxType.Neither)
	                        continue;
	                    var currentMinMaxPoint = {
	                        index: categoryIndex,
	                        type: minMaxType,
	                        value: data[categoryIndex].value,
	                    };
	                    minMaxPoints.push(currentMinMaxPoint);
	                }
	                // Adjust mins and maxes to be the actual mins/maxes based on the data, because the min/max of the smoothed values
	                //   may not be the actual min max in the data within the window, and we want to apply the weight to the actual min/max
	                var previousMinMax;
	                var currentMinMax;
	                var nextMinMax;
	                for (var minMaxIndex = 0, minMaxCount = minMaxPoints.length; minMaxIndex < minMaxCount; minMaxIndex++) {
	                    previousMinMax = minMaxPoints[minMaxIndex - 1];
	                    currentMinMax = minMaxPoints[minMaxIndex];
	                    nextMinMax = minMaxPoints[minMaxIndex + 1];
	                    if (!previousMinMax || !nextMinMax)
	                        continue;
	                    var actualMinMaxInRange = MinMaxLabelDataPointSorter.getMinMaxInRange(Math.max(previousMinMax.index, currentMinMax.index - halfWindowSize), Math.min(nextMinMax.index, currentMinMax.index + halfWindowSize), data);
	                    if (currentMinMax.type === MinMaxType.Maximum) {
	                        var actualIndex = actualMinMaxInRange.maxIndex;
	                        currentMinMax.index = actualIndex;
	                        currentMinMax.value = data[actualIndex].value;
	                    }
	                    else {
	                        var actualIndex = actualMinMaxInRange.minIndex;
	                        currentMinMax.index = actualIndex;
	                        currentMinMax.value = data[actualIndex].value;
	                    }
	                }
	                return minMaxPoints;
	            };
	            MinMaxLabelDataPointSorter.getMinMaxInRange = function (startIndex, endIndex, data) {
	                var minValue;
	                var maxValue;
	                var minIndex;
	                var maxIndex;
	                // Iterate over the data points to find the min and max index and values
	                for (var categoryIndex = startIndex, dataLength = data.length; categoryIndex <= endIndex && categoryIndex < dataLength; categoryIndex++) {
	                    var value = data[categoryIndex].value;
	                    if (value == null)
	                        continue;
	                    if (minValue === undefined || value < minValue) {
	                        minValue = value;
	                        minIndex = categoryIndex;
	                    }
	                    if (maxValue === undefined || value > maxValue) {
	                        maxValue = value;
	                        maxIndex = categoryIndex;
	                    }
	                }
	                return {
	                    minIndex: minIndex,
	                    minValue: minValue,
	                    maxIndex: maxIndex,
	                    maxValue: maxValue,
	                };
	            };
	            MinMaxLabelDataPointSorter.prototype.getWindowSize = function (data) {
	                var idealSize = (data.length / this.viewport.width) * MinMaxLabelDataPointSorter.estimatedLabelWidth;
	                var actualsize = Math.floor(idealSize / 2) * 2 + 1; // Force the window size to be a nearby odd number
	                return actualsize;
	            };
	            MinMaxLabelDataPointSorter.prototype.calculateSmoothedValues = function (data, windowSize) {
	                var gaussianValues = MinMaxLabelDataPointSorter.getGaussianDistribution(windowSize);
	                var scaledAndSmoothedValues = [];
	                for (var categoryIndex = 0, categoryCount = data.length; categoryIndex < categoryCount; categoryIndex++) {
	                    if (windowSize === 1) {
	                        scaledAndSmoothedValues.push(data[categoryIndex].value);
	                    }
	                    else {
	                        var scaledValue = this.getSmoothedValue(data, categoryIndex, windowSize, gaussianValues);
	                        scaledAndSmoothedValues.push(scaledValue);
	                    }
	                }
	                return scaledAndSmoothedValues;
	            };
	            MinMaxLabelDataPointSorter.getGaussianDistribution = function (windowSize) {
	                debug.assert(windowSize / 2 !== Math.floor(windowSize / 2), "window size should be a whole odd number");
	                var gaussianDistribution = [];
	                var halfWayIndex = Math.floor(windowSize / 2); // Value at which, value should be 1.
	                // Standard gaussian equation:
	                //   y = a * e ^ -((x-b)^2 / (2c^2))
	                //   height: 1 (height at the maximum)
	                //   maxPosition: 1 (position of maximum)
	                //   standardDeviation: 0.5 (standard deviation; this ratio places the edge of the window around 0.1)
	                var height = 1;
	                var maxPosition = halfWayIndex;
	                var standardDeviation = halfWayIndex / 2;
	                for (var i = 0; i < halfWayIndex; i++) {
	                    var gaussianValue = height * Math.pow(Math.E, (-1 * ((i - maxPosition) * (i - maxPosition)) / (2 * standardDeviation * standardDeviation)));
	                    gaussianDistribution.push(gaussianValue);
	                }
	                gaussianDistribution.push(1); // Add the maximum, which should always be 1
	                for (var i = halfWayIndex - 1; i >= 0; i--) {
	                    gaussianDistribution.push(gaussianDistribution[i]);
	                }
	                return gaussianDistribution;
	            };
	            MinMaxLabelDataPointSorter.prototype.getSmoothedValue = function (data, categoryIndex, windowSize, gaussianValues) {
	                if (data[categoryIndex].value == null)
	                    return data[categoryIndex].value;
	                var halfWindowSize = Math.floor(windowSize / 2);
	                var startingIndex = categoryIndex - halfWindowSize;
	                var endingIndex = categoryIndex + halfWindowSize;
	                var totalValue = 0;
	                var totalValueCount = 0;
	                var lastDataIndex = data.length - 1;
	                for (var currentIndex = startingIndex, gaussianIndex = 0; currentIndex <= endingIndex; currentIndex++, gaussianIndex++) {
	                    var valueIndex = Math.max(0, Math.min(currentIndex, lastDataIndex));
	                    var value = data[valueIndex].value;
	                    if (value != null) {
	                        totalValue += value * gaussianValues[gaussianIndex];
	                        totalValueCount++;
	                    }
	                }
	                return totalValue / totalValueCount;
	            };
	            MinMaxLabelDataPointSorter.prototype.addFirstLastMaxMin = function (unsorted, sorted, maxIndex, minIndex) {
	                var labelsAdded = 0;
	                // Don't add anything if unsorted is empty
	                if (_.isEmpty(unsorted))
	                    return labelsAdded;
	                // Push first
	                sorted.push(unsorted[0]);
	                labelsAdded++;
	                // Push last only last != first
	                var lastIndex = unsorted.length - 1;
	                if (lastIndex !== 0) {
	                    sorted.push(unsorted[lastIndex]);
	                    labelsAdded++;
	                }
	                // Push max if it is neither first nor last
	                if (maxIndex !== 0 && maxIndex !== lastIndex) {
	                    sorted.push(unsorted[maxIndex]);
	                    labelsAdded++;
	                }
	                // Push min if it is neither first nor last
	                if (minIndex !== 0 && minIndex !== lastIndex) {
	                    sorted.push(unsorted[minIndex]);
	                    labelsAdded++;
	                }
	                return labelsAdded;
	            };
	            MinMaxLabelDataPointSorter.prototype.addLocalMinMaxes = function (unsorted, sorted, maxIndex, minIndex, maxNumberOfLabels) {
	                var lastIndex = unsorted.length - 1;
	                // Obtain all local min/maxes; all min/maxes should have weights now and we filter out first/last/max/min
	                var localMinMaxes = _.filter(unsorted, function (labelDataPoint, index) {
	                    if (index === 0 || index === lastIndex || index === maxIndex || index === minIndex) {
	                        return false;
	                    }
	                    return labelDataPoint.weight != null;
	                });
	                var sortedMinMaxes = _.sortBy(localMinMaxes, function (weighedLabelDataPoint) {
	                    return -weighedLabelDataPoint.weight; // Return weight as a negative since _.sortBy sorts ascending, and we want descending
	                });
	                var labelsAdded = 0;
	                // Add labels until you run out of max/mins or you've sorted enough labels
	                for (var i = 0, ilen = Math.min(sortedMinMaxes.length, maxNumberOfLabels); i < ilen; i++) {
	                    sorted.push(sortedMinMaxes[i]);
	                    labelsAdded++;
	                }
	                return labelsAdded;
	            };
	            MinMaxLabelDataPointSorter.prototype.addNonMinMaxes = function (unsorted, sorted, maxNumberOfLabels) {
	                // First construct sets of non-min/maxes by iterating over the unsorted data points.
	                var nonMinMaxSets = [];
	                var currentNonMinMaxSet;
	                for (var categoryIndex = 0, categoryCount = unsorted.length; categoryIndex < categoryCount; categoryIndex++) {
	                    if (unsorted[categoryIndex].weight != null) {
	                        // If the current data point is a min/max, we add the old NonMinMaxSet to the array, reset it so that
	                        //   a new one will be constructed, and then continue
	                        if (currentNonMinMaxSet && currentNonMinMaxSet.count > 0) {
	                            nonMinMaxSets.push(currentNonMinMaxSet);
	                            currentNonMinMaxSet = null;
	                        }
	                        continue;
	                    }
	                    if (!currentNonMinMaxSet) {
	                        // If the previous data point was a min/max and this one isn't, set up a new NonMinMaxSet
	                        currentNonMinMaxSet = {
	                            startingIndex: categoryIndex,
	                            count: 1,
	                        };
	                    }
	                    else {
	                        // Otherwise, we're just "adding" another non-min/max point to the set, so increase count.
	                        currentNonMinMaxSet.count++;
	                    }
	                }
	                var numberOfLabelsAdded = 0;
	                while (nonMinMaxSets.length > 0 && numberOfLabelsAdded < maxNumberOfLabels) {
	                    // Find the index of the largest set
	                    var currentMaxCount = 0;
	                    var maxIndex = 0;
	                    for (var i = 0, ilen = nonMinMaxSets.length; i < ilen; i++) {
	                        var currentCount = nonMinMaxSets[i].count;
	                        if (currentCount > currentMaxCount) {
	                            currentMaxCount = currentCount;
	                            maxIndex = i;
	                        }
	                    }
	                    var setToSplit = nonMinMaxSets.splice(maxIndex, 1)[0];
	                    if (setToSplit.count === 1) {
	                        sorted.push(unsorted[setToSplit.startingIndex]);
	                    }
	                    else {
	                        var splitIndex = Math.floor(setToSplit.count / 2) + setToSplit.startingIndex;
	                        // Split the array in two, putting the split point into sorted, and creating two new sets by splitting the old set
	                        sorted.push(unsorted[splitIndex]);
	                        var leftCount = splitIndex - setToSplit.startingIndex;
	                        if (leftCount > 0) {
	                            nonMinMaxSets.push({
	                                startingIndex: setToSplit.startingIndex,
	                                count: leftCount,
	                            });
	                        }
	                        var rightCount = setToSplit.startingIndex + setToSplit.count - splitIndex - 1;
	                        if (rightCount > 0) {
	                            nonMinMaxSets.push({
	                                startingIndex: splitIndex + 1,
	                                count: rightCount,
	                            });
	                        }
	                    }
	                    numberOfLabelsAdded++;
	                }
	            };
	            MinMaxLabelDataPointSorter.prototype.getMinMaxType = function (index, scaledDataPoints) {
	                var currentValue = scaledDataPoints[index];
	                // Check to see if the point's value is null; these are not considered min/maxes
	                if (scaledDataPoints[index] == null)
	                    return MinMaxType.Neither;
	                // If the array is of length one, return neither to exit early
	                if (scaledDataPoints.length < 2)
	                    return MinMaxType.Neither;
	                // Check for cases at the very edge of the array
	                if (scaledDataPoints[index - 1] == null) {
	                    return scaledDataPoints[index + 1] > currentValue ? MinMaxType.Minimum : MinMaxType.Maximum;
	                }
	                if (scaledDataPoints[index + 1] == null) {
	                    return scaledDataPoints[index - 1] > currentValue ? MinMaxType.Minimum : MinMaxType.Maximum;
	                }
	                var prevValue = scaledDataPoints[index - 1];
	                var nextValue = scaledDataPoints[index + 1];
	                // Check for cases next to nulls
	                if (prevValue == null && nextValue == null) {
	                    return MinMaxType.Neither;
	                }
	                if (prevValue == null) {
	                    return nextValue > currentValue ? MinMaxType.Minimum : MinMaxType.Maximum;
	                }
	                if (nextValue == null) {
	                    return prevValue > currentValue ? MinMaxType.Minimum : MinMaxType.Maximum;
	                }
	                // Check for typical min/maxes
	                if (prevValue > currentValue && currentValue < nextValue) {
	                    return MinMaxType.Minimum;
	                }
	                if (prevValue < currentValue && currentValue > nextValue) {
	                    return MinMaxType.Maximum;
	                }
	                return MinMaxType.Neither;
	            };
	            /** A rough estimate for how wide labels are for purposes of calculating density, window size, etc. */
	            MinMaxLabelDataPointSorter.estimatedLabelWidth = 40;
	            MinMaxLabelDataPointSorter.minimumWeightToConsiderMinMax = 0.015;
	            MinMaxLabelDataPointSorter.maxNumberToSortFactor = 2; // Once we've sorted first/last/min/max and local max/mins, we limit ourselves to twice the maximum number of labels to render
	            return MinMaxLabelDataPointSorter;
	        }());
	        visuals.MinMaxLabelDataPointSorter = MinMaxLabelDataPointSorter;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 204 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var ReferenceLineHelper;
	        (function (ReferenceLineHelper) {
	            ReferenceLineHelper.referenceLineProps = {
	                show: 'show',
	                displayName: 'displayName',
	                lineColor: 'lineColor',
	                transparency: 'transparency',
	                value: 'value',
	                style: 'style',
	                position: 'position',
	                dataLabelShow: 'dataLabelShow',
	                dataLabelColor: 'dataLabelColor',
	                dataLabelDecimalPoints: 'dataLabelDecimalPoints',
	                dataLabelHorizontalPosition: 'dataLabelHorizontalPosition',
	                dataLabelVerticalPosition: 'dataLabelVerticalPosition',
	                dataLabelDisplayUnits: 'dataLabelDisplayUnits',
	            };
	            function enumerateObjectInstances(enumeration, referenceLines, defaultColor, objectName) {
	                debug.assertValue(enumeration, 'enumeration');
	                if (_.isEmpty(referenceLines)) {
	                    // NOTE: We do not currently have support for object maps in the property pane. For now we will generate a single reference line 
	                    // object that the format pane can handle.In the future we will need property pane support for multiple reference lines. Also, we're
	                    // assuming that the user-defined IDs will be numeric strings, this may change in the future and will likley be controlled by the property pane.
	                    var instance = {
	                        selector: {
	                            id: '0'
	                        },
	                        properties: {
	                            show: false,
	                            value: '',
	                            lineColor: { solid: { color: defaultColor } },
	                            transparency: 50,
	                            style: visuals.lineStyle.dashed,
	                            position: visuals.referenceLinePosition.back,
	                            dataLabelShow: false,
	                        },
	                        objectName: objectName
	                    };
	                    enumeration.pushInstance(instance);
	                    return;
	                }
	                for (var _i = 0, referenceLines_1 = referenceLines; _i < referenceLines_1.length; _i++) {
	                    var referenceLine = referenceLines_1[_i];
	                    var referenceLineProperties = referenceLine.object;
	                    var show = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.show, false);
	                    var displayName = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.displayName);
	                    var value = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.value);
	                    var lineColor = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.lineColor, { solid: { color: defaultColor } });
	                    var transparency = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.transparency, 50);
	                    var style = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.style, visuals.lineStyle.dashed);
	                    var position = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.position, visuals.referenceLinePosition.back);
	                    var dataLabelShow = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelShow, false);
	                    var instance = {
	                        selector: {
	                            id: referenceLine.id
	                        },
	                        properties: {
	                            show: show,
	                            displayName: displayName,
	                            value: value,
	                            lineColor: lineColor,
	                            transparency: transparency,
	                            style: style,
	                            position: position,
	                            dataLabelShow: dataLabelShow,
	                        },
	                        objectName: objectName
	                    };
	                    // Show the data label properties only if the user chose to show the data label
	                    if (dataLabelShow) {
	                        var dataLabelColor = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelColor, { solid: { color: defaultColor } });
	                        var dataLabelHorizontalPosition = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelHorizontalPosition, visuals.referenceLineDataLabelHorizontalPosition.left);
	                        var dataLabelVerticalPosition = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelVerticalPosition, visuals.referenceLineDataLabelVerticalPosition.above);
	                        var dataLabelDecimalPoints = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelDecimalPoints, undefined) < 0
	                            ? undefined
	                            : powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelDecimalPoints, undefined);
	                        var dataLabelDisplayUnits = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelDisplayUnits, 0);
	                        instance.properties[ReferenceLineHelper.referenceLineProps.dataLabelColor] = dataLabelColor;
	                        instance.properties[ReferenceLineHelper.referenceLineProps.dataLabelHorizontalPosition] = dataLabelHorizontalPosition;
	                        instance.properties[ReferenceLineHelper.referenceLineProps.dataLabelVerticalPosition] = dataLabelVerticalPosition;
	                        instance.properties[ReferenceLineHelper.referenceLineProps.dataLabelDisplayUnits] = dataLabelDisplayUnits;
	                        instance.properties[ReferenceLineHelper.referenceLineProps.dataLabelDecimalPoints] = dataLabelDecimalPoints;
	                    }
	                    enumeration.pushInstance(instance);
	                }
	            }
	            ReferenceLineHelper.enumerateObjectInstances = enumerateObjectInstances;
	            function render(options) {
	                var graphicContext = options.graphicContext;
	                var axes = options.axes;
	                var referenceLineProperties = options.referenceLineProperties;
	                var isHorizontal = options.isHorizontal;
	                var viewport = options.viewport;
	                var classAndSelector = options.classAndSelector;
	                var xScale = axes.x.scale;
	                var yScale = axes.y1.scale;
	                var refValue = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.value, 0);
	                var lineColor = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.lineColor, { solid: { color: options.defaultColor } });
	                var transparency = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.transparency);
	                var style = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.style, visuals.lineStyle.dashed);
	                var position = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.position, visuals.referenceLinePosition.back);
	                var refLine = graphicContext.select(classAndSelector.selector);
	                var index = $(refLine[0]).index();
	                var isRefLineExists = index !== -1;
	                var isPositionChanged = true;
	                if (isRefLineExists) {
	                    var lastIndex = $(refLine[0]).siblings().length;
	                    if (position === visuals.referenceLinePosition.back && index === 0)
	                        isPositionChanged = false;
	                    else if (position === visuals.referenceLinePosition.front && index === lastIndex)
	                        isPositionChanged = false;
	                }
	                if (isRefLineExists && isPositionChanged)
	                    refLine.remove();
	                if (!isRefLineExists || isPositionChanged)
	                    refLine = (position === visuals.referenceLinePosition.back) ? graphicContext.insert('line', ":first-child") : graphicContext.append('line');
	                var refLineX1 = isHorizontal ? 0 : xScale(refValue);
	                var refLineY1 = isHorizontal ? yScale(refValue) : 0;
	                var refLineX2 = isHorizontal ? viewport.width : xScale(refValue);
	                var refLineY2 = isHorizontal ? yScale(refValue) : viewport.height;
	                refLine.attr({
	                    'class': classAndSelector.class,
	                    x1: refLineX1,
	                    y1: refLineY1,
	                    x2: refLineX2,
	                    y2: refLineY2,
	                })
	                    .style({
	                    'stroke': lineColor.solid.color,
	                });
	                if (transparency != null)
	                    refLine.style('stroke-opacity', ((100 - transparency) / 100));
	                if (style === visuals.lineStyle.dashed) {
	                    refLine.style('stroke-dasharray', ("5, 5"));
	                }
	                else if (style === visuals.lineStyle.dotted) {
	                    refLine.style({
	                        'stroke-dasharray': ("1, 5"),
	                        'stroke-linecap': "round"
	                    });
	                }
	                else if (style === visuals.lineStyle.solid) {
	                    refLine.style({
	                        'stroke-dasharray': null,
	                        'stroke-linecap': null
	                    });
	                }
	            }
	            ReferenceLineHelper.render = render;
	            function createLabelDataPoint(options) {
	                var offsetRefLine = 5;
	                var axes = options.axes;
	                var referenceLineProperties = options.referenceLineProperties;
	                var isHorizontal = options.isHorizontal;
	                var viewport = options.viewport;
	                var xScale = axes.x.scale;
	                var yScale = axes.y1.scale;
	                // Get the data label properties                
	                var refValue = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.value, 0);
	                var color = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelColor, { solid: { color: options.defaultColor } });
	                var decimalPoints = (referenceLineProperties[ReferenceLineHelper.referenceLineProps.dataLabelDecimalPoints] < 0 ? undefined : referenceLineProperties[ReferenceLineHelper.referenceLineProps.dataLabelDecimalPoints]);
	                var horizontalPosition = referenceLineProperties[ReferenceLineHelper.referenceLineProps.dataLabelHorizontalPosition] || visuals.referenceLineDataLabelHorizontalPosition.left;
	                var verticalPosition = referenceLineProperties[ReferenceLineHelper.referenceLineProps.dataLabelVerticalPosition] || visuals.referenceLineDataLabelVerticalPosition.above;
	                var displayUnits = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelDisplayUnits, 0);
	                // Format the reference line data label text according to the matching axis formatter
	                // When options is null default formatter is used either boolean, numeric, or text
	                var axisFormatter = isHorizontal ? axes.y1.formatter : axes.x.formatter;
	                var formatterForReferenceLineDataLabel = axisFormatter;
	                if (axisFormatter.options != null) {
	                    var formatterOptions = powerbi.Prototype.inherit(axisFormatter.options);
	                    formatterOptions.precision = decimalPoints;
	                    formatterOptions.value = displayUnits;
	                    formatterOptions.detectAxisPrecision = false;
	                    formatterForReferenceLineDataLabel = visuals.valueFormatter.create(formatterOptions);
	                }
	                var text = visuals.NewDataLabelUtils.getLabelFormattedText(formatterForReferenceLineDataLabel.format(refValue));
	                var properties = {
	                    text: text,
	                    fontFamily: visuals.dataLabelUtils.LabelTextProperties.fontFamily,
	                    fontSize: visuals.dataLabelUtils.LabelTextProperties.fontSize,
	                    fontWeight: visuals.dataLabelUtils.LabelTextProperties.fontWeight,
	                };
	                // Get the height and with of the text element that will be created in order to place it correctly
	                var rectWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
	                var rectHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
	                var dataLabelX;
	                var dataLabelY;
	                var x1 = isHorizontal ? 0 : xScale(refValue);
	                var y1 = isHorizontal ? yScale(refValue) : 0;
	                var x2 = isHorizontal ? viewport.width : xScale(refValue);
	                var y2 = isHorizontal ? yScale(refValue) : viewport.height;
	                var validPositions = [1 /* Above */];
	                if (isHorizontal) {
	                    // Horizontal line. y1 = y2
	                    dataLabelX = (horizontalPosition === visuals.referenceLineDataLabelHorizontalPosition.left) ? x1 + offsetRefLine : x2 - (rectWidth / 2) - offsetRefLine;
	                    dataLabelY = y1;
	                    validPositions = (verticalPosition === visuals.referenceLineDataLabelVerticalPosition.above) ? [1 /* Above */] : [2 /* Below */];
	                }
	                else {
	                    // Vertical line. x1 = x2 
	                    dataLabelX = x1;
	                    dataLabelY = (verticalPosition === visuals.referenceLineDataLabelVerticalPosition.above) ? y1 + (rectHeight / 2) + offsetRefLine : y2 - (rectHeight / 2) - offsetRefLine;
	                    validPositions = (horizontalPosition === visuals.referenceLineDataLabelHorizontalPosition.left) ? [4 /* Left */] : [8 /* Right */];
	                }
	                var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
	                var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, true /* tightFitForNumeric */);
	                var parentShape;
	                parentShape = {
	                    point: {
	                        x: dataLabelX,
	                        y: dataLabelY,
	                    },
	                    radius: 0,
	                    validPositions: validPositions,
	                };
	                return {
	                    isPreferred: true,
	                    text: text,
	                    textSize: {
	                        width: textWidth,
	                        height: textHeight,
	                    },
	                    outsideFill: color.solid.color,
	                    insideFill: null,
	                    parentShape: parentShape,
	                    parentType: 0 /* Point */,
	                    fontSize: 9,
	                    identity: null,
	                    secondRowText: null,
	                    key: options.key,
	                };
	            }
	            ReferenceLineHelper.createLabelDataPoint = createLabelDataPoint;
	            function extractReferenceLineValue(referenceLineProperties) {
	                var referenceLineValue = null;
	                if (referenceLineProperties && powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.show, false))
	                    referenceLineValue = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.value, null);
	                return referenceLineValue;
	            }
	            ReferenceLineHelper.extractReferenceLineValue = extractReferenceLineValue;
	        })(ReferenceLineHelper = visuals.ReferenceLineHelper || (visuals.ReferenceLineHelper = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 205 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var InteractivityUtils;
	        (function (InteractivityUtils) {
	            function getPositionOfLastInputEvent() {
	                return {
	                    x: d3.event.clientX,
	                    y: d3.event.clientY
	                };
	            }
	            InteractivityUtils.getPositionOfLastInputEvent = getPositionOfLastInputEvent;
	            function registerStandardInteractivityHandlers(selection, selectionHandler) {
	                registerStandardSelectionHandler(selection, selectionHandler);
	                registerStandardContextMenuHandler(selection, selectionHandler);
	            }
	            InteractivityUtils.registerStandardInteractivityHandlers = registerStandardInteractivityHandlers;
	            function registerStandardSelectionHandler(selection, selectionHandler) {
	                selection.on('click', function (d) { return handleSelection(d, selectionHandler); });
	            }
	            InteractivityUtils.registerStandardSelectionHandler = registerStandardSelectionHandler;
	            function registerStandardContextMenuHandler(selection, selectionHandler) {
	                selection.on('contextmenu', function (d) { return handleContextMenu(d, selectionHandler); });
	            }
	            InteractivityUtils.registerStandardContextMenuHandler = registerStandardContextMenuHandler;
	            function registerGroupInteractivityHandlers(group, selectionHandler) {
	                registerGroupSelectionHandler(group, selectionHandler);
	                registerGroupContextMenuHandler(group, selectionHandler);
	            }
	            InteractivityUtils.registerGroupInteractivityHandlers = registerGroupInteractivityHandlers;
	            function registerGroupSelectionHandler(group, selectionHandler) {
	                group.on('click', function () {
	                    var target = d3.event.target;
	                    var d = d3.select(target).datum();
	                    handleSelection(d, selectionHandler);
	                });
	            }
	            InteractivityUtils.registerGroupSelectionHandler = registerGroupSelectionHandler;
	            function registerGroupContextMenuHandler(group, selectionHandler) {
	                group.on('contextmenu', function () {
	                    var target = d3.event.target;
	                    var d = d3.select(target).datum();
	                    handleContextMenu(d, selectionHandler);
	                });
	            }
	            InteractivityUtils.registerGroupContextMenuHandler = registerGroupContextMenuHandler;
	            function handleContextMenu(d, selectionHandler) {
	                if (d3.event.ctrlKey)
	                    return;
	                d3.event.preventDefault();
	                var position = InteractivityUtils.getPositionOfLastInputEvent();
	                selectionHandler.handleContextMenu(d, position);
	            }
	            function handleSelection(d, selectionHandler) {
	                selectionHandler.handleSelection(d, d3.event.ctrlKey);
	            }
	        })(InteractivityUtils = visuals.InteractivityUtils || (visuals.InteractivityUtils = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 206 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        function getInvalidValueWarnings(dataViews, supportsNaN, supportsNegativeInfinity, supportsPositiveInfinity) {
	            var checker = new InvalidDataValuesChecker(supportsNaN /*supportsNaN*/, supportsNegativeInfinity /*supportsNegativeInfinity*/, supportsPositiveInfinity /*supportsPositiveInfinity*/);
	            // Show a warning if necessary.
	            return checker.getWarningMessages(dataViews);
	        }
	        visuals.getInvalidValueWarnings = getInvalidValueWarnings;
	        var InvalidDataValuesChecker = (function () {
	            function InvalidDataValuesChecker(supportsNaN, supportsNegativeInfinity, supportsPositiveInfinity) {
	                this.supportsNaN = supportsNaN;
	                this.supportsNegativeInfinity = supportsNegativeInfinity;
	                this.supportsPositiveInfinity = supportsPositiveInfinity;
	            }
	            InvalidDataValuesChecker.prototype.getWarningMessages = function (dataViews) {
	                this.loadWarningStatus(dataViews);
	                var warnings = [];
	                if (this.hasNaN && !this.supportsNaN) {
	                    warnings.push(new visuals.NaNNotSupportedWarning());
	                }
	                if ((this.hasNegativeInfinity && !this.supportsNegativeInfinity)
	                    || (this.hasPositiveInfinity && !this.supportsPositiveInfinity)) {
	                    warnings.push(new visuals.InfinityValuesNotSupportedWarning());
	                }
	                if (this.hasOutOfRange) {
	                    warnings.push(new visuals.ValuesOutOfRangeWarning());
	                }
	                return warnings;
	            };
	            InvalidDataValuesChecker.prototype.loadWarningStatus = function (dataViews) {
	                this.hasNaN = false;
	                this.hasNegativeInfinity = false;
	                this.hasOutOfRange = false;
	                this.hasPositiveInfinity = false;
	                for (var k = 0; k < dataViews.length; k++) {
	                    var dataView = dataViews[k];
	                    var values = dataView && dataView.categorical && dataView.categorical.values
	                        ? dataView.categorical.values
	                        : null;
	                    if (!values)
	                        return;
	                    var valueLength = values.length;
	                    for (var i = 0; i < valueLength; i++) {
	                        var value = values[i];
	                        if (value.values) {
	                            var valueValueLength = value.values.length;
	                            for (var j = 0; j < valueValueLength; j++) {
	                                var v = value.values[j];
	                                if (isNaN(v))
	                                    this.hasNaN = true;
	                                else if (v === Number.POSITIVE_INFINITY)
	                                    this.hasPositiveInfinity = true;
	                                else if (v === Number.NEGATIVE_INFINITY)
	                                    this.hasNegativeInfinity = true;
	                                else if (v < -1e300 || v > 1e300)
	                                    this.hasOutOfRange = true;
	                            }
	                        }
	                    }
	                }
	            };
	            return InvalidDataValuesChecker;
	        }());
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 207 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var ListViewFactory;
	        (function (ListViewFactory) {
	            function createListView(options) {
	                return new ListView(options);
	            }
	            ListViewFactory.createListView = createListView;
	        })(ListViewFactory = visuals.ListViewFactory || (visuals.ListViewFactory = {}));
	        /**
	         * A UI Virtualized List, that uses the D3 Enter, Update & Exit pattern to update rows.
	         * It can create lists containing either HTML or SVG elements.
	         */
	        var ListView = (function () {
	            function ListView(options) {
	                var _this = this;
	                // make a copy of options so that it is not modified later by caller
	                this.options = $.extend(true, {}, options);
	                this.scrollbarInner = options.baseContainer
	                    .append('div')
	                    .classed('scrollbar-inner', true)
	                    .on('scroll', function () { return _this.renderImpl(_this.options.rowHeight); });
	                this.scrollContainer = this.scrollbarInner
	                    .append('div')
	                    .classed('scrollRegion', true)
	                    .on('touchstart', function () { return _this.stopTouchPropagation(); })
	                    .on('touchmove', function () { return _this.stopTouchPropagation(); });
	                this.visibleGroupContainer = this.scrollContainer
	                    .append('div')
	                    .classed('visibleGroup', true);
	                $(options.baseContainer.node()).find('.scroll-element').attr('drag-resize-disabled', 'true');
	                ListView.SetDefaultOptions(options);
	            }
	            ListView.SetDefaultOptions = function (options) {
	                options.rowHeight = options.rowHeight || ListView.defaultRowHeight;
	            };
	            ListView.prototype.rowHeight = function (rowHeight) {
	                this.options.rowHeight = Math.ceil(rowHeight);
	                return this;
	            };
	            ListView.prototype.data = function (data, getDatumIndex, dataReset) {
	                if (dataReset === void 0) { dataReset = false; }
	                this._data = data;
	                this.getDatumIndex = getDatumIndex;
	                this.setTotalRows();
	                if (dataReset)
	                    $(this.scrollbarInner.node()).scrollTop(0);
	                this.render();
	                return this;
	            };
	            ListView.prototype.viewport = function (viewport) {
	                this.options.viewport = viewport;
	                this.render();
	                return this;
	            };
	            ListView.prototype.empty = function () {
	                this._data = [];
	                this.render();
	            };
	            ListView.prototype.render = function () {
	                var _this = this;
	                if (this.renderTimeoutId)
	                    window.clearTimeout(this.renderTimeoutId);
	                this.renderTimeoutId = window.setTimeout(function () {
	                    _this.getRowHeight().then(function (rowHeight) {
	                        _this.renderImpl(rowHeight);
	                    });
	                    _this.renderTimeoutId = undefined;
	                }, 0);
	            };
	            ListView.prototype.renderImpl = function (rowHeight) {
	                var totalHeight = this.options.scrollEnabled ? Math.max(0, (this._totalRows * rowHeight)) : this.options.viewport.height;
	                this.scrollContainer
	                    .style('height', totalHeight + "px")
	                    .attr('height', totalHeight);
	                this.scrollToFrame(true /*loadMoreData*/);
	            };
	            /*
	             *  This method is called in order to prevent a bug found in the Interact.js.
	             *  The bug is caused when finishing a scroll outside the scroll area.
	             *  In that case the Interact doesn't process a touchcancel event and thinks a touch point still exists.
	             *  since the Interact listens on the visualContainer, by stoping the propagation we prevent the bug from taking place.
	             */
	            ListView.prototype.stopTouchPropagation = function () {
	                //Stop the propagation only in read mode so the drag won't be affected.
	                if (this.options.isReadMode()) {
	                    if (d3.event.type === "touchstart") {
	                        var event_1 = d3.event;
	                        //If there is another touch point outside this visual than the event should be propagated.
	                        //This way the pinch to zoom will not be affected.
	                        if (event_1.touches && event_1.touches.length === 1) {
	                            d3.event.stopPropagation();
	                        }
	                    }
	                    if (d3.event.type === "touchmove") {
	                        d3.event.stopPropagation();
	                    }
	                }
	            };
	            ListView.prototype.scrollToFrame = function (loadMoreData) {
	                var options = this.options;
	                var visibleGroupContainer = this.visibleGroupContainer;
	                var totalRows = this._totalRows;
	                var rowHeight = options.rowHeight || ListView.defaultRowHeight;
	                var visibleRows = this.getVisibleRows();
	                var scrollTop = this.scrollbarInner.node().scrollTop;
	                var scrollPosition = (scrollTop === 0) ? 0 : Math.floor(scrollTop / rowHeight);
	                var transformAttr = visuals.SVGUtil.translateWithPixels(0, scrollPosition * rowHeight);
	                visibleGroupContainer.style({
	                    //order matters for proper overriding
	                    'transform': function (d) { return transformAttr; },
	                    '-webkit-transform': transformAttr
	                });
	                var position0 = Math.max(0, Math.min(scrollPosition, totalRows - visibleRows + 1)), position1 = position0 + visibleRows;
	                var rowSelection = visibleGroupContainer.selectAll(".row")
	                    .data(this._data.slice(position0, Math.min(position1, totalRows)), this.getDatumIndex);
	                rowSelection
	                    .enter()
	                    .append('div')
	                    .classed('row', true)
	                    .call(function (d) { return options.enter(d); });
	                rowSelection.order();
	                var rowUpdateSelection = visibleGroupContainer.selectAll('.row:not(.transitioning)');
	                rowUpdateSelection.call(function (d) { return options.update(d); });
	                rowSelection
	                    .exit()
	                    .call(function (d) { return options.exit(d); })
	                    .remove();
	                if (loadMoreData && visibleRows !== totalRows && position1 >= totalRows * ListView.loadMoreDataThreshold)
	                    options.loadMoreData();
	            };
	            ListView.prototype.setTotalRows = function () {
	                var data = this._data;
	                this._totalRows = data ? data.length : 0;
	            };
	            ListView.prototype.getVisibleRows = function () {
	                var minimumVisibleRows = 1;
	                var options = this.options;
	                var rowHeight = options.rowHeight;
	                var viewportHeight = options.viewport.height;
	                if (!rowHeight || rowHeight < 1)
	                    return minimumVisibleRows;
	                // How many rows of space the viewport can hold (not the number of rows it can display).
	                var viewportRowCount = viewportHeight / rowHeight;
	                if (this.options.scrollEnabled) {
	                    // Ceiling the count since we can have items be partially displayed when scrolling.
	                    // Add 1 to make sure we always render enough rows to cover the entire viewport (handles when rows are partially visible when scrolling).
	                    // Ex. If you have a viewport that can show 280 (viewport height) / 100 (row height) = 2.8 rows, you need to have up to Math.ceil(2.8) + 1 = 4 rows of data to cover the viewport.
	                    // If you only had Math.ceil(2.8) = 3 rows of data, and the top rows was 50% visible (scrolled up), you'd only be able to cover .5 + 1 + 1 = 2.5 rows of the viewport.
	                    // This makes a gap at the bottom of the listview.
	                    // Add an extra row of data and we can cover .5 + 1 + 1 + 1 = 3.5 rows of the viewport. 3.5 is enough to cover the entire viewport as only 2.8 is needed.
	                    // 1 is always added, even if not needed, to keep logic simple. Advanced logic would figure out what % of the top row is visible and use that to add 1 if needed.
	                    return Math.min(Math.ceil(viewportRowCount) + 1, this._totalRows) || minimumVisibleRows;
	                }
	                // Floor the count since that's the maximum number of entire rows we can display without scrolling.
	                return Math.min(Math.floor(viewportRowCount), this._totalRows) || minimumVisibleRows;
	            };
	            ListView.prototype.getRowHeight = function () {
	                var deferred = $.Deferred();
	                var listView = this;
	                var options = listView.options;
	                if (this.cancelMeasurePass)
	                    this.cancelMeasurePass();
	                // if there is no data, resolve and return
	                if (!(this._data && this._data.length && options)) {
	                    listView.rowHeight(ListView.defaultRowHeight);
	                    return deferred.resolve(options.rowHeight).promise();
	                }
	                //render the first item to calculate the row height
	                this.scrollToFrame(false /*loadMoreData*/);
	                var requestAnimationFrameId = window.requestAnimationFrame(function () {
	                    //measure row height
	                    var rows = listView.visibleGroupContainer.select(".row");
	                    if (!rows.empty()) {
	                        var firstRow = rows.node();
	                        // If the container (child) has margins amd the row (parent) doesn't, the child's margins will collapse into the parent.
	                        // outerHeight doesn't report the correct height for the parent in this case, but it does measure the child properly.
	                        // Fix for #7497261 Measures both and take the max to work around this issue.
	                        var rowHeight = Math.max($(firstRow).outerHeight(true), $(firstRow).children().first().outerHeight(true));
	                        listView.rowHeight(rowHeight);
	                        deferred.resolve(rowHeight);
	                    }
	                    listView.cancelMeasurePass = undefined;
	                    window.cancelAnimationFrame(requestAnimationFrameId);
	                });
	                this.cancelMeasurePass = function () {
	                    window.cancelAnimationFrame(requestAnimationFrameId);
	                    deferred.reject();
	                };
	                return deferred.promise();
	            };
	            /**
	             * The value indicates the percentage of data already shown
	             * in the list view that triggers a loadMoreData call.
	             */
	            ListView.loadMoreDataThreshold = 0.8;
	            ListView.defaultRowHeight = 1;
	            return ListView;
	        }());
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 208 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var defaultLevelOfDetail = 11;
	        var MapUtil;
	        (function (MapUtil) {
	            MapUtil.Settings = {
	                /** Maximum Bing requests at once. The Bing have limit how many request at once you can do per socket. */
	                MaxBingRequest: 6,
	                /** Maximum cache size of cached geocode data. */
	                MaxCacheSize: 3000,
	                /** Maximum cache overflow of cached geocode data to kick the cache reducing. */
	                MaxCacheSizeOverflow: 100,
	                // Bing Keys and URL
	                BingKey: "insert your key",
	                BingUrl: "https://dev.virtualearth.net/REST/v1/Locations",
	                BingUrlGeodata: "https://platform.bing.com/geo/spatial/v1/public/Geodata?",
	                /** Switch the data result for geodata polygons to by double array instead locations array */
	                UseDoubleArrayGeodataResult: true,
	                UseDoubleArrayDequeueTimeout: 0,
	            };
	            // Bing map min/max boundaries
	            MapUtil.MinAllowedLatitude = -85.05112878;
	            MapUtil.MaxAllowedLatitude = 85.05112878;
	            MapUtil.MinAllowedLongitude = -180;
	            MapUtil.MaxAllowedLongitude = 180;
	            MapUtil.TileSize = 256;
	            MapUtil.MaxLevelOfDetail = 23;
	            MapUtil.MinLevelOfDetail = 1;
	            MapUtil.MaxAutoZoomLevel = 5;
	            MapUtil.DefaultLevelOfDetail = 11;
	            MapUtil.WorkerErrorName = "___error___";
	            MapUtil.CategoryTypes = {
	                Address: "Address",
	                City: "City",
	                Continent: "Continent",
	                CountryRegion: "Country",
	                County: "County",
	                Longitude: "Longitude",
	                Latitude: "Latitude",
	                Place: "Place",
	                PostalCode: "PostalCode",
	                StateOrProvince: "StateOrProvince"
	            };
	            var safeCharacters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";
	            function clip(n, minValue, maxValue) {
	                return Math.min(Math.max(n, minValue), maxValue);
	            }
	            MapUtil.clip = clip;
	            function getMapSize(levelOfDetail) {
	                if (levelOfDetail === 23)
	                    return 2147483648; //256 << 23 overflow the integer and return a negative value
	                if (Math.floor(levelOfDetail) === levelOfDetail)
	                    return 256 << levelOfDetail;
	                return 256 * Math.pow(2, levelOfDetail);
	            }
	            MapUtil.getMapSize = getMapSize;
	            /**
	             * pointArrayChunkLength Motivation:
	             * When the number is too small (e.g. less than 1000) the tile is rendering but VERY SLOW,
	             * when it's too high there is a risk to get "stack overflow" error on mobile (while joining).
	             * this is the lowest number I managed to get without any noticeable slowness.
	             */
	            var pointArrayChunkLength = 15000;
	            /**
	             * @param latLongArray - is a Float64Array as [lt0, lon0, lat1, long1, lat2, long2,....]
	             * @param buildString - optional, if true returns also a string as "x0 y0 x1 y1 x2 y2 ...."
	             * @returns IPixelArrayResult with Float64Array as [x0, y0, x1, y1, x2, y2,....]
	             */
	            function latLongToPixelXYArray(latLongArray, levelOfDetail, buildString) {
	                if (buildString === void 0) { buildString = false; }
	                var helperArray = [];
	                var result = {
	                    array: new Float64Array(latLongArray.length),
	                    arrayString: ""
	                };
	                for (var i = 0; i < latLongArray.length; i += 2) {
	                    var latitude = clip(latLongArray[i], MapUtil.MinAllowedLatitude, MapUtil.MaxAllowedLatitude);
	                    var longitude = clip(latLongArray[i + 1], MapUtil.MinAllowedLongitude, MapUtil.MaxAllowedLongitude);
	                    var x = (longitude + 180) / 360;
	                    var sinLatitude = Math.sin(latitude * Math.PI / 180);
	                    var y = 0.5 - Math.log((1 + sinLatitude) / (1 - sinLatitude)) / (4 * Math.PI);
	                    var mapSize = getMapSize(levelOfDetail);
	                    result.array[i] = clip(x * mapSize + 0.5, 0.0, mapSize - 1);
	                    result.array[i + 1] = clip(y * mapSize + 0.5, 0.0, mapSize - 1);
	                    if (buildString) {
	                        helperArray.push(result.array[i], result.array[i + 1]);
	                        if (helperArray.length >= pointArrayChunkLength) {
	                            result.arrayString += helperArray.join(" ") + " ";
	                            helperArray = [];
	                        }
	                    }
	                }
	                if (buildString) {
	                    result.arrayString += helperArray.join(" ") + " ";
	                }
	                return result;
	            }
	            MapUtil.latLongToPixelXYArray = latLongToPixelXYArray;
	            function getLocationBoundaries(latLongArray) {
	                var northWest = {
	                    latitude: -90, longitude: 180
	                };
	                var southEast = {
	                    latitude: 90, longitude: -180
	                };
	                for (var i = 0; i < latLongArray.length; i += 2) {
	                    northWest.latitude = Math.max(latLongArray[i], northWest.latitude);
	                    northWest.longitude = Math.min(latLongArray[i + 1], northWest.longitude);
	                    southEast.latitude = Math.min(latLongArray[i], southEast.latitude);
	                    southEast.longitude = Math.max(latLongArray[i + 1], southEast.longitude);
	                }
	                northWest.longitude = clip(northWest.longitude, -180, 180);
	                southEast.longitude = clip(southEast.longitude, -180, 180);
	                return Microsoft.Maps.LocationRect.fromCorners(new Microsoft.Maps.Location(northWest.latitude, northWest.longitude), new Microsoft.Maps.Location(southEast.latitude, southEast.longitude));
	            }
	            MapUtil.getLocationBoundaries = getLocationBoundaries;
	            /**
	             * Note: this code is taken from Bing.
	             *  see Point Compression Algorithm http://msdn.microsoft.com/en-us/library/jj158958.aspx
	             *  see Decompression Algorithm in http://msdn.microsoft.com/en-us/library/dn306801.aspx
	             */
	            function parseEncodedSpatialValueArray(value) {
	                var list = [];
	                var index = 0;
	                var xsum = 0;
	                var ysum = 0;
	                var max = 4294967296;
	                while (index < value.length) {
	                    var n = 0;
	                    var k = 0;
	                    while (1) {
	                        if (index >= value.length) {
	                            return null;
	                        }
	                        var b = safeCharacters.indexOf(value.charAt(index++));
	                        if (b === -1) {
	                            return null;
	                        }
	                        var tmp = ((b & 31) * (Math.pow(2, k)));
	                        var ht = tmp / max;
	                        var lt = tmp % max;
	                        var hn = n / max;
	                        var ln = n % max;
	                        var nl = (lt | ln) >>> 0;
	                        n = (ht | hn) * max + nl;
	                        k += 5;
	                        if (b < 32)
	                            break;
	                    }
	                    var diagonal = Math.floor((Math.sqrt(8 * n + 5) - 1) / 2);
	                    n -= diagonal * (diagonal + 1) / 2;
	                    var ny = Math.floor(n);
	                    var nx = diagonal - ny;
	                    nx = (nx >> 1) ^ -(nx & 1);
	                    ny = (ny >> 1) ^ -(ny & 1);
	                    xsum += nx;
	                    ysum += ny;
	                    var lat = ysum * 0.00001;
	                    var lon = xsum * 0.00001;
	                    list.push(lat);
	                    list.push(lon);
	                }
	                return new Float64Array(list);
	            }
	            MapUtil.parseEncodedSpatialValueArray = parseEncodedSpatialValueArray;
	            function calcGeoData(data) {
	                var locations = data.locations;
	                for (var i = 0; i < locations.length; i++) {
	                    var location_1 = locations[i];
	                    if (!location_1.geographic) {
	                        location_1.geographic = MapUtil.parseEncodedSpatialValueArray(location_1.nativeBing);
	                    }
	                    var polygon = location_1.geographic;
	                    if (polygon) {
	                        if (!location_1.absolute) {
	                            var result = MapUtil.latLongToPixelXYArray(polygon, MapUtil.DefaultLevelOfDetail, true);
	                            location_1.absolute = result.array;
	                            location_1.absoluteString = result.arrayString;
	                            var geographicBounds = MapUtil.getLocationBoundaries(polygon);
	                            location_1.absoluteBounds = MapUtil.locationRectToRectXY(geographicBounds, MapUtil.DefaultLevelOfDetail);
	                        }
	                    }
	                }
	            }
	            MapUtil.calcGeoData = calcGeoData;
	            function locationToPixelXY(location, levelOfDetail) {
	                return latLongToPixelXY(location.latitude, location.longitude, levelOfDetail);
	            }
	            MapUtil.locationToPixelXY = locationToPixelXY;
	            function locationRectToRectXY(locationRect, levelOfDetail) {
	                var topleft = locationToPixelXY(locationRect.getNorthwest(), levelOfDetail);
	                var bottomRight = locationToPixelXY(locationRect.getSoutheast(), levelOfDetail);
	                return new powerbi.visuals.Rect(topleft.x, topleft.y, bottomRight.x - topleft.x, bottomRight.y - topleft.y);
	            }
	            MapUtil.locationRectToRectXY = locationRectToRectXY;
	            function latLongToPixelXY(latitude, longitude, levelOfDetail) {
	                var array = latLongToPixelXYArray(new Float64Array([latitude, longitude]), levelOfDetail).array;
	                return new powerbi.visuals.Point(array[0], array[1]);
	            }
	            MapUtil.latLongToPixelXY = latLongToPixelXY;
	            function pixelXYToLocation(pixelX, pixelY, levelOfDetail) {
	                var mapSize = getMapSize(levelOfDetail);
	                var x = (clip(pixelX, 0, mapSize - 1) / mapSize) - 0.5;
	                var y = 0.5 - (clip(pixelY, 0, mapSize - 1) / mapSize);
	                var latitude = 90 - 360 * Math.atan(Math.exp(-y * 2 * Math.PI)) / Math.PI;
	                var longitude = 360 * x;
	                return new Microsoft.Maps.Location(latitude, longitude);
	            }
	            MapUtil.pixelXYToLocation = pixelXYToLocation;
	            var CurrentLocation;
	            (function (CurrentLocation) {
	                function createPushpin(location) {
	                    var template = '<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">'
	                        + '<circle fill="#FF5F00" cx="12" cy="12" r="6"/>'
	                        + '<circle fill="none" stroke="#FF5F00" stroke-width="2" cx="12" cy="12" r="10"/>'
	                        + '</svg>';
	                    var options = {
	                        draggable: false,
	                        htmlContent: template,
	                        height: 24,
	                        width: 24
	                    };
	                    return new Microsoft.Maps.Pushpin(location, options);
	                }
	                CurrentLocation.createPushpin = createPushpin;
	            })(CurrentLocation = MapUtil.CurrentLocation || (MapUtil.CurrentLocation = {}));
	        })(MapUtil = visuals.MapUtil || (visuals.MapUtil = {}));
	        var MapPolygonInfo = (function () {
	            function MapPolygonInfo() {
	                this._locationRect = new Microsoft.Maps.LocationRect(new Microsoft.Maps.Location(30, -30), 60, 60);
	            }
	            MapPolygonInfo.prototype.reCalc = function (mapControl, width, height) {
	                var baseLocations = [this._locationRect.getNorthwest(), this._locationRect.getSoutheast()];
	                width = width / 2.00;
	                height = height / 2.00;
	                if (!this._baseRect) {
	                    var l0 = MapUtil.locationToPixelXY(this._locationRect.getNorthwest(), defaultLevelOfDetail);
	                    var l1 = MapUtil.locationToPixelXY(this._locationRect.getSoutheast(), defaultLevelOfDetail);
	                    this._baseRect = new visuals.Rect(l0.x, l0.y, l1.x - l0.x, l1.y - l0.y);
	                }
	                var l = mapControl.tryLocationToPixel(baseLocations);
	                this._currentRect = new visuals.Rect(l[0].x + width, l[0].y + height, l[1].x - l[0].x, l[1].y - l[0].y);
	            };
	            Object.defineProperty(MapPolygonInfo.prototype, "scale", {
	                get: function () {
	                    if (this._baseRect) {
	                        return this._currentRect.width / this._baseRect.width;
	                    }
	                    return 1.0;
	                },
	                enumerable: true,
	                configurable: true
	            });
	            Object.defineProperty(MapPolygonInfo.prototype, "transform", {
	                get: function () {
	                    var base = this._baseRect;
	                    var current = this._currentRect;
	                    var transform = new visuals.Transform();
	                    transform.translate(current.left, current.top);
	                    transform.scale((current.width / base.width), (current.height / base.height));
	                    transform.translate(-base.left, -base.top);
	                    return transform;
	                },
	                enumerable: true,
	                configurable: true
	            });
	            Object.defineProperty(MapPolygonInfo.prototype, "outherTransform", {
	                get: function () {
	                    var base = this._baseRect;
	                    var current = this._currentRect;
	                    var transform = new visuals.Transform();
	                    transform.translate(current.left, current.top);
	                    var scale = Math.sqrt(current.width / base.width);
	                    transform.scale(scale, scale);
	                    return transform;
	                },
	                enumerable: true,
	                configurable: true
	            });
	            MapPolygonInfo.prototype.setViewBox = function (svg) {
	                var rect = svg.getBoundingClientRect();
	                var current = this._currentRect;
	                svg.setAttribute("viewBox", [-current.left, -current.top, rect.width, rect.height].join(" "));
	            };
	            Object.defineProperty(MapPolygonInfo.prototype, "innerTransform", {
	                get: function () {
	                    var base = this._baseRect;
	                    var current = this._currentRect;
	                    var transform = new visuals.Transform();
	                    var scale = current.width / base.width;
	                    transform.scale(scale, scale);
	                    transform.translate(-base.left, -base.top);
	                    return transform;
	                },
	                enumerable: true,
	                configurable: true
	            });
	            MapPolygonInfo.prototype.transformToString = function (transform) {
	                var m = transform.matrix;
	                return "matrix(" + m.m00 + " " + m.m10 + " " + m.m01 + " " + m.m11 + " " + m.m02 + " " + m.m12 + ")";
	            };
	            return MapPolygonInfo;
	        }());
	        visuals.MapPolygonInfo = MapPolygonInfo;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 209 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	*  Power BI Visualizations
	*
	*  Copyright (c) Microsoft Corporation
	*  All rights reserved.
	*  MIT License
	*
	*  Permission is hereby granted, free of charge, to any person obtaining a copy
	*  of this software and associated documentation files (the ""Software""), to deal
	*  in the Software without restriction, including without limitation the rights
	*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	*  copies of the Software, and to permit persons to whom the Software is
	*  furnished to do so, subject to the following conditions:
	*
	*  The above copyright notice and this permission notice shall be included in
	*  all copies or substantial portions of the Software.
	*
	*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	*  THE SOFTWARE.
	*/
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var utility;
	        (function (utility) {
	            ;
	            var SelectionManager = (function () {
	                function SelectionManager(options) {
	                    this.dataPointObjectName = 'dataPoint';
	                    this.hostServices = options.hostServices;
	                    this.selectedIds = [];
	                }
	                SelectionManager.prototype.select = function (selectionId, multiSelect) {
	                    if (multiSelect === void 0) { multiSelect = false; }
	                    var deferred = $.Deferred();
	                    if (this.hostServices.shouldRetainSelection()) {
	                        this.sendSelectionToHost([selectionId]);
	                    }
	                    else {
	                        this.selectInternal(selectionId, multiSelect);
	                        this.sendSelectionToHost(this.selectedIds);
	                    }
	                    deferred.resolve(this.selectedIds);
	                    return deferred;
	                };
	                SelectionManager.prototype.showContextMenu = function (selectionId, position) {
	                    var deferred = $.Deferred();
	                    position = position || visuals.InteractivityUtils.getPositionOfLastInputEvent();
	                    this.sendContextMenuToHost(selectionId, position);
	                    deferred.resolve();
	                    return deferred;
	                };
	                SelectionManager.prototype.hasSelection = function () {
	                    return this.selectedIds.length > 0;
	                };
	                SelectionManager.prototype.clear = function () {
	                    var deferred = $.Deferred();
	                    this.selectedIds = [];
	                    this.sendSelectionToHost([]);
	                    deferred.resolve();
	                    return deferred;
	                };
	                SelectionManager.prototype.getSelectionIds = function () {
	                    return this.selectedIds;
	                };
	                SelectionManager.prototype.sendSelectionToHost = function (ids) {
	                    var dataPointObjectName = this.dataPointObjectName;
	                    var selectArgs = {
	                        visualObjects: _.chain(ids)
	                            .filter(function (value) { return value.hasIdentity(); })
	                            .map(function (value) {
	                            return { objectName: dataPointObjectName, selectorsByColumn: value.getSelectorsByColumn() };
	                        })
	                            .value(),
	                        selectors: undefined,
	                    };
	                    var shouldInsertSelectors = false;
	                    if (!_.isEmpty(ids)) {
	                        shouldInsertSelectors = ids[0].getSelector() && !ids[0].getSelectorsByColumn();
	                    }
	                    if (shouldInsertSelectors) {
	                        selectArgs.selectors = _.chain(ids)
	                            .filter(function (value) { return value.hasIdentity(); })
	                            .map(function (value) { return value.getSelector(); })
	                            .value();
	                    }
	                    this.hostServices.onSelect(selectArgs);
	                };
	                SelectionManager.prototype.sendContextMenuToHost = function (selectionId, position) {
	                    var selectors = this.getSelectorsByColumn([selectionId]);
	                    if (_.isEmpty(selectors))
	                        return;
	                    var args = {
	                        data: selectors,
	                        position: position
	                    };
	                    this.hostServices.onContextMenu(args);
	                };
	                SelectionManager.prototype.getSelectorsByColumn = function (selectionIds) {
	                    return _(selectionIds)
	                        .filter(function (value) { return value.hasIdentity; })
	                        .map(function (value) { return value.getSelectorsByColumn(); })
	                        .compact()
	                        .value();
	                };
	                SelectionManager.prototype.selectInternal = function (selectionId, multiSelect) {
	                    if (SelectionManager.containsSelection(this.selectedIds, selectionId)) {
	                        this.selectedIds = multiSelect
	                            ? this.selectedIds.filter(function (d) { return !powerbi.data.Selector.equals(d, selectionId); })
	                            : this.selectedIds.length > 1
	                                ? [selectionId] : [];
	                    }
	                    else {
	                        if (multiSelect)
	                            this.selectedIds.push(selectionId);
	                        else
	                            this.selectedIds = [selectionId];
	                    }
	                };
	                SelectionManager.containsSelection = function (list, id) {
	                    return list.some(function (d) { return powerbi.data.Selector.equals(d.getSelector(), id.getSelector()); });
	                };
	                return SelectionManager;
	            }());
	            utility.SelectionManager = SelectionManager;
	        })(utility = visuals.utility || (visuals.utility = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 210 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        "use strict";
	        var shapes;
	        (function (shapes) {
	            var Utility = jsCommon.Utility;
	            var Polygon = (function () {
	                function Polygon(absolutePoints) {
	                    this.polygonPoints = this.convertArrayPathToPoints(absolutePoints);
	                }
	                Polygon.prototype.absoluteCentroid = function () {
	                    if (this._absoluteCentroid == null) {
	                        this._absoluteCentroid = this.calculatePolygonCentroid();
	                    }
	                    return this._absoluteCentroid;
	                };
	                Polygon.prototype.absoluteBoundingRect = function () {
	                    if (this._absoluteBoundingRect == null) {
	                        this._absoluteBoundingRect = this.calculateBoundingRect();
	                    }
	                    return this._absoluteBoundingRect;
	                };
	                /**
	                 * Check if label text contain in polygon shape.
	                 *
	                 * @return true/false is the label fit in polygon.
	                 * measure if rects points are inside the polygon shape
	                 * return true if there is at least 3 point inside the polygon
	                 */
	                Polygon.prototype.contains = function (rect) {
	                    var topLeft = { x: rect.left, y: rect.top };
	                    var topRight = { x: rect.left + rect.width, y: rect.top };
	                    var bottomLeft = { x: rect.left, y: rect.top + rect.height };
	                    var bottomRight = { x: rect.left + rect.width, y: rect.top + rect.height };
	                    return (this.inside(topLeft)
	                        && this.inside(topRight)
	                        && this.inside(bottomLeft)
	                        && this.inside(bottomRight));
	                };
	                /**
	                * Check if label text is outside of polygon shape.
	                * It checks 8 points in the label. TopLeft, TopCenter, TopRight, MiddleLeft, MiddleRight, BottomLeft, BottomMiddle, BottomRight
	                * @return true/false is there is any conflict (at least one point inside the shape).
	                */
	                Polygon.prototype.conflicts = function (rect) {
	                    if (!this.isConflictWithBoundingBox(rect)) {
	                        return false;
	                    }
	                    var topLeft = { x: rect.left, y: rect.top };
	                    var topCenter = { x: rect.left + rect.width / 2, y: rect.top };
	                    var topRight = { x: rect.left + rect.width, y: rect.top };
	                    var bottomLeft = { x: rect.left, y: rect.top + rect.height };
	                    var bottomCenter = { x: rect.left + rect.width / 2, y: rect.top + rect.height };
	                    var bottomRight = { x: rect.left + rect.width, y: rect.top + rect.height };
	                    var middleLeft = { x: rect.left, y: rect.top + rect.height / 2 };
	                    var middleRight = { x: rect.left + rect.width, y: rect.top + rect.height / 2 };
	                    return (this.inside(topLeft)
	                        || this.inside(topCenter)
	                        || this.inside(topRight)
	                        || this.inside(bottomLeft)
	                        || this.inside(bottomCenter)
	                        || this.inside(bottomRight)
	                        || this.inside(middleLeft)
	                        || this.inside(middleRight));
	                };
	                /**
	                * returns intersection point of a line (depicted by two points) and a polygon.
	                *
	                * @return the point of intersection or null if there is no intersection.
	                */
	                Polygon.prototype.lineIntersectionPoint = function (p0, p1) {
	                    for (var i = 0; i < this.polygonPoints.length; i++) {
	                        var p2 = this.polygonPoints[i];
	                        var p3 = (i === this.polygonPoints.length - 1 ? this.polygonPoints[0] : this.polygonPoints[i + 1]);
	                        var intersection = this.getLineIntersection(p0, p1, p2, p3);
	                        if (intersection !== null) {
	                            return intersection;
	                        }
	                    }
	                    return null;
	                };
	                /**
	                 * calculate Polygon Area.
	                 *
	                 * @return the area of the polygon (as number).
	                 */
	                Polygon.calculateAbsolutePolygonArea = function (polygonPoints) {
	                    var i, j = 1;
	                    var area = 0.0;
	                    for (i = 0; i < polygonPoints.length; i++) {
	                        area += polygonPoints[i].x * polygonPoints[j].y - polygonPoints[j].x * polygonPoints[i].y;
	                        j = (j + 1) % polygonPoints.length;
	                    }
	                    area *= 0.5;
	                    return area;
	                };
	                /**
	                * Check if label text is outside of polygon bounding box.
	                *
	                * @return true/false is there is any conflict (at least one point inside the shape).
	                */
	                Polygon.prototype.isConflictWithBoundingBox = function (rect) {
	                    return Rect.isIntersecting(this.absoluteBoundingRect(), rect);
	                };
	                /**
	                 * Calculate Polygon Centroid.
	                 *
	                 * @return 'center' point of the polygon.
	                 * calculate the polygon area
	                 * calculate the average points of the polygon by x & y axis.
	                 * divided the average point by the area
	                 */
	                Polygon.prototype.calculatePolygonCentroid = function () {
	                    var area, tempPoint, cx, cy, i, j;
	                    /* First calculate the polygon's signed area A */
	                    area = Polygon.calculateAbsolutePolygonArea(this.polygonPoints);
	                    /* Now calculate the centroid coordinates Cx and Cy */
	                    cx = cy = 0.0;
	                    j = 1;
	                    for (i = 0; i < this.polygonPoints.length; i++) {
	                        tempPoint = this.polygonPoints[i].x * this.polygonPoints[j].y - this.polygonPoints[j].x * this.polygonPoints[i].y;
	                        cx += (this.polygonPoints[i].x + this.polygonPoints[j].x) * tempPoint;
	                        cy += (this.polygonPoints[i].y + this.polygonPoints[j].y) * tempPoint;
	                        j = (j + 1) % this.polygonPoints.length;
	                    }
	                    cx = cx / (6.0 * area);
	                    cy = cy / (6.0 * area);
	                    return {
	                        x: cx,
	                        y: cy,
	                    };
	                };
	                Polygon.prototype.calculateBoundingRect = function () {
	                    var minX = Number.POSITIVE_INFINITY;
	                    var minY = Number.POSITIVE_INFINITY;
	                    var maxX = Number.NEGATIVE_INFINITY;
	                    var maxY = Number.NEGATIVE_INFINITY;
	                    for (var i = 0; i < this.polygonPoints.length; i++) {
	                        if (this.polygonPoints[i].x < minX) {
	                            minX = this.polygonPoints[i].x;
	                        }
	                        else if (this.polygonPoints[i].x > maxX) {
	                            maxX = this.polygonPoints[i].x;
	                        }
	                        if (this.polygonPoints[i].y < minY) {
	                            minY = this.polygonPoints[i].y;
	                        }
	                        else if (this.polygonPoints[i].y > maxY) {
	                            maxY = this.polygonPoints[i].y;
	                        }
	                    }
	                    return {
	                        left: minX,
	                        top: minY,
	                        width: maxX - minX,
	                        height: maxY - minY
	                    };
	                };
	                /**
	                 * Check if point exist inside polygon shape.
	                 *
	                 * @return true/false if point exist inside shape.
	                 * ray-casting algorithm based on:
	                 * http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
	                 */
	                Polygon.prototype.inside = function (point) {
	                    var x = point.x, y = point.y;
	                    var insideVar = false;
	                    for (var i = 0, j = this.polygonPoints.length - 1; i < this.polygonPoints.length; j = i++) {
	                        var xi = this.polygonPoints[i].x, yi = this.polygonPoints[i].y;
	                        var xj = this.polygonPoints[j].x, yj = this.polygonPoints[j].y;
	                        var intersect = ((yi > y) !== (yj > y))
	                            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
	                        if (intersect) {
	                            insideVar = !insideVar;
	                        }
	                    }
	                    return insideVar;
	                };
	                ;
	                /**
	                 * Checks if a line (presented as two points) intersects with a another line
	                 */
	                Polygon.prototype.getLineIntersection = function (line0p1, line0p2, line1p1, line1p2) {
	                    var p0_x = line0p1.x;
	                    var p0_y = line0p1.y;
	                    var p1_x = line0p2.x;
	                    var p1_y = line0p2.y;
	                    var p2_x = line1p1.x;
	                    var p2_y = line1p1.y;
	                    var p3_x = line1p2.x;
	                    var p3_y = line1p2.y;
	                    var s1_x = p1_x - p0_x;
	                    var s1_y = p1_y - p0_y;
	                    var s2_x = p3_x - p2_x;
	                    var s2_y = p3_y - p2_y;
	                    //Calculating collisions using cross products
	                    var s = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / (-s2_x * s1_y + s1_x * s2_y);
	                    var t = (s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / (-s2_x * s1_y + s1_x * s2_y);
	                    // 0<=s<=1 and 0<=t<=1 ensures that the collision is part of the original line
	                    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
	                        // Collision detected
	                        return { x: (p0_x + (t * s1_x)), y: (p0_y + (t * s1_y)) };
	                    }
	                    return null; // No collision
	                };
	                Polygon.prototype.convertArrayPathToPoints = function (path) {
	                    var pointsRes = [];
	                    for (var i = 0; i < path.length; i += 2) {
	                        var x = path[i];
	                        var y = path[i + 1];
	                        var newPoint = {
	                            x: x,
	                            y: y,
	                        };
	                        pointsRes.push(newPoint);
	                    }
	                    return pointsRes;
	                };
	                return Polygon;
	            }());
	            shapes.Polygon = Polygon;
	            var Point;
	            (function (Point) {
	                function offset(point, offsetX, offsetY) {
	                    var newPointX = ((point.x + offsetX) >= 0) ? (point.x + offsetX) : 0;
	                    var newPointY = ((point.y + offsetY) >= 0) ? (point.y + offsetY) : 0;
	                    return { x: newPointX, y: newPointY };
	                }
	                Point.offset = offset;
	                function equals(point, other) {
	                    return point !== undefined && point !== null && other !== undefined && other !== null && point.x === other.x && point.y === other.y;
	                }
	                Point.equals = equals;
	                function clone(point) {
	                    return (point !== null) ? { x: point.x, y: point.y } : null;
	                }
	                Point.clone = clone;
	                function toString(point) {
	                    return "{x:" + point.x + ", y:" + point.y + "}";
	                }
	                Point.toString = toString;
	                function serialize(point) {
	                    return point.x + "," + point.y;
	                }
	                Point.serialize = serialize;
	                function getDistance(point, other) {
	                    if ((point === null) || (other) === null) {
	                        return null;
	                    }
	                    var diffX = other.x - point.x;
	                    var diffY = other.y - point.y;
	                    return Math.sqrt(diffX * diffX + diffY * diffY);
	                }
	                Point.getDistance = getDistance;
	                function equalWithPrecision(point1, point2) {
	                    return point1 === point2 ||
	                        (point1 !== undefined && point2 !== undefined && powerbi.Double.equalWithPrecision(point1.x, point2.x) && powerbi.Double.equalWithPrecision(point1.y, point2.y));
	                }
	                Point.equalWithPrecision = equalWithPrecision;
	                function parsePoint(value, defaultValue) {
	                    if (value === null) {
	                        return (defaultValue === undefined) ? null : defaultValue;
	                    }
	                    else if (value === undefined) {
	                        return (defaultValue === undefined) ? null : defaultValue;
	                    }
	                    else {
	                        if (value.length === 2) {
	                            return { x: Utility.parseNumber(value[0]), y: Utility.parseNumber(value[1]) };
	                        }
	                        else if (typeof value === "string") {
	                            var parts = value.split(",");
	                            if (parts.length !== 2) {
	                                return (defaultValue === undefined) ? null : defaultValue;
	                            }
	                            return { x: Utility.parseNumber(parts[0]), y: Utility.parseNumber(parts[1]) };
	                        }
	                        else if ((value.length !== 2) && (typeof value !== "string")) {
	                            return (defaultValue === undefined) ? null : defaultValue;
	                        }
	                        else {
	                            return { x: Utility.parseNumber(value.x), y: Utility.parseNumber(value.y) };
	                        }
	                    }
	                }
	                Point.parsePoint = parsePoint;
	            })(Point = shapes.Point || (shapes.Point = {}));
	            var Size;
	            (function (Size) {
	                function isEmpty(size) {
	                    return size.width === 0 && size.height === 0;
	                }
	                Size.isEmpty = isEmpty;
	                function equals(size, other) {
	                    return size !== undefined && size !== null && other !== undefined && other !== null && size.width === other.width && size.height === other.height;
	                }
	                Size.equals = equals;
	                function clone(size) {
	                    return (size !== null) ? { width: size.width, height: size.height } : null;
	                }
	                Size.clone = clone;
	                function inflate(size, padding) {
	                    var result = clone(size);
	                    if (padding) {
	                        result.width += padding.left + padding.right;
	                        result.height += padding.top + padding.bottom;
	                    }
	                    return result;
	                }
	                Size.inflate = inflate;
	                function deflate(size, padding) {
	                    var result = clone(size);
	                    if (padding) {
	                        result.width = result.width - padding.left - padding.right;
	                        if (result.width < 0) {
	                            result.width = 0;
	                        }
	                        result.height = result.height - padding.top - padding.bottom;
	                        if (result.height < 0) {
	                            result.height = 0;
	                        }
	                    }
	                    return result;
	                }
	                Size.deflate = deflate;
	                function combine(size, other) {
	                    if (other) {
	                        size.width = Math.max(size.width, other.width);
	                        size.height = Math.max(size.height, other.height);
	                    }
	                    return size;
	                }
	                Size.combine = combine;
	                function toRect(size) {
	                    return { left: 0, top: 0, width: size.width, height: size.height };
	                }
	                Size.toRect = toRect;
	                function toString(size) {
	                    return "{width:" + size.width + ", height:" + size.height + "}";
	                }
	                Size.toString = toString;
	                function equal(size1, size2) {
	                    return size1 === size2 ||
	                        (size1 !== undefined && size2 !== undefined && size1.width === size2.width && size1.height === size2.height);
	                }
	                Size.equal = equal;
	                function equalWithPrecision(size1, size2) {
	                    return size1 === size2 ||
	                        (size1 !== undefined && size2 !== undefined && powerbi.Double.equalWithPrecision(size1.width, size2.width) && powerbi.Double.equalWithPrecision(size1.height, size2.height));
	                }
	                Size.equalWithPrecision = equalWithPrecision;
	                function parseSize(value, defaultValue) {
	                    if (value === null) {
	                        return (defaultValue === undefined) ? null : defaultValue;
	                    }
	                    else if (value === undefined) {
	                        return (defaultValue === undefined) ? null : defaultValue;
	                    }
	                    else {
	                        if (value.length === 2) {
	                            return { width: Utility.parseNumber(value[0]), height: Utility.parseNumber(value[1]) };
	                        }
	                        else if (typeof value === "string") {
	                            var parts = value.split(",");
	                            if (parts.length !== 2) {
	                                return (defaultValue === undefined) ? null : defaultValue;
	                            }
	                            return { width: Utility.parseNumber(parts[0]), height: Utility.parseNumber(parts[1]) };
	                        }
	                        else if ((value.length !== 2) && (typeof value !== "string")) {
	                            return (defaultValue === undefined) ? null : defaultValue;
	                        }
	                        else {
	                            return { width: Utility.parseNumber(value.width), height: Utility.parseNumber(value.height) };
	                        }
	                    }
	                }
	                Size.parseSize = parseSize;
	            })(Size = shapes.Size || (shapes.Size = {}));
	            var Rect;
	            (function (Rect) {
	                function getOffset(rect) {
	                    return { x: rect.left, y: rect.top };
	                }
	                Rect.getOffset = getOffset;
	                function getSize(rect) {
	                    return { width: rect.width, height: rect.height };
	                }
	                Rect.getSize = getSize;
	                function setSize(rect, value) {
	                    rect.width = value.width;
	                    rect.height = value.height;
	                }
	                Rect.setSize = setSize;
	                function right(rect) {
	                    return rect.left + rect.width;
	                }
	                Rect.right = right;
	                function bottom(rect) {
	                    return rect.top + rect.height;
	                }
	                Rect.bottom = bottom;
	                function topLeft(rect) {
	                    return { x: rect.left, y: rect.top };
	                }
	                Rect.topLeft = topLeft;
	                function topRight(rect) {
	                    return { x: rect.left + rect.width, y: rect.top };
	                }
	                Rect.topRight = topRight;
	                function bottomLeft(rect) {
	                    return { x: rect.left, y: rect.top + rect.height };
	                }
	                Rect.bottomLeft = bottomLeft;
	                function bottomRight(rect) {
	                    return { x: rect.left + rect.width, y: rect.top + rect.height };
	                }
	                Rect.bottomRight = bottomRight;
	                function equals(rect, other) {
	                    return other !== undefined && other !== null &&
	                        rect.left === other.left && rect.top === other.top && rect.width === other.width && rect.height === other.height;
	                }
	                Rect.equals = equals;
	                function clone(rect) {
	                    return (rect !== null) ? { left: rect.left, top: rect.top, width: rect.width, height: rect.height } : null;
	                }
	                Rect.clone = clone;
	                function toString(rect) {
	                    return "{left:" + rect.left + ", top:" + rect.top + ", width:" + rect.width + ", height:" + rect.height + "}";
	                }
	                Rect.toString = toString;
	                function offset(rect, offsetX, offsetY) {
	                    var newLeft = ((rect.left + offsetX) >= 0) ? rect.left + offsetX : 0;
	                    var newTop = ((rect.top + offsetY) >= 0) ? rect.top + offsetY : 0;
	                    return { left: newLeft, top: newTop, width: rect.width, height: rect.height };
	                }
	                Rect.offset = offset;
	                function inflate(rect, padding) {
	                    var result = clone(rect);
	                    if (padding) {
	                        result.left -= padding.left;
	                        result.top -= padding.top;
	                        result.width += padding.left + padding.right;
	                        result.height += padding.top + padding.bottom;
	                    }
	                    return result;
	                }
	                Rect.inflate = inflate;
	                function deflate(rect, padding) {
	                    var result = clone(rect);
	                    if (padding) {
	                        result.left += padding.left;
	                        result.top += padding.top;
	                        result.width -= padding.left + padding.right;
	                        result.height -= padding.top + padding.bottom;
	                    }
	                    return result;
	                }
	                Rect.deflate = deflate;
	                function inflateBy(rect, padding) {
	                    return { left: rect.left - padding, top: rect.top - padding, width: rect.width + padding + padding, height: rect.height + padding + padding };
	                }
	                Rect.inflateBy = inflateBy;
	                function deflateBy(rect, padding) {
	                    return { left: rect.left + padding, top: rect.top + padding, width: rect.width - padding - padding, height: rect.height - padding - padding };
	                }
	                Rect.deflateBy = deflateBy;
	                /**
	                 * Get closest point.
	                 *
	                 * @return the closest point on the rect to the (x,y) point given.
	                 * In case the (x,y) given is inside the rect, (x,y) will be returned.
	                 * Otherwise, a point on a border will be returned.
	                 */
	                function getClosestPoint(rect, x, y) {
	                    return {
	                        x: Math.min(Math.max(rect.left, x), rect.left + rect.width),
	                        y: Math.min(Math.max(rect.top, y), rect.top + rect.height)
	                    };
	                }
	                Rect.getClosestPoint = getClosestPoint;
	                function equal(rect1, rect2) {
	                    return rect1 === rect2 ||
	                        (rect1 !== undefined && rect2 !== undefined && rect1.left === rect2.left && rect1.top === rect2.top && rect1.width === rect2.width && rect1.height === rect2.height);
	                }
	                Rect.equal = equal;
	                function equalWithPrecision(rect1, rect2) {
	                    return rect1 === rect2 ||
	                        (rect1 !== undefined && rect2 !== undefined &&
	                            powerbi.Double.equalWithPrecision(rect1.left, rect2.left) && powerbi.Double.equalWithPrecision(rect1.top, rect2.top) &&
	                            powerbi.Double.equalWithPrecision(rect1.width, rect2.width) && powerbi.Double.equalWithPrecision(rect1.height, rect2.height));
	                }
	                Rect.equalWithPrecision = equalWithPrecision;
	                function isEmpty(rect) {
	                    return rect === undefined || rect === null || (rect.width === 0 && rect.height === 0);
	                }
	                Rect.isEmpty = isEmpty;
	                function containsPoint(rect, point) {
	                    if ((rect === null) || (point === null)) {
	                        return false;
	                    }
	                    return powerbi.Double.lessOrEqualWithPrecision(rect.left, point.x) &&
	                        powerbi.Double.lessOrEqualWithPrecision(point.x, rect.left + rect.width) &&
	                        powerbi.Double.lessOrEqualWithPrecision(rect.top, point.y) &&
	                        powerbi.Double.lessOrEqualWithPrecision(point.y, rect.top + rect.height);
	                }
	                Rect.containsPoint = containsPoint;
	                function isIntersecting(rect1, rect2) {
	                    if (!rect1 || !rect2) {
	                        return false;
	                    }
	                    var left = Math.max(rect1.left, rect2.left);
	                    var right = Math.min(rect1.left + rect1.width, rect2.left + rect2.width);
	                    if (left > right) {
	                        return false;
	                    }
	                    var top = Math.max(rect1.top, rect2.top);
	                    var bottom = Math.min(rect1.top + rect1.height, rect2.top + rect2.height);
	                    return top <= bottom;
	                }
	                Rect.isIntersecting = isIntersecting;
	                function intersect(rect1, rect2) {
	                    if (!rect1) {
	                        return rect2;
	                    }
	                    if (!rect2) {
	                        return rect1;
	                    }
	                    var left = Math.max(rect1.left, rect2.left);
	                    var top = Math.max(rect1.top, rect2.top);
	                    var right = Math.min(rect1.left + rect1.width, rect2.left + rect2.width);
	                    var bottom = Math.min(rect1.top + rect1.height, rect2.top + rect2.height);
	                    if (left <= right && top <= bottom) {
	                        return { left: left, top: top, width: right - left, height: bottom - top };
	                    }
	                    else {
	                        return { left: 0, top: 0, width: 0, height: 0 };
	                    }
	                }
	                Rect.intersect = intersect;
	                function combine(rect1, rect2) {
	                    if (!rect1) {
	                        return rect2;
	                    }
	                    if (!rect2) {
	                        return rect1;
	                    }
	                    var left = Math.min(rect1.left, rect2.left);
	                    var top = Math.min(rect1.top, rect2.top);
	                    var right = Math.max(rect1.left + rect1.width, rect2.left + rect2.width);
	                    var bottom = Math.max(rect1.top + rect1.height, rect2.top + rect2.height);
	                    return { left: left, top: top, width: right - left, height: bottom - top };
	                }
	                Rect.combine = combine;
	                function parseRect(value, defaultValue) {
	                    if (value === null) {
	                        return (defaultValue === undefined) ? null : defaultValue;
	                    }
	                    else if (value === undefined) {
	                        return (defaultValue === undefined) ? null : defaultValue;
	                    }
	                    else {
	                        if (value.length === 4) {
	                            return { left: Utility.parseNumber(value[0]), top: Utility.parseNumber(value[1]), width: Utility.parseNumber(value[2]), height: Utility.parseNumber(value[3]) };
	                        }
	                        else if (typeof value === "string") {
	                            var parts = value.split(",");
	                            if (parts.length !== 4) {
	                                return (defaultValue === undefined) ? null : defaultValue;
	                            }
	                            return {
	                                left: Utility.parseNumber(parts[0]), top: Utility.parseNumber(parts[1]), width: Utility.parseNumber(parts[2]), height: Utility.parseNumber(parts[3])
	                            };
	                        }
	                        else if ((value.length !== 4) && (typeof value !== "string")) {
	                            return (defaultValue === undefined) ? null : defaultValue;
	                        }
	                        else {
	                            return { left: Utility.parseNumber(value.left), top: Utility.parseNumber(value.top), width: Utility.parseNumber(value.width), height: Utility.parseNumber(value.height) };
	                        }
	                    }
	                }
	                Rect.parseRect = parseRect;
	                function getCentroid(rect) {
	                    return {
	                        x: rect.left + (rect.width / 2),
	                        y: rect.top + (rect.height / 2)
	                    };
	                }
	                Rect.getCentroid = getCentroid;
	            })(Rect = shapes.Rect || (shapes.Rect = {}));
	            var Thickness;
	            (function (Thickness) {
	                function inflate(thickness, other) {
	                    var result = clone(thickness);
	                    if (other) {
	                        result.left = thickness.left + other.left;
	                        result.right = thickness.right + other.right;
	                        result.bottom = thickness.bottom + other.bottom;
	                        result.top = thickness.top + other.top;
	                    }
	                    return result;
	                }
	                Thickness.inflate = inflate;
	                function getWidth(thickness) {
	                    return thickness.left + thickness.right;
	                }
	                Thickness.getWidth = getWidth;
	                function getHeight(thickness) {
	                    return thickness.top + thickness.bottom;
	                }
	                Thickness.getHeight = getHeight;
	                function clone(thickness) {
	                    return (thickness !== null) ? { left: thickness.left, top: thickness.top, right: thickness.right, bottom: thickness.bottom } : null;
	                }
	                Thickness.clone = clone;
	                function equals(thickness, other) {
	                    return thickness !== undefined && thickness !== null && other !== undefined && other !== null && thickness.left === other.left && thickness.bottom === other.bottom && thickness.right === other.right && thickness.top === other.top;
	                }
	                Thickness.equals = equals;
	                function flipHorizontal(thickness) {
	                    var temp = thickness.right;
	                    thickness.right = thickness.left;
	                    thickness.left = temp;
	                }
	                Thickness.flipHorizontal = flipHorizontal;
	                function flipVertical(thickness) {
	                    var top = thickness.top;
	                    thickness.top = thickness.bottom;
	                    thickness.bottom = top;
	                }
	                Thickness.flipVertical = flipVertical;
	                function toString(thickness) {
	                    return "{top:" + thickness.top + ", left:" + thickness.left + ", right:" + thickness.right + ", bottom:" + thickness.bottom + "}";
	                }
	                Thickness.toString = toString;
	                function toCssString(thickness) {
	                    return thickness.top + "px " + thickness.right + "px " + thickness.bottom + "px " + thickness.left + "px";
	                }
	                Thickness.toCssString = toCssString;
	                function isEmpty(thickness) {
	                    return thickness.left === 0 && thickness.top === 0 && thickness.right === 0 && thickness.bottom === 0;
	                }
	                Thickness.isEmpty = isEmpty;
	                function equal(thickness1, thickness2) {
	                    return thickness1 === thickness2 ||
	                        (thickness1 !== undefined && thickness2 !== undefined && thickness1.left === thickness2.left && thickness1.top === thickness2.top && thickness1.right === thickness2.right && thickness1.bottom === thickness2.bottom);
	                }
	                Thickness.equal = equal;
	                function equalWithPrecision(thickness1, thickness2) {
	                    return thickness1 === thickness2 ||
	                        (thickness1 !== undefined && thickness2 !== undefined &&
	                            powerbi.Double.equalWithPrecision(thickness1.left, thickness2.left) && powerbi.Double.equalWithPrecision(thickness1.top, thickness2.top) &&
	                            powerbi.Double.equalWithPrecision(thickness1.right, thickness2.right) && powerbi.Double.equalWithPrecision(thickness1.bottom, thickness2.bottom));
	                }
	                Thickness.equalWithPrecision = equalWithPrecision;
	                function parseThickness(value, defaultValue, resetValue) {
	                    if (value === null) {
	                        return (defaultValue === undefined) ? null : defaultValue;
	                    }
	                    else if (value === undefined) {
	                        return (defaultValue === undefined) ? null : defaultValue;
	                    }
	                    else {
	                        if (value.length === 4) {
	                            return { left: Utility.parseNumber(value[0]), top: Utility.parseNumber(value[1]), right: Utility.parseNumber(value[2]), bottom: Utility.parseNumber(value[3]) };
	                        }
	                        else if (typeof value === "string") {
	                            var parts = value.split(",");
	                            if (parts.length !== 4) {
	                                return (defaultValue === undefined) ? null : defaultValue;
	                            }
	                            return { left: Utility.parseNumber(parts[0]), top: Utility.parseNumber(parts[1]), right: Utility.parseNumber(parts[2]), bottom: Utility.parseNumber(parts[3]) };
	                        }
	                        else if ((value.length !== 4) && (typeof value !== "string")) {
	                            return (defaultValue === undefined) ? null : defaultValue;
	                        }
	                        else {
	                            return { left: Utility.parseNumber(value.left), top: Utility.parseNumber(value.top), right: Utility.parseNumber(value.right), bottom: Utility.parseNumber(value.bottom) };
	                        }
	                    }
	                }
	                Thickness.parseThickness = parseThickness;
	            })(Thickness = shapes.Thickness || (shapes.Thickness = {}));
	            var Vector;
	            (function (Vector) {
	                function isEmpty(vector) {
	                    return vector.x === 0 && vector.y === 0;
	                }
	                Vector.isEmpty = isEmpty;
	                function equals(vector, other) {
	                    return vector !== undefined && vector !== null && other !== undefined && other !== null && vector.x === other.x && vector.y === other.y;
	                }
	                Vector.equals = equals;
	                function clone(vector) {
	                    return (vector !== null) ? { x: vector.x, y: vector.y } : null;
	                }
	                Vector.clone = clone;
	                function toString(vector) {
	                    return "{x:" + vector.x + ", y:" + vector.y + "}";
	                }
	                Vector.toString = toString;
	                function getLength(vector) {
	                    return Math.sqrt(vector.x * vector.x + vector.y * vector.y);
	                }
	                Vector.getLength = getLength;
	                function getLengthSqr(vector) {
	                    return vector.x * vector.x + vector.y * vector.y;
	                }
	                Vector.getLengthSqr = getLengthSqr;
	                function scale(vector, scalar) {
	                    return { x: vector.x * scalar, y: vector.y * scalar };
	                }
	                Vector.scale = scale;
	                function normalize(vector) {
	                    return !isEmpty(vector) ? scale(vector, 1 / getLength(vector)) : vector;
	                }
	                Vector.normalize = normalize;
	                function rotate90DegCW(vector) {
	                    return { x: vector.y, y: -vector.x };
	                }
	                Vector.rotate90DegCW = rotate90DegCW;
	                function rotate90DegCCW(vector) {
	                    return { x: -vector.y, y: vector.x };
	                }
	                Vector.rotate90DegCCW = rotate90DegCCW;
	                function rotate(vector, angle) {
	                    var newX = vector.x * Math.cos(angle) - vector.y * Math.sin(angle);
	                    var newY = vector.x * Math.sin(angle) + vector.y * Math.cos(angle);
	                    return { x: newX, y: newY };
	                }
	                Vector.rotate = rotate;
	                function equal(vector1, vector2) {
	                    return vector1 === vector2 ||
	                        (vector1 !== undefined && vector2 !== undefined && vector1.x === vector2.x && vector1.y === vector2.y);
	                }
	                Vector.equal = equal;
	                function equalWithPrecision(vector1, vector2) {
	                    return vector1 === vector2 ||
	                        (vector1 !== undefined && vector2 !== undefined && powerbi.Double.equalWithPrecision(vector1.x, vector2.x) && powerbi.Double.equalWithPrecision(vector1.y, vector2.y));
	                }
	                Vector.equalWithPrecision = equalWithPrecision;
	                function add(vect1, vect2) {
	                    if (!vect1 || !vect2) {
	                        return undefined;
	                    }
	                    return { x: vect1.x + vect2.x, y: vect1.y + vect2.y };
	                }
	                Vector.add = add;
	                function subtract(vect1, vect2) {
	                    if (!vect1 || !vect2) {
	                        return undefined;
	                    }
	                    return { x: vect1.x - vect2.x, y: vect1.y - vect2.y };
	                }
	                Vector.subtract = subtract;
	                function dotProduct(vect1, vect2) {
	                    if (!vect1 || !vect2) {
	                        return undefined;
	                    }
	                    return vect1.x * vect2.x + vect1.y * vect2.y;
	                }
	                Vector.dotProduct = dotProduct;
	                function getDeltaVector(p0, p1) {
	                    if (!p0 || !p1) {
	                        return undefined;
	                    }
	                    return { x: p1.x - p0.x, y: p1.y - p0.y };
	                }
	                Vector.getDeltaVector = getDeltaVector;
	            })(Vector = shapes.Vector || (shapes.Vector = {}));
	        })(shapes = visuals.shapes || (visuals.shapes = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 211 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var Color = jsCommon.Color;
	        var PixelConverter = jsCommon.PixelConverter;
	        var SQExprBuilder = powerbi.data.SQExprBuilder;
	        var SemanticFilter = powerbi.data.SemanticFilter;
	        /** Utility class for slicer*/
	        var SlicerUtil;
	        (function (SlicerUtil) {
	            /** CSS selectors for slicer elements. */
	            var Selectors;
	            (function (Selectors) {
	                var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
	                Selectors.HeaderContainer = createClassAndSelector('headerContainer');
	                Selectors.Header = createClassAndSelector('slicerHeader');
	                Selectors.TitleHeader = createClassAndSelector('titleHeader');
	                Selectors.HeaderText = createClassAndSelector('headerText');
	                Selectors.Body = createClassAndSelector('slicerBody');
	                Selectors.Label = createClassAndSelector('slicerLabel');
	                Selectors.LabelText = createClassAndSelector('slicerText');
	                Selectors.LabelImage = createClassAndSelector('slicerImage');
	                Selectors.CountText = createClassAndSelector('slicerCountText');
	                Selectors.Clear = createClassAndSelector('clear');
	                Selectors.SearchHeader = createClassAndSelector('searchHeader');
	                Selectors.SearchInput = createClassAndSelector('searchInput');
	                Selectors.SearchHeaderCollapsed = createClassAndSelector('collapsed');
	                Selectors.SearchHeaderShow = createClassAndSelector('show');
	                Selectors.MultiSelectEnabled = createClassAndSelector('isMultiSelectEnabled');
	            })(Selectors = SlicerUtil.Selectors || (SlicerUtil.Selectors = {}));
	            /** Const declarations*/
	            var DisplayNameKeys;
	            (function (DisplayNameKeys) {
	                DisplayNameKeys.Clear = 'Slicer_Clear';
	                DisplayNameKeys.SelectAll = 'Slicer_SelectAll';
	                DisplayNameKeys.Search = 'SearchBox_Text';
	            })(DisplayNameKeys = SlicerUtil.DisplayNameKeys || (SlicerUtil.DisplayNameKeys = {}));
	            /** Helper class for slicer settings  */
	            var SettingsHelper;
	            (function (SettingsHelper) {
	                function areSettingsDefined(data) {
	                    return data != null && data.slicerSettings != null;
	                }
	                SettingsHelper.areSettingsDefined = areSettingsDefined;
	            })(SettingsHelper = SlicerUtil.SettingsHelper || (SlicerUtil.SettingsHelper = {}));
	            /** Helper class for handling slicer default value  */
	            var DefaultValueHandler;
	            (function (DefaultValueHandler) {
	                function getIdentityFields(dataView) {
	                    if (!dataView)
	                        return;
	                    var dataViewCategorical = dataView.categorical;
	                    if (!dataViewCategorical || _.isEmpty(dataViewCategorical.categories))
	                        return;
	                    return dataViewCategorical.categories[0].identityFields;
	                }
	                DefaultValueHandler.getIdentityFields = getIdentityFields;
	            })(DefaultValueHandler = SlicerUtil.DefaultValueHandler || (SlicerUtil.DefaultValueHandler = {}));
	            function getContainsFilter(expr, containsText) {
	                var containsTextExpr = SQExprBuilder.text(containsText);
	                var filterExpr = SQExprBuilder.contains(expr, containsTextExpr);
	                return SemanticFilter.fromSQExpr(filterExpr);
	            }
	            SlicerUtil.getContainsFilter = getContainsFilter;
	            // Compare the sqExpr of the scopeId with sqExprs of the retained values. 
	            // If match found, remove the item from the retainedValues list, and return true, 
	            // otherwise return false.
	            function tryRemoveValueFromRetainedList(value, selectedScopeIds, caseInsensitive) {
	                if (!value || _.isEmpty(selectedScopeIds))
	                    return false;
	                for (var i = 0, len = selectedScopeIds.length; i < len; i++) {
	                    var retainedValueScopeId = selectedScopeIds[i];
	                    if (powerbi.DataViewScopeIdentity.equals(value, retainedValueScopeId, caseInsensitive)) {
	                        selectedScopeIds.splice(i, 1);
	                        return true;
	                    }
	                }
	                return false;
	            }
	            SlicerUtil.tryRemoveValueFromRetainedList = tryRemoveValueFromRetainedList;
	            function getUpdatedSelfFilter(searchKey, metaData) {
	                if (!metaData || _.isEmpty(searchKey))
	                    return;
	                debug.assert(_.size(metaData.columns) === 1, 'slicer should not have more than one column based on the capability');
	                var column = _.first(metaData.columns);
	                if (column && column.expr)
	                    return SlicerUtil.getContainsFilter(column.expr, searchKey);
	            }
	            SlicerUtil.getUpdatedSelfFilter = getUpdatedSelfFilter;
	            /** Helper class for creating and measuring slicer DOM elements  */
	            var DOMHelper = (function () {
	                function DOMHelper() {
	                }
	                DOMHelper.prototype.createSlicerHeader = function (hostServices) {
	                    var slicerHeaderDiv = document.createElement('div');
	                    slicerHeaderDiv.className = Selectors.Header.class;
	                    var slicerHeader = d3.select(slicerHeaderDiv);
	                    var slicerTitle = slicerHeader.append('h2')
	                        .classed(Selectors.TitleHeader.class, true);
	                    slicerTitle.append('span')
	                        .classed(Selectors.Clear.class, true)
	                        .attr('title', hostServices.getLocalizedString(DisplayNameKeys.Clear));
	                    slicerTitle.append('div').classed(Selectors.HeaderText.class, true);
	                    var slicerSearch = slicerHeader.append('div')
	                        .classed(Selectors.SearchHeader.class, true)
	                        .classed(Selectors.SearchHeaderCollapsed.class, true);
	                    slicerSearch.append('span')
	                        .classed('powervisuals-glyph search', true)
	                        .attr('title', hostServices.getLocalizedString(DisplayNameKeys.Search));
	                    slicerSearch.append('input')
	                        .attr('type', 'text')
	                        .classed(Selectors.SearchInput.class, true)
	                        .attr('drag-resize-disabled', 'true');
	                    return slicerHeaderDiv;
	                };
	                DOMHelper.prototype.getHeaderTextProperties = function (settings) {
	                    var headerTextProperties = {
	                        fontFamily: visuals.Font.Family.regular.css,
	                        fontSize: '10px'
	                    };
	                    if (settings.header.show) {
	                        headerTextProperties.fontSize = PixelConverter.fromPoint(settings.header.textSize);
	                    }
	                    return headerTextProperties;
	                };
	                DOMHelper.prototype.getSlicerBodyViewport = function (currentViewport, settings, headerTextProperties) {
	                    var headerHeight = (settings.header.show) ? this.getHeaderHeight(settings, headerTextProperties) : 0;
	                    var searchHeaderHight = settings.search.enabled ? DOMHelper.SearchInputHeight : 0;
	                    var slicerBodyHeight = currentViewport.height - (headerHeight + settings.header.borderBottomWidth + searchHeaderHight);
	                    return {
	                        height: slicerBodyHeight,
	                        width: currentViewport.width
	                    };
	                };
	                // TODO: Slicer body height and width update should be done through less file
	                DOMHelper.prototype.updateSlicerBodyDimensions = function (currentViewport, slicerBody, settings) {
	                    var slicerViewport = this.getSlicerBodyViewport(currentViewport, settings, this.getHeaderTextProperties(settings));
	                    slicerBody.style({
	                        'height': PixelConverter.toString(slicerViewport.height),
	                        'width': PixelConverter.toString(slicerViewport.width),
	                    });
	                };
	                DOMHelper.prototype.getHeaderHeight = function (settings, textProperties) {
	                    return powerbi.TextMeasurementService.estimateSvgTextHeight(this.getTextProperties(settings.header.textSize, textProperties)) + settings.general.outlineWeight;
	                };
	                DOMHelper.prototype.getRowHeight = function (settings, textProperties) {
	                    return powerbi.TextMeasurementService.estimateSvgTextHeight(this.getTextProperties(settings.slicerText.textSize, textProperties)) + this.getRowsOutlineWidth(settings.slicerText.outline, settings.general.outlineWeight);
	                };
	                DOMHelper.prototype.styleSlicerHeader = function (slicerHeader, settings, headerText) {
	                    var titleHeader = slicerHeader.select(SlicerUtil.Selectors.TitleHeader.selector);
	                    var searchHeader = slicerHeader.select(SlicerUtil.Selectors.SearchHeader.selector);
	                    if (settings.header.show) {
	                        titleHeader.style('display', 'block');
	                        var headerTextElement = slicerHeader.select(Selectors.HeaderText.selector)
	                            .text(headerText);
	                        this.setSlicerHeaderTextStyle(titleHeader, headerTextElement, settings, settings.search.enabled);
	                    }
	                    else {
	                        titleHeader.style('display', 'none');
	                    }
	                    if (settings.search.enabled) {
	                        searchHeader.classed(Selectors.SearchHeaderShow.class, true);
	                        searchHeader.classed(Selectors.SearchHeaderCollapsed.class, false);
	                    }
	                    else {
	                        searchHeader.classed(Selectors.SearchHeaderShow.class, false);
	                        searchHeader.classed(Selectors.SearchHeaderCollapsed.class, true);
	                    }
	                };
	                DOMHelper.prototype.setSlicerTextStyle = function (slicerText, settings) {
	                    slicerText
	                        .style({
	                        'color': settings.slicerText.color,
	                        'background-color': settings.slicerText.background,
	                        'border-style': 'solid',
	                        'border-color': settings.general.outlineColor,
	                        'border-width': visuals.VisualBorderUtil.getBorderWidth(settings.slicerText.outline, settings.general.outlineWeight),
	                        'font-size': PixelConverter.fromPoint(settings.slicerText.textSize),
	                        // Makes height consistent between browsers. 1.79 was found by aproximating current chrome line-height: normal calculation.
	                        "line-height": Math.floor(1.79 * settings.slicerText.textSize) + "px"
	                    });
	                    var color = this.calculateSlicerTextHighlightColor(settings.slicerText.color);
	                    slicerText.on('mouseover', function (d) {
	                        d3.select(this).style({
	                            'color': color,
	                        });
	                    });
	                    slicerText.on('mouseout', function (d) {
	                        d3.select(this).style({
	                            'color': settings.slicerText.color,
	                        });
	                    });
	                };
	                DOMHelper.prototype.getRowsOutlineWidth = function (outlineElement, outlineWeight) {
	                    switch (outlineElement) {
	                        case visuals.outline.none:
	                        case visuals.outline.leftRight:
	                            return 0;
	                        case visuals.outline.bottomOnly:
	                        case visuals.outline.topOnly:
	                            return outlineWeight;
	                        case visuals.outline.topBottom:
	                        case visuals.outline.frame:
	                            return outlineWeight * 2;
	                        default:
	                            return 0;
	                    }
	                };
	                DOMHelper.prototype.setSlicerHeaderTextStyle = function (slicerHeader, headerTextElement, settings, searchEnabled) {
	                    var hideOutline = false;
	                    // When search is enabled, we will hide the default outline if the outline properties haven't been customized by user.
	                    if (searchEnabled) {
	                        var defaultSetting = visuals.Slicer.DefaultStyleProperties();
	                        hideOutline = (settings.header.outline === defaultSetting.header.outline
	                            && settings.general.outlineWeight === defaultSetting.general.outlineWeight
	                            && settings.general.outlineColor === defaultSetting.general.outlineColor);
	                    }
	                    slicerHeader
	                        .style({
	                        'border-style': hideOutline ? 'none' : 'solid',
	                        'border-color': settings.general.outlineColor,
	                        'border-width': visuals.VisualBorderUtil.getBorderWidth(settings.header.outline, settings.general.outlineWeight),
	                    });
	                    headerTextElement
	                        .style({
	                        'color': settings.header.fontColor,
	                        'background-color': settings.header.background,
	                        'font-size': PixelConverter.fromPoint(settings.header.textSize),
	                    });
	                };
	                DOMHelper.prototype.calculateSlicerTextHighlightColor = function (color) {
	                    var rgbColor = Color.parseColorString(color);
	                    // If it's white, use the @neutralTertiaryAltColor
	                    if (rgbColor.R === 255 && rgbColor.G === 255 && rgbColor.B === 255)
	                        return '#C8C8C8';
	                    return Color.calculateHighlightColor(rgbColor, 0.8, 0.2);
	                };
	                DOMHelper.prototype.getTextProperties = function (textSize, textProperties) {
	                    textProperties.fontSize = PixelConverter.fromPoint(textSize);
	                    return textProperties;
	                };
	                DOMHelper.SearchInputHeight = 20;
	                return DOMHelper;
	            }());
	            SlicerUtil.DOMHelper = DOMHelper;
	        })(SlicerUtil = visuals.SlicerUtil || (visuals.SlicerUtil = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 212 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        /**
	         * Contains functions/constants to aid in adding tooltips.
	         */
	        var tooltipUtils;
	        (function (tooltipUtils) {
	            function tooltipUpdate(selection, tooltips) {
	                if (tooltips.length === 0)
	                    return;
	                debug.assert(selection.length === tooltips.length || selection[0].length === tooltips.length, 'data length should match dom element count');
	                var titles = selection.selectAll('title');
	                var titlesUpdate = titles.data(function (d, i) { return [tooltips[i]]; });
	                titlesUpdate.enter().append('title');
	                titlesUpdate.exit().remove();
	                titlesUpdate.text(function (d) { return d; });
	            }
	            tooltipUtils.tooltipUpdate = tooltipUpdate;
	        })(tooltipUtils = visuals.tooltipUtils || (visuals.tooltipUtils = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 213 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        /**
	         * Contains functions/constants to aid in SVG manupilation.
	         */
	        var SVGUtil;
	        (function (SVGUtil) {
	            /**
	             * Very small values, when stringified, may be converted to scientific notation and cause a temporarily
	             * invalid attribute or style property value.
	             * For example, the number 0.0000001 is converted to the string "1e-7".
	             * This is particularly noticeable when interpolating opacity values.
	             * To avoid scientific notation, start or end the transition at 1e-6,
	             * which is the smallest value that is not stringified in exponential notation.
	             */
	            SVGUtil.AlmostZero = 1e-6;
	            /**
	             * Creates a translate string for use with the SVG transform call.
	             */
	            function translate(x, y) {
	                debug.assertValue(x, 'x');
	                debug.assertValue(y, 'y');
	                return 'translate(' + x + ',' + y + ')';
	            }
	            SVGUtil.translate = translate;
	            /**
	             * Creates a translateX string for use with the SVG transform call.
	             */
	            function translateXWithPixels(x) {
	                debug.assertValue(x, 'x');
	                return 'translateX(' + x + 'px)';
	            }
	            SVGUtil.translateXWithPixels = translateXWithPixels;
	            function translateWithPixels(x, y) {
	                debug.assertValue(x, 'x');
	                debug.assertValue(y, 'y');
	                return 'translate(' + x + 'px,' + y + 'px)';
	            }
	            SVGUtil.translateWithPixels = translateWithPixels;
	            /**
	             * Creates a translate + rotate string for use with the SVG transform call.
	             */
	            function translateAndRotate(x, y, px, py, angle) {
	                debug.assertValue(x, 'x');
	                debug.assertValue(y, 'y');
	                debug.assertValue(px, 'px');
	                debug.assertValue(py, 'py');
	                debug.assertValue(angle, 'angle');
	                return 'transform', "translate("
	                    + x + "," + y + ")"
	                    + " rotate(" + angle + "," + px + "," + py + ")";
	            }
	            SVGUtil.translateAndRotate = translateAndRotate;
	            /**
	             * Creates a scale string for use in a CSS transform property.
	             */
	            function scale(scale) {
	                debug.assertValue(scale, 'scale');
	                return "scale(" + scale + ")";
	            }
	            SVGUtil.scale = scale;
	            /**
	             * Creates a translate + scale string for use with the SVG transform call.
	             */
	            function translateAndScale(x, y, ratio) {
	                debug.assertValue(x, 'x');
	                debug.assertValue(y, 'y');
	                debug.assertValue(ratio, 'ratio');
	                return 'transform', "translate("
	                    + x + "," + y + ")"
	                    + " scale(" + ratio + ")";
	            }
	            SVGUtil.translateAndScale = translateAndScale;
	            /**
	             * Creates a transform origin string for use in a CSS transform-origin property.
	             */
	            function transformOrigin(xOffset, yOffset) {
	                debug.assertValue(xOffset, 'xOffset');
	                debug.assertValue(yOffset, 'yOffset');
	                return xOffset + " " + yOffset;
	            }
	            SVGUtil.transformOrigin = transformOrigin;
	            /**
	             * Forces all D3 transitions to complete.
	             * Normally, zero-delay transitions are executed after an instantaneous delay (<10ms).
	             * This can cause a brief flicker if the browser renders the page twice: once at the end of the first event loop,
	             * then again immediately on the first timer callback. By flushing the timer queue at the end of the first event loop,
	             * you can run any zero-delay transitions immediately and avoid the flicker.
	             *
	             * These flickers are noticable on IE, and with a large number of webviews(not recommend you ever do this) on iOS.
	             */
	            function flushAllD3Transitions() {
	                var now = Date.now;
	                Date.now = function () { return Infinity; };
	                d3.timer.flush();
	                Date.now = now;
	            }
	            SVGUtil.flushAllD3Transitions = flushAllD3Transitions;
	            /**
	             * Wrapper for flushAllD3Transitions.
	             */
	            function flushAllD3TransitionsIfNeeded(options) {
	                if (!options)
	                    return;
	                var animationOptions = options;
	                var asVisualInitOptions = options;
	                if (asVisualInitOptions.animation)
	                    animationOptions = asVisualInitOptions.animation;
	                if (animationOptions && animationOptions.transitionImmediate) {
	                    flushAllD3Transitions();
	                }
	            }
	            SVGUtil.flushAllD3TransitionsIfNeeded = flushAllD3TransitionsIfNeeded;
	            /**
	             * There is a known bug in IE10 that causes cryptic crashes for SVG elements with a null 'd' attribute:
	             * https://github.com/mbostock/d3/issues/1737
	             */
	            function ensureDAttribute(pathElement) {
	                if (!pathElement.getAttribute('d')) {
	                    pathElement.setAttribute('d', '');
	                }
	            }
	            SVGUtil.ensureDAttribute = ensureDAttribute;
	            /**
	             * In IE10, it is possible to return SVGPoints with NaN members.
	             */
	            function ensureValidSVGPoint(point) {
	                if (isNaN(point.x)) {
	                    point.x = 0;
	                }
	                if (isNaN(point.y)) {
	                    point.y = 0;
	                }
	            }
	            SVGUtil.ensureValidSVGPoint = ensureValidSVGPoint;
	            /**
	             * Parse the Transform string with value 'translate(x,y)'.
	             * In Chrome for the translate(position) string the delimiter
	             * is a comma and in IE it is a spaceso checking for both.
	             */
	            function parseTranslateTransform(input) {
	                if (!input || input.length === 0) {
	                    return {
	                        x: "0",
	                        y: "0",
	                    };
	                }
	                var translateCoordinates = input.split(/[\s,]+/);
	                debug.assertValue(translateCoordinates, 'translateCoordinates');
	                debug.assert(translateCoordinates.length > 0, 'translate array must atleast have one value');
	                var yValue = '0';
	                var xValue;
	                var xCoord = translateCoordinates[0];
	                // Y coordinate is ommited in I.E if it is 0, so need to check against that
	                if (translateCoordinates.length === 1) {
	                    // 10 refers to the length of 'translate('
	                    xValue = xCoord.substring(10, xCoord.length - 1);
	                }
	                else {
	                    var yCoord = translateCoordinates[1];
	                    yValue = yCoord.substring(0, yCoord.length - 1);
	                    // 10 refers to the length of 'translate('
	                    xValue = xCoord.substring(10, xCoord.length);
	                }
	                return {
	                    x: xValue,
	                    y: yValue
	                };
	            }
	            SVGUtil.parseTranslateTransform = parseTranslateTransform;
	            /**
	             * Create an arrow.
	             */
	            function createArrow(width, height, rotate) {
	                var transform = "rotate(" + rotate + " " + width / 2 + " " + height / 2 + ")";
	                var path = "M0 0";
	                path += "L0 " + height;
	                path += "L" + width + " " + height / 2 + " Z";
	                return {
	                    path: path,
	                    transform: transform
	                };
	            }
	            SVGUtil.createArrow = createArrow;
	            /**
	             * Use the ratio of the scaled bounding rect and the SVG DOM bounding box to get the x and y transform scale values
	             * @deprecated This function is unreliable across browser implementations, prefer to use SVGScaleDetector if needed.
	             */
	            function getTransformScaleRatios(svgElement) {
	                debug.assertFail('deprecated');
	                if (svgElement != null) {
	                    var scaledRect = svgElement.getBoundingClientRect();
	                    var domRect = svgElement.getBBox();
	                    if (domRect.height > 0 && domRect.width > 0) {
	                        return {
	                            x: scaledRect.width / domRect.width,
	                            y: scaledRect.height / domRect.height
	                        };
	                    }
	                }
	                return { x: 1, y: 1 };
	            }
	            SVGUtil.getTransformScaleRatios = getTransformScaleRatios;
	        })(SVGUtil = visuals.SVGUtil || (visuals.SVGUtil = {}));
	        var SVGScaleDetector = (function () {
	            function SVGScaleDetector(svgElement) {
	                this.scaleDetectorElement = svgElement
	                    .append('rect') // Using a <rect> which should have a reliable bounding box across browser implementations.
	                    .classed('scale-detector', true)
	                    .attr({
	                    width: 1,
	                    height: 1,
	                    'stroke-width': '0px',
	                    fill: 'none',
	                })
	                    .node();
	            }
	            SVGScaleDetector.prototype.getScale = function () {
	                var scaledRect = this.scaleDetectorElement.getBoundingClientRect();
	                var domRect = this.scaleDetectorElement.getBBox();
	                if (domRect.height > 0 && domRect.width > 0) {
	                    return {
	                        x: scaledRect.width / domRect.width,
	                        y: scaledRect.height / domRect.height
	                    };
	                }
	                return {
	                    x: 1,
	                    y: 1
	                };
	            };
	            return SVGScaleDetector;
	        }());
	        visuals.SVGScaleDetector = SVGScaleDetector;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 214 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        /**
	         * Contains functions/constants to aid in text manupilation.
	         */
	        var TextUtil;
	        (function (TextUtil) {
	            /**
	             * Remove breaking spaces from given string and replace by none breaking space (&nbsp).
	             */
	            function removeBreakingSpaces(str) {
	                return str.toString().replace(new RegExp(' ', 'g'), '&nbsp');
	            }
	            TextUtil.removeBreakingSpaces = removeBreakingSpaces;
	            /**
	             * Remove ellipses from a given string
	             */
	            function removeEllipses(str) {
	                return str.replace(/…/g, '');
	            }
	            TextUtil.removeEllipses = removeEllipses;
	            /**
	            * Replace every whitespace (0x20) with Non-Breaking Space (0xA0)
	             * @param {string} txt String to replace White spaces
	             * @returns Text after replcing white spaces
	             */
	            function replaceSpaceWithNBSP(txt) {
	                if (txt != null)
	                    return txt.replace(/ /g, "\xA0");
	            }
	            TextUtil.replaceSpaceWithNBSP = replaceSpaceWithNBSP;
	        })(TextUtil = visuals.TextUtil || (visuals.TextUtil = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 215 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var DataRoleHelper = powerbi.data.DataRoleHelper;
	        ;
	        var GradientUtils;
	        (function (GradientUtils) {
	            var SQExprBuilder = powerbi.data.SQExprBuilder;
	            var DefaultMidColor = "#ffffff";
	            var DefaultColor = DefaultMidColor;
	            var DataPointPropertyIdentifier = "dataPoint";
	            var FillRulePropertyIdentifier = "fillRule";
	            function getFillRuleRole(objectDescs) {
	                if (!objectDescs)
	                    return;
	                for (var objectName in objectDescs) {
	                    var objectDesc = objectDescs[objectName];
	                    for (var propertyName in objectDesc.properties) {
	                        var propertyDesc = objectDesc.properties[propertyName];
	                        if (propertyDesc.type && propertyDesc.type[FillRulePropertyIdentifier]) {
	                            return propertyDesc.rule.inputRole;
	                        }
	                    }
	                }
	            }
	            GradientUtils.getFillRuleRole = getFillRuleRole;
	            function shouldShowGradient(visualConfig) {
	                var isShowGradienCard = visualConfig && visualConfig.query && visualConfig.query.projections && visualConfig.query.projections['Gradient'] ? true : false;
	                return isShowGradienCard;
	            }
	            GradientUtils.shouldShowGradient = shouldShowGradient;
	            function getUpdatedGradientSettings(gradientObject) {
	                var gradientSettings;
	                if (gradientObject && !$.isEmptyObject(gradientObject)) {
	                    gradientSettings = getDefaultGradientSettings();
	                    for (var propertyName in gradientSettings) {
	                        var hasProperty = gradientObject.hasOwnProperty(propertyName);
	                        if (hasProperty) {
	                            var value = gradientObject[propertyName];
	                            if (value && value.solid && value.solid.color) {
	                                value = value.solid.color;
	                            }
	                            gradientSettings[propertyName] = value;
	                        }
	                    }
	                }
	                return gradientSettings;
	            }
	            GradientUtils.getUpdatedGradientSettings = getUpdatedGradientSettings;
	            function getGradientMeasureIndex(dataViewCategorical) {
	                if (dataViewCategorical && dataViewCategorical.values && dataViewCategorical.values.grouped) {
	                    var grouped = dataViewCategorical.values.grouped();
	                    return DataRoleHelper.getMeasureIndexOfRole(grouped, 'Gradient');
	                }
	                return -1;
	            }
	            GradientUtils.getGradientMeasureIndex = getGradientMeasureIndex;
	            function getGradientValueColumn(dataViewCategorical) {
	                if (dataViewCategorical == null)
	                    return null;
	                // check for gradient measure index
	                var gradientMeasureIndex = GradientUtils.getGradientMeasureIndex(dataViewCategorical);
	                var gradientValueColumn = gradientMeasureIndex === -1 ? null : dataViewCategorical.values[gradientMeasureIndex];
	                return gradientValueColumn;
	            }
	            GradientUtils.getGradientValueColumn = getGradientValueColumn;
	            function hasGradientRole(dataViewCategorical) {
	                var gradientMeasureIndex = getGradientMeasureIndex(dataViewCategorical);
	                return gradientMeasureIndex >= 0;
	            }
	            GradientUtils.hasGradientRole = hasGradientRole;
	            function getDefaultGradientSettings() {
	                var colors = getDefaultColors();
	                var gradientSettings = {
	                    diverging: false,
	                    minColor: colors.minColor,
	                    midColor: DefaultMidColor,
	                    maxColor: colors.maxColor,
	                    minValue: undefined,
	                    midValue: undefined,
	                    maxValue: undefined,
	                };
	                return gradientSettings;
	            }
	            GradientUtils.getDefaultGradientSettings = getDefaultGradientSettings;
	            function getDefaultFillRuleDefinition() {
	                return getLinearGradien2FillRuleDefinition();
	            }
	            GradientUtils.getDefaultFillRuleDefinition = getDefaultFillRuleDefinition;
	            function updateFillRule(propertyName, propertyValue, definitions) {
	                var dataPointObjectDefinition = powerbi.data.DataViewObjectDefinitions.ensure(definitions, DataPointPropertyIdentifier, null);
	                var fillRule = getFillRule(definitions);
	                var numericValueExpr;
	                var colorValueExpr;
	                if (!fillRule) {
	                    return;
	                }
	                if ($.isNumeric(propertyValue)) {
	                    numericValueExpr = propertyValue !== undefined ? SQExprBuilder.double(+propertyValue) : undefined;
	                    ;
	                }
	                if (propertyName === "minColor" || propertyName === "midColor" || propertyName === "maxColor") {
	                    colorValueExpr = getColorExpressionValue(fillRule, propertyName, propertyValue);
	                }
	                if (propertyName === "minColor") {
	                    updateMinColor(fillRule, colorValueExpr);
	                }
	                else if (propertyName === "midColor") {
	                    updateMidColor(fillRule, colorValueExpr);
	                }
	                else if (propertyName === "maxColor") {
	                    updateMaxColor(fillRule, colorValueExpr);
	                }
	                else if (propertyName === "minValue") {
	                    updateMinValue(fillRule, numericValueExpr);
	                }
	                else if (propertyName === "midValue") {
	                    updateMidValue(fillRule, numericValueExpr);
	                }
	                else if (propertyName === "maxValue") {
	                    updateMaxValue(fillRule, numericValueExpr);
	                }
	                else if (propertyName === "diverging") {
	                    if (propertyValue) {
	                        fillRule = getLinearGradien3FillRuleDefinition(fillRule);
	                    }
	                    else {
	                        fillRule = getLinearGradien2FillRuleDefinition(fillRule);
	                    }
	                    dataPointObjectDefinition.properties[FillRulePropertyIdentifier] = fillRule;
	                }
	                else if (propertyName === "revertToDefault") {
	                    fillRule = this.getDefaultFillRuleDefinition();
	                    dataPointObjectDefinition.properties[FillRulePropertyIdentifier] = fillRule;
	                }
	            }
	            GradientUtils.updateFillRule = updateFillRule;
	            function getGradientSettings(baseFillRule) {
	                if (baseFillRule) {
	                    return getGradientSettingsFromRule(baseFillRule);
	                }
	                else {
	                    return getDefaultGradientSettings();
	                }
	            }
	            GradientUtils.getGradientSettings = getGradientSettings;
	            function getFillRule(objectDefinitions) {
	                var fillRuleDefinition = powerbi.data.DataViewObjectDefinitions.getValue(objectDefinitions, { objectName: DataPointPropertyIdentifier, propertyName: FillRulePropertyIdentifier }, null);
	                return fillRuleDefinition;
	            }
	            GradientUtils.getFillRule = getFillRule;
	            function getDefaultColors() {
	                var dataColors = new powerbi.visuals.DataColorPalette();
	                var maxColorInfo = dataColors.getColorByIndex(0);
	                var colors = d3.scale.linear()
	                    .domain([0, 100])
	                    .range(["#ffffff", maxColorInfo.value]);
	                var maxColor = maxColorInfo.value;
	                var minColor = colors(20);
	                var midColor = DefaultMidColor;
	                return {
	                    minColor: minColor,
	                    midColor: midColor,
	                    maxColor: maxColor,
	                };
	            }
	            function getGradientSettingsFromRule(fillRule) {
	                var maxColor;
	                var minColor;
	                var midColor = DefaultMidColor;
	                var maxValue;
	                var midValue;
	                var minValue;
	                var diverging = fillRule.linearGradient3 !== undefined;
	                if (fillRule.linearGradient2) {
	                    var maxColorExpr = fillRule.linearGradient2.max.color;
	                    var minColorExpr = fillRule.linearGradient2.min.color;
	                    var maxValueExpr = fillRule.linearGradient2.max.value;
	                    var minValueExpr = fillRule.linearGradient2.min.value;
	                    maxColor = maxColorExpr.value;
	                    minColor = minColorExpr.value;
	                    if (maxValueExpr) {
	                        maxValue = maxValueExpr.value;
	                    }
	                    if (minValueExpr) {
	                        minValue = minValueExpr.value;
	                    }
	                }
	                else if (fillRule.linearGradient3) {
	                    var maxColorExpr = fillRule.linearGradient3.max.color;
	                    var midColorExpr = fillRule.linearGradient3.mid.color;
	                    var minColorExpr = fillRule.linearGradient3.min.color;
	                    var maxValueExpr = fillRule.linearGradient3.max.value;
	                    var midValueExpr = fillRule.linearGradient3.mid.value;
	                    var minValueExpr = fillRule.linearGradient3.min.value;
	                    maxColor = maxColorExpr.value;
	                    midColor = midColorExpr.value;
	                    minColor = minColorExpr.value;
	                    if (maxValueExpr) {
	                        maxValue = maxValueExpr.value;
	                    }
	                    if (midValueExpr) {
	                        midValue = midValueExpr.value;
	                    }
	                    if (minValueExpr) {
	                        minValue = minValueExpr.value;
	                    }
	                }
	                return {
	                    diverging: diverging,
	                    minColor: minColor,
	                    midColor: midColor,
	                    maxColor: maxColor,
	                    minValue: minValue,
	                    midValue: midValue,
	                    maxValue: maxValue,
	                };
	            }
	            GradientUtils.getGradientSettingsFromRule = getGradientSettingsFromRule;
	            /** Returns a string representing the gradient to be used for the GradientBar directive. */
	            function getGradientBarColors(gradientSettings) {
	                var colors = [];
	                gradientSettings.minColor = gradientSettings.minColor || DefaultColor;
	                colors.push(gradientSettings.minColor);
	                if (gradientSettings.diverging) {
	                    gradientSettings.midColor = gradientSettings.midColor || DefaultColor;
	                    colors.push(gradientSettings.midColor || DefaultColor);
	                }
	                gradientSettings.maxColor = gradientSettings.maxColor || DefaultColor;
	                colors.push(gradientSettings.maxColor || DefaultColor);
	                return colors.join(",");
	            }
	            GradientUtils.getGradientBarColors = getGradientBarColors;
	            function getLinearGradien2FillRuleDefinition(baseFillRule) {
	                var gradientSettings = getGradientSettings(baseFillRule);
	                var fillRuleDefinition = {
	                    linearGradient2: {
	                        max: { color: SQExprBuilder.text(gradientSettings.maxColor) },
	                        min: { color: SQExprBuilder.text(gradientSettings.minColor) },
	                    }
	                };
	                return fillRuleDefinition;
	            }
	            function getLinearGradien3FillRuleDefinition(baseFillRule) {
	                var gradientSettings = getGradientSettings(baseFillRule);
	                var fillRuleDefinition = {
	                    linearGradient3: {
	                        max: { color: SQExprBuilder.text(gradientSettings.maxColor) },
	                        mid: { color: SQExprBuilder.text(gradientSettings.midColor) },
	                        min: { color: SQExprBuilder.text(gradientSettings.minColor) },
	                    }
	                };
	                return fillRuleDefinition;
	            }
	            function getDefaultColorExpression(fillRule, propertyName) {
	                var defaultColor;
	                var defaultFillRule;
	                if (fillRule.linearGradient3) {
	                    defaultFillRule = getLinearGradien3FillRuleDefinition();
	                    if (propertyName === "minColor") {
	                        defaultColor = defaultFillRule.linearGradient3.min.color;
	                    }
	                    else if (propertyName === "midColor") {
	                        defaultColor = defaultFillRule.linearGradient3.mid.color;
	                    }
	                    else if (propertyName === "maxColor") {
	                        defaultColor = defaultFillRule.linearGradient3.max.color;
	                    }
	                }
	                else if (fillRule.linearGradient2) {
	                    defaultFillRule = getLinearGradien2FillRuleDefinition();
	                    if (propertyName === "minColor") {
	                        defaultColor = defaultFillRule.linearGradient2.min.color;
	                    }
	                    else if (propertyName === "maxColor") {
	                        defaultColor = defaultFillRule.linearGradient2.max.color;
	                    }
	                }
	                return defaultColor;
	            }
	            function getColorExpressionValue(fillRule, propertyName, propertyValue) {
	                var colorExpressionValue;
	                if (propertyValue) {
	                    colorExpressionValue = SQExprBuilder.text(propertyValue);
	                }
	                else {
	                    colorExpressionValue = getDefaultColorExpression(fillRule, propertyName);
	                }
	                return colorExpressionValue;
	            }
	            function updateMinColor(fillRule, colorExpressionValue) {
	                if (fillRule.linearGradient2) {
	                    fillRule.linearGradient2.min.color = colorExpressionValue;
	                }
	                else if (fillRule.linearGradient3) {
	                    fillRule.linearGradient3.min.color = colorExpressionValue;
	                }
	            }
	            function updateMidColor(fillRule, colorExpressionValue) {
	                if (fillRule.linearGradient3) {
	                    fillRule.linearGradient3.mid.color = colorExpressionValue;
	                }
	            }
	            function updateMaxColor(fillRule, colorExpressionValue) {
	                if (fillRule.linearGradient2) {
	                    fillRule.linearGradient2.max.color = colorExpressionValue;
	                }
	                else if (fillRule.linearGradient3) {
	                    fillRule.linearGradient3.max.color = colorExpressionValue;
	                }
	            }
	            function updateMinValue(fillRule, value) {
	                if (fillRule.linearGradient2) {
	                    fillRule.linearGradient2.min.value = value;
	                }
	                else if (fillRule.linearGradient3) {
	                    fillRule.linearGradient3.min.value = value;
	                }
	            }
	            function updateMidValue(fillRule, value) {
	                if (fillRule.linearGradient3) {
	                    fillRule.linearGradient3.mid.value = value;
	                }
	            }
	            function updateMaxValue(fillRule, value) {
	                if (fillRule.linearGradient2) {
	                    fillRule.linearGradient2.max.value = value;
	                }
	                else if (fillRule.linearGradient3) {
	                    fillRule.linearGradient3.max.value = value;
	                }
	            }
	        })(GradientUtils = visuals.GradientUtils || (visuals.GradientUtils = {}));
	        ;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 216 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var visualBackgroundHelper;
	        (function (visualBackgroundHelper) {
	            function getDefaultColor() {
	                return '#FFF';
	            }
	            visualBackgroundHelper.getDefaultColor = getDefaultColor;
	            function getDefaultTransparency() {
	                return 50;
	            }
	            visualBackgroundHelper.getDefaultTransparency = getDefaultTransparency;
	            function getDefaultShow() {
	                return false;
	            }
	            visualBackgroundHelper.getDefaultShow = getDefaultShow;
	            function getDefaultValues() {
	                return {
	                    color: getDefaultColor(),
	                    transparency: getDefaultTransparency(),
	                    show: getDefaultShow()
	                };
	            }
	            visualBackgroundHelper.getDefaultValues = getDefaultValues;
	            function enumeratePlot(enumeration, background) {
	                var transparency = (background && background.transparency);
	                if (transparency == null)
	                    transparency = getDefaultTransparency();
	                var backgroundObject = {
	                    selector: null,
	                    properties: {
	                        transparency: transparency,
	                        image: (background && background.image)
	                    },
	                    objectName: 'plotArea',
	                };
	                enumeration.pushInstance(backgroundObject);
	            }
	            visualBackgroundHelper.enumeratePlot = enumeratePlot;
	            function renderBackgroundImage(background, visualElement, layout) {
	                var image = background && background.image;
	                var imageUrl = image && image.url;
	                var imageFit = image && image.scaling;
	                var imageTransparency = background && background.transparency;
	                var backgroundImage = visualElement.children('.background-image');
	                // If there were image and it was removed
	                if (!imageUrl) {
	                    if (backgroundImage.length !== 0)
	                        backgroundImage.remove();
	                    return;
	                }
	                // If this is the first edit of the image
	                if (backgroundImage.length === 0) {
	                    // Place the div only if the image exists in order to keep the html as clean as possible
	                    visualElement.prepend('<div class="background-image"></div>');
	                    backgroundImage = visualElement.children('.background-image');
	                    // the div should be positioned absolute in order to get on top of the sibling svg
	                    backgroundImage.css('position', 'absolute');
	                }
	                // Get the size and margins from the visual for the div will placed inside the plot area
	                backgroundImage.css({
	                    'width': layout.width,
	                    'height': layout.height,
	                    'margin-left': layout.left,
	                    'margin-top': layout.top,
	                });
	                // Background properties
	                backgroundImage.css({
	                    'background-image': 'url(' + imageUrl + ')',
	                    'background-repeat': 'no-repeat',
	                    'opacity': (100 - imageTransparency) / 100,
	                });
	                switch (imageFit) {
	                    // The image will be centered in its initial size
	                    case visuals.imageScalingType.normal: {
	                        backgroundImage.css({
	                            'background-size': '',
	                            'background-position': '50% 50%',
	                        });
	                        break;
	                    }
	                    // The image will be streched all over the background
	                    case visuals.imageScalingType.fit: {
	                        backgroundImage.css({
	                            'background-size': '100% 100%',
	                            'background-position': '',
	                        });
	                        break;
	                    }
	                    // The image will stretch on the width and the height will scale accordingly
	                    case visuals.imageScalingType.fill: {
	                        backgroundImage.css({
	                            'background-size': '100%',
	                            'background-position': '50% 50%',
	                        });
	                        break;
	                    }
	                    default: {
	                        backgroundImage.css({
	                            'background-size': '',
	                            'background-position': '50% 50%',
	                        });
	                        break;
	                    }
	                }
	            }
	            visualBackgroundHelper.renderBackgroundImage = renderBackgroundImage;
	        })(visualBackgroundHelper = visuals.visualBackgroundHelper || (visuals.visualBackgroundHelper = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 217 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var Selector = powerbi.data.Selector;
	        /**
	         * A helper class for building a VisualObjectInstanceEnumerationObject:
	         * - Allows call chaining (e.g., builder.pushInstance({...}).pushInstance({...})
	         * - Allows creating of containers (via pushContainer/popContainer)
	         */
	        var ObjectEnumerationBuilder = (function () {
	            function ObjectEnumerationBuilder() {
	            }
	            ObjectEnumerationBuilder.prototype.pushInstance = function (instance) {
	                debug.assertValue(instance, 'instance');
	                var instances = this.instances;
	                if (!instances) {
	                    instances = this.instances = [];
	                }
	                var containerIdx = this.containerIdx;
	                if (containerIdx != null) {
	                    instance.containerIdx = containerIdx;
	                }
	                // Attempt to merge with an existing item if possible.
	                for (var _i = 0, instances_1 = instances; _i < instances_1.length; _i++) {
	                    var existingInstance = instances_1[_i];
	                    if (this.canMerge(existingInstance, instance)) {
	                        this.extend(existingInstance, instance, 'properties');
	                        this.extend(existingInstance, instance, 'validValues');
	                        return this;
	                    }
	                }
	                instances.push(instance);
	                return this;
	            };
	            ObjectEnumerationBuilder.prototype.pushContainer = function (container) {
	                debug.assertValue(container, 'container');
	                var containers = this.containers;
	                if (!containers) {
	                    containers = this.containers = [];
	                }
	                var updatedLen = containers.push(container);
	                this.containerIdx = updatedLen - 1;
	                return this;
	            };
	            ObjectEnumerationBuilder.prototype.popContainer = function () {
	                this.containerIdx = undefined;
	                return this;
	            };
	            ObjectEnumerationBuilder.prototype.complete = function () {
	                if (!this.instances)
	                    return;
	                var result = {
	                    instances: this.instances,
	                };
	                var containers = this.containers;
	                if (containers) {
	                    result.containers = containers;
	                }
	                return result;
	            };
	            ObjectEnumerationBuilder.prototype.canMerge = function (x, y) {
	                debug.assertValue(x, 'x');
	                debug.assertValue(y, 'y');
	                return x.objectName === y.objectName &&
	                    x.containerIdx === y.containerIdx &&
	                    Selector.equals(x.selector, y.selector);
	            };
	            ObjectEnumerationBuilder.prototype.extend = function (target, source, propertyName) {
	                debug.assertValue(target, 'target');
	                debug.assertValue(source, 'source');
	                debug.assertValue(propertyName, 'propertyName');
	                var sourceValues = source[propertyName];
	                if (!sourceValues)
	                    return;
	                var targetValues = target[propertyName];
	                if (!targetValues)
	                    targetValues = target[propertyName] = {};
	                for (var valuePropertyName in sourceValues) {
	                    if (targetValues[valuePropertyName]) {
	                        // Properties have first-writer-wins semantics.
	                        continue;
	                    }
	                    targetValues[valuePropertyName] = sourceValues[valuePropertyName];
	                }
	            };
	            ObjectEnumerationBuilder.merge = function (x, y) {
	                var xNormalized = ObjectEnumerationBuilder.normalize(x);
	                var yNormalized = ObjectEnumerationBuilder.normalize(y);
	                if (!xNormalized || !yNormalized)
	                    return xNormalized || yNormalized;
	                debug.assertValue(xNormalized, 'xNormalized');
	                debug.assertValue(yNormalized, 'yNormalized');
	                var xCategoryCount = xNormalized.containers ? xNormalized.containers.length : 0;
	                for (var _i = 0, _a = yNormalized.instances; _i < _a.length; _i++) {
	                    var yInstance = _a[_i];
	                    xNormalized.instances.push(yInstance);
	                    if (yInstance.containerIdx != null)
	                        yInstance.containerIdx += xCategoryCount;
	                }
	                var yContainers = yNormalized.containers;
	                if (!_.isEmpty(yContainers)) {
	                    if (xNormalized.containers)
	                        Array.prototype.push.apply(xNormalized.containers, yContainers);
	                    else
	                        xNormalized.containers = yContainers;
	                }
	                return xNormalized;
	            };
	            ObjectEnumerationBuilder.normalize = function (x) {
	                debug.assertAnyValue(x, 'x');
	                if (_.isArray(x)) {
	                    return { instances: x };
	                }
	                return x;
	            };
	            ObjectEnumerationBuilder.getContainerForInstance = function (enumeration, instance) {
	                debug.assertValue(enumeration, "enumeration");
	                debug.assertValue(instance, "instance");
	                debug.assertValue(enumeration.containers, "containers");
	                debug.assert(enumeration.containers.length > instance.containerIdx, "no container found in containers collection");
	                return enumeration.containers[instance.containerIdx];
	            };
	            return ObjectEnumerationBuilder;
	        }());
	        visuals.ObjectEnumerationBuilder = ObjectEnumerationBuilder;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 218 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        /** Helper class for Visual border styles */
	        var VisualBorderUtil;
	        (function (VisualBorderUtil) {
	            /**
	             * Gets The Boder Width string (e.g. 0px 1px 2px 3px)
	             * @param {OutlineType} string Type of the Outline, one of Visuals.outline.<XX> const strings
	             * @param {number} outlineWeight Weight of the outline in pixels
	             * @returns String representing the Border Width
	             */
	            function getBorderWidth(outlineType, outlineWeight) {
	                switch (outlineType) {
	                    case visuals.outline.none:
	                        return '0px';
	                    case visuals.outline.bottomOnly:
	                        return '0px 0px ' + outlineWeight + 'px 0px';
	                    case visuals.outline.topOnly:
	                        return outlineWeight + 'px 0px 0px 0px';
	                    case visuals.outline.leftOnly:
	                        return '0px 0px 0px ' + outlineWeight + 'px';
	                    case visuals.outline.rightOnly:
	                        return '0px ' + outlineWeight + 'px 0px 0px';
	                    case visuals.outline.topBottom:
	                        return outlineWeight + 'px 0px';
	                    case visuals.outline.leftRight:
	                        return '0px ' + outlineWeight + 'px';
	                    case visuals.outline.frame:
	                        return outlineWeight + 'px';
	                    default:
	                        debug.assertFail('Unexpected OutlineType value: ' + outlineType);
	                        return '0px';
	                }
	            }
	            VisualBorderUtil.getBorderWidth = getBorderWidth;
	        })(VisualBorderUtil = visuals.VisualBorderUtil || (visuals.VisualBorderUtil = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 219 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        /** Transformation matrix math wrapper */
	        var Transform = (function () {
	            // Constructor
	            function Transform(m) {
	                this.matrix = m || {
	                    m00: 1, m01: 0, m02: 0,
	                    m10: 0, m11: 1, m12: 0,
	                };
	            }
	            // Methods
	            Transform.prototype.applyToPoint = function (point) {
	                if (!point) {
	                    return point;
	                }
	                var m = this.matrix;
	                return {
	                    x: m.m00 * point.x + m.m01 * point.y + m.m02,
	                    y: m.m10 * point.x + m.m11 * point.y + m.m12,
	                };
	            };
	            Transform.prototype.applyToRect = function (rect) {
	                if (!rect) {
	                    return rect;
	                }
	                var x0 = rect.left;
	                var y0 = rect.top;
	                var m = this.matrix;
	                var isScaled = m.m00 !== 1 || m.m11 !== 1;
	                var isRotated = m.m01 !== 0 || m.m10 !== 0;
	                if (!isRotated && !isScaled) {
	                    // Optimize for the translation only case
	                    return { left: x0 + m.m02, top: y0 + m.m12, width: rect.width, height: rect.height };
	                }
	                var x1 = rect.left + rect.width;
	                var y1 = rect.top + rect.height;
	                var minX;
	                var maxX;
	                var minY;
	                var maxY;
	                if (isRotated) {
	                    var p0x = m.m00 * x0 + m.m01 * y0 + m.m02;
	                    var p0y = m.m10 * x0 + m.m11 * y0 + m.m12;
	                    var p1x = m.m00 * x0 + m.m01 * y1 + m.m02;
	                    var p1y = m.m10 * x0 + m.m11 * y1 + m.m12;
	                    var p2x = m.m00 * x1 + m.m01 * y0 + m.m02;
	                    var p2y = m.m10 * x1 + m.m11 * y0 + m.m12;
	                    var p3x = m.m00 * x1 + m.m01 * y1 + m.m02;
	                    var p3y = m.m10 * x1 + m.m11 * y1 + m.m12;
	                    minX = Math.min(p0x, p1x, p2x, p3x);
	                    maxX = Math.max(p0x, p1x, p2x, p3x);
	                    minY = Math.min(p0y, p1y, p2y, p3y);
	                    maxY = Math.max(p0y, p1y, p2y, p3y);
	                }
	                else {
	                    var p0x = m.m00 * x0 + m.m02;
	                    var p0y = m.m11 * y0 + m.m12;
	                    var p3x = m.m00 * x1 + m.m02;
	                    var p3y = m.m11 * y1 + m.m12;
	                    minX = Math.min(p0x, p3x);
	                    maxX = Math.max(p0x, p3x);
	                    minY = Math.min(p0y, p3y);
	                    maxY = Math.max(p0y, p3y);
	                }
	                return { left: minX, top: minY, width: maxX - minX, height: maxY - minY };
	            };
	            Transform.prototype.translate = function (xOffset, yOffset) {
	                if (xOffset !== 0 || yOffset !== 0) {
	                    var m = createTranslateMatrix(xOffset, yOffset);
	                    this.matrix = multiplyMatrices(this.matrix, m);
	                    this._inverse = null;
	                }
	            };
	            Transform.prototype.scale = function (xScale, yScale) {
	                if (xScale !== 1 || yScale !== 1) {
	                    var m = createScaleMatrix(xScale, yScale);
	                    this.matrix = multiplyMatrices(this.matrix, m);
	                    this._inverse = null;
	                }
	            };
	            Transform.prototype.rotate = function (angleInRadians) {
	                if (angleInRadians !== 0) {
	                    var m = createRotationMatrix(angleInRadians);
	                    this.matrix = multiplyMatrices(this.matrix, m);
	                    this._inverse = null;
	                }
	            };
	            Transform.prototype.add = function (other) {
	                if (other) {
	                    this.matrix = multiplyMatrices(this.matrix, other.matrix);
	                    this._inverse = null;
	                }
	            };
	            Transform.prototype.getInverse = function () {
	                if (!this._inverse) {
	                    this._inverse = new Transform(createInverseMatrix(this.matrix));
	                }
	                return this._inverse;
	            };
	            return Transform;
	        }());
	        visuals.Transform = Transform;
	        function createTranslateMatrix(xOffset, yOffset) {
	            return {
	                m00: 1, m01: 0, m02: xOffset,
	                m10: 0, m11: 1, m12: yOffset,
	            };
	        }
	        visuals.createTranslateMatrix = createTranslateMatrix;
	        function createScaleMatrix(xScale, yScale) {
	            return {
	                m00: xScale, m01: 0, m02: 0,
	                m10: 0, m11: yScale, m12: 0
	            };
	        }
	        visuals.createScaleMatrix = createScaleMatrix;
	        function createRotationMatrix(angleInRads) {
	            var a = angleInRads;
	            var sinA = Math.sin(a);
	            var cosA = Math.cos(a);
	            return {
	                m00: cosA, m01: -sinA, m02: 0,
	                m10: sinA, m11: cosA, m12: 0,
	            };
	        }
	        visuals.createRotationMatrix = createRotationMatrix;
	        function createInverseMatrix(m) {
	            var determinant = m.m00 * m.m11 - m.m01 * m.m10;
	            var invdet = 1 / determinant;
	            return {
	                m00: m.m11 * invdet,
	                m01: -m.m01 * invdet,
	                m02: (m.m01 * m.m12 - m.m02 * m.m11) * invdet,
	                m10: -m.m10 * invdet,
	                m11: m.m00 * invdet,
	                m12: -(m.m00 * m.m12 - m.m10 * m.m02) * invdet
	            };
	        }
	        visuals.createInverseMatrix = createInverseMatrix;
	        function multiplyMatrices(a, b) {
	            return {
	                m00: a.m00 * b.m00 + a.m01 * b.m10,
	                m01: a.m00 * b.m01 + a.m01 * b.m11,
	                m02: a.m00 * b.m02 + a.m01 * b.m12 + a.m02,
	                m10: a.m10 * b.m00 + a.m11 * b.m10,
	                m11: a.m10 * b.m01 + a.m11 * b.m11,
	                m12: a.m10 * b.m02 + a.m11 * b.m12 + a.m12,
	            };
	        }
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 220 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var Color = jsCommon.Color;
	        var DataRoleHelper = powerbi.data.DataRoleHelper;
	        var TrendLineHelper;
	        (function (TrendLineHelper) {
	            var TrendLinePropertyNames;
	            (function (TrendLinePropertyNames) {
	                TrendLinePropertyNames.show = 'show';
	                TrendLinePropertyNames.displayName = 'displayName';
	                TrendLinePropertyNames.lineColor = 'lineColor';
	                TrendLinePropertyNames.transparency = 'transparency';
	                TrendLinePropertyNames.style = 'style';
	                TrendLinePropertyNames.combineSeries = 'combineSeries';
	                TrendLinePropertyNames.useHighlightValues = 'useHighlightValues';
	            })(TrendLinePropertyNames || (TrendLinePropertyNames = {}));
	            var trendObjectName = 'trend';
	            TrendLineHelper.defaults = {
	                lineColor: { solid: { color: '#000' } },
	                lineStyle: visuals.lineStyle.dashed,
	                transparency: 0,
	                combineSeries: true,
	                useHighlightValues: true,
	            };
	            var TrendLineClassSelector = jsCommon.CssConstants.createClassAndSelector('trend-line');
	            var TrendLineLayerClassSelector = jsCommon.CssConstants.createClassAndSelector('trend-line-layer');
	            function enumerateObjectInstances(enumeration, trendLines) {
	                debug.assertValue(enumeration, 'enumeration');
	                if (_.isEmpty(trendLines)) {
	                    enumeration.pushInstance({
	                        selector: null,
	                        properties: {
	                            show: false,
	                            lineColor: TrendLineHelper.defaults.lineColor,
	                            transparency: TrendLineHelper.defaults.transparency,
	                            style: TrendLineHelper.defaults.lineStyle,
	                            combineSeries: TrendLineHelper.defaults.combineSeries,
	                        },
	                        objectName: trendObjectName,
	                    });
	                    return;
	                }
	                var trendLine = trendLines[0];
	                var properties = {};
	                properties['show'] = trendLine.show;
	                properties['displayName'] = trendLine.displayName;
	                if (trendLine.combineSeries)
	                    properties['lineColor'] = trendLine.lineColor;
	                properties['transparency'] = trendLine.transparency;
	                properties['style'] = trendLine.style;
	                properties['combineSeries'] = trendLine.combineSeries;
	                properties['useHighlightValues'] = trendLine.useHighlightValues;
	                enumeration.pushInstance({
	                    selector: null,
	                    properties: properties,
	                    objectName: trendObjectName,
	                });
	            }
	            TrendLineHelper.enumerateObjectInstances = enumerateObjectInstances;
	            function isDataViewForRegression(dataView) {
	                return DataRoleHelper.hasRoleInDataView(dataView, 'regression.X');
	            }
	            TrendLineHelper.isDataViewForRegression = isDataViewForRegression;
	            function readDataView(dataView, sourceDataView, y2, colors) {
	                if (!dataView || !dataView.categorical)
	                    return;
	                var categorical = dataView.categorical;
	                if (_.isEmpty(categorical.categories) || _.isEmpty(categorical.values))
	                    return;
	                var categories = categorical.categories[0].values;
	                var groups = categorical.values.grouped();
	                if (!categories || !groups)
	                    return;
	                var trendProperties = powerbi.DataViewObjects.getObject(dataView.metadata.objects, trendObjectName, {});
	                var show = powerbi.DataViewObject.getValue(trendProperties, TrendLinePropertyNames.show, false);
	                var displayName = powerbi.DataViewObject.getValue(trendProperties, TrendLinePropertyNames.displayName);
	                var lineColor = powerbi.DataViewObject.getValue(trendProperties, TrendLinePropertyNames.lineColor);
	                var transparency = powerbi.DataViewObject.getValue(trendProperties, TrendLinePropertyNames.transparency, TrendLineHelper.defaults.transparency);
	                var style = powerbi.DataViewObject.getValue(trendProperties, TrendLinePropertyNames.style, TrendLineHelper.defaults.lineStyle);
	                var combineSeries = powerbi.DataViewObject.getValue(trendProperties, TrendLinePropertyNames.combineSeries, TrendLineHelper.defaults.combineSeries);
	                var useHighlightValues = powerbi.DataViewObject.getValue(trendProperties, TrendLinePropertyNames.useHighlightValues, TrendLineHelper.defaults.useHighlightValues);
	                // Trend lines generated by Insights will be putting line color here, we should convert the Insights code to create
	                // "trend" objects like above and write the upgrade code to handle pinned tiles with trend lines before removing any feature switch.
	                var legacyColor = powerbi.DataViewObjects.getValue(categorical.values[0].source.objects, visuals.lineChartProps.dataPoint.fill);
	                if (legacyColor)
	                    lineColor = legacyColor;
	                var objects = sourceDataView.metadata.objects;
	                var defaultColor = powerbi.DataViewObjects.getFillColor(objects, { objectName: 'dataPoint', propertyName: 'defaultColor' });
	                var colorHelper = new visuals.ColorHelper(colors, { objectName: 'dataPoint', propertyName: 'fill' }, defaultColor);
	                var trendLines = [];
	                for (var groupIndex = 0; groupIndex < groups.length; groupIndex++) {
	                    var group = groups[groupIndex];
	                    var points = [];
	                    for (var i = 0; i < categories.length; i++) {
	                        var x = visuals.AxisHelper.normalizeNonFiniteNumber(categories[i]);
	                        // There is a assumption here that the group only has 1 set of values in it. Once we add more things like confidence bands,
	                        // this assumption will not be true. This assumption comes from the way dataViewRegresion generates the dataView
	                        var valueColumn = group.values[0];
	                        var values = void 0;
	                        if (useHighlightValues && valueColumn.highlights) {
	                            values = valueColumn.highlights;
	                        }
	                        else {
	                            values = valueColumn.values;
	                        }
	                        var y = visuals.AxisHelper.normalizeNonFiniteNumber(values[i]);
	                        if (x != null && y != null) {
	                            points.push({
	                                x: x,
	                                y: y,
	                            });
	                        }
	                    }
	                    var seriesLineColor = void 0;
	                    if (combineSeries) {
	                        seriesLineColor = lineColor || TrendLineHelper.defaults.lineColor;
	                    }
	                    else {
	                        // TODO: This should likely be delegated to the layer which knows how to choose the correct color for any given situation.
	                        if (sourceDataView.categorical.values.source) {
	                            // Dynamic series
	                            var sourceGroups = sourceDataView.categorical.values.grouped();
	                            var color = colorHelper.getColorForSeriesValue(sourceGroups[groupIndex].objects, sourceDataView.categorical.values.identityFields, group.name);
	                            color = darkenTrendLineColor(color);
	                            seriesLineColor = { solid: { color: color } };
	                        }
	                        else {
	                            // Static series
	                            var matchingMeasure = sourceDataView.categorical.values[groupIndex];
	                            var color = colorHelper.getColorForMeasure(matchingMeasure.source.objects, group.name);
	                            color = darkenTrendLineColor(color);
	                            seriesLineColor = { solid: { color: color } };
	                        }
	                    }
	                    trendLines.push({
	                        points: points,
	                        show: show,
	                        displayName: displayName,
	                        lineColor: seriesLineColor,
	                        transparency: transparency,
	                        style: style,
	                        combineSeries: combineSeries,
	                        useHighlightValues: useHighlightValues,
	                        y2Axis: y2,
	                    });
	                }
	                return trendLines;
	            }
	            TrendLineHelper.readDataView = readDataView;
	            function darkenTrendLineColor(color) {
	                var rgb = Color.parseColorString(color);
	                rgb = Color.darken(rgb, 20);
	                return Color.rgbString(rgb);
	            }
	            TrendLineHelper.darkenTrendLineColor = darkenTrendLineColor;
	            function render(trendLines, graphicsContext, axes, viewport) {
	                var layer = graphicsContext.select(TrendLineLayerClassSelector.selector);
	                if (layer.empty()) {
	                    layer = graphicsContext.append('svg').classed(TrendLineLayerClassSelector.class, true);
	                }
	                layer.attr({
	                    height: viewport.height,
	                    width: viewport.width
	                });
	                var lines = layer.selectAll(TrendLineClassSelector.selector).data(trendLines || []);
	                lines.enter().append('path').classed(TrendLineClassSelector.class, true);
	                lines
	                    .attr('d', function (d) {
	                    var xScale = axes.x.scale;
	                    var yScale = (d.y2Axis && axes.y2) ? axes.y2.scale : axes.y1.scale;
	                    var pathGen = d3.svg.line()
	                        .x(function (point) { return xScale(point.x); })
	                        .y(function (point) { return yScale(point.y); });
	                    return pathGen(_.filter(d.points, function (point) { return point.x != null && point.y != null; }));
	                });
	                lines.each(function (d) {
	                    var line = d3.select(this);
	                    var style = {};
	                    style.stroke = d.lineColor.solid.color;
	                    if (d.transparency != null) {
	                        style['stroke-opacity'] = (100 - d.transparency) / 100;
	                    }
	                    if (d.style === visuals.lineStyle.dashed) {
	                        style['stroke-dasharray'] = "5, 5";
	                    }
	                    else if (d.style === visuals.lineStyle.dotted) {
	                        style['stroke-dasharray'] = "1, 5";
	                        style['stroke-linecap'] = "round";
	                    }
	                    else if (d.style === visuals.lineStyle.solid) {
	                        style['stroke-dasharray'] = null;
	                        style['stroke-linecap'] = null;
	                    }
	                    line.style(style);
	                });
	                lines.exit().remove();
	            }
	            TrendLineHelper.render = render;
	        })(TrendLineHelper = visuals.TrendLineHelper || (visuals.TrendLineHelper = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 221 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var visibilityHelper;
	        (function (visibilityHelper) {
	            /**  Helper method that uses jQuery :visible selector to determine if visual is visible.
	                Elements are considered visible if they consume space in the document. Visible elements have a width or height that is greater than zero.
	                Elements with visibility: hidden or opacity: 0 are considered visible, since they still consume space in the layout.
	            */
	            function partiallyVisible(element) {
	                return element.is(":visible");
	            }
	            visibilityHelper.partiallyVisible = partiallyVisible;
	        })(visibilityHelper = visuals.visibilityHelper || (visuals.visibilityHelper = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 222 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var Selector = powerbi.data.Selector;
	    var VisualObjectRepetition;
	    (function (VisualObjectRepetition) {
	        /** Determines whether two repetitions are equal. */
	        function equals(x, y) {
	            // Normalize falsy to null
	            x = x || null;
	            y = y || null;
	            if (x === y)
	                return true;
	            if (!x !== !y)
	                return false;
	            debug.assertValue(x, 'x');
	            debug.assertValue(y, 'y');
	            if (!Selector.equals(x.selector, y.selector))
	                return false;
	            return _.isEqual(x.objects, y.objects);
	        }
	        VisualObjectRepetition.equals = equals;
	    })(VisualObjectRepetition = powerbi.VisualObjectRepetition || (powerbi.VisualObjectRepetition = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 223 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
	        var DataRoleHelper = powerbi.data.DataRoleHelper;
	        var ForecastHelper;
	        (function (ForecastHelper) {
	            var ForecastPropertyNames;
	            (function (ForecastPropertyNames) {
	                ForecastPropertyNames.show = 'show';
	                ForecastPropertyNames.lineColor = 'lineColor';
	                ForecastPropertyNames.confidenceBandStyle = 'confidenceBandStyle';
	                ForecastPropertyNames.transparency = 'transparency';
	                ForecastPropertyNames.style = 'style';
	            })(ForecastPropertyNames || (ForecastPropertyNames = {}));
	            var forecastObjectName = 'forecast';
	            var forecastValueRole = 'forecast.ForecastValue';
	            var forecastConfidenceHighBoundRole = 'forecast.ConfidenceHighBound';
	            var forecastConfidenceLowBoundRole = 'forecast.ConfidenceLowBound';
	            ForecastHelper.defaults = {
	                lineColor: { solid: { color: '#000' } },
	                confidenceBandStyle: visuals.confidenceBandStyle.fill,
	                transparency: 80,
	                style: visuals.lineStyle.solid
	            };
	            var ForecastClassSelector = createClassAndSelector('forecast-line');
	            var ForecastErrorRangeClassSelector = createClassAndSelector('forecast-error-range');
	            var ForecastLayerClassSelector = createClassAndSelector('forecast-line-layer');
	            function enumerateObjectInstances(enumeration, forecast) {
	                debug.assertValue(enumeration, 'enumeration');
	                if (!forecast) {
	                    enumeration.pushInstance({
	                        selector: {
	                            id: '0'
	                        },
	                        properties: {
	                            show: false,
	                            lineColor: ForecastHelper.defaults.lineColor,
	                            confidenceBandStyle: ForecastHelper.defaults.confidenceBandStyle,
	                            transparency: ForecastHelper.defaults.transparency,
	                            style: ForecastHelper.defaults.style
	                        },
	                        objectName: forecastObjectName,
	                    });
	                    return;
	                }
	                var properties = (_a = {},
	                    _a[ForecastPropertyNames.show] = forecast.show,
	                    _a[ForecastPropertyNames.lineColor] = forecast.lineColor,
	                    _a[ForecastPropertyNames.confidenceBandStyle] = forecast.confidenceBandStyle,
	                    _a[ForecastPropertyNames.transparency] = forecast.transparency,
	                    _a[ForecastPropertyNames.style] = forecast.style,
	                    _a
	                );
	                enumeration.pushInstance({
	                    selector: {
	                        id: forecast.id
	                    },
	                    properties: properties,
	                    objectName: forecastObjectName,
	                });
	                var _a;
	            }
	            ForecastHelper.enumerateObjectInstances = enumerateObjectInstances;
	            function isDataViewForForecast(dataView) {
	                if (!dataView || !dataView.categorical || !dataView.categorical.values)
	                    return false;
	                var grouped = dataView.categorical.values.grouped();
	                for (var _i = 0, grouped_1 = grouped; _i < grouped_1.length; _i++) {
	                    var group = grouped_1[_i];
	                    var hasRole = _.any(group.values, function (value) { return DataRoleHelper.hasRoleInValueColumn(value, 'forecast.ForecastValue'); });
	                    if (hasRole)
	                        return true;
	                }
	                return false;
	            }
	            ForecastHelper.isDataViewForForecast = isDataViewForForecast;
	            function readDataView(dataView, sourceDataView, colors) {
	                if (!dataView || !dataView.categorical || !sourceDataView || !sourceDataView.categorical)
	                    return;
	                var categorical = dataView.categorical;
	                if (_.isEmpty(categorical.categories) || _.isEmpty(categorical.values))
	                    return;
	                var categories = categorical.categories[0].values;
	                var groups = categorical.values.grouped();
	                if (!categories || !groups)
	                    return;
	                var valueColumnIndex = DataRoleHelper.getMeasureIndexOfRole(groups, forecastValueRole);
	                var upperBoundColumnIndex = DataRoleHelper.getMeasureIndexOfRole(groups, forecastConfidenceHighBoundRole);
	                var lowerBoundColumnIndex = DataRoleHelper.getMeasureIndexOfRole(groups, forecastConfidenceLowBoundRole);
	                var forecastLines = [];
	                var forecastProperties = powerbi.DataViewObjects.getUserDefinedObjects(dataView.metadata.objects, forecastObjectName);
	                var groupIndex = 0;
	                for (var _i = 0, forecastProperties_1 = forecastProperties; _i < forecastProperties_1.length; _i++) {
	                    var forecastProperty = forecastProperties_1[_i];
	                    var forecastObjects = forecastProperty.object;
	                    var show = powerbi.DataViewObject.getValue(forecastObjects, ForecastPropertyNames.show, false);
	                    var lineColor = powerbi.DataViewObject.getValue(forecastObjects, ForecastPropertyNames.lineColor, ForecastHelper.defaults.lineColor);
	                    var confidenceBandStyle_1 = powerbi.DataViewObject.getValue(forecastObjects, ForecastPropertyNames.confidenceBandStyle, ForecastHelper.defaults.confidenceBandStyle);
	                    var transparency = powerbi.DataViewObject.getValue(forecastObjects, ForecastPropertyNames.transparency, ForecastHelper.defaults.transparency);
	                    var style = powerbi.DataViewObject.getValue(forecastObjects, ForecastPropertyNames.style, ForecastHelper.defaults.style);
	                    var colorHelper = new visuals.ColorHelper(colors, { objectName: 'dataPoint', propertyName: 'fill' }, ForecastHelper.defaults.lineColor.solid.color);
	                    var group = groups[groupIndex];
	                    var points = [];
	                    var values = group.values[valueColumnIndex].highlights ? group.values[valueColumnIndex].highlights : group.values[valueColumnIndex].values;
	                    var upperBoundValues = group.values[upperBoundColumnIndex].highlights ? group.values[upperBoundColumnIndex].highlights : group.values[upperBoundColumnIndex].values;
	                    var lowerBoundValues = group.values[lowerBoundColumnIndex].highlights ? group.values[lowerBoundColumnIndex].highlights : group.values[lowerBoundColumnIndex].values;
	                    for (var i = 0; i < categories.length; i++) {
	                        var x = visuals.AxisHelper.normalizeNonFiniteNumber(categories[i]);
	                        var y = visuals.AxisHelper.normalizeNonFiniteNumber(values[i]);
	                        if (x != null && y != null) {
	                            var upperBoundY = visuals.AxisHelper.normalizeNonFiniteNumber(upperBoundValues[i]);
	                            var lowerBoundY = visuals.AxisHelper.normalizeNonFiniteNumber(lowerBoundValues[i]);
	                            points.push({
	                                point: { x: x, y: y },
	                                upperBound: { x: x, y: upperBoundY },
	                                lowerBound: { x: x, y: lowerBoundY },
	                            });
	                        }
	                    }
	                    var seriesLineColor = void 0;
	                    if (lineColor) {
	                        seriesLineColor = lineColor;
	                    }
	                    else {
	                        if (sourceDataView.categorical.values.source) {
	                            // Dynamic series
	                            var sourceGroups = sourceDataView.categorical.values.grouped();
	                            var color = colorHelper.getColorForSeriesValue(sourceGroups[groupIndex].objects, sourceDataView.categorical.values.identityFields, group.name);
	                            seriesLineColor = { solid: { color: color } };
	                        }
	                        else {
	                            // Static series
	                            var matchingMeasure = sourceDataView.categorical.values[groupIndex];
	                            var color = colorHelper.getColorForMeasure(matchingMeasure.source.objects, group.name);
	                            seriesLineColor = { solid: { color: color } };
	                        }
	                    }
	                    forecastLines.push({
	                        id: forecastProperty.id,
	                        points: points,
	                        show: show,
	                        lineColor: seriesLineColor,
	                        confidenceBandStyle: confidenceBandStyle_1,
	                        transparency: transparency,
	                        style: style
	                    });
	                    groupIndex++;
	                }
	                return forecastLines[0];
	            }
	            ForecastHelper.readDataView = readDataView;
	            function render(forecastLine, graphicsContext, axes, viewport, animator, suppressAnimations) {
	                var duration = visuals.AnimatorCommon.GetAnimationDuration(animator, suppressAnimations);
	                var layer = graphicsContext.select(ForecastLayerClassSelector.selector);
	                if (layer.empty()) {
	                    layer = graphicsContext.insert('svg', ':first-child').classed(ForecastLayerClassSelector.class, true);
	                }
	                layer.attr({
	                    height: viewport.height,
	                    width: viewport.width
	                });
	                var errorRange = layer.selectAll(ForecastErrorRangeClassSelector.selector).data(forecastLine ? [forecastLine] : []);
	                errorRange.enter().insert('path', ':first-child').classed(ForecastErrorRangeClassSelector.class, true);
	                errorRange
	                    .transition()
	                    .ease('linear')
	                    .duration(duration)
	                    .attr('d', function (d) {
	                    var xScale = axes.x.scale;
	                    var yScale = axes.y1.scale;
	                    var pathGen = d3.svg.area()
	                        .x(function (point) { return xScale(point.upperBound.x); })
	                        .y0(function (point) { return yScale(point.upperBound.y); })
	                        .y1(function (point) { return yScale(point.lowerBound.y); });
	                    return pathGen(d.points);
	                });
	                errorRange.each(function (d) {
	                    var errorRangeArea = d3.select(this);
	                    var style = {};
	                    var opacity = (100 - d.transparency) / 100;
	                    style['fill-opacity'] = opacity;
	                    style['stroke-opacity'] = opacity;
	                    if (d.confidenceBandStyle === visuals.confidenceBandStyle.fill) {
	                        style['stroke'] = 'transparent';
	                        style['fill'] = d.lineColor.solid.color;
	                    }
	                    else if (d.confidenceBandStyle === visuals.confidenceBandStyle.line) {
	                        style['stroke'] = d.lineColor.solid.color;
	                        style['fill'] = 'transparent';
	                    }
	                    else if (d.confidenceBandStyle === visuals.confidenceBandStyle.none) {
	                        style['stroke'] = 'transparent';
	                        style['fill'] = 'transparent';
	                    }
	                    errorRangeArea.style(style);
	                });
	                errorRange.exit().remove();
	                var lines = layer.selectAll(ForecastClassSelector.selector).data(forecastLine ? [forecastLine] : []);
	                lines.enter().append('path').classed(ForecastClassSelector.class, true);
	                lines
	                    .transition()
	                    .ease('linear')
	                    .duration(duration)
	                    .attr('d', function (d) {
	                    var xScale = axes.x.scale;
	                    var yScale = axes.y1.scale;
	                    var pathGen = d3.svg.line()
	                        .x(function (point) { return xScale(point.point.x); })
	                        .y(function (point) { return yScale(point.point.y); });
	                    return pathGen(_.filter(d.points, function (point) { return point.point.x != null && point.point.y != null; }));
	                });
	                lines.each(function (d) {
	                    var line = d3.select(this);
	                    var style = {};
	                    style['stroke'] = d.lineColor.solid.color;
	                    style['fill'] = 'transparent';
	                    if (d.style === visuals.lineStyle.dashed) {
	                        style['stroke-dasharray'] = '5, 5';
	                    }
	                    else if (d.style === visuals.lineStyle.dotted) {
	                        style['stroke-dasharray'] = '1, 5';
	                        style['stroke-linecap'] = "round";
	                    }
	                    else if (d.style === visuals.lineStyle.solid) {
	                        style['stroke-dasharray'] = null;
	                        style['stroke-linecap'] = null;
	                    }
	                    line.style(style);
	                });
	                lines.exit().remove();
	            }
	            ForecastHelper.render = render;
	        })(ForecastHelper = visuals.ForecastHelper || (visuals.ForecastHelper = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 224 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var DefaultSQExprVisitor = powerbi.data.DefaultSQExprVisitor;
	        var SemanticFilter = powerbi.data.SemanticFilter;
	        var UrlUtils = jsCommon.UrlUtils;
	        /** Helper module for converting a DataView into SlicerData. */
	        var DataConversion;
	        (function (DataConversion) {
	            function convert(dataView, localizedSelectAllText, interactivityService, hostServices) {
	                debug.assertValue(hostServices, 'hostServices');
	                if (!dataView || !dataView.categorical || _.isEmpty(dataView.categorical.categories))
	                    return;
	                var identityFields = dataView.categorical.categories[0].identityFields;
	                if (!identityFields)
	                    return;
	                var filter = (dataView.metadata &&
	                    dataView.metadata.objects &&
	                    powerbi.DataViewObjects.getValue(dataView.metadata.objects, visuals.slicerProps.filterPropertyIdentifier));
	                var analyzer = hostServices.analyzeFilter({
	                    dataView: dataView,
	                    defaultValuePropertyId: visuals.slicerProps.defaultValue,
	                    filter: filter,
	                    fieldSQExprs: identityFields
	                });
	                if (!analyzer)
	                    return;
	                var analyzedSemanticFilter = analyzer.filter;
	                if (analyzedSemanticFilter && !SemanticFilter.isSameFilter(analyzedSemanticFilter, filter)) {
	                    interactivityService.handleClearSelection();
	                    var filterPropertyIdentifier = visuals.slicerProps.filterPropertyIdentifier;
	                    var properties = {};
	                    properties[filterPropertyIdentifier.propertyName] = analyzer.filter;
	                    var instance = {
	                        objectName: filterPropertyIdentifier.objectName,
	                        selector: undefined,
	                        properties: properties
	                    };
	                    var changes = {
	                        merge: [instance]
	                    };
	                    hostServices.persistProperties(changes);
	                }
	                var slicerData = getSlicerData(analyzer, dataView.metadata, dataView.categorical, localizedSelectAllText, interactivityService, hostServices);
	                return slicerData;
	            }
	            DataConversion.convert = convert;
	            function getSlicerData(analyzer, dataViewMetadata, categorical, localizedSelectAllText, interactivityService, hostServices) {
	                var isInvertedSelectionMode = interactivityService && interactivityService.isSelectionModeInverted();
	                var selectedScopeIds = analyzer.selectedIdentities;
	                var hasSelectionOverride = !_.isEmpty(selectedScopeIds) || isInvertedSelectionMode === true;
	                if (!isInvertedSelectionMode && analyzer.filter)
	                    isInvertedSelectionMode = analyzer.isNotFilter;
	                if (interactivityService) {
	                    // To indicate whether the selection is Not selected items
	                    interactivityService.setSelectionModeInverted(isInvertedSelectionMode);
	                    // defaultValueMode will be used when determine show/hide clear button.
	                    interactivityService.setDefaultValueMode(SemanticFilter.isDefaultFilter(analyzer.filter));
	                }
	                var category = categorical.categories[0];
	                var categoryValuesLen = category && category.values ? category.values.length : 0;
	                var slicerDataPoints = [];
	                var formatString = visuals.valueFormatter.getFormatString(category.source, visuals.slicerProps.formatString);
	                var numOfSelected = 0;
	                var valueCounts = categorical.values && categorical.values[0] && categorical.values[0].values;
	                if (valueCounts && _.isEmpty(valueCounts))
	                    valueCounts = undefined;
	                debug.assert(!valueCounts || valueCounts.length === categoryValuesLen, "valueCounts doesn't match values");
	                var isImageData = dataViewMetadata &&
	                    !_.isEmpty(dataViewMetadata.columns) && visuals.converterHelper.isImageUrlColumn(dataViewMetadata.columns[0]);
	                var displayNameIdentityPairs = [];
	                for (var i = 0; i < categoryValuesLen; i++) {
	                    var scopeId = category.identity && category.identity[i];
	                    var value = category.values && category.values[i];
	                    var count = valueCounts && valueCounts[i];
	                    var isRetained = hasSelectionOverride ? visuals.SlicerUtil.tryRemoveValueFromRetainedList(scopeId, selectedScopeIds) : false;
	                    var label = visuals.valueFormatter.format(value, formatString);
	                    var isImage = isImageData === true && UrlUtils.isValidImageUrl(label);
	                    var slicerData_1 = {
	                        value: label,
	                        tooltip: label,
	                        identity: visuals.SelectionIdBuilder.builder().withCategory(category, i).createSelectionId(),
	                        selected: isRetained,
	                        count: count,
	                        isImage: isImage,
	                    };
	                    if (isRetained) {
	                        var displayNameIdentityPair = {
	                            displayName: label,
	                            identity: scopeId
	                        };
	                        displayNameIdentityPairs.push(displayNameIdentityPair);
	                    }
	                    slicerDataPoints.push(slicerData_1);
	                    if (slicerData_1.selected)
	                        numOfSelected++;
	                }
	                if (!_.isEmpty(displayNameIdentityPairs))
	                    hostServices.setIdentityDisplayNames(displayNameIdentityPairs);
	                // Add retained values that are not in the returned dataview to the value list.
	                if (hasSelectionOverride && !_.isEmpty(selectedScopeIds)) {
	                    var displayNamesIdentityPairs = hostServices.getIdentityDisplayNames(selectedScopeIds);
	                    if (!_.isEmpty(displayNamesIdentityPairs)) {
	                        for (var _i = 0, displayNamesIdentityPairs_1 = displayNamesIdentityPairs; _i < displayNamesIdentityPairs_1.length; _i++) {
	                            var pair = displayNamesIdentityPairs_1[_i];
	                            // When there is no valueCounts, set count to be undefined, otherwise use 0 as the count for retained values
	                            var slicerData_2 = {
	                                value: pair.displayName,
	                                tooltip: pair.displayName,
	                                identity: visuals.SelectionIdBuilder.builder().withCategoryIdentity(category, pair.identity).createSelectionId(),
	                                selected: true,
	                                count: valueCounts != null ? 0 : undefined,
	                            };
	                            slicerDataPoints.push(slicerData_2);
	                            numOfSelected++;
	                        }
	                    }
	                }
	                var searchKey = getSearchKey(dataViewMetadata);
	                var defaultSettings = createDefaultSettings(dataViewMetadata);
	                // When search is on, we hide the SelectAll option.
	                if (defaultSettings.selection.selectAllCheckboxEnabled && _.isEmpty(searchKey)) {
	                    slicerDataPoints.unshift({
	                        value: localizedSelectAllText,
	                        tooltip: localizedSelectAllText,
	                        identity: visuals.SelectionId.createWithMeasure(localizedSelectAllText),
	                        selected: !!isInvertedSelectionMode && numOfSelected === 0,
	                        isSelectAllDataPoint: true,
	                        count: undefined,
	                    });
	                }
	                var slicerData = {
	                    categorySourceName: category.source.displayName,
	                    slicerSettings: defaultSettings,
	                    slicerDataPoints: slicerDataPoints,
	                    hasSelectionOverride: hasSelectionOverride,
	                    defaultValue: analyzer.defaultValue,
	                    searchKey: searchKey,
	                };
	                return slicerData;
	            }
	            function getSearchKey(dataViewMetadata) {
	                var selfFilter = powerbi.DataViewObjects.getValue(dataViewMetadata.objects, visuals.slicerProps.selfFilterPropertyIdentifier, undefined);
	                // The searchKey need to be empty string so that the inputbox dom content gets updated after search is removed.
	                // When the search key is undefined, the previous content will not updated while binding data.
	                if (!selfFilter)
	                    return '';
	                var filterItems = selfFilter.conditions();
	                debug.assert(filterItems.length === 1, 'There should be exactly 1 filter expression.');
	                var containsFilter = filterItems[0];
	                if (containsFilter) {
	                    var containsValueVisitor = new ConditionsFilterValueVisitor();
	                    containsFilter.accept(containsValueVisitor);
	                    return containsValueVisitor.getValueForField();
	                }
	            }
	            function createDefaultSettings(dataViewMetadata) {
	                var defaultSettings = visuals.Slicer.DefaultStyleProperties();
	                var objects = dataViewMetadata.objects;
	                var forceSingleSelect = dataViewMetadata.columns && _.some(dataViewMetadata.columns, function (column) { return column.discourageAggregationAcrossGroups; });
	                if (objects) {
	                    defaultSettings.general.outlineColor = powerbi.DataViewObjects.getFillColor(objects, visuals.slicerProps.general.outlineColor, defaultSettings.general.outlineColor);
	                    defaultSettings.general.outlineWeight = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.general.outlineWeight, defaultSettings.general.outlineWeight);
	                    defaultSettings.general.orientation = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.general.orientation, defaultSettings.general.orientation);
	                    defaultSettings.header.show = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.header.show, defaultSettings.header.show);
	                    defaultSettings.header.fontColor = powerbi.DataViewObjects.getFillColor(objects, visuals.slicerProps.header.fontColor, defaultSettings.header.fontColor);
	                    var headerBackground = powerbi.DataViewObjects.getFillColor(objects, visuals.slicerProps.header.background);
	                    if (headerBackground)
	                        defaultSettings.header.background = headerBackground;
	                    defaultSettings.header.outline = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.header.outline, defaultSettings.header.outline);
	                    defaultSettings.header.textSize = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.header.textSize, defaultSettings.header.textSize);
	                    defaultSettings.slicerText.color = powerbi.DataViewObjects.getFillColor(objects, visuals.slicerProps.items.fontColor, defaultSettings.slicerText.color);
	                    var textBackground = powerbi.DataViewObjects.getFillColor(objects, visuals.slicerProps.items.background);
	                    if (textBackground)
	                        defaultSettings.slicerText.background = textBackground;
	                    defaultSettings.slicerText.outline = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.items.outline, defaultSettings.slicerText.outline);
	                    defaultSettings.slicerText.textSize = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.items.textSize, defaultSettings.slicerText.textSize);
	                    defaultSettings.selection.selectAllCheckboxEnabled = !forceSingleSelect && powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.selection.selectAllCheckboxEnabled, defaultSettings.selection.selectAllCheckboxEnabled);
	                    defaultSettings.selection.singleSelect = forceSingleSelect || powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.selection.singleSelect, defaultSettings.selection.singleSelect);
	                    defaultSettings.search.enabled = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.general.selfFilterEnabled, defaultSettings.search.enabled);
	                }
	                return defaultSettings;
	            }
	            var ConditionsFilterValueVisitor = (function (_super) {
	                __extends(ConditionsFilterValueVisitor, _super);
	                function ConditionsFilterValueVisitor() {
	                    _super.apply(this, arguments);
	                }
	                ConditionsFilterValueVisitor.prototype.visitConstant = function (expr) {
	                    if (expr.type && expr.type.text)
	                        this.value = expr.value;
	                };
	                ConditionsFilterValueVisitor.prototype.visitContains = function (expr) {
	                    expr.left.accept(this);
	                    expr.right.accept(this);
	                };
	                ConditionsFilterValueVisitor.prototype.visitColumnRef = function (expr) {
	                    this.fieldExpr = expr;
	                };
	                ConditionsFilterValueVisitor.prototype.visitDefault = function (expr) {
	                    this.value = undefined;
	                    this.fieldExpr = undefined;
	                };
	                ConditionsFilterValueVisitor.prototype.getValueForField = function () {
	                    return this.fieldExpr && this.value;
	                };
	                return ConditionsFilterValueVisitor;
	            }(DefaultSQExprVisitor));
	        })(DataConversion = visuals.DataConversion || (visuals.DataConversion = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 225 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var shapes = powerbi.visuals.shapes;
	    /**
	    * Rectangle orientation. Rectangle orientation is used to define vertical or horizontal orientation
	    * and starting/ending side of the rectangle.
	    */
	    (function (RectOrientation) {
	        /** Rectangle with no specific orientation. */
	        RectOrientation[RectOrientation["None"] = 0] = "None";
	        /** Vertical rectangle with base at the bottom. */
	        RectOrientation[RectOrientation["VerticalBottomTop"] = 1] = "VerticalBottomTop";
	        /** Vertical rectangle with base at the top. */
	        RectOrientation[RectOrientation["VerticalTopBottom"] = 2] = "VerticalTopBottom";
	        /** Horizontal rectangle with base at the left. */
	        RectOrientation[RectOrientation["HorizontalLeftRight"] = 3] = "HorizontalLeftRight";
	        /** Horizontal rectangle with base at the right. */
	        RectOrientation[RectOrientation["HorizontalRightLeft"] = 4] = "HorizontalRightLeft";
	    })(powerbi.RectOrientation || (powerbi.RectOrientation = {}));
	    var RectOrientation = powerbi.RectOrientation;
	    /**
	    * Defines if panel elements are allowed to be positioned
	    * outside of the panel boundaries.
	    */
	    (function (OutsidePlacement) {
	        /** Elements can be positioned outside of the panel. */
	        OutsidePlacement[OutsidePlacement["Allowed"] = 0] = "Allowed";
	        /** Elements can not be positioned outside of the panel. */
	        OutsidePlacement[OutsidePlacement["Disallowed"] = 1] = "Disallowed";
	        /** Elements can be partially outside of the panel. */
	        OutsidePlacement[OutsidePlacement["Partial"] = 2] = "Partial";
	    })(powerbi.OutsidePlacement || (powerbi.OutsidePlacement = {}));
	    var OutsidePlacement = powerbi.OutsidePlacement;
	    /**
	    * Arranges label elements using the anchor point or rectangle. Collisions
	    * between elements can be automatically detected and as a result elements
	    * can be repositioned or get hidden.
	    */
	    var DataLabelManager = (function () {
	        function DataLabelManager() {
	            this.movingStep = 3;
	            this.hideOverlapped = true;
	            // The global settings for all labels. 
	            // They can be oweridden by each label we add into the panel, because contains same properties.
	            this.defaultDataLabelSettings = {
	                anchorMargin: DataLabelManager.DefaultAnchorMargin,
	                anchorRectOrientation: RectOrientation.None,
	                contentPosition: 128 /* BottomCenter */,
	                outsidePlacement: OutsidePlacement.Disallowed,
	                maximumMovingDistance: DataLabelManager.DefaultMaximumMovingDistance,
	                minimumMovingDistance: DataLabelManager.DefaultMinimumMovingDistance,
	                validContentPositions: 128 /* BottomCenter */,
	                opacity: 1
	            };
	        }
	        Object.defineProperty(DataLabelManager.prototype, "defaultSettings", {
	            get: function () {
	                return this.defaultDataLabelSettings;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /** Arranges the lables position and visibility*/
	        DataLabelManager.prototype.hideCollidedLabels = function (viewport, data, layout, addTransform) {
	            if (addTransform === void 0) { addTransform = false; }
	            // Split size into a grid
	            var arrangeGrid = new DataLabelArrangeGrid(viewport, data, layout);
	            var filteredData = [];
	            var transform = { x: 0, y: 0 };
	            if (addTransform) {
	                transform.x = viewport.width / 2;
	                transform.y = viewport.height / 2;
	            }
	            for (var i = 0, len = data.length; i < len; i++) {
	                // Filter unwanted data points
	                if (!layout.filter(data[i]))
	                    continue;
	                // Set default values where properties values are undefined
	                var info = this.getLabelInfo(data[i]);
	                info.anchorPoint = {
	                    x: layout.labelLayout.x(data[i]) + transform.x,
	                    y: layout.labelLayout.y(data[i]) + transform.y,
	                };
	                var position = this.calculateContentPosition(info, info.contentPosition, data[i].size, info.anchorMargin);
	                if (DataLabelManager.isValid(position) && !this.hasCollisions(arrangeGrid, info, position, viewport)) {
	                    data[i].labelX = position.left - transform.x;
	                    data[i].labelY = position.top - transform.y;
	                    // Keep track of all panel elements positions.
	                    arrangeGrid.add(info, position);
	                    // Save all data points to display
	                    filteredData.push(data[i]);
	                }
	            }
	            return filteredData;
	        };
	        /**
	         * Merges the label element info with the panel element info and returns correct label info.
	         * @param source The label info.
	         */
	        DataLabelManager.prototype.getLabelInfo = function (source) {
	            var settings = this.defaultDataLabelSettings;
	            source.anchorMargin = source.anchorMargin !== undefined ? source.anchorMargin : settings.anchorMargin;
	            source.anchorRectOrientation = source.anchorRectOrientation !== undefined ? source.anchorRectOrientation : settings.anchorRectOrientation;
	            source.contentPosition = source.contentPosition !== undefined ? source.contentPosition : settings.contentPosition;
	            source.maximumMovingDistance = source.maximumMovingDistance !== undefined ? source.maximumMovingDistance : settings.maximumMovingDistance;
	            source.minimumMovingDistance = source.minimumMovingDistance !== undefined ? source.minimumMovingDistance : settings.minimumMovingDistance;
	            source.outsidePlacement = source.outsidePlacement !== undefined ? source.outsidePlacement : settings.outsidePlacement;
	            source.validContentPositions = source.validContentPositions !== undefined ? source.validContentPositions : settings.validContentPositions;
	            source.opacity = source.opacity !== undefined ? source.opacity : settings.opacity;
	            source.maximumMovingDistance += source.anchorMargin;
	            return source;
	        };
	        /**
	        * (Private) Calculates element position using anchor point..
	        */
	        DataLabelManager.prototype.calculateContentPositionFromPoint = function (anchorPoint, contentPosition, contentSize, offset) {
	            var position = { x: 0, y: 0 };
	            if (anchorPoint) {
	                if (anchorPoint.x !== undefined && isFinite(anchorPoint.x)) {
	                    position.x = anchorPoint.x;
	                    switch (contentPosition) {
	                        // D3 positions the label in the middle by default.
	                        // The algorithem asumed the label was positioned in right so this is why we add/substract half width
	                        case 1 /* TopLeft */:
	                        case 8 /* MiddleLeft */:
	                        case 64 /* BottomLeft */:
	                            position.x -= contentSize.width / 2.0;
	                            break;
	                        case 4 /* TopRight */:
	                        case 32 /* MiddleRight */:
	                        case 256 /* BottomRight */:
	                            position.x += contentSize.width / 2.0;
	                            break;
	                    }
	                }
	                if (anchorPoint.y !== undefined && isFinite(anchorPoint.y)) {
	                    position.y = anchorPoint.y;
	                    switch (contentPosition) {
	                        case 8 /* MiddleLeft */:
	                        case 16 /* MiddleCenter */:
	                        case 32 /* MiddleRight */:
	                            position.y -= contentSize.height / 2.0;
	                            break;
	                        case 4 /* TopRight */:
	                        case 1 /* TopLeft */:
	                        case 2 /* TopCenter */:
	                            position.y -= contentSize.height;
	                            break;
	                    }
	                }
	                if (offset !== undefined && isFinite(offset)) {
	                    switch (contentPosition) {
	                        case 1 /* TopLeft */:
	                            position.x -= offset;
	                            position.y -= offset;
	                            break;
	                        case 8 /* MiddleLeft */:
	                            position.x -= offset;
	                            break;
	                        case 64 /* BottomLeft */:
	                            position.x -= offset;
	                            position.y += offset;
	                            break;
	                        case 2 /* TopCenter */:
	                            position.y -= offset;
	                            break;
	                        case 16 /* MiddleCenter */:
	                            // Offset is not applied
	                            break;
	                        case 128 /* BottomCenter */:
	                            position.y += offset;
	                            break;
	                        case 4 /* TopRight */:
	                            position.x += offset;
	                            position.y -= offset;
	                            break;
	                        case 32 /* MiddleRight */:
	                            position.x += offset;
	                            break;
	                        case 256 /* BottomRight */:
	                            position.x += offset;
	                            position.y += offset;
	                            break;
	                        default:
	                            debug.assertFail("Unsupported content position.");
	                            break;
	                    }
	                }
	            }
	            return { left: position.x, top: position.y, width: contentSize.width, height: contentSize.height };
	        };
	        /** (Private) Calculates element position using anchor rect. */
	        DataLabelManager.prototype.calculateContentPositionFromRect = function (anchorRect, anchorRectOrientation, contentPosition, contentSize, offset) {
	            switch (contentPosition) {
	                case 512 /* InsideCenter */:
	                    return this.handleInsideCenterPosition(anchorRectOrientation, contentSize, anchorRect, offset);
	                case 2048 /* InsideEnd */:
	                    return this.handleInsideEndPosition(anchorRectOrientation, contentSize, anchorRect, offset);
	                case 1024 /* InsideBase */:
	                    return this.handleInsideBasePosition(anchorRectOrientation, contentSize, anchorRect, offset);
	                case 8192 /* OutsideEnd */:
	                    return this.handleOutsideEndPosition(anchorRectOrientation, contentSize, anchorRect, offset);
	                case 4096 /* OutsideBase */:
	                    return this.handleOutsideBasePosition(anchorRectOrientation, contentSize, anchorRect, offset);
	                default:
	                    debug.assertFail("Unsupported ContentPosition.");
	            }
	            return { left: 0, top: 0, width: -1, height: -1 };
	        };
	        /** (Private) Calculates element inside center position using anchor rect. */
	        DataLabelManager.prototype.handleInsideCenterPosition = function (anchorRectOrientation, contentSize, anchorRect, offset) {
	            switch (anchorRectOrientation) {
	                case RectOrientation.VerticalBottomTop:
	                case RectOrientation.VerticalTopBottom:
	                    return LocationConverter.middleVertical(contentSize, anchorRect, offset);
	                case RectOrientation.HorizontalLeftRight:
	                case RectOrientation.HorizontalRightLeft:
	                default:
	                    return LocationConverter.middleHorizontal(contentSize, anchorRect, offset);
	            }
	        };
	        /** (Private) Calculates element inside end position using anchor rect. */
	        DataLabelManager.prototype.handleInsideEndPosition = function (anchorRectOrientation, contentSize, anchorRect, offset) {
	            switch (anchorRectOrientation) {
	                case RectOrientation.VerticalBottomTop:
	                    return LocationConverter.topInside(contentSize, anchorRect, offset);
	                case RectOrientation.VerticalTopBottom:
	                    return LocationConverter.bottomInside(contentSize, anchorRect, offset);
	                case RectOrientation.HorizontalRightLeft:
	                    return LocationConverter.leftInside(contentSize, anchorRect, offset);
	                case RectOrientation.HorizontalLeftRight:
	                default:
	                    return LocationConverter.rightInside(contentSize, anchorRect, offset);
	            }
	        };
	        /** (Private) Calculates element inside base position using anchor rect. */
	        DataLabelManager.prototype.handleInsideBasePosition = function (anchorRectOrientation, contentSize, anchorRect, offset) {
	            switch (anchorRectOrientation) {
	                case RectOrientation.VerticalBottomTop:
	                    return LocationConverter.bottomInside(contentSize, anchorRect, offset);
	                case RectOrientation.VerticalTopBottom:
	                    return LocationConverter.topInside(contentSize, anchorRect, offset);
	                case RectOrientation.HorizontalRightLeft:
	                    return LocationConverter.rightInside(contentSize, anchorRect, offset);
	                case RectOrientation.HorizontalLeftRight:
	                default:
	                    return LocationConverter.leftInside(contentSize, anchorRect, offset);
	            }
	        };
	        /** (Private) Calculates element outside end position using anchor rect. */
	        DataLabelManager.prototype.handleOutsideEndPosition = function (anchorRectOrientation, contentSize, anchorRect, offset) {
	            switch (anchorRectOrientation) {
	                case RectOrientation.VerticalBottomTop:
	                    return LocationConverter.topOutside(contentSize, anchorRect, offset);
	                case RectOrientation.VerticalTopBottom:
	                    return LocationConverter.bottomOutside(contentSize, anchorRect, offset);
	                case RectOrientation.HorizontalRightLeft:
	                    return LocationConverter.leftOutside(contentSize, anchorRect, offset);
	                case RectOrientation.HorizontalLeftRight:
	                default:
	                    return LocationConverter.rightOutside(contentSize, anchorRect, offset);
	            }
	        };
	        /** (Private) Calculates element outside base position using anchor rect. */
	        DataLabelManager.prototype.handleOutsideBasePosition = function (anchorRectOrientation, contentSize, anchorRect, offset) {
	            switch (anchorRectOrientation) {
	                case RectOrientation.VerticalBottomTop:
	                    return LocationConverter.bottomOutside(contentSize, anchorRect, offset);
	                case RectOrientation.VerticalTopBottom:
	                    return LocationConverter.topOutside(contentSize, anchorRect, offset);
	                case RectOrientation.HorizontalRightLeft:
	                    return LocationConverter.rightOutside(contentSize, anchorRect, offset);
	                case RectOrientation.HorizontalLeftRight:
	                default:
	                    return LocationConverter.leftOutside(contentSize, anchorRect, offset);
	            }
	        };
	        /**  (Private) Calculates element position. */
	        DataLabelManager.prototype.calculateContentPosition = function (anchoredElementInfo, contentPosition, contentSize, offset) {
	            if (contentPosition !== 2048 /* InsideEnd */ &&
	                contentPosition !== 512 /* InsideCenter */ &&
	                contentPosition !== 1024 /* InsideBase */ &&
	                contentPosition !== 4096 /* OutsideBase */ &&
	                contentPosition !== 8192 /* OutsideEnd */) {
	                // Determine position using anchor point.
	                return this.calculateContentPositionFromPoint(anchoredElementInfo.anchorPoint, contentPosition, contentSize, offset);
	            }
	            // Determine position using anchor rectangle.
	            return this.calculateContentPositionFromRect(anchoredElementInfo.anchorRect, anchoredElementInfo.anchorRectOrientation, contentPosition, contentSize, offset);
	        };
	        /** (Private) Check for collisions. */
	        DataLabelManager.prototype.hasCollisions = function (arrangeGrid, info, position, size) {
	            var rect = shapes.Rect;
	            if (arrangeGrid.hasConflict(position)) {
	                return true;
	            }
	            // Since we divide the height by 2 we add it back to the top of the view port so labels won't be cut off
	            var intersection = { left: 0, top: position.height / 2, width: size.width, height: size.height };
	            intersection = rect.inflate(intersection, { left: DataLabelManager.InflateAmount, top: 0, right: DataLabelManager.InflateAmount, bottom: 0 });
	            intersection = rect.intersect(intersection, position);
	            if (rect.isEmpty(intersection))
	                // Empty rectangle means there is a collision
	                return true;
	            var lessWithPrecision = powerbi.Double.lessWithPrecision;
	            switch (info.outsidePlacement) {
	                // D3 positions the label in the middle by default.
	                // The algorithem asumed the label was positioned in right so this is why we devide by 2 or 4
	                case OutsidePlacement.Disallowed:
	                    return lessWithPrecision(intersection.width, position.width) ||
	                        lessWithPrecision(intersection.height, position.height / 2);
	                case OutsidePlacement.Partial:
	                    return lessWithPrecision(intersection.width, position.width / 2) ||
	                        lessWithPrecision(intersection.height, position.height / 4);
	            }
	            return false;
	        };
	        DataLabelManager.isValid = function (rect) {
	            return !shapes.Rect.isEmpty(rect) && (rect.width > 0 && rect.height > 0);
	        };
	        DataLabelManager.DefaultAnchorMargin = 0; // For future use
	        DataLabelManager.DefaultMaximumMovingDistance = 12;
	        DataLabelManager.DefaultMinimumMovingDistance = 3;
	        DataLabelManager.InflateAmount = 5;
	        return DataLabelManager;
	    }());
	    powerbi.DataLabelManager = DataLabelManager;
	    /**
	    * Utility class to speed up the conflict detection by collecting the arranged items in the DataLabelsPanel.
	    */
	    var DataLabelArrangeGrid = (function () {
	        /**
	         * Creates new ArrangeGrid.
	         * @param size The available size
	         */
	        function DataLabelArrangeGrid(size, elements, layout) {
	            this.grid = [];
	            if (size.width === 0 || size.height === 0) {
	                this.cellSize = size;
	                this.rowCount = this.colCount = 0;
	            }
	            var baseProperties = {
	                fontFamily: powerbi.visuals.dataLabelUtils.LabelTextProperties.fontFamily,
	                fontSize: powerbi.visuals.dataLabelUtils.LabelTextProperties.fontSize,
	                fontWeight: powerbi.visuals.dataLabelUtils.LabelTextProperties.fontWeight,
	            };
	            //sets the cell size to be twice of the Max with and Max height of the elements 
	            this.cellSize = { width: 0, height: 0 };
	            for (var i = 0, len = elements.length; i < len; i++) {
	                var child = elements[i];
	                // Fill label field
	                child.labeltext = layout.labelText(child);
	                var properties = powerbi.Prototype.inherit(baseProperties);
	                properties.text = child.labeltext;
	                properties.fontSize = (child.data) ? child.data.labelFontSize :
	                    child.labelFontSize ? child.labelFontSize : powerbi.visuals.dataLabelUtils.LabelTextProperties.fontSize;
	                child.size = {
	                    width: powerbi.TextMeasurementService.measureSvgTextWidth(properties),
	                    height: powerbi.TextMeasurementService.estimateSvgTextHeight(properties),
	                };
	                var w = child.size.width * 2;
	                var h = child.size.height * 2;
	                if (w > this.cellSize.width)
	                    this.cellSize.width = w;
	                if (h > this.cellSize.height)
	                    this.cellSize.height = h;
	            }
	            if (this.cellSize.width === 0)
	                this.cellSize.width = size.width;
	            if (this.cellSize.height === 0)
	                this.cellSize.height = size.height;
	            this.colCount = this.getGridRowColCount(this.cellSize.width, size.width, DataLabelArrangeGrid.ARRANGEGRID_MIN_COUNT, DataLabelArrangeGrid.ARRANGEGRID_MAX_COUNT);
	            this.rowCount = this.getGridRowColCount(this.cellSize.height, size.height, DataLabelArrangeGrid.ARRANGEGRID_MIN_COUNT, DataLabelArrangeGrid.ARRANGEGRID_MAX_COUNT);
	            this.cellSize.width = size.width / this.colCount;
	            this.cellSize.height = size.height / this.rowCount;
	            var grid = this.grid;
	            for (var x = 0; x < this.colCount; x++) {
	                grid[x] = [];
	                for (var y = 0; y < this.rowCount; y++) {
	                    grid[x][y] = [];
	                }
	            }
	        }
	        /**
	         * Register a new label element.
	         * @param element The label element to register.
	         * @param rect The label element position rectangle.
	         */
	        DataLabelArrangeGrid.prototype.add = function (element, rect) {
	            var indexRect = this.getGridIndexRect(rect);
	            var grid = this.grid;
	            for (var x = indexRect.left; x < indexRect.right; x++) {
	                for (var y = indexRect.top; y < indexRect.bottom; y++) {
	                    grid[x][y].push({ element: element, rect: rect });
	                }
	            }
	        };
	        /**
	         * Checks for conflict of given rectangle in registered elements.
	         * @param rect The rectengle to check.
	         * @return True if conflict is detected.
	         */
	        DataLabelArrangeGrid.prototype.hasConflict = function (rect) {
	            var indexRect = this.getGridIndexRect(rect);
	            var grid = this.grid;
	            var isIntersecting = shapes.Rect.isIntersecting;
	            for (var x = indexRect.left; x < indexRect.right; x++) {
	                for (var y = indexRect.top; y < indexRect.bottom; y++) {
	                    for (var z = 0; z < grid[x][y].length; z++) {
	                        var item = grid[x][y][z];
	                        if (isIntersecting(item.rect, rect)) {
	                            return true;
	                        }
	                    }
	                }
	            }
	            return false;
	        };
	        /**
	         * Calculates the number of rows or columns in a grid
	         * @param step is the largest label size (width or height)
	         * @param length is the grid size (width or height)
	         * @param minCount is the minimum allowed size
	         * @param maxCount is the maximum allowed size
	         * @return the number of grid rows or columns
	         */
	        DataLabelArrangeGrid.prototype.getGridRowColCount = function (step, length, minCount, maxCount) {
	            return Math.min(Math.max(Math.ceil(length / step), minCount), maxCount);
	        };
	        /**
	         * Returns the grid index of a given recangle
	         * @param rect The rectengle to check.
	         * @return grid index as a thickness object.
	         */
	        DataLabelArrangeGrid.prototype.getGridIndexRect = function (rect) {
	            var restrict = function (n, min, max) { return Math.min(Math.max(n, min), max); };
	            return {
	                left: restrict(Math.floor(rect.left / this.cellSize.width), 0, this.colCount),
	                top: restrict(Math.floor(rect.top / this.cellSize.height), 0, this.rowCount),
	                right: restrict(Math.ceil((rect.left + rect.width) / this.cellSize.width), 0, this.colCount),
	                bottom: restrict(Math.ceil((rect.top + rect.height) / this.cellSize.height), 0, this.rowCount)
	            };
	        };
	        DataLabelArrangeGrid.ARRANGEGRID_MIN_COUNT = 1;
	        DataLabelArrangeGrid.ARRANGEGRID_MAX_COUNT = 100;
	        return DataLabelArrangeGrid;
	    }());
	    powerbi.DataLabelArrangeGrid = DataLabelArrangeGrid;
	    /**
	    * (Private) Contains methods for calculating the top-left coordinate of rectangle based on content size and anchor rect.
	    */
	    var LocationConverter;
	    (function (LocationConverter) {
	        function topInside(size, rect, offset) {
	            return {
	                left: rect.left + rect.width / 2.0 - size.width / 2.0,
	                top: rect.top + offset,
	                width: size.width,
	                height: size.height
	            };
	        }
	        LocationConverter.topInside = topInside;
	        function bottomInside(size, rect, offset) {
	            return {
	                left: rect.left + rect.width / 2.0 - size.width / 2.0,
	                top: (rect.top + rect.height) - size.height - offset,
	                width: size.width,
	                height: size.height
	            };
	        }
	        LocationConverter.bottomInside = bottomInside;
	        function rightInside(size, rect, offset) {
	            return {
	                left: (rect.left + rect.width) - size.width - offset,
	                top: rect.top + rect.height / 2.0 - size.height / 2.0,
	                width: size.width,
	                height: size.height
	            };
	        }
	        LocationConverter.rightInside = rightInside;
	        function leftInside(size, rect, offset) {
	            return {
	                left: rect.left + offset,
	                top: rect.top + rect.height / 2.0 - size.height / 2.0,
	                width: size.width,
	                height: size.height
	            };
	        }
	        LocationConverter.leftInside = leftInside;
	        function topOutside(size, rect, offset) {
	            return {
	                left: rect.left + rect.width / 2.0 - size.width / 2.0,
	                top: rect.top - size.height - offset,
	                width: size.width,
	                height: size.height
	            };
	        }
	        LocationConverter.topOutside = topOutside;
	        function bottomOutside(size, rect, offset) {
	            return {
	                left: rect.left + rect.width / 2.0 - size.width / 2.0,
	                top: (rect.top + rect.height) + offset,
	                width: size.width,
	                height: size.height
	            };
	        }
	        LocationConverter.bottomOutside = bottomOutside;
	        function rightOutside(size, rect, offset) {
	            return {
	                left: (rect.left + rect.width) + offset,
	                top: rect.top + rect.height / 2.0 - size.height / 2.0,
	                width: size.width,
	                height: size.height
	            };
	        }
	        LocationConverter.rightOutside = rightOutside;
	        function leftOutside(size, rect, offset) {
	            return {
	                left: rect.left - size.width - offset,
	                top: rect.top + rect.height / 2.0 - size.height / 2.0,
	                width: size.width,
	                height: size.height
	            };
	        }
	        LocationConverter.leftOutside = leftOutside;
	        function middleHorizontal(size, rect, offset) {
	            return {
	                left: rect.left + rect.width / 2.0 - size.width / 2.0 + offset,
	                top: rect.top + rect.height / 2.0 - size.height / 2.0,
	                width: size.width,
	                height: size.height
	            };
	        }
	        LocationConverter.middleHorizontal = middleHorizontal;
	        function middleVertical(size, rect, offset) {
	            return {
	                left: rect.left + rect.width / 2.0 - size.width / 2.0,
	                top: rect.top + rect.height / 2.0 - size.height / 2.0 + offset,
	                width: size.width,
	                height: size.height
	            };
	        }
	        LocationConverter.middleVertical = middleVertical;
	    })(LocationConverter || (LocationConverter = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 226 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var shapes = powerbi.visuals.shapes;
	    var Rect = powerbi.visuals.shapes.Rect;
	    var NewDataLabelUtils = powerbi.visuals.NewDataLabelUtils;
	    var LabelArrangeGrid = (function () {
	        function LabelArrangeGrid(labelDataPointsGroups, viewport) {
	            this.viewport = viewport;
	            var maxLabelWidth = 0;
	            var maxLabelHeight = 0;
	            for (var _i = 0, labelDataPointsGroups_1 = labelDataPointsGroups; _i < labelDataPointsGroups_1.length; _i++) {
	                var labelDataPointsGroup = labelDataPointsGroups_1[_i];
	                for (var _a = 0, _b = labelDataPointsGroup.labelDataPoints; _a < _b.length; _a++) {
	                    var labelDataPoint = _b[_a];
	                    if (labelDataPoint.isPreferred) {
	                        var dataLabelSize = labelDataPoint.labelSize;
	                        if (dataLabelSize.width > maxLabelWidth) {
	                            maxLabelWidth = dataLabelSize.width;
	                        }
	                        if (dataLabelSize.height > maxLabelHeight) {
	                            maxLabelHeight = dataLabelSize.height;
	                        }
	                    }
	                }
	            }
	            if (maxLabelWidth === 0) {
	                maxLabelWidth = viewport.width;
	            }
	            if (maxLabelHeight === 0) {
	                maxLabelHeight = viewport.height;
	            }
	            var cellSize = this.cellSize = { width: maxLabelWidth * LabelArrangeGrid.cellSizeMultiplier, height: maxLabelHeight * LabelArrangeGrid.cellSizeMultiplier };
	            this.columnCount = LabelArrangeGrid.getCellCount(cellSize.width, viewport.width, 1, 100);
	            this.rowCount = LabelArrangeGrid.getCellCount(cellSize.height, viewport.height, 1, 100);
	            var grid = [];
	            for (var i = 0, ilen = this.columnCount; i < ilen; i++) {
	                grid[i] = [];
	                for (var j = 0, jlen = this.rowCount; j < jlen; j++) {
	                    grid[i][j] = [];
	                }
	            }
	            this.grid = grid;
	        }
	        /**
	         * Add a rectangle to check collision against
	         */
	        LabelArrangeGrid.prototype.add = function (rect) {
	            var containingIndexRect = this.getContainingGridSubsection(rect);
	            for (var x = containingIndexRect.xMin; x < containingIndexRect.xMax; x++) {
	                for (var y = containingIndexRect.yMin; y < containingIndexRect.yMax; y++) {
	                    this.grid[x][y].push(rect);
	                }
	            }
	        };
	        /**
	         * Check whether the rect conflicts with the grid, either bleeding outside the
	         * viewport or colliding with another rect added to the grid.
	         */
	        LabelArrangeGrid.prototype.hasConflict = function (rect) {
	            if (!this.isWithinGridViewport(rect)) {
	                return true;
	            }
	            return this.hasCollision(rect);
	        };
	        /**
	         * Attempt to position the given rect within the viewport.  Returns
	         * the adjusted rectangle or null if the rectangle couldn't fit,
	         * conflicts with the viewport, or is too far outside the viewport
	         */
	        LabelArrangeGrid.prototype.tryPositionInViewport = function (rect) {
	            // If it's too far outside the viewport, return null
	            if (!this.isCloseToGridViewport(rect)) {
	                return;
	            }
	            if (!this.isWithinGridViewport(rect)) {
	                rect = this.tryMoveInsideViewport(rect);
	            }
	            if (rect && !this.hasCollision(rect)) {
	                return rect;
	            }
	        };
	        /**
	         * Checks for a collision between the given rect and others in the grid.
	         * Returns true if there is a collision.
	         */
	        LabelArrangeGrid.prototype.hasCollision = function (rect) {
	            var containingIndexRect = this.getContainingGridSubsection(rect);
	            var grid = this.grid;
	            var isIntersecting = shapes.Rect.isIntersecting;
	            for (var x = containingIndexRect.xMin; x < containingIndexRect.xMax; x++) {
	                for (var y = containingIndexRect.yMin; y < containingIndexRect.yMax; y++) {
	                    for (var _i = 0, _a = grid[x][y]; _i < _a.length; _i++) {
	                        var currentGridRect = _a[_i];
	                        if (isIntersecting(currentGridRect, rect)) {
	                            return true;
	                        }
	                    }
	                }
	            }
	            return false;
	        };
	        /**
	         * Check to see if the given rect is inside the grid's viewport
	         */
	        LabelArrangeGrid.prototype.isWithinGridViewport = function (rect) {
	            return rect.left >= 0 &&
	                rect.top >= 0 &&
	                rect.left + rect.width <= this.viewport.width &&
	                rect.top + rect.height <= this.viewport.height;
	        };
	        /**
	         * Checks to see if the rect is close enough to the viewport to be moved inside.
	         * "Close" here is determined by the distance between the edge of the viewport
	         * and the closest edge of the rect; if that distance is less than the appropriate
	         * dimension of the rect, we will reposition the rect.
	         */
	        LabelArrangeGrid.prototype.isCloseToGridViewport = function (rect) {
	            return rect.left + rect.width >= 0 - rect.width &&
	                rect.top + rect.height >= -rect.height &&
	                rect.left <= this.viewport.width + rect.width &&
	                rect.top <= this.viewport.height + rect.height;
	        };
	        /**
	         * Attempt to move the rect inside the grid's viewport.  Returns the resulting
	         * rectangle with the same width/height adjusted to be inside the viewport or
	         * null if it couldn't fit regardless.
	         */
	        LabelArrangeGrid.prototype.tryMoveInsideViewport = function (rect) {
	            var result = Rect.clone(rect);
	            var viewport = this.viewport;
	            // Return null if it's too big to fit regardless of positioning
	            if (rect.width > viewport.width || rect.height > viewport.height) {
	                return;
	            }
	            // Only one movement should be made in each direction, because we are only moving it inside enough for it to fit; there should be no overshooting.
	            // Outside to the left
	            if (rect.left < 0) {
	                result.left = 0;
	            }
	            else if (rect.left + rect.width > viewport.width) {
	                result.left -= (rect.left + rect.width) - viewport.width;
	            }
	            // Outside above
	            if (rect.top < 0) {
	                result.top = 0;
	            }
	            else if (rect.top + rect.height > viewport.height) {
	                result.top -= (rect.top + rect.height) - viewport.height;
	            }
	            return result;
	        };
	        LabelArrangeGrid.prototype.getContainingGridSubsection = function (rect) {
	            return {
	                xMin: LabelArrangeGrid.bound(Math.floor(rect.left / this.cellSize.width), 0, this.columnCount),
	                xMax: LabelArrangeGrid.bound(Math.ceil((rect.left + rect.width) / this.cellSize.width), 0, this.columnCount),
	                yMin: LabelArrangeGrid.bound(Math.floor(rect.top / this.cellSize.height), 0, this.rowCount),
	                yMax: LabelArrangeGrid.bound(Math.ceil((rect.top + rect.height) / this.cellSize.height), 0, this.rowCount),
	            };
	        };
	        LabelArrangeGrid.getCellCount = function (step, length, minCount, maxCount) {
	            return LabelArrangeGrid.bound(Math.ceil(length / step), minCount, maxCount);
	        };
	        LabelArrangeGrid.bound = function (value, min, max) {
	            return Math.max(Math.min(value, max), min);
	        };
	        /**
	         * A multiplier applied to the largest width height to attempt to balance # of
	         * labels in each cell and number of cells each label belongs to
	         */
	        LabelArrangeGrid.cellSizeMultiplier = 2;
	        return LabelArrangeGrid;
	    }());
	    powerbi.LabelArrangeGrid = LabelArrangeGrid;
	    var LabelLayout = (function () {
	        function LabelLayout(options) {
	            this.startingOffset = options.startingOffset;
	            this.maximumOffset = options.maximumOffset;
	            if (options.offsetIterationDelta != null) {
	                debug.assert(options.offsetIterationDelta > 0, "label offset delta must be greater than 0");
	                this.offsetIterationDelta = options.offsetIterationDelta;
	            }
	            else {
	                this.offsetIterationDelta = LabelLayout.defaultOffsetIterationDelta;
	            }
	            if (options.horizontalPadding != null) {
	                this.horizontalPadding = options.horizontalPadding;
	            }
	            else {
	                this.horizontalPadding = LabelLayout.defaultHorizontalPadding;
	            }
	            if (options.verticalPadding != null) {
	                this.verticalPadding = options.verticalPadding;
	            }
	            else {
	                this.verticalPadding = LabelLayout.defaultVerticalPadding;
	            }
	            this.allowLeaderLines = !!options.allowLeaderLines;
	            this.attemptToMoveLabelsIntoViewport = !!options.attemptToMoveLabelsIntoViewport;
	        }
	        /**
	         * Arrange takes a set of data labels and lays them out in order, assuming that
	         * the given array has already been sorted with the most preferred labels at the
	         * front, taking into considiration a maximum number of labels that are alowed
	         * to display.
	         *
	         * Details:
	         * - We iterate over offsets from the target position, increasing from 0 while
	         *      verifiying the maximum number of labels to display hasn't been reached
	         * - For each offset, we iterate over each data label
	         * - For each data label, we iterate over each position that is valid for
	         *     both the specific label and this layout
	         * - When a valid position is found, we position the label there and no longer
	         *     reposition it.
	         * - This prioritizes the earlier labels to be positioned closer to their
	         *     target points in the position they prefer.
	         * - This prioritizes putting data labels close to a valid position over
	         *     placing them at their preferred position (it will place it at a less
	         *     preferred position if it will be a smaller offset)
	         */
	        LabelLayout.prototype.layout = function (labelDataPointsGroups, viewport) {
	            // Clear data labels for a new layout
	            for (var _i = 0, labelDataPointsGroups_2 = labelDataPointsGroups; _i < labelDataPointsGroups_2.length; _i++) {
	                var labelDataPointsGroup = labelDataPointsGroups_2[_i];
	                for (var _a = 0, _b = labelDataPointsGroup.labelDataPoints; _a < _b.length; _a++) {
	                    var labelPoint = _b[_a];
	                    labelPoint.hasBeenRendered = false;
	                    if (labelPoint.hasBackground) {
	                        labelPoint.labelSize = {
	                            width: labelPoint.textSize.width + 2 * NewDataLabelUtils.horizontalLabelBackgroundPadding,
	                            height: labelPoint.textSize.height + 2 * NewDataLabelUtils.verticalLabelBackgroundPadding,
	                        };
	                    }
	                    else {
	                        labelPoint.labelSize = labelPoint.textSize;
	                    }
	                }
	            }
	            var resultingDataLabels = [];
	            var grid = new LabelArrangeGrid(labelDataPointsGroups, viewport);
	            // Iterates on every series
	            for (var _c = 0, labelDataPointsGroups_3 = labelDataPointsGroups; _c < labelDataPointsGroups_3.length; _c++) {
	                var labelDataPointsGroup = labelDataPointsGroups_3[_c];
	                var maxLabelsToRender = labelDataPointsGroup.maxNumberOfLabels;
	                // NOTE: we create a copy and modify the copy to keep track of preferred vs. non-preferred labels.
	                var labelDataPoints = _.clone(labelDataPointsGroup.labelDataPoints);
	                var preferredLabels = [];
	                // Exclude preferred labels
	                for (var j = labelDataPoints.length - 1, localMax = maxLabelsToRender; j >= 0 && localMax > 0; j--) {
	                    var labelPoint = labelDataPoints[j];
	                    if (labelPoint.isPreferred) {
	                        preferredLabels.unshift(labelDataPoints.splice(j, 1)[0]);
	                        localMax--;
	                    }
	                }
	                // First iterate all the preferred labels
	                if (preferredLabels.length > 0) {
	                    var positionedLabels = this.positionDataLabels(preferredLabels, viewport, grid, maxLabelsToRender);
	                    maxLabelsToRender -= positionedLabels.length;
	                    resultingDataLabels = resultingDataLabels.concat(positionedLabels);
	                }
	                // While there are invisible not preferred labels and label distance is less than the max
	                // allowed distance
	                if (labelDataPoints.length > 0) {
	                    var labels = this.positionDataLabels(labelDataPoints, viewport, grid, maxLabelsToRender);
	                    resultingDataLabels = resultingDataLabels.concat(labels);
	                }
	            }
	            return resultingDataLabels;
	        };
	        LabelLayout.prototype.positionDataLabels = function (labelDataPoints, viewport, grid, maxLabelsToRender) {
	            var resultingDataLabels = [];
	            var offsetDelta = this.offsetIterationDelta;
	            var currentOffset = this.startingOffset;
	            var currentCenteredOffset = 0;
	            var drawLeaderLinesOnIteration;
	            var labelsRendered = 0;
	            while (currentOffset <= this.maximumOffset && labelsRendered < maxLabelsToRender) {
	                drawLeaderLinesOnIteration = this.allowLeaderLines && currentOffset > this.startingOffset;
	                for (var _i = 0, labelDataPoints_1 = labelDataPoints; _i < labelDataPoints_1.length; _i++) {
	                    var labelPoint = labelDataPoints_1[_i];
	                    if (labelPoint.hasBeenRendered) {
	                        continue;
	                    }
	                    var dataLabel = void 0;
	                    if (labelPoint.parentType === 1 /* Rectangle */) {
	                        dataLabel = this.tryPositionForRectPositions(labelPoint, grid, currentOffset, currentCenteredOffset);
	                    }
	                    else {
	                        dataLabel = this.tryPositionForPointPositions(labelPoint, grid, currentOffset, drawLeaderLinesOnIteration);
	                    }
	                    if (dataLabel) {
	                        resultingDataLabels.push(dataLabel);
	                        labelsRendered++;
	                    }
	                    if (!(labelsRendered < maxLabelsToRender)) {
	                        break;
	                    }
	                }
	                currentOffset += offsetDelta;
	                currentCenteredOffset += offsetDelta;
	            }
	            return resultingDataLabels;
	        };
	        LabelLayout.prototype.tryPositionForRectPositions = function (labelPoint, grid, currentLabelOffset, currentCenteredLabelOffset) {
	            var _this = this;
	            // Function declared and reused to reduce code duplication
	            var tryPosition = function (position, adjustForViewport) {
	                var isPositionInside = position & 7 /* InsideAll */;
	                if (isPositionInside && !DataLabelRectPositioner.canFitWithinParent(labelPoint, _this.horizontalPadding, _this.verticalPadding)) {
	                    return;
	                }
	                var resultingBoundingBox = LabelLayout.tryPositionRect(grid, position, labelPoint, currentLabelOffset, currentCenteredLabelOffset, adjustForViewport);
	                if (resultingBoundingBox) {
	                    if (isPositionInside && !DataLabelRectPositioner.isLabelWithinParent(resultingBoundingBox, labelPoint, _this.horizontalPadding, _this.verticalPadding)) {
	                        return;
	                    }
	                    grid.add(resultingBoundingBox);
	                    labelPoint.hasBeenRendered = true;
	                    return {
	                        boundingBox: resultingBoundingBox,
	                        text: labelPoint.text,
	                        tooltip: labelPoint.tooltip,
	                        isVisible: true,
	                        fill: isPositionInside ? labelPoint.insideFill : labelPoint.outsideFill,
	                        identity: labelPoint.identity,
	                        key: labelPoint.key,
	                        fontSize: labelPoint.fontSize,
	                        selected: false,
	                        hasBackground: !!labelPoint.hasBackground,
	                    };
	                }
	            };
	            // Iterate over all positions that are valid for the data point
	            for (var _i = 0, _a = labelPoint.parentShape.validPositions; _i < _a.length; _i++) {
	                var position = _a[_i];
	                var label = tryPosition(position, false /* adjustForViewport */);
	                if (label)
	                    return label;
	            }
	            // If no position has been found and the option is enabled, try any outside positions while moving the label inside the viewport
	            if (this.attemptToMoveLabelsIntoViewport) {
	                for (var _b = 0, _c = labelPoint.parentShape.validPositions; _b < _c.length; _b++) {
	                    var position = _c[_b];
	                    var label = tryPosition(position, true /* adjustForViewport */);
	                    if (label)
	                        return label;
	                }
	            }
	            return null;
	        };
	        /**
	         * Tests a particular position/offset combination for the given data label.
	         * If the label can be placed, returns the resulting bounding box for the data
	         * label.  If not, returns null.
	         */
	        LabelLayout.tryPositionRect = function (grid, position, labelDataPoint, offset, centerOffset, adjustForViewport) {
	            var offsetForPosition = offset;
	            if (position & 1 /* InsideCenter */) {
	                offsetForPosition = centerOffset;
	            }
	            var labelRect = DataLabelRectPositioner.getLabelRect(labelDataPoint, position, offsetForPosition);
	            if (position !== 1 /* InsideCenter */ || labelDataPoint.parentShape.orientation === 0 /* None */) {
	                if (!grid.hasConflict(labelRect)) {
	                    return labelRect;
	                }
	                if (adjustForViewport) {
	                    return grid.tryPositionInViewport(labelRect);
	                }
	            }
	            else {
	                // If the position is centered, attempt to offset in both a positive and negative direction
	                if (!grid.hasConflict(labelRect)) {
	                    return labelRect;
	                }
	                labelRect = DataLabelRectPositioner.getLabelRect(labelDataPoint, position, -offsetForPosition);
	                if (!grid.hasConflict(labelRect)) {
	                    return labelRect;
	                }
	            }
	            return null;
	        };
	        LabelLayout.prototype.tryPositionForPointPositions = function (labelPoint, grid, currentLabelOffset, drawLeaderLines) {
	            // Function declared and reused to reduce code duplication
	            var tryPosition = function (position, parentShape, adjustForViewport) {
	                var resultingBoundingBox = LabelLayout.tryPositionPoint(grid, position, labelPoint, currentLabelOffset, adjustForViewport);
	                if (resultingBoundingBox) {
	                    grid.add(resultingBoundingBox);
	                    labelPoint.hasBeenRendered = true;
	                    return {
	                        boundingBox: resultingBoundingBox,
	                        text: labelPoint.text,
	                        tooltip: labelPoint.tooltip,
	                        isVisible: true,
	                        fill: position === 256 /* Center */ ? labelPoint.insideFill : labelPoint.outsideFill,
	                        isInsideParent: position === 256 /* Center */,
	                        identity: labelPoint.identity,
	                        key: labelPoint.key,
	                        fontSize: labelPoint.fontSize,
	                        selected: false,
	                        leaderLinePoints: drawLeaderLines ? DataLabelPointPositioner.getLabelLeaderLineEndingPoint(resultingBoundingBox, position, parentShape) : null,
	                        hasBackground: !!labelPoint.hasBackground,
	                    };
	                }
	            };
	            // Iterate over all positions that are valid for the data point
	            var parentShape = labelPoint.parentShape;
	            var validPositions = parentShape.validPositions;
	            for (var _i = 0, validPositions_1 = validPositions; _i < validPositions_1.length; _i++) {
	                var position = validPositions_1[_i];
	                var label = tryPosition(position, parentShape, false /* adjustForViewport */);
	                if (label)
	                    return label;
	            }
	            // Attempt to position at the most preferred position by simply moving it inside the viewport
	            if (this.attemptToMoveLabelsIntoViewport && !_.isEmpty(validPositions)) {
	                var label = tryPosition(validPositions[0], parentShape, true /* adjustForViewport */);
	                if (label)
	                    return label;
	            }
	            return null;
	        };
	        LabelLayout.tryPositionPoint = function (grid, position, labelDataPoint, offset, adjustForViewport) {
	            var labelRect = DataLabelPointPositioner.getLabelRect(labelDataPoint.labelSize, labelDataPoint.parentShape, position, offset);
	            if (!grid.hasConflict(labelRect)) {
	                return labelRect;
	            }
	            if (adjustForViewport) {
	                return grid.tryPositionInViewport(labelRect);
	            }
	            return null;
	        };
	        // Default values
	        LabelLayout.defaultOffsetIterationDelta = 2;
	        LabelLayout.defaultHorizontalPadding = 2;
	        LabelLayout.defaultVerticalPadding = 2;
	        return LabelLayout;
	    }());
	    powerbi.LabelLayout = LabelLayout;
	    /**
	     * (Private) Contains methods for calculating the bounding box of a data label
	     */
	    var DataLabelRectPositioner;
	    (function (DataLabelRectPositioner) {
	        function getLabelRect(labelDataPoint, position, offset) {
	            var parentRect = labelDataPoint.parentShape;
	            if (parentRect != null) {
	                // Each combination of position and orientation results in a different actual positioning, which is then called.
	                switch (position) {
	                    case 1 /* InsideCenter */:
	                        switch (parentRect.orientation) {
	                            case 1 /* VerticalBottomBased */:
	                            case 2 /* VerticalTopBased */:
	                                return DataLabelRectPositioner.middleVertical(labelDataPoint.labelSize, parentRect.rect, offset);
	                            case 3 /* HorizontalLeftBased */:
	                            case 4 /* HorizontalRightBased */:
	                                return DataLabelRectPositioner.middleHorizontal(labelDataPoint.labelSize, parentRect.rect, offset);
	                            case 0 /* None */:
	                        }
	                    case 2 /* InsideBase */:
	                        switch (parentRect.orientation) {
	                            case 1 /* VerticalBottomBased */:
	                                return DataLabelRectPositioner.bottomInside(labelDataPoint.labelSize, parentRect.rect, offset);
	                            case 2 /* VerticalTopBased */:
	                                return DataLabelRectPositioner.topInside(labelDataPoint.labelSize, parentRect.rect, offset);
	                            case 3 /* HorizontalLeftBased */:
	                                return DataLabelRectPositioner.leftInside(labelDataPoint.labelSize, parentRect.rect, offset);
	                            case 4 /* HorizontalRightBased */:
	                                return DataLabelRectPositioner.rightInside(labelDataPoint.labelSize, parentRect.rect, offset);
	                            case 0 /* None */:
	                        }
	                    case 4 /* InsideEnd */:
	                        switch (parentRect.orientation) {
	                            case 1 /* VerticalBottomBased */:
	                                return DataLabelRectPositioner.topInside(labelDataPoint.labelSize, parentRect.rect, offset);
	                            case 2 /* VerticalTopBased */:
	                                return DataLabelRectPositioner.bottomInside(labelDataPoint.labelSize, parentRect.rect, offset);
	                            case 3 /* HorizontalLeftBased */:
	                                return DataLabelRectPositioner.rightInside(labelDataPoint.labelSize, parentRect.rect, offset);
	                            case 4 /* HorizontalRightBased */:
	                                return DataLabelRectPositioner.leftInside(labelDataPoint.labelSize, parentRect.rect, offset);
	                            case 0 /* None */:
	                        }
	                    case 8 /* OutsideBase */:
	                        switch (parentRect.orientation) {
	                            case 1 /* VerticalBottomBased */:
	                                return DataLabelRectPositioner.bottomOutside(labelDataPoint.labelSize, parentRect.rect, offset);
	                            case 2 /* VerticalTopBased */:
	                                return DataLabelRectPositioner.topOutside(labelDataPoint.labelSize, parentRect.rect, offset);
	                            case 3 /* HorizontalLeftBased */:
	                                return DataLabelRectPositioner.leftOutside(labelDataPoint.labelSize, parentRect.rect, offset);
	                            case 4 /* HorizontalRightBased */:
	                                return DataLabelRectPositioner.rightOutside(labelDataPoint.labelSize, parentRect.rect, offset);
	                            case 0 /* None */:
	                        }
	                    case 16 /* OutsideEnd */:
	                        switch (parentRect.orientation) {
	                            case 1 /* VerticalBottomBased */:
	                                return DataLabelRectPositioner.topOutside(labelDataPoint.labelSize, parentRect.rect, offset);
	                            case 2 /* VerticalTopBased */:
	                                return DataLabelRectPositioner.bottomOutside(labelDataPoint.labelSize, parentRect.rect, offset);
	                            case 3 /* HorizontalLeftBased */:
	                                return DataLabelRectPositioner.rightOutside(labelDataPoint.labelSize, parentRect.rect, offset);
	                            case 4 /* HorizontalRightBased */:
	                                return DataLabelRectPositioner.leftOutside(labelDataPoint.labelSize, parentRect.rect, offset);
	                            case 0 /* None */:
	                        }
	                    default:
	                        debug.assertFail("Unsupported label position");
	                }
	            }
	            else {
	            }
	            return null;
	        }
	        DataLabelRectPositioner.getLabelRect = getLabelRect;
	        function canFitWithinParent(labelDataPoint, horizontalPadding, verticalPadding) {
	            return (labelDataPoint.labelSize.width + 2 * horizontalPadding < labelDataPoint.parentShape.rect.width) ||
	                (labelDataPoint.labelSize.height + 2 * verticalPadding < labelDataPoint.parentShape.rect.height);
	        }
	        DataLabelRectPositioner.canFitWithinParent = canFitWithinParent;
	        function isLabelWithinParent(labelRect, labelPoint, horizontalPadding, verticalPadding) {
	            var parentRect = labelPoint.parentShape.rect;
	            var labelRectWithPadding = shapes.Rect.inflate(labelRect, { left: horizontalPadding, right: horizontalPadding, top: verticalPadding, bottom: verticalPadding });
	            return shapes.Rect.containsPoint(parentRect, {
	                x: labelRectWithPadding.left,
	                y: labelRectWithPadding.top,
	            }) && shapes.Rect.containsPoint(parentRect, {
	                x: labelRectWithPadding.left + labelRectWithPadding.width,
	                y: labelRectWithPadding.top + labelRectWithPadding.height,
	            });
	        }
	        DataLabelRectPositioner.isLabelWithinParent = isLabelWithinParent;
	        function topInside(labelSize, parentRect, offset) {
	            return {
	                left: parentRect.left + parentRect.width / 2.0 - labelSize.width / 2.0,
	                top: parentRect.top + offset,
	                width: labelSize.width,
	                height: labelSize.height
	            };
	        }
	        DataLabelRectPositioner.topInside = topInside;
	        function bottomInside(labelSize, parentRect, offset) {
	            return {
	                left: parentRect.left + parentRect.width / 2.0 - labelSize.width / 2.0,
	                top: (parentRect.top + parentRect.height) - offset - labelSize.height,
	                width: labelSize.width,
	                height: labelSize.height
	            };
	        }
	        DataLabelRectPositioner.bottomInside = bottomInside;
	        function rightInside(labelSize, parentRect, offset) {
	            return {
	                left: (parentRect.left + parentRect.width) - labelSize.width - offset,
	                top: parentRect.top + parentRect.height / 2.0 - labelSize.height / 2.0,
	                width: labelSize.width,
	                height: labelSize.height
	            };
	        }
	        DataLabelRectPositioner.rightInside = rightInside;
	        function leftInside(labelSize, parentRect, offset) {
	            return {
	                left: parentRect.left + offset,
	                top: parentRect.top + parentRect.height / 2.0 - labelSize.height / 2.0,
	                width: labelSize.width,
	                height: labelSize.height
	            };
	        }
	        DataLabelRectPositioner.leftInside = leftInside;
	        function topOutside(labelSize, parentRect, offset) {
	            return {
	                left: parentRect.left + parentRect.width / 2.0 - labelSize.width / 2.0,
	                top: parentRect.top - labelSize.height - offset,
	                width: labelSize.width,
	                height: labelSize.height
	            };
	        }
	        DataLabelRectPositioner.topOutside = topOutside;
	        function bottomOutside(labelSize, parentRect, offset) {
	            return {
	                left: parentRect.left + parentRect.width / 2.0 - labelSize.width / 2.0,
	                top: (parentRect.top + parentRect.height) + offset,
	                width: labelSize.width,
	                height: labelSize.height
	            };
	        }
	        DataLabelRectPositioner.bottomOutside = bottomOutside;
	        function rightOutside(labelSize, parentRect, offset) {
	            return {
	                left: (parentRect.left + parentRect.width) + offset,
	                top: parentRect.top + parentRect.height / 2.0 - labelSize.height / 2.0,
	                width: labelSize.width,
	                height: labelSize.height
	            };
	        }
	        DataLabelRectPositioner.rightOutside = rightOutside;
	        function leftOutside(labelSize, parentRect, offset) {
	            return {
	                left: parentRect.left - labelSize.width - offset,
	                top: parentRect.top + parentRect.height / 2.0 - labelSize.height / 2.0,
	                width: labelSize.width,
	                height: labelSize.height
	            };
	        }
	        DataLabelRectPositioner.leftOutside = leftOutside;
	        function middleHorizontal(labelSize, parentRect, offset) {
	            return {
	                left: parentRect.left + parentRect.width / 2.0 - labelSize.width / 2.0 + offset,
	                top: parentRect.top + parentRect.height / 2.0 - labelSize.height / 2.0,
	                width: labelSize.width,
	                height: labelSize.height
	            };
	        }
	        DataLabelRectPositioner.middleHorizontal = middleHorizontal;
	        function middleVertical(labelSize, parentRect, offset) {
	            return {
	                left: parentRect.left + parentRect.width / 2.0 - labelSize.width / 2.0,
	                top: parentRect.top + parentRect.height / 2.0 - labelSize.height / 2.0 + offset,
	                width: labelSize.width,
	                height: labelSize.height
	            };
	        }
	        DataLabelRectPositioner.middleVertical = middleVertical;
	    })(DataLabelRectPositioner = powerbi.DataLabelRectPositioner || (powerbi.DataLabelRectPositioner = {}));
	    var DataLabelPointPositioner;
	    (function (DataLabelPointPositioner) {
	        DataLabelPointPositioner.cos45 = Math.cos(45);
	        DataLabelPointPositioner.sin45 = Math.sin(45);
	        function getLabelRect(labelSize, parentPoint, position, offset) {
	            switch (position) {
	                case 1 /* Above */: {
	                    return DataLabelPointPositioner.above(labelSize, parentPoint.point, parentPoint.radius + offset);
	                }
	                case 2 /* Below */: {
	                    return DataLabelPointPositioner.below(labelSize, parentPoint.point, parentPoint.radius + offset);
	                }
	                case 4 /* Left */: {
	                    return DataLabelPointPositioner.left(labelSize, parentPoint.point, parentPoint.radius + offset);
	                }
	                case 8 /* Right */: {
	                    return DataLabelPointPositioner.right(labelSize, parentPoint.point, parentPoint.radius + offset);
	                }
	                case 32 /* BelowLeft */: {
	                    return DataLabelPointPositioner.belowLeft(labelSize, parentPoint.point, parentPoint.radius + offset);
	                }
	                case 16 /* BelowRight */: {
	                    return DataLabelPointPositioner.belowRight(labelSize, parentPoint.point, parentPoint.radius + offset);
	                }
	                case 128 /* AboveLeft */: {
	                    return DataLabelPointPositioner.aboveLeft(labelSize, parentPoint.point, parentPoint.radius + offset);
	                }
	                case 64 /* AboveRight */: {
	                    return DataLabelPointPositioner.aboveRight(labelSize, parentPoint.point, parentPoint.radius + offset);
	                }
	                case 256 /* Center */: {
	                    return DataLabelPointPositioner.center(labelSize, parentPoint.point);
	                }
	                default: {
	                    debug.assertFail("Unsupported label position");
	                }
	            }
	            return null;
	        }
	        DataLabelPointPositioner.getLabelRect = getLabelRect;
	        function above(labelSize, parentPoint, offset) {
	            return {
	                left: parentPoint.x - (labelSize.width / 2),
	                top: parentPoint.y - offset - labelSize.height,
	                width: labelSize.width,
	                height: labelSize.height
	            };
	        }
	        DataLabelPointPositioner.above = above;
	        function below(labelSize, parentPoint, offset) {
	            return {
	                left: parentPoint.x - (labelSize.width / 2),
	                top: parentPoint.y + offset,
	                width: labelSize.width,
	                height: labelSize.height
	            };
	        }
	        DataLabelPointPositioner.below = below;
	        function left(labelSize, parentPoint, offset) {
	            return {
	                left: parentPoint.x - offset - labelSize.width,
	                top: parentPoint.y - (labelSize.height / 2),
	                width: labelSize.width,
	                height: labelSize.height
	            };
	        }
	        DataLabelPointPositioner.left = left;
	        function right(labelSize, parentPoint, offset) {
	            return {
	                left: parentPoint.x + offset,
	                top: parentPoint.y - (labelSize.height / 2),
	                width: labelSize.width,
	                height: labelSize.height
	            };
	        }
	        DataLabelPointPositioner.right = right;
	        function belowLeft(labelSize, parentPoint, offset) {
	            return {
	                left: parentPoint.x - (DataLabelPointPositioner.sin45 * offset) - labelSize.width,
	                top: parentPoint.y + (DataLabelPointPositioner.cos45 * offset),
	                width: labelSize.width,
	                height: labelSize.height
	            };
	        }
	        DataLabelPointPositioner.belowLeft = belowLeft;
	        function belowRight(labelSize, parentPoint, offset) {
	            return {
	                left: parentPoint.x + (DataLabelPointPositioner.sin45 * offset),
	                top: parentPoint.y + (DataLabelPointPositioner.cos45 * offset),
	                width: labelSize.width,
	                height: labelSize.height
	            };
	        }
	        DataLabelPointPositioner.belowRight = belowRight;
	        function aboveLeft(labelSize, parentPoint, offset) {
	            return {
	                left: parentPoint.x - (DataLabelPointPositioner.sin45 * offset) - labelSize.width,
	                top: parentPoint.y - (DataLabelPointPositioner.cos45 * offset) - labelSize.height,
	                width: labelSize.width,
	                height: labelSize.height
	            };
	        }
	        DataLabelPointPositioner.aboveLeft = aboveLeft;
	        function aboveRight(labelSize, parentPoint, offset) {
	            return {
	                left: parentPoint.x + (DataLabelPointPositioner.sin45 * offset),
	                top: parentPoint.y - (DataLabelPointPositioner.cos45 * offset) - labelSize.height,
	                width: labelSize.width,
	                height: labelSize.height
	            };
	        }
	        DataLabelPointPositioner.aboveRight = aboveRight;
	        function center(labelSize, parentPoint) {
	            return {
	                left: parentPoint.x - (labelSize.width / 2),
	                top: parentPoint.y - (labelSize.height / 2),
	                width: labelSize.width,
	                height: labelSize.height
	            };
	        }
	        DataLabelPointPositioner.center = center;
	        function getLabelLeaderLineEndingPoint(boundingBox, position, parentShape) {
	            var x = boundingBox.left;
	            var y = boundingBox.top;
	            switch (position) {
	                case 1 /* Above */:
	                    x += (boundingBox.width / 2);
	                    y += boundingBox.height;
	                    break;
	                case 2 /* Below */:
	                    x += (boundingBox.width / 2);
	                    break;
	                case 4 /* Left */:
	                    x += boundingBox.width;
	                    y += ((boundingBox.height * 2) / 3);
	                    break;
	                case 8 /* Right */:
	                    y += ((boundingBox.height * 2) / 3);
	                    break;
	                case 32 /* BelowLeft */:
	                    x += boundingBox.width;
	                    y += (boundingBox.height / 2);
	                    break;
	                case 16 /* BelowRight */:
	                    y += (boundingBox.height / 2);
	                    break;
	                case 128 /* AboveLeft */:
	                    x += boundingBox.width;
	                    y += boundingBox.height;
	                    break;
	                case 64 /* AboveRight */:
	                    y += boundingBox.height;
	                    break;
	            }
	            return [[parentShape.point.x, parentShape.point.y], [x, y]];
	        }
	        DataLabelPointPositioner.getLabelLeaderLineEndingPoint = getLabelLeaderLineEndingPoint;
	    })(DataLabelPointPositioner = powerbi.DataLabelPointPositioner || (powerbi.DataLabelPointPositioner = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 227 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var NewDataLabelUtils = powerbi.visuals.NewDataLabelUtils;
	    var labelStyle = powerbi.visuals.labelStyle;
	    var DonutLabelUtils = powerbi.visuals.DonutLabelUtils;
	    var DonutLabelLayout = (function () {
	        function DonutLabelLayout(options, donutChartProperties) {
	            this.startingOffset = options.startingOffset;
	            this.maximumOffset = options.maximumOffset;
	            if (options.offsetIterationDelta != null) {
	                debug.assert(options.offsetIterationDelta > 0, "label offset delta must be greater than 0");
	                this.offsetIterationDelta = options.offsetIterationDelta;
	            }
	            this.donutChartProperties = donutChartProperties;
	            this.center = {
	                x: donutChartProperties.viewport.width / 2,
	                y: donutChartProperties.viewport.height / 2,
	            };
	            this.outerRadius = this.donutChartProperties.radius * this.donutChartProperties.outerArcRadiusRatio;
	            this.innerRadius = (this.donutChartProperties.radius / 2) * this.donutChartProperties.innerArcRadiusRatio;
	            this.additionalCharsWidth = powerbi.TextMeasurementService.measureSvgTextWidth({
	                text: " ()",
	                fontFamily: NewDataLabelUtils.LabelTextProperties.fontFamily,
	                fontSize: jsCommon.PixelConverter.fromPoint(donutChartProperties.dataLabelsSettings.fontSize),
	                fontWeight: NewDataLabelUtils.LabelTextProperties.fontWeight,
	            });
	        }
	        /**
	         * Arrange takes a set of data labels and lays them out them in order, assuming that
	         * the given array has already been sorted with the most preferred labels at the
	         * front.
	         *
	         * Details:
	         * - We iterate over offsets from the target position, increasing from 0
	         * - For each offset, we iterate over each data label
	         * - For each data label, we iterate over each position that is valid for
	         *     both the specific label and this layout
	         * - When a valid position is found, we position the label there and no longer
	         *     reposition it.
	         * - This prioritizes the earlier labels to be positioned closer to their
	         *     target points in the position they prefer.
	         * - This prioritizes putting data labels close to a valid position over
	         *     placing them at their preferred position (it will place it at a less
	         *     preferred position if it will be a smaller offset)
	         */
	        DonutLabelLayout.prototype.layout = function (labelDataPoints) {
	            // Clear data labels for a new layout
	            for (var _i = 0, labelDataPoints_1 = labelDataPoints; _i < labelDataPoints_1.length; _i++) {
	                var donutLabel = labelDataPoints_1[_i];
	                donutLabel.hasBeenRendered = false;
	                donutLabel.labelSize = donutLabel.textSize;
	            }
	            var resultingLabels = [];
	            var preferredLabels = [];
	            var viewport = this.donutChartProperties.viewport;
	            var labelDataPointsGroup = {
	                labelDataPoints: labelDataPoints,
	                maxNumberOfLabels: labelDataPoints.length
	            };
	            var grid = new powerbi.LabelArrangeGrid([labelDataPointsGroup], viewport);
	            for (var i = labelDataPoints.length - 1; i >= 0; i--) {
	                var labelPoint = labelDataPoints[i];
	                if (labelPoint.isPreferred) {
	                    var label = labelDataPoints.splice(i, 1);
	                    preferredLabels = label.concat(preferredLabels);
	                }
	            }
	            // first iterate all the preferred labels
	            if (preferredLabels.length > 0)
	                resultingLabels = this.positionLabels(preferredLabels, grid);
	            // While there are invisible not preferred labels and label distance is less than the max
	            // allowed distance
	            if (labelDataPoints.length > 0) {
	                var labels = this.positionLabels(labelDataPoints, grid);
	                resultingLabels = resultingLabels.concat(labels);
	            }
	            return resultingLabels;
	        };
	        DonutLabelLayout.prototype.positionLabels = function (labelDataPoints, grid) {
	            var resultingLabels = [];
	            var offsetDelta = this.offsetIterationDelta;
	            var currentOffset = this.startingOffset;
	            var currentCenteredOffset = 0;
	            while (currentOffset <= this.maximumOffset) {
	                for (var _i = 0, labelDataPoints_2 = labelDataPoints; _i < labelDataPoints_2.length; _i++) {
	                    var labelPoint = labelDataPoints_2[_i];
	                    if (labelPoint.hasBeenRendered)
	                        continue;
	                    var label = this.tryPositionForDonut(labelPoint, grid, currentOffset);
	                    if (label)
	                        resultingLabels.push(label);
	                }
	                currentOffset += offsetDelta;
	                currentCenteredOffset += offsetDelta;
	            }
	            return resultingLabels;
	        };
	        /**
	         * We try to move the label 25% up/down if the label is truncated or it collides with other labels.
	         * after we moved it once we check that the new position doesn't failed (collides with other labels).
	         */
	        DonutLabelLayout.prototype.tryPositionForDonut = function (labelPoint, grid, currentLabelOffset) {
	            var parentShape = labelPoint.parentShape;
	            if (_.isEmpty(parentShape.validPositions) || parentShape.validPositions[0] === 0 /* None */)
	                return;
	            var defaultPosition = parentShape.validPositions[0];
	            var bestCandidate = this.tryAllPositions(labelPoint, grid, defaultPosition, currentLabelOffset);
	            if (bestCandidate && bestCandidate.score === 0) {
	                return this.buildLabel(bestCandidate, grid);
	            }
	            // If we haven't found a non-truncated label, try to split into 2 lines.
	            if (this.donutChartProperties.dataLabelsSettings.labelStyle === labelStyle.both) {
	                // Try to split the label to two lines if both data and category label are on
	                var splitLabelDataPoint = this.splitDonutDataPoint(labelPoint);
	                var bestSplitCandidate = this.tryAllPositions(splitLabelDataPoint, grid, defaultPosition, currentLabelOffset);
	                // If the best candidate with a split line is better than the best candidate with a single line, return the former.
	                if (bestSplitCandidate && (!bestCandidate || (bestSplitCandidate.score < bestCandidate.score))) {
	                    return this.buildLabel(bestSplitCandidate, grid);
	                }
	            }
	            // We didn't find a better candidate by splitting the label lines, so return our best single-line candidate.
	            if (bestCandidate) {
	                return this.buildLabel(bestCandidate, grid);
	            }
	        };
	        DonutLabelLayout.prototype.generateCandidate = function (labelDataPoint, candidatePosition, grid, currentLabelOffset) {
	            var angle = this.generateCandidateAngleForPosition(labelDataPoint.donutArcDescriptor, candidatePosition);
	            var parentShape = this.getPointPositionForAngle(angle);
	            var parentPoint = parentShape.point;
	            var score = this.score(labelDataPoint, parentPoint);
	            var leaderLinePoints = DonutLabelUtils.getLabelLeaderLineForDonutChart(labelDataPoint.donutArcDescriptor, this.donutChartProperties, parentPoint, angle);
	            var leaderLinesSize = DonutLabelUtils.getLabelLeaderLinesSizeForDonutChart(leaderLinePoints);
	            var newLabelDataPoint = _.clone(labelDataPoint);
	            newLabelDataPoint.angle = angle;
	            newLabelDataPoint.parentShape = parentShape;
	            newLabelDataPoint.leaderLinePoints = leaderLinePoints;
	            newLabelDataPoint.linesSize = leaderLinesSize;
	            var boundingBoxs = DonutLabelLayout.tryPositionPoint(grid, parentShape.validPositions[0], newLabelDataPoint, currentLabelOffset, this.center, this.donutChartProperties.viewport);
	            return {
	                angle: angle,
	                point: parentShape,
	                score: score,
	                labelRects: boundingBoxs,
	                labelDataPoint: newLabelDataPoint,
	            };
	        };
	        DonutLabelLayout.prototype.tryAllPositions = function (labelDataPoint, grid, defaultPosition, currentLabelOffset) {
	            var boundingBoxs = DonutLabelLayout.tryPositionPoint(grid, defaultPosition, labelDataPoint, currentLabelOffset, this.center, this.donutChartProperties.viewport);
	            var originalPoint = labelDataPoint.parentShape;
	            var originalCandidate = {
	                point: originalPoint,
	                angle: labelDataPoint.angle,
	                score: this.score(labelDataPoint, originalPoint.point),
	                labelRects: boundingBoxs,
	                labelDataPoint: labelDataPoint,
	            };
	            if (boundingBoxs && boundingBoxs.textRect && originalCandidate.score === 0) {
	                return originalCandidate;
	            }
	            var positions = [];
	            var bestCandidate;
	            if (boundingBoxs && boundingBoxs.textRect) {
	                // We have a truncated label here, otherwised we would have returned already
	                positions = this.getLabelPointPositions(labelDataPoint, /* isTruncated */ true);
	                bestCandidate = originalCandidate;
	            }
	            else {
	                positions = this.getLabelPointPositions(labelDataPoint, /* isTruncated */ false);
	            }
	            // Try to reposition the label if necessary
	            for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
	                var position = positions_1[_i];
	                var candidate = this.generateCandidate(labelDataPoint, position, grid, currentLabelOffset);
	                if (candidate.labelRects && candidate.labelRects.textRect) {
	                    if (bestCandidate == null || candidate.score < bestCandidate.score) {
	                        bestCandidate = candidate;
	                        if (bestCandidate.score === 0)
	                            return bestCandidate;
	                    }
	                }
	            }
	            return bestCandidate;
	        };
	        DonutLabelLayout.prototype.buildLabel = function (labelLayout, grid) {
	            var resultingBoundingBox = labelLayout.labelRects.textRect;
	            var labelPoint = labelLayout.labelDataPoint;
	            grid.add(resultingBoundingBox);
	            grid.add(labelLayout.labelRects.horizontalLineRect);
	            grid.add(labelLayout.labelRects.diagonalLineRect);
	            labelPoint.hasBeenRendered = true;
	            var left = resultingBoundingBox.left - this.center.x;
	            //We need to add or subtract half resultingBoundingBox.width because Donut chart labels get text anchor start/end
	            if (left < 0)
	                left += resultingBoundingBox.width / 2;
	            else
	                left -= resultingBoundingBox.width / 2;
	            var textAnchor = labelPoint.parentShape.validPositions[0] === 8 /* Right */ ? 'start' : 'end';
	            var boundingBox = {
	                left: left,
	                top: resultingBoundingBox.top - this.center.y,
	                height: resultingBoundingBox.height,
	                width: resultingBoundingBox.width,
	            };
	            // After repositioning the label we need to recalculate its size and format it according to the current available space
	            var labelSettingsStyle = this.donutChartProperties.dataLabelsSettings.labelStyle;
	            var spaceAvailableForLabels = DonutLabelUtils.getSpaceAvailableForDonutLabels(labelPoint.parentShape.point.x, this.donutChartProperties.viewport);
	            var formattedDataLabel;
	            var formattedCategoryLabel;
	            var text;
	            var getLabelFormattedText = powerbi.visuals.dataLabelUtils.getLabelFormattedText;
	            var fontSize = labelPoint.fontSize;
	            var hasOneLabelRow = labelSettingsStyle === labelStyle.both && labelPoint.secondRowText == null;
	            // Giving 50/50 space when both category and measure are on
	            if (hasOneLabelRow) {
	                labelPoint.dataLabel = " (" + labelPoint.dataLabel + ")";
	                spaceAvailableForLabels /= 2;
	            }
	            if (labelSettingsStyle === labelStyle.both || labelSettingsStyle === labelStyle.data) {
	                formattedDataLabel = getLabelFormattedText({
	                    label: labelPoint.dataLabel,
	                    maxWidth: spaceAvailableForLabels,
	                    fontSize: fontSize
	                });
	            }
	            if (labelSettingsStyle === labelStyle.both || labelSettingsStyle === labelStyle.category) {
	                formattedCategoryLabel = getLabelFormattedText({
	                    label: labelPoint.categoryLabel,
	                    maxWidth: spaceAvailableForLabels,
	                    fontSize: fontSize
	                });
	            }
	            switch (labelSettingsStyle) {
	                case labelStyle.both:
	                    if (labelPoint.secondRowText == null) {
	                        text = formattedCategoryLabel + formattedDataLabel;
	                    }
	                    else {
	                        text = formattedDataLabel;
	                        labelPoint.secondRowText = formattedCategoryLabel;
	                    }
	                    break;
	                case labelStyle.data:
	                    text = formattedDataLabel;
	                    break;
	                case labelStyle.category:
	                    text = formattedCategoryLabel;
	                    break;
	            }
	            // Limit text size width for correct leader line calculation
	            labelPoint.textSize.width = Math.min(labelPoint.textSize.width, hasOneLabelRow ? spaceAvailableForLabels * 2 : spaceAvailableForLabels);
	            return {
	                boundingBox: boundingBox,
	                text: text,
	                tooltip: labelPoint.tooltip,
	                isVisible: true,
	                fill: labelPoint.outsideFill,
	                identity: labelPoint.identity,
	                fontSize: fontSize,
	                selected: false,
	                textAnchor: textAnchor,
	                leaderLinePoints: labelPoint.leaderLinePoints,
	                hasBackground: false,
	                secondRowText: labelPoint.secondRowText,
	            };
	        };
	        DonutLabelLayout.tryPositionPoint = function (grid, position, labelDataPoint, offset, center, viewport) {
	            var parentPoint = labelDataPoint.parentShape;
	            // Limit label width to fit the availabe space for labels
	            var textSize = _.clone(labelDataPoint.textSize);
	            textSize.width = Math.min(textSize.width, DonutLabelUtils.getSpaceAvailableForDonutLabels(parentPoint.point.x, viewport));
	            // Create label rectangle
	            var labelRect = powerbi.DataLabelPointPositioner.getLabelRect(textSize, parentPoint, position, offset);
	            // Create label diagonal line rectangle
	            var diagonalLineParentPoint = {
	                point: {
	                    x: labelDataPoint.leaderLinePoints[0][0],
	                    y: labelDataPoint.leaderLinePoints[0][1] < 0 ? labelDataPoint.leaderLinePoints[1][1] : labelDataPoint.leaderLinePoints[0][1]
	                },
	                radius: 0,
	                validPositions: null
	            };
	            var diagonalLineRect = powerbi.DataLabelPointPositioner.getLabelRect(labelDataPoint.linesSize[DonutLabelUtils.DiagonalLineIndex], diagonalLineParentPoint, position, offset);
	            // Create label horizontal line rectangle
	            var horizontalLineParentPoint = {
	                point: {
	                    x: labelDataPoint.leaderLinePoints[1][0],
	                    y: labelDataPoint.leaderLinePoints[1][1]
	                },
	                radius: 0,
	                validPositions: null
	            };
	            var horizontalLineRect = powerbi.DataLabelPointPositioner.getLabelRect(labelDataPoint.linesSize[DonutLabelUtils.HorizontalLineIndex], horizontalLineParentPoint, position, offset);
	            if (!labelRect || !diagonalLineRect || !horizontalLineRect)
	                return;
	            labelRect.left += center.x;
	            labelRect.top += center.y;
	            var centerForLinesWidth = center.x - labelRect.width / 2;
	            diagonalLineRect.left += centerForLinesWidth;
	            diagonalLineRect.top += center.y;
	            horizontalLineRect.left += centerForLinesWidth;
	            horizontalLineRect.top += center.y;
	            if (!grid.hasConflict(labelRect) && !grid.hasConflict(diagonalLineRect) && !grid.hasConflict(horizontalLineRect))
	                return { textRect: labelRect, diagonalLineRect: diagonalLineRect, horizontalLineRect: horizontalLineRect };
	        };
	        /**
	         * Returns an array of valid positions for hidden and truncated labels.
	         * For truncated labels will return positions with more available space.
	         * For hidden labels will return all possible positions by the order we draw labels (clockwise)
	         */
	        DonutLabelLayout.prototype.getLabelPointPositions = function (labelPoint, isTruncated) {
	            var parentShape = labelPoint.parentShape;
	            var position = parentShape.validPositions[0];
	            if (!isTruncated) {
	                return position === 4 /* Left */
	                    ? [128 /* AboveLeft */, 32 /* BelowLeft */]
	                    : [16 /* BelowRight */, 64 /* AboveRight */];
	            }
	            if (parentShape.point.y < 0) {
	                return position === 8 /* Right */
	                    ? [64 /* AboveRight */]
	                    : [128 /* AboveLeft */];
	            }
	            else {
	                return position === 8 /* Right */
	                    ? [16 /* BelowRight */]
	                    : [32 /* BelowLeft */];
	            }
	        };
	        /**
	         * Returns a new DonutLabelDataPoint after splitting it into two lines
	         */
	        DonutLabelLayout.prototype.splitDonutDataPoint = function (labelPoint) {
	            var textSize = {
	                width: Math.max(labelPoint.categoryLabelSize.width, labelPoint.dataLabelSize.width),
	                height: labelPoint.dataLabelSize.height * 2,
	            };
	            var newLabelPoint = _.clone(labelPoint);
	            newLabelPoint.textSize = textSize;
	            newLabelPoint.secondRowText = labelPoint.categoryLabel;
	            return newLabelPoint;
	        };
	        DonutLabelLayout.prototype.generateCandidateAngleForPosition = function (d, position) {
	            var midAngle = d.startAngle + ((d.endAngle - d.startAngle) / 2);
	            switch (position) {
	                case 64 /* AboveRight */:
	                case 32 /* BelowLeft */:
	                    return ((d.startAngle + midAngle) - Math.PI) / 2;
	                case 128 /* AboveLeft */:
	                case 16 /* BelowRight */:
	                    return ((midAngle + d.endAngle) - Math.PI) / 2;
	                default:
	                    debug.assertFail("Unsupported label position");
	            }
	        };
	        DonutLabelLayout.prototype.getPointPositionForAngle = function (angle) {
	            // Calculate the new label coordinates
	            var labelX = DonutLabelUtils.getXPositionForDonutLabel(Math.cos(angle) * this.outerRadius);
	            var labelY = Math.sin(angle) * this.outerRadius;
	            var newPosition = labelX < 0 ? 4 /* Left */ : 8 /* Right */;
	            var pointPosition = {
	                point: {
	                    x: labelX,
	                    y: labelY,
	                },
	                validPositions: [newPosition],
	                radius: 0,
	            };
	            return pointPosition;
	        };
	        DonutLabelLayout.prototype.score = function (labelPoint, point) {
	            var spaceAvailableForLabels = DonutLabelUtils.getSpaceAvailableForDonutLabels(point.x, this.donutChartProperties.viewport);
	            var textWidth;
	            // Check if we show category and data labels in one row
	            if (this.donutChartProperties.dataLabelsSettings.labelStyle === labelStyle.both && labelPoint.secondRowText == null) {
	                // Each of the labels gets half of the available space for labels so we take this into consideration in the score
	                textWidth = Math.max(labelPoint.categoryLabelSize.width, labelPoint.dataLabelSize.width + this.additionalCharsWidth);
	                spaceAvailableForLabels /= 2;
	            }
	            else {
	                textWidth = labelPoint.textSize.width;
	            }
	            return Math.max(textWidth - spaceAvailableForLabels, 0);
	        };
	        return DonutLabelLayout;
	    }());
	    powerbi.DonutLabelLayout = DonutLabelLayout;
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 228 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var NewDataLabelUtils = powerbi.visuals.NewDataLabelUtils;
	    var DefaultCentroidOffset = 5;
	    var OffsetDelta = 10;
	    var MaximumOffset = 60;
	    var stemExtension = 5;
	    var FilledMapLabelLayout = (function () {
	        function FilledMapLabelLayout() {
	        }
	        FilledMapLabelLayout.prototype.layout = function (labelDataPoints, viewport, polygonInfoTransform, redrawDataLabels) {
	            if (redrawDataLabels || this.labels === undefined) {
	                var labelDataPointsGroup = {
	                    labelDataPoints: labelDataPoints,
	                    maxNumberOfLabels: labelDataPoints.length
	                };
	                for (var _i = 0, labelDataPoints_1 = labelDataPoints; _i < labelDataPoints_1.length; _i++) {
	                    var labelPoint = labelDataPoints_1[_i];
	                    labelPoint.labelSize = {
	                        width: labelPoint.textSize.width + 2 * NewDataLabelUtils.horizontalLabelBackgroundPadding,
	                        height: labelPoint.textSize.height + 2 * NewDataLabelUtils.verticalLabelBackgroundPadding,
	                    };
	                }
	                var grid = new powerbi.LabelArrangeGrid([labelDataPointsGroup], viewport);
	                var resultingDataLabels = [];
	                var allPolygons = [];
	                for (var _a = 0, labelDataPoints_2 = labelDataPoints; _a < labelDataPoints_2.length; _a++) {
	                    var labelPoint = labelDataPoints_2[_a];
	                    var polygon = labelPoint.parentShape.polygon;
	                    allPolygons.push(polygon);
	                    polygon.pixelBoundingRect = polygonInfoTransform.applyToRect(polygon.absoluteBoundingRect());
	                }
	                var shapesgrid = new LabelPolygonArrangeGrid(allPolygons, viewport);
	                for (var _b = 0, labelDataPoints_3 = labelDataPoints; _b < labelDataPoints_3.length; _b++) {
	                    var labelPoint = labelDataPoints_3[_b];
	                    var dataLabel = this.getLabelByPolygonPositions(labelPoint, polygonInfoTransform, grid, shapesgrid);
	                    if (dataLabel != null) {
	                        resultingDataLabels.push(dataLabel);
	                    }
	                }
	                this.labels = resultingDataLabels;
	            }
	            else {
	                this.updateLabelOffsets(polygonInfoTransform);
	            }
	            return this.labels;
	        };
	        FilledMapLabelLayout.prototype.getLabelPolygon = function (mapDataPoint, position, pointPosition, offset) {
	            var dataPointSize = {
	                width: mapDataPoint.textSize.width,
	                height: (mapDataPoint.textSize.height)
	            };
	            return this.getLabelBoundingBox(dataPointSize, position, pointPosition, offset);
	        };
	        FilledMapLabelLayout.prototype.getLabelBoundingBox = function (dataPointSize, position, pointPosition, offset) {
	            switch (position) {
	                case 1 /* Above */: {
	                    return powerbi.DataLabelPointPositioner.above(dataPointSize, pointPosition, offset);
	                }
	                case 2 /* Below */: {
	                    return powerbi.DataLabelPointPositioner.below(dataPointSize, pointPosition, offset);
	                }
	                case 4 /* Left */: {
	                    return powerbi.DataLabelPointPositioner.left(dataPointSize, pointPosition, offset);
	                }
	                case 8 /* Right */: {
	                    return powerbi.DataLabelPointPositioner.right(dataPointSize, pointPosition, offset);
	                }
	                case 128 /* AboveLeft */: {
	                    return powerbi.DataLabelPointPositioner.aboveLeft(dataPointSize, pointPosition, offset);
	                }
	                case 64 /* AboveRight */: {
	                    return powerbi.DataLabelPointPositioner.aboveRight(dataPointSize, pointPosition, offset);
	                }
	                case 32 /* BelowLeft */: {
	                    return powerbi.DataLabelPointPositioner.belowLeft(dataPointSize, pointPosition, offset);
	                }
	                case 16 /* BelowRight */: {
	                    return powerbi.DataLabelPointPositioner.belowRight(dataPointSize, pointPosition, offset);
	                }
	                case 256 /* Center */: {
	                    return powerbi.DataLabelPointPositioner.center(dataPointSize, pointPosition);
	                }
	                default: {
	                    debug.assertFail("Unsupported label position");
	                }
	            }
	            return null;
	        };
	        FilledMapLabelLayout.prototype.getLabelByPolygonPositions = function (labelPoint, polygonInfoTransform, grid, shapesGrid) {
	            var offset = 0;
	            var inverseTransorm = polygonInfoTransform.getInverse();
	            for (var i = 0; i < 2; i++) {
	                if (i === 1) {
	                    offset = DefaultCentroidOffset;
	                }
	                for (var _i = 0, _a = labelPoint.parentShape.validPositions; _i < _a.length; _i++) {
	                    var position = _a[_i];
	                    var resultingAbsoluteBoundingBox = this.tryPositionForPolygonPosition(position, labelPoint, polygonInfoTransform, offset, inverseTransorm);
	                    if (position === 256 /* Center */ && i !== 0) {
	                        continue;
	                    }
	                    if (resultingAbsoluteBoundingBox) {
	                        var resultingBoundingBox = polygonInfoTransform.applyToRect(resultingAbsoluteBoundingBox);
	                        var dataLabel = {
	                            text: labelPoint.text,
	                            secondRowText: labelPoint.secondRowText,
	                            boundingBox: resultingBoundingBox,
	                            isVisible: true,
	                            fill: labelPoint.insideFill,
	                            identity: null,
	                            selected: false,
	                            hasBackground: true,
	                            textAnchor: "middle",
	                            originalPixelOffset: offset,
	                            isPlacedInsidePolygon: true,
	                            absoluteBoundingBoxCenter: {
	                                x: resultingAbsoluteBoundingBox.left + resultingAbsoluteBoundingBox.width / 2,
	                                y: resultingAbsoluteBoundingBox.top + resultingAbsoluteBoundingBox.height / 2
	                            }
	                        };
	                        return dataLabel;
	                    }
	                }
	            }
	            var currentOffset = 6;
	            while (currentOffset <= MaximumOffset) {
	                for (var _b = 0, _c = labelPoint.parentShape.validPositions; _b < _c.length; _b++) {
	                    var position = _c[_b];
	                    if (position === 256 /* Center */) {
	                        continue;
	                    }
	                    var polygon = labelPoint.parentShape.polygon;
	                    var pixelCentroid = polygonInfoTransform.applyToPoint(polygon.absoluteCentroid());
	                    var resultingAbsolutBoundingBox = this.tryPlaceLabelOutsidePolygon(grid, position, labelPoint, currentOffset, pixelCentroid, shapesGrid, inverseTransorm);
	                    if (resultingAbsolutBoundingBox) {
	                        var resultingBoundingBox = polygonInfoTransform.applyToRect(resultingAbsolutBoundingBox);
	                        var dataLabel = {
	                            text: labelPoint.text,
	                            secondRowText: labelPoint.secondRowText,
	                            boundingBox: resultingBoundingBox,
	                            isVisible: true,
	                            fill: labelPoint.insideFill,
	                            identity: null,
	                            selected: false,
	                            hasBackground: true,
	                            isPlacedInsidePolygon: false,
	                            textAnchor: "middle",
	                            originalPixelOffset: currentOffset,
	                            originalPosition: position,
	                            originalAbsoluteCentroid: polygon.absoluteCentroid(),
	                            absoluteBoundingBoxCenter: {
	                                x: resultingAbsolutBoundingBox.left + resultingAbsolutBoundingBox.width / 2,
	                                y: resultingAbsolutBoundingBox.top + resultingAbsolutBoundingBox.height / 2
	                            }
	                        };
	                        var pixelStemSource = this.calculateStemSource(polygonInfoTransform, inverseTransorm, polygon, resultingBoundingBox, position, pixelCentroid);
	                        dataLabel.leaderLinePoints = this.setLeaderLinePoints(pixelStemSource, this.calculateStemDestination(resultingBoundingBox, position));
	                        dataLabel.absoluteStemSource = inverseTransorm.applyToPoint(pixelStemSource);
	                        grid.add(resultingBoundingBox);
	                        return dataLabel;
	                    }
	                }
	                currentOffset += OffsetDelta;
	            }
	            return null;
	        };
	        FilledMapLabelLayout.prototype.setLeaderLinePoints = function (stemSource, stemDestination) {
	            return [[stemSource.x, stemSource.y], [stemDestination.x, stemDestination.y]];
	        };
	        FilledMapLabelLayout.prototype.calculateStemSource = function (polygonInfoTransform, inverseTransorm, polygon, labelBoundingBox, position, pixelCentroid) {
	            var absoluteStemSource = polygon.lineIntersectionPoint(polygon.absoluteCentroid(), inverseTransorm.applyToPoint({ x: labelBoundingBox.left + labelBoundingBox.width / 2, y: labelBoundingBox.top + labelBoundingBox.height / 2 }));
	            if (absoluteStemSource == null) {
	                return pixelCentroid;
	            }
	            var stemSource = polygonInfoTransform.applyToPoint(absoluteStemSource);
	            switch (position) {
	                case 1 /* Above */: {
	                    stemSource.y += stemExtension;
	                    break;
	                }
	                case 2 /* Below */: {
	                    stemSource.y -= stemExtension;
	                    break;
	                }
	                case 4 /* Left */: {
	                    stemSource.x += stemExtension;
	                    break;
	                }
	                case 8 /* Right */: {
	                    stemSource.x -= stemExtension;
	                    break;
	                }
	                case 128 /* AboveLeft */: {
	                    stemSource.x += (stemExtension / powerbi.DataLabelPointPositioner.cos45);
	                    stemSource.y += (stemExtension / powerbi.DataLabelPointPositioner.sin45);
	                    break;
	                }
	                case 64 /* AboveRight */: {
	                    stemSource.x -= (stemExtension / powerbi.DataLabelPointPositioner.cos45);
	                    stemSource.y += (stemExtension / powerbi.DataLabelPointPositioner.sin45);
	                    break;
	                }
	                case 32 /* BelowLeft */: {
	                    stemSource.x += (stemExtension / powerbi.DataLabelPointPositioner.cos45);
	                    stemSource.y -= (stemExtension / powerbi.DataLabelPointPositioner.sin45);
	                    break;
	                }
	                case 16 /* BelowRight */: {
	                    stemSource.x -= (stemExtension / powerbi.DataLabelPointPositioner.cos45);
	                    stemSource.y -= (stemExtension / powerbi.DataLabelPointPositioner.sin45);
	                    break;
	                }
	                case 256 /* Center */: {
	                    break;
	                }
	                default: {
	                    debug.assertFail("Unsupported label position");
	                }
	            }
	            return stemSource;
	        };
	        FilledMapLabelLayout.prototype.calculateStemDestination = function (labelBoundingBox, position) {
	            var x;
	            var y;
	            switch (position) {
	                case 1 /* Above */: {
	                    x = labelBoundingBox.left + labelBoundingBox.width / 2;
	                    y = labelBoundingBox.top + labelBoundingBox.height;
	                    break;
	                }
	                case 2 /* Below */: {
	                    x = labelBoundingBox.left + labelBoundingBox.width / 2;
	                    y = labelBoundingBox.top;
	                    break;
	                }
	                case 4 /* Left */: {
	                    x = labelBoundingBox.left + labelBoundingBox.width;
	                    y = labelBoundingBox.top + labelBoundingBox.height / 2;
	                    break;
	                }
	                case 8 /* Right */: {
	                    x = labelBoundingBox.left;
	                    y = labelBoundingBox.top + labelBoundingBox.height / 2;
	                    break;
	                }
	                case 128 /* AboveLeft */: {
	                    x = labelBoundingBox.left + labelBoundingBox.width;
	                    y = labelBoundingBox.top + labelBoundingBox.height;
	                    break;
	                }
	                case 64 /* AboveRight */: {
	                    x = labelBoundingBox.left;
	                    y = labelBoundingBox.top + labelBoundingBox.height;
	                    break;
	                }
	                case 32 /* BelowLeft */: {
	                    x = labelBoundingBox.left + labelBoundingBox.width;
	                    y = labelBoundingBox.top;
	                    break;
	                }
	                case 16 /* BelowRight */: {
	                    x = labelBoundingBox.left;
	                    y = labelBoundingBox.top;
	                    break;
	                }
	                case 256 /* Center */: {
	                    break;
	                }
	                default: {
	                    debug.assertFail("Unsupported label position");
	                }
	            }
	            return { x: x, y: y };
	        };
	        FilledMapLabelLayout.prototype.tryPositionForPolygonPosition = function (position, labelDataPoint, polygonInfoTransform, offset, inverseTransorm) {
	            var polygon = labelDataPoint.parentShape.polygon;
	            var pixelCentroid = polygonInfoTransform.applyToPoint(polygon.absoluteCentroid());
	            var labelRect = this.getLabelPolygon(labelDataPoint, position, pixelCentroid, offset);
	            var absoluteLabelRect = this.getAbsoluteRectangle(inverseTransorm, labelRect);
	            return polygon.contains(absoluteLabelRect) ? absoluteLabelRect : null;
	        };
	        /**
	        * Tests a particular position/offset combination for the given data label.
	        * If the label can be placed, returns the resulting bounding box for the data
	        * label.  If not, returns null.
	        */
	        FilledMapLabelLayout.prototype.tryPlaceLabelOutsidePolygon = function (grid, position, labelDataPoint, offset, pixelCentroid, shapesGrid, inverseTransform) {
	            var offsetForPosition = offset;
	            var labelRect = this.getLabelPolygon(labelDataPoint, position, pixelCentroid, offsetForPosition);
	            var otherLabelsConflict = grid.hasConflict(labelRect);
	            if (!otherLabelsConflict) {
	                var absoluteLabelRect = this.getAbsoluteRectangle(inverseTransform, labelRect);
	                if (!shapesGrid.hasConflict(absoluteLabelRect, labelRect))
	                    return absoluteLabelRect;
	            }
	            return null;
	        };
	        FilledMapLabelLayout.prototype.updateLabelOffsets = function (polygonInfoTransform) {
	            for (var _i = 0, _a = this.labels; _i < _a.length; _i++) {
	                var label = _a[_i];
	                if (!label.isVisible)
	                    continue;
	                if (label.isPlacedInsidePolygon) {
	                    var newOffset = polygonInfoTransform.applyToPoint(label.absoluteBoundingBoxCenter);
	                    var xDelta = (label.boundingBox.left + label.boundingBox.width / 2) - newOffset.x;
	                    var yDelta = (label.boundingBox.top + label.boundingBox.height / 2) - newOffset.y;
	                    label.boundingBox.top -= yDelta;
	                    label.boundingBox.left -= xDelta;
	                }
	                else {
	                    var stemSourcePoint = polygonInfoTransform.applyToPoint(label.absoluteStemSource);
	                    var pixelCentroid = polygonInfoTransform.applyToPoint(label.originalAbsoluteCentroid);
	                    label.boundingBox = this.getLabelBoundingBox({ width: label.boundingBox.width, height: label.boundingBox.height }, label.originalPosition, pixelCentroid, label.originalPixelOffset);
	                    if (label.leaderLinePoints !== undefined)
	                        label.leaderLinePoints = this.setLeaderLinePoints(stemSourcePoint, this.calculateStemDestination(label.boundingBox, label.originalPosition));
	                }
	            }
	        };
	        FilledMapLabelLayout.prototype.getAbsoluteRectangle = function (inverseTransorm, rect) {
	            return inverseTransorm.applyToRect(rect);
	        };
	        return FilledMapLabelLayout;
	    }());
	    powerbi.FilledMapLabelLayout = FilledMapLabelLayout;
	    var LabelPolygonArrangeGrid = (function () {
	        function LabelPolygonArrangeGrid(polygons, viewport) {
	            this.viewport = viewport;
	            var maxPolygonWidth = 0;
	            var maxPolygonHeight = 0;
	            for (var _i = 0, polygons_1 = polygons; _i < polygons_1.length; _i++) {
	                var polygon = polygons_1[_i];
	                var polygonSize = polygon.pixelBoundingRect;
	                if (polygonSize.width > maxPolygonWidth) {
	                    maxPolygonWidth = polygonSize.width;
	                }
	                if (polygonSize.height > maxPolygonHeight) {
	                    maxPolygonHeight = polygonSize.height;
	                }
	            }
	            if (maxPolygonWidth === 0) {
	                maxPolygonWidth = viewport.width;
	            }
	            if (maxPolygonHeight === 0) {
	                maxPolygonHeight = viewport.height;
	            }
	            var cellSize = this.cellSize = { width: maxPolygonWidth * LabelPolygonArrangeGrid.cellSizeMultiplier, height: maxPolygonHeight * LabelPolygonArrangeGrid.cellSizeMultiplier };
	            this.columnCount = LabelPolygonArrangeGrid.getCellCount(cellSize.width, viewport.width, 1, 100);
	            this.rowCount = LabelPolygonArrangeGrid.getCellCount(cellSize.height, viewport.height, 1, 100);
	            var grid = [];
	            for (var i = 0, ilen = this.columnCount; i < ilen; i++) {
	                grid[i] = [];
	                for (var j = 0, jlen = this.rowCount; j < jlen; j++) {
	                    grid[i][j] = [];
	                }
	            }
	            this.grid = grid;
	            for (var _a = 0, polygons_2 = polygons; _a < polygons_2.length; _a++) {
	                var polygon = polygons_2[_a];
	                this.add(polygon);
	            }
	        }
	        LabelPolygonArrangeGrid.prototype.hasConflict = function (absolutLabelRect, pixelLabelRect) {
	            var containingIndexRect = this.getContainingGridSubsection(pixelLabelRect);
	            var grid = this.grid;
	            for (var x = containingIndexRect.xMin; x < containingIndexRect.xMax; x++) {
	                for (var y = containingIndexRect.yMin; y < containingIndexRect.yMax; y++) {
	                    for (var _i = 0, _a = grid[x][y]; _i < _a.length; _i++) {
	                        var currentPolygon = _a[_i];
	                        if (currentPolygon.conflicts(absolutLabelRect)) {
	                            return true;
	                        }
	                    }
	                }
	            }
	            return false;
	        };
	        LabelPolygonArrangeGrid.prototype.add = function (polygon) {
	            var containingIndexRect = this.getContainingGridSubsection(polygon.pixelBoundingRect);
	            for (var x = containingIndexRect.xMin; x < containingIndexRect.xMax; x++) {
	                for (var y = containingIndexRect.yMin; y < containingIndexRect.yMax; y++) {
	                    this.grid[x][y].push(polygon);
	                }
	            }
	        };
	        LabelPolygonArrangeGrid.prototype.getContainingGridSubsection = function (rect) {
	            return {
	                xMin: LabelPolygonArrangeGrid.bound(Math.floor(rect.left / this.cellSize.width), 0, this.columnCount),
	                xMax: LabelPolygonArrangeGrid.bound(Math.ceil((rect.left + rect.width) / this.cellSize.width), 0, this.columnCount),
	                yMin: LabelPolygonArrangeGrid.bound(Math.floor(rect.top / this.cellSize.height), 0, this.rowCount),
	                yMax: LabelPolygonArrangeGrid.bound(Math.ceil((rect.top + rect.height) / this.cellSize.height), 0, this.rowCount),
	            };
	        };
	        LabelPolygonArrangeGrid.getCellCount = function (step, length, minCount, maxCount) {
	            return LabelPolygonArrangeGrid.bound(Math.ceil(length / step), minCount, maxCount);
	        };
	        LabelPolygonArrangeGrid.bound = function (value, min, max) {
	            return Math.max(Math.min(value, max), min);
	        };
	        /**
	         * A multiplier applied to the largest width height to attempt to balance # of
	         * polygons in each cell and number of cells each polygon belongs to
	         */
	        LabelPolygonArrangeGrid.cellSizeMultiplier = 2;
	        return LabelPolygonArrangeGrid;
	    }());
	    powerbi.LabelPolygonArrangeGrid = LabelPolygonArrangeGrid;
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 229 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        function createColorAllocatorFactory() {
	            return new ColorAllocatorFactory();
	        }
	        visuals.createColorAllocatorFactory = createColorAllocatorFactory;
	        var ColorAllocatorFactory = (function () {
	            function ColorAllocatorFactory() {
	            }
	            ColorAllocatorFactory.prototype.linearGradient2 = function (options) {
	                return new LinearGradient2Allocator(options);
	            };
	            ColorAllocatorFactory.prototype.linearGradient3 = function (options, splitScales) {
	                if (splitScales)
	                    return new LinearGradient3AllocatorWithSplittedScales(options);
	                return new LinearGradient3Allocator(options);
	            };
	            return ColorAllocatorFactory;
	        }());
	        var LinearGradient2Allocator = (function () {
	            function LinearGradient2Allocator(options) {
	                debug.assertValue(options, 'options');
	                this.options = options;
	                var min = options.min, max = options.max;
	                this.scale = d3.scale.linear()
	                    .domain([min.value, max.value])
	                    .range([min.color, max.color])
	                    .clamp(true); // process a value outside of the domain - set to extremum values
	            }
	            LinearGradient2Allocator.prototype.color = function (value) {
	                var min = this.options.min, max = this.options.max;
	                if (min.value === max.value) {
	                    if (value >= max.value)
	                        return max.color;
	                    return min.color;
	                }
	                return this.scale(value);
	            };
	            return LinearGradient2Allocator;
	        }());
	        var LinearGradient3Allocator = (function () {
	            function LinearGradient3Allocator(options) {
	                debug.assertValue(options, 'options');
	                this.options = options;
	                var min = options.min, mid = options.mid, max = options.max;
	                this.scale = d3.scale.linear()
	                    .domain([min.value, mid.value, max.value])
	                    .range([min.color, mid.color, max.color])
	                    .clamp(true); // process a value outside of the domain- set to extremum values
	            }
	            LinearGradient3Allocator.prototype.color = function (value) {
	                var min = this.options.min, mid = this.options.mid, max = this.options.max;
	                if (max.value === mid.value || mid.value === min.value || (max.value === mid.value && max.value === min.value)) {
	                    if (value >= max.value)
	                        return max.color;
	                    else if (value >= mid.value)
	                        return mid.color;
	                    return min.color;
	                }
	                return this.scale(value);
	            };
	            return LinearGradient3Allocator;
	        }());
	        var LinearGradient3AllocatorWithSplittedScales = (function () {
	            function LinearGradient3AllocatorWithSplittedScales(options) {
	                debug.assertValue(options, 'options');
	                this.options = options;
	                var min = options.min, mid = options.mid, max = options.max;
	                /*
	                If the center value is overridden, but the max and min remain automatic,
	                colors are then assigned on a scale between the overridden center value and the max/min values in the data.
	                Each side of the center value is assigned separately, independent of the relative scales.
	                */
	                this.scale1 = d3.scale.linear()
	                    .domain([min.value, mid.value])
	                    .range([min.color, mid.color])
	                    .clamp(true); // process a value outside of the domain- set to extremum values
	                this.scale2 = d3.scale.linear()
	                    .domain([mid.value, max.value])
	                    .range([mid.color, max.color])
	                    .clamp(true); // process a value outside of the domain- set to extremum values
	            }
	            LinearGradient3AllocatorWithSplittedScales.prototype.color = function (value) {
	                var min = this.options.min, mid = this.options.mid, max = this.options.max;
	                if (max.value === mid.value || mid.value === min.value || (max.value === mid.value && max.value === min.value)) {
	                    if (value >= max.value)
	                        return max.color;
	                    else if (value >= mid.value)
	                        return mid.color;
	                    return min.color;
	                }
	                else if (value <= mid.value) {
	                    return this.scale1(value);
	                }
	                return this.scale2(value);
	            };
	            return LinearGradient3AllocatorWithSplittedScales;
	        }());
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 230 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var BeautifiedFormat = {
	            '0.00 %;-0.00 %;0.00 %': 'Percentage',
	            '0.0 %;-0.0 %;0.0 %': 'Percentage1',
	        };
	        var defaultLocalizedStrings = {
	            'NullValue': '(Blank)',
	            'BooleanTrue': 'True',
	            'BooleanFalse': 'False',
	            'NaNValue': 'NaN',
	            'InfinityValue': '+Infinity',
	            'NegativeInfinityValue': '-Infinity',
	            'Restatement_Comma': '{0}, {1}',
	            'Restatement_CompoundAnd': '{0} and {1}',
	            'DisplayUnitSystem_EAuto_Title': 'Auto',
	            'DisplayUnitSystem_E0_Title': 'None',
	            'DisplayUnitSystem_E3_LabelFormat': '{0}K',
	            'DisplayUnitSystem_E3_Title': 'Thousands',
	            'DisplayUnitSystem_E6_LabelFormat': '{0}M',
	            'DisplayUnitSystem_E6_Title': 'Millions',
	            'DisplayUnitSystem_E9_LabelFormat': '{0}bn',
	            'DisplayUnitSystem_E9_Title': 'Billions',
	            'DisplayUnitSystem_E12_LabelFormat': '{0}T',
	            'DisplayUnitSystem_E12_Title': 'Trillions',
	            'Percentage': '#,0.##%',
	            'Percentage1': '#,0.#%',
	            'RichTextbox_Link_DefaultText': 'Link',
	            'TableTotalLabel': 'Total',
	            'ListJoin_Separator': ', ',
	            'Tooltip_HighlightedValueDisplayName': 'Highlighted',
	            'Funnel_PercentOfFirst': 'Percent of first',
	            'Funnel_PercentOfPrevious': 'Percent of previous',
	            'Funnel_PercentOfFirst_Highlight': 'Percent of first (highlighted)',
	            'Funnel_PercentOfPrevious_Highlight': 'Percent of previous (highlighted)',
	            // Geotagging strings
	            'GeotaggingString_Continent': 'continent',
	            'GeotaggingString_Continents': 'continents',
	            'GeotaggingString_Country': 'country',
	            'GeotaggingString_Countries': 'countries',
	            'GeotaggingString_State': 'state',
	            'GeotaggingString_States': 'states',
	            'GeotaggingString_City': 'city',
	            'GeotaggingString_Cities': 'cities',
	            'GeotaggingString_Town': 'town',
	            'GeotaggingString_Towns': 'towns',
	            'GeotaggingString_Province': 'province',
	            'GeotaggingString_Provinces': 'provinces',
	            'GeotaggingString_County': 'county',
	            'GeotaggingString_Counties': 'counties',
	            'GeotaggingString_Village': 'village',
	            'GeotaggingString_Villages': 'villages',
	            'GeotaggingString_Post': 'post',
	            'GeotaggingString_Zip': 'zip',
	            'GeotaggingString_Code': 'code',
	            'GeotaggingString_Place': 'place',
	            'GeotaggingString_Places': 'places',
	            'GeotaggingString_Address': 'address',
	            'GeotaggingString_Addresses': 'addresses',
	            'GeotaggingString_Street': 'street',
	            'GeotaggingString_Streets': 'streets',
	            'GeotaggingString_Longitude': 'longitude',
	            'GeotaggingString_Longitude_Short': 'lon',
	            'GeotaggingString_Longitude_Short2': 'long',
	            'GeotaggingString_Latitude': 'latitude',
	            'GeotaggingString_Latitude_Short': 'lat',
	            'GeotaggingString_PostalCode': 'postal code',
	            'GeotaggingString_PostalCodes': 'postal codes',
	            'GeotaggingString_ZipCode': 'zip code',
	            'GeotaggingString_ZipCodes': 'zip codes',
	            'GeotaggingString_Territory': 'territory',
	            'GeotaggingString_Territories': 'territories',
	            'Waterfall_IncreaseLabel': 'Increase',
	            'Waterfall_DecreaseLabel': 'Decrease',
	            'Waterfall_TotalLabel': 'Total',
	            'Slicer_SelectAll': 'Select All',
	        };
	        var DefaultVisualHostServices = (function () {
	            function DefaultVisualHostServices() {
	            }
	            // TODO: Add locale-awareness to this host service. Currently default/english functionality only.
	            DefaultVisualHostServices.initialize = function () {
	                visuals.valueFormatter.setLocaleOptions(DefaultVisualHostServices.createLocaleOptions());
	                visuals.TooltipManager.setLocalizedStrings(DefaultVisualHostServices.createTooltipLocaleOptions());
	            };
	            /**
	             * Create locale options.
	             *
	             * Note: Public for testability.
	             */
	            DefaultVisualHostServices.createLocaleOptions = function () {
	                return {
	                    null: defaultLocalizedStrings['NullValue'],
	                    true: defaultLocalizedStrings['BooleanTrue'],
	                    false: defaultLocalizedStrings['BooleanFalse'],
	                    NaN: defaultLocalizedStrings['NaNValue'],
	                    infinity: defaultLocalizedStrings['InfinityValue'],
	                    negativeInfinity: defaultLocalizedStrings['NegativeInfinityValue'],
	                    beautify: function (format) { return DefaultVisualHostServices.beautify(format); },
	                    describe: function (exponent) { return DefaultVisualHostServices.describeUnit(exponent); },
	                    restatementComma: defaultLocalizedStrings['Restatement_Comma'],
	                    restatementCompoundAnd: defaultLocalizedStrings['Restatement_CompoundAnd'],
	                    restatementCompoundOr: defaultLocalizedStrings['Restatement_CompoundOr']
	                };
	            };
	            DefaultVisualHostServices.createTooltipLocaleOptions = function () {
	                return {
	                    highlightedValueDisplayName: defaultLocalizedStrings['Tooltip_HighlightedValueDisplayName']
	                };
	            };
	            DefaultVisualHostServices.prototype.getLocalizedString = function (stringId) {
	                return defaultLocalizedStrings[stringId];
	            };
	            // NO-OP IHostServices methods
	            DefaultVisualHostServices.prototype.onDragStart = function () { };
	            DefaultVisualHostServices.prototype.canSelect = function () { return false; };
	            DefaultVisualHostServices.prototype.onSelecting = function (args) { args.action = 0 /* Selection */; };
	            DefaultVisualHostServices.prototype.onSelect = function () { };
	            DefaultVisualHostServices.prototype.onContextMenu = function () { };
	            DefaultVisualHostServices.prototype.loadMoreData = function () { };
	            DefaultVisualHostServices.prototype.persistProperties = function (changes) { };
	            DefaultVisualHostServices.prototype.onCustomSort = function (args) { };
	            DefaultVisualHostServices.prototype.getViewMode = function () { return 0 /* View */; };
	            DefaultVisualHostServices.prototype.setWarnings = function (warnings) { };
	            DefaultVisualHostServices.prototype.setToolbar = function ($toolbar) { };
	            DefaultVisualHostServices.prototype.shouldRetainSelection = function () { return false; };
	            DefaultVisualHostServices.prototype.geocoder = function () { return visuals.services.createGeocoder(); };
	            DefaultVisualHostServices.prototype.geolocation = function () { return visuals.services.createGeolocation(); };
	            DefaultVisualHostServices.prototype.promiseFactory = function () { return powerbi.createJQueryPromiseFactory(); };
	            DefaultVisualHostServices.prototype.visualCapabilitiesChanged = function () { };
	            DefaultVisualHostServices.prototype.analyzeFilter = function (options) {
	                return {
	                    isNotFilter: false,
	                    selectedIdentities: [],
	                    filter: undefined,
	                    defaultValue: undefined,
	                };
	            };
	            DefaultVisualHostServices.prototype.getIdentityDisplayNames = function (dentities) { return; };
	            DefaultVisualHostServices.prototype.setIdentityDisplayNames = function (displayNamesIdentityPairs) { };
	            DefaultVisualHostServices.beautify = function (format) {
	                var key = BeautifiedFormat[format];
	                if (key)
	                    return defaultLocalizedStrings[key] || format;
	                return format;
	            };
	            DefaultVisualHostServices.describeUnit = function (exponent) {
	                var exponentLookup = (exponent === -1) ? 'Auto' : exponent.toString();
	                var title = defaultLocalizedStrings["DisplayUnitSystem_E" + exponentLookup + "_Title"];
	                var format = (exponent <= 0) ? '{0}' : defaultLocalizedStrings["DisplayUnitSystem_E" + exponentLookup + "_LabelFormat"];
	                if (title || format)
	                    return { title: title, format: format };
	            };
	            return DefaultVisualHostServices;
	        }());
	        visuals.DefaultVisualHostServices = DefaultVisualHostServices;
	        visuals.defaultVisualHostServices = new DefaultVisualHostServices();
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 231 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var ArrayExtensions = jsCommon.ArrayExtensions;
	        var SemanticFilter = powerbi.data.SemanticFilter;
	        /**
	         * Factory method to create an IInteractivityService instance.
	         */
	        function createInteractivityService(hostServices) {
	            return new InteractivityService(hostServices);
	        }
	        visuals.createInteractivityService = createInteractivityService;
	        /**
	         * Creates a clear an svg rect to catch clear clicks.
	         */
	        function appendClearCatcher(selection) {
	            return selection
	                .append("rect")
	                .classed("clearCatcher", true)
	                .attr({ width: "100%", height: "100%" });
	        }
	        visuals.appendClearCatcher = appendClearCatcher;
	        function isCategoryColumnSelected(propertyId, categories, idx) {
	            return categories.objects != null
	                && categories.objects[idx]
	                && powerbi.DataViewObjects.getValue(categories.objects[idx], propertyId);
	        }
	        visuals.isCategoryColumnSelected = isCategoryColumnSelected;
	        function dataHasSelection(data) {
	            for (var i = 0, ilen = data.length; i < ilen; i++) {
	                if (data[i].selected)
	                    return true;
	            }
	            return false;
	        }
	        visuals.dataHasSelection = dataHasSelection;
	        var InteractivityService = (function () {
	            function InteractivityService(hostServices) {
	                this.renderSelectionInVisual = _.noop;
	                this.renderSelectionInLegend = _.noop;
	                this.renderSelectionInLabels = _.noop;
	                // Selection state
	                this.selectedIds = [];
	                this.isInvertedSelectionMode = false;
	                this.dataPointObjectName = 'dataPoint';
	                debug.assertValue(hostServices, 'hostServices');
	                this.hostService = hostServices;
	            }
	            // IInteractivityService Implementation
	            /** Binds the vsiual to the interactivityService */
	            InteractivityService.prototype.bind = function (dataPoints, behavior, behaviorOptions, options) {
	                var _this = this;
	                // Bind the data
	                if (options && options.overrideSelectionFromData) {
	                    // Override selection state from data points if needed
	                    this.takeSelectionStateFromDataPoints(dataPoints);
	                }
	                if (options) {
	                    if (options.isLegend) {
	                        // Bind to legend data instead of normal data if isLegend
	                        this.selectableLegendDataPoints = dataPoints;
	                        this.renderSelectionInLegend = function () { return behavior.renderSelection(_this.legendHasSelection()); };
	                    }
	                    else if (options.isLabels) {
	                        //Bind to label data instead of normal data if isLabels
	                        this.selectableLabelsDataPoints = dataPoints;
	                        this.renderSelectionInLabels = function () { return behavior.renderSelection(_this.labelsHasSelection()); };
	                    }
	                    else {
	                        this.selectableDataPoints = dataPoints;
	                        this.renderSelectionInVisual = function () { return behavior.renderSelection(_this.hasSelection()); };
	                    }
	                    if (options.hasSelectionOverride != null)
	                        this.hasSelectionOverride = options.hasSelectionOverride;
	                    if (options.slicerValueHandler)
	                        this.slicerValueHandler = options.slicerValueHandler;
	                }
	                else {
	                    this.selectableDataPoints = dataPoints;
	                    this.renderSelectionInVisual = function () { return behavior.renderSelection(_this.hasSelection()); };
	                }
	                // Bind to the behavior
	                this.behavior = behavior;
	                behavior.bindEvents(behaviorOptions, this);
	                // Sync data points with current selection state
	                this.syncSelectionState();
	            };
	            /**
	             * Sets the selected state of all selectable data points to false and invokes the behavior's select command.
	             */
	            InteractivityService.prototype.clearSelection = function () {
	                // if default value is already applied, don't clear the default selection
	                if (this.slicerValueHandler && this.slicerValueHandler.getDefaultValue() && this.useDefaultValue) {
	                    this.isInvertedSelectionMode = false;
	                    return;
	                }
	                this.hasSelectionOverride = undefined;
	                ArrayExtensions.clear(this.selectedIds);
	                this.isInvertedSelectionMode = false;
	                this.applyToAllSelectableDataPoints(function (dataPoint) { return dataPoint.selected = false; });
	                this.renderAll();
	            };
	            InteractivityService.prototype.applySelectionStateToData = function (dataPoints) {
	                for (var _i = 0, dataPoints_1 = dataPoints; _i < dataPoints_1.length; _i++) {
	                    var dataPoint = dataPoints_1[_i];
	                    dataPoint.selected = InteractivityService.checkDatapointAgainstSelectedIds(dataPoint, this.selectedIds);
	                }
	                return this.hasSelection();
	            };
	            /**
	             * Checks whether there is at least one item selected.
	             */
	            InteractivityService.prototype.hasSelection = function () {
	                return this.selectedIds.length > 0;
	            };
	            InteractivityService.prototype.legendHasSelection = function () {
	                return this.selectableLegendDataPoints ? dataHasSelection(this.selectableLegendDataPoints) : false;
	            };
	            InteractivityService.prototype.labelsHasSelection = function () {
	                return this.selectableLabelsDataPoints ? dataHasSelection(this.selectableLabelsDataPoints) : false;
	            };
	            InteractivityService.prototype.isSelectionModeInverted = function () {
	                return this.isInvertedSelectionMode;
	            };
	            InteractivityService.prototype.setSelectionModeInverted = function (inverted) {
	                this.isInvertedSelectionMode = inverted;
	            };
	            // ISelectionHandler Implementation
	            InteractivityService.prototype.handleSelection = function (dataPoint, multiSelect) {
	                // defect 7067397: should not happen so assert but also don't continue as it's
	                // causing a lot of error telemetry in desktop.
	                debug.assertValue(dataPoint, 'dataPoint');
	                if (!dataPoint)
	                    return;
	                var selectingSelectorsByColumn;
	                if (dataPoint.specificIdentity) {
	                    selectingSelectorsByColumn = dataPoint.specificIdentity.getSelectorsByColumn();
	                }
	                else if (dataPoint.identity) {
	                    selectingSelectorsByColumn = dataPoint.identity.getSelectorsByColumn();
	                }
	                var selectingArgs = {
	                    visualObjects: [{
	                            objectName: this.dataPointObjectName,
	                            selectorsByColumn: selectingSelectorsByColumn,
	                        }],
	                };
	                this.hostService.onSelecting(selectingArgs);
	                if (selectingArgs.action === 0 /* Selection */ || selectingArgs.action == null) {
	                    if (!dataPoint.identity) {
	                        this.handleClearSelection();
	                    }
	                    else {
	                        this.useDefaultValue = false;
	                        this.select(dataPoint, multiSelect);
	                        this.sendSelectionToHost();
	                        this.renderAll();
	                    }
	                }
	            };
	            InteractivityService.prototype.handleContextMenu = function (dataPoint, point) {
	                this.sendContextMenuToHost(dataPoint, point);
	            };
	            InteractivityService.prototype.handleClearSelection = function () {
	                this.useDefaultValue = true;
	                this.clearSelection();
	                this.sendSelectionToHost();
	            };
	            InteractivityService.prototype.toggleSelectionModeInversion = function () {
	                this.useDefaultValue = false;
	                this.isInvertedSelectionMode = !this.isInvertedSelectionMode;
	                ArrayExtensions.clear(this.selectedIds);
	                this.applyToAllSelectableDataPoints(function (dataPoint) { return dataPoint.selected = false; });
	                this.sendSelectionToHost();
	                this.isInvertedSelectionMode ? this.syncSelectionStateInverted() : this.syncSelectionState();
	                this.renderAll();
	                return this.isInvertedSelectionMode;
	            };
	            InteractivityService.prototype.persistSelectionFilter = function (filterPropertyIdentifier) {
	                this.hostService.persistProperties(InteractivityService.createChangeForFilterProperty(filterPropertyIdentifier, this.getFilterFromSelectors()));
	            };
	            InteractivityService.prototype.persistSelfFilter = function (filterPropertyIdentifier, selfFilter) {
	                this.hostService.persistProperties(InteractivityService.createChangeForFilterProperty(filterPropertyIdentifier, selfFilter));
	            };
	            InteractivityService.prototype.setDefaultValueMode = function (useDefaultValue) {
	                this.useDefaultValue = useDefaultValue;
	            };
	            InteractivityService.prototype.isDefaultValueEnabled = function () {
	                return this.useDefaultValue;
	            };
	            // Private utility methods
	            InteractivityService.prototype.renderAll = function () {
	                this.renderSelectionInVisual();
	                this.renderSelectionInLegend();
	                this.renderSelectionInLabels();
	            };
	            /** Marks a data point as selected and syncs selection with the host. */
	            InteractivityService.prototype.select = function (d, multiSelect) {
	                // If we're in inverted mode, use the invertedSelect instead
	                if (this.isInvertedSelectionMode) {
	                    return this.selectInverted(d, multiSelect);
	                }
	                // For highlight data points we actually want to select the non-highlight data point
	                if (d.identity && d.identity.highlight) {
	                    d = _.find(this.selectableDataPoints, function (dp) { return !dp.identity.highlight && d.identity.includes(dp.identity, /* ignoreHighlight */ true); });
	                    debug.assertValue(d, 'Expected to find a non-highlight data point');
	                }
	                var id = d.identity;
	                if (!id)
	                    return;
	                var selected = !d.selected || (!multiSelect && this.selectedIds.length > 1);
	                // If we have a multiselect flag, we attempt a multiselect
	                if (multiSelect) {
	                    if (selected) {
	                        d.selected = true;
	                        this.selectedIds.push(id);
	                        if (id.hasIdentity()) {
	                            this.removeSelectionIdsWithOnlyMeasures();
	                        }
	                        else {
	                            this.removeSelectionIdsExceptOnlyMeasures();
	                        }
	                    }
	                    else {
	                        d.selected = false;
	                        this.removeId(id);
	                    }
	                }
	                // We do a single select if we didn't do a multiselect or if we find out that the multiselect is invalid.
	                if (!multiSelect || !this.hostService.canSelect(this.createSelectEventArgs(this.selectedIds))) {
	                    this.clearSelection();
	                    if (selected) {
	                        d.selected = true;
	                        this.selectedIds.push(id);
	                    }
	                }
	                this.syncSelectionState();
	            };
	            InteractivityService.prototype.selectInverted = function (d, multiSelect) {
	                var wasSelected = d.selected;
	                var id = d.identity;
	                debug.assert(!!multiSelect, "inverted selections are only supported in multiselect mode");
	                // the current datapoint state has to be inverted
	                d.selected = !wasSelected;
	                if (wasSelected) {
	                    this.removeId(id);
	                }
	                else {
	                    this.selectedIds.push(id);
	                    if (id.hasIdentity()) {
	                        this.removeSelectionIdsWithOnlyMeasures();
	                    }
	                    else {
	                        this.removeSelectionIdsExceptOnlyMeasures();
	                    }
	                }
	                this.syncSelectionStateInverted();
	            };
	            InteractivityService.prototype.removeId = function (toRemove) {
	                var selectedIds = this.selectedIds;
	                for (var i = selectedIds.length - 1; i > -1; i--) {
	                    var currentId = selectedIds[i];
	                    if (toRemove.includes(currentId))
	                        selectedIds.splice(i, 1);
	                }
	            };
	            InteractivityService.prototype.getFilterFromSelectors = function () {
	                var selectors = [];
	                if (this.selectedIds.length > 0) {
	                    selectors = _.chain(this.selectedIds)
	                        .filter(function (value) { return value.hasIdentity(); })
	                        .map(function (value) { return value.getSelector(); })
	                        .value();
	                }
	                var filter = powerbi.data.Selector.filterFromSelector(selectors, this.isInvertedSelectionMode);
	                if (this.slicerValueHandler && this.slicerValueHandler.getDefaultValue()) {
	                    // we explicitly check for true/false because undefine means no default value
	                    if (this.useDefaultValue === true)
	                        filter = SemanticFilter.getDefaultValueFilter(this.slicerValueHandler.getIdentityFields());
	                    else if (_.isEmpty(selectors))
	                        filter = SemanticFilter.getAnyValueFilter(this.slicerValueHandler.getIdentityFields());
	                }
	                return filter;
	            };
	            InteractivityService.createChangeForFilterProperty = function (filterPropertyIdentifier, filter) {
	                var properties = {};
	                var instance = {
	                    objectName: filterPropertyIdentifier.objectName,
	                    selector: undefined,
	                    properties: properties
	                };
	                if (filter == null) {
	                    properties[filterPropertyIdentifier.propertyName] = {};
	                    return {
	                        remove: [instance]
	                    };
	                }
	                else {
	                    properties[filterPropertyIdentifier.propertyName] = filter;
	                    return {
	                        merge: [instance]
	                    };
	                }
	            };
	            InteractivityService.prototype.sendContextMenuToHost = function (dataPoint, position) {
	                var host = this.hostService;
	                if (!host.onContextMenu)
	                    return;
	                var selectors = this.getSelectorsByColumn([dataPoint.identity]);
	                if (_.isEmpty(selectors))
	                    return;
	                var args = {
	                    data: selectors,
	                    position: position
	                };
	                host.onContextMenu(args);
	            };
	            InteractivityService.prototype.sendSelectionToHost = function () {
	                var host = this.hostService;
	                if (host.onSelect) {
	                    var selectArgs = this.createSelectEventArgs(this.selectedIds);
	                    host.onSelect(selectArgs);
	                }
	            };
	            InteractivityService.prototype.createSelectEventArgs = function (selectedIds) {
	                var shouldInsertSelectors = false;
	                var dataPointObjectName = this.dataPointObjectName;
	                if (!_.isEmpty(selectedIds)) {
	                    shouldInsertSelectors = selectedIds[0].getSelector() && !selectedIds[0].getSelectorsByColumn();
	                }
	                var selectedIdsWithIdentities = _.chain(selectedIds)
	                    .filter(function (value) { return value.hasIdentity(); });
	                var selectEventArgs = {
	                    visualObjects: selectedIdsWithIdentities
	                        .map(function (value) { return { objectName: dataPointObjectName, selectorsByColumn: value.getSelectorsByColumn() }; })
	                        .value(),
	                };
	                if (shouldInsertSelectors) {
	                    selectEventArgs.selectors = selectedIdsWithIdentities
	                        .map(function (value) { return value.getSelector(); })
	                        .value();
	                }
	                return selectEventArgs;
	            };
	            InteractivityService.prototype.getSelectorsByColumn = function (selectionIds) {
	                return _(selectionIds)
	                    .filter(function (value) { return value.hasIdentity; })
	                    .map(function (value) { return value.getSelectorsByColumn(); })
	                    .compact()
	                    .value();
	            };
	            InteractivityService.prototype.takeSelectionStateFromDataPoints = function (dataPoints) {
	                debug.assertValue(dataPoints, "dataPoints");
	                var selectedIds = this.selectedIds;
	                // Replace the existing selectedIds rather than merging.
	                ArrayExtensions.clear(selectedIds);
	                for (var _i = 0, dataPoints_2 = dataPoints; _i < dataPoints_2.length; _i++) {
	                    var dataPoint = dataPoints_2[_i];
	                    if (dataPoint.selected)
	                        selectedIds.push(dataPoint.identity);
	                }
	            };
	            /**
	             * Syncs the selection state for all data points that have the same category. Returns
	             * true if the selection state was out of sync and corrections were made; false if
	             * the data is already in sync with the service.
	             *
	             * If the data is not compatible with the current service's current selection state,
	             * the state is cleared and the cleared selection is sent to the host.
	             *
	             * Ignores series for now, since we don't support series selection at the moment.
	             */
	            InteractivityService.prototype.syncSelectionState = function () {
	                if (this.isInvertedSelectionMode) {
	                    return this.syncSelectionStateInverted();
	                }
	                var selectedIds = this.selectedIds;
	                var selectableDataPoints = this.selectableDataPoints;
	                var selectableLegendDataPoints = this.selectableLegendDataPoints;
	                var selectableLabelsDataPoints = this.selectableLabelsDataPoints;
	                var foundMatchingId = false; // Checked only against the visual's data points; it's possible to have stuff selected in the visual that's not in the legend, but not vice-verse
	                if (!selectableDataPoints && !selectableLegendDataPoints)
	                    return;
	                if (selectableDataPoints) {
	                    if (InteractivityService.updateSelectableDataPointsBySelectedIds(selectableDataPoints, selectedIds))
	                        foundMatchingId = true;
	                }
	                if (selectableLegendDataPoints) {
	                    if (InteractivityService.updateSelectableDataPointsBySelectedIds(selectableLegendDataPoints, selectedIds))
	                        foundMatchingId = true;
	                }
	                if (selectableLabelsDataPoints) {
	                    var labelsDataPoint_1;
	                    for (var i = 0, ilen = selectableLabelsDataPoints.length; i < ilen; i++) {
	                        labelsDataPoint_1 = selectableLabelsDataPoints[i];
	                        if (selectedIds.some(function (value) { return value.includes(labelsDataPoint_1.identity); }))
	                            labelsDataPoint_1.selected = true;
	                        else
	                            labelsDataPoint_1.selected = false;
	                    }
	                }
	                if (!foundMatchingId && selectedIds.length > 0) {
	                    this.clearSelection();
	                    this.sendSelectionToHost();
	                }
	            };
	            InteractivityService.prototype.syncSelectionStateInverted = function () {
	                var selectedIds = this.selectedIds;
	                var selectableDataPoints = this.selectableDataPoints;
	                if (!selectableDataPoints)
	                    return;
	                if (selectedIds.length === 0) {
	                    for (var _i = 0, selectableDataPoints_1 = selectableDataPoints; _i < selectableDataPoints_1.length; _i++) {
	                        var dataPoint_1 = selectableDataPoints_1[_i];
	                        dataPoint_1.selected = false;
	                    }
	                }
	                else {
	                    for (var _a = 0, selectableDataPoints_2 = selectableDataPoints; _a < selectableDataPoints_2.length; _a++) {
	                        var dataPoint = selectableDataPoints_2[_a];
	                        if (selectedIds.some(function (value) { return value.includes(dataPoint.identity); }))
	                            dataPoint.selected = true;
	                        else if (dataPoint.selected)
	                            dataPoint.selected = false;
	                    }
	                }
	            };
	            InteractivityService.prototype.applyToAllSelectableDataPoints = function (action) {
	                var selectableDataPoints = this.selectableDataPoints;
	                var selectableLegendDataPoints = this.selectableLegendDataPoints;
	                var selectableLabelsDataPoints = this.selectableLabelsDataPoints;
	                if (selectableDataPoints) {
	                    for (var _i = 0, selectableDataPoints_3 = selectableDataPoints; _i < selectableDataPoints_3.length; _i++) {
	                        var dataPoint = selectableDataPoints_3[_i];
	                        action(dataPoint);
	                    }
	                }
	                if (selectableLegendDataPoints) {
	                    for (var _a = 0, selectableLegendDataPoints_1 = selectableLegendDataPoints; _a < selectableLegendDataPoints_1.length; _a++) {
	                        var dataPoint = selectableLegendDataPoints_1[_a];
	                        action(dataPoint);
	                    }
	                }
	                if (selectableLabelsDataPoints) {
	                    for (var _b = 0, selectableLabelsDataPoints_1 = selectableLabelsDataPoints; _b < selectableLabelsDataPoints_1.length; _b++) {
	                        var dataPoint = selectableLabelsDataPoints_1[_b];
	                        action(dataPoint);
	                    }
	                }
	            };
	            InteractivityService.updateSelectableDataPointsBySelectedIds = function (selectableDataPoints, selectedIds) {
	                var foundMatchingId = false;
	                for (var _i = 0, selectableDataPoints_4 = selectableDataPoints; _i < selectableDataPoints_4.length; _i++) {
	                    var datapoint = selectableDataPoints_4[_i];
	                    datapoint.selected = InteractivityService.checkDatapointAgainstSelectedIds(datapoint, selectedIds);
	                    if (datapoint.selected)
	                        foundMatchingId = true;
	                }
	                return foundMatchingId;
	            };
	            InteractivityService.checkDatapointAgainstSelectedIds = function (datapoint, selectedIds) {
	                return selectedIds.some(function (value) { return value.includes(datapoint.identity); });
	            };
	            InteractivityService.prototype.removeSelectionIdsWithOnlyMeasures = function () {
	                this.selectedIds = _.filter(this.selectedIds, function (identity) { return identity.hasIdentity(); });
	            };
	            InteractivityService.prototype.removeSelectionIdsExceptOnlyMeasures = function () {
	                this.selectedIds = _.filter(this.selectedIds, function (identity) { return !identity.hasIdentity(); });
	            };
	            return InteractivityService;
	        }());
	        visuals.InteractivityService = InteractivityService;
	        ;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 232 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var services;
	        (function (services) {
	            var CategoryTypes = visuals.MapUtil.CategoryTypes;
	            var Settings = visuals.MapUtil.Settings;
	            function createGeocoder() {
	                return {
	                    geocode: geocode,
	                    geocodeBoundary: geocodeBoundary,
	                    geocodePoint: geocodePoint,
	                    tryGeocodeImmediate: tryGeocodeImmediate,
	                    tryGeocodeBoundaryImmediate: tryGeocodeBoundaryImmediate,
	                };
	            }
	            services.createGeocoder = createGeocoder;
	            services.safeCharacters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";
	            /** Note: Used for test mockup */
	            services.BingAjaxCall = $.ajax;
	            services.CategoryTypeArray = [
	                "Address",
	                "City",
	                "Continent",
	                "Country",
	                "County",
	                "Longitude",
	                "Latitude",
	                "Place",
	                "PostalCode",
	                "StateOrProvince"
	            ];
	            function isCategoryType(value) {
	                return services.CategoryTypeArray.indexOf(value) > -1;
	            }
	            services.isCategoryType = isCategoryType;
	            services.BingEntities = {
	                Continent: "Continent",
	                Sovereign: "Sovereign",
	                CountryRegion: "CountryRegion",
	                AdminDivision1: "AdminDivision1",
	                AdminDivision2: "AdminDivision2",
	                PopulatedPlace: "PopulatedPlace",
	                Postcode: "Postcode",
	                Postcode1: "Postcode1",
	                Neighborhood: "Neighborhood",
	                Address: "Address",
	            };
	            // Static variables for caching, maps, etc.
	            var geocodeQueue;
	            var activeRequests;
	            var categoryToBingEntity;
	            var categoryToBingEntityGeodata;
	            var geocodingCache;
	            var GeocodeQuery = (function () {
	                function GeocodeQuery(query, category) {
	                    this.query = query != null ? query : "";
	                    this.category = category != null ? category : "";
	                    this.key = (this.query + "/" + this.category).toLowerCase();
	                    if (!geocodingCache) {
	                        geocodingCache = services.createGeocodingCache(Settings.MaxCacheSize, Settings.MaxCacheSizeOverflow);
	                    }
	                }
	                GeocodeQuery.prototype.getBingEntity = function () {
	                    var category = this.category.toLowerCase();
	                    if (!categoryToBingEntity) {
	                        categoryToBingEntity = {};
	                        categoryToBingEntity[CategoryTypes.Continent.toLowerCase()] = services.BingEntities.Continent;
	                        categoryToBingEntity[CategoryTypes.CountryRegion.toLowerCase()] = services.BingEntities.Sovereign;
	                        categoryToBingEntity[CategoryTypes.StateOrProvince.toLowerCase()] = services.BingEntities.AdminDivision1;
	                        categoryToBingEntity[CategoryTypes.County.toLowerCase()] = services.BingEntities.AdminDivision2;
	                        categoryToBingEntity[CategoryTypes.City.toLowerCase()] = services.BingEntities.PopulatedPlace;
	                        categoryToBingEntity[CategoryTypes.PostalCode.toLowerCase()] = services.BingEntities.Postcode;
	                        categoryToBingEntity[CategoryTypes.Address.toLowerCase()] = services.BingEntities.Address;
	                    }
	                    return categoryToBingEntity[category] || "";
	                };
	                GeocodeQuery.prototype.getUrl = function () {
	                    var url = Settings.BingUrl + "?key=" + Settings.BingKey;
	                    var entityType = this.getBingEntity();
	                    var queryAdded = false;
	                    if (entityType) {
	                        if (entityType === services.BingEntities.Postcode) {
	                            url += "&includeEntityTypes=Postcode,Postcode1,Postcode2,Postcode3,Postcode4";
	                        }
	                        else if (this.query.indexOf(",") === -1 && (entityType === services.BingEntities.AdminDivision1 || entityType === services.BingEntities.AdminDivision2)) {
	                            queryAdded = true;
	                            try {
	                                url += "&adminDistrict=" + decodeURIComponent(this.query);
	                            }
	                            catch (e) {
	                                return null;
	                            }
	                        }
	                        else {
	                            url += "&includeEntityTypes=" + entityType;
	                        }
	                    }
	                    if (!queryAdded) {
	                        try {
	                            url += "&q=" + decodeURIComponent(this.query);
	                        }
	                        catch (e) {
	                            return null;
	                        }
	                    }
	                    var cultureName = navigator.userLanguage || navigator["language"];
	                    cultureName = mapLocalesForBing(cultureName);
	                    if (cultureName) {
	                        url += "&c=" + cultureName;
	                    }
	                    url += "&maxRes=20";
	                    // If the query is of length 2, request the ISO 2-letter country code to be returned with the result to be compared against the query so that such results can be preferred.
	                    if (this.query.length === 2 && this.category === CategoryTypes.CountryRegion) {
	                        url += "&include=ciso2";
	                    }
	                    return url;
	                };
	                return GeocodeQuery;
	            }());
	            services.GeocodeQuery = GeocodeQuery;
	            var GeocodePointQuery = (function (_super) {
	                __extends(GeocodePointQuery, _super);
	                function GeocodePointQuery(latitude, longitude, entities) {
	                    _super.call(this, [latitude, longitude].join(), "Point");
	                    this.latitude = latitude;
	                    this.longitude = longitude;
	                    this.entities = entities;
	                }
	                GeocodePointQuery.prototype.getUrl = function () {
	                    debug.assert(this.entities.every(function (e) { return !!_.findKey(services.BingEntities, function (be) { return be === e; }); }), "All entities should match one of the allowed BingEntities");
	                    var url = Settings.BingUrl + "/" +
	                        [this.latitude, this.longitude].join() + "?" +
	                        "key=" + Settings.BingKey +
	                        (_.isEmpty(this.entities) ? "" : "&includeEntityTypes=" + this.entities.join()) +
	                        "&include=ciso2";
	                    return url;
	                };
	                return GeocodePointQuery;
	            }(GeocodeQuery));
	            services.GeocodePointQuery = GeocodePointQuery;
	            var GeocodeBoundaryQuery = (function (_super) {
	                __extends(GeocodeBoundaryQuery, _super);
	                function GeocodeBoundaryQuery(latitude, longitude, category, levelOfDetail, maxGeoData) {
	                    if (maxGeoData === void 0) { maxGeoData = 3; }
	                    _super.call(this, [latitude, longitude, levelOfDetail, maxGeoData].join(","), category);
	                    this.latitude = latitude;
	                    this.longitude = longitude;
	                    this.levelOfDetail = levelOfDetail;
	                    this.maxGeoData = maxGeoData;
	                }
	                GeocodeBoundaryQuery.prototype.getBingEntity = function () {
	                    var category = this.category.toLowerCase();
	                    if (!categoryToBingEntityGeodata) {
	                        categoryToBingEntityGeodata = {};
	                        categoryToBingEntityGeodata[CategoryTypes.CountryRegion.toLowerCase()] = services.BingEntities.CountryRegion;
	                        categoryToBingEntityGeodata[CategoryTypes.StateOrProvince.toLowerCase()] = services.BingEntities.AdminDivision1;
	                        categoryToBingEntityGeodata[CategoryTypes.County.toLowerCase()] = services.BingEntities.AdminDivision2;
	                        categoryToBingEntityGeodata[CategoryTypes.City.toLowerCase()] = services.BingEntities.PopulatedPlace;
	                        categoryToBingEntityGeodata[CategoryTypes.PostalCode.toLowerCase()] = services.BingEntities.Postcode1;
	                    }
	                    return categoryToBingEntityGeodata[category] || "";
	                };
	                GeocodeBoundaryQuery.prototype.getUrl = function () {
	                    var url = Settings.BingUrlGeodata + "key=" + Settings.BingKey + "&$format=json";
	                    var entityType = this.getBingEntity();
	                    if (!entityType) {
	                        return null;
	                    }
	                    var cultureName = navigator.userLanguage || navigator["language"];
	                    cultureName = mapLocalesForBing(cultureName);
	                    var cultures = cultureName.split("-");
	                    var data = [this.latitude, this.longitude, this.levelOfDetail, "'" + entityType + "'", 1, 0, "'" + cultureName + "'"];
	                    if (cultures.length > 1) {
	                        data.push("'" + cultures[1] + "'");
	                    }
	                    return url + "&SpatialFilter=GetBoundary(" + data.join(", ") + ")";
	                };
	                return GeocodeBoundaryQuery;
	            }(GeocodeQuery));
	            services.GeocodeBoundaryQuery = GeocodeBoundaryQuery;
	            /**
	             * Map locales that cause failures to similar locales that work
	             */
	            function mapLocalesForBing(locale) {
	                switch (locale.toLowerCase()) {
	                    case 'fr':
	                        return 'fr-FR';
	                    default:
	                        return locale;
	                }
	            }
	            function tryGeocodeImmediate(query, category) {
	                var result = geocodingCache ? geocodingCache.getCoordinates(new GeocodeQuery(query, category).key) : undefined;
	                return result;
	            }
	            function tryGeocodeBoundaryImmediate(latitude, longitude, category, levelOfDetail, maxGeoData) {
	                if (maxGeoData === void 0) { maxGeoData = 3; }
	                var result = geocodingCache ? geocodingCache.getCoordinates(new GeocodeBoundaryQuery(latitude, longitude, category, levelOfDetail, maxGeoData).key) : undefined;
	                return result;
	            }
	            function geocodeCore(geocodeQuery, options) {
	                var result = geocodingCache ? geocodingCache.getCoordinates(geocodeQuery.key) : undefined;
	                var deferred = $.Deferred();
	                if (result) {
	                    deferred.resolve(result);
	                }
	                else {
	                    var item_1 = { query: geocodeQuery, deferred: deferred, isResolved: false };
	                    if (options && options.timeout) {
	                        options.timeout.finally(function () {
	                            if (!item_1.isResolved) {
	                                item_1.deferred.reject();
	                                item_1.isResolved = true;
	                            }
	                        });
	                    }
	                    geocodeQueue.push(item_1);
	                    dequeue();
	                }
	                return deferred;
	            }
	            services.geocodeCore = geocodeCore;
	            function geocode(query, category, options) {
	                if (category === void 0) { category = ""; }
	                return geocodeCore(new GeocodeQuery(query, category), options);
	            }
	            services.geocode = geocode;
	            function geocodeBoundary(latitude, longitude, category, levelOfDetail, maxGeoData, options) {
	                if (category === void 0) { category = ""; }
	                if (levelOfDetail === void 0) { levelOfDetail = 2; }
	                if (maxGeoData === void 0) { maxGeoData = 3; }
	                return geocodeCore(new GeocodeBoundaryQuery(latitude, longitude, category, levelOfDetail, maxGeoData), options);
	            }
	            services.geocodeBoundary = geocodeBoundary;
	            function geocodePoint(latitude, longitude, entities, options) {
	                return geocodeCore(new GeocodePointQuery(latitude, longitude, entities), options);
	            }
	            services.geocodePoint = geocodePoint;
	            function dequeue(decrement) {
	                if (decrement === void 0) { decrement = 0; }
	                activeRequests -= decrement;
	                while (activeRequests < Settings.MaxBingRequest) {
	                    if (geocodeQueue.length === 0) {
	                        break;
	                    }
	                    activeRequests++;
	                    makeRequest(geocodeQueue.shift());
	                }
	            }
	            function makeRequest(item) {
	                if (!item.isResolved) {
	                    var result = geocodingCache ? geocodingCache.getCoordinates(item.query.key) : undefined;
	                    if (result) {
	                        item.deferred.resolve(result);
	                        item.isResolved = true;
	                    }
	                }
	                if (item.isResolved) {
	                    setTimeout(function () { return dequeue(1); });
	                    return;
	                }
	                // Unfortunately the Bing service doesn't support CORS, only jsonp. This issue must be raised and revised.
	                // VSTS: 1396088 - Tracking: Ask: Bing geocoding to support CORS
	                var config = {
	                    type: "GET",
	                    dataType: "jsonp",
	                    jsonp: "jsonp"
	                };
	                var url = item.query.getUrl();
	                if (!url) {
	                    completeRequest(item, new Error("Unsupported query. " + item.query.query));
	                }
	                services.BingAjaxCall(url, config).then(function (data) {
	                    try {
	                        if (item.query instanceof GeocodeBoundaryQuery) {
	                            var result = data;
	                            if (result && result.d && Array.isArray(result.d.results) && result.d.results.length > 0) {
	                                var entity = result.d.results[0];
	                                var primitives = entity.Primitives;
	                                if (primitives && primitives.length > 0) {
	                                    var coordinates = {
	                                        latitude: item.query.latitude,
	                                        longitude: item.query.longitude,
	                                        locations: []
	                                    };
	                                    primitives.sort(function (a, b) {
	                                        if (a.Shape.length < b.Shape.length) {
	                                            return 1;
	                                        }
	                                        if (a.Shape.length > b.Shape.length) {
	                                            return -1;
	                                        }
	                                        return 0;
	                                    });
	                                    var maxGeoData = Math.min(primitives.length, item.query.maxGeoData);
	                                    for (var i = 0; i < maxGeoData; i++) {
	                                        var ringStr = primitives[i].Shape;
	                                        var ringArray = ringStr.split(",");
	                                        for (var j = 1; j < ringArray.length; j++) {
	                                            coordinates.locations.push({ nativeBing: ringArray[j] });
	                                        }
	                                    }
	                                    completeRequest(item, null, coordinates);
	                                }
	                                else {
	                                    completeRequest(item, new Error("Geocode result is empty."));
	                                }
	                            }
	                            else {
	                                completeRequest(item, new Error("Geocode result is empty."));
	                            }
	                        }
	                        else if (item.query instanceof GeocodePointQuery) {
	                            var resources = data.resourceSets[0].resources;
	                            if (Array.isArray(resources) && resources.length > 0) {
	                                var index = getBestResultIndex(resources, item.query);
	                                var pointData = resources[index].point.coordinates;
	                                var addressData = resources[index].address;
	                                var name_1 = resources[index].name;
	                                var coordinates = {
	                                    latitude: parseFloat(pointData[0]),
	                                    longitude: parseFloat(pointData[1]),
	                                    addressLine: addressData.addressLine,
	                                    locality: addressData.locality,
	                                    neighborhood: addressData.neighborhood,
	                                    adminDistrict: addressData.adminDistrict,
	                                    adminDistrict2: addressData.adminDistrict2,
	                                    formattedAddress: addressData.formattedAddress,
	                                    postalCode: addressData.postalCode,
	                                    countryRegionIso2: addressData.countryRegionIso2,
	                                    countryRegion: addressData.countryRegion,
	                                    landmark: addressData.landmark,
	                                    name: name_1,
	                                };
	                                completeRequest(item, null, coordinates);
	                            }
	                            else {
	                                completeRequest(item, null, null);
	                            }
	                        }
	                        else {
	                            var resources = data.resourceSets[0].resources;
	                            if (Array.isArray(resources) && resources.length > 0) {
	                                var index = getBestResultIndex(resources, item.query);
	                                var pointData = resources[index].point.coordinates;
	                                var coordinates = {
	                                    latitude: parseFloat(pointData[0]),
	                                    longitude: parseFloat(pointData[1])
	                                };
	                                completeRequest(item, null, coordinates);
	                            }
	                            else {
	                                completeRequest(item, new Error("Geocode result is empty."));
	                            }
	                        }
	                    }
	                    catch (error) {
	                        completeRequest(item, error);
	                    }
	                }, function (error) {
	                    completeRequest(item, error);
	                });
	            }
	            var dequeueTimeoutId;
	            function completeRequest(item, error, coordinate) {
	                if (coordinate === void 0) { coordinate = null; }
	                if (!item.isResolved) {
	                    if (error) {
	                        item.deferred.reject(error);
	                    }
	                    else {
	                        if (geocodingCache && !(item.query instanceof GeocodePointQuery))
	                            geocodingCache.registerCoordinates(item.query.key, coordinate);
	                        item.deferred.resolve(coordinate);
	                    }
	                    item.isResolved = true;
	                }
	                dequeueTimeoutId = setTimeout(function () { return dequeue(1); }, Settings.UseDoubleArrayGeodataResult ? Settings.UseDoubleArrayDequeueTimeout : 0);
	            }
	            function getBestResultIndex(resources, query) {
	                var queryString = query.query.toLowerCase();
	                // If string is of length 2 and is a country, check against the ISO country code of results, prefering exact matches
	                if (queryString.length === 2 && query.category === CategoryTypes.CountryRegion) {
	                    for (var index = 0; index < resources.length; index++) {
	                        var iso2 = resources[index].address && resources[index].address.countryRegionIso2;
	                        if (iso2 && queryString === iso2.toLowerCase()) {
	                            return index;
	                        }
	                    }
	                }
	                // Prefer results that match the targetEntity (geotagged category) on the query
	                var targetEntity = query.getBingEntity().toLowerCase();
	                for (var index = 0; index < resources.length; index++) {
	                    var resultEntity = (resources[index].entityType || "").toLowerCase();
	                    if (resultEntity === targetEntity) {
	                        return index;
	                    }
	                }
	                return 0;
	            }
	            function resetStaticGeocoderState(cache) {
	                if (cache !== undefined)
	                    geocodingCache = cache;
	                geocodeQueue = [];
	                activeRequests = 0;
	                categoryToBingEntity = null;
	                clearTimeout(dequeueTimeoutId);
	            }
	            services.resetStaticGeocoderState = resetStaticGeocoderState;
	            resetStaticGeocoderState();
	        })(services = visuals.services || (visuals.services = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 233 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var services;
	        (function (services) {
	            function createGeocodingCache(maxCacheSize, maxCacheSizeOverflow, localStorageService) {
	                if (!localStorageService)
	                    localStorageService = powerbi.localStorageService;
	                return new GeocodingCache(maxCacheSize, maxCacheSizeOverflow, localStorageService);
	            }
	            services.createGeocodingCache = createGeocodingCache;
	            var GeocodingCache = (function () {
	                function GeocodingCache(maxCacheSize, maxCacheSizeOverflow, localStorageService) {
	                    this.geocodeCache = {};
	                    this.geocodeCacheCount = 0;
	                    this.maxCacheSize = maxCacheSize;
	                    this.maxCacheSizeOverflow = maxCacheSizeOverflow;
	                    this.localStorageService = localStorageService;
	                }
	                /**
	                 * Retrieves the coordinate for the key from the cache, returning undefined on a cache miss.
	                 */
	                GeocodingCache.prototype.getCoordinates = function (key) {
	                    // Check in-memory cache
	                    var pair = this.geocodeCache[key];
	                    if (pair) {
	                        ++pair.hitCount;
	                        return pair.coordinate;
	                    }
	                    // Check local storage cache
	                    pair = this.localStorageService.getData(key);
	                    if (pair) {
	                        this.registerInMemory(key, pair.coordinate);
	                        return pair.coordinate;
	                    }
	                    return undefined;
	                };
	                /**
	                 * Registers the query and coordinate to the cache.
	                 */
	                GeocodingCache.prototype.registerCoordinates = function (key, coordinate) {
	                    this.registerInMemory(key, coordinate);
	                    this.registerInStorage(key, coordinate);
	                };
	                GeocodingCache.prototype.registerInMemory = function (key, coordinate) {
	                    var geocodeCache = this.geocodeCache;
	                    var maxCacheSize = this.maxCacheSize;
	                    var maxCacheCount = maxCacheSize + this.maxCacheSizeOverflow;
	                    // are we about to exceed the maximum?
	                    if (this.geocodeCacheCount >= maxCacheCount) {
	                        var keys = Object.keys(geocodeCache);
	                        var cacheSize = keys.length;
	                        // sort keys in *descending* hitCount order
	                        keys.sort(function (a, b) {
	                            var cachedA = geocodeCache[a];
	                            var cachedB = geocodeCache[b];
	                            var ca = cachedA ? cachedA.hitCount : 0;
	                            var cb = cachedB ? cachedB.hitCount : 0;
	                            return ca < cb ? 1 : (ca > cb ? -1 : 0);
	                        });
	                        // whack ones with the lower hitCounts.
	                        // - while # whacked keys is small, do a quick wipe
	                        // - after awhile we get lots of keys whose cached value is undefined. 
	                        //   when there are "too many," make a whole new memory cache.
	                        if (cacheSize < 2 * maxCacheCount) {
	                            for (var i = maxCacheSize; i < cacheSize; i++)
	                                geocodeCache[keys[i]] = undefined;
	                        }
	                        else {
	                            var newGeocodeCache = {};
	                            for (var i = 0; i < maxCacheSize; ++i)
	                                newGeocodeCache[keys[i]] = geocodeCache[keys[i]];
	                            geocodeCache = this.geocodeCache = newGeocodeCache;
	                        }
	                        this.geocodeCacheCount = maxCacheSize;
	                    }
	                    geocodeCache[key] = { coordinate: coordinate, hitCount: 1 };
	                    ++this.geocodeCacheCount;
	                };
	                GeocodingCache.prototype.registerInStorage = function (key, coordinate) {
	                    this.localStorageService.setData(key, { coordinate: coordinate });
	                };
	                return GeocodingCache;
	            }());
	        })(services = visuals.services || (visuals.services = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 234 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var services;
	        (function (services) {
	            function createGeolocation() {
	                return new GeolocationService();
	            }
	            services.createGeolocation = createGeolocation;
	            /**
	             * HTML5 Implementation of IGeolocation
	             */
	            var GeolocationService = (function () {
	                function GeolocationService() {
	                    this.webGeolocation = navigator.geolocation;
	                }
	                GeolocationService.prototype.watchPosition = function (successCallback, errorCallback) {
	                    return this.webGeolocation.watchPosition(function (position) {
	                        successCallback(position);
	                    }, function (error) {
	                        if (errorCallback != null) {
	                            errorCallback(error);
	                        }
	                    });
	                };
	                GeolocationService.prototype.clearWatch = function (watchId) {
	                    this.webGeolocation.clearWatch(watchId);
	                };
	                GeolocationService.prototype.getCurrentPosition = function (successCallback, errorCallback) {
	                    this.webGeolocation.getCurrentPosition(function (position) {
	                        successCallback(position);
	                    }, function (error) {
	                        if (errorCallback != null) {
	                            errorCallback(error);
	                        }
	                    });
	                };
	                return GeolocationService;
	            }());
	        })(services = visuals.services || (visuals.services = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 235 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/// <reference path="../../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var controls;
	        (function (controls) {
	            var UNSELECTABLE_CLASS_NAME = "unselectable";
	            function fire(eventHandlers, eventArgs) {
	                if (eventHandlers) {
	                    for (var i = 0; i < eventHandlers.length; i++) {
	                        var h = eventHandlers[i];
	                        h(eventArgs);
	                    }
	                }
	            }
	            controls.fire = fire;
	            var ScrollbarButton = (function () {
	                // Constructor
	                function ScrollbarButton(owner, direction) {
	                    this._owner = owner;
	                    this._direction = direction;
	                    this._timerHandle = undefined;
	                    this.createView();
	                    var that = this;
	                    this._element.addEventListener("mousedown", function (e) { that.onMouseDown(e); });
	                    $(this._element).addClass(UNSELECTABLE_CLASS_NAME);
	                    $(this._svg).addClass(UNSELECTABLE_CLASS_NAME);
	                    $(this._polygon).addClass(UNSELECTABLE_CLASS_NAME);
	                }
	                Object.defineProperty(ScrollbarButton.prototype, "element", {
	                    // Properties
	                    get: function () {
	                        return this._element;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                // Methods
	                ScrollbarButton.prototype.createView = function () {
	                    var svgns = "http://www.w3.org/2000/svg";
	                    this._polygon = document.createElementNS(svgns, "polygon");
	                    this._polygon.setAttributeNS(null, "points", "3,3 6,3 13,8 6,13 3,13 10,8");
	                    this._polygon.setAttributeNS(null, "fill", ScrollbarButton.ARROW_COLOR);
	                    this._svg = document.createElementNS(svgns, "svg");
	                    var svgStyle = this._svg.style;
	                    svgStyle.position = "absolute";
	                    svgStyle.left = "0px";
	                    svgStyle.top = "0px";
	                    this._svg.appendChild(this._polygon);
	                    this._element = document.createElement("div");
	                    this._element.className = Scrollbar.arrowClassName;
	                    this._element.appendChild(this._svg);
	                    this._owner.element.appendChild(this._element);
	                };
	                ScrollbarButton.prototype.onMouseDown = function (event) {
	                    var that = this;
	                    clearTimeout(this._timerHandle);
	                    if (!this._mouseUpWrapper) {
	                        event.cancelBubble = true;
	                        var that_1 = this;
	                        this._mouseUpWrapper = function (event) { that_1.onMouseUp(event); };
	                        Scrollbar.addDocumentMouseUpEvent(this._mouseUpWrapper);
	                    }
	                    this._owner._scrollSmallIncrement(this._direction);
	                    this._owner.refresh();
	                    this._timerHandle = setTimeout(function () { that.onMouseDown(event); }, 100);
	                    if (event.preventDefault) {
	                        event.preventDefault(); // prevent dragging
	                    }
	                };
	                ScrollbarButton.prototype.onMouseUp = function (event) {
	                    clearTimeout(this._timerHandle);
	                    Scrollbar.removeDocumentMouseUpEvent(this._mouseUpWrapper);
	                    this._mouseUpWrapper = undefined;
	                };
	                ScrollbarButton.prototype.arrange = function (width, height, angle) {
	                    var size = Math.min(width, height);
	                    var scale = size / 16;
	                    var x = (width - size) / 2;
	                    var y = (height - size) / 2;
	                    this._polygon.setAttributeNS(null, "transform", "translate(" + x + ", " + y + ") scale(" + scale + ") rotate(" + angle + ",8,8)");
	                    this._svg.setAttributeNS(null, "width", width + "px");
	                    this._svg.setAttributeNS(null, "height", height + "px");
	                    controls.HTMLElementUtils.setElementWidth(this._element, width);
	                    controls.HTMLElementUtils.setElementHeight(this._element, height);
	                };
	                // Const
	                // TODO: Move to style
	                ScrollbarButton.MIN_WIDTH = 26;
	                ScrollbarButton.ARROW_COLOR = "#404040";
	                return ScrollbarButton;
	            }());
	            controls.ScrollbarButton = ScrollbarButton;
	            /** Scrollbar base class */
	            var Scrollbar = (function () {
	                function Scrollbar(parentElement, layoutKind) {
	                    this.MIN_BAR_SIZE = 10;
	                    this.min = 0;
	                    this.max = 10;
	                    this.viewMin = 0;
	                    this.viewSize = 2;
	                    this.smallIncrement = 1;
	                    this._onscroll = [];
	                    this._screenToOffsetScale = 1.0;
	                    this.createView(parentElement, layoutKind);
	                    var that = this;
	                    this._element.addEventListener("mousedown", function (e) { that.onBackgroundMouseDown(e); });
	                    this._middleBar.addEventListener("mousedown", function (e) { that.onMiddleBarMouseDown(e); });
	                    this._timerHandle = undefined;
	                    this._visible = true;
	                    this.element["winControl"] = this;
	                    $(this._touchPanel).addClass(UNSELECTABLE_CLASS_NAME);
	                }
	                Scrollbar.prototype.scrollBy = function (delta) {
	                    this.scrollTo(this.viewMin + delta);
	                };
	                Scrollbar.prototype.scrollUp = function () {
	                    this.scrollBy(-this.smallIncrement);
	                };
	                Scrollbar.prototype.scrollDown = function () {
	                    this.scrollBy(this.smallIncrement);
	                };
	                Scrollbar.prototype.scrollPageUp = function () {
	                    this.scrollBy(-this.viewSize);
	                };
	                Scrollbar.prototype.scrollPageDown = function () {
	                    this.scrollBy(this.viewSize);
	                };
	                Object.defineProperty(Scrollbar.prototype, "width", {
	                    get: function () {
	                        return this._width;
	                    },
	                    set: function (value) {
	                        this._width = value;
	                        this._element.style.width = value;
	                        this.invalidateArrange();
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(Scrollbar.prototype, "height", {
	                    get: function () {
	                        return this._height;
	                    },
	                    set: function (value) {
	                        this._height = value;
	                        this._element.style.height = value;
	                        this.invalidateArrange();
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Scrollbar.prototype.refresh = function () {
	                    debug.assertFail("PureVirtualMethod: Scrollbar.refresh()");
	                };
	                Object.defineProperty(Scrollbar.prototype, "element", {
	                    get: function () {
	                        return this._element;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(Scrollbar.prototype, "maxButton", {
	                    get: function () {
	                        return this._maxButton;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(Scrollbar.prototype, "middleBar", {
	                    get: function () {
	                        return this._middleBar;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Scrollbar.prototype._scrollSmallIncrement = function (direction) {
	                    this.scrollBy(this.smallIncrement * direction);
	                };
	                Object.defineProperty(Scrollbar.prototype, "visible", {
	                    get: function () {
	                        return this._visible;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(Scrollbar.prototype, "isInMouseCapture", {
	                    get: function () {
	                        return this._timerHandle !== undefined;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Scrollbar.prototype.show = function (value) {
	                    this._visible = value;
	                    this.element.style.visibility = value ? "visible" : "hidden";
	                    this.invalidateArrange();
	                };
	                Scrollbar.prototype._getMouseOffset = function (event) {
	                    if (event.offsetX !== undefined)
	                        return { x: event.offsetX, y: event.offsetY };
	                    if (event.layerX !== undefined)
	                        return { x: event.layerX, y: event.layerY };
	                    return { x: event.screenX, y: event.screenY };
	                };
	                Scrollbar.prototype._getOffsetXDelta = function (event) {
	                    return (event.screenX - this._screenPrevMousePos.x) / this._screenToOffsetScale;
	                };
	                Scrollbar.prototype._getOffsetYDelta = function (event) {
	                    return (event.screenY - this._screenPrevMousePos.y) / this._screenToOffsetScale;
	                };
	                Scrollbar.prototype._getOffsetXTouchDelta = function (event) {
	                    return this._getMouseOffset(event).x - this._offsetTouchPrevPos.x;
	                };
	                Scrollbar.prototype._getOffsetYTouchDelta = function (event) {
	                    return this._getMouseOffset(event).y - this._offsetTouchPrevPos.y;
	                };
	                Scrollbar.prototype.initTouch = function (panel, allowMouseDrag) {
	                    var _this = this;
	                    this._touchPanel = panel;
	                    this._allowMouseDrag = allowMouseDrag === undefined ? true : allowMouseDrag;
	                    if ("ontouchmove" in panel) {
	                        panel.addEventListener("touchstart", function (e) { return _this.onTouchStart(e); });
	                        panel.addEventListener("touchmove", function (e) { return _this.onTouchMove(e); });
	                        panel.addEventListener("touchend", function (e) { return _this.onTouchEnd(e); });
	                    }
	                    else {
	                        panel.addEventListener("mousedown", function (e) { return _this.onTouchMouseDown(e); });
	                        panel.addEventListener("mousemove", function (e) { return _this.onTouchMouseMove(e); });
	                        panel.addEventListener("mouseup", function (e) { return _this.onTouchMouseUp(e); });
	                    }
	                };
	                Scrollbar.prototype.onTouchStart = function (e) {
	                    if (e.touches.length === 1) {
	                        this.onTouchMouseDown(e.touches[0]);
	                    }
	                };
	                Scrollbar.prototype.onTouchMove = function (e) {
	                    if (e.touches.length === 1) {
	                        if (e.preventDefault)
	                            e.preventDefault();
	                        this.onTouchMouseMove(e.touches[0]);
	                    }
	                };
	                Scrollbar.prototype.onTouchEnd = function (e) {
	                    this.onTouchMouseUp(e.touches.length === 1 ? e.touches[0] : e, true);
	                };
	                Scrollbar.prototype.onTouchMouseDown = function (e) {
	                    // except IE touch cancels mouse so not need for detection. For IE touch and mouse difference is detected by a flag.
	                    if (!this._allowMouseDrag &&
	                        e["pointerType"] === MSPointerEvent.MSPOINTER_TYPE_MOUSE) {
	                        return;
	                    }
	                    if ("setCapture" in this._touchPanel) {
	                        this._touchPanel.setCapture(true);
	                    }
	                    this._offsetTouchPrevPos = this._offsetTouchStartPos = null;
	                    this._touchStarted = true;
	                };
	                Scrollbar.prototype._getOffsetTouchDelta = function (e) {
	                    debug.assertFail("PureVirtualMethod: Scrollbar._getOffsetTouchDelta()");
	                    return null;
	                };
	                Scrollbar.prototype.onTouchMouseMove = function (e) {
	                    if (this._touchStarted) {
	                        if (!this._offsetTouchStartPos) {
	                            this._offsetTouchPrevPos = this._offsetTouchStartPos = this._getMouseOffset(e);
	                        }
	                        var delta = this._getOffsetTouchDelta(e);
	                        if (delta !== 0) {
	                            this.scrollBy(-delta / this._getRunningSize(false) * this.viewSize);
	                            this._offsetTouchPrevPos = this._getMouseOffset(e);
	                        }
	                        if (e.preventDefault)
	                            e.preventDefault();
	                        e.cancelBubble = true;
	                    }
	                };
	                Scrollbar.prototype.onTouchMouseUp = function (e, bubble) {
	                    if (this._touchStarted) {
	                        if (this._offsetTouchStartPos) {
	                            var end = this._getMouseOffset(e);
	                            if (!bubble && (Math.abs(this._offsetTouchStartPos.x - end.x) > 3 || Math.abs(this._offsetTouchStartPos.y - end.y) > 3)) {
	                                if (e.preventDefault)
	                                    e.preventDefault();
	                                e.cancelBubble = true;
	                            }
	                        }
	                    }
	                    if ("releaseCapture" in this._touchPanel) {
	                        this._touchPanel.releaseCapture();
	                    }
	                    this._touchStarted = false;
	                };
	                Scrollbar.prototype.createView = function (parentElement, layoutKind) {
	                    this._element = document.createElement("div");
	                    this._element.className = Scrollbar.className;
	                    this._element.setAttribute("drag-resize-disabled", "true");
	                    if (layoutKind === 0 /* Canvas */)
	                        parentElement.appendChild(this._element);
	                    this._minButton = new ScrollbarButton(this, -1);
	                    this._maxButton = new ScrollbarButton(this, 1);
	                    this._middleBar = document.createElement("div");
	                    this._middleBar.className = Scrollbar.barClassName;
	                    this._element.appendChild(this._middleBar);
	                };
	                Scrollbar.prototype.scrollTo = function (pos) {
	                    var viewMin = Math.min(this.max - this.viewSize, Math.max(this.min, pos));
	                    if (viewMin !== this.viewMin) {
	                        this.viewMin = viewMin;
	                        fire(this._onscroll, null);
	                    }
	                };
	                Scrollbar.prototype._scrollByPage = function (event) {
	                    debug.assertFail("PureVirtualMethod: Scrollbar._scrollByPage()");
	                };
	                Scrollbar.prototype._getRunningSize = function (net) {
	                    debug.assertFail("PureVirtualMethod: Scrollbar._getRunningSize()");
	                    return null;
	                };
	                Scrollbar.prototype._getOffsetDelta = function (event) {
	                    debug.assertFail("PureVirtualMethod: Scrollbar._getOffsetDelta()");
	                    return null;
	                };
	                Scrollbar.prototype.scroll = function (event) {
	                    var delta = this._getOffsetDelta(event) / this._getRunningSize(true) * (this.max - this.min);
	                    if (delta < 0) {
	                        if (this._getScreenMousePos(event) >= this._screenMaxMousePos) {
	                            return;
	                        }
	                    }
	                    else if (delta > 0) {
	                        if (this._getScreenMousePos(event) <= this._screenMinMousePos) {
	                            return;
	                        }
	                    }
	                    this.scrollBy(delta);
	                };
	                Object.defineProperty(Scrollbar.prototype, "actualWidth", {
	                    get: function () {
	                        if (this._actualWidth === undefined) {
	                            this.arrange();
	                        }
	                        return this._actualWidth;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(Scrollbar.prototype, "actualHeight", {
	                    get: function () {
	                        if (!this._actualHeight === undefined) {
	                            this.arrange();
	                        }
	                        return this._actualHeight;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(Scrollbar.prototype, "actualButtonWidth", {
	                    get: function () {
	                        if (!this._actualButtonWidth === undefined) {
	                            this.arrange();
	                        }
	                        return this._actualButtonWidth;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(Scrollbar.prototype, "actualButtonHeight", {
	                    get: function () {
	                        if (!this._actualButtonHeight === undefined) {
	                            this.arrange();
	                        }
	                        return this._actualButtonHeight;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Scrollbar.prototype.arrange = function () {
	                    if (!this._actualWidth) {
	                        this._actualWidth = this._element.offsetWidth;
	                        this._actualHeight = this._element.offsetHeight;
	                        this._actualButtonWidth = this._calculateButtonWidth();
	                        this._actualButtonHeight = this._calculateButtonHeight();
	                        this._minButton.arrange(this._actualButtonWidth, this._actualButtonHeight, this._getMinButtonAngle());
	                        this._maxButton.arrange(this._actualButtonWidth, this._actualButtonHeight, this._getMaxButtonAngle());
	                        this._setMaxButtonPosition();
	                    }
	                };
	                Scrollbar.prototype._calculateButtonWidth = function () {
	                    debug.assertFail("PureVirtualMethod: Scrollbar._calculateButtonWidth()");
	                    return null;
	                };
	                Scrollbar.prototype._calculateButtonHeight = function () {
	                    debug.assertFail("PureVirtualMethod: Scrollbar._calculateButtonHeight()");
	                    return null;
	                };
	                Scrollbar.prototype._getMinButtonAngle = function () {
	                    debug.assertFail("PureVirtualMethod: Scrollbar._getMinButtonAngle()");
	                    return null;
	                };
	                Scrollbar.prototype._getMaxButtonAngle = function () {
	                    debug.assertFail("PureVirtualMethod: Scrollbar._getMaxButtonAngle()");
	                    return null;
	                };
	                Scrollbar.prototype._setMaxButtonPosition = function () {
	                    debug.assertFail("PureVirtualMethod: Scrollbar._setMaxButtonPosition()");
	                };
	                Scrollbar.prototype.invalidateArrange = function () {
	                    this._actualWidth = undefined;
	                    this._actualHeight = undefined;
	                    this._actualButtonWidth = undefined;
	                    this._actualButtonHeight = undefined;
	                };
	                Scrollbar.prototype.onHoldBackgroundMouseDown = function (event) {
	                    var _this = this;
	                    var holdDelay = this._timerHandle ?
	                        Scrollbar.ScrollbarBackgroundMousedownHoldDelay :
	                        Scrollbar.ScrollbarBackgroundFirstTimeMousedownHoldDelay;
	                    this._timerHandle = setTimeout(function () {
	                        _this.onBackgroundMouseDown(event);
	                    }, holdDelay);
	                };
	                Scrollbar.prototype.onBackgroundMouseDown = function (event) {
	                    var that = this;
	                    clearTimeout(this._timerHandle);
	                    if (!this._backgroundMouseUpWrapper) {
	                        event.cancelBubble = true;
	                        this._backgroundMouseUpWrapper = function (event) { that.onBackgroundMouseUp(event); };
	                        Scrollbar.addDocumentMouseUpEvent(this._backgroundMouseUpWrapper);
	                    }
	                    this._scrollByPage(event);
	                    this.refresh();
	                    this.onHoldBackgroundMouseDown(event);
	                    if (event.preventDefault)
	                        event.preventDefault(); // prevent dragging
	                };
	                Scrollbar.prototype.onBackgroundMouseUp = function (event) {
	                    clearTimeout(this._timerHandle);
	                    this._timerHandle = undefined;
	                    Scrollbar.removeDocumentMouseUpEvent(this._backgroundMouseUpWrapper);
	                    this._backgroundMouseUpWrapper = undefined;
	                };
	                Scrollbar.prototype.getPinchZoomY = function () {
	                    return document.documentElement.clientHeight / window.innerHeight;
	                };
	                Scrollbar.prototype.onMiddleBarMouseDown = function (event) {
	                    event.cancelBubble = true;
	                    this._screenPrevMousePos = { x: event.screenX, y: event.screenY };
	                    this._screenMinMousePos = this._getScreenMousePos(event) - (this._getScreenContextualLeft(this._middleBar) - this._getScreenContextualRight(this._minButton.element));
	                    this._screenMaxMousePos = this._getScreenMousePos(event) + (this._getScreenContextualLeft(this._maxButton.element) - this._getScreenContextualRight(this._middleBar));
	                    this._screenToOffsetScale = controls.HTMLElementUtils.getAccumulatedScale(this.element) * this.getPinchZoomY();
	                    var that = this;
	                    this._middleBarMouseMoveWrapper = function (e) { that.onMiddleBarMouseMove(e); };
	                    Scrollbar.addDocumentMouseMoveEvent(this._middleBarMouseMoveWrapper);
	                    this._middleBarMouseUpWrapper = function (e) { that.onMiddleBarMouseUp(e); };
	                    Scrollbar.addDocumentMouseUpEvent(this._middleBarMouseUpWrapper);
	                    if (event.preventDefault)
	                        event.preventDefault(); // prevent dragging
	                };
	                Scrollbar.prototype.onMiddleBarMouseMove = function (event) {
	                    if (!this._screenPrevMousePos) {
	                        return;
	                    }
	                    this.scroll(event);
	                    this.refresh();
	                    this._screenPrevMousePos = { x: event.screenX, y: event.screenY };
	                };
	                Scrollbar.prototype.onMiddleBarMouseUp = function (event) {
	                    this._screenPrevMousePos = undefined;
	                    Scrollbar.removeDocumentMouseMoveEvent(this._middleBarMouseMoveWrapper);
	                    this._middleBarMouseMoveWrapper = undefined;
	                    Scrollbar.removeDocumentMouseUpEvent(this._middleBarMouseUpWrapper);
	                    this._middleBarMouseUpWrapper = undefined;
	                    if (event.preventDefault)
	                        event.preventDefault(); // prevent other events
	                };
	                Scrollbar.prototype._getScreenContextualLeft = function (element) {
	                    debug.assertFail("PureVirtualMethod: Scrollbar._getScreenContextualLeft()");
	                    return null;
	                };
	                Scrollbar.prototype._getScreenContextualRight = function (element) {
	                    debug.assertFail("PureVirtualMethod: Scrollbar._getScreenContextualRight()");
	                    return null;
	                };
	                Scrollbar.prototype.onMouseWheel = function (delta) {
	                    if (delta) {
	                        this.mouseWheel(delta);
	                    }
	                };
	                Scrollbar.prototype.mouseWheel = function (delta) {
	                    if (this.visible) {
	                        if (delta < 0) {
	                            delta = Math.min(-Scrollbar.MouseWheelRange, delta);
	                        }
	                        else if (delta > 0) {
	                            delta = Math.max(Scrollbar.MouseWheelRange, delta);
	                        }
	                        this.scrollBy(-delta / Scrollbar.MouseWheelRange * this.smallIncrement);
	                    }
	                };
	                Scrollbar.prototype._getScreenMousePos = function (event) {
	                    debug.assertFail("PureVirtualMethod: Scrollbar._getScreenMousePos()");
	                    return null;
	                };
	                Scrollbar.addDocumentMouseUpEvent = function (func) {
	                    document.addEventListener("mouseup", func);
	                };
	                Scrollbar.removeDocumentMouseUpEvent = function (func) {
	                    document.removeEventListener("mouseup", func);
	                };
	                Scrollbar.addDocumentMouseMoveEvent = function (func) {
	                    document.addEventListener("mousemove", func);
	                };
	                Scrollbar.removeDocumentMouseMoveEvent = function (func) {
	                    document.removeEventListener("mousemove", func);
	                };
	                Scrollbar.DefaultScrollbarWidth = "15px"; // protected
	                Scrollbar.ScrollbarBackgroundFirstTimeMousedownHoldDelay = 500;
	                Scrollbar.ScrollbarBackgroundMousedownHoldDelay = 50;
	                Scrollbar.MouseWheelRange = 120;
	                Scrollbar.className = "scroll-bar-div";
	                Scrollbar.barClassName = "scroll-bar-part-bar";
	                Scrollbar.arrowClassName = "scroll-bar-part-arrow";
	                return Scrollbar;
	            }());
	            controls.Scrollbar = Scrollbar;
	            /** Horizontal Scrollbar */
	            var HorizontalScrollbar = (function (_super) {
	                __extends(HorizontalScrollbar, _super);
	                function HorizontalScrollbar(parentElement, layoutKind) {
	                    _super.call(this, parentElement, layoutKind);
	                    this.height = Scrollbar.DefaultScrollbarWidth;
	                }
	                HorizontalScrollbar.prototype._calculateButtonWidth = function () {
	                    return Math.min(this.actualWidth / 2, Math.max(this.actualHeight, ScrollbarButton.MIN_WIDTH));
	                };
	                HorizontalScrollbar.prototype._calculateButtonHeight = function () {
	                    return this.actualHeight;
	                };
	                HorizontalScrollbar.prototype._getMinButtonAngle = function () {
	                    return -180;
	                };
	                HorizontalScrollbar.prototype._getMaxButtonAngle = function () {
	                    return 0;
	                };
	                HorizontalScrollbar.prototype._setMaxButtonPosition = function () {
	                    controls.HTMLElementUtils.setElementLeft(this.maxButton.element, this.actualWidth - this.actualButtonWidth);
	                };
	                HorizontalScrollbar.prototype.refresh = function () {
	                    this.arrange();
	                    var runningSize = this.actualWidth - this.actualButtonWidth * 2 - 2;
	                    var barSize = this.viewSize / (this.max - this.min) * runningSize;
	                    if (barSize < this.MIN_BAR_SIZE) {
	                        runningSize -= this.MIN_BAR_SIZE - barSize;
	                        barSize = this.MIN_BAR_SIZE;
	                    }
	                    if (runningSize < 0) {
	                        runningSize = 0;
	                        barSize = 0;
	                    }
	                    barSize = Math.min(barSize, runningSize);
	                    var barPos = this.viewMin / (this.max - this.min) * runningSize;
	                    controls.HTMLElementUtils.setElementWidth(this.middleBar, barSize);
	                    controls.HTMLElementUtils.setElementHeight(this.middleBar, this.actualHeight);
	                    controls.HTMLElementUtils.setElementLeft(this.middleBar, this.actualButtonWidth + 1 + barPos);
	                };
	                HorizontalScrollbar.prototype.show = function (visible) {
	                    if (visible === this.visible)
	                        return;
	                    _super.prototype.show.call(this, visible);
	                    if (visible) {
	                        this.element.style.height = this.height;
	                    }
	                    else {
	                        controls.HTMLElementUtils.setElementHeight(this.element, 0);
	                    }
	                };
	                HorizontalScrollbar.prototype._scrollByPage = function (event) {
	                    var left = this.middleBar.offsetLeft;
	                    var right = left + this.middleBar.offsetWidth;
	                    var x = (event.offsetX === undefined) ? event.layerX : event.offsetX;
	                    if (x > right) {
	                        this.scrollPageDown();
	                    }
	                    else if (x < left) {
	                        this.scrollPageUp();
	                    }
	                };
	                HorizontalScrollbar.prototype._getRunningSize = function (net) {
	                    var result = this.actualWidth;
	                    if (net) {
	                        var barMinPos = this.actualButtonWidth + 1;
	                        result -= barMinPos * 2;
	                        var barSize = result * (this.viewSize / (this.max - this.min));
	                        if (barSize < this.MIN_BAR_SIZE)
	                            result -= this.MIN_BAR_SIZE - barSize;
	                    }
	                    return result;
	                };
	                HorizontalScrollbar.prototype._getOffsetDelta = function (event) {
	                    return this._getOffsetXDelta(event);
	                };
	                HorizontalScrollbar.prototype._getOffsetTouchDelta = function (e) {
	                    return this._getOffsetXTouchDelta(e);
	                };
	                HorizontalScrollbar.prototype._getScreenContextualLeft = function (element) {
	                    return element.getBoundingClientRect().left;
	                };
	                HorizontalScrollbar.prototype._getScreenContextualRight = function (element) {
	                    return element.getBoundingClientRect().right;
	                };
	                HorizontalScrollbar.prototype._getScreenMousePos = function (event) {
	                    return event.screenX;
	                };
	                return HorizontalScrollbar;
	            }(Scrollbar));
	            controls.HorizontalScrollbar = HorizontalScrollbar;
	            /** Vertical Scrollbar */
	            var VerticalScrollbar = (function (_super) {
	                __extends(VerticalScrollbar, _super);
	                function VerticalScrollbar(parentElement, layoutKind) {
	                    _super.call(this, parentElement, layoutKind);
	                    this.width = Scrollbar.DefaultScrollbarWidth;
	                }
	                VerticalScrollbar.prototype._calculateButtonWidth = function () {
	                    return this.actualWidth;
	                };
	                VerticalScrollbar.prototype._calculateButtonHeight = function () {
	                    return Math.min(this.actualHeight / 2, Math.max(this.actualWidth, ScrollbarButton.MIN_WIDTH));
	                };
	                VerticalScrollbar.prototype._getMinButtonAngle = function () {
	                    return -90;
	                };
	                VerticalScrollbar.prototype._getMaxButtonAngle = function () {
	                    return 90;
	                };
	                VerticalScrollbar.prototype._setMaxButtonPosition = function () {
	                    controls.HTMLElementUtils.setElementTop(this.maxButton.element, this.actualHeight - this.actualButtonHeight);
	                };
	                VerticalScrollbar.prototype.refresh = function () {
	                    this.arrange();
	                    var runningSize = this.actualHeight - this.actualButtonHeight * 2 - 2;
	                    var barSize = this.viewSize / (this.max - this.min) * runningSize;
	                    if (barSize < this.MIN_BAR_SIZE) {
	                        runningSize -= this.MIN_BAR_SIZE - barSize;
	                        barSize = this.MIN_BAR_SIZE;
	                    }
	                    if (runningSize < 0) {
	                        runningSize = 0;
	                        barSize = 0;
	                    }
	                    var barPos = this.viewMin / (this.max - this.min) * runningSize;
	                    controls.HTMLElementUtils.setElementWidth(this.middleBar, this.actualWidth);
	                    controls.HTMLElementUtils.setElementHeight(this.middleBar, barSize);
	                    controls.HTMLElementUtils.setElementTop(this.middleBar, this.actualButtonHeight + 1 + barPos);
	                };
	                VerticalScrollbar.prototype.show = function (visible) {
	                    if (visible === this.visible)
	                        return;
	                    _super.prototype.show.call(this, visible);
	                    if (visible) {
	                        this.element.style.width = this.width;
	                    }
	                    else {
	                        controls.HTMLElementUtils.setElementWidth(this.element, 0);
	                    }
	                };
	                VerticalScrollbar.prototype._scrollByPage = function (event) {
	                    var top = this.middleBar.offsetTop;
	                    var bottom = top + this.middleBar.offsetHeight;
	                    var y = (event.offsetY === undefined) ? event.layerY : event.offsetY;
	                    if (y > bottom) {
	                        this.scrollPageDown();
	                    }
	                    else if (y < top) {
	                        this.scrollPageUp();
	                    }
	                };
	                VerticalScrollbar.prototype._getRunningSize = function (net) {
	                    var result = this.actualHeight;
	                    if (net) {
	                        var barMinPos = this.actualButtonHeight + 1;
	                        result -= barMinPos * 2;
	                        var barSize = result * (this.viewSize / (this.max - this.min));
	                        if (barSize < this.MIN_BAR_SIZE)
	                            result -= this.MIN_BAR_SIZE - barSize;
	                    }
	                    return result;
	                };
	                VerticalScrollbar.prototype._getOffsetDelta = function (event) {
	                    return this._getOffsetYDelta(event);
	                };
	                VerticalScrollbar.prototype._getOffsetTouchDelta = function (e) {
	                    return this._getOffsetYTouchDelta(e);
	                };
	                VerticalScrollbar.prototype._getScreenContextualLeft = function (element) {
	                    return element.getBoundingClientRect().top;
	                };
	                VerticalScrollbar.prototype._getScreenContextualRight = function (element) {
	                    return element.getBoundingClientRect().bottom;
	                };
	                VerticalScrollbar.prototype._getScreenMousePos = function (event) {
	                    return event.screenY;
	                };
	                return VerticalScrollbar;
	            }(Scrollbar));
	            controls.VerticalScrollbar = VerticalScrollbar;
	        })(controls = visuals.controls || (visuals.controls = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 236 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/// <reference path="../../../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var controls;
	        (function (controls) {
	            var internal;
	            (function (internal) {
	                var UNSELECTABLE_CLASS_NAME = "unselectable";
	                /** This class is responsible for tablix header resizing */
	                var TablixResizer = (function () {
	                    function TablixResizer(element, handler) {
	                        this._element = element;
	                        this._handler = handler;
	                        this._elementMouseDownWrapper = null;
	                        this._elementMouseMoveWrapper = null;
	                        this._elementMouseOutWrapper = null;
	                        this._documentMouseMoveWrapper = null;
	                        this._documentMouseUpWrapper = null;
	                        this._startMousePosition = null;
	                        this._originalCursor = null;
	                    }
	                    TablixResizer.addDocumentMouseUpEvent = function (listener) {
	                        document.addEventListener("mouseup", listener);
	                    };
	                    TablixResizer.removeDocumentMouseUpEvent = function (listener) {
	                        document.removeEventListener("mouseup", listener);
	                    };
	                    TablixResizer.addDocumentMouseMoveEvent = function (listener) {
	                        document.addEventListener("mousemove", listener);
	                    };
	                    TablixResizer.removeDocumentMouseMoveEvent = function (listener) {
	                        document.removeEventListener("mousemove", listener);
	                    };
	                    TablixResizer.getMouseCoordinates = function (event) {
	                        return { x: event.pageX, y: event.pageY };
	                    };
	                    TablixResizer.getMouseCoordinateDelta = function (previous, current) {
	                        return { x: current.x - previous.x, y: current.y - previous.y };
	                    };
	                    TablixResizer.prototype.initialize = function () {
	                        var _this = this;
	                        this._elementMouseDownWrapper = function (e) { return _this.onElementMouseDown(e); };
	                        this._element.addEventListener("mousedown", this._elementMouseDownWrapper);
	                        this._elementMouseMoveWrapper = function (e) { return _this.onElementMouseMove(e); };
	                        this._element.addEventListener("mousemove", this._elementMouseMoveWrapper);
	                        this._elementMouseOutWrapper = function (e) { return _this.onElementMouseOut(e); };
	                        this._element.addEventListener("mouseout", this._elementMouseOutWrapper);
	                        this._elementMouseDoubleClickOutWrapper = function (e) { return _this.onElementMouseDoubleClick(e); };
	                        this._element.addEventListener("dblclick", this._elementMouseDoubleClickOutWrapper);
	                    };
	                    TablixResizer.prototype.uninitialize = function () {
	                        this._element.removeEventListener("mousedown", this._elementMouseDownWrapper);
	                        this._elementMouseDownWrapper = null;
	                        this._element.removeEventListener("mousemove", this._elementMouseMoveWrapper);
	                        this._elementMouseMoveWrapper = null;
	                        this._element.removeEventListener("mouseout", this._elementMouseOutWrapper);
	                        this._elementMouseOutWrapper = null;
	                        this._element.removeEventListener("dblclick", this._elementMouseDoubleClickOutWrapper);
	                        this._elementMouseDoubleClickOutWrapper = null;
	                    };
	                    Object.defineProperty(TablixResizer.prototype, "cell", {
	                        get: function () {
	                            // abstract
	                            debug.assertFail("PureVirtualMethod: TablixResizer.cell");
	                            return null;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(TablixResizer.prototype, "element", {
	                        get: function () {
	                            return this._element;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    // Protected
	                    TablixResizer.prototype._hotSpot = function (position) {
	                        // abstract
	                        debug.assertFail("PureVirtualMethod: TablixResizer._hotSpot");
	                        return false;
	                    };
	                    TablixResizer.prototype.onElementMouseDown = function (event) {
	                        var _this = this;
	                        var position = TablixResizer.getMouseCoordinates(event);
	                        if (!this._hotSpot(position))
	                            return;
	                        if ("setCapture" in this._element) {
	                            this._element.setCapture();
	                        }
	                        event.cancelBubble = true;
	                        this._startMousePosition = position;
	                        this._documentMouseMoveWrapper = function (e) { return _this.onDocumentMouseMove(e); };
	                        TablixResizer.addDocumentMouseMoveEvent(this._documentMouseMoveWrapper);
	                        this._documentMouseUpWrapper = function (e) { return _this.onDocumentMouseUp(e); };
	                        TablixResizer.addDocumentMouseUpEvent(this._documentMouseUpWrapper);
	                        if (document.documentElement) {
	                            this._originalCursor = document.documentElement.style.cursor;
	                            document.documentElement.style.cursor = TablixResizer.resizeCursor;
	                        }
	                        this._handler.onStartResize(this.cell, this._startMousePosition.x, this._startMousePosition.y);
	                    };
	                    TablixResizer.prototype.onElementMouseMove = function (event) {
	                        if (!this._startMousePosition) {
	                            if (this._hotSpot(TablixResizer.getMouseCoordinates(event))) {
	                                if (this._originalCursor === null) {
	                                    this._originalCursor = this._element.style.cursor;
	                                    this._element.style.cursor = TablixResizer.resizeCursor;
	                                }
	                            }
	                            else {
	                                if (this._originalCursor !== null) {
	                                    this._element.style.cursor = this._originalCursor;
	                                    this._originalCursor = null;
	                                }
	                            }
	                        }
	                    };
	                    TablixResizer.prototype.onElementMouseOut = function (event) {
	                        if (!this._startMousePosition) {
	                            if (this._originalCursor !== null) {
	                                this._element.style.cursor = this._originalCursor;
	                                this._originalCursor = null;
	                            }
	                        }
	                    };
	                    TablixResizer.prototype.onElementMouseDoubleClick = function (event) {
	                        if (!this._hotSpot(TablixResizer.getMouseCoordinates(event)))
	                            return;
	                        this._handler.onReset(this.cell);
	                    };
	                    TablixResizer.prototype.onDocumentMouseMove = function (event) {
	                        if (!this._startMousePosition)
	                            return;
	                        var delta = TablixResizer.getMouseCoordinateDelta(this._startMousePosition, TablixResizer.getMouseCoordinates(event));
	                        this._handler.onResize(this.cell, delta.x, delta.y);
	                        // Need to prevent default to prevent mouse move from triggering other effects (VSTS 6720639)
	                        event.preventDefault();
	                    };
	                    TablixResizer.prototype.onDocumentMouseUp = function (event) {
	                        this._startMousePosition = null;
	                        if ("releaseCapture" in this._element) {
	                            this._element.releaseCapture();
	                        }
	                        TablixResizer.removeDocumentMouseMoveEvent(this._documentMouseMoveWrapper);
	                        this._documentMouseMoveWrapper = null;
	                        TablixResizer.removeDocumentMouseUpEvent(this._documentMouseUpWrapper);
	                        this._documentMouseUpWrapper = null;
	                        if (document.documentElement)
	                            document.documentElement.style.cursor = this._originalCursor;
	                        if (event.preventDefault)
	                            event.preventDefault(); // prevent other events
	                        this._handler.onEndResize(this.cell);
	                    };
	                    TablixResizer.resizeHandleSize = 4;
	                    TablixResizer.resizeCursor = "e-resize";
	                    return TablixResizer;
	                }());
	                internal.TablixResizer = TablixResizer;
	                var TablixDomResizer = (function (_super) {
	                    __extends(TablixDomResizer, _super);
	                    function TablixDomResizer(cell, element, handler) {
	                        _super.call(this, element, handler);
	                        this._cell = cell;
	                    }
	                    Object.defineProperty(TablixDomResizer.prototype, "cell", {
	                        get: function () {
	                            return this._cell;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    // Protected
	                    TablixDomResizer.prototype._hotSpot = function (position) {
	                        return position.x >= this.element.getBoundingClientRect().right - TablixResizer.resizeHandleSize;
	                    };
	                    return TablixDomResizer;
	                }(TablixResizer));
	                internal.TablixDomResizer = TablixDomResizer;
	                var TablixCellPresenter = (function () {
	                    function TablixCellPresenter(fitProportionally, layoutKind) {
	                        // Table cell will be created once needed
	                        this._tableCell = null;
	                        // Content element
	                        this._contentElement = internal.TablixUtils.createDiv();
	                        // Content Host
	                        this._contentHost = internal.TablixUtils.createDiv();
	                        this.layoutKind = layoutKind;
	                        this._contentElement.appendChild(this._contentHost);
	                        this._resizer = null;
	                    }
	                    TablixCellPresenter.prototype.initialize = function (owner) {
	                        this._owner = owner;
	                    };
	                    Object.defineProperty(TablixCellPresenter.prototype, "owner", {
	                        get: function () {
	                            return this._owner;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    TablixCellPresenter.prototype.registerTableCell = function (tableCell) {
	                        this._tableCell = tableCell;
	                        tableCell.appendChild(this._contentElement);
	                    };
	                    Object.defineProperty(TablixCellPresenter.prototype, "tableCell", {
	                        get: function () {
	                            return this._tableCell;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(TablixCellPresenter.prototype, "contentElement", {
	                        /**
	                         * Outer DIV
	                         */
	                        get: function () {
	                            return this._contentElement;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(TablixCellPresenter.prototype, "contentHost", {
	                        /**
	                        * Inner DIV
	                        */
	                        get: function () {
	                            return this._contentHost;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    TablixCellPresenter.prototype.registerClickHandler = function (handler) {
	                        this._contentElement.onclick = handler;
	                    };
	                    TablixCellPresenter.prototype.unregisterClickHandler = function () {
	                        this._contentElement.onclick = null;
	                    };
	                    TablixCellPresenter.prototype.onContainerWidthChanged = function (value) {
	                        controls.HTMLElementUtils.setElementWidth(this._contentElement, value);
	                    };
	                    TablixCellPresenter.prototype.onContinerHeightChanged = function (height) {
	                        controls.HTMLElementUtils.setElementHeight(this._contentElement, height);
	                    };
	                    TablixCellPresenter.prototype.onColumnSpanChanged = function (value) {
	                        this._tableCell.colSpan = value;
	                    };
	                    TablixCellPresenter.prototype.onRowSpanChanged = function (value) {
	                        this._tableCell.rowSpan = value;
	                    };
	                    TablixCellPresenter.prototype.onTextAlignChanged = function (value) {
	                        this._tableCell.style.textAlign = value;
	                    };
	                    TablixCellPresenter.prototype.onClear = function () {
	                        this._contentHost.className = "";
	                        this._tableCell.className = "";
	                    };
	                    TablixCellPresenter.prototype.onHorizontalScroll = function (width, offset) {
	                        controls.HTMLElementUtils.setElementLeft(this._contentHost, offset);
	                        controls.HTMLElementUtils.setElementWidth(this._contentHost, width);
	                    };
	                    TablixCellPresenter.prototype.onVerticalScroll = function (height, offset) {
	                        controls.HTMLElementUtils.setElementTop(this._contentHost, offset);
	                        controls.HTMLElementUtils.setElementHeight(this._contentHost, height);
	                    };
	                    TablixCellPresenter.prototype.onInitializeScrolling = function () {
	                        controls.HTMLElementUtils.setElementLeft(this._contentHost, 0);
	                        controls.HTMLElementUtils.setElementTop(this._contentHost, 0);
	                        controls.HTMLElementUtils.setElementWidth(this._contentHost, -1);
	                        controls.HTMLElementUtils.setElementHeight(this._contentHost, -1);
	                    };
	                    TablixCellPresenter.prototype.enableHorizontalResize = function (enable, handler) {
	                        if (enable === (this._resizer !== null))
	                            return;
	                        if (enable) {
	                            this._resizer = new TablixDomResizer(this._owner, this._tableCell, handler);
	                            this._resizer.initialize();
	                        }
	                        else {
	                            this._resizer.uninitialize();
	                            this._resizer = null;
	                        }
	                    };
	                    /**
	                     * In order to allow dragging of the tableCell we need to
	                     * disable dragging of the container of the cell in IE.
	                     */
	                    TablixCellPresenter.prototype.disableDragResize = function () {
	                        this._tableCell.setAttribute(TablixCellPresenter._dragResizeDisabledAttributeName, "true");
	                    };
	                    // Attribute used to disable dragging in order to have cell resizing work.
	                    TablixCellPresenter._dragResizeDisabledAttributeName = "drag-resize-disabled";
	                    return TablixCellPresenter;
	                }());
	                internal.TablixCellPresenter = TablixCellPresenter;
	                var TablixRowPresenter = (function () {
	                    function TablixRowPresenter(fitProportionally) {
	                        // Table row will be created once needed
	                        this._tableRow = null;
	                        this._fitProportionally = fitProportionally;
	                    }
	                    TablixRowPresenter.prototype.initialize = function (row) {
	                        this._row = row;
	                    };
	                    TablixRowPresenter.prototype.createCellPresenter = function (layoutKind) {
	                        return new TablixCellPresenter(this._fitProportionally, layoutKind);
	                    };
	                    TablixRowPresenter.prototype.registerRow = function (tableRow) {
	                        this._tableRow = tableRow;
	                    };
	                    TablixRowPresenter.prototype.onAppendCell = function (cell) {
	                        var presenter = cell._presenter;
	                        if (presenter.tableCell === null) {
	                            // For performance reason we use InsertCell() to create new table cells instead of AppendChild()
	                            // We use -1 to insert at the end (that's the cross-browser way of doing it)
	                            var tableCell = this._tableRow.insertCell(-1);
	                            presenter.registerTableCell(tableCell);
	                        }
	                        else {
	                            this._tableRow.appendChild(presenter.tableCell);
	                        }
	                    };
	                    TablixRowPresenter.prototype.onInsertCellBefore = function (cell, refCell) {
	                        debug.assertValue(refCell._presenter.tableCell, 'refTableCell');
	                        var presenter = cell._presenter;
	                        if (presenter.tableCell === null) {
	                            // For performance reasons we use InsertCell() to create new table cells instead of AppendChild()
	                            var tableCell = this._tableRow.insertCell(Math.max(0, refCell._presenter.tableCell.cellIndex - 1));
	                            presenter.registerTableCell(tableCell);
	                        }
	                        else {
	                            this._tableRow.insertBefore(cell._presenter.tableCell, refCell._presenter.tableCell);
	                        }
	                    };
	                    TablixRowPresenter.prototype.onRemoveCell = function (cell) {
	                        this._tableRow.removeChild(cell._presenter.tableCell);
	                    };
	                    TablixRowPresenter.prototype.getHeight = function () {
	                        return this.getCellHeight(this._row.getTablixCell());
	                    };
	                    TablixRowPresenter.prototype.getCellHeight = function (cell) {
	                        debug.assertFail("PureVirtualMethod: TablixRowPresenter.getCellHeight");
	                        return -1;
	                    };
	                    TablixRowPresenter.prototype.getCellContentHeight = function (cell) {
	                        debug.assertFail("PureVirtualMethod: TablixRowPresenter.getCellHeight");
	                        return -1;
	                    };
	                    Object.defineProperty(TablixRowPresenter.prototype, "tableRow", {
	                        get: function () {
	                            return this._tableRow;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    return TablixRowPresenter;
	                }());
	                internal.TablixRowPresenter = TablixRowPresenter;
	                var DashboardRowPresenter = (function (_super) {
	                    __extends(DashboardRowPresenter, _super);
	                    function DashboardRowPresenter(gridPresenter, fitProportionally) {
	                        _super.call(this, fitProportionally);
	                        this._gridPresenter = gridPresenter;
	                    }
	                    DashboardRowPresenter.prototype.getCellHeight = function (cell) {
	                        return cell.containerHeight;
	                    };
	                    DashboardRowPresenter.prototype.getCellContentHeight = function (cell) {
	                        return cell.contentHeight;
	                    };
	                    return DashboardRowPresenter;
	                }(TablixRowPresenter));
	                internal.DashboardRowPresenter = DashboardRowPresenter;
	                var CanvasRowPresenter = (function (_super) {
	                    __extends(CanvasRowPresenter, _super);
	                    function CanvasRowPresenter() {
	                        _super.apply(this, arguments);
	                    }
	                    CanvasRowPresenter.prototype.getCellHeight = function (cell) {
	                        return cell.containerHeight;
	                    };
	                    CanvasRowPresenter.prototype.getCellContentHeight = function (cell) {
	                        return cell.contentHeight;
	                    };
	                    return CanvasRowPresenter;
	                }(TablixRowPresenter));
	                internal.CanvasRowPresenter = CanvasRowPresenter;
	                var TablixColumnPresenter = (function () {
	                    function TablixColumnPresenter() {
	                    }
	                    TablixColumnPresenter.prototype.initialize = function (column) {
	                        this._column = column;
	                    };
	                    TablixColumnPresenter.prototype.getWidth = function () {
	                        var width = this.getPersistedWidth();
	                        if (width == null)
	                            width = this.getCellWidth(this._column.getTablixCell());
	                        return width;
	                    };
	                    TablixColumnPresenter.prototype.getPersistedWidth = function () {
	                        debug.assertFail("PureVirtualMethod: TablixColumnPresenter.getPersistedWidth");
	                        return -1;
	                    };
	                    TablixColumnPresenter.prototype.getCellWidth = function (cell) {
	                        debug.assertFail("PureVirtualMethod: TablixColumnPresenter.getCellWidth");
	                        return -1;
	                    };
	                    return TablixColumnPresenter;
	                }());
	                internal.TablixColumnPresenter = TablixColumnPresenter;
	                var DashboardColumnPresenter = (function (_super) {
	                    __extends(DashboardColumnPresenter, _super);
	                    function DashboardColumnPresenter(gridPresenter) {
	                        _super.call(this);
	                        this._gridPresenter = gridPresenter;
	                    }
	                    DashboardColumnPresenter.prototype.getPersistedWidth = function () {
	                        return this._gridPresenter.sizeComputationManager.cellWidth;
	                    };
	                    DashboardColumnPresenter.prototype.getCellWidth = function (cell) {
	                        return this._gridPresenter.sizeComputationManager.cellWidth;
	                    };
	                    return DashboardColumnPresenter;
	                }(TablixColumnPresenter));
	                internal.DashboardColumnPresenter = DashboardColumnPresenter;
	                var CanvasColumnPresenter = (function (_super) {
	                    __extends(CanvasColumnPresenter, _super);
	                    function CanvasColumnPresenter(gridPresenter, index) {
	                        _super.call(this);
	                        this._gridPresenter = gridPresenter;
	                        this._columnIndex = index;
	                    }
	                    CanvasColumnPresenter.prototype.getPersistedWidth = function () {
	                        return this._gridPresenter.getPersistedColumnWidth(this._column);
	                    };
	                    CanvasColumnPresenter.prototype.getCellWidth = function (cell) {
	                        var tablixCell = cell;
	                        if (!tablixCell._presenter)
	                            return 0;
	                        return cell.contentWidth;
	                    };
	                    return CanvasColumnPresenter;
	                }(TablixColumnPresenter));
	                internal.CanvasColumnPresenter = CanvasColumnPresenter;
	                var TablixGridPresenter = (function () {
	                    function TablixGridPresenter(columnWidthManager) {
	                        // Main Table
	                        this._table = internal.TablixUtils.createTable();
	                        this._table.className = UNSELECTABLE_CLASS_NAME;
	                        // Footer Table
	                        this._footerTable = internal.TablixUtils.createTable();
	                        this._footerTable.className = UNSELECTABLE_CLASS_NAME;
	                        // ColumnWidthManager
	                        this._columnWidthManager = columnWidthManager;
	                    }
	                    TablixGridPresenter.prototype.initialize = function (owner, gridHost, footerHost, control) {
	                        this._owner = owner;
	                        gridHost.appendChild(this._table);
	                        footerHost.appendChild(this._footerTable);
	                    };
	                    TablixGridPresenter.prototype.getWidth = function () {
	                        debug.assertFail("PureVirtualMethod: TablixGridPresenter.getWidth");
	                        return -1;
	                    };
	                    TablixGridPresenter.prototype.getHeight = function () {
	                        debug.assertFail("PureVirtualMethod: TablixGridPresenter.getHeight");
	                        return -1;
	                    };
	                    TablixGridPresenter.prototype.getScreenToCssRatioX = function () {
	                        return 1;
	                    };
	                    TablixGridPresenter.prototype.getScreenToCssRatioY = function () {
	                        return 1;
	                    };
	                    TablixGridPresenter.prototype.createRowPresenter = function () {
	                        debug.assertFail("PureVirtualMethod: TablixGridPresenter.createRowPresenter");
	                        return null;
	                    };
	                    TablixGridPresenter.prototype.createColumnPresenter = function (index) {
	                        debug.assertFail("PureVirtualMethod: TablixGridPresenter.createColumnPresenter");
	                        return null;
	                    };
	                    TablixGridPresenter.prototype.onAppendRow = function (row) {
	                        var presenter = row.presenter;
	                        if (presenter.tableRow === null) {
	                            // For performance reason we use InsertRow() to create new table cells instead of AppendChild()
	                            // We use -1 to insert at the end (that's the cross-browser way of doing it)
	                            var tableRow = this._table.insertRow(-1);
	                            presenter.registerRow(tableRow);
	                        }
	                        else {
	                            this._table.tBodies[0].appendChild(row.presenter.tableRow);
	                        }
	                    };
	                    TablixGridPresenter.prototype.onInsertRowBefore = function (row, refRow) {
	                        debug.assertValue(refRow.presenter.tableRow, 'refTableRow');
	                        var presenter = row.presenter;
	                        if (presenter.tableRow === null) {
	                            // For performance reason we use InsertRow() to create new table cells instead of AppendChild()
	                            var tableRow = this._table.insertRow(Math.max(0, refRow.presenter.tableRow.rowIndex - 1));
	                            presenter.registerRow(tableRow);
	                        }
	                        else {
	                            this._table.tBodies[0].insertBefore(row.presenter.tableRow, refRow.presenter.tableRow);
	                        }
	                    };
	                    TablixGridPresenter.prototype.onRemoveRow = function (row) {
	                        this._table.tBodies[0].removeChild(row.presenter.tableRow);
	                    };
	                    TablixGridPresenter.prototype.onAddFooterRow = function (row) {
	                        var presenter = row.presenter;
	                        if (presenter.tableRow === null) {
	                            // For performance reason we use InsertRow() to create new table cells instead of AppendChild()
	                            // We use -1 to insert at the end (that's the cross-browser way of doing it)
	                            var tableRow = this._footerTable.insertRow(-1);
	                            presenter.registerRow(tableRow);
	                        }
	                        else {
	                            this._footerTable.tBodies[0].appendChild(row.presenter.tableRow);
	                        }
	                    };
	                    TablixGridPresenter.prototype.onClear = function () {
	                        controls.HTMLElementUtils.clearChildren(this._table);
	                        controls.HTMLElementUtils.clearChildren(this._footerTable);
	                    };
	                    TablixGridPresenter.prototype.onFillColumnsProportionallyChanged = function (value) {
	                        if (value) {
	                            this._table.style.width = "100%";
	                            this._footerTable.style.width = "100%";
	                        }
	                        else {
	                            this._table.style.width = "auto";
	                            this._footerTable.style.width = "auto";
	                        }
	                    };
	                    TablixGridPresenter.prototype.invokeColumnResizeEndCallback = function (column, width) {
	                        if (this._columnWidthManager)
	                            this._columnWidthManager.onColumnWidthChanged(controls.TablixColumnWidthManager.getColumnQueryName(column), width);
	                    };
	                    TablixGridPresenter.prototype.getPersistedColumnWidth = function (column) {
	                        if (this._columnWidthManager) {
	                            return this._columnWidthManager.getPersistedColumnWidth(controls.TablixColumnWidthManager.getColumnQueryName(column));
	                        }
	                    };
	                    return TablixGridPresenter;
	                }());
	                internal.TablixGridPresenter = TablixGridPresenter;
	                var DashboardTablixGridPresenter = (function (_super) {
	                    __extends(DashboardTablixGridPresenter, _super);
	                    function DashboardTablixGridPresenter(sizeComputationManager) {
	                        _super.call(this);
	                        this._sizeComputationManager = sizeComputationManager;
	                    }
	                    DashboardTablixGridPresenter.prototype.createRowPresenter = function () {
	                        return new DashboardRowPresenter(this, this._owner.fillColumnsProportionally);
	                    };
	                    DashboardTablixGridPresenter.prototype.createColumnPresenter = function (index) {
	                        return new DashboardColumnPresenter(this);
	                    };
	                    Object.defineProperty(DashboardTablixGridPresenter.prototype, "sizeComputationManager", {
	                        get: function () {
	                            return this._sizeComputationManager;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    DashboardTablixGridPresenter.prototype.getWidth = function () {
	                        return this._sizeComputationManager.gridWidth;
	                    };
	                    DashboardTablixGridPresenter.prototype.getHeight = function () {
	                        return this._sizeComputationManager.gridHeight;
	                    };
	                    return DashboardTablixGridPresenter;
	                }(TablixGridPresenter));
	                internal.DashboardTablixGridPresenter = DashboardTablixGridPresenter;
	                var CanvasTablixGridPresenter = (function (_super) {
	                    __extends(CanvasTablixGridPresenter, _super);
	                    function CanvasTablixGridPresenter(columnWidthManager) {
	                        _super.call(this, columnWidthManager);
	                    }
	                    CanvasTablixGridPresenter.prototype.createRowPresenter = function () {
	                        return new CanvasRowPresenter(this._owner.fillColumnsProportionally);
	                    };
	                    CanvasTablixGridPresenter.prototype.createColumnPresenter = function (index) {
	                        return new CanvasColumnPresenter(this, index);
	                    };
	                    CanvasTablixGridPresenter.prototype.getWidth = function () {
	                        return controls.HTMLElementUtils.getElementWidth(this._table);
	                    };
	                    CanvasTablixGridPresenter.prototype.getHeight = function () {
	                        return controls.HTMLElementUtils.getElementHeight(this._table);
	                    };
	                    return CanvasTablixGridPresenter;
	                }(TablixGridPresenter));
	                internal.CanvasTablixGridPresenter = CanvasTablixGridPresenter;
	            })(internal = controls.internal || (controls.internal = {}));
	        })(controls = visuals.controls || (visuals.controls = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 237 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/// <reference path="../../../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var controls;
	        (function (controls) {
	            var internal;
	            (function (internal) {
	                /**
	                 * Base class for Tablix realization manager.
	                 */
	                var TablixDimensionRealizationManager = (function () {
	                    function TablixDimensionRealizationManager(binder) {
	                        this._binder = binder;
	                        this._adjustmentFactor = 1;
	                    }
	                    TablixDimensionRealizationManager.prototype._getOwner = function () {
	                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager.getOwner");
	                        return null;
	                    };
	                    Object.defineProperty(TablixDimensionRealizationManager.prototype, "binder", {
	                        get: function () {
	                            return this._binder;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(TablixDimensionRealizationManager.prototype, "adjustmentFactor", {
	                        get: function () {
	                            return this._adjustmentFactor;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(TablixDimensionRealizationManager.prototype, "itemsToRealizeCount", {
	                        get: function () {
	                            return this._itemsToRealizeCount;
	                        },
	                        set: function (count) {
	                            this._itemsToRealizeCount = count;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(TablixDimensionRealizationManager.prototype, "itemsEstimatedContextualWidth", {
	                        get: function () {
	                            return this._itemsEstimatedContextualWidth;
	                        },
	                        set: function (contextualWidth) {
	                            this._itemsEstimatedContextualWidth = contextualWidth;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    TablixDimensionRealizationManager.prototype.onStartRenderingIteration = function () {
	                        var owner = this._getOwner();
	                        if (owner.measureEnabled && !owner.done) {
	                            this._getEstimatedItemsToRealizeCount();
	                        }
	                        this._realizedLeavesCount = 0;
	                    };
	                    TablixDimensionRealizationManager.prototype.onEndRenderingIteration = function (gridContextualWidth, filled) {
	                        if (!filled && !this._getOwner().allItemsRealized)
	                            this._adjustmentFactor *= this._getSizeAdjustment(gridContextualWidth);
	                    };
	                    TablixDimensionRealizationManager.prototype.onEndRenderingSession = function () {
	                        this._adjustmentFactor = 1;
	                    };
	                    TablixDimensionRealizationManager.prototype.onCornerCellRealized = function (item, cell) {
	                    };
	                    TablixDimensionRealizationManager.prototype.onHeaderRealized = function (item, cell, leaf) {
	                        if (leaf) {
	                            this._realizedLeavesCount++;
	                        }
	                    };
	                    Object.defineProperty(TablixDimensionRealizationManager.prototype, "needsToRealize", {
	                        get: function () {
	                            return this._realizedLeavesCount < this._itemsToRealizeCount;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    TablixDimensionRealizationManager.prototype._getEstimatedItemsToRealizeCount = function () {
	                        debug.assertFail("PureVirtualMethod: TablixDimensionRealizationManager._calculateItemsToRealize");
	                    };
	                    TablixDimensionRealizationManager.prototype._getSizeAdjustment = function (gridContextualWidth) {
	                        debug.assertFail("PureVirtualMethod: TablixDimensionRealizationManager._getSizeAdjustment");
	                        return 1;
	                    };
	                    return TablixDimensionRealizationManager;
	                }());
	                internal.TablixDimensionRealizationManager = TablixDimensionRealizationManager;
	                /**
	                 * DOM implementation for Row Tablix realization manager.
	                 */
	                var RowRealizationManager = (function (_super) {
	                    __extends(RowRealizationManager, _super);
	                    function RowRealizationManager() {
	                        _super.apply(this, arguments);
	                    }
	                    Object.defineProperty(RowRealizationManager.prototype, "owner", {
	                        set: function (owner) {
	                            this._owner = owner;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    RowRealizationManager.prototype._getOwner = function () {
	                        return this._owner;
	                    };
	                    RowRealizationManager.prototype._getEstimatedItemsToRealizeCount = function () {
	                        this.estimateRowsToRealizeCount();
	                    };
	                    RowRealizationManager.prototype.estimateRowsToRealizeCount = function () {
	                        debug.assertValue(this._owner, '_owner');
	                        if (!this._owner.dimension.model) {
	                            this.itemsToRealizeCount = 0;
	                            return;
	                        }
	                        if (this._owner.alignToEnd)
	                            this.itemsToRealizeCount = this._owner.dimension.getItemsCount() - this._owner.dimension.getIntegerScrollOffset() + 1;
	                        else
	                            this.itemsToRealizeCount = Math.ceil((this._owner.contextualWidthToFill / (this._owner.owner.getEstimatedRowHeight() * this.adjustmentFactor)) + this._owner.dimension.getFractionScrollOffset()) - this._owner.otherLayoutManager.dimension.getDepth() + 1;
	                    };
	                    RowRealizationManager.prototype.getEstimatedRowHierarchyWidth = function () {
	                        if (!this._owner.dimension.model || this._owner.dimension.getItemsCount() === 0)
	                            return 0;
	                        var levels = new RowWidths();
	                        this.updateRowHiearchyEstimatedWidth(this._owner.dimension.model, this._owner.dimension._hierarchyNavigator.getIndex(this._owner.dimension.getFirstVisibleItem(0)), levels);
	                        var levelsArray = levels.items;
	                        var levelCount = levelsArray.length;
	                        var width = 0;
	                        for (var i = 0; i < levelCount; i++) {
	                            var level = levelsArray[i];
	                            if (level.maxNonLeafWidth !== 0)
	                                width += level.maxNonLeafWidth;
	                            else
	                                width += level.maxLeafWidth;
	                        }
	                        return width;
	                    };
	                    RowRealizationManager.prototype.updateRowHiearchyEstimatedWidth = function (items, firstVisibleIndex, levels) {
	                        if (firstVisibleIndex < 0)
	                            return;
	                        var hierarchyNavigator = this._owner.owner.owner.hierarchyNavigator;
	                        var binder = this.binder;
	                        var length = hierarchyNavigator.getCount(items);
	                        for (var i = firstVisibleIndex; i < length; i++) {
	                            if (levels.leafCount === this.itemsToRealizeCount)
	                                return;
	                            var item = hierarchyNavigator.getAt(items, i);
	                            var label = binder.getHeaderLabel(item);
	                            var itemWidth = this._owner.getEstimatedHeaderWidth(label, firstVisibleIndex);
	                            var isLeaf = hierarchyNavigator.isLeaf(item);
	                            var l = hierarchyNavigator.getLevel(item);
	                            var level = levels.items[l];
	                            if (!level) {
	                                level = new RowWidth();
	                                levels.items[l] = level;
	                            }
	                            if (isLeaf) {
	                                level.maxLeafWidth = Math.max(level.maxLeafWidth, itemWidth);
	                                levels.leafCount = levels.leafCount + 1;
	                            }
	                            else {
	                                level.maxNonLeafWidth = Math.max(level.maxNonLeafWidth, itemWidth);
	                                this.updateRowHiearchyEstimatedWidth(hierarchyNavigator.getChildren(item), this._owner.dimension.getFirstVisibleChildIndex(item), levels);
	                            }
	                        }
	                    };
	                    RowRealizationManager.prototype._getSizeAdjustment = function (gridContextualWidth) {
	                        return gridContextualWidth / ((this._owner.getRealizedItemsCount() - this._owner.dimension.getFractionScrollOffset()) * this._owner.owner.getEstimatedRowHeight());
	                    };
	                    return RowRealizationManager;
	                }(TablixDimensionRealizationManager));
	                internal.RowRealizationManager = RowRealizationManager;
	                /**
	                 * DOM implementation for Column Tablix realization manager.
	                 */
	                var ColumnRealizationManager = (function (_super) {
	                    __extends(ColumnRealizationManager, _super);
	                    function ColumnRealizationManager() {
	                        _super.apply(this, arguments);
	                    }
	                    Object.defineProperty(ColumnRealizationManager.prototype, "owner", {
	                        set: function (owner) {
	                            this._owner = owner;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    ColumnRealizationManager.prototype._getOwner = function () {
	                        return this._owner;
	                    };
	                    ColumnRealizationManager.prototype._getEstimatedItemsToRealizeCount = function () {
	                        this.estimateColumnsToRealizeCount(this.getEstimatedRowHierarchyWidth());
	                    };
	                    Object.defineProperty(ColumnRealizationManager.prototype, "rowRealizationManager", {
	                        get: function () {
	                            return this._owner.otherLayoutManager.realizationManager;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    ColumnRealizationManager.prototype.getEstimatedRowHierarchyWidth = function () {
	                        if (this._owner.otherLayoutManager.done)
	                            return this._owner.getOtherHierarchyContextualHeight();
	                        return this.rowRealizationManager.getEstimatedRowHierarchyWidth() * this.adjustmentFactor;
	                    };
	                    ColumnRealizationManager.prototype.estimateColumnsToRealizeCount = function (rowHierarchyWidth) {
	                        var widthToFill = this._owner.contextualWidthToFill - rowHierarchyWidth;
	                        if (!this._owner.dimension.model || powerbi.Double.lessOrEqualWithPrecision(widthToFill, 0, internal.DimensionLayoutManager._pixelPrecision)) {
	                            this.itemsToRealizeCount = 0;
	                            return;
	                        }
	                        var binder = this.binder;
	                        var hierarchyNavigator = this._owner.owner.owner.hierarchyNavigator;
	                        var startColumnIndex = this._owner.dimension.getIntegerScrollOffset();
	                        var endColumnIndex = this._owner.dimension.getItemsCount();
	                        var columnCount = endColumnIndex - startColumnIndex;
	                        var startRowIndex = this._owner.otherLayoutManager.dimension.getIntegerScrollOffset();
	                        var endRowIndex = this._owner.otherLayoutManager.dimension.getItemsCount();
	                        this.itemsEstimatedContextualWidth = 0;
	                        if (this._owner.alignToEnd) {
	                            this.itemsToRealizeCount = columnCount;
	                            return;
	                        }
	                        for (var i = startColumnIndex; i < endColumnIndex; i++) {
	                            if (powerbi.Double.greaterOrEqualWithPrecision(this.itemsEstimatedContextualWidth, widthToFill, internal.DimensionLayoutManager._pixelPrecision)) {
	                                this.itemsToRealizeCount = i - startColumnIndex;
	                                return;
	                            }
	                            var maxWidth = 0;
	                            var visibleSizeRatio = void 0;
	                            if (i === startColumnIndex) {
	                                visibleSizeRatio = this._owner.getVisibleSizeRatio();
	                            }
	                            else {
	                                visibleSizeRatio = 1;
	                            }
	                            var columnMember = hierarchyNavigator.getLeafAt(this._owner.dimension.model, i);
	                            var label = binder.getHeaderLabel(columnMember);
	                            maxWidth = Math.max(maxWidth, this._owner.getEstimatedHeaderWidth(label, i));
	                            for (var j = startRowIndex; j < endRowIndex; j++) {
	                                var intersection = hierarchyNavigator.getIntersection(hierarchyNavigator.getLeafAt(this._owner.otherLayoutManager.dimension.model, j), columnMember);
	                                label = binder.getCellContent(intersection);
	                                maxWidth = Math.max(maxWidth, this._owner.getEstimatedBodyCellWidth(label));
	                            }
	                            this.itemsEstimatedContextualWidth += maxWidth * visibleSizeRatio * this.adjustmentFactor;
	                        }
	                        this.itemsToRealizeCount = columnCount;
	                    };
	                    ColumnRealizationManager.prototype._getSizeAdjustment = function (gridContextualWidth) {
	                        return gridContextualWidth / (this.getEstimatedRowHierarchyWidth() + this.itemsEstimatedContextualWidth);
	                    };
	                    return ColumnRealizationManager;
	                }(TablixDimensionRealizationManager));
	                internal.ColumnRealizationManager = ColumnRealizationManager;
	                var RowWidths = (function () {
	                    function RowWidths() {
	                        this.items = [];
	                        this.leafCount = 0;
	                    }
	                    return RowWidths;
	                }());
	                internal.RowWidths = RowWidths;
	                var RowWidth = (function () {
	                    function RowWidth() {
	                        this.maxLeafWidth = 0;
	                        this.maxNonLeafWidth = 0;
	                    }
	                    return RowWidth;
	                }());
	                internal.RowWidth = RowWidth;
	            })(internal = controls.internal || (controls.internal = {}));
	        })(controls = visuals.controls || (visuals.controls = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 238 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../../../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var controls;
	        (function (controls) {
	            var internal;
	            (function (internal) {
	                var TablixCell = (function () {
	                    function TablixCell(presenter, extension, row) {
	                        this._scrollable = false;
	                        this._presenter = presenter;
	                        this.extension = extension;
	                        this._presenter.initialize(this);
	                        this._row = row;
	                        this.item = null;
	                        this.type = null;
	                        this._horizontalOffset = 0;
	                        this._verticalOffset = 0;
	                        this._colSpan = 1;
	                        this._rowSpan = 1;
	                        this._containerWidth = -1;
	                        this._containerHeight = -1;
	                        this.contentHeight = this.contentWidth = 0;
	                        this.position = new internal.TablixUtils.CellPosition();
	                    }
	                    TablixCell.prototype.unfixRowHeight = function () {
	                        this._row.unfixSize();
	                    };
	                    Object.defineProperty(TablixCell.prototype, "colSpan", {
	                        get: function () {
	                            return this._colSpan;
	                        },
	                        set: function (value) {
	                            if (this._colSpan !== value) {
	                                this._presenter.onColumnSpanChanged(value);
	                                this._colSpan = value;
	                                this._presenter.onContainerWidthChanged(-1);
	                            }
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(TablixCell.prototype, "rowSpan", {
	                        get: function () {
	                            return this._rowSpan;
	                        },
	                        set: function (value) {
	                            if (this._rowSpan !== value) {
	                                this._presenter.onRowSpanChanged(value);
	                                this._rowSpan = value;
	                                this._row.unfixSize();
	                            }
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    TablixCell.prototype.getCellSpanningHeight = function () {
	                        return this._row.getCellSpanningHeight(this);
	                    };
	                    Object.defineProperty(TablixCell.prototype, "textAlign", {
	                        get: function () {
	                            return this._textAlign;
	                        },
	                        set: function (value) {
	                            if (value !== this._textAlign) {
	                                this._presenter.onTextAlignChanged(value);
	                                this._textAlign = value;
	                            }
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(TablixCell.prototype, "horizontalOffset", {
	                        get: function () {
	                            return this._horizontalOffset;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(TablixCell.prototype, "verticalOffset", {
	                        get: function () {
	                            return this._verticalOffset;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    TablixCell.prototype.isScrollable = function () {
	                        return this._scrollable;
	                    };
	                    TablixCell.prototype.clear = function () {
	                        if (this.isScrollable()) {
	                            this.initializeScrolling();
	                        }
	                        this._presenter.onClear();
	                        this.setContainerWidth(-1);
	                        this.setContainerHeight(-1);
	                        this.contentHeight = this.contentWidth = 0;
	                    };
	                    TablixCell.prototype.initializeScrolling = function () {
	                        this._presenter.onInitializeScrolling();
	                        this._horizontalOffset = 0;
	                        this._verticalOffset = 0;
	                        if (this.colSpan === 1)
	                            this.setContainerWidth(-1);
	                        if (this.rowSpan === 1)
	                            this.setContainerHeight(-1);
	                    };
	                    TablixCell.prototype.prepare = function (scrollable) {
	                        if (this.isScrollable())
	                            this.initializeScrolling();
	                        this._scrollable = scrollable;
	                    };
	                    TablixCell.prototype.scrollVertically = function (height, offset) {
	                        // Ceiling the offset because setting a fraction Width on the TD will ceil it
	                        // We need to let the TD and the OuterDiv to align in order for Borders to touch
	                        var offsetInPixels = Math.ceil(-height * offset);
	                        this._verticalOffset = offsetInPixels;
	                        if (this.isScrollable()) {
	                            this._presenter.onVerticalScroll(height, offsetInPixels);
	                            this.setContainerHeight(height + offsetInPixels);
	                        }
	                        else {
	                            this.setContainerHeight(this._row.getCellSpanningHeight(this) + offsetInPixels);
	                        }
	                    };
	                    TablixCell.prototype.scrollHorizontally = function (width, offset) {
	                        if (!this.isScrollable()) {
	                            return;
	                        }
	                        this._presenter.onHorizontalScroll(width, offset);
	                        this.setContainerWidth(width + offset);
	                    };
	                    TablixCell.prototype.setContainerWidth = function (value) {
	                        if (value === this._containerWidth)
	                            return;
	                        this._containerWidth = value;
	                        this._presenter.onContainerWidthChanged(value);
	                    };
	                    Object.defineProperty(TablixCell.prototype, "containerWidth", {
	                        get: function () {
	                            return this._containerWidth;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    TablixCell.prototype.setContainerHeight = function (value) {
	                        if (value < 0)
	                            value = -1;
	                        if (value === this._containerHeight)
	                            return;
	                        this._containerHeight = value;
	                        this._presenter.onContinerHeightChanged(value);
	                    };
	                    Object.defineProperty(TablixCell.prototype, "containerHeight", {
	                        get: function () {
	                            return this._containerHeight;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    TablixCell.prototype.applyStyle = function (style) {
	                        if (style) {
	                            style.applyStyle(this);
	                            this.contentHeight += style.getExtraBottom() + style.getExtraTop();
	                            this.contentWidth += style.getExtraLeft() + style.getExtraRight();
	                        }
	                    };
	                    TablixCell.prototype.enableHorizontalResize = function (enable, handler) {
	                        this._presenter.enableHorizontalResize(enable, handler);
	                    };
	                    return TablixCell;
	                }());
	                internal.TablixCell = TablixCell;
	                var TablixColumn = (function () {
	                    function TablixColumn(presenter, columnIndex) {
	                        this._presenter = presenter;
	                        this._presenter.initialize(this);
	                        this._containerWidth = -1;
	                        this._width = -1;
	                        this._sizeFixed = false;
	                        this._aligningWidth = -1;
	                        this._fixedToAligningWidth = false;
	                        this._items = [];
	                        this._itemType = null;
	                        this._footerCell = null;
	                        this._columnIndex = columnIndex;
	                    }
	                    TablixColumn.prototype.initialize = function (owner) {
	                        this._owner = owner;
	                        this._realizedRowHeaders = [];
	                        this._realizedColumnHeaders = [];
	                        this._realizedCornerCells = [];
	                        this._realizedBodyCells = [];
	                    };
	                    Object.defineProperty(TablixColumn.prototype, "owner", {
	                        get: function () {
	                            return this._owner;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    TablixColumn.prototype.getType = function () {
	                        if (this._realizedCornerCells.length > 0)
	                            return 0 /* CornerCell */;
	                        return 2 /* ColumnHeader */;
	                    };
	                    TablixColumn.prototype.getColumnHeadersOrCorners = function () {
	                        if (this._realizedCornerCells.length > 0)
	                            return this._realizedCornerCells;
	                        return this._realizedColumnHeaders;
	                    };
	                    TablixColumn.prototype.columnHeadersOrCornersEqual = function (newType, headers, hierarchyNavigator) {
	                        if (this._items.length !== headers.length)
	                            return false;
	                        var count = this._items.length;
	                        for (var i = 0; i < count; i++) {
	                            if (!this.columnHeaderOrCornerEquals(this._itemType, this._items[i], newType, headers[i].item, hierarchyNavigator))
	                                return false;
	                        }
	                        return true;
	                    };
	                    Object.defineProperty(TablixColumn.prototype, "itemType", {
	                        get: function () {
	                            return this._itemType;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    TablixColumn.prototype.getLeafItem = function () {
	                        if (this._items.length === 0)
	                            return null;
	                        return this._items[this._items.length - 1];
	                    };
	                    TablixColumn.prototype.columnHeaderOrCornerEquals = function (type1, item1, type2, item2, hierarchyNavigator) {
	                        if (type1 !== type2)
	                            return false;
	                        if (type1 === 0 /* CornerCell */) {
	                            if (!hierarchyNavigator.cornerCellItemEquals(item1, item2))
	                                return false;
	                        }
	                        else {
	                            if (!hierarchyNavigator.headerItemEquals(item1, item2))
	                                return false;
	                        }
	                        return true;
	                    };
	                    TablixColumn.prototype.OnLeafRealized = function (hierarchyNavigator) {
	                        // if the headers/corner have changed we should clear the column size to accomodate for the new content
	                        var type = this.getType();
	                        var columnHeadersOrCorners = this.getColumnHeadersOrCorners();
	                        if (this.columnHeadersOrCornersEqual(type, columnHeadersOrCorners, hierarchyNavigator)) {
	                            this.clearSpanningCellsWidth(this._realizedColumnHeaders);
	                        }
	                        else {
	                            var count = columnHeadersOrCorners.length;
	                            this._items = [];
	                            for (var i = 0; i < count; i++) {
	                                this._items.push(columnHeadersOrCorners[i].item);
	                            }
	                            this._itemType = type;
	                            this.clearSize();
	                        }
	                    };
	                    TablixColumn.prototype.clearSpanningCellsWidth = function (cells) {
	                        for (var i = 0; i < cells.length; i++) {
	                            var cell = cells[i];
	                            if (cell.colSpan > 1) {
	                                cell.setContainerWidth(-1);
	                            }
	                        }
	                    };
	                    TablixColumn.prototype.addCornerCell = function (cell) {
	                        cell._column = this;
	                        this._realizedCornerCells.push(cell);
	                        cell.setContainerWidth(this._containerWidth);
	                    };
	                    TablixColumn.prototype.addRowHeader = function (cell) {
	                        cell._column = this;
	                        this._realizedRowHeaders.push(cell);
	                        cell.setContainerWidth(this._containerWidth);
	                    };
	                    TablixColumn.prototype.addColumnHeader = function (cell, isLeaf) {
	                        cell._column = this;
	                        this._realizedColumnHeaders.push(cell);
	                        if (isLeaf) {
	                            cell.setContainerWidth(this._containerWidth);
	                        }
	                    };
	                    TablixColumn.prototype.addBodyCell = function (cell) {
	                        cell._column = this;
	                        this._realizedBodyCells.push(cell);
	                        cell.setContainerWidth(this._containerWidth);
	                    };
	                    Object.defineProperty(TablixColumn.prototype, "footer", {
	                        get: function () {
	                            return this._footerCell;
	                        },
	                        set: function (footerCell) {
	                            this._footerCell = footerCell;
	                            footerCell._column = this;
	                            footerCell.setContainerWidth(this._containerWidth);
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    TablixColumn.prototype.onResize = function (width) {
	                        if (width === this.getContentContextualWidth())
	                            return;
	                        this._containerWidth = width;
	                        this.setContainerWidth(this._containerWidth);
	                        this._sizeFixed = true;
	                        this._fixedToAligningWidth = false;
	                        this._aligningWidth = -1;
	                    };
	                    TablixColumn.prototype.onResizeEnd = function (width) {
	                        // Invoke resize callback
	                        var gridPresenter = this.owner._presenter;
	                        if (gridPresenter)
	                            gridPresenter.invokeColumnResizeEndCallback(this, width);
	                    };
	                    TablixColumn.prototype.fixSize = function () {
	                        var shouldAlign = this._aligningWidth !== -1;
	                        var switched = shouldAlign !== this._fixedToAligningWidth;
	                        if ((this._sizeFixed && !switched && !shouldAlign))
	                            return;
	                        if (this._aligningWidth === -1) {
	                            this.setContainerWidth(this._containerWidth);
	                        }
	                        else {
	                            this.setContainerWidth(this._aligningWidth);
	                        }
	                        this._sizeFixed = true;
	                        this._fixedToAligningWidth = this._aligningWidth !== -1;
	                    };
	                    TablixColumn.prototype.clearSize = function () {
	                        this._containerWidth = -1;
	                        this.setContainerWidth(this._containerWidth);
	                        this._sizeFixed = false;
	                    };
	                    TablixColumn.prototype.getContentContextualWidth = function () {
	                        return this._containerWidth;
	                    };
	                    TablixColumn.prototype.getCellIContentContextualWidth = function (cell) {
	                        return this._presenter.getCellWidth(cell);
	                    };
	                    TablixColumn.prototype.getCellSpanningWidthWithScrolling = function (cell, tablixGrid) {
	                        var width = this.getContextualWidth() + this.getScrollingOffset();
	                        if (cell.colSpan > 1) {
	                            var index = this.getIndex(tablixGrid);
	                            var columns = tablixGrid.realizedColumns;
	                            for (var i = 1; i < cell.colSpan; i++)
	                                width += columns[i + index].getContextualWidth();
	                        }
	                        return width;
	                    };
	                    TablixColumn.prototype.getScrollingOffset = function () {
	                        var offset = 0;
	                        if (this._realizedColumnHeaders.length > 0)
	                            offset = _.last(this._realizedColumnHeaders).horizontalOffset;
	                        return offset;
	                    };
	                    TablixColumn.prototype.getContextualWidth = function () {
	                        if (this._width === -1 || this._containerWidth === -1)
	                            this._width = this._presenter.getWidth();
	                        return this._width;
	                    };
	                    TablixColumn.prototype.calculateSize = function () {
	                        if (this._sizeFixed)
	                            return this._containerWidth;
	                        var contentWidth = 0;
	                        // Check for persisted width
	                        var persistedWidth = this._presenter.getPersistedWidth();
	                        if (persistedWidth != null) {
	                            // If yes, Set the width to the persisted width
	                            contentWidth = persistedWidth;
	                            // Handle special case of a single-child non-leaf column header, we need to show that wholly
	                            for (var i = 0, len = this._realizedColumnHeaders.length; i < len - 1; i++) {
	                                var cell = this._realizedColumnHeaders[i];
	                                if (cell.colSpan === 1)
	                                    contentWidth = Math.max(contentWidth, this._presenter.getCellWidth(cell));
	                            }
	                            return this._containerWidth = contentWidth;
	                        }
	                        // If no persisted width, we get the maximum width of the visible cells
	                        for (var _i = 0, _a = this._realizedColumnHeaders; _i < _a.length; _i++) {
	                            var cell = _a[_i];
	                            if (cell.colSpan === 1)
	                                contentWidth = Math.max(contentWidth, this._presenter.getCellWidth(cell));
	                        }
	                        for (var _b = 0, _c = this._realizedRowHeaders; _b < _c.length; _b++) {
	                            var cell = _c[_b];
	                            if (cell.colSpan === 1)
	                                contentWidth = Math.max(contentWidth, this._presenter.getCellWidth(cell));
	                        }
	                        for (var _d = 0, _e = this._realizedCornerCells; _d < _e.length; _d++) {
	                            var cell = _e[_d];
	                            contentWidth = Math.max(contentWidth, this._presenter.getCellWidth(cell));
	                        }
	                        for (var _f = 0, _g = this._realizedBodyCells; _f < _g.length; _f++) {
	                            var cell = _g[_f];
	                            contentWidth = Math.max(contentWidth, this._presenter.getCellWidth(cell));
	                        }
	                        if (this._footerCell !== null && this._footerCell.colSpan === 1)
	                            contentWidth = Math.max(contentWidth, this._presenter.getCellWidth(this._footerCell));
	                        return this._containerWidth = contentWidth;
	                    };
	                    TablixColumn.prototype.setAligningContextualWidth = function (size) {
	                        this._aligningWidth = size;
	                    };
	                    TablixColumn.prototype.getAligningContextualWidth = function () {
	                        return this._aligningWidth;
	                    };
	                    TablixColumn.prototype.setContainerWidth = function (value) {
	                        for (var _i = 0, _a = this._realizedColumnHeaders; _i < _a.length; _i++) {
	                            var cell = _a[_i];
	                            if (cell.colSpan === 1)
	                                cell.setContainerWidth(value);
	                        }
	                        for (var _b = 0, _c = this._realizedRowHeaders; _b < _c.length; _b++) {
	                            var cell = _c[_b];
	                            if (cell.colSpan === 1)
	                                cell.setContainerWidth(value);
	                        }
	                        for (var _d = 0, _e = this._realizedCornerCells; _d < _e.length; _d++) {
	                            var cell = _e[_d];
	                            cell.setContainerWidth(value);
	                        }
	                        for (var _f = 0, _g = this._realizedBodyCells; _f < _g.length; _f++) {
	                            var cell = _g[_f];
	                            cell.setContainerWidth(value);
	                        }
	                        if (this._footerCell !== null) {
	                            if (this._footerCell.colSpan === 1)
	                                this._footerCell.setContainerWidth(value);
	                        }
	                        this._width = value; // set cell width to new value
	                    };
	                    TablixColumn.prototype.getTablixCell = function () {
	                        var realizedCells = this._realizedColumnHeaders.length > 0 ? this._realizedColumnHeaders : this._realizedCornerCells;
	                        //Debug.assert(realizedCells.length !== 0, "At least on header should have been realized");
	                        return realizedCells[realizedCells.length - 1];
	                    };
	                    TablixColumn.prototype.getIndex = function (grid) {
	                        return grid.realizedColumns.indexOf(this);
	                    };
	                    TablixColumn.prototype.getHeaders = function () {
	                        return this._realizedColumnHeaders;
	                    };
	                    TablixColumn.prototype.getOtherDimensionHeaders = function () {
	                        return this._realizedRowHeaders;
	                    };
	                    TablixColumn.prototype.getCellContextualSpan = function (cell) {
	                        return cell.colSpan;
	                    };
	                    TablixColumn.prototype.getOtherDimensionOwner = function (cell) {
	                        return cell._row;
	                    };
	                    return TablixColumn;
	                }());
	                internal.TablixColumn = TablixColumn;
	                var TablixRow = (function () {
	                    function TablixRow(presenter) {
	                        this._containerHeight = -1;
	                        this._presenter = presenter;
	                        this._presenter.initialize(this);
	                        this._allocatedCells = [];
	                        this._heightFixed = false;
	                        this._containerHeight = -1;
	                        this._height = -1;
	                    }
	                    TablixRow.prototype.initialize = function (owner) {
	                        this._owner = owner;
	                        this._realizedRowHeaders = [];
	                        this._realizedBodyCells = [];
	                        this._realizedCornerCells = [];
	                        this._realizedColumnHeaders = [];
	                        this._realizedCellsCount = 0;
	                    };
	                    Object.defineProperty(TablixRow.prototype, "presenter", {
	                        get: function () {
	                            return this._presenter;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(TablixRow.prototype, "owner", {
	                        get: function () {
	                            return this._owner;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    TablixRow.prototype.releaseUnusedCells = function (owner) {
	                        this.releaseCells(owner, this._realizedCellsCount);
	                    };
	                    TablixRow.prototype.releaseAllCells = function (owner) {
	                        this.releaseCells(owner, 0);
	                    };
	                    TablixRow.prototype.releaseCells = function (owner, startIndex) {
	                        var cells = this._allocatedCells;
	                        var length = cells.length;
	                        for (var i = startIndex; i < length; i++) {
	                            var cell = cells[i];
	                            owner._unbindCell(cell);
	                            cell.clear();
	                        }
	                    };
	                    TablixRow.prototype.moveScrollableCellsToEnd = function (count) {
	                        var frontIndex = Math.max(this._realizedRowHeaders.length, this._realizedCornerCells.length);
	                        for (var i = frontIndex; i < frontIndex + count; i++) {
	                            var cell = this._allocatedCells[i];
	                            this._presenter.onRemoveCell(cell);
	                            this._presenter.onAppendCell(cell);
	                            this._allocatedCells.push(cell);
	                        }
	                        this._allocatedCells.splice(frontIndex, count);
	                    };
	                    TablixRow.prototype.moveScrollableCellsToStart = function (count) {
	                        var frontIndex = Math.max(this._realizedRowHeaders.length, this._realizedCornerCells.length);
	                        for (var i = frontIndex; i < frontIndex + count; i++) {
	                            var cell = this._allocatedCells.pop();
	                            this._presenter.onRemoveCell(cell);
	                            this._presenter.onInsertCellBefore(cell, this._allocatedCells[frontIndex]);
	                            this._allocatedCells.splice(frontIndex, 0, cell);
	                        }
	                    };
	                    TablixRow.prototype.getOrCreateCornerCell = function (column) {
	                        var cell = this.getOrCreateCell();
	                        cell.prepare(false);
	                        column.addCornerCell(cell);
	                        this._realizedCornerCells.push(cell);
	                        cell.setContainerHeight(this._containerHeight);
	                        return cell;
	                    };
	                    TablixRow.prototype.getOrCreateRowHeader = function (column, scrollable, leaf) {
	                        var cell = this.getOrCreateCell();
	                        cell.prepare(scrollable);
	                        column.addRowHeader(cell);
	                        this._realizedRowHeaders.push(cell);
	                        if (leaf)
	                            cell.setContainerHeight(this._containerHeight);
	                        return cell;
	                    };
	                    TablixRow.prototype.getOrCreateColumnHeader = function (column, scrollable, leaf) {
	                        var cell = this.getOrCreateCell();
	                        cell.prepare(scrollable);
	                        column.addColumnHeader(cell, leaf);
	                        this._realizedColumnHeaders.push(cell);
	                        cell.setContainerHeight(this._containerHeight);
	                        return cell;
	                    };
	                    TablixRow.prototype.getOrCreateBodyCell = function (column, scrollable) {
	                        var cell = this.getOrCreateCell();
	                        cell.prepare(scrollable);
	                        column.addBodyCell(cell);
	                        this._realizedBodyCells.push(cell);
	                        cell.setContainerHeight(this._containerHeight);
	                        return cell;
	                    };
	                    TablixRow.prototype.getOrCreateFooterRowHeader = function (column) {
	                        var cell = this.getOrCreateCell();
	                        cell.prepare(false);
	                        column.footer = cell;
	                        this._realizedRowHeaders.push(cell);
	                        cell.setContainerHeight(this._containerHeight);
	                        return cell;
	                    };
	                    TablixRow.prototype.getOrCreateFooterBodyCell = function (column, scrollable) {
	                        var cell = this.getOrCreateCell();
	                        cell.prepare(scrollable);
	                        column.footer = cell;
	                        this._realizedBodyCells.push(cell);
	                        cell.setContainerHeight(this._containerHeight);
	                        return cell;
	                    };
	                    TablixRow.prototype.getRowHeaderLeafIndex = function () {
	                        var index = -1;
	                        var count = this._allocatedCells.length;
	                        for (var i = 0; i < count; i++) {
	                            if (this._allocatedCells[i].type !== 1 /* RowHeader */)
	                                break;
	                            index++;
	                        }
	                        return index;
	                    };
	                    TablixRow.prototype.getAllocatedCellAt = function (index) {
	                        return this._allocatedCells[index];
	                    };
	                    TablixRow.prototype.moveCellsBy = function (delta) {
	                        if (this._allocatedCells.length === 0)
	                            return;
	                        if (delta > 0) {
	                            var refCell = this._allocatedCells[0];
	                            for (var i = 0; i < delta; i++) {
	                                var cell = this.createCell(this);
	                                this._presenter.onInsertCellBefore(cell, refCell);
	                                this._allocatedCells.unshift(cell);
	                                refCell = cell;
	                            }
	                        }
	                        else {
	                            delta = -delta;
	                            for (var i = 0; i < delta; i++) {
	                                this._presenter.onRemoveCell(this._allocatedCells[i]);
	                            }
	                            this._allocatedCells.splice(0, delta);
	                        }
	                    };
	                    TablixRow.prototype.getRealizedCellCount = function () {
	                        return this._realizedCellsCount;
	                    };
	                    TablixRow.prototype.getRealizedHeadersCount = function () {
	                        return this._realizedRowHeaders.length;
	                    };
	                    TablixRow.prototype.getRealizedHeaderAt = function (index) {
	                        return this._realizedRowHeaders[index];
	                    };
	                    TablixRow.prototype.getTablixCell = function () {
	                        var realizedCells;
	                        if (this._realizedRowHeaders.length > 0) {
	                            realizedCells = this._realizedRowHeaders;
	                        }
	                        else if (this._realizedCornerCells.length > 0) {
	                            realizedCells = this._realizedCornerCells;
	                        }
	                        else {
	                            realizedCells = this._realizedColumnHeaders;
	                        }
	                        //Debug.assert(realizedCells.length !== 0, "At least on header should have been realized");
	                        return realizedCells[realizedCells.length - 1];
	                    };
	                    TablixRow.prototype.getOrCreateEmptySpaceCell = function () {
	                        var cell = this._allocatedCells[this._realizedCellsCount];
	                        if (cell === undefined) {
	                            cell = this.createCell(this);
	                            this._allocatedCells[this._realizedCellsCount] = cell;
	                            this._presenter.onAppendCell(cell);
	                        }
	                        return cell;
	                    };
	                    TablixRow.prototype.createCell = function (row) {
	                        var presenter = this._presenter.createCellPresenter(this._owner.owner.layoutManager.getLayoutKind());
	                        return new TablixCell(presenter, presenter, this);
	                    };
	                    TablixRow.prototype.getOrCreateCell = function () {
	                        var cell = this._allocatedCells[this._realizedCellsCount];
	                        if (cell === undefined) {
	                            cell = this.createCell(this);
	                            this._allocatedCells[this._realizedCellsCount] = cell;
	                            this._presenter.onAppendCell(cell);
	                        }
	                        else {
	                            cell.colSpan = 1;
	                            cell.rowSpan = 1;
	                        }
	                        this._realizedCellsCount = this._realizedCellsCount + 1;
	                        return cell;
	                    };
	                    TablixRow.prototype.onResize = function (height) {
	                        if (height === this.getContentContextualWidth())
	                            return;
	                        this._containerHeight = height;
	                        this.setContentHeight();
	                        this._heightFixed = true;
	                        this.setAligningContextualWidth(-1);
	                    };
	                    TablixRow.prototype.onResizeEnd = function (height) { };
	                    TablixRow.prototype.fixSize = function () {
	                        if (this.sizeFixed())
	                            return;
	                        this.setContentHeight();
	                        this._heightFixed = true;
	                    };
	                    TablixRow.prototype.unfixSize = function () {
	                        this._heightFixed = false;
	                        this._height = -1;
	                    };
	                    TablixRow.prototype.getContentContextualWidth = function () {
	                        return this._containerHeight;
	                    };
	                    TablixRow.prototype.getCellIContentContextualWidth = function (cell) {
	                        return this.presenter.getCellContentHeight(cell);
	                    };
	                    TablixRow.prototype.getCellSpanningHeight = function (cell) {
	                        var height = this.getContextualWidth();
	                        if (cell.rowSpan > 1) {
	                            var index = this.getIndex(this.owner);
	                            var rows = this.owner.realizedRows;
	                            for (var i = 1; i < cell.rowSpan; i++)
	                                height += rows[i + index].getContextualWidth();
	                        }
	                        return height;
	                    };
	                    TablixRow.prototype.getContextualWidth = function () {
	                        if (this._height === -1 || this._containerHeight === -1)
	                            this._height = this._presenter.getHeight();
	                        return this._height;
	                    };
	                    TablixRow.prototype.sizeFixed = function () {
	                        return this._heightFixed;
	                    };
	                    TablixRow.prototype.calculateSize = function () {
	                        if (this._heightFixed)
	                            return this._containerHeight;
	                        var contentHeight = 0;
	                        var count = this._realizedRowHeaders.length;
	                        for (var i = 0; i < count; i++) {
	                            var cell = this._realizedRowHeaders[i];
	                            if (cell.rowSpan === 1)
	                                contentHeight = Math.max(contentHeight, this._presenter.getCellContentHeight(cell));
	                        }
	                        count = this._realizedCornerCells.length;
	                        for (var i = 0; i < count; i++) {
	                            contentHeight = Math.max(contentHeight, this._presenter.getCellContentHeight(this._realizedCornerCells[i]));
	                        }
	                        count = this._realizedColumnHeaders.length;
	                        for (var i = 0; i < count; i++) {
	                            var cell = this._realizedColumnHeaders[i];
	                            if (cell.rowSpan === 1)
	                                contentHeight = Math.max(contentHeight, this._presenter.getCellContentHeight(cell));
	                        }
	                        count = this._realizedBodyCells.length;
	                        for (var i = 0; i < count; i++) {
	                            contentHeight = Math.max(contentHeight, this._presenter.getCellContentHeight(this._realizedBodyCells[i]));
	                        }
	                        return this._containerHeight = contentHeight;
	                    };
	                    TablixRow.prototype.setAligningContextualWidth = function (size) {
	                        // TODO should be implemented when we support variable row heights
	                    };
	                    TablixRow.prototype.getAligningContextualWidth = function () {
	                        // TODO should be implemented when we support variable row heights
	                        return -1;
	                    };
	                    TablixRow.prototype.setContentHeight = function () {
	                        var count = this._realizedRowHeaders.length;
	                        // Need to do them in reverse order so that leaf headers are set first
	                        for (var i = count - 1; i >= 0; i--) {
	                            var cell = this._realizedRowHeaders[i];
	                            cell.setContainerHeight(this._containerHeight);
	                            if (cell.rowSpan > 1)
	                                cell.setContainerHeight(this.getCellSpanningHeight(cell));
	                        }
	                        count = this._realizedCornerCells.length;
	                        for (var i = 0; i < count; i++) {
	                            this._realizedCornerCells[i].setContainerHeight(this._containerHeight);
	                        }
	                        count = this._realizedColumnHeaders.length;
	                        for (var i = 0; i < count; i++) {
	                            var cell = this._realizedColumnHeaders[i];
	                            cell.setContainerHeight(this._containerHeight);
	                            if (cell.rowSpan > 1)
	                                cell.setContainerHeight(this.getCellSpanningHeight(cell));
	                        }
	                        count = this._realizedBodyCells.length;
	                        for (var i = 0; i < count; i++) {
	                            this._realizedBodyCells[i].setContainerHeight(this._containerHeight);
	                        }
	                        this._height = -1;
	                    };
	                    TablixRow.prototype.getIndex = function (grid) {
	                        return grid.realizedRows.indexOf(this);
	                    };
	                    TablixRow.prototype.getHeaders = function () {
	                        return this._realizedRowHeaders;
	                    };
	                    TablixRow.prototype.getOtherDimensionHeaders = function () {
	                        return this._realizedColumnHeaders;
	                    };
	                    TablixRow.prototype.getCellContextualSpan = function (cell) {
	                        return cell.rowSpan;
	                    };
	                    TablixRow.prototype.getOtherDimensionOwner = function (cell) {
	                        return cell._column;
	                    };
	                    return TablixRow;
	                }());
	                internal.TablixRow = TablixRow;
	                var TablixGrid = (function () {
	                    function TablixGrid(presenter) {
	                        this._presenter = presenter;
	                        this._footerRow = null;
	                    }
	                    TablixGrid.prototype.initialize = function (owner, gridHost, footerHost) {
	                        this._owner = owner;
	                        this._presenter.initialize(this, gridHost, footerHost, owner);
	                        this.fillColumnsProportionally = false;
	                        this._realizedRows = [];
	                        this._realizedColumns = [];
	                        this._emptySpaceHeaderCell = null;
	                        this._emptyFooterSpaceCell = null;
	                    };
	                    Object.defineProperty(TablixGrid.prototype, "owner", {
	                        get: function () {
	                            return this._owner;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(TablixGrid.prototype, "fillColumnsProportionally", {
	                        get: function () {
	                            return this._fillColumnsProportionally;
	                        },
	                        set: function (value) {
	                            if (this._fillColumnsProportionally === value)
	                                return;
	                            this._fillColumnsProportionally = value;
	                            this._presenter.onFillColumnsProportionallyChanged(value);
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(TablixGrid.prototype, "realizedColumns", {
	                        get: function () {
	                            return this._realizedColumns;
	                        },
	                        set: function (columns) {
	                            this._realizedColumns = columns;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(TablixGrid.prototype, "realizedRows", {
	                        get: function () {
	                            return this._realizedRows;
	                        },
	                        set: function (rows) {
	                            this._realizedRows = rows;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(TablixGrid.prototype, "footerRow", {
	                        get: function () {
	                            return this._footerRow;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(TablixGrid.prototype, "emptySpaceHeaderCell", {
	                        get: function () {
	                            return this._emptySpaceHeaderCell;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(TablixGrid.prototype, "emptySpaceFooterCell", {
	                        get: function () {
	                            return this._emptyFooterSpaceCell;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    TablixGrid.prototype.ShowEmptySpaceCells = function (rowSpan, width) {
	                        if (this._realizedRows.length === 0)
	                            return;
	                        if (this._realizedRows.length !== 0 && !this._emptySpaceHeaderCell) {
	                            this._emptySpaceHeaderCell = this._realizedRows[0].getOrCreateEmptySpaceCell();
	                            this._emptySpaceHeaderCell.rowSpan = rowSpan;
	                            this._emptySpaceHeaderCell.colSpan = 1;
	                            this._emptySpaceHeaderCell.setContainerWidth(width);
	                        }
	                        if (this._footerRow && (this._emptyFooterSpaceCell === null)) {
	                            this._emptyFooterSpaceCell = this._footerRow.getOrCreateEmptySpaceCell();
	                            this._emptyFooterSpaceCell.rowSpan = 1;
	                            this._emptyFooterSpaceCell.colSpan = 1;
	                            this._emptyFooterSpaceCell.setContainerWidth(width);
	                        }
	                    };
	                    TablixGrid.prototype.HideEmptySpaceCells = function () {
	                        if (this._emptySpaceHeaderCell) {
	                            this._emptySpaceHeaderCell.clear();
	                            this._emptySpaceHeaderCell = null;
	                        }
	                        if (this._emptyFooterSpaceCell) {
	                            this._emptyFooterSpaceCell.clear();
	                            this._emptyFooterSpaceCell = null;
	                        }
	                    };
	                    TablixGrid.prototype.onStartRenderingSession = function (clear) {
	                        if (clear) {
	                            this.clearRows();
	                            this.clearColumns();
	                        }
	                    };
	                    TablixGrid.prototype.onStartRenderingIteration = function () {
	                        this.initializeRows();
	                        this.initializeColumns();
	                    };
	                    TablixGrid.prototype.onEndRenderingIteration = function () {
	                        var rows = this._rows;
	                        if (rows !== undefined) {
	                            var rowCount = rows.length;
	                            for (var i = 0; i < rowCount; i++) {
	                                rows[i].releaseUnusedCells(this._owner);
	                            }
	                        }
	                        if (this._footerRow) {
	                            this._footerRow.releaseUnusedCells(this._owner);
	                        }
	                    };
	                    TablixGrid.prototype.getOrCreateRow = function (rowIndex) {
	                        var currentRow = this._rows[rowIndex];
	                        if (currentRow === undefined) {
	                            currentRow = new TablixRow(this._presenter.createRowPresenter());
	                            currentRow.initialize(this);
	                            this._presenter.onAppendRow(currentRow);
	                            this._rows[rowIndex] = currentRow;
	                        }
	                        if (this._realizedRows[rowIndex] === undefined) {
	                            this._realizedRows[rowIndex] = currentRow;
	                        }
	                        return currentRow;
	                    };
	                    TablixGrid.prototype.getOrCreateFootersRow = function () {
	                        if (this._footerRow === null) {
	                            this._footerRow = new TablixRow(this._presenter.createRowPresenter());
	                            this._footerRow.initialize(this);
	                            this._presenter.onAddFooterRow(this._footerRow);
	                        }
	                        return this._footerRow;
	                    };
	                    TablixGrid.prototype.moveRowsToEnd = function (moveFromIndex, count) {
	                        for (var i = 0; i < count; i++) {
	                            var row = this._rows[i + moveFromIndex];
	                            debug.assertValue(row, "Invalid Row Index");
	                            row.unfixSize();
	                            this._presenter.onRemoveRow(row);
	                            this._presenter.onAppendRow(row);
	                            this._rows.push(row);
	                        }
	                        this._rows.splice(moveFromIndex, count);
	                    };
	                    TablixGrid.prototype.moveRowsToStart = function (moveToIndex, count) {
	                        var refRow = this._rows[moveToIndex];
	                        debug.assertValue(refRow, "Invalid Row Index");
	                        for (var i = 0; i < count; i++) {
	                            var row = this._rows.pop();
	                            row.unfixSize();
	                            this._presenter.onRemoveRow(row);
	                            this._presenter.onInsertRowBefore(row, refRow);
	                            this._rows.splice(moveToIndex + i, 0, row);
	                        }
	                    };
	                    TablixGrid.prototype.moveColumnsToEnd = function (moveFromIndex, count) {
	                        var firstCol = this._rows[0]._realizedCornerCells.length;
	                        var leafStartDepth = Math.max(this._columns[firstCol]._realizedColumnHeaders.length - 1, 0);
	                        for (var i = leafStartDepth; i < this._rows.length; i++) {
	                            this._rows[i].moveScrollableCellsToEnd(count);
	                        }
	                        for (var i = 0; i < count; i++) {
	                            var column = this._columns[i + moveFromIndex];
	                            //Debug.assertValue(column, "Invalid Column Index");
	                            this._columns.push(column);
	                        }
	                        this._columns.splice(moveFromIndex, count);
	                    };
	                    TablixGrid.prototype.moveColumnsToStart = function (moveToIndex, count) {
	                        var firstCol = this._rows[0]._realizedCornerCells.length;
	                        var leafStartDepth = Math.max(this._columns[firstCol]._realizedColumnHeaders.length - 1, 0);
	                        for (var i = leafStartDepth; i < this._rows.length; i++) {
	                            this._rows[i].moveScrollableCellsToStart(count);
	                        }
	                        for (var i = 0; i < count; i++) {
	                            var column = this._columns.pop();
	                            this._columns.splice(moveToIndex + i, 0, column);
	                        }
	                    };
	                    TablixGrid.prototype.getOrCreateColumn = function (columnIndex) {
	                        var currentColumn = this._columns[columnIndex];
	                        if (currentColumn === undefined) {
	                            currentColumn = new TablixColumn(this._presenter.createColumnPresenter(columnIndex), columnIndex);
	                            currentColumn.initialize(this);
	                            this._columns[columnIndex] = currentColumn;
	                        }
	                        if (this._realizedColumns[columnIndex] === undefined) {
	                            this._realizedColumns[columnIndex] = currentColumn;
	                        }
	                        return currentColumn;
	                    };
	                    TablixGrid.prototype.initializeColumns = function () {
	                        if (!this._columns)
	                            this._columns = [];
	                        var length = this._columns.length;
	                        for (var i = 0; i < length; i++) {
	                            this._columns[i].initialize(this);
	                        }
	                        this._realizedColumns = [];
	                    };
	                    TablixGrid.prototype.clearColumns = function () {
	                        this._columns = null;
	                        this._realizedColumns = null;
	                    };
	                    TablixGrid.prototype.initializeRows = function () {
	                        // make sure rowDimension confirms it and it's not null in the grid
	                        var hasFooter = this._owner.rowDimension.hasFooter() && (this._footerRow !== null);
	                        this._realizedRows = [];
	                        if (!this._rows) {
	                            this._rows = [];
	                        }
	                        var rows = this._rows;
	                        var length = rows.length;
	                        for (var i = 0; i < length; i++) {
	                            rows[i].initialize(this);
	                        }
	                        if (hasFooter) {
	                            if (!this._footerRow) {
	                                this.getOrCreateFootersRow();
	                            }
	                            this._footerRow.initialize(this);
	                        }
	                    };
	                    TablixGrid.prototype.clearRows = function () {
	                        var rows = this._rows;
	                        if (rows) {
	                            var length_1 = rows.length;
	                            for (var i = 0; i < length_1; i++) {
	                                rows[i].releaseAllCells(this._owner);
	                            }
	                            if (this._footerRow)
	                                this._footerRow.releaseAllCells(this._owner);
	                            this._presenter.onClear();
	                            this._footerRow = null;
	                            this._rows = null;
	                            this._realizedRows = null;
	                        }
	                    };
	                    TablixGrid.prototype.getWidth = function () {
	                        return this._presenter.getWidth();
	                    };
	                    TablixGrid.prototype.getHeight = function () {
	                        return this._presenter.getHeight();
	                    };
	                    return TablixGrid;
	                }());
	                internal.TablixGrid = TablixGrid;
	            })(internal = controls.internal || (controls.internal = {}));
	        })(controls = visuals.controls || (visuals.controls = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 239 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/// <reference path="../../../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var controls;
	        (function (controls) {
	            var internal;
	            (function (internal) {
	                var PixelConverter = jsCommon.PixelConverter;
	                /**
	                 * This class is used for layouts that don't or cannot
	                 * rely on DOM measurements.  Instead they compute all required
	                 * widths and heights and store it in this structure.
	                 */
	                var SizeComputationManager = (function () {
	                    function SizeComputationManager() {
	                    }
	                    Object.defineProperty(SizeComputationManager.prototype, "visibleWidth", {
	                        get: function () {
	                            return this._viewport ? this._viewport.width : 0;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(SizeComputationManager.prototype, "visibleHeight", {
	                        get: function () {
	                            return this._viewport ? this._viewport.height : 0;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(SizeComputationManager.prototype, "gridWidth", {
	                        get: function () {
	                            return this.visibleWidth;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(SizeComputationManager.prototype, "gridHeight", {
	                        get: function () {
	                            return this.visibleHeight;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(SizeComputationManager.prototype, "rowHeight", {
	                        get: function () {
	                            return this._cellHeight;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(SizeComputationManager.prototype, "cellWidth", {
	                        get: function () {
	                            return this._cellWidth;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(SizeComputationManager.prototype, "cellHeight", {
	                        get: function () {
	                            return this._cellHeight;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(SizeComputationManager.prototype, "contentWidth", {
	                        get: function () {
	                            return this._cellWidth;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(SizeComputationManager.prototype, "contentHeight", {
	                        get: function () {
	                            return this._cellHeight;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    SizeComputationManager.prototype.updateColumnCount = function (columnCount) {
	                        this._columnCount = columnCount;
	                    };
	                    SizeComputationManager.prototype.updateRowHeight = function (rowHeight) {
	                        this._cellHeight = rowHeight;
	                    };
	                    SizeComputationManager.prototype.updateScalingFactor = function (scalingFactor) {
	                        this._scalingFactor = scalingFactor;
	                        this._cellWidth = this.computeColumnWidth(this._columnCount);
	                    };
	                    SizeComputationManager.prototype.updateViewport = function (viewport) {
	                        this._viewport = viewport;
	                        this._cellWidth = this.computeColumnWidth(this._columnCount);
	                        this._cellHeight = this.computeColumnHeight();
	                    };
	                    SizeComputationManager.prototype.computeColumnWidth = function (totalColumnCount) {
	                        var scalingFactor = this._scalingFactor;
	                        if (!scalingFactor)
	                            scalingFactor = 1;
	                        var minimumColumnWidth = scalingFactor * SizeComputationManager.TablixMinimumColumnWidth;
	                        var maxAllowedColumns = Math.floor(this._viewport.width / minimumColumnWidth);
	                        return this.fitToColumnCount(maxAllowedColumns, totalColumnCount);
	                    };
	                    SizeComputationManager.prototype.computeColumnHeight = function () {
	                        if (!this.hasImageContent)
	                            return this._cellHeight;
	                        var width = this._viewport.width;
	                        if (width <= 250) {
	                            // Small
	                            return 20;
	                        }
	                        else if (width <= 510) {
	                            // Medium
	                            return 51;
	                        }
	                        else if (width <= 770) {
	                            // Large
	                            return 52;
	                        }
	                        debug.assertFail("Fixed size is only for viewport up to 770px width.");
	                    };
	                    SizeComputationManager.prototype.fitToColumnCount = function (maxAllowedColumnCount, totalColumnCount) {
	                        var columnsToFit = Math.min(maxAllowedColumnCount, totalColumnCount);
	                        return Math.floor(this._viewport.width / columnsToFit);
	                    };
	                    // Minimum size for a column, used to calculate layout
	                    SizeComputationManager.TablixMinimumColumnWidth = 75;
	                    return SizeComputationManager;
	                }());
	                internal.SizeComputationManager = SizeComputationManager;
	                var DimensionLayoutManager = (function () {
	                    function DimensionLayoutManager(owner, grid, realizationManager) {
	                        //debug.assertValue(realizationManager, "Realization Manager must be defined");
	                        this._owner = owner;
	                        this._grid = grid;
	                        this._lastScrollOffset = null;
	                        this._isScrolling = false;
	                        this._fixedSizeEnabled = true;
	                        this._done = false;
	                        this._realizationManager = realizationManager;
	                    }
	                    Object.defineProperty(DimensionLayoutManager.prototype, "owner", {
	                        get: function () {
	                            return this._owner;
	                        },
	                        set: function (owner) {
	                            this._owner = owner;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(DimensionLayoutManager.prototype, "realizationManager", {
	                        get: function () {
	                            return this._realizationManager;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(DimensionLayoutManager.prototype, "fixedSizeEnabled", {
	                        get: function () {
	                            return this._fixedSizeEnabled;
	                        },
	                        set: function (enable) {
	                            this._fixedSizeEnabled = enable;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    DimensionLayoutManager.prototype.onCornerCellRealized = function (item, cell, leaf) {
	                        this._realizationManager.onCornerCellRealized(item, cell);
	                    };
	                    DimensionLayoutManager.prototype.onHeaderRealized = function (item, cell, leaf) {
	                        this._realizationManager.onHeaderRealized(item, cell, leaf);
	                    };
	                    Object.defineProperty(DimensionLayoutManager.prototype, "needsToRealize", {
	                        get: function () {
	                            return this._realizationManager.needsToRealize;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    DimensionLayoutManager.prototype.getVisibleSizeRatio = function () {
	                        return 1 - this.dimension.getFractionScrollOffset();
	                    };
	                    Object.defineProperty(DimensionLayoutManager.prototype, "alignToEnd", {
	                        get: function () {
	                            return this._alignToEnd;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(DimensionLayoutManager.prototype, "done", {
	                        get: function () {
	                            return this._done;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    DimensionLayoutManager.prototype._requiresMeasure = function () {
	                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._requiresMeasure");
	                        return true;
	                    };
	                    DimensionLayoutManager.prototype.startScrollingSession = function () {
	                        this._isScrolling = true;
	                    };
	                    DimensionLayoutManager.prototype.endScrollingSession = function () {
	                        this._isScrolling = false;
	                    };
	                    DimensionLayoutManager.prototype.isScrolling = function () {
	                        return this._isScrolling;
	                    };
	                    DimensionLayoutManager.prototype.isResizing = function () {
	                        return false;
	                    };
	                    DimensionLayoutManager.prototype.getOtherHierarchyContextualHeight = function () {
	                        var otherDimension = this.dimension.otherDimension;
	                        var count = otherDimension.getDepth();
	                        var contextualHeight = 0;
	                        var items = this._getRealizedItems();
	                        if (items.length > 0) {
	                            for (var i = 0; i < count; i++) {
	                                contextualHeight += items[i].getContextualWidth();
	                            }
	                        }
	                        return contextualHeight;
	                    };
	                    DimensionLayoutManager.prototype._isAutoSized = function () {
	                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._isAutoSized");
	                        return false;
	                    };
	                    DimensionLayoutManager.prototype.onStartRenderingSession = function () {
	                        this._measureEnabled = this._requiresMeasure();
	                        this._gridOffset = this.dimension.otherDimension.getDepth();
	                    };
	                    DimensionLayoutManager.prototype.onEndRenderingSession = function () {
	                        this._realizationManager.onEndRenderingSession();
	                        this._alignToEnd = false;
	                        this._done = false;
	                        this._measureEnabled = true;
	                        this._sendDimensionsToControl();
	                    };
	                    /**
	                     * Implementing classes must override this to send dimentions to TablixControl.
	                     */
	                    DimensionLayoutManager.prototype._sendDimensionsToControl = function () {
	                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._sendDimensionsToControl");
	                    };
	                    Object.defineProperty(DimensionLayoutManager.prototype, "measureEnabled", {
	                        get: function () {
	                            return this._measureEnabled;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    DimensionLayoutManager.prototype.getFooterContextualWidth = function () {
	                        return 0;
	                    };
	                    DimensionLayoutManager.prototype.onStartRenderingIteration = function (clear, contextualWidth) {
	                        if (this._measureEnabled && !this._done) {
	                            this._contextualWidthToFill = (contextualWidth - this.otherScrollbarContextualWidth) * this.getGridScale() - this.getFooterContextualWidth();
	                        }
	                        this._realizationManager.onStartRenderingIteration();
	                        if (clear) {
	                            this._lastScrollOffset = null;
	                        }
	                        else if (this._lastScrollOffset !== null) {
	                            this.swapElements();
	                        }
	                    };
	                    Object.defineProperty(DimensionLayoutManager.prototype, "allItemsRealized", {
	                        get: function () {
	                            return this.getRealizedItemsCount() - this._gridOffset === this.dimension.getItemsCount() || this.dimension.getItemsCount() === 0;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    DimensionLayoutManager.prototype.onEndRenderingIteration = function () {
	                        if (this._done) {
	                            return;
	                        }
	                        if (!this._measureEnabled) {
	                            this._lastScrollOffset = this.dimension.scrollOffset;
	                            this._done = true;
	                            return;
	                        }
	                        var gridContextualWidth = this.getGridContextualWidth();
	                        var filled = powerbi.Double.greaterOrEqualWithPrecision(gridContextualWidth, this._contextualWidthToFill, DimensionLayoutManager._pixelPrecision);
	                        var allRealized = this.allItemsRealized;
	                        var newScrollOffset;
	                        if (filled) {
	                            newScrollOffset = this.scrollForwardToAlignEnd(gridContextualWidth);
	                        }
	                        else {
	                            newScrollOffset = this.scrollBackwardToFill(gridContextualWidth);
	                        }
	                        this._realizationManager.onEndRenderingIteration(gridContextualWidth, filled);
	                        var originalScrollbarVisible = this.dimension.scrollbar.visible;
	                        this.updateScrollbar(gridContextualWidth);
	                        this._done = (filled || allRealized) &&
	                            this.dimension.scrollbar.visible === originalScrollbarVisible &&
	                            powerbi.Double.equalWithPrecision(newScrollOffset, this.dimension.scrollOffset, DimensionLayoutManager._scrollOffsetPrecision);
	                        this.dimension.scrollOffset = newScrollOffset;
	                        this._lastScrollOffset = this.dimension.scrollOffset;
	                    };
	                    DimensionLayoutManager.prototype.getScrollDeltaWithinPage = function () {
	                        if (this._lastScrollOffset !== null) {
	                            var delta = this.dimension.getIntegerScrollOffset() - Math.floor(this._lastScrollOffset);
	                            if (Math.abs(delta) < this.getRealizedItemsCount() - this.dimension.otherDimension.getDepth()) {
	                                return delta;
	                            }
	                        }
	                        return null;
	                    };
	                    DimensionLayoutManager.prototype.swapElements = function () {
	                        var delta = this.getScrollDeltaWithinPage();
	                        if (delta !== null) {
	                            var otherHierarchyDepth = this.dimension.otherDimension.getDepth();
	                            if (Math.abs(delta) < this.getRealizedItemsCount() - otherHierarchyDepth) {
	                                if (delta > 0) {
	                                    this._moveElementsToBottom(otherHierarchyDepth, delta);
	                                }
	                                else if (delta < 0) {
	                                    this._moveElementsToTop(otherHierarchyDepth, -delta);
	                                }
	                            }
	                        }
	                    };
	                    DimensionLayoutManager.prototype._getRealizedItems = function () {
	                        // abstract
	                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._getRealizedItems");
	                        return null;
	                    };
	                    DimensionLayoutManager.prototype.getRealizedItemsCount = function () {
	                        var realizedItems = this._getRealizedItems();
	                        return realizedItems.length;
	                    };
	                    DimensionLayoutManager.prototype._moveElementsToBottom = function (moveFromIndex, count) {
	                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._moveElementsToBottom");
	                    };
	                    DimensionLayoutManager.prototype._moveElementsToTop = function (moveToIndex, count) {
	                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._moveElementsToTop");
	                    };
	                    DimensionLayoutManager.prototype.isScrollingWithinPage = function () {
	                        return this.getScrollDeltaWithinPage() !== null;
	                    };
	                    DimensionLayoutManager.prototype.getGridContextualWidth = function () {
	                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager.getGridContextualWidth");
	                        return 0;
	                    };
	                    DimensionLayoutManager.prototype.updateScrollbar = function (gridContextualWidth) {
	                        var scrollbar = this.dimension.scrollbar;
	                        scrollbar.viewMin = this.dimension.scrollOffset;
	                        scrollbar.min = 0;
	                        scrollbar.max = this.dimension.getItemsCount();
	                        scrollbar.viewSize = this.getViewSize(gridContextualWidth);
	                        this.dimension.scrollbar.show(this.canScroll(gridContextualWidth));
	                    };
	                    DimensionLayoutManager.prototype.getViewSize = function (gridContextualWidth) {
	                        var count = this.getRealizedItemsCount();
	                        if (count === 0)
	                            return 0;
	                        var startIndex = this._gridOffset;
	                        var sizeInItems = 0;
	                        var sizeInPixels = 0;
	                        var widthToFill = this._contextualWidthToFill;
	                        var scrollableArea = widthToFill - this.getOtherHierarchyContextualHeight();
	                        var error = this.getMeaurementError(gridContextualWidth);
	                        for (var i = startIndex; i < count; i++) {
	                            var visibleRatio = void 0;
	                            if (i === startIndex) {
	                                visibleRatio = this.getVisibleSizeRatio();
	                            }
	                            else
	                                visibleRatio = 1;
	                            var itemContextualWidth = this.getItemContextualWidthWithScrolling(i) * error;
	                            sizeInPixels += itemContextualWidth;
	                            sizeInItems += visibleRatio;
	                            if (powerbi.Double.greaterWithPrecision(sizeInPixels, scrollableArea, DimensionLayoutManager._pixelPrecision)) {
	                                sizeInItems -= ((sizeInPixels - scrollableArea) / itemContextualWidth) * visibleRatio;
	                                break;
	                            }
	                        }
	                        return sizeInItems;
	                    };
	                    DimensionLayoutManager.prototype.isScrollableHeader = function (item, items, index) {
	                        if (index !== 0 || this.dimension.getFractionScrollOffset() === 0) {
	                            return false;
	                        }
	                        var hierarchyNavigator = this.dimension._hierarchyNavigator;
	                        if (hierarchyNavigator.isLeaf(item)) {
	                            return true;
	                        }
	                        var currentItem = item;
	                        var currentItems = items;
	                        do {
	                            currentItems = hierarchyNavigator.getChildren(currentItem);
	                            currentItem = this.dimension.getFirstVisibleItem(hierarchyNavigator.getLevel(currentItem) + 1);
	                            if (currentItem === undefined) {
	                                break;
	                            }
	                            if (!hierarchyNavigator.isLastItem(currentItem, currentItems)) {
	                                return false;
	                            }
	                        } while (!hierarchyNavigator.isLeaf(currentItem));
	                        return true;
	                    };
	                    DimensionLayoutManager.prototype.reachedEnd = function () {
	                        return this.dimension.getIntegerScrollOffset() + (this.getRealizedItemsCount() - this._gridOffset) >= this.dimension.getItemsCount();
	                    };
	                    DimensionLayoutManager.prototype.scrollBackwardToFill = function (gridContextualWidth) {
	                        var newScrollOffset = this.dimension.scrollOffset;
	                        if (this.reachedEnd()) {
	                            var widthToFill = this._contextualWidthToFill - gridContextualWidth;
	                            if (this.dimension.getItemsCount() > 0) {
	                                var averageColumnwidth = gridContextualWidth / (this.getRealizedItemsCount() - this.dimension.getFractionScrollOffset());
	                                newScrollOffset = this.dimension.getValidScrollOffset(Math.floor(this.dimension.scrollOffset - (widthToFill / averageColumnwidth)));
	                            }
	                            this._alignToEnd = !powerbi.Double.equalWithPrecision(newScrollOffset, this.dimension.scrollOffset, DimensionLayoutManager._scrollOffsetPrecision); // this is an aproximate scrolling back, we have to ensure it is aligned to the end of the control
	                        }
	                        return newScrollOffset;
	                    };
	                    DimensionLayoutManager.prototype.getItemContextualWidth = function (index) {
	                        var realizedItems = this._getRealizedItems();
	                        if (index >= realizedItems.length)
	                            return null;
	                        return realizedItems[index].getContextualWidth();
	                    };
	                    DimensionLayoutManager.prototype.getItemContextualWidthWithScrolling = function (index) {
	                        return this.getSizeWithScrolling(this.getItemContextualWidth(index), index);
	                    };
	                    DimensionLayoutManager.prototype.getSizeWithScrolling = function (size, index) {
	                        var ratio;
	                        if (this._gridOffset === index) {
	                            ratio = this.getVisibleSizeRatio();
	                        }
	                        else {
	                            ratio = 1;
	                        }
	                        return size * ratio;
	                    };
	                    DimensionLayoutManager.prototype.getGridContextualWidthFromItems = function () {
	                        var count = this.getRealizedItemsCount();
	                        var contextualWidth = 0;
	                        for (var i = 0; i < count; i++) {
	                            contextualWidth += this.getItemContextualWidthWithScrolling(i);
	                        }
	                        return contextualWidth;
	                    };
	                    DimensionLayoutManager.prototype.getMeaurementError = function (gridContextualWidth) {
	                        return gridContextualWidth / this.getGridContextualWidthFromItems();
	                    };
	                    DimensionLayoutManager.prototype.scrollForwardToAlignEnd = function (gridContextualWidth) {
	                        var newScrollOffset = this.dimension.scrollOffset;
	                        if (this._alignToEnd) {
	                            var withinThreshold = powerbi.Double.equalWithPrecision(gridContextualWidth, this._contextualWidthToFill, DimensionLayoutManager._pixelPrecision);
	                            if (!withinThreshold) {
	                                var count = this.getRealizedItemsCount();
	                                var startIndex = this._gridOffset;
	                                var widthToScroll = gridContextualWidth - this._contextualWidthToFill;
	                                var error = this.getMeaurementError(gridContextualWidth);
	                                for (var i = startIndex; i < count; i++) {
	                                    var itemContextualWidth = this.getItemContextualWidth(i) * error;
	                                    if (powerbi.Double.lessWithPrecision(itemContextualWidth, widthToScroll, DimensionLayoutManager._pixelPrecision)) {
	                                        widthToScroll -= itemContextualWidth;
	                                    }
	                                    else {
	                                        var visibleRatio = startIndex === i ? 1 - this.dimension.getFractionScrollOffset() : 1;
	                                        newScrollOffset = this.dimension.getValidScrollOffset(this.dimension.scrollOffset + (i - startIndex) + (widthToScroll * visibleRatio / itemContextualWidth));
	                                        break;
	                                    }
	                                }
	                            }
	                            this._alignToEnd = !withinThreshold;
	                        }
	                        return newScrollOffset;
	                    };
	                    Object.defineProperty(DimensionLayoutManager.prototype, "dimension", {
	                        get: function () {
	                            debug.assertFail("PureVirtualMethod: DimensionLayoutManager.dimension");
	                            return null;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(DimensionLayoutManager.prototype, "otherLayoutManager", {
	                        get: function () {
	                            return this.dimension.otherDimension.layoutManager;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(DimensionLayoutManager.prototype, "contextualWidthToFill", {
	                        get: function () {
	                            return this._contextualWidthToFill;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    DimensionLayoutManager.prototype.getGridScale = function () {
	                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager.getGridScale");
	                        return 0;
	                    };
	                    Object.defineProperty(DimensionLayoutManager.prototype, "otherScrollbarContextualWidth", {
	                        get: function () {
	                            debug.assertFail("PureVirtualMethod: DimensionLayoutManager.otherScrollbarContextualWidth");
	                            return 0;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    DimensionLayoutManager.prototype.getActualContextualWidth = function (gridContextualWidth) {
	                        if (this._isAutoSized() && !this.canScroll(gridContextualWidth))
	                            return gridContextualWidth;
	                        return this._contextualWidthToFill;
	                    };
	                    DimensionLayoutManager.prototype.canScroll = function (gridContextualWidth) {
	                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager.canScroll");
	                        return false;
	                    };
	                    DimensionLayoutManager.prototype.calculateSizes = function () {
	                        if (this.fixedSizeEnabled) {
	                            this.calculateContextualWidths();
	                            this.calculateSpans();
	                        }
	                    };
	                    DimensionLayoutManager.prototype._calculateSize = function (item) {
	                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._calculateSize");
	                        return null;
	                    };
	                    DimensionLayoutManager.prototype.calculateContextualWidths = function () {
	                        var items = this._getRealizedItems();
	                        var count = items.length;
	                        for (var i = 0; i < count; i++) {
	                            var item = items[i];
	                            if (this.measureEnabled)
	                                item.setAligningContextualWidth(-1);
	                            this._calculateSize(item);
	                        }
	                    };
	                    DimensionLayoutManager.prototype.calculateSpans = function () {
	                        if (this.measureEnabled) {
	                            this.updateNonScrollableItemsSpans();
	                            this.updateScrollableItemsSpans();
	                        }
	                        // TODO override in row layout manager to add footer to calculation, this is required for Matrix
	                    };
	                    DimensionLayoutManager.prototype.updateNonScrollableItemsSpans = function () {
	                        var otherDimensionItems = this.otherLayoutManager._getRealizedItems();
	                        var otherDimensionItemsCount = otherDimensionItems.length;
	                        var startIndex = this.dimension.getDepth();
	                        for (var i = startIndex; i < otherDimensionItemsCount; i++) {
	                            var otherDimensionItem = otherDimensionItems[i];
	                            this.updateSpans(otherDimensionItem, otherDimensionItem.getHeaders(), false);
	                        }
	                    };
	                    DimensionLayoutManager.prototype.updateScrollableItemsSpans = function () {
	                        var otherRealizedItems = this.otherLayoutManager._getRealizedItems();
	                        var otherRealizedItemsCount = Math.min(this.dimension.getDepth(), otherRealizedItems.length);
	                        for (var i = 0; i < otherRealizedItemsCount; i++) {
	                            var otherRealizedItem = otherRealizedItems[i];
	                            this.updateSpans(otherRealizedItem, otherRealizedItem.getOtherDimensionHeaders(), true);
	                        }
	                    };
	                    DimensionLayoutManager.prototype.fixSizes = function () {
	                        if (this.fixedSizeEnabled) {
	                            var items = this._getRealizedItems();
	                            var count = items.length;
	                            for (var i = count - 1; i >= 0; i--) {
	                                items[i].fixSize();
	                            }
	                        }
	                    };
	                    DimensionLayoutManager.prototype.updateSpans = function (otherRealizedItem, cells, considerScrolling) {
	                        var realizedItems = this._getRealizedItems();
	                        var cellCount = cells.length;
	                        for (var j = 0; j < cellCount; j++) {
	                            var cell = cells[j];
	                            var owner = otherRealizedItem.getOtherDimensionOwner(cell);
	                            var span = owner.getCellContextualSpan(cell);
	                            if (span > 1) {
	                                var totalSizeInSpan = 0;
	                                var startIndex = owner.getIndex(this._grid);
	                                for (var k = 0; k < span; k++) {
	                                    var item = realizedItems[k + startIndex];
	                                    var childWidth = item.getContentContextualWidth();
	                                    // Considering scroll offset for first column only, as scroll has not been applied to the cells
	                                    if (considerScrolling && j === 0 && k === 0) {
	                                        childWidth = Math.floor((1 - this.dimension.getFractionScrollOffset()) * childWidth);
	                                    }
	                                    totalSizeInSpan += childWidth;
	                                    if (k === span - 1)
	                                        this.updateLastChildSize(cell, item, totalSizeInSpan);
	                                }
	                            }
	                        }
	                    };
	                    DimensionLayoutManager.prototype.updateLastChildSize = function (spanningCell, item, totalSpanSize) {
	                        var delta = item.getCellIContentContextualWidth(spanningCell) - totalSpanSize;
	                        if (delta > 0)
	                            item.setAligningContextualWidth(Math.max(item.getAligningContextualWidth(), delta + item.getContentContextualWidth()));
	                    };
	                    DimensionLayoutManager._pixelPrecision = 1.0001;
	                    DimensionLayoutManager._scrollOffsetPrecision = 0.01;
	                    return DimensionLayoutManager;
	                }());
	                internal.DimensionLayoutManager = DimensionLayoutManager;
	                var ResizeState = (function () {
	                    function ResizeState(column, width, scale) {
	                        this.column = column;
	                        this.item = column.getLeafItem();
	                        this.itemType = column.itemType;
	                        this.startColumnWidth = width;
	                        this.resizingDelta = 0;
	                        this.animationFrame = null;
	                        this.scale = scale;
	                    }
	                    ResizeState.prototype.getNewSize = function () {
	                        return this.startColumnWidth + this.resizingDelta;
	                    };
	                    return ResizeState;
	                }());
	                internal.ResizeState = ResizeState;
	                var ColumnLayoutManager = (function (_super) {
	                    __extends(ColumnLayoutManager, _super);
	                    function ColumnLayoutManager(owner, grid, realizationManager) {
	                        _super.call(this, owner, grid, realizationManager);
	                        realizationManager.owner = this;
	                        this.fillProportionally = false;
	                        this._resizeState = null;
	                    }
	                    Object.defineProperty(ColumnLayoutManager.prototype, "dimension", {
	                        get: function () {
	                            return this.owner.owner.columnDimension;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    ColumnLayoutManager.prototype.isResizing = function () {
	                        return this._resizeState !== null;
	                    };
	                    Object.defineProperty(ColumnLayoutManager.prototype, "fillProportionally", {
	                        get: function () {
	                            return this._grid.fillColumnsProportionally;
	                        },
	                        set: function (value) {
	                            this._grid.fillColumnsProportionally = value;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    ColumnLayoutManager.prototype.getGridScale = function () {
	                        return this._grid._presenter.getScreenToCssRatioX();
	                    };
	                    Object.defineProperty(ColumnLayoutManager.prototype, "otherScrollbarContextualWidth", {
	                        get: function () {
	                            if (this.dimension.otherDimension.scrollbar.visible) {
	                                return controls.HTMLElementUtils.getElementWidth(this.dimension.otherDimension.scrollbar.element);
	                            }
	                            return 0;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    ColumnLayoutManager.prototype._getRealizedItems = function () {
	                        if (!this._grid.realizedColumns) {
	                            this._grid.realizedColumns = [];
	                        }
	                        return this._grid.realizedColumns;
	                    };
	                    ColumnLayoutManager.prototype._moveElementsToBottom = function (moveFromIndex, count) {
	                        this._grid.moveColumnsToEnd(moveFromIndex, count);
	                    };
	                    ColumnLayoutManager.prototype._moveElementsToTop = function (moveToIndex, count) {
	                        this._grid.moveColumnsToStart(moveToIndex, count);
	                    };
	                    ColumnLayoutManager.prototype._requiresMeasure = function () {
	                        // if the control is not scrolling in either dimension or is scrolling or is resizing
	                        return (!this.isScrolling() && !this.otherLayoutManager.isScrolling()) || this.isScrolling() || this.isResizing();
	                    };
	                    ColumnLayoutManager.prototype.getGridContextualWidth = function () {
	                        return this._grid.getWidth();
	                    };
	                    ColumnLayoutManager.prototype.getFirstVisibleColumn = function () {
	                        return this._grid.realizedColumns[this._gridOffset];
	                    };
	                    ColumnLayoutManager.prototype._isAutoSized = function () {
	                        return this.owner.owner.autoSizeWidth;
	                    };
	                    ColumnLayoutManager.prototype.applyScrolling = function () {
	                        var columnOffset = this.dimension.getFractionScrollOffset();
	                        var firstVisibleColumnWidth = 0;
	                        if (columnOffset !== 0) {
	                            var firstVisibleColumn = this.getFirstVisibleColumn();
	                            if (firstVisibleColumn !== undefined) {
	                                firstVisibleColumnWidth = firstVisibleColumn.getContextualWidth();
	                                // Ceiling the offset because setting a fraction Width on the TD will ceil it
	                                // We need to let the TD and the OuterDiv to align in order for Borders to touch
	                                var offsetInPixels = Math.ceil(-firstVisibleColumnWidth * columnOffset);
	                                this.scroll(firstVisibleColumn, firstVisibleColumnWidth, offsetInPixels);
	                            }
	                        }
	                    };
	                    ColumnLayoutManager.prototype.scroll = function (firstVisibleColumn, width, offset) {
	                        this.scrollCells(firstVisibleColumn._realizedColumnHeaders, width, offset);
	                        this.scrollBodyCells(this._grid.realizedRows, width, offset);
	                        if (firstVisibleColumn.footer !== null) {
	                            firstVisibleColumn.footer.scrollHorizontally(width, offset);
	                        }
	                    };
	                    ColumnLayoutManager.prototype.scrollCells = function (cells, width, offset) {
	                        var length = cells.length;
	                        for (var i = 0; i < length; i++) {
	                            cells[i].scrollHorizontally(width, offset);
	                        }
	                    };
	                    ColumnLayoutManager.prototype.scrollBodyCells = function (rows, width, offset) {
	                        var length = rows.length;
	                        var cells;
	                        var cell;
	                        for (var i = 0; i < length; i++) {
	                            cells = rows[i]._realizedBodyCells;
	                            if (cells !== undefined) {
	                                cell = cells[0];
	                                if (cell !== undefined) {
	                                    cell.scrollHorizontally(width, offset);
	                                }
	                            }
	                        }
	                    };
	                    ColumnLayoutManager.prototype.onStartResize = function (cell, currentX, currentY) {
	                        this._resizeState = new ResizeState(cell._column, cell._column.getContentContextualWidth(), controls.HTMLElementUtils.getAccumulatedScale(this.owner.owner.container));
	                    };
	                    ColumnLayoutManager.prototype.onResize = function (cell, deltaX, deltaY) {
	                        var _this = this;
	                        if (this.isResizing()) {
	                            this._resizeState.resizingDelta = Math.round(Math.max(deltaX / this._resizeState.scale, ColumnLayoutManager.minColumnWidth - this._resizeState.startColumnWidth));
	                            if (this._resizeState.animationFrame === null)
	                                this._resizeState.animationFrame = requestAnimationFrame(function () { return _this.performResizing(); });
	                        }
	                    };
	                    ColumnLayoutManager.prototype.onEndResize = function (cell) {
	                        if (this.isResizing() && this._resizeState.animationFrame !== null) {
	                            this.performResizing(); // if we reached the end and we are still waiting for the last animation frame, perform the pending resizing and clear the state 
	                        }
	                        this.endResizing();
	                        this._resizeState = null;
	                    };
	                    ColumnLayoutManager.prototype.onReset = function (cell) {
	                        this._resizeState = new ResizeState(cell._column, -1, 1);
	                        cell._column.clearSize();
	                        this.endResizing();
	                        this.owner.owner.refresh(false);
	                        this._resizeState = null;
	                    };
	                    ColumnLayoutManager.prototype.updateItemToResizeState = function (realizedColumns) {
	                        if (this._resizeState === null)
	                            return;
	                        var columnCount = realizedColumns.length;
	                        var hierarchyNavigator = this.owner.owner.hierarchyNavigator;
	                        // Only iterate over the columns that belong to column hierachy (i.e. skip the row hierarchy rows)
	                        // as this post-rendering adjustment only applies to them.
	                        var startIndex = this.otherLayoutManager.dimension.getDepth();
	                        for (var i = startIndex; i < columnCount; i++) {
	                            var column = realizedColumns[i];
	                            if (!column.columnHeaderOrCornerEquals(this._resizeState.itemType, this._resizeState.item, column.itemType, column.getLeafItem(), hierarchyNavigator))
	                                continue;
	                            if (column !== this._resizeState.column) {
	                                this._resizeState.column = column;
	                                column.onResize(this._resizeState.getNewSize());
	                                break;
	                            }
	                        }
	                    };
	                    ColumnLayoutManager.prototype.performResizing = function () {
	                        if (this._resizeState === null)
	                            return;
	                        this._resizeState.animationFrame = null;
	                        var newSize = this._resizeState.getNewSize();
	                        this._resizeState.column.onResize(newSize);
	                        this.owner.owner.refresh(false);
	                    };
	                    ColumnLayoutManager.prototype.endResizing = function () {
	                        if (this._resizeState === null)
	                            return;
	                        var newSize = this._resizeState.getNewSize();
	                        this._resizeState.column.onResizeEnd(newSize);
	                    };
	                    /**
	                     * Sends column related data (pixel size, column count, etc) to TablixControl.
	                     */
	                    ColumnLayoutManager.prototype._sendDimensionsToControl = function () {
	                        var gridContextualWidth = this.getGridContextualWidth();
	                        var widthToFill = this.getActualContextualWidth(gridContextualWidth);
	                        var otherContextualHeight = this.getOtherHierarchyContextualHeight();
	                        var scale = this.getGridScale(); // in case of canvas we have to convert the size from device pixel to css pixel
	                        this.owner.owner.updateColumnDimensions(otherContextualHeight / scale, (widthToFill - otherContextualHeight) / scale, this.getViewSize(gridContextualWidth));
	                    };
	                    ColumnLayoutManager.prototype.getEstimatedHeaderWidth = function (label, headerIndex) {
	                        debug.assertFail("PureVirtualMethod: ColumnLayoutManager.getEstimatedHeaderWidth");
	                        return -1;
	                    };
	                    ColumnLayoutManager.prototype.getEstimatedBodyCellWidth = function (content) {
	                        debug.assertFail("PureVirtualMethod: ColumnLayoutManager.getEstimatedBodyCellWidth");
	                        return -1;
	                    };
	                    ColumnLayoutManager.minColumnWidth = 10;
	                    return ColumnLayoutManager;
	                }(DimensionLayoutManager));
	                internal.ColumnLayoutManager = ColumnLayoutManager;
	                var DashboardColumnLayoutManager = (function (_super) {
	                    __extends(DashboardColumnLayoutManager, _super);
	                    function DashboardColumnLayoutManager() {
	                        _super.apply(this, arguments);
	                    }
	                    DashboardColumnLayoutManager.prototype.getEstimatedHeaderWidth = function (label, headerIndex) {
	                        if (this.ignoreColumn(headerIndex))
	                            return 0;
	                        // for dashboard layout it does not matter whether we pass an actual cell or not
	                        return this.owner.getCellWidth(undefined);
	                    };
	                    DashboardColumnLayoutManager.prototype.getEstimatedBodyCellWidth = function (content) {
	                        // for dashboard layout it does not matter whether we pass an actual cell or not
	                        return this.owner.getCellWidth(undefined);
	                    };
	                    DashboardColumnLayoutManager.prototype.canScroll = function (gridContextualWidth) {
	                        return false;
	                    };
	                    DashboardColumnLayoutManager.prototype._calculateSize = function (item) {
	                        var headerIndex = item.getIndex(this._grid);
	                        var computedSize = 0;
	                        if (!this.ignoreColumn(headerIndex)) {
	                            // for dashboard layout it does not matter whether we pass an actual cell or not
	                            computedSize = this.owner.getContentWidth(undefined);
	                        }
	                        item.onResize(computedSize);
	                        item.onResizeEnd(computedSize);
	                        return computedSize;
	                    };
	                    DashboardColumnLayoutManager.prototype.ignoreColumn = function (headerIndex) {
	                        // On the dashboard, we need to return 0 if the row header is static
	                        // (a table or a matrix without row groups)
	                        return headerIndex === 0 && !this.owner.binder.hasRowGroups();
	                    };
	                    return DashboardColumnLayoutManager;
	                }(ColumnLayoutManager));
	                internal.DashboardColumnLayoutManager = DashboardColumnLayoutManager;
	                var CanvasColumnLayoutManager = (function (_super) {
	                    __extends(CanvasColumnLayoutManager, _super);
	                    function CanvasColumnLayoutManager() {
	                        _super.apply(this, arguments);
	                    }
	                    CanvasColumnLayoutManager.prototype.getEstimatedHeaderWidth = function (label, headerIndex) {
	                        // On the canvas the header width depends on the size of the content
	                        return this.owner.getEstimatedTextWidth(label);
	                    };
	                    CanvasColumnLayoutManager.prototype.getEstimatedBodyCellWidth = function (content) {
	                        return this.owner.getEstimatedTextWidth(content);
	                    };
	                    CanvasColumnLayoutManager.prototype.calculateContextualWidths = function () {
	                        var items = this._getRealizedItems();
	                        var columnWidths = [];
	                        for (var i = 0, len = items.length; i < len; i++) {
	                            var item = items[i];
	                            if (this.measureEnabled)
	                                item.setAligningContextualWidth(-1);
	                            var queryName = controls.TablixColumnWidthManager.getColumnQueryName(item);
	                            if (queryName != null) {
	                                columnWidths.push({
	                                    queryName: queryName,
	                                    width: this._calculateSize(item),
	                                    isFixed: false // Unused
	                                });
	                            }
	                        }
	                        // Save all column widths. Needed when user turns off auto-sizing for column widths.
	                        this.owner.columnWidthsToPersist = columnWidths;
	                    };
	                    CanvasColumnLayoutManager.prototype.canScroll = function (gridContextualWidth) {
	                        return !powerbi.Double.equalWithPrecision(this.dimension.scrollOffset, 0, DimensionLayoutManager._scrollOffsetPrecision) ||
	                            (((this.getRealizedItemsCount() - this._gridOffset) < this.dimension.getItemsCount()) && this._contextualWidthToFill > 0) ||
	                            powerbi.Double.greaterWithPrecision(gridContextualWidth, this._contextualWidthToFill, DimensionLayoutManager._pixelPrecision);
	                    };
	                    CanvasColumnLayoutManager.prototype._calculateSize = function (item) {
	                        return item.calculateSize();
	                    };
	                    return CanvasColumnLayoutManager;
	                }(ColumnLayoutManager));
	                internal.CanvasColumnLayoutManager = CanvasColumnLayoutManager;
	                var RowLayoutManager = (function (_super) {
	                    __extends(RowLayoutManager, _super);
	                    function RowLayoutManager(owner, grid, realizationManager) {
	                        _super.call(this, owner, grid, realizationManager);
	                        realizationManager.owner = this;
	                    }
	                    Object.defineProperty(RowLayoutManager.prototype, "dimension", {
	                        get: function () {
	                            return this.owner.owner.rowDimension;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    RowLayoutManager.prototype.getGridScale = function () {
	                        return this._grid._presenter.getScreenToCssRatioY();
	                    };
	                    Object.defineProperty(RowLayoutManager.prototype, "otherScrollbarContextualWidth", {
	                        get: function () {
	                            if (this.dimension.otherDimension.scrollbar.visible) {
	                                return controls.HTMLElementUtils.getElementHeight(this.dimension.otherDimension.scrollbar.element);
	                            }
	                            return 0;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    RowLayoutManager.prototype.startScrollingSession = function () {
	                        _super.prototype.startScrollingSession.call(this);
	                    };
	                    RowLayoutManager.prototype._getRealizedItems = function () {
	                        if (!this._grid.realizedRows) {
	                            this._grid.realizedRows = [];
	                        }
	                        return this._grid.realizedRows;
	                    };
	                    RowLayoutManager.prototype._moveElementsToBottom = function (moveFromIndex, count) {
	                        this._grid.moveRowsToEnd(moveFromIndex, count);
	                    };
	                    RowLayoutManager.prototype._moveElementsToTop = function (moveToIndex, count) {
	                        this._grid.moveRowsToStart(moveToIndex, count);
	                    };
	                    RowLayoutManager.prototype._requiresMeasure = function () {
	                        // if the control is not scrolling in either dimension and the column dimension is not resizing or row dimension is scrolling and reaching the end while scrolling 
	                        return (!this.isScrolling() && !this.otherLayoutManager.isScrolling() && !this.otherLayoutManager.isResizing())
	                            || (this.isScrolling() && (this.dimension.getIntegerScrollOffset() + (this.getRealizedItemsCount() - this._gridOffset) >= this.dimension.getItemsCount()));
	                    };
	                    RowLayoutManager.prototype.getGridContextualWidth = function () {
	                        return this._grid.getHeight();
	                    };
	                    RowLayoutManager.prototype.getFirstVisibleRow = function () {
	                        return this._grid.realizedRows[this._gridOffset];
	                    };
	                    RowLayoutManager.prototype._isAutoSized = function () {
	                        return this.owner.owner.autoSizeHeight;
	                    };
	                    RowLayoutManager.prototype.applyScrolling = function () {
	                        var rowOffset = this.dimension.getFractionScrollOffset();
	                        var firstVisibleRowHeight = 0;
	                        if (rowOffset !== 0) {
	                            var firstVisibleRow = this.getFirstVisibleRow();
	                            if (firstVisibleRow) {
	                                firstVisibleRowHeight = firstVisibleRow.getContextualWidth();
	                                this.scroll(firstVisibleRow, firstVisibleRowHeight, rowOffset);
	                            }
	                        }
	                    };
	                    RowLayoutManager.prototype.scroll = function (firstVisibleRow, height, offset) {
	                        this.scrollCells(firstVisibleRow._realizedRowHeaders, height, offset);
	                        this.scrollCells(firstVisibleRow._realizedBodyCells, height, offset);
	                    };
	                    RowLayoutManager.prototype.scrollCells = function (cells, height, offset) {
	                        var length = cells.length;
	                        for (var i = 0; i < length; i++) {
	                            cells[i].scrollVertically(height, offset);
	                        }
	                    };
	                    RowLayoutManager.prototype.getFooterContextualWidth = function () {
	                        if (this.owner.owner.rowDimension.hasFooter()) {
	                            if (this.owner.grid.footerRow) {
	                                return this.owner.grid.footerRow.getContextualWidth();
	                            }
	                        }
	                        return 0;
	                    };
	                    RowLayoutManager.prototype.calculateContextualWidths = function () {
	                        _super.prototype.calculateContextualWidths.call(this);
	                        if (this.fixedSizeEnabled) {
	                            var footerRow = this._grid.footerRow;
	                            if (footerRow) {
	                                this._calculateSize(footerRow);
	                            }
	                        }
	                    };
	                    RowLayoutManager.prototype.fixSizes = function () {
	                        _super.prototype.fixSizes.call(this);
	                        if (this.fixedSizeEnabled) {
	                            if (this._grid.footerRow) {
	                                this._grid.footerRow.fixSize();
	                            }
	                        }
	                    };
	                    /**
	                     * Sends row related data (pixel size, column count, etc) to TablixControl.
	                     */
	                    RowLayoutManager.prototype._sendDimensionsToControl = function () {
	                        var gridContextualWidth = this.getGridContextualWidth();
	                        var widthToFill = this.getActualContextualWidth(gridContextualWidth);
	                        var otherContextualHeight = this.getOtherHierarchyContextualHeight();
	                        var scale = this.getGridScale();
	                        this.owner.owner.updateRowDimensions(otherContextualHeight / scale, (widthToFill - otherContextualHeight) / scale, gridContextualWidth / scale, this.getViewSize(gridContextualWidth), (this._grid.footerRow ? this._grid.footerRow.getContextualWidth() / scale : 0));
	                    };
	                    RowLayoutManager.prototype.getEstimatedHeaderWidth = function (label, headerIndex) {
	                        debug.assertFail("PureVirtualMethod: RowLayoutManager.getEstimatedHeaderWidth");
	                        return -1;
	                    };
	                    return RowLayoutManager;
	                }(DimensionLayoutManager));
	                internal.RowLayoutManager = RowLayoutManager;
	                var DashboardRowLayoutManager = (function (_super) {
	                    __extends(DashboardRowLayoutManager, _super);
	                    function DashboardRowLayoutManager() {
	                        _super.apply(this, arguments);
	                    }
	                    DashboardRowLayoutManager.prototype.getEstimatedHeaderWidth = function (label, headerIndex) {
	                        return this.getHeaderWidth(headerIndex);
	                    };
	                    DashboardRowLayoutManager.prototype.canScroll = function (gridContextualWidth) {
	                        return false;
	                    };
	                    DashboardRowLayoutManager.prototype._calculateSize = function (item) {
	                        return item.calculateSize();
	                    };
	                    DashboardRowLayoutManager.prototype.getHeaderWidth = function (headerIndex) {
	                        // On the dashboard, we need to return 0 if the row header is static
	                        // (a table or a matrix without row groups)
	                        if (headerIndex === 0 && !this.owner.binder.hasRowGroups())
	                            return 0;
	                        // for dashboard layout it does not matter whether we pass an actual text or not
	                        return this.owner.getEstimatedTextWidth(undefined);
	                    };
	                    return DashboardRowLayoutManager;
	                }(RowLayoutManager));
	                internal.DashboardRowLayoutManager = DashboardRowLayoutManager;
	                var CanvasRowLayoutManager = (function (_super) {
	                    __extends(CanvasRowLayoutManager, _super);
	                    function CanvasRowLayoutManager() {
	                        _super.apply(this, arguments);
	                    }
	                    CanvasRowLayoutManager.prototype.getEstimatedHeaderWidth = function (label, headerIndex) {
	                        // On the canvas the header width depends on the size of the content
	                        return this.owner.getEstimatedTextWidth(label);
	                    };
	                    CanvasRowLayoutManager.prototype.canScroll = function (gridContextualWidth) {
	                        return !powerbi.Double.equalWithPrecision(this.dimension.scrollOffset, 0, DimensionLayoutManager._scrollOffsetPrecision) ||
	                            (((this.getRealizedItemsCount() - this._gridOffset) < this.dimension.getItemsCount()) && this._contextualWidthToFill > 0) ||
	                            powerbi.Double.greaterWithPrecision(gridContextualWidth, this._contextualWidthToFill, DimensionLayoutManager._pixelPrecision);
	                    };
	                    CanvasRowLayoutManager.prototype._calculateSize = function (item) {
	                        return item.calculateSize();
	                    };
	                    return CanvasRowLayoutManager;
	                }(RowLayoutManager));
	                internal.CanvasRowLayoutManager = CanvasRowLayoutManager;
	                var TablixLayoutManager = (function () {
	                    function TablixLayoutManager(binder, grid, columnLayoutManager, rowLayoutManager) {
	                        this._allowHeaderResize = true;
	                        this._binder = binder;
	                        this._grid = grid;
	                        this._columnLayoutManager = columnLayoutManager;
	                        this._rowLayoutManager = rowLayoutManager;
	                        this._columnWidthsToPersist = [];
	                    }
	                    TablixLayoutManager.prototype.initialize = function (owner) {
	                        this._owner = owner;
	                        this._container = owner.container;
	                        this._gridHost = owner.contentHost;
	                        this._footersHost = owner.footerHost;
	                        this._grid.initialize(owner, this._gridHost, this._footersHost);
	                    };
	                    Object.defineProperty(TablixLayoutManager.prototype, "owner", {
	                        get: function () {
	                            return this._owner;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(TablixLayoutManager.prototype, "binder", {
	                        get: function () {
	                            return this._binder;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(TablixLayoutManager.prototype, "columnWidthsToPersist", {
	                        get: function () {
	                            return this._columnWidthsToPersist;
	                        },
	                        set: function (columnWidths) {
	                            this._columnWidthsToPersist = columnWidths;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    TablixLayoutManager.prototype.getTablixClassName = function () {
	                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getTablixClassName");
	                        return null;
	                    };
	                    TablixLayoutManager.prototype.getLayoutKind = function () {
	                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getLayoutKind");
	                        // TODO ckerer: this method should not be necessary when we are done refactoring!
	                        return null;
	                    };
	                    TablixLayoutManager.prototype.getOrCreateColumnHeader = function (item, items, rowIndex, columnIndex) {
	                        var hierarchyNav = this.owner.hierarchyNavigator;
	                        var row = this._grid.getOrCreateRow(rowIndex);
	                        var column = this._grid.getOrCreateColumn(columnIndex + this._columnLayoutManager._gridOffset);
	                        var isLeaf = hierarchyNav.isLeaf(item);
	                        var cell = row.getOrCreateColumnHeader(column, this._columnLayoutManager.isScrollableHeader(item, items, columnIndex), isLeaf);
	                        var rowIdx = hierarchyNav.getLevel(item);
	                        cell.position.row.index = cell.position.row.indexInSiblings = rowIdx;
	                        cell.position.row.isFirst = rowIdx === 0;
	                        cell.position.row.isLast = isLeaf;
	                        var colIdx = hierarchyNav.getIndex(item);
	                        cell.position.column.index = cell.position.row.indexInSiblings = colIdx;
	                        cell.position.column.isFirst = hierarchyNav.areAllParentsFirst(item, items);
	                        cell.position.column.isLast = hierarchyNav.areAllParentsLast(item, items);
	                        this.enableCellHorizontalResize(isLeaf, cell);
	                        return cell;
	                    };
	                    TablixLayoutManager.prototype.getOrCreateRowHeader = function (item, items, rowIndex, columnIndex) {
	                        var hierarchyNav = this.owner.hierarchyNavigator;
	                        var row = this._grid.getOrCreateRow(rowIndex + this._rowLayoutManager._gridOffset);
	                        var column = this._grid.getOrCreateColumn(columnIndex);
	                        var isLeaf = hierarchyNav.isLeaf(item);
	                        var scrollable = this._rowLayoutManager.isScrollableHeader(item, items, rowIndex);
	                        if (row.getRealizedCellCount() === 0) {
	                            this.alignRowHeaderCells(item, row);
	                        }
	                        var cell = row.getOrCreateRowHeader(column, scrollable, hierarchyNav.isLeaf(item));
	                        var rowIdx = hierarchyNav.getIndex(item);
	                        cell.position.row.index = cell.position.row.indexInSiblings = rowIdx;
	                        cell.position.row.isFirst = hierarchyNav.areAllParentsFirst(item, items);
	                        cell.position.row.isLast = hierarchyNav.areAllParentsLast(item, items);
	                        var colIdx = hierarchyNav.getLevel(item);
	                        cell.position.column.index = cell.position.column.indexInSiblings = colIdx;
	                        cell.position.column.isFirst = colIdx === 0;
	                        cell.position.column.isLast = isLeaf;
	                        cell.enableHorizontalResize(false, this._columnLayoutManager);
	                        return cell;
	                    };
	                    TablixLayoutManager.prototype.getOrCreateCornerCell = function (item, rowLevel, columnLevel) {
	                        var row = this._grid.getOrCreateRow(columnLevel);
	                        var column = this._grid.getOrCreateColumn(rowLevel);
	                        var columnDepth = this._columnLayoutManager.dimension.getDepth();
	                        var isLeaf = columnLevel === (columnDepth - 1);
	                        var cell = row.getOrCreateCornerCell(column);
	                        var rowIdx = columnLevel;
	                        cell.position.row.index = cell.position.row.indexInSiblings = rowIdx;
	                        cell.position.row.isFirst = rowIdx === 0;
	                        cell.position.row.isLast = isLeaf;
	                        var colIdx = rowLevel;
	                        cell.position.column.index = cell.position.column.indexInSiblings = colIdx;
	                        cell.position.column.isFirst = colIdx === 0;
	                        cell.position.column.isLast = colIdx === this._rowLayoutManager.dimension.getDepth() - 1;
	                        this.enableCellHorizontalResize(isLeaf, cell);
	                        return cell;
	                    };
	                    TablixLayoutManager.prototype.getOrCreateBodyCell = function (cellItem, rowItem, rowItems, rowIndex, columnIndex) {
	                        var scrollable;
	                        var row = this._grid.getOrCreateRow(rowIndex + this._rowLayoutManager._gridOffset);
	                        var column = this._grid.getOrCreateColumn(columnIndex + this._columnLayoutManager._gridOffset);
	                        if (row._realizedBodyCells.length === 0 && this._owner.columnDimension.getFractionScrollOffset() !== 0) {
	                            scrollable = true;
	                        }
	                        else {
	                            scrollable = this._rowLayoutManager.isScrollableHeader(rowItem, rowItems, rowIndex);
	                        }
	                        var cell = row.getOrCreateBodyCell(column, scrollable);
	                        cell.position = cellItem.position;
	                        cell.enableHorizontalResize(false, this._columnLayoutManager);
	                        return cell;
	                    };
	                    TablixLayoutManager.prototype.getOrCreateFooterBodyCell = function (cellItem, columnIndex) {
	                        var scrollable;
	                        var row = this._grid.getOrCreateFootersRow();
	                        var column = this._grid.getOrCreateColumn(columnIndex + this._columnLayoutManager._gridOffset);
	                        scrollable = (row._realizedBodyCells.length === 0 && this._owner.columnDimension.getFractionScrollOffset() !== 0);
	                        var cell = row.getOrCreateFooterBodyCell(column, scrollable);
	                        cell.position = cellItem.position;
	                        cell.enableHorizontalResize(false, this._columnLayoutManager);
	                        return cell;
	                    };
	                    TablixLayoutManager.prototype.getOrCreateFooterRowHeader = function (item, items) {
	                        var row = this._grid.getOrCreateFootersRow();
	                        var column = this._grid.getOrCreateColumn(0);
	                        //debug.assert(this.owner.hierarchyNavigator.isLeaf(item), "Leaf item expected");
	                        var cell = row.getOrCreateFooterRowHeader(column);
	                        cell.position = undefined;
	                        cell.enableHorizontalResize(false, this._columnLayoutManager);
	                        return cell;
	                    };
	                    TablixLayoutManager.prototype.getVisibleWidth = function () {
	                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getVisibleWidth");
	                        return -1;
	                    };
	                    TablixLayoutManager.prototype.getVisibleHeight = function () {
	                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getVisibleHeight");
	                        return -1;
	                    };
	                    TablixLayoutManager.prototype.updateColumnCount = function (rowDimension, columnDimension) {
	                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.updateColumnCount");
	                    };
	                    TablixLayoutManager.prototype.updateViewport = function (viewport) {
	                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.updateViewport");
	                    };
	                    TablixLayoutManager.prototype.getEstimatedRowHeight = function () {
	                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getEstimatedRowHeight");
	                        return -1;
	                    };
	                    TablixLayoutManager.prototype.getCellWidth = function (cell) {
	                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getCellWidth");
	                        return -1;
	                    };
	                    TablixLayoutManager.prototype.getContentWidth = function (cell) {
	                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getContentWidth");
	                        return -1;
	                    };
	                    TablixLayoutManager.prototype.adjustContentSize = function (hasImage) {
	                        // default implementation has no adjustment
	                    };
	                    /**
	                     * This call makes room for parent header cells where neccessary.
	                     * Since HTML cells that span vertically displace other rows,
	                     * room has to be made for spanning headers that leave an exiting
	                     * row to enter the new row that it starts from and removed when
	                     * returning to an entering row.
	                     */
	                    TablixLayoutManager.prototype.alignRowHeaderCells = function (item, currentRow) {
	                        var index = currentRow.getRowHeaderLeafIndex();
	                        if (index === -1) {
	                            return;
	                        }
	                        var rowDimension = this._owner.rowDimension;
	                        var leaf = rowDimension.getFirstVisibleChildLeaf(item);
	                        if (!this.owner.hierarchyNavigator.headerItemEquals(leaf, currentRow.getAllocatedCellAt(index).item)) {
	                            return;
	                        }
	                        currentRow.moveCellsBy(this.owner.hierarchyNavigator.getLevel(leaf) - this.owner.hierarchyNavigator.getLevel(item) - index);
	                    };
	                    Object.defineProperty(TablixLayoutManager.prototype, "grid", {
	                        get: function () {
	                            return this._grid;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(TablixLayoutManager.prototype, "rowLayoutManager", {
	                        get: function () {
	                            return this._rowLayoutManager;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(TablixLayoutManager.prototype, "columnLayoutManager", {
	                        get: function () {
	                            return this._columnLayoutManager;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    TablixLayoutManager.prototype.showEmptySpaceHeader = function () {
	                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.showEmptySpaceHeader");
	                        return false;
	                    };
	                    TablixLayoutManager.prototype.onStartRenderingSession = function (scrollingDimension, parentElement, clear) {
	                        if (this.showEmptySpaceHeader()) {
	                            var cell = this._grid.emptySpaceHeaderCell;
	                            if (cell) {
	                                this._binder.unbindEmptySpaceHeaderCell(cell);
	                            }
	                            cell = this._grid.emptySpaceFooterCell;
	                            if (cell) {
	                                this._binder.unbindEmptySpaceFooterCell(cell);
	                            }
	                            this._grid.HideEmptySpaceCells();
	                        }
	                        this._scrollingDimension = scrollingDimension;
	                        if (this._scrollingDimension) {
	                            this._scrollingDimension.layoutManager.startScrollingSession();
	                        }
	                        this._rowLayoutManager.onStartRenderingSession();
	                        this._columnLayoutManager.onStartRenderingSession();
	                        this._grid.onStartRenderingSession(clear);
	                        var measureEnabled = this._columnLayoutManager.measureEnabled || this._rowLayoutManager.measureEnabled;
	                        if (measureEnabled)
	                            this.measureSampleText(parentElement);
	                    };
	                    TablixLayoutManager.prototype.onEndRenderingSession = function () {
	                        this._rowLayoutManager.onEndRenderingSession();
	                        this._columnLayoutManager.onEndRenderingSession();
	                        if (this._scrollingDimension) {
	                            this._scrollingDimension.layoutManager.endScrollingSession();
	                        }
	                        this._scrollingDimension = null;
	                        if (this.showEmptySpaceHeader()) {
	                            var emptySpace = this._columnLayoutManager.contextualWidthToFill - this._columnLayoutManager.getGridContextualWidth();
	                            if (emptySpace > 0) {
	                                this._grid.ShowEmptySpaceCells(this._owner.columnDimension.getDepth(), emptySpace);
	                                var cell = this._grid.emptySpaceHeaderCell;
	                                if (cell) {
	                                    this._binder.bindEmptySpaceHeaderCell(cell);
	                                }
	                                cell = this._grid.emptySpaceFooterCell;
	                                if (cell) {
	                                    this._binder.bindEmptySpaceFooterCell(cell);
	                                }
	                            }
	                        }
	                    };
	                    TablixLayoutManager.prototype.onStartRenderingIteration = function (clear) {
	                        this._rowLayoutManager.onStartRenderingIteration(clear, this.getVisibleHeight());
	                        this._columnLayoutManager.onStartRenderingIteration(clear, this.getVisibleWidth());
	                        this._grid.onStartRenderingIteration();
	                    };
	                    TablixLayoutManager.prototype.onEndRenderingIteration = function () {
	                        this._grid.onEndRenderingIteration();
	                        // ANDREMI: Comment out for static tablix
	                        this._columnLayoutManager.calculateSizes(); // calculate the entire grid first without altering the tree to avoid multiple measure pass invoking
	                        this._rowLayoutManager.calculateSizes();
	                        this._columnLayoutManager.fixSizes(); // now assign the sizes
	                        this._rowLayoutManager.fixSizes();
	                        this._columnLayoutManager.updateItemToResizeState(this._grid.realizedColumns); // if we are in a middle of a resize, the column to resize might have been swaped during the render, restore its resize state
	                        this._columnLayoutManager.applyScrolling();
	                        this._rowLayoutManager.applyScrolling();
	                        this._columnLayoutManager.onEndRenderingIteration();
	                        this._rowLayoutManager.onEndRenderingIteration();
	                        return this._columnLayoutManager.done && this._rowLayoutManager.done;
	                    };
	                    TablixLayoutManager.prototype.onCornerCellRealized = function (item, cell) {
	                        var columnLeaf = this.owner.hierarchyNavigator.isColumnHierarchyLeaf(item);
	                        var rowLeaf = this.owner.hierarchyNavigator.isRowHierarchyLeaf(item);
	                        if (columnLeaf)
	                            cell._column.OnLeafRealized(this._owner.hierarchyNavigator);
	                        this._columnLayoutManager.onCornerCellRealized(item, cell, columnLeaf);
	                        this._rowLayoutManager.onCornerCellRealized(item, cell, rowLeaf);
	                    };
	                    TablixLayoutManager.prototype.onRowHeaderRealized = function (item, cell) {
	                        var hierarchyNavigator = this._owner.hierarchyNavigator;
	                        var leaf = hierarchyNavigator.isLeaf(item);
	                        var tablixCell = cell;
	                        if (tablixCell.colSpan > 1)
	                            tablixCell.setContainerWidth(-1);
	                        this._rowLayoutManager.onHeaderRealized(item, cell, leaf);
	                    };
	                    TablixLayoutManager.prototype.onRowHeaderFooterRealized = function (item, cell) {
	                    };
	                    TablixLayoutManager.prototype.onColumnHeaderRealized = function (item, cell) {
	                        var hierarchyNavigator = this._owner.hierarchyNavigator;
	                        var leaf = hierarchyNavigator.isLeaf(item);
	                        if (leaf)
	                            cell._column.OnLeafRealized(this._owner.hierarchyNavigator);
	                        this._columnLayoutManager.onHeaderRealized(item, cell, leaf);
	                    };
	                    TablixLayoutManager.prototype.onBodyCellRealized = function (item, cell) {
	                    };
	                    TablixLayoutManager.prototype.onBodyCellFooterRealized = function (item, cell) {
	                    };
	                    TablixLayoutManager.prototype.setAllowHeaderResize = function (value) {
	                        this._allowHeaderResize = value;
	                    };
	                    TablixLayoutManager.prototype.enableCellHorizontalResize = function (isLeaf, cell) {
	                        var enableCellHorizontalResize = isLeaf && this._allowHeaderResize;
	                        cell.enableHorizontalResize(enableCellHorizontalResize, this._columnLayoutManager);
	                    };
	                    TablixLayoutManager.prototype.getEstimatedTextWidth = function (label) {
	                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getEstimatedTextWidth");
	                        return -1;
	                    };
	                    TablixLayoutManager.prototype.measureSampleText = function (parentElement) {
	                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.measureSampleText");
	                    };
	                    return TablixLayoutManager;
	                }());
	                internal.TablixLayoutManager = TablixLayoutManager;
	                var DashboardTablixLayoutManager = (function (_super) {
	                    __extends(DashboardTablixLayoutManager, _super);
	                    function DashboardTablixLayoutManager(binder, sizeComputationManager, grid, rowRealizationManager, columnRealizationManager) {
	                        var dashboardColumnLayoutManager = new DashboardColumnLayoutManager(null, grid, columnRealizationManager);
	                        var dashboardRowLayoutManager = new DashboardRowLayoutManager(null, grid, rowRealizationManager);
	                        _super.call(this, binder, grid, dashboardColumnLayoutManager, dashboardRowLayoutManager);
	                        dashboardColumnLayoutManager.owner = this;
	                        dashboardRowLayoutManager.owner = this;
	                        this._sizeComputationManager = sizeComputationManager;
	                    }
	                    DashboardTablixLayoutManager.createLayoutManager = function (binder) {
	                        // computed sizes are shared between layout manager and grid presenter
	                        var sizeComputationManager = new SizeComputationManager();
	                        return new DashboardTablixLayoutManager(binder, sizeComputationManager, new internal.TablixGrid(new internal.DashboardTablixGridPresenter(sizeComputationManager)), new internal.RowRealizationManager(binder), new internal.ColumnRealizationManager(binder));
	                    };
	                    DashboardTablixLayoutManager.prototype.getTablixClassName = function () {
	                        return "tablixDashboard";
	                    };
	                    DashboardTablixLayoutManager.prototype.getLayoutKind = function () {
	                        return 1 /* DashboardTile */;
	                    };
	                    DashboardTablixLayoutManager.prototype.showEmptySpaceHeader = function () {
	                        return false;
	                    };
	                    DashboardTablixLayoutManager.prototype.measureSampleText = function (parentElement) {
	                        var textProperties = powerbi.TextMeasurementService.getSvgMeasurementProperties(parentElement);
	                        this._characterHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties);
	                        this._sizeComputationManager.updateRowHeight(this._characterHeight);
	                        var actualTextSize = PixelConverter.toPoint(parseFloat(textProperties.fontSize));
	                        var scalingFactor = actualTextSize / controls.TablixDefaultTextSize;
	                        this._sizeComputationManager.updateScalingFactor(powerbi.Double.toIncrement(scalingFactor, 0.05));
	                    };
	                    DashboardTablixLayoutManager.prototype.getVisibleWidth = function () {
	                        return this._sizeComputationManager.visibleWidth;
	                    };
	                    DashboardTablixLayoutManager.prototype.getVisibleHeight = function () {
	                        return this._sizeComputationManager.visibleHeight;
	                    };
	                    DashboardTablixLayoutManager.prototype.getCellWidth = function (cell) {
	                        return this._sizeComputationManager.cellWidth;
	                    };
	                    DashboardTablixLayoutManager.prototype.getContentWidth = function (cell) {
	                        return this._sizeComputationManager.contentWidth;
	                    };
	                    DashboardTablixLayoutManager.prototype.getEstimatedTextWidth = function (label) {
	                        // On the dashboard it does not matter what text we render, 
	                        // we always use the same content width
	                        return this._sizeComputationManager.contentWidth;
	                    };
	                    DashboardTablixLayoutManager.prototype.adjustContentSize = function (hasImage) {
	                        this._sizeComputationManager.hasImageContent = hasImage;
	                    };
	                    DashboardTablixLayoutManager.prototype.updateColumnCount = function (rowDimension, columnDimension) {
	                        // The total number of columns is the number (depth) of row groups + the number of (leaf) column group instances
	                        var rowDimensionDepth = rowDimension ? rowDimension.getDepth() : 0;
	                        var columnInstances = columnDimension ? columnDimension.getItemsCount() : 0;
	                        var totalColumnCount = rowDimensionDepth + columnInstances;
	                        // Adjust the column count by the static row header (if any)
	                        if (!this.binder.hasRowGroups())
	                            totalColumnCount--;
	                        this._sizeComputationManager.updateColumnCount(totalColumnCount);
	                    };
	                    DashboardTablixLayoutManager.prototype.updateViewport = function (viewport) {
	                        this._sizeComputationManager.updateViewport(viewport);
	                    };
	                    DashboardTablixLayoutManager.prototype.getEstimatedRowHeight = function () {
	                        return this._characterHeight;
	                    };
	                    return DashboardTablixLayoutManager;
	                }(TablixLayoutManager));
	                internal.DashboardTablixLayoutManager = DashboardTablixLayoutManager;
	                var CanvasTablixLayoutManager = (function (_super) {
	                    __extends(CanvasTablixLayoutManager, _super);
	                    function CanvasTablixLayoutManager(binder, grid, rowRealizationManager, columnRealizationManager) {
	                        var canvasColumnLayoutManager = new CanvasColumnLayoutManager(null, grid, columnRealizationManager);
	                        var canvasRowLayoutManager = new CanvasRowLayoutManager(null, grid, rowRealizationManager);
	                        _super.call(this, binder, grid, canvasColumnLayoutManager, canvasRowLayoutManager);
	                        canvasColumnLayoutManager.owner = this;
	                        canvasRowLayoutManager.owner = this;
	                    }
	                    CanvasTablixLayoutManager.createLayoutManager = function (binder, columnWidthManager) {
	                        return new CanvasTablixLayoutManager(binder, new internal.TablixGrid(new controls.internal.CanvasTablixGridPresenter(columnWidthManager)), new internal.RowRealizationManager(binder), new internal.ColumnRealizationManager(binder));
	                    };
	                    CanvasTablixLayoutManager.prototype.getTablixClassName = function () {
	                        return "tablixCanvas";
	                    };
	                    CanvasTablixLayoutManager.prototype.getLayoutKind = function () {
	                        return 0 /* Canvas */;
	                    };
	                    CanvasTablixLayoutManager.prototype.measureSampleText = function (parentElement) {
	                        // TODO: Use TextMeasurementService once the DOM methods are fixed (they are not working right now)
	                        var textDiv = controls.internal.TablixUtils.createDiv();
	                        textDiv.style.cssFloat = 'left';
	                        textDiv.style.whiteSpace = 'nowrap';
	                        textDiv.style.overflow = 'hidden';
	                        textDiv.style.lineHeight = 'normal';
	                        parentElement.appendChild(textDiv);
	                        var textNode = document.createTextNode("a");
	                        textDiv.appendChild(textNode);
	                        this.characterWidth = controls.HTMLElementUtils.getElementWidth(textDiv);
	                        this.characterHeight = controls.HTMLElementUtils.getElementHeight(textDiv);
	                        textDiv.removeChild(textNode);
	                        parentElement.removeChild(textDiv);
	                    };
	                    CanvasTablixLayoutManager.prototype.showEmptySpaceHeader = function () {
	                        return !this._columnLayoutManager.fillProportionally;
	                    };
	                    CanvasTablixLayoutManager.prototype.getVisibleWidth = function () {
	                        if (this._columnLayoutManager.measureEnabled) {
	                            if (this._owner.autoSizeWidth && this._owner.maxWidth) {
	                                return this._owner.maxWidth;
	                            }
	                            else {
	                                return controls.HTMLElementUtils.getElementWidth(this._container);
	                            }
	                        }
	                        return -1;
	                    };
	                    CanvasTablixLayoutManager.prototype.getVisibleHeight = function () {
	                        if (this._rowLayoutManager.measureEnabled) {
	                            if (this._owner.autoSizeHeight && this._owner.maxHeight) {
	                                return this._owner.maxHeight;
	                            }
	                            else {
	                                return controls.HTMLElementUtils.getElementHeight(this._container);
	                            }
	                        }
	                        return -1;
	                    };
	                    CanvasTablixLayoutManager.prototype.getCellWidth = function (cell) {
	                        return cell.containerWidth;
	                    };
	                    CanvasTablixLayoutManager.prototype.getContentWidth = function (cell) {
	                        return cell.contentWidth;
	                    };
	                    CanvasTablixLayoutManager.prototype.getEstimatedTextWidth = function (text) {
	                        return text ? text.length * this.characterWidth : 0;
	                    };
	                    CanvasTablixLayoutManager.prototype.updateColumnCount = function (rowDimension, columnDimension) {
	                        // We currently only need to update model information when using dashboard layouts
	                    };
	                    CanvasTablixLayoutManager.prototype.updateViewport = function (viewport) {
	                        // We currently only need to update model information when using dashboard layouts
	                    };
	                    CanvasTablixLayoutManager.prototype.getEstimatedRowHeight = function () {
	                        return this.characterHeight;
	                    };
	                    return CanvasTablixLayoutManager;
	                }(TablixLayoutManager));
	                internal.CanvasTablixLayoutManager = CanvasTablixLayoutManager;
	            })(internal = controls.internal || (controls.internal = {}));
	        })(controls = visuals.controls || (visuals.controls = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 240 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../../../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var controls;
	        (function (controls) {
	            var HTMLElementUtils;
	            (function (HTMLElementUtils) {
	                function clearChildren(element) {
	                    if (!element) {
	                        return;
	                    }
	                    while (element.hasChildNodes()) {
	                        element.removeChild(element.firstChild);
	                    }
	                }
	                HTMLElementUtils.clearChildren = clearChildren;
	                function setElementTop(element, top) {
	                    element.style.top = top + "px";
	                }
	                HTMLElementUtils.setElementTop = setElementTop;
	                function setElementLeft(element, left) {
	                    element.style.left = left + "px";
	                }
	                HTMLElementUtils.setElementLeft = setElementLeft;
	                function setElementHeight(element, height) {
	                    if (HTMLElementUtils.isAutoSize(height))
	                        element.style.height = "";
	                    else
	                        element.style.height = height + "px";
	                }
	                HTMLElementUtils.setElementHeight = setElementHeight;
	                function setElementWidth(element, width) {
	                    if (HTMLElementUtils.isAutoSize(width))
	                        element.style.width = "";
	                    else
	                        element.style.width = width + "px";
	                }
	                HTMLElementUtils.setElementWidth = setElementWidth;
	                function getElementWidth(element) {
	                    return element.offsetWidth;
	                }
	                HTMLElementUtils.getElementWidth = getElementWidth;
	                function getElementHeight(element) {
	                    return element.offsetHeight;
	                }
	                HTMLElementUtils.getElementHeight = getElementHeight;
	                function isAutoSize(size) {
	                    return size === -1;
	                }
	                HTMLElementUtils.isAutoSize = isAutoSize;
	                function getAccumulatedScale(element) {
	                    var scale = 1;
	                    while (element) {
	                        scale *= HTMLElementUtils.getScale(element);
	                        element = element.parentElement;
	                    }
	                    return scale;
	                }
	                HTMLElementUtils.getAccumulatedScale = getAccumulatedScale;
	                /**
	                 * Get scale of element, return 1 when not scaled.
	                 */
	                function getScale(element) {
	                    element = $(element);
	                    var str = element.css('-webkit-transform') ||
	                        element.css('-moz-transform') ||
	                        element.css('-ms-transform') ||
	                        element.css('-o-transform') ||
	                        element.css('transform');
	                    return (str && (str.match(/\d*\.\d*/) && Number(str.match(/\d*\.\d*/)[0]) ||
	                        str.match(/\d+/) && Number(str.match(/\d+/)[0]))) || 1;
	                }
	                HTMLElementUtils.getScale = getScale;
	            })(HTMLElementUtils = controls.HTMLElementUtils || (controls.HTMLElementUtils = {}));
	        })(controls = visuals.controls || (visuals.controls = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var controls;
	        (function (controls) {
	            var internal;
	            (function (internal) {
	                var DomFactory = InJs.DomFactory;
	                var DataViewObjectDefinitions = powerbi.data.DataViewObjectDefinitions;
	                var DataViewRoleWildCard = powerbi.data.DataViewRoleWildcard;
	                var TablixObjects;
	                (function (TablixObjects) {
	                    TablixObjects.ObjectGeneral = "general";
	                    TablixObjects.ObjectGrid = "grid";
	                    TablixObjects.ObjectColumnHeaders = "columnHeaders";
	                    TablixObjects.ObjectRowHeaders = "rowHeaders";
	                    TablixObjects.ObjectValues = "values";
	                    TablixObjects.ObjectTotal = "total";
	                    TablixObjects.ObjectSubTotals = "subTotals";
	                    /**
	                     * Represents a DataViewObjects property related to the Tablix
	                     */
	                    var TablixProperty = (function () {
	                        /**
	                         * Creates a new TablixProperty
	                         * @param {string} objectName Object Name
	                         * @param {string} propertyName Property Name
	                         * @param {any} defaultValue Default value of the Property
	                         * @param {ObjectValueGetterFunction} getterFuntion Function used to get the Property value from the Objects
	                         */
	                        function TablixProperty(objectName, propertyName, defaultValue, getterFuntion) {
	                            this.objectName = objectName;
	                            this.propertyName = propertyName;
	                            this.defaultValue = defaultValue;
	                            this.getterFuntion = getterFuntion;
	                        }
	                        /**
	                         * Gets the PropertyIdentifier for the Property
	                         * @returns PropertyIdentifier for the Property
	                         */
	                        TablixProperty.prototype.getPropertyID = function () {
	                            return { objectName: this.objectName, propertyName: this.propertyName };
	                        };
	                        /**
	                         * Gets the value of the Property from the Objects
	                         * @param {DataViewObjects} objects DataView Objects to get the value from
	                         * @param {boolean} useDefault True to fall back to the Default value if the Property is missing from the objects. False to return undefined
	                         * @returns Value of the property
	                         */
	                        TablixProperty.prototype.getValue = function (objects) {
	                            // We use this when we intend to have undefined for missing properties. Useful in letting styles fallback to CSS if not defined
	                            return this.getterFuntion(objects, this.getPropertyID(), this.defaultValue);
	                        };
	                        return TablixProperty;
	                    }());
	                    TablixObjects.TablixProperty = TablixProperty;
	                    // Per Column
	                    TablixObjects.PropColumnFormatString = new TablixProperty(TablixObjects.ObjectGeneral, 'formatString', undefined, powerbi.DataViewObjects.getValue);
	                    // General
	                    TablixObjects.PropGeneralAutoSizeColumns = new TablixProperty(TablixObjects.ObjectGeneral, 'autoSizeColumnWidth', true, powerbi.DataViewObjects.getValue);
	                    TablixObjects.PropGeneralTextSize = new TablixProperty(TablixObjects.ObjectGeneral, 'textSize', 8, powerbi.DataViewObjects.getValue);
	                    TablixObjects.PropGeneralTableTotals = new TablixProperty(TablixObjects.ObjectGeneral, 'totals', true, powerbi.DataViewObjects.getValue);
	                    TablixObjects.PropGeneralMatrixRowSubtotals = new TablixProperty(TablixObjects.ObjectGeneral, 'rowSubtotals', true, powerbi.DataViewObjects.getValue);
	                    TablixObjects.PropGeneralMatrixColumnSubtotals = new TablixProperty(TablixObjects.ObjectGeneral, 'columnSubtotals', true, powerbi.DataViewObjects.getValue);
	                    //Grid
	                    TablixObjects.PropGridVertical = new TablixProperty(TablixObjects.ObjectGrid, 'gridVertical', false, powerbi.DataViewObjects.getValue);
	                    TablixObjects.PropGridVerticalColor = new TablixProperty(TablixObjects.ObjectGrid, 'gridVerticalColor', "#E8E8E8", powerbi.DataViewObjects.getFillColor);
	                    TablixObjects.PropGridVerticalWeight = new TablixProperty(TablixObjects.ObjectGrid, 'gridVerticalWeight', 1, powerbi.DataViewObjects.getValue);
	                    TablixObjects.PropGridHorizontalTable = new TablixProperty(TablixObjects.ObjectGrid, 'gridHorizontal', true, powerbi.DataViewObjects.getValue);
	                    TablixObjects.PropGridHorizontalMatrix = new TablixProperty(TablixObjects.ObjectGrid, 'gridHorizontal', false, powerbi.DataViewObjects.getValue);
	                    TablixObjects.PropGridHorizontalColor = new TablixProperty(TablixObjects.ObjectGrid, 'gridHorizontalColor', "#E8E8E8", powerbi.DataViewObjects.getFillColor);
	                    TablixObjects.PropGridHorizontalWeight = new TablixProperty(TablixObjects.ObjectGrid, 'gridHorizontalWeight', 1, powerbi.DataViewObjects.getValue);
	                    TablixObjects.PropGridRowPadding = new TablixProperty(TablixObjects.ObjectGrid, 'rowPadding', 0, powerbi.DataViewObjects.getValue);
	                    TablixObjects.PropGridOutlineColor = new TablixProperty(TablixObjects.ObjectGrid, 'outlineColor', "#CCC", powerbi.DataViewObjects.getFillColor);
	                    TablixObjects.PropGridOutlineWeight = new TablixProperty(TablixObjects.ObjectGrid, 'outlineWeight', 1, powerbi.DataViewObjects.getValue);
	                    TablixObjects.PropGridImageHeight = new TablixProperty(TablixObjects.ObjectGrid, 'imageHeight', 75, powerbi.DataViewObjects.getValue);
	                    // Column Headers
	                    TablixObjects.PropColumnsFontColor = new TablixProperty(TablixObjects.ObjectColumnHeaders, 'fontColor', "#666", powerbi.DataViewObjects.getFillColor);
	                    TablixObjects.PropColumnsBackColor = new TablixProperty(TablixObjects.ObjectColumnHeaders, 'backColor', undefined, powerbi.DataViewObjects.getFillColor);
	                    TablixObjects.PropColumnsOutline = new TablixProperty(TablixObjects.ObjectColumnHeaders, 'outline', "BottomOnly", powerbi.DataViewObjects.getValue);
	                    // Row Headers
	                    TablixObjects.PropRowsFontColor = new TablixProperty(TablixObjects.ObjectRowHeaders, 'fontColor', "#666", powerbi.DataViewObjects.getFillColor);
	                    TablixObjects.PropRowsBackColor = new TablixProperty(TablixObjects.ObjectRowHeaders, 'backColor', undefined, powerbi.DataViewObjects.getFillColor);
	                    TablixObjects.PropRowsOutline = new TablixProperty(TablixObjects.ObjectRowHeaders, 'outline', "RightOnly", powerbi.DataViewObjects.getValue);
	                    // Values
	                    TablixObjects.PropValuesBackColor = new TablixProperty(TablixObjects.ObjectValues, 'backColor', undefined, powerbi.DataViewObjects.getFillColor);
	                    TablixObjects.PropValuesFontColorPrimary = new TablixProperty(TablixObjects.ObjectValues, 'fontColorPrimary', "#333", powerbi.DataViewObjects.getFillColor);
	                    TablixObjects.PropValuesBackColorPrimary = new TablixProperty(TablixObjects.ObjectValues, 'backColorPrimary', undefined, powerbi.DataViewObjects.getFillColor);
	                    TablixObjects.PropValuesFontColorSecondary = new TablixProperty(TablixObjects.ObjectValues, 'fontColorSecondary', "#333", powerbi.DataViewObjects.getFillColor);
	                    TablixObjects.PropValuesBackColorSecondary = new TablixProperty(TablixObjects.ObjectValues, 'backColorSecondary', undefined, powerbi.DataViewObjects.getFillColor);
	                    TablixObjects.PropValuesOutline = new TablixProperty(TablixObjects.ObjectValues, 'outline', "None", powerbi.DataViewObjects.getValue);
	                    TablixObjects.PropValuesUrlIconProp = new TablixProperty(TablixObjects.ObjectValues, 'urlIcon', false, powerbi.DataViewObjects.getValue);
	                    // Total
	                    TablixObjects.PropTotalFontColor = new TablixProperty(TablixObjects.ObjectTotal, 'fontColor', "#333", powerbi.DataViewObjects.getFillColor);
	                    TablixObjects.PropTotalBackColor = new TablixProperty(TablixObjects.ObjectTotal, 'backColor', undefined, powerbi.DataViewObjects.getFillColor);
	                    TablixObjects.PropTotalOutline = new TablixProperty(TablixObjects.ObjectTotal, 'outline', "TopOnly", powerbi.DataViewObjects.getValue);
	                    // SubTotals
	                    TablixObjects.PropSubTotalsFontColor = new TablixProperty(TablixObjects.ObjectSubTotals, 'fontColor', "#333", powerbi.DataViewObjects.getFillColor);
	                    TablixObjects.PropSubTotalsBackColor = new TablixProperty(TablixObjects.ObjectSubTotals, 'backColor', undefined, powerbi.DataViewObjects.getFillColor);
	                    TablixObjects.PropSubTotalsOutline = new TablixProperty(TablixObjects.ObjectSubTotals, 'outline', "TopOnly", powerbi.DataViewObjects.getValue);
	                    /**
	                     * Get the DataViewObject from the DataView
	                     * @param {DataView} dataview The DataView
	                     * @returns DataViewObjects (dataView.metadata.objects)
	                     */
	                    function getMetadadataObjects(dataview) {
	                        if (dataview && dataview.metadata)
	                            return dataview.metadata.objects;
	                        return null;
	                    }
	                    TablixObjects.getMetadadataObjects = getMetadadataObjects;
	                    function enumerateObjectRepetition(enumeration, dataView, tablixType) {
	                        debug.assertValue(enumeration, 'enumeration should be defined');
	                        debug.assertValue(dataView, "dataView can't be undefined");
	                        // We currently only support Table
	                        if (tablixType !== controls.TablixType.Table)
	                            return;
	                        var columns = getTableColumnMetadata(dataView);
	                        for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {
	                            var column = columns_1[_i];
	                            var repetition = {
	                                selector: {
	                                    data: [DataViewRoleWildCard.fromRoles(['Values'])],
	                                    metadata: column.queryName,
	                                },
	                                objects: (_a = {},
	                                    _a[TablixObjects.ObjectValues] = {
	                                        formattingProperties: [TablixObjects.PropValuesBackColor.propertyName]
	                                    },
	                                    _a
	                                )
	                            };
	                            enumeration.push(repetition);
	                        }
	                        var _a;
	                    }
	                    TablixObjects.enumerateObjectRepetition = enumerateObjectRepetition;
	                    function enumerateObjectInstances(options, enumeration, dataView, tablixType) {
	                        debug.assertValue(dataView, "dataView can't be undefined");
	                        var objects = getMetadadataObjects(dataView);
	                        var totalsShown = true;
	                        if (tablixType === controls.TablixType.Table) {
	                            totalsShown = shouldShowTableTotalsOption(dataView) && shouldShowTableTotals(objects);
	                        }
	                        else {
	                            totalsShown =
	                                (shouldShowColumnSubtotalsOption(dataView) && shouldShowColumnSubtotals(objects)) ||
	                                    (shouldShowRowSubtotalsOption(dataView) && shouldShowRowSubtotals(objects));
	                        }
	                        switch (options.objectName) {
	                            case TablixObjects.ObjectGeneral:
	                                enumerateGeneralOptions(enumeration, objects, tablixType, dataView);
	                                break;
	                            case TablixObjects.ObjectGrid:
	                                enumerateGridOptions(enumeration, objects, tablixType);
	                                break;
	                            case TablixObjects.ObjectColumnHeaders:
	                                enumerateColumnHeadersOptions(enumeration, objects);
	                                break;
	                            case TablixObjects.ObjectRowHeaders:
	                                enumerateRowHeadersOptions(enumeration, objects);
	                                break;
	                            case TablixObjects.ObjectValues:
	                                enumerateValuesOptions(enumeration, objects, tablixType);
	                                break;
	                            case TablixObjects.ObjectTotal:
	                                if (totalsShown)
	                                    enumerateTotalOptions(enumeration, objects);
	                                break;
	                            case TablixObjects.ObjectSubTotals:
	                                if (totalsShown)
	                                    enumerateSubTotalsOptions(enumeration, objects);
	                                break;
	                            default:
	                                break;
	                        }
	                    }
	                    TablixObjects.enumerateObjectInstances = enumerateObjectInstances;
	                    function enumerateGeneralOptions(enumeration, objects, tablixType, dataView) {
	                        var visualObjectinstance = {
	                            selector: null,
	                            objectName: TablixObjects.ObjectGeneral,
	                            properties: {
	                                autoSizeColumnWidth: TablixObjects.PropGeneralAutoSizeColumns.getValue(objects),
	                                textSize: TablixObjects.PropGeneralTextSize.getValue(objects),
	                            }
	                        };
	                        var properties = visualObjectinstance.properties;
	                        // Total and SubTotals
	                        switch (tablixType) {
	                            case controls.TablixType.Table:
	                                if (shouldShowTableTotalsOption(dataView))
	                                    properties[TablixObjects.PropGeneralTableTotals.propertyName] = shouldShowTableTotals(objects);
	                                break;
	                            case controls.TablixType.Matrix:
	                                if (shouldShowRowSubtotalsOption(dataView))
	                                    properties[TablixObjects.PropGeneralMatrixRowSubtotals.propertyName] = shouldShowRowSubtotals(objects);
	                                if (shouldShowColumnSubtotalsOption(dataView))
	                                    properties[TablixObjects.PropGeneralMatrixColumnSubtotals.propertyName] = shouldShowColumnSubtotals(objects);
	                                break;
	                        }
	                        enumeration.pushInstance(visualObjectinstance);
	                    }
	                    TablixObjects.enumerateGeneralOptions = enumerateGeneralOptions;
	                    function enumerateGridOptions(enumeration, objects, tablixType) {
	                        var visualObjectinstance = {
	                            selector: null,
	                            objectName: TablixObjects.ObjectGeneral,
	                            properties: {}
	                        };
	                        var properties = visualObjectinstance.properties;
	                        // Vertical Grid
	                        var verticalGridEnabled = TablixObjects.PropGridVertical.getValue(objects);
	                        properties[TablixObjects.PropGridVertical.propertyName] = verticalGridEnabled;
	                        if (verticalGridEnabled) {
	                            properties[TablixObjects.PropGridVerticalColor.propertyName] = TablixObjects.PropGridVerticalColor.getValue(objects);
	                            properties[TablixObjects.PropGridVerticalWeight.propertyName] = TablixObjects.PropGridVerticalWeight.getValue(objects);
	                        }
	                        // Horizontal Grid
	                        var horizontalGridEnabled = (tablixType === controls.TablixType.Table ? TablixObjects.PropGridHorizontalTable : TablixObjects.PropGridHorizontalMatrix).getValue(objects);
	                        properties[(tablixType === controls.TablixType.Table ? TablixObjects.PropGridHorizontalTable : TablixObjects.PropGridHorizontalMatrix).propertyName] = horizontalGridEnabled;
	                        if (horizontalGridEnabled) {
	                            properties[TablixObjects.PropGridHorizontalColor.propertyName] = TablixObjects.PropGridHorizontalColor.getValue(objects);
	                            properties[TablixObjects.PropGridHorizontalWeight.propertyName] = TablixObjects.PropGridHorizontalWeight.getValue(objects);
	                        }
	                        // Row Padding
	                        properties[TablixObjects.PropGridRowPadding.propertyName] = TablixObjects.PropGridRowPadding.getValue(objects);
	                        // Outline
	                        properties[TablixObjects.PropGridOutlineColor.propertyName] = TablixObjects.PropGridOutlineColor.getValue(objects);
	                        properties[TablixObjects.PropGridOutlineWeight.propertyName] = TablixObjects.PropGridOutlineWeight.getValue(objects);
	                        // Image Height
	                        properties[TablixObjects.PropGridImageHeight.propertyName] = TablixObjects.PropGridImageHeight.getValue(objects);
	                        enumeration.pushInstance(visualObjectinstance);
	                    }
	                    TablixObjects.enumerateGridOptions = enumerateGridOptions;
	                    function enumerateColumnHeadersOptions(enumeration, objects) {
	                        enumeration.pushInstance({
	                            selector: null,
	                            objectName: TablixObjects.ObjectColumnHeaders,
	                            properties: {
	                                fontColor: TablixObjects.PropColumnsFontColor.getValue(objects),
	                                backColor: TablixObjects.PropColumnsBackColor.getValue(objects),
	                                outline: TablixObjects.PropColumnsOutline.getValue(objects),
	                            }
	                        });
	                    }
	                    TablixObjects.enumerateColumnHeadersOptions = enumerateColumnHeadersOptions;
	                    function enumerateRowHeadersOptions(enumeration, objects) {
	                        enumeration.pushInstance({
	                            selector: null,
	                            objectName: TablixObjects.ObjectRowHeaders,
	                            properties: {
	                                fontColor: TablixObjects.PropRowsFontColor.getValue(objects),
	                                backColor: TablixObjects.PropRowsBackColor.getValue(objects),
	                                outline: TablixObjects.PropRowsOutline.getValue(objects),
	                            }
	                        });
	                    }
	                    TablixObjects.enumerateRowHeadersOptions = enumerateRowHeadersOptions;
	                    function enumerateValuesOptions(enumeration, objects, tablixType) {
	                        var instance = {
	                            selector: null,
	                            objectName: TablixObjects.ObjectValues,
	                            properties: {
	                                fontColorPrimary: TablixObjects.PropValuesFontColorPrimary.getValue(objects),
	                                backColorPrimary: TablixObjects.PropValuesBackColorPrimary.getValue(objects),
	                                fontColorSecondary: TablixObjects.PropValuesFontColorSecondary.getValue(objects),
	                                backColorSecondary: TablixObjects.PropValuesBackColorSecondary.getValue(objects),
	                                outline: TablixObjects.PropValuesOutline.getValue(objects),
	                            }
	                        };
	                        if (tablixType === controls.TablixType.Table)
	                            instance.properties[TablixObjects.PropValuesUrlIconProp.propertyName] = TablixObjects.PropValuesUrlIconProp.getValue(objects);
	                        enumeration.pushInstance(instance);
	                    }
	                    TablixObjects.enumerateValuesOptions = enumerateValuesOptions;
	                    function enumerateTotalOptions(enumeration, objects) {
	                        enumeration.pushInstance({
	                            selector: null,
	                            objectName: TablixObjects.ObjectTotal,
	                            properties: {
	                                fontColor: TablixObjects.PropTotalFontColor.getValue(objects),
	                                backColor: TablixObjects.PropTotalBackColor.getValue(objects),
	                                outline: TablixObjects.PropTotalOutline.getValue(objects),
	                            }
	                        });
	                    }
	                    TablixObjects.enumerateTotalOptions = enumerateTotalOptions;
	                    function enumerateSubTotalsOptions(enumeration, objects) {
	                        enumeration.pushInstance({
	                            selector: null,
	                            objectName: TablixObjects.ObjectSubTotals,
	                            properties: {
	                                fontColor: TablixObjects.PropSubTotalsFontColor.getValue(objects),
	                                backColor: TablixObjects.PropSubTotalsBackColor.getValue(objects),
	                            }
	                        });
	                    }
	                    TablixObjects.enumerateSubTotalsOptions = enumerateSubTotalsOptions;
	                    function getTableObjects(dataView) {
	                        var objects = getMetadadataObjects(dataView);
	                        var formattingProperties = {
	                            general: {
	                                autoSizeColumnWidth: TablixObjects.PropGeneralAutoSizeColumns.getValue(objects),
	                                textSize: TablixObjects.PropGeneralTextSize.getValue(objects),
	                                totals: shouldShowTableTotals(objects),
	                            },
	                        };
	                        formattingProperties.grid = {
	                            gridVertical: TablixObjects.PropGridVertical.getValue(objects),
	                            gridVerticalColor: TablixObjects.PropGridVerticalColor.getValue(objects),
	                            gridVerticalWeight: TablixObjects.PropGridVerticalWeight.getValue(objects),
	                            gridHorizontal: TablixObjects.PropGridHorizontalTable.getValue(objects),
	                            gridHorizontalColor: TablixObjects.PropGridHorizontalColor.getValue(objects),
	                            gridHorizontalWeight: TablixObjects.PropGridHorizontalWeight.getValue(objects),
	                            outlineColor: TablixObjects.PropGridOutlineColor.getValue(objects),
	                            outlineWeight: TablixObjects.PropGridOutlineWeight.getValue(objects),
	                            rowPadding: TablixObjects.PropGridRowPadding.getValue(objects),
	                            imageHeight: TablixObjects.PropGridImageHeight.getValue(objects),
	                        };
	                        formattingProperties.columnHeaders = {
	                            fontColor: TablixObjects.PropColumnsFontColor.getValue(objects),
	                            backColor: TablixObjects.PropColumnsBackColor.getValue(objects),
	                            outline: TablixObjects.PropColumnsOutline.getValue(objects),
	                        };
	                        formattingProperties.values = {
	                            fontColorPrimary: TablixObjects.PropValuesFontColorPrimary.getValue(objects),
	                            backColorPrimary: TablixObjects.PropValuesBackColorPrimary.getValue(objects),
	                            fontColorSecondary: TablixObjects.PropValuesFontColorSecondary.getValue(objects),
	                            backColorSecondary: TablixObjects.PropValuesBackColorSecondary.getValue(objects),
	                            outline: TablixObjects.PropValuesOutline.getValue(objects),
	                            urlIcon: TablixObjects.PropValuesUrlIconProp.getValue(objects),
	                        };
	                        formattingProperties.total = {
	                            fontColor: TablixObjects.PropTotalFontColor.getValue(objects),
	                            backColor: TablixObjects.PropTotalBackColor.getValue(objects),
	                            outline: TablixObjects.PropTotalOutline.getValue(objects),
	                        };
	                        return formattingProperties;
	                    }
	                    TablixObjects.getTableObjects = getTableObjects;
	                    function getMatrixObjects(dataView) {
	                        var objects = getMetadadataObjects(dataView);
	                        var formattingProperties = {
	                            general: {
	                                autoSizeColumnWidth: TablixObjects.PropGeneralAutoSizeColumns.getValue(objects),
	                                textSize: TablixObjects.PropGeneralTextSize.getValue(objects),
	                                rowSubtotals: shouldShowRowSubtotals(objects),
	                                columnSubtotals: shouldShowColumnSubtotals(objects),
	                            },
	                        };
	                        formattingProperties.grid = {
	                            gridVertical: TablixObjects.PropGridVertical.getValue(objects),
	                            gridVerticalColor: TablixObjects.PropGridVerticalColor.getValue(objects),
	                            gridVerticalWeight: TablixObjects.PropGridVerticalWeight.getValue(objects),
	                            gridHorizontal: TablixObjects.PropGridHorizontalMatrix.getValue(objects),
	                            gridHorizontalColor: TablixObjects.PropGridHorizontalColor.getValue(objects),
	                            gridHorizontalWeight: TablixObjects.PropGridHorizontalWeight.getValue(objects),
	                            outlineColor: TablixObjects.PropGridOutlineColor.getValue(objects),
	                            outlineWeight: TablixObjects.PropGridOutlineWeight.getValue(objects),
	                            rowPadding: TablixObjects.PropGridRowPadding.getValue(objects),
	                            imageHeight: TablixObjects.PropGridImageHeight.getValue(objects),
	                        };
	                        formattingProperties.columnHeaders = {
	                            fontColor: TablixObjects.PropColumnsFontColor.getValue(objects),
	                            backColor: TablixObjects.PropColumnsBackColor.getValue(objects),
	                            outline: TablixObjects.PropColumnsOutline.getValue(objects),
	                        };
	                        formattingProperties.rowHeaders = {
	                            fontColor: TablixObjects.PropRowsFontColor.getValue(objects),
	                            backColor: TablixObjects.PropRowsBackColor.getValue(objects),
	                            outline: TablixObjects.PropRowsOutline.getValue(objects),
	                        };
	                        formattingProperties.values = {
	                            fontColorPrimary: TablixObjects.PropValuesFontColorPrimary.getValue(objects),
	                            backColorPrimary: TablixObjects.PropValuesBackColorPrimary.getValue(objects),
	                            fontColorSecondary: TablixObjects.PropValuesFontColorSecondary.getValue(objects),
	                            backColorSecondary: TablixObjects.PropValuesBackColorSecondary.getValue(objects),
	                            outline: TablixObjects.PropValuesOutline.getValue(objects),
	                        };
	                        formattingProperties.subtotals = {
	                            fontColor: TablixObjects.PropSubTotalsFontColor.getValue(objects),
	                            backColor: TablixObjects.PropSubTotalsBackColor.getValue(objects),
	                            outline: TablixObjects.PropSubTotalsOutline.getValue(objects),
	                        };
	                        return formattingProperties;
	                    }
	                    TablixObjects.getMatrixObjects = getMatrixObjects;
	                    /**
	                     * Generate default objects for the Table/Matrix to set default styling
	                     * @param {TablixType} tablixType Tablix Type: table | matrix
	                     * @returns DataViewObjects that can be attached to the DataViewMetadata
	                     */
	                    function generateTablixDefaultObjects(tablixType) {
	                        return {
	                            general: [{
	                                    selector: null,
	                                    properties: {
	                                        textSize: DataViewObjectDefinitions.encodePropertyValue(12, { numeric: true }),
	                                        totals: DataViewObjectDefinitions.encodePropertyValue(false, { bool: true }),
	                                    }
	                                }],
	                        };
	                    }
	                    TablixObjects.generateTablixDefaultObjects = generateTablixDefaultObjects;
	                    function getTextSizeInPx(textSize) {
	                        return jsCommon.PixelConverter.fromPoint(textSize);
	                    }
	                    TablixObjects.getTextSizeInPx = getTextSizeInPx;
	                    function shouldShowTableTotals(objects) {
	                        return TablixObjects.PropGeneralTableTotals.getValue(objects);
	                    }
	                    TablixObjects.shouldShowTableTotals = shouldShowTableTotals;
	                    function shouldShowTableTotalsOption(dataView) {
	                        if (dataView && dataView.table && !_.isEmpty(dataView.table.columns)) {
	                            var columns = dataView.table.columns;
	                            if (_.some(columns, function (column) { return column.discourageAggregationAcrossGroups; }))
	                                return false;
	                        }
	                        return true;
	                    }
	                    function getTableColumnMetadata(dataView) {
	                        if (!dataView || !dataView.table || _.isEmpty(dataView.table.columns))
	                            return;
	                        return dataView.table.columns;
	                    }
	                    function shouldShowRowSubtotals(objects) {
	                        return TablixObjects.PropGeneralMatrixRowSubtotals.getValue(objects);
	                    }
	                    TablixObjects.shouldShowRowSubtotals = shouldShowRowSubtotals;
	                    function shouldShowRowSubtotalsOption(dataView) {
	                        return !(dataView &&
	                            dataView.matrix &&
	                            dataView.matrix.rows &&
	                            isDiscourageAggregationAcrossGroups(dataView.matrix.rows.levels));
	                    }
	                    function shouldShowColumnSubtotals(objects) {
	                        return TablixObjects.PropGeneralMatrixColumnSubtotals.getValue(objects);
	                    }
	                    TablixObjects.shouldShowColumnSubtotals = shouldShowColumnSubtotals;
	                    function shouldShowColumnSubtotalsOption(dataView) {
	                        return !(dataView &&
	                            dataView.matrix &&
	                            dataView.matrix.columns &&
	                            isDiscourageAggregationAcrossGroups(dataView.matrix.columns.levels));
	                    }
	                    TablixObjects.shouldShowColumnSubtotalsOption = shouldShowColumnSubtotalsOption;
	                    function isDiscourageAggregationAcrossGroups(levels) {
	                        var lastLevel = _.last(levels);
	                        // If the last item is not Aggregatable, disable totals option since there will be no totals at all to display
	                        // However, if the non-aggregatable filed is in the middle, there are totals showing up in matrix.
	                        // Therefore, we still allow users to turn it off
	                        return lastLevel && _.some(lastLevel.sources, function (source) { return source.discourageAggregationAcrossGroups; });
	                    }
	                    TablixObjects.isDiscourageAggregationAcrossGroups = isDiscourageAggregationAcrossGroups;
	                })(TablixObjects = internal.TablixObjects || (internal.TablixObjects = {}));
	                var TablixUtils;
	                (function (TablixUtils) {
	                    TablixUtils.CssClassTablixDiv = "tablixDiv"; // Any DIV inside the table (outer and inner)
	                    TablixUtils.CssClassContentElement = "tablixCellContentElement"; // Outer DIV
	                    TablixUtils.CssClassContentHost = "tablixCellContentHost"; // Inner DIV
	                    TablixUtils.CssClassTablixHeader = "tablixHeader"; // Any Header in the Table/Matrix
	                    TablixUtils.CssClassTablixColumnHeaderLeaf = "tablixColumnHeaderLeaf"; // Leaf Column Headers
	                    TablixUtils.CssClassTablixValueNumeric = "tablixValueNumeric"; // Numeric cells, will also be applied to all Matrix body cells
	                    TablixUtils.CssClassTablixValueTotal = "tablixValueTotal"; // Total cells,  will also be applied to subtotal Matrix body cells
	                    TablixUtils.CssClassValueURLIcon = "powervisuals-glyph url-icon tablixUrlIconGlyph"; // Any <a> Tag
	                    TablixUtils.CssClassValueURLIconContainer = "tablixValueUrlIcon"; // Container for the <a> tag
	                    TablixUtils.CssClassMatrixRowHeaderLeaf = "matrixRowHeaderLeaf"; // Matrix Leaf Row Headers
	                    TablixUtils.CssClassMatrixRowHeaderSubTotal = "matrixRowHeaderSubTotal"; // Matrix SubTotal Row Headers
	                    TablixUtils.CssClassTableFooter = 'tableFooterCell'; // Any cell in the Footer area
	                    TablixUtils.CssClassTableBodyCell = 'tableBodyCell'; // Any cell in the Table Body
	                    TablixUtils.CssClassTableBodyCellBottom = 'tableBodyCellBottom'; // Bottom-Most Body cell
	                    TablixUtils.StringNonBreakingSpace = '&nbsp;';
	                    TablixUtils.UnitOfMeasurement = 'px';
	                    var SortIconContainerClassName = "tablixSortIconContainer";
	                    TablixUtils.CellPaddingLeft = 10;
	                    TablixUtils.CellPaddingRight = 5;
	                    TablixUtils.CellPaddingLeftMatrixTotal = 5;
	                    TablixUtils.SortIconPadding = 5;
	                    TablixUtils.ImageDefaultAspectRatio = 1;
	                    TablixUtils.FontFamilyCell = visuals.Font.Family.regular.css;
	                    TablixUtils.FontFamilyHeader = visuals.Font.Family.regular.css;
	                    TablixUtils.FontFamilyTotal = visuals.Font.Family.bold.css;
	                    TablixUtils.FontColorCells = "#333";
	                    TablixUtils.FontColorHeaders = "#666";
	                    (function (EdgeType) {
	                        EdgeType[EdgeType["Outline"] = 0] = "Outline";
	                        EdgeType[EdgeType["Gridline"] = 1] = "Gridline";
	                    })(TablixUtils.EdgeType || (TablixUtils.EdgeType = {}));
	                    var EdgeType = TablixUtils.EdgeType;
	                    ;
	                    var EdgeSettings = (function () {
	                        function EdgeSettings(weight, color) {
	                            this.applyParams(true, weight, color);
	                        }
	                        EdgeSettings.prototype.applyParams = function (shown, weight, color, type) {
	                            if (shown) {
	                                this.weight = weight == null ? 0 : weight;
	                                this.color = color == null ? 'black' : color;
	                                this.type = type == null ? EdgeType.Gridline : type;
	                            }
	                            else {
	                                this.weight = 0;
	                                this.color = 'black';
	                                this.type = EdgeType.Gridline;
	                            }
	                        };
	                        EdgeSettings.prototype.getCSS = function () {
	                            var css = [];
	                            if (_.isNumber(this.weight)) {
	                                css.push(this.weight + TablixUtils.UnitOfMeasurement);
	                                if (this.color)
	                                    css.push(this.color);
	                                css.push('solid');
	                            }
	                            return css.join(' ');
	                        };
	                        /**
	                         * Returns the priority of the current edge.
	                         * H. Grid = 0
	                         * V. Grid = 1
	                         * H. Outline = 2
	                         * V. Outline = 3
	                         * Uknown = -1
	                         * @param {Surround<EdgeSettings>} edges Edges. Used to determine the side of the current edge
	                         */
	                        EdgeSettings.prototype.getPriority = function (edges) {
	                            if (this === edges.top || this === edges.bottom)
	                                if (this.type === EdgeType.Outline)
	                                    return 2;
	                                else
	                                    return 0;
	                            if (this === edges.right || this === edges.left)
	                                if (this.type === EdgeType.Outline)
	                                    return 3;
	                                else
	                                    return 1;
	                            return -1;
	                        };
	                        EdgeSettings.prototype.getShadowCss = function (edges) {
	                            var output = "inset ";
	                            if (this === edges.left)
	                                output += this.weight + TablixUtils.UnitOfMeasurement + " 0";
	                            else if (this === edges.right)
	                                output += "-" + this.weight + TablixUtils.UnitOfMeasurement + " 0";
	                            else if (this === edges.top)
	                                output += "0 " + this.weight + TablixUtils.UnitOfMeasurement;
	                            else if (this === edges.bottom)
	                                output += "0 -" + this.weight + TablixUtils.UnitOfMeasurement;
	                            else
	                                return "";
	                            return output + " 0 0 " + this.color;
	                        };
	                        return EdgeSettings;
	                    }());
	                    TablixUtils.EdgeSettings = EdgeSettings;
	                    /**
	                     * Style parameters for each Cell
	                     */
	                    var CellStyle = (function () {
	                        function CellStyle() {
	                            this.borders = {};
	                            this.paddings = { top: 0, left: TablixUtils.CellPaddingLeft, bottom: 0, right: TablixUtils.CellPaddingRight };
	                            // Initializing values with empty string would cause CSS attributes to not be set if they are undefined
	                            this.fontFamily = "";
	                            this.fontColor = "";
	                            this.backColor = "";
	                        }
	                        /**
	                         * Sets the Inline style for the Cell
	                         * @param {ITablixCell} cell Cell to set style to
	                         */
	                        CellStyle.prototype.applyStyle = function (cell) {
	                            var _this = this;
	                            var div = cell.extension.contentHost;
	                            var style = div.style;
	                            style.fontFamily = this.fontFamily;
	                            style.color = this.fontColor;
	                            style.backgroundColor = this.backColor;
	                            var edges = [this.borders.top, this.borders.right, this.borders.bottom, this.borders.left];
	                            // Sorting edges by priority Descending
	                            edges = _.sortBy(edges, function (e) {
	                                return e ? e.getPriority(_this.borders) : -1;
	                            }).reverse();
	                            /**
	                            * We are setting the borders as inset shadow
	                            * This way we can control how intersecting borders would look like when they have different colors
	                            */
	                            style.boxShadow = _.map(edges, function (e) {
	                                if (e)
	                                    return e.getShadowCss(_this.borders);
	                            }).join(', ');
	                            style.border = "none";
	                            style.paddingTop = ((this.paddings.top == null ? 0 : this.paddings.top) + (this.borders.top == null ? 0 : this.borders.top.weight)) + TablixUtils.UnitOfMeasurement;
	                            style.paddingRight = ((this.paddings.right == null ? TablixUtils.CellPaddingRight : this.paddings.right) + (this.borders.right == null ? 0 : this.borders.right.weight)) + TablixUtils.UnitOfMeasurement;
	                            style.paddingBottom = ((this.paddings.bottom == null ? 0 : this.paddings.bottom) + (this.borders.bottom == null ? 0 : this.borders.bottom.weight)) + TablixUtils.UnitOfMeasurement;
	                            style.paddingLeft = ((this.paddings.left == null ? TablixUtils.CellPaddingLeft : this.paddings.left) + (this.borders.left == null ? 0 : this.borders.left.weight)) + TablixUtils.UnitOfMeasurement;
	                        };
	                        CellStyle.prototype.getExtraTop = function () {
	                            var extra = 0;
	                            if (this.paddings.top)
	                                extra += this.paddings.top;
	                            if (this.borders.top)
	                                extra += this.borders.top.weight;
	                            return extra;
	                        };
	                        CellStyle.prototype.getExtraBottom = function () {
	                            var extra = 0;
	                            if (this.paddings.bottom)
	                                extra += this.paddings.bottom;
	                            if (this.borders.bottom)
	                                extra += this.borders.bottom.weight;
	                            return extra;
	                        };
	                        CellStyle.prototype.getExtraRight = function () {
	                            var extra = 0;
	                            if (this.paddings.right)
	                                extra += this.paddings.right;
	                            if (this.borders.right)
	                                extra += this.borders.right.weight;
	                            return extra;
	                        };
	                        CellStyle.prototype.getExtraLeft = function () {
	                            var extra = 0;
	                            if (this.paddings.left)
	                                extra += this.paddings.left;
	                            if (this.borders.left)
	                                extra += this.borders.left.weight;
	                            return extra;
	                        };
	                        return CellStyle;
	                    }());
	                    TablixUtils.CellStyle = CellStyle;
	                    /**
	                     * Index within a dimension (row/column)
	                     */
	                    var DimensionPosition = (function () {
	                        function DimensionPosition() {
	                        }
	                        return DimensionPosition;
	                    }());
	                    TablixUtils.DimensionPosition = DimensionPosition;
	                    /**
	                     * Poistion information about the cell
	                     */
	                    var CellPosition = (function () {
	                        function CellPosition() {
	                            this.row = new DimensionPosition();
	                            this.column = new DimensionPosition();
	                        }
	                        CellPosition.prototype.isMatch = function (position) {
	                            return this.column.index === position.column.index &&
	                                this.row.index === position.row.index;
	                        };
	                        return CellPosition;
	                    }());
	                    TablixUtils.CellPosition = CellPosition;
	                    var TablixVisualCell = (function () {
	                        function TablixVisualCell(dataPoint, isTotal, columnMetadata, formatter, nullsAreBlank) {
	                            this.dataPoint = dataPoint;
	                            this.columnMetadata = columnMetadata;
	                            this.formatter = formatter;
	                            this.isTotal = isTotal;
	                            this.nullsAreBlank = nullsAreBlank;
	                            this.position = new TablixUtils.CellPosition();
	                        }
	                        Object.defineProperty(TablixVisualCell.prototype, "textContent", {
	                            get: function () {
	                                if (this.formatter)
	                                    return this.formatter(this.dataPoint, this.columnMetadata, TablixObjects.PropColumnFormatString.getPropertyID(), this.nullsAreBlank);
	                                else if (this.dataPoint != null)
	                                    return this.dataPoint;
	                                else
	                                    return '';
	                            },
	                            enumerable: true,
	                            configurable: true
	                        });
	                        ;
	                        Object.defineProperty(TablixVisualCell.prototype, "kpiContent", {
	                            get: function () {
	                                if (this.columnMetadata && isValidStatusGraphic(this.columnMetadata.kpi, this.textContent))
	                                    return createKpiDom(this.columnMetadata.kpi, this.textContent);
	                            },
	                            enumerable: true,
	                            configurable: true
	                        });
	                        ;
	                        Object.defineProperty(TablixVisualCell.prototype, "isNumeric", {
	                            get: function () {
	                                if (this.columnMetadata)
	                                    return this.columnMetadata.type.numeric && !this.columnMetadata.kpi;
	                            },
	                            enumerable: true,
	                            configurable: true
	                        });
	                        ;
	                        Object.defineProperty(TablixVisualCell.prototype, "isUrl", {
	                            get: function () {
	                                if (this.columnMetadata)
	                                    return visuals.converterHelper.isWebUrlColumn(this.columnMetadata);
	                            },
	                            enumerable: true,
	                            configurable: true
	                        });
	                        ;
	                        Object.defineProperty(TablixVisualCell.prototype, "isImage", {
	                            get: function () {
	                                if (this.columnMetadata)
	                                    return visuals.converterHelper.isImageUrlColumn(this.columnMetadata);
	                            },
	                            enumerable: true,
	                            configurable: true
	                        });
	                        Object.defineProperty(TablixVisualCell.prototype, "isValidUrl", {
	                            get: function () {
	                                return jsCommon.UrlUtils.isValidImageUrl(this.textContent);
	                            },
	                            enumerable: true,
	                            configurable: true
	                        });
	                        ;
	                        TablixVisualCell.prototype.isMatch = function (item) {
	                            return this.position.isMatch(item.position) && this.backColor === item.backColor;
	                        };
	                        return TablixVisualCell;
	                    }());
	                    TablixUtils.TablixVisualCell = TablixVisualCell;
	                    function createTable() {
	                        return document.createElement("table");
	                    }
	                    TablixUtils.createTable = createTable;
	                    function createDiv() {
	                        var div = document.createElement("div");
	                        div.className = "tablixDiv";
	                        return div;
	                    }
	                    TablixUtils.createDiv = createDiv;
	                    function resetCellCssClass(cell) {
	                        cell.extension.contentElement.className = TablixUtils.CssClassTablixDiv + " " + TablixUtils.CssClassContentElement;
	                        cell.extension.contentHost.className = TablixUtils.CssClassTablixDiv + " " + TablixUtils.CssClassContentHost;
	                    }
	                    TablixUtils.resetCellCssClass = resetCellCssClass;
	                    function addCellCssClass(cell, style) {
	                        cell.extension.contentHost.className += " " + style;
	                    }
	                    TablixUtils.addCellCssClass = addCellCssClass;
	                    /**
	                     * Clears all inline styles (border, fontColor, background) and resets CSS classes
	                     * Performed with unbind-<Cell>
	                     */
	                    function clearCellStyle(cell) {
	                        cell.extension.contentHost.className = "";
	                        cell.extension.contentHost.style.cssText = "";
	                    }
	                    TablixUtils.clearCellStyle = clearCellStyle;
	                    function clearCellTextAndTooltip(cell) {
	                        cell.extension.contentHost.textContent = '';
	                        cell.extension.contentHost.removeAttribute('title');
	                        cell.contentHeight = cell.contentWidth = 0;
	                        controls.HTMLElementUtils.clearChildren(cell.extension.contentHost);
	                    }
	                    TablixUtils.clearCellTextAndTooltip = clearCellTextAndTooltip;
	                    /**
	                     * Sets text and tooltip for cell
	                     * @param {string} text Text to set
	                     * @param {HTMLElement} elementText Element to set text to
	                     * @param {HTMLElement} elementTooltip? Element to set tootltip to, if undefined, elementText will be used
	                     */
	                    function setCellTextAndTooltip(text, elementText, elementTooltip) {
	                        var val = visuals.TextUtil.replaceSpaceWithNBSP(text);
	                        elementText.textContent = val;
	                        (elementTooltip || elementText).title = val;
	                    }
	                    TablixUtils.setCellTextAndTooltip = setCellTextAndTooltip;
	                    function isValidSortClick(e) {
	                        var colHeader = e.target;
	                        var x = e.offsetX;
	                        return x >= 0 && x < colHeader.offsetWidth - internal.TablixResizer.resizeHandleSize;
	                    }
	                    TablixUtils.isValidSortClick = isValidSortClick;
	                    function appendATagToBodyCell(value, cellElement, urlIcon) {
	                        var atag = null;
	                        if (cellElement.childElementCount === 0) {
	                            atag = document.createElement('a');
	                            cellElement.appendChild(atag);
	                        }
	                        else {
	                            atag = cellElement.children[0];
	                        }
	                        atag.href = value;
	                        atag.target = '_blank';
	                        atag.title = value;
	                        if (urlIcon === true) {
	                            atag.className = TablixUtils.CssClassValueURLIcon;
	                            cellElement.className = TablixUtils.CssClassValueURLIconContainer;
	                        }
	                        else {
	                            atag.innerText = value;
	                        }
	                    }
	                    TablixUtils.appendATagToBodyCell = appendATagToBodyCell;
	                    function appendImgTagToBodyCell(value, cellElement, imageHeight) {
	                        var imgContainer = TablixUtils.createDiv();
	                        var imgTag = document.createElement('img');
	                        imgContainer.style.height = imageHeight + "px";
	                        imgContainer.style.width = "100%";
	                        imgContainer.style.textAlign = "center";
	                        imgTag.src = value;
	                        imgTag.style.maxHeight = "100%";
	                        imgTag.style.maxWidth = "100%";
	                        imgContainer.appendChild(imgTag);
	                        cellElement.appendChild(imgContainer);
	                        cellElement.title = value;
	                    }
	                    TablixUtils.appendImgTagToBodyCell = appendImgTagToBodyCell;
	                    function createKpiDom(kpi, kpiValue) {
	                        debug.assertValue(kpi, 'kpi');
	                        debug.assertValue(kpiValue, 'kpiValue');
	                        var className = visuals.KpiUtil.getClassForKpi(kpi, kpiValue) || '';
	                        return DomFactory.div()
	                            .addClass(className)
	                            .css({
	                            'display': 'inline-block',
	                            'vertical-align': 'bottom',
	                            'margin': '0',
	                        });
	                    }
	                    TablixUtils.createKpiDom = createKpiDom;
	                    function isValidStatusGraphic(kpi, kpiValue) {
	                        if (!kpi || kpiValue === undefined) {
	                            return false;
	                        }
	                        return !!visuals.KpiUtil.getClassForKpi(kpi, kpiValue);
	                    }
	                    TablixUtils.isValidStatusGraphic = isValidStatusGraphic;
	                    function getCustomSortEventArgs(queryName, sortDirection) {
	                        var sortDescriptors = [{
	                                queryName: queryName,
	                                sortDirection: sortDirection
	                            }];
	                        return { sortDescriptors: sortDescriptors };
	                    }
	                    TablixUtils.getCustomSortEventArgs = getCustomSortEventArgs;
	                    function reverseSort(sortDirection) {
	                        return sortDirection === 2 /* Descending */ ? 1 /* Ascending */ : 2 /* Descending */;
	                    }
	                    TablixUtils.reverseSort = reverseSort;
	                    /**
	                     * Add sort icon to a table cell and return the element that should contain the contents
	                     * @param {SortDirection} itemSort SortDirection
	                     * @param {HTMLElement} cellDiv The inner DIV of the cell
	                     */
	                    function addSortIconToColumnHeader(itemSort, cellDiv) {
	                        var colHeaderContainer = TablixUtils.createDiv();
	                        if (itemSort) {
	                            colHeaderContainer.appendChild(createSortIcon(itemSort, true));
	                            colHeaderContainer.appendChild(createSortIcon(reverseSort(itemSort), false));
	                        }
	                        else {
	                            colHeaderContainer.appendChild(createSortIcon(2 /* Descending */, false));
	                        }
	                        var colHeaderTitle = TablixUtils.createDiv();
	                        colHeaderContainer.appendChild(colHeaderTitle);
	                        cellDiv.appendChild(colHeaderContainer);
	                        return colHeaderTitle;
	                    }
	                    TablixUtils.addSortIconToColumnHeader = addSortIconToColumnHeader;
	                    function createSortIcon(sort, isSorted) {
	                        var imgSort = document.createElement('i');
	                        imgSort.className = SortIconContainerClassName +
	                            " " + (isSorted ? "sorted" : "future") +
	                            " " + (sort === 1 /* Ascending */ ? "powervisuals-glyph caret-up" : "powervisuals-glyph caret-down");
	                        return imgSort;
	                    }
	                    function checkSortIconExists(cell) {
	                        for (var i = 0, len = cell.extension.contentElement.childElementCount; i < len; i++) {
	                            var element = cell.extension.contentElement.children.item(i);
	                            if (element.classList.contains(SortIconContainerClassName))
	                                return true;
	                        }
	                        return false;
	                    }
	                    function removeSortIcons(cell) {
	                        if (!checkSortIconExists(cell))
	                            return;
	                        $(cell.extension.contentElement).find('.' + SortIconContainerClassName).remove();
	                    }
	                    TablixUtils.removeSortIcons = removeSortIcons;
	                })(TablixUtils = internal.TablixUtils || (internal.TablixUtils = {}));
	            })(internal = controls.internal || (controls.internal = {}));
	        })(controls = visuals.controls || (visuals.controls = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 241 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../../_references.ts"/>

	

/***/ },
/* 242 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../../_references.ts"/>

	

/***/ },
/* 243 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../../_references.ts"/>

	

/***/ },
/* 244 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var controls;
	        (function (controls) {
	            controls.TablixDefaultTextSize = jsCommon.TextSizeDefaults.TextSizeMin;
	            var TablixControl = (function () {
	                function TablixControl(hierarchyNavigator, layoutManager, binder, parentDomElement, options) {
	                    var _this = this;
	                    this.scrollBarElementWidth = 9;
	                    // Options (fontSize set after container initialized)
	                    this.options = options;
	                    var isInteractive = options.interactive;
	                    this.isTouchEnabled = isInteractive && options.enableTouchSupport;
	                    // Main Div
	                    this.mainDiv = controls.internal.TablixUtils.createDiv();
	                    this.mainDiv.classList.add(TablixControl.TablixTableAreaClassName);
	                    // Footer Div
	                    this.footerDiv = controls.internal.TablixUtils.createDiv();
	                    this.footerDiv.classList.add(TablixControl.TablixFooterClassName);
	                    if (this.isTouchEnabled)
	                        this.InitializeTouchSupport();
	                    this.gridDimensions = {};
	                    this.containerElement = controls.internal.TablixUtils.createDiv();
	                    this.className = layoutManager.getTablixClassName();
	                    this.autoSizeWidth = false;
	                    this.autoSizeHeight = false;
	                    this.fontFamily = controls.internal.TablixUtils.FontFamilyCell;
	                    this.fontColor = controls.internal.TablixUtils.FontColorCells;
	                    this.fontSize = options.fontSize;
	                    parentDomElement.className = TablixControl.TablixContainerClassName;
	                    parentDomElement.appendChild(this.containerElement);
	                    this.containerElement.addEventListener("mousewheel", function (e) { _this.onMouseWheel(e); });
	                    this.containerElement.addEventListener("DOMMouseScroll", function (e) { _this.onFireFoxMouseWheel(e); });
	                    this.containerElement.appendChild(this.mainDiv);
	                    this.containerElement.appendChild(this.footerDiv);
	                    if (this.isTouchEnabled) {
	                        this.touchInterpreter.initTouch(this.mainDiv, null, false);
	                        this.footerTouchInterpreter.initTouch(this.footerDiv, this.mainDiv, false);
	                    }
	                    this.controlLayoutManager = layoutManager;
	                    this.controlLayoutManager.initialize(this);
	                    this.hierarchyTablixNavigator = hierarchyNavigator;
	                    this.binder = binder;
	                    this.columnDim = new controls.TablixColumnDimension(this);
	                    this.rowDim = new controls.TablixRowDimension(this);
	                    this.columnDim._otherDimension = this.rowDimension;
	                    this.rowDim._otherDimension = this.columnDimension;
	                    this.InitializeScrollbars();
	                    if (!isInteractive) {
	                        this.scrollbarWidth = 0;
	                    }
	                    this.updateHorizontalPosition();
	                    this.updateVerticalPosition();
	                    this.updateFooterVisibility();
	                    this.lastRenderingArgs = {};
	                }
	                TablixControl.prototype.InitializeTouchSupport = function () {
	                    this.touchManager = new controls.TouchUtils.TouchManager();
	                    this.touchInterpreter = new controls.TouchUtils.TouchEventInterpreter(this.touchManager);
	                    this.footerTouchInterpreter = new controls.TouchUtils.TouchEventInterpreter(this.touchManager);
	                    this.columnTouchDelegate = new controls.ColumnTouchDelegate(new controls.TouchUtils.Rectangle());
	                    this.rowTouchDelegate = new controls.RowTouchDelegate(new controls.TouchUtils.Rectangle());
	                    this.bodyTouchDelegate = new controls.BodyTouchDelegate(new controls.TouchUtils.Rectangle());
	                    this.footerTouchDelegate = new controls.ColumnTouchDelegate(new controls.TouchUtils.Rectangle());
	                    this.columnTouchDelegate.setHandler(this, this.onTouchEvent);
	                    this.rowTouchDelegate.setHandler(this, this.onTouchEvent);
	                    this.bodyTouchDelegate.setHandler(this, this.onTouchEvent);
	                    this.footerTouchDelegate.setHandler(this, this.onTouchEvent);
	                    this.touchManager.addTouchRegion(this.columnTouchDelegate.dimension, this.columnTouchDelegate, this.columnTouchDelegate);
	                    this.touchManager.addTouchRegion(this.rowTouchDelegate.dimension, this.rowTouchDelegate, this.rowTouchDelegate);
	                    this.touchManager.addTouchRegion(this.bodyTouchDelegate.dimension, this.bodyTouchDelegate, this.bodyTouchDelegate);
	                    this.touchManager.addTouchRegion(this.footerTouchDelegate.dimension, this.footerTouchDelegate, this.footerTouchDelegate);
	                };
	                TablixControl.prototype.InitializeScrollbars = function () {
	                    // Row Dimension
	                    this.rowDim._initializeScrollbar(this.containerElement, null, this.options.layoutKind);
	                    var rowDimensionScrollbarStyle = this.rowDim.scrollbar.element.style;
	                    rowDimensionScrollbarStyle.position = "absolute";
	                    rowDimensionScrollbarStyle.top = "0" + TablixControl.UnitOfMeasurement;
	                    rowDimensionScrollbarStyle.right = "0" + TablixControl.UnitOfMeasurement;
	                    this.rowDim.scrollbar.width = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement;
	                    // Default to true which is the more common case to avoid an extra rendering iteration
	                    // when first rendering the visual
	                    this.rowDim.scrollbar.show(true);
	                    // Column Dimension
	                    this.columnDim._initializeScrollbar(this.containerElement, null, this.options.layoutKind);
	                    var columnDimensionScrollbarStyle = this.columnDim.scrollbar.element.style;
	                    columnDimensionScrollbarStyle.position = "absolute";
	                    columnDimensionScrollbarStyle.left = "0" + TablixControl.UnitOfMeasurement;
	                    columnDimensionScrollbarStyle.bottom = "0" + TablixControl.UnitOfMeasurement;
	                    this.columnDim.scrollbar.height = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement;
	                    this.columnDim.scrollbar.show(false);
	                };
	                Object.defineProperty(TablixControl.prototype, "container", {
	                    get: function () {
	                        return this.containerElement;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(TablixControl.prototype, "contentHost", {
	                    get: function () {
	                        return this.mainDiv;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(TablixControl.prototype, "footerHost", {
	                    get: function () {
	                        return this.footerDiv;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(TablixControl.prototype, "className", {
	                    set: function (value) {
	                        this.containerElement.className = value;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(TablixControl.prototype, "hierarchyNavigator", {
	                    get: function () {
	                        return this.hierarchyTablixNavigator;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                TablixControl.prototype.getBinder = function () {
	                    return this.binder;
	                };
	                Object.defineProperty(TablixControl.prototype, "autoSizeWidth", {
	                    get: function () {
	                        return this._autoSizeWidth;
	                    },
	                    set: function (value) {
	                        this._autoSizeWidth = value;
	                        if (!value) {
	                            this.containerElement.style.minWidth = this.containerElement.style.maxWidth = "none";
	                        }
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(TablixControl.prototype, "autoSizeHeight", {
	                    get: function () {
	                        return this._autoSizeHeight;
	                    },
	                    set: function (value) {
	                        if (!value) {
	                            this.containerElement.style.minHeight = this.containerElement.style.maxHeight = "none";
	                        }
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(TablixControl.prototype, "maxWidth", {
	                    get: function () {
	                        return this.maximumWidth;
	                    },
	                    set: function (value) {
	                        this.maximumWidth = value;
	                        this.containerElement.style.maxWidth = this.maximumWidth + TablixControl.UnitOfMeasurement;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(TablixControl.prototype, "viewport", {
	                    get: function () {
	                        return this.viewPort;
	                    },
	                    set: function (value) {
	                        this.viewPort = value;
	                        this.containerElement.style.width = this.viewPort.width + TablixControl.UnitOfMeasurement;
	                        this.containerElement.style.height = this.viewPort.height + TablixControl.UnitOfMeasurement;
	                        this.rowDim.scrollbar.invalidateArrange();
	                        this.columnDim.scrollbar.invalidateArrange();
	                        this.controlLayoutManager.updateViewport(this.viewPort);
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(TablixControl.prototype, "maxHeight", {
	                    get: function () {
	                        return this.maximumHeight;
	                    },
	                    set: function (value) {
	                        this.maximumHeight = value;
	                        this.containerElement.style.maxHeight = this.maximumHeight + TablixControl.UnitOfMeasurement;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(TablixControl.prototype, "minWidth", {
	                    get: function () {
	                        return this.minimumWidth;
	                    },
	                    set: function (value) {
	                        this.minimumWidth = value;
	                        this.containerElement.style.minWidth = this.minimumWidth + TablixControl.UnitOfMeasurement;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(TablixControl.prototype, "minHeight", {
	                    get: function () {
	                        return this.minimumHeight;
	                    },
	                    set: function (value) {
	                        this.minimumHeight = value;
	                        this.containerElement.style.minHeight = this.minimumHeight + TablixControl.UnitOfMeasurement;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(TablixControl.prototype, "fontSize", {
	                    get: function () {
	                        return this.textFontSize;
	                    },
	                    set: function (value) {
	                        this.textFontSize = !value ? TablixControl.DefaultFontSize : value;
	                        this.containerElement.style.fontSize = this.textFontSize;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(TablixControl.prototype, "fontFamily", {
	                    get: function () {
	                        return this.textFontFamily;
	                    },
	                    set: function (value) {
	                        this.textFontFamily = value;
	                        this.containerElement.style.fontFamily = value;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(TablixControl.prototype, "fontColor", {
	                    get: function () {
	                        return this.textFontColor;
	                    },
	                    set: function (value) {
	                        this.textFontColor = value;
	                        this.containerElement.style.color = value;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(TablixControl.prototype, "scrollbarWidth", {
	                    set: function (value) {
	                        this.scrollBarElementWidth = value;
	                        this.rowDim.scrollbar.width = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement;
	                        this.columnDim.scrollbar.height = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                TablixControl.prototype.updateModels = function (resetScrollOffsets, rowModel, columnModel) {
	                    this.rowDim.model = rowModel;
	                    this.rowDim.modelDepth = this.hierarchyNavigator.getRowHierarchyDepth();
	                    this.columnDim.model = columnModel;
	                    this.columnDim.modelDepth = this.hierarchyNavigator.getColumnHierarchyDepth();
	                    if (resetScrollOffsets) {
	                        this.rowDim.scrollOffset = 0;
	                        this.columnDim.scrollOffset = 0;
	                    }
	                    this.layoutManager.updateColumnCount(this.rowDim, this.columnDim);
	                };
	                TablixControl.prototype.updateColumnDimensions = function (rowHierarchyWidth, columnHierarchyWidth, count) {
	                    var gridDimensions = this.gridDimensions;
	                    gridDimensions.columnCount = count;
	                    gridDimensions.rowHierarchyWidth = rowHierarchyWidth;
	                    gridDimensions.columnHierarchyWidth = columnHierarchyWidth;
	                };
	                TablixControl.prototype.updateRowDimensions = function (columnHierarchyHeight, rowHierarchyHeight, rowHierarchyContentHeight, count, footerHeight) {
	                    var gridDimensions = this.gridDimensions;
	                    gridDimensions.rowCount = count;
	                    gridDimensions.rowHierarchyHeight = rowHierarchyHeight;
	                    gridDimensions.rowHierarchyContentHeight = rowHierarchyContentHeight;
	                    gridDimensions.columnHierarchyHeight = columnHierarchyHeight;
	                    gridDimensions.footerHeight = footerHeight;
	                };
	                TablixControl.prototype.updateTouchDimensions = function () {
	                    var gridDimensions = this.gridDimensions;
	                    this.columnTouchDelegate.resize(gridDimensions.rowHierarchyWidth, 0, gridDimensions.columnHierarchyWidth, gridDimensions.columnHierarchyHeight);
	                    this.columnTouchDelegate.setScrollDensity(gridDimensions.columnCount / gridDimensions.columnHierarchyWidth);
	                    this.rowTouchDelegate.resize(0, gridDimensions.columnHierarchyHeight, gridDimensions.rowHierarchyWidth, gridDimensions.rowHierarchyHeight);
	                    this.rowTouchDelegate.setScrollDensity(gridDimensions.rowCount / gridDimensions.rowHierarchyHeight);
	                    this.bodyTouchDelegate.resize(gridDimensions.rowHierarchyWidth, gridDimensions.columnHierarchyHeight, gridDimensions.columnHierarchyWidth, gridDimensions.rowHierarchyHeight);
	                    this.bodyTouchDelegate.setScrollDensity(gridDimensions.columnCount / gridDimensions.columnHierarchyWidth, gridDimensions.rowCount / gridDimensions.rowHierarchyHeight);
	                    this.footerTouchDelegate.resize(gridDimensions.rowHierarchyWidth, gridDimensions.columnHierarchyHeight + gridDimensions.rowHierarchyHeight, gridDimensions.columnHierarchyWidth, gridDimensions.footerHeight);
	                    this.footerTouchDelegate.setScrollDensity(gridDimensions.columnCount / gridDimensions.columnHierarchyWidth);
	                };
	                TablixControl.prototype.onMouseWheel = function (e) {
	                    this.determineDimensionToScroll(e, function (dimension, delta) { dimension.scrollbar.onMouseWheel(delta); });
	                    if (this.options.layoutKind === 0 /* Canvas */)
	                        e.preventDefault();
	                };
	                TablixControl.prototype.onFireFoxMouseWheel = function (e) {
	                    this.determineDimensionToScrollFirefox(e, function (dimension, delta) { dimension.scrollbar.onMouseWheel(delta); });
	                    if (this.options.layoutKind === 0 /* Canvas */)
	                        e.preventDefault();
	                };
	                TablixControl.prototype.determineDimensionToScroll = function (e, scrollCallback) {
	                    // If vertical scrollbar is shown, apply normal scrolling in X, Y
	                    if (this.rowDim.scrollbar.visible) {
	                        if (e.wheelDeltaY)
	                            scrollCallback(this.rowDim, e.wheelDeltaY);
	                        if (e.wheelDeltaX && this.columnDim.scrollbar.visible)
	                            scrollCallback(this.columnDim, e.wheelDeltaX);
	                    }
	                    else if (this.columnDim.scrollbar.visible) {
	                        if (e.wheelDeltaX)
	                            scrollCallback(this.columnDim, e.wheelDeltaX);
	                        else if (e.wheelDeltaY)
	                            scrollCallback(this.columnDim, e.wheelDeltaY);
	                    }
	                };
	                TablixControl.prototype.determineDimensionToScrollFirefox = function (e, scrollCallback) {
	                    // Firefox
	                    if (e.detail) {
	                        if (this.rowDim.scrollbar.visible) {
	                            scrollCallback(this.rowDim, -e.detail);
	                            return;
	                        }
	                        // In the absence of the vertical scrollbar, we scroll the
	                        // horizontal scrollbar.
	                        if (this.columnDim.scrollbar.visible) {
	                            scrollCallback(this.columnDim, -e.detail);
	                            return;
	                        }
	                    }
	                };
	                Object.defineProperty(TablixControl.prototype, "layoutManager", {
	                    get: function () {
	                        return this.controlLayoutManager;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(TablixControl.prototype, "columnDimension", {
	                    get: function () {
	                        return this.columnDim;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(TablixControl.prototype, "rowDimension", {
	                    get: function () {
	                        return this.rowDim;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                TablixControl.prototype.refresh = function (clear) {
	                    this.render(clear, null);
	                };
	                TablixControl.prototype._onScrollAsync = function (dimension) {
	                    var _this = this;
	                    requestAnimationFrame(function () { _this.performPendingScroll(dimension); });
	                };
	                TablixControl.prototype.performPendingScroll = function (dimension) {
	                    this.render(false, dimension);
	                };
	                TablixControl.prototype.updateHorizontalPosition = function () {
	                    if (this.rowDim.scrollbar.visible) {
	                        this.columnDim.scrollbar.element.style.right = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement;
	                        this.footerDiv.style.right = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement;
	                        this.mainDiv.style.right = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement;
	                    }
	                    else {
	                        this.columnDim.scrollbar.element.style.right = "0" + TablixControl.UnitOfMeasurement;
	                        this.mainDiv.style.right = "0" + TablixControl.UnitOfMeasurement;
	                        this.footerDiv.style.right = "0" + TablixControl.UnitOfMeasurement;
	                    }
	                };
	                TablixControl.prototype.updateFooterVisibility = function () {
	                    if (this.rowDim.hasFooter() ? (this.footerDiv.style.display !== "block") : (this.footerDiv.style.display !== "none")) {
	                        if (this.rowDim.hasFooter()) {
	                            this.footerDiv.style.display = "block";
	                        }
	                        else {
	                            this.footerDiv.style.display = "none";
	                        }
	                    }
	                };
	                TablixControl.prototype.updateVerticalPosition = function () {
	                    var hasVerticalScrollbar = this.rowDim.scrollbar.visible;
	                    // TODO: ideally the tablix control would not know about where it is rendered but the layout manager
	                    //       would provider that information; we should refactor the layout manager so that getLayoutKind is not needed anymore.
	                    var isDashboardTile = this.controlLayoutManager.getLayoutKind() === 1 /* DashboardTile */;
	                    var showFooter = hasVerticalScrollbar || isDashboardTile;
	                    if (showFooter) {
	                        var mainBottom = this.footerDiv.offsetHeight;
	                        var footerBottom = 0;
	                        var verticalScrollbarBottom = 0;
	                        // If we have a horizontal scrollbar, we need to adjust the bottom
	                        // value by the scrollbar width
	                        var hasHorizontalScrollbar = this.columnDim.scrollbar.visible;
	                        if (hasHorizontalScrollbar) {
	                            mainBottom += this.scrollBarElementWidth;
	                            footerBottom += this.scrollBarElementWidth;
	                            verticalScrollbarBottom = this.scrollBarElementWidth;
	                        }
	                        this.mainDiv.style.bottom = mainBottom + TablixControl.UnitOfMeasurement;
	                        this.rowDim.scrollbar.element.style.bottom = verticalScrollbarBottom + TablixControl.UnitOfMeasurement;
	                        this.footerDiv.style.bottom = footerBottom + TablixControl.UnitOfMeasurement;
	                        // With a vertical scrollbar, the footer is always rendered at the bottom
	                        this.footerDiv.style.removeProperty("top");
	                    }
	                    else {
	                        // Without a vertical scrollbar, the footer is rendered below the last row;
	                        // this is controlled by the top value only
	                        this.footerDiv.style.top = this.gridDimensions.rowHierarchyContentHeight + TablixControl.UnitOfMeasurement;
	                        this.footerDiv.style.removeProperty("bottom");
	                        this.mainDiv.style.removeProperty("bottom");
	                    }
	                };
	                TablixControl.prototype.alreadyRendered = function (scrollingDimension) {
	                    if (scrollingDimension !== this.lastRenderingArgs.scrollingDimension ||
	                        this.rowDimension.scrollOffset !== this.lastRenderingArgs.rowScrollOffset ||
	                        this.columnDimension.scrollOffset !== this.lastRenderingArgs.columnScrollOffset) {
	                        return false;
	                    }
	                    return true;
	                };
	                TablixControl.prototype.render = function (clear, scrollingDimension) {
	                    // at time of rendering always ensure the scroll offset is valid
	                    this.columnDim.makeScrollOffsetValid();
	                    this.rowDim.makeScrollOffsetValid();
	                    if (clear || scrollingDimension === null) {
	                        this.lastRenderingArgs = {};
	                    }
	                    else if (this.alreadyRendered(scrollingDimension)) {
	                        return;
	                    }
	                    var done = false;
	                    this.renderIterationCount = 0;
	                    this.controlLayoutManager.onStartRenderingSession(scrollingDimension, this.mainDiv, clear);
	                    var binder = this.binder;
	                    binder.onStartRenderingSession();
	                    var priorFooterHeight = this.gridDimensions.footerHeight;
	                    var priorRowHierarchyHeight = this.gridDimensions.rowHierarchyHeight;
	                    var priorRowHierarchyContentHeight = this.gridDimensions.rowHierarchyContentHeight;
	                    while (!done && this.renderIterationCount < TablixControl.MaxRenderIterationCount) {
	                        var hScrollbarVisibility = this.columnDim.scrollbar.visible;
	                        var vScrollbarVisibility = this.rowDim.scrollbar.visible;
	                        this.columnDim._onStartRenderingIteration();
	                        this.rowDim._onStartRenderingIteration();
	                        this.controlLayoutManager.onStartRenderingIteration(clear);
	                        // These calls add cells to the table.
	                        // Column needs to be rendered before rows as the row call will pair up with columns to produce the body cells.
	                        this.renderCorner();
	                        this.columnDim._render();
	                        this.rowDim._render();
	                        done = this.controlLayoutManager.onEndRenderingIteration();
	                        this.columnDim._onEndRenderingIteration();
	                        this.rowDim._onEndRenderingIteration();
	                        if ((hScrollbarVisibility !== this.columnDim.scrollbar.visible)) {
	                            this.updateVerticalPosition();
	                        }
	                        if (vScrollbarVisibility !== this.rowDim.scrollbar.visible) {
	                            this.updateHorizontalPosition();
	                        }
	                        this.renderIterationCount++;
	                    }
	                    this.controlLayoutManager.onEndRenderingSession();
	                    binder.onEndRenderingSession();
	                    if (this.isTouchEnabled)
	                        this.updateTouchDimensions();
	                    this.lastRenderingArgs.rowScrollOffset = this.rowDimension.scrollOffset;
	                    this.lastRenderingArgs.columnScrollOffset = this.columnDimension.scrollOffset;
	                    this.updateContainerDimensions();
	                    var lastRenderingArgs = this.lastRenderingArgs;
	                    lastRenderingArgs.rowScrollOffset = this.rowDimension.scrollOffset;
	                    lastRenderingArgs.columnScrollOffset = this.columnDimension.scrollOffset;
	                    lastRenderingArgs.scrollingDimension = scrollingDimension;
	                    if (priorFooterHeight !== this.gridDimensions.footerHeight ||
	                        priorRowHierarchyHeight !== this.gridDimensions.rowHierarchyHeight ||
	                        priorRowHierarchyContentHeight !== this.gridDimensions.rowHierarchyContentHeight) {
	                        this.updateVerticalPosition();
	                    }
	                    // NOTE: it is critical that we refresh the scrollbars only after the vertical
	                    //       position was updated above; otherwise the measurements can be incorrect.
	                    if (this.options.interactive) {
	                        this.columnDim.scrollbar.refresh();
	                        this.rowDim.scrollbar.refresh();
	                    }
	                };
	                TablixControl.prototype.updateContainerDimensions = function () {
	                    var gridDimensions = this.gridDimensions;
	                    if (this._autoSizeWidth) {
	                        var vScrollBarWidth = this.rowDim.scrollbar.visible ? this.scrollBarElementWidth : 0;
	                        this.containerElement.style.width =
	                            gridDimensions.rowHierarchyWidth +
	                                gridDimensions.columnHierarchyWidth +
	                                vScrollBarWidth +
	                                TablixControl.UnitOfMeasurement;
	                    }
	                    if (this._autoSizeHeight) {
	                        var hScrollBarHeight = this.columnDim.scrollbar.visible ? this.scrollBarElementWidth : 0;
	                        this.containerElement.style.height =
	                            gridDimensions.columnHierarchyHeight +
	                                gridDimensions.rowHierarchyHeight +
	                                gridDimensions.footerHeight +
	                                hScrollBarHeight +
	                                TablixControl.UnitOfMeasurement;
	                    }
	                };
	                TablixControl.prototype.cornerCellMatch = function (item, cell) {
	                    var previousItem = cell.item;
	                    return cell.type === 0 /* CornerCell */ && previousItem && this.hierarchyTablixNavigator.cornerCellItemEquals(item, previousItem);
	                };
	                TablixControl.prototype.renderCorner = function () {
	                    var columnDepth = this.columnDim.getDepth();
	                    var rowDepth = this.rowDim.getDepth();
	                    for (var i = 0; i < columnDepth; i++) {
	                        for (var j = 0; j < rowDepth; j++) {
	                            var item = this.hierarchyTablixNavigator.getCorner(j, i);
	                            var cell = this.controlLayoutManager.getOrCreateCornerCell(item, j, i);
	                            var match = this.cornerCellMatch(item, cell);
	                            if (!match) {
	                                this._unbindCell(cell);
	                                cell.type = 0 /* CornerCell */;
	                                cell.item = item;
	                                this.binder.bindCornerCell(item, cell);
	                            }
	                            this.controlLayoutManager.onCornerCellRealized(item, cell);
	                        }
	                    }
	                };
	                TablixControl.prototype._unbindCell = function (cell) {
	                    switch (cell.type) {
	                        case 3 /* BodyCell */:
	                            this.binder.unbindBodyCell(cell.item, cell);
	                            break;
	                        case 2 /* ColumnHeader */:
	                            this.binder.unbindColumnHeader(cell.item, cell);
	                            break;
	                        case 1 /* RowHeader */:
	                            this.binder.unbindRowHeader(cell.item, cell);
	                            break;
	                        case 0 /* CornerCell */:
	                            this.binder.unbindCornerCell(cell.item, cell);
	                    }
	                    cell.item = null;
	                    cell.type = null;
	                };
	                TablixControl.prototype.onTouchEvent = function (args) {
	                    var colShift;
	                    var rowShift;
	                    var that;
	                    if ((args) && (args.length > 0)) {
	                        if (("columnDim" in args[0]) && ("rowDim" in args[0])) {
	                            that = args[0];
	                            colShift = that.columnDim.scrollbar.visible ? args[1] : 0;
	                            rowShift = that.rowDim.scrollbar.visible ? args[2] : 0;
	                            that.columnDim.scrollbar.viewMin = Math.max(0, that.columnDim.scrollbar.viewMin + colShift);
	                            that.columnDim.scrollOffset = Math.max(0, that.columnDim.scrollOffset + colShift);
	                            that.rowDim.scrollbar.viewMin = Math.max(0, that.rowDim.scrollbar.viewMin + rowShift);
	                            that.rowDim.scrollOffset = Math.max(0, that.rowDim.scrollOffset + rowShift);
	                            if (colShift === 0) {
	                                that._onScrollAsync(that.rowDim);
	                            }
	                            else if (rowShift === 0) {
	                                that._onScrollAsync(that.columnDim);
	                            }
	                            else {
	                                that._onScrollAsync(null);
	                            }
	                        }
	                    }
	                };
	                TablixControl.UnitOfMeasurement = 'px';
	                TablixControl.TablixContainerClassName = 'tablixContainer';
	                TablixControl.TablixTableAreaClassName = "tablixTableArea";
	                TablixControl.TablixFooterClassName = "tableFooterArea";
	                TablixControl.DefaultFontSize = jsCommon.PixelConverter.fromPoint(controls.TablixDefaultTextSize);
	                /*
	                * This is workaround for the infinite loop in rendering
	                * BugID: 6518621
	                * ToDo: Investigate the underlying cause for rendering to never report completion
	                * Rendering typically require 3-5 iterations to complete, so 10 is enough
	                */
	                TablixControl.MaxRenderIterationCount = 10;
	                return TablixControl;
	            }());
	            controls.TablixControl = TablixControl;
	        })(controls = visuals.controls || (visuals.controls = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 245 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/// <reference path="../../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var controls;
	        (function (controls) {
	            var TablixDimension = (function () {
	                function TablixDimension(tablixControl) {
	                    this._scrollStep = 0.1;
	                    this._owner = tablixControl;
	                    this._hierarchyNavigator = tablixControl.hierarchyNavigator;
	                    this._binder = tablixControl.getBinder();
	                    this._tablixLayoutManager = tablixControl.layoutManager;
	                    this.scrollOffset = 0;
	                }
	                TablixDimension.prototype._onStartRenderingIteration = function () {
	                    this.updateScrollPosition();
	                };
	                TablixDimension.prototype._onEndRenderingIteration = function () {
	                };
	                TablixDimension.prototype.getValidScrollOffset = function (scrollOffset) {
	                    return Math.min(Math.max(scrollOffset, 0), Math.max(this.getItemsCount() - this._scrollStep, 0));
	                };
	                TablixDimension.prototype.makeScrollOffsetValid = function () {
	                    this.scrollOffset = this.getValidScrollOffset(this.scrollOffset);
	                };
	                TablixDimension.prototype.getIntegerScrollOffset = function () {
	                    return Math.floor(this.scrollOffset);
	                };
	                TablixDimension.prototype.getFractionScrollOffset = function () {
	                    return this.scrollOffset - this.getIntegerScrollOffset();
	                };
	                Object.defineProperty(TablixDimension.prototype, "scrollbar", {
	                    get: function () {
	                        return this._scrollbar;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                TablixDimension.prototype.getFirstVisibleItem = function (level) {
	                    return this._scrollItems[level];
	                };
	                TablixDimension.prototype.getFirstVisibleChild = function (item) {
	                    return this._hierarchyNavigator.getAt(this._hierarchyNavigator.getChildren(item), this.getFirstVisibleChildIndex(item));
	                };
	                TablixDimension.prototype.getFirstVisibleChildIndex = function (item) {
	                    var startItem = this.getFirstVisibleItem(this._hierarchyNavigator.getLevel(item) + 1);
	                    var firstVisibleIndex;
	                    if (startItem === undefined || (startItem !== undefined && this._hierarchyNavigator.getParent(startItem) !== item)) {
	                        firstVisibleIndex = 0;
	                    }
	                    else {
	                        firstVisibleIndex = this._hierarchyNavigator.getIndex(startItem);
	                    }
	                    return firstVisibleIndex;
	                };
	                TablixDimension.prototype._initializeScrollbar = function (parentElement, touchDiv, layoutKind) {
	                    var _this = this;
	                    this._scrollbar = this._createScrollbar(parentElement, layoutKind);
	                    this._scrollbar._onscroll.push(function (e) { return _this.onScroll(); });
	                    if (touchDiv) {
	                        this.scrollbar.initTouch(touchDiv, true);
	                        touchDiv.style.setProperty("-ms-touch-action", "pinch-zoom");
	                    }
	                };
	                TablixDimension.prototype.getItemsCount = function () {
	                    return this.model ? this._hierarchyNavigator.getLeafCount(this.model) : 0;
	                };
	                TablixDimension.prototype.getDepth = function () {
	                    return this.modelDepth;
	                };
	                TablixDimension.prototype.onScroll = function () {
	                    this.scrollOffset = this._scrollbar.viewMin;
	                    this._owner._onScrollAsync(this);
	                };
	                Object.defineProperty(TablixDimension.prototype, "otherDimension", {
	                    get: function () {
	                        return this._otherDimension;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(TablixDimension.prototype, "layoutManager", {
	                    get: function () {
	                        return this._layoutManager;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                TablixDimension.prototype._createScrollbar = function (parentElement, layoutKind) {
	                    // abstract
	                    debug.assertFail("PureVirtualMethod: TablixDimension._createScrollbar");
	                    return null;
	                };
	                TablixDimension.prototype.updateScrollPosition = function () {
	                    this._scrollItems = [];
	                    if (!this.model) {
	                        return;
	                    }
	                    var firstVisibleScrollIndex = this.getIntegerScrollOffset();
	                    var firstVisible = this._hierarchyNavigator.getLeafAt(this.model, firstVisibleScrollIndex);
	                    if (!firstVisible) {
	                        return;
	                    }
	                    this._firstVisibleScrollIndex = firstVisibleScrollIndex;
	                    do {
	                        this._scrollItems[this._hierarchyNavigator.getLevel(firstVisible)] = firstVisible;
	                        firstVisible = this._hierarchyNavigator.getParent(firstVisible);
	                    } while (firstVisible !== null);
	                };
	                return TablixDimension;
	            }());
	            controls.TablixDimension = TablixDimension;
	            var TablixRowDimension = (function (_super) {
	                __extends(TablixRowDimension, _super);
	                function TablixRowDimension(tablixControl) {
	                    _super.call(this, tablixControl);
	                    this._layoutManager = this._tablixLayoutManager.rowLayoutManager;
	                    this._footer = null;
	                }
	                TablixRowDimension.prototype.setFooter = function (footerHeader) {
	                    this._footer = footerHeader;
	                    this._owner.updateFooterVisibility();
	                };
	                TablixRowDimension.prototype.hasFooter = function () {
	                    return (this._footer !== null);
	                };
	                /**
	                 * This method first populates the footer followed by each row and their correlating body cells from top to bottom.
	                 */
	                TablixRowDimension.prototype._render = function () {
	                    var firstVisibleRowItem = this.getFirstVisibleItem(0);
	                    if (this.hasFooter()) {
	                        this.addFooterRowHeader(this._footer);
	                        this.addFooterBodyCells(this._footer);
	                    }
	                    if (firstVisibleRowItem !== undefined) {
	                        this.addNodes(this.model, 0, this.getDepth(), this._hierarchyNavigator.getIndex(firstVisibleRowItem));
	                    }
	                };
	                TablixRowDimension.prototype._createScrollbar = function (parentElement, layoutKind) {
	                    return new controls.VerticalScrollbar(parentElement, layoutKind);
	                };
	                /**
	                 * This function is a recursive call (with its recursive behavior in addNode()) that will navigate
	                 * through the row hierarchy in DFS (Depth First Search) order and continue into a single row
	                 * upto its estimated edge.
	                 */
	                TablixRowDimension.prototype.addNodes = function (items, rowIndex, depth, firstVisibleIndex) {
	                    var count = this._hierarchyNavigator.getCount(items);
	                    //for loop explores children of current "items"
	                    for (var i = firstVisibleIndex; i < count; i++) {
	                        if (!this._layoutManager.needsToRealize) {
	                            return;
	                        }
	                        var item = this._hierarchyNavigator.getAt(items, i);
	                        var cell = this.addNode(item, items, rowIndex, depth);
	                        rowIndex += cell.rowSpan; //next node is bumped down according cells vertical span
	                    }
	                };
	                TablixRowDimension.prototype.getFirstVisibleChildLeaf = function (item) {
	                    var leaf = item;
	                    while (!this._hierarchyNavigator.isLeaf(leaf)) {
	                        leaf = this.getFirstVisibleChild(leaf);
	                    }
	                    return leaf;
	                };
	                TablixRowDimension.prototype.bindRowHeader = function (item, cell) {
	                    this._binder.bindRowHeader(item, cell);
	                };
	                /**
	                 * This method can be thought of as the continuation of addNodes() as it continues the DFS (Depth First Search)
	                 * started from addNodes(). This function also handles ending the recursion with "_needsToRealize" being set to
	                 * false.
	                 *
	                 * Once the body cells are reached, populating is done linearly with addBodyCells().
	                 */
	                TablixRowDimension.prototype.addNode = function (item, items, rowIndex, depth) {
	                    var previousCount;
	                    var rowHeaderCell = this._tablixLayoutManager.getOrCreateRowHeader(item, items, rowIndex, this._hierarchyNavigator.getLevel(item));
	                    var match = this.rowHeaderMatch(item, rowHeaderCell);
	                    if (!match) {
	                        this._owner._unbindCell(rowHeaderCell);
	                        rowHeaderCell.type = 1 /* RowHeader */;
	                        rowHeaderCell.item = item;
	                        rowHeaderCell.unfixRowHeight();
	                    }
	                    if (this._hierarchyNavigator.isLeaf(item)) {
	                        rowHeaderCell.colSpan = depth - this._hierarchyNavigator.getLevel(item);
	                        rowHeaderCell.rowSpan = 1;
	                        if (!match)
	                            this.bindRowHeader(item, rowHeaderCell);
	                        this._tablixLayoutManager.onRowHeaderRealized(item, rowHeaderCell);
	                        this.addBodyCells(item, items, rowIndex);
	                    }
	                    else {
	                        previousCount = this._layoutManager.getRealizedItemsCount();
	                        this.addNodes(this._hierarchyNavigator.getChildren(item), rowIndex, depth, this.getFirstVisibleChildIndex(item));
	                        rowHeaderCell.colSpan = 1;
	                        rowHeaderCell.rowSpan = this._layoutManager.getRealizedItemsCount() - previousCount + 1;
	                        if (!match)
	                            this.bindRowHeader(item, rowHeaderCell);
	                        this._tablixLayoutManager.onRowHeaderRealized(item, rowHeaderCell);
	                    }
	                    return rowHeaderCell;
	                };
	                TablixRowDimension.prototype.rowHeaderMatch = function (item, cell) {
	                    var previousItem = cell.item;
	                    return cell.type === 1 /* RowHeader */ && previousItem && this._hierarchyNavigator.headerItemEquals(item, previousItem);
	                };
	                TablixRowDimension.prototype.addBodyCells = function (item, items, rowIndex) {
	                    var firstVisibleColumnIndex = this._otherDimension.getIntegerScrollOffset();
	                    var columnCount = this._otherDimension._layoutManager.getRealizedItemsCount() - this.getDepth();
	                    var hierarchyNavigator = this._hierarchyNavigator;
	                    var otherModel = this._otherDimension.model;
	                    var layoutManager = this._tablixLayoutManager;
	                    for (var i = 0; i < columnCount; i++) {
	                        //get column header "item" by index to pair up with row header to find corelating body cell
	                        var cellItem = hierarchyNavigator.getIntersection(item, hierarchyNavigator.getLeafAt(otherModel, firstVisibleColumnIndex + i));
	                        var cell = layoutManager.getOrCreateBodyCell(cellItem, item, items, rowIndex, i);
	                        this.bindBodyCell(cellItem, cell);
	                        layoutManager.onBodyCellRealized(cellItem, cell);
	                    }
	                };
	                TablixRowDimension.prototype.bindBodyCell = function (item, cell) {
	                    var match = this.bodyCelMatch(item, cell);
	                    if (!match) {
	                        this._owner._unbindCell(cell);
	                        cell.type = 3 /* BodyCell */;
	                        cell.item = item;
	                        cell.unfixRowHeight();
	                        this._binder.bindBodyCell(item, cell);
	                    }
	                };
	                TablixRowDimension.prototype.addFooterRowHeader = function (item) {
	                    var cell = this._tablixLayoutManager.getOrCreateFooterRowHeader(item, this.model);
	                    cell.colSpan = this.getDepth();
	                    var match = this.rowHeaderMatch(item, cell);
	                    if (!match) {
	                        this._owner._unbindCell(cell);
	                        cell.type = 1 /* RowHeader */;
	                        cell.item = item;
	                        cell.unfixRowHeight();
	                        this.bindRowHeader(item, cell);
	                        this._tablixLayoutManager.onRowHeaderFooterRealized(item, cell);
	                    }
	                };
	                TablixRowDimension.prototype.addFooterBodyCells = function (rowItem) {
	                    var firstVisibleColumnIndex = this._otherDimension.getIntegerScrollOffset();
	                    var columnCount = this._otherDimension.layoutManager.getRealizedItemsCount() - this.getDepth();
	                    var layoutManager = this._tablixLayoutManager;
	                    for (var i = 0; i < columnCount; i++) {
	                        //get column header "item" by index to pair up with row header to find corelating body cell
	                        var columnItem = this._hierarchyNavigator.getLeafAt(this._otherDimension.model, firstVisibleColumnIndex + i);
	                        //get corelating body cell and bind it
	                        var item = this._hierarchyNavigator.getIntersection(rowItem, columnItem);
	                        var cell = layoutManager.getOrCreateFooterBodyCell(item, i);
	                        this.bindBodyCell(item, cell);
	                        layoutManager.onBodyCellFooterRealized(item, cell);
	                    }
	                };
	                TablixRowDimension.prototype.bodyCelMatch = function (item, cell) {
	                    var previousItem = cell.item;
	                    return cell.type === 3 /* BodyCell */ && previousItem && this._hierarchyNavigator.bodyCellItemEquals(item, previousItem);
	                };
	                return TablixRowDimension;
	            }(TablixDimension));
	            controls.TablixRowDimension = TablixRowDimension;
	            var TablixColumnDimension = (function (_super) {
	                __extends(TablixColumnDimension, _super);
	                function TablixColumnDimension(tablixControl) {
	                    _super.call(this, tablixControl);
	                    this._layoutManager = this._tablixLayoutManager.columnLayoutManager;
	                }
	                TablixColumnDimension.prototype._render = function () {
	                    var firstVisibleColumnItem = this.getFirstVisibleItem(0);
	                    if (firstVisibleColumnItem !== undefined) {
	                        this.addNodes(this.model, 0, this.getDepth(), this._hierarchyNavigator.getIndex(firstVisibleColumnItem));
	                    }
	                };
	                TablixColumnDimension.prototype._createScrollbar = function (parentElement, layoutKind) {
	                    var scrollbar = new controls.HorizontalScrollbar(parentElement, layoutKind);
	                    // Set smallest increment of the scrollbar to 0.2 rows
	                    scrollbar.smallIncrement = 0.2;
	                    return scrollbar;
	                };
	                TablixColumnDimension.prototype.addNodes = function (items, columnIndex, depth, firstVisibleIndex) {
	                    var count = this._hierarchyNavigator.getCount(items);
	                    for (var i = firstVisibleIndex; i < count; i++) {
	                        if (!this._layoutManager.needsToRealize) {
	                            return;
	                        }
	                        var cell = this.addNode(this._hierarchyNavigator.getAt(items, i), items, columnIndex, depth);
	                        columnIndex += cell.colSpan;
	                    }
	                };
	                TablixColumnDimension.prototype.addNode = function (item, items, columnIndex, depth) {
	                    var cell = this._tablixLayoutManager.getOrCreateColumnHeader(item, items, this._hierarchyNavigator.getLevel(item), columnIndex);
	                    var match = this.columnHeaderMatch(item, cell);
	                    if (!match) {
	                        this._owner._unbindCell(cell);
	                        cell.type = 2 /* ColumnHeader */;
	                        cell.item = item;
	                        cell.unfixRowHeight();
	                    }
	                    if (this._hierarchyNavigator.isLeaf(item)) {
	                        cell.rowSpan = depth - this._hierarchyNavigator.getLevel(item);
	                    }
	                    else {
	                        var previousCount = this._layoutManager.getRealizedItemsCount();
	                        this.addNodes(this._hierarchyNavigator.getChildren(item), columnIndex, depth, this.getFirstVisibleChildIndex(item));
	                        // In case we have a grand total with multiple measures, the multi-measures will be direct children
	                        // There can be difference in level > 1. In this case, we want the Total cell to have rowspan = the difference
	                        var childrenLevelDifference = this._hierarchyNavigator.getChildrenLevelDifference(item);
	                        if (childrenLevelDifference === Infinity)
	                            cell.rowSpan = 1;
	                        else
	                            cell.rowSpan = childrenLevelDifference;
	                        cell.colSpan = this._layoutManager.getRealizedItemsCount() - previousCount + 1;
	                    }
	                    if (!match)
	                        this._binder.bindColumnHeader(item, cell);
	                    this._tablixLayoutManager.onColumnHeaderRealized(item, cell);
	                    return cell;
	                };
	                TablixColumnDimension.prototype.columnHeaderMatch = function (item, cell) {
	                    var previousItem = cell.item;
	                    return cell.type === 2 /* ColumnHeader */ && previousItem && this._hierarchyNavigator.headerItemEquals(item, previousItem);
	                };
	                return TablixColumnDimension;
	            }(TablixDimension));
	            controls.TablixColumnDimension = TablixColumnDimension;
	        })(controls = visuals.controls || (visuals.controls = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 246 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var controls;
	        (function (controls) {
	            /**
	             * This class represents the touch region of the column headers (this can also apply to footer/total).
	             * This class is reponsible for interpreting gestures in terms of pixels to changes in column position.
	             *
	             * Unlike the table body, this can only scroll in one direction.
	             */
	            var ColumnTouchDelegate = (function () {
	                /**
	                 * @constructor
	                 * @param region Location and area of the touch region in respect to its HTML element.
	                 */
	                function ColumnTouchDelegate(region) {
	                    this.dim = region;
	                    this.averageSize = 1; //default
	                    this.handlers = null;
	                    this.tablixControl = null;
	                }
	                Object.defineProperty(ColumnTouchDelegate.prototype, "dimension", {
	                    get: function () {
	                        return this.dim;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                /**
	                 * Sets the amount of columns to be shifted per delta in pixels.
	                 *
	                 * @param xRatio Column to pixel ratio (# columns / # pixels).
	                 */
	                ColumnTouchDelegate.prototype.setScrollDensity = function (xRatio) {
	                    this.averageSize = xRatio;
	                };
	                /**
	                 * Resize element.
	                 *
	                 * @param x X location from upper left of listened HTML element.
	                 * @param y Y location from upper left of listened HTML element.
	                 * @param width Width of area to listen for events.
	                 * @param height Height of area to listen for events.
	                 */
	                ColumnTouchDelegate.prototype.resize = function (x, y, width, height) {
	                    this.dim.x = x;
	                    this.dim.y = y;
	                    this.dim.width = width;
	                    this.dim.height = height;
	                };
	                /**
	                 * @see IPixelToItem.
	                 */
	                ColumnTouchDelegate.prototype.getPixelToItem = function (x, y, dx, dy, down) {
	                    return new controls.TouchUtils.TouchEvent(x * this.averageSize, 0, down, -dx * this.averageSize, 0);
	                };
	                /**
	                 * Fires event to Tablix Control to scroll with the event passed from the TouchManager.
	                 *
	                 * @param e Event recieved from touch manager.
	                 */
	                ColumnTouchDelegate.prototype.touchEvent = function (e) {
	                    var args = [];
	                    args[0] = this.tablixControl;
	                    args[1] = e.dx;
	                    args[2] = e.dy;
	                    if (this.handlers) {
	                        controls.fire([this.handlers], args);
	                    }
	                };
	                /**
	                 * Asigns handler for scrolling when scroll event is fired.
	                 *
	                 * @param tablixObj TablixControl that's handling the fired event.
	                 * @param handlerCall The call to be made (EXAMPLE: handlerCall = object.method;).
	                 */
	                ColumnTouchDelegate.prototype.setHandler = function (tablixObj, handlerCall) {
	                    this.handlers = handlerCall;
	                    this.tablixControl = tablixObj;
	                };
	                return ColumnTouchDelegate;
	            }());
	            controls.ColumnTouchDelegate = ColumnTouchDelegate;
	            /**
	             * This class represents the touch region of the row headers (left or right side aligned).
	             * This class is reponsible for interpreting gestures in terms of pixels to changes in row position.
	             *
	             * Unlike the table body, this can only scroll in one direction.
	             */
	            var RowTouchDelegate = (function () {
	                /**
	                 * @constructor
	                 * @param region Location and area of the touch region in respect to its HTML element.
	                 */
	                function RowTouchDelegate(region) {
	                    this.dim = region;
	                    this.averageSize = 30; //default
	                    this.handlers = null;
	                    this.tablixControl = null;
	                }
	                Object.defineProperty(RowTouchDelegate.prototype, "dimension", {
	                    get: function () {
	                        return this.dim;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                /**
	                 * Sets the amount of rows to be shifted per delta in pixels.
	                 *
	                 * @param yRatio Row to pixel ratio (# rows / # pixels).
	                 */
	                RowTouchDelegate.prototype.setScrollDensity = function (yRatio) {
	                    this.averageSize = yRatio;
	                };
	                /**
	                 * Resize element.
	                 * @param x X location from upper left of listened HTML element.
	                 * @param y Y location from upper left of listened HTML element.
	                 * @param width Width of area to listen for events.
	                 * @param height Height of area to listen for events.
	                 */
	                RowTouchDelegate.prototype.resize = function (x, y, width, height) {
	                    this.dim.x = x;
	                    this.dim.y = y;
	                    this.dim.width = width;
	                    this.dim.height = height;
	                };
	                /**
	                 * @see: IPixelToItem
	                 */
	                RowTouchDelegate.prototype.getPixelToItem = function (x, y, dx, dy, down) {
	                    var event = new controls.TouchUtils.TouchEvent(0, y * this.averageSize, down, 0, -dy * this.averageSize);
	                    return event;
	                };
	                /**
	                 * Fires event to Tablix Control to scroll with the event passed from the TouchManager.
	                 *
	                 * @param e Event recieved from touch manager.
	                 */
	                RowTouchDelegate.prototype.touchEvent = function (e) {
	                    var args = [];
	                    args[0] = this.tablixControl;
	                    args[1] = e.dx;
	                    args[2] = e.dy;
	                    if (this.handlers) {
	                        controls.fire([this.handlers], args);
	                    }
	                };
	                /**
	                 * Asigns handler for scrolling when scroll event is fired.
	                 *
	                 * @param tablixObj TablixControl that's handling the fired event.
	                 * @param handlerCall The call to be made (EXAMPLE: handlerCall = object.method;).
	                 */
	                RowTouchDelegate.prototype.setHandler = function (tablixObj, handlerCall) {
	                    this.handlers = handlerCall;
	                    this.tablixControl = tablixObj;
	                };
	                return RowTouchDelegate;
	            }());
	            controls.RowTouchDelegate = RowTouchDelegate;
	            /**
	             * This class represents the touch region covering the body of the table.
	             * This class is reponsible for interpreting gestures in terms of pixels to
	             * changes in row and column position.
	             */
	            var BodyTouchDelegate = (function () {
	                /**
	                 * @constructor
	                 * @param region Location and area of the touch region in respect to its HTML element.
	                 */
	                function BodyTouchDelegate(region) {
	                    this.dim = region;
	                    this.averageSizeX = BodyTouchDelegate.DefaultAverageSizeX;
	                    this.averageSizeY = BodyTouchDelegate.DefaultAverageSizeY;
	                    this.handlers = null;
	                    this.tablixControl = null;
	                }
	                Object.defineProperty(BodyTouchDelegate.prototype, "dimension", {
	                    /**
	                     * Returns dimension.
	                     *
	                     * @return The dimentions of the region this delegate listens to.
	                     */
	                    get: function () {
	                        return this.dim;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                /**
	                 * Sets the amount of rows and columns to be shifted per delta in pixels.
	                 *
	                 * @param xRatio Column to pixel ratio (# columns / # pixels)
	                 * @param yRatio Row to pixel ratio (# rows / # pixels)
	                 */
	                BodyTouchDelegate.prototype.setScrollDensity = function (xRatio, yRatio) {
	                    this.averageSizeX = xRatio;
	                    this.averageSizeY = yRatio;
	                };
	                /**
	                 * Resize element.
	                 *
	                 * @param x X location from upper left of listened HTML element.
	                 * @param y Y location from upper left of listened HTML element.
	                 * @param width Width of area to listen for events.
	                 * @param height Height of area to listen for events.
	                 */
	                BodyTouchDelegate.prototype.resize = function (x, y, width, height) {
	                    var dimension = this.dim;
	                    dimension.x = x;
	                    dimension.y = y;
	                    dimension.width = width;
	                    dimension.height = height;
	                };
	                /**
	                 * @see: IPixelToItem.
	                 */
	                BodyTouchDelegate.prototype.getPixelToItem = function (x, y, dx, dy, down) {
	                    return new controls.TouchUtils.TouchEvent(x * this.averageSizeX, y * this.averageSizeY, down, -dx * this.averageSizeX, -dy * this.averageSizeY);
	                };
	                /**
	                 * Fires event to Tablix Control to scroll with the event passed from the TouchManager.
	                 *
	                 * @param e Event recieved from touch manager.
	                 */
	                BodyTouchDelegate.prototype.touchEvent = function (e) {
	                    var args = [this.tablixControl, e.dx, e.dy];
	                    if (this.handlers) {
	                        controls.fire([this.handlers], args);
	                    }
	                };
	                /**
	                 * Asigns handler for scrolling when scroll event is fired.
	                 *
	                 * @param tablixObj TablixControl that's handling the fired event.
	                 * @param handlerCall The call to be made (EXAMPLE: handlerCall = object.method;).
	                 */
	                BodyTouchDelegate.prototype.setHandler = function (tablixObj, handlerCall) {
	                    this.handlers = handlerCall;
	                    this.tablixControl = tablixObj;
	                };
	                BodyTouchDelegate.DefaultAverageSizeX = 30;
	                BodyTouchDelegate.DefaultAverageSizeY = 30;
	                return BodyTouchDelegate;
	            }());
	            controls.BodyTouchDelegate = BodyTouchDelegate;
	        })(controls = visuals.controls || (visuals.controls = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 247 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/// <reference path="../../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var controls;
	        (function (controls) {
	            var TouchUtils;
	            (function (TouchUtils) {
	                var Point = (function () {
	                    function Point(x, y) {
	                        this.x = x || 0;
	                        this.y = y || 0;
	                    }
	                    Point.prototype.offset = function (offsetX, offsetY) {
	                        this.x += offsetX;
	                        this.y += offsetY;
	                    };
	                    return Point;
	                }());
	                TouchUtils.Point = Point;
	                var Rectangle = (function (_super) {
	                    __extends(Rectangle, _super);
	                    function Rectangle(x, y, width, height) {
	                        _super.call(this, x, y);
	                        this.width = width || 0;
	                        this.height = height || 0;
	                    }
	                    Object.defineProperty(Rectangle.prototype, "point", {
	                        get: function () {
	                            return new Point(this.x, this.y);
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Rectangle.prototype.contains = function (p) {
	                        return Rectangle.contains(this, p);
	                    };
	                    Rectangle.contains = function (rect, p) {
	                        if (p && !Rectangle.isEmpty(rect)) {
	                            return rect.x <= p.x && p.x < rect.x + rect.width && rect.y <= p.y && p.y < rect.y + rect.height;
	                        }
	                        return false;
	                    };
	                    Rectangle.isEmpty = function (rect) {
	                        return !(rect !== undefined && rect.width >= 0 && rect.height >= 0);
	                    };
	                    return Rectangle;
	                }(Point));
	                TouchUtils.Rectangle = Rectangle;
	                (function (MouseButton) {
	                    MouseButton[MouseButton["NoClick"] = 0] = "NoClick";
	                    MouseButton[MouseButton["LeftClick"] = 1] = "LeftClick";
	                    MouseButton[MouseButton["RightClick"] = 2] = "RightClick";
	                    MouseButton[MouseButton["CenterClick"] = 3] = "CenterClick";
	                })(TouchUtils.MouseButton || (TouchUtils.MouseButton = {}));
	                var MouseButton = TouchUtils.MouseButton;
	                /**
	                 * A simple touch event class that's abstracted away from any platform specific traits.
	                 */
	                var TouchEvent = (function () {
	                    /**
	                     * @constructor
	                     * @param x X Location of mouse.
	                     * @param y Y Location of mouse.
	                     * @param isMouseDown Indicates if the mouse button is held down or a finger press on screen.
	                     * @param dx (optional) The change in x of the gesture.
	                     * @param dy (optional) The change in y of the gesture.
	                     */
	                    function TouchEvent(x, y, isMouseDown, dx, dy) {
	                        this._x = x;
	                        this._y = y;
	                        this.isMouseButtonDown = isMouseDown;
	                        this._dx = dx || 0;
	                        this._dy = dy || 0;
	                    }
	                    Object.defineProperty(TouchEvent.prototype, "x", {
	                        get: function () {
	                            return this._x;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(TouchEvent.prototype, "y", {
	                        get: function () {
	                            return this._y;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(TouchEvent.prototype, "dx", {
	                        get: function () {
	                            return this._dx;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(TouchEvent.prototype, "dy", {
	                        get: function () {
	                            return this._dy;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    Object.defineProperty(TouchEvent.prototype, "isMouseDown", {
	                        /**
	                         * Returns a boolean indicating if the mouse button is held down.
	                         *
	                         * @return: True if the the mouse button is held down,
	                         * otherwise false.
	                         */
	                        get: function () {
	                            return this.isMouseButtonDown;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    return TouchEvent;
	                }());
	                TouchUtils.TouchEvent = TouchEvent;
	                /**
	                 * This class "listens" to the TouchEventInterpreter  to recieve touch events and sends it to all
	                 * "Touch Delegates" with  TouchRegions that contain the mouse event. Prior to sending off the
	                 * event, its position is put in respect to the delegate's TouchRegion and converted to the appropriate
	                 * unit (see IPixelToItem).
	                 */
	                var TouchManager = (function () {
	                    /**
	                     * Default constructor.
	                     *
	                     * The default behavior is to enable thresholds and lock to axis.
	                     */
	                    function TouchManager() {
	                        this.touchList = [];
	                        this.swipeDirection = 2 /* FreeForm */;
	                        this.matchingDirectionCount = 0;
	                        this.lockThreshold = true;
	                        this.scrollThreshold = true;
	                        this.lastTouchEvent = new TouchEvent(0, 0, false);
	                    }
	                    Object.defineProperty(TouchManager.prototype, "lastEvent", {
	                        get: function () {
	                            return this.lastTouchEvent;
	                        },
	                        enumerable: true,
	                        configurable: true
	                    });
	                    /**
	                     * @param region Rectangle indicating the locations of the touch region.
	                     * @param handler Handler for recieved touch events.
	                     * @param converter Converts from pixels to the wanted item of measure (rows, columns, etc).
	                     *
	                     * EXAMPLE: dx -> from # of pixels to the right to # of columns moved to the right.
	                     */
	                    TouchManager.prototype.addTouchRegion = function (region, handler, converter) {
	                        var item = {
	                            lastPoint: new TouchEvent(0, 0, false),
	                            handler: handler,
	                            region: region,
	                            converter: converter
	                        };
	                        this.touchList = this.touchList.concat([item]);
	                    };
	                    /**
	                     * Sends a mouse up event to all regions with their last event as a mouse down event.
	                     */
	                    TouchManager.prototype.upAllTouches = function () {
	                        var eventPoint;
	                        var length;
	                        length = this.touchList.length;
	                        for (var i = 0; i < length; i++) {
	                            if (this.touchList[i].lastPoint.isMouseDown) {
	                                eventPoint = this.touchList[i].converter.getPixelToItem(this.touchList[i].lastPoint.x, this.touchList[i].lastPoint.y, 0, 0, false);
	                                this.touchList[i].handler.touchEvent(eventPoint);
	                            }
	                            this.touchList[i].lastPoint = new TouchEvent(this.touchList[i].lastPoint.x, this.touchList[i].lastPoint.y, false);
	                        }
	                        this.lastTouchEvent = new TouchEvent(0, 0, false);
	                    };
	                    TouchManager.prototype.touchEvent = function (e) {
	                        var list;
	                        var length;
	                        var x = 0;
	                        var y = 0;
	                        var dx = 0;
	                        var dy = 0;
	                        var angle = 0;
	                        var eventPoint = null;
	                        //assume there are already regions in the middle of a drag event and get those regions
	                        list = this._getActive();
	                        //if this is the start of a mouse drag event, repopulate the list with touched regions
	                        if (!this.lastTouchEvent.isMouseDown && e.isMouseDown) {
	                            list = this._findRegions(e);
	                        }
	                        //determine the delta values and update last event (delta ignored on first mouse down event)
	                        dx = this.lastTouchEvent.x - e.x;
	                        dy = this.lastTouchEvent.y - e.y;
	                        this.lastTouchEvent = new TouchEvent(e.x, e.y, e.isMouseDown, dx, dy);
	                        //go through the list
	                        length = list.length;
	                        for (var i = 0; i < length; i++) {
	                            x = e.x - list[i].region.point.x;
	                            y = e.y - list[i].region.point.y;
	                            //is this in the middle of a drag?
	                            if (list[i].lastPoint.isMouseDown && e.isMouseDown) {
	                                dx = x - list[i].lastPoint.x;
	                                dy = y - list[i].lastPoint.y;
	                                //calculate the absolute angle from the horizontal axis
	                                angle = Math.abs(180 / Math.PI * Math.atan(dy / dx));
	                                if (this.scrollThreshold) {
	                                    //is the gesture already locked? (6 prior events within the threshold)
	                                    if (this.lockThreshold && (this.matchingDirectionCount > 5)) {
	                                        if (this.swipeDirection === 1 /* Horizontal */) {
	                                            dy = 0;
	                                        }
	                                        else if (this.swipeDirection === 0 /* Vertical */) {
	                                            dx = 0;
	                                        }
	                                    }
	                                    else {
	                                        //is it within the horizontal threshold?
	                                        if (angle < 20) {
	                                            dy = 0;
	                                            if (this.swipeDirection === 1 /* Horizontal */) {
	                                                this.matchingDirectionCount++;
	                                            }
	                                            else {
	                                                this.matchingDirectionCount = 1;
	                                                this.swipeDirection = 1 /* Horizontal */;
	                                            }
	                                        }
	                                        else {
	                                            //calculate the absolute angle from the vertical axis
	                                            angle = Math.abs(180 / Math.PI * Math.atan(dx / dy));
	                                            //is it within the horizontal threshold?
	                                            if (angle < 20) {
	                                                dx = 0;
	                                                if (this.swipeDirection === 0 /* Vertical */) {
	                                                    this.matchingDirectionCount++;
	                                                }
	                                                else {
	                                                    this.matchingDirectionCount = 1;
	                                                    this.swipeDirection = 0 /* Vertical */;
	                                                }
	                                            }
	                                            else {
	                                                if (this.swipeDirection === 2 /* FreeForm */) {
	                                                    this.matchingDirectionCount++;
	                                                }
	                                                else {
	                                                    this.swipeDirection = 2 /* FreeForm */;
	                                                    this.matchingDirectionCount = 1;
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                            else {
	                                dx = 0;
	                                dy = 0;
	                                this.swipeDirection = 2 /* FreeForm */;
	                                this.matchingDirectionCount = 0;
	                            }
	                            list[i].lastPoint = new TouchEvent(x, y, e.isMouseDown, dx, dy);
	                            eventPoint = list[i].converter.getPixelToItem(x, y, dx, dy, e.isMouseDown);
	                            list[i].handler.touchEvent(eventPoint);
	                        }
	                    };
	                    /**
	                     * @param e Position of event used to find touched regions
	                     * @return Array of regions that contain the event point.
	                     */
	                    TouchManager.prototype._findRegions = function (e) {
	                        var list = [];
	                        var length;
	                        length = this.touchList.length;
	                        for (var i = 0; i < length; i++) {
	                            if (this.touchList[i].region.contains(new Point(e.x, e.y))) {
	                                list = list.concat([this.touchList[i]]);
	                            }
	                        }
	                        return list;
	                    };
	                    /**
	                     * @return Array of regions that contain a mouse down event. (see ITouchHandlerSet.lastPoint).
	                     */
	                    TouchManager.prototype._getActive = function () {
	                        var list = [];
	                        var length;
	                        length = this.touchList.length;
	                        for (var i = 0; i < length; i++) {
	                            if (this.touchList[i].lastPoint.isMouseDown) {
	                                list = list.concat([this.touchList[i]]);
	                            }
	                        }
	                        return list;
	                    };
	                    return TouchManager;
	                }());
	                TouchUtils.TouchManager = TouchManager;
	                var MinDistanceForSwipe = 80;
	                var MaxTimeForSwipe = 600;
	                /**
	                 * This class is responsible for establishing connections to handle touch events
	                 * and to interpret those events so they're compatible with the touch abstractions.
	                 *
	                 * Touch events with platform specific handles should be done here.
	                 */
	                var TouchEventInterpreter = (function () {
	                    function TouchEventInterpreter(manager) {
	                        this.manager = manager;
	                        this.allowMouseDrag = true;
	                        this.touchPanel = null;
	                        this.scale = 1;
	                        this.documentMouseMoveWrapper = null;
	                        this.documentMouseUpWrapper = null;
	                        this.sliding = false;
	                    }
	                    TouchEventInterpreter.prototype.initTouch = function (panel, touchReferencePoint, allowMouseDrag) {
	                        var _this = this;
	                        panel.style.setProperty("-ms-touch-action", "pinch-zoom");
	                        this.touchReferencePoint = touchReferencePoint;
	                        this.touchPanel = panel;
	                        this.allowMouseDrag = allowMouseDrag === undefined ? true : allowMouseDrag;
	                        if ("ontouchmove" in panel) {
	                            panel.addEventListener("touchstart", function (e) { return _this.onTouchStart(e); });
	                            panel.addEventListener("touchend", function (e) { return _this.onTouchEnd(e); });
	                        }
	                        else {
	                            panel.addEventListener("mousedown", function (e) { return _this.onTouchMouseDown(e); });
	                            panel.addEventListener("mouseup", function (e) { return _this.onTouchMouseUp(e); });
	                        }
	                    };
	                    TouchEventInterpreter.prototype.getXYByClient = function (pageX, pageY, rect) {
	                        var x = rect.left;
	                        var y = rect.top;
	                        // Fix for Safari
	                        if (window["scrollX"] !== undefined) {
	                            x += window["scrollX"];
	                            y += window["scrollY"];
	                        }
	                        var point = new Point(0, 0);
	                        point.offset(pageX - x, pageY - y);
	                        return point;
	                    };
	                    TouchEventInterpreter.prototype.onTouchStart = function (e) {
	                        if (e.touches.length === 1) {
	                            e.cancelBubble = true;
	                            var mouchEvent = e.touches[0];
	                            this.touchStartTime = new Date().getTime();
	                            this.touchStartPageY = mouchEvent.pageY;
	                            this.onTouchMouseDown(mouchEvent);
	                        }
	                    };
	                    TouchEventInterpreter.prototype.onTouchMove = function (e) {
	                        if (e.touches.length === 1) {
	                            if (e.preventDefault) {
	                                e.preventDefault();
	                            }
	                            var mouchEvent = e.touches[0];
	                            this.touchLastPageY = mouchEvent.pageY;
	                            this.touchLastPageX = mouchEvent.pageX;
	                            // while sliding ignore the touch move event 
	                            if (!this.sliding) {
	                                this.onTouchMouseMove(mouchEvent);
	                            }
	                        }
	                    };
	                    TouchEventInterpreter.prototype.onTouchEnd = function (e) {
	                        this.clearTouchEvents();
	                        var swipeInfo = this.getSwipeInfo();
	                        if (this.didUserSwipe(swipeInfo)) {
	                            this.startSlideAffect(swipeInfo);
	                        }
	                        else if (!this.sliding) {
	                            this.upAllTouches();
	                        }
	                    };
	                    TouchEventInterpreter.prototype.onTouchMouseDown = function (e) {
	                        var _this = this;
	                        this.scale = controls.HTMLElementUtils.getAccumulatedScale(this.touchPanel);
	                        //any prior touch scrolling that produced a selection outside Tablix will prevent the next touch scroll (1262519)
	                        document.getSelection().removeAllRanges();
	                        this.rect = (this.touchReferencePoint ? this.touchReferencePoint : this.touchPanel).getBoundingClientRect();
	                        if ("ontouchmove" in this.touchPanel) {
	                            this.documentMouseMoveWrapper = function (e) { return _this.onTouchMove(e); };
	                            document.addEventListener("touchmove", this.documentMouseMoveWrapper);
	                            this.documentMouseUpWrapper = function (e) { return _this.onTouchEnd(e); };
	                            document.addEventListener("touchend", this.documentMouseUpWrapper);
	                        }
	                        else {
	                            this.documentMouseMoveWrapper = function (e) { return _this.onTouchMouseMove(e); };
	                            document.addEventListener("mousemove", this.documentMouseMoveWrapper);
	                            this.documentMouseUpWrapper = function (e) { return _this.onTouchMouseUp(e); };
	                            document.addEventListener("mouseup", this.documentMouseUpWrapper);
	                        }
	                        if ("setCapture" in this.touchPanel) {
	                            this.touchPanel.setCapture();
	                        }
	                    };
	                    TouchEventInterpreter.prototype.onTouchMouseMove = function (e) {
	                        var event;
	                        var point;
	                        var rect = this.rect;
	                        var validMouseDragEvent = (rect !== null) && (e.which !== MouseButton.NoClick);
	                        // Ignore events that are not part of a drag event
	                        if (!validMouseDragEvent || this.sliding)
	                            return;
	                        point = this.getXYByClient(e.pageX, e.pageY, rect);
	                        event = new TouchEvent(point.x / this.scale, point.y / this.scale, validMouseDragEvent);
	                        this.manager.touchEvent(event);
	                        if (e.preventDefault)
	                            e.preventDefault();
	                        else if ("returnValue" in e)
	                            e["returnValue"] = false;
	                    };
	                    TouchEventInterpreter.prototype.onTouchMouseUp = function (e, bubble) {
	                        this.upAllTouches();
	                        this.clearTouchEvents();
	                    };
	                    TouchEventInterpreter.prototype.getSwipeInfo = function () {
	                        var touchEndTime = new Date().getTime();
	                        var touchTime = touchEndTime - this.touchStartTime;
	                        var touchDist = this.touchLastPageY - this.touchStartPageY;
	                        var touchDirection = touchDist < 0 ? -1 : 1;
	                        return {
	                            direction: touchDirection,
	                            distance: touchDist,
	                            endTime: touchEndTime,
	                            time: touchTime,
	                        };
	                    };
	                    TouchEventInterpreter.prototype.didUserSwipe = function (swipeInfo) {
	                        return swipeInfo.time < MaxTimeForSwipe && swipeInfo.distance * swipeInfo.direction > MinDistanceForSwipe;
	                    };
	                    /**
	                     * In case of swipe - auto advance to the swipe direction in 2 steps.
	                     */
	                    TouchEventInterpreter.prototype.startSlideAffect = function (swipeInfo) {
	                        var _this = this;
	                        if (this.sliding) {
	                            return;
	                        }
	                        this.sliding = true;
	                        var point = this.getXYByClient(this.touchLastPageX, this.touchLastPageY, this.rect);
	                        this.slide(point, 300, swipeInfo);
	                        // second step
	                        requestAnimationFrame(function () {
	                            // in case the user is now scrolling in the opposite direction stop the slide
	                            if (!_this.didUserChangeDirection(swipeInfo)) {
	                                _this.slide(point, 200, swipeInfo);
	                            }
	                            _this.clearSlide();
	                        });
	                    };
	                    TouchEventInterpreter.prototype.didUserChangeDirection = function (swipeInfo) {
	                        if (this.touchStartTime <= swipeInfo.endTime) {
	                            return false;
	                        }
	                        var updatedDist = this.touchLastPageY - this.touchStartPageY;
	                        var updatedDirection = updatedDist < 0 ? -1 : 1;
	                        return updatedDirection !== swipeInfo.direction;
	                    };
	                    TouchEventInterpreter.prototype.slide = function (point, slideDist, swipeInfo) {
	                        var updatedDist = this.touchStartTime > swipeInfo.endTime ? this.touchLastPageY - this.touchStartPageY : 0;
	                        point.y += slideDist * swipeInfo.direction + updatedDist;
	                        var event = new TouchEvent(point.x / this.scale, point.y / this.scale, true);
	                        this.manager.touchEvent(event);
	                    };
	                    TouchEventInterpreter.prototype.clearSlide = function () {
	                        this.sliding = false;
	                        this.upAllTouches();
	                    };
	                    TouchEventInterpreter.prototype.upAllTouches = function () {
	                        if (this.documentMouseMoveWrapper !== null)
	                            return;
	                        this.rect = null;
	                        this.manager.upAllTouches();
	                    };
	                    TouchEventInterpreter.prototype.clearTouchEvents = function () {
	                        if ("releaseCapture" in this.touchPanel) {
	                            this.touchPanel.releaseCapture();
	                        }
	                        if (this.documentMouseMoveWrapper === null)
	                            return;
	                        if ("ontouchmove" in this.touchPanel) {
	                            document.removeEventListener("touchmove", this.documentMouseMoveWrapper);
	                            document.removeEventListener("touchend", this.documentMouseUpWrapper);
	                        }
	                        else {
	                            document.removeEventListener("mousemove", this.documentMouseMoveWrapper);
	                            document.removeEventListener("mouseup", this.documentMouseUpWrapper);
	                        }
	                        this.documentMouseMoveWrapper = null;
	                        this.documentMouseUpWrapper = null;
	                    };
	                    return TouchEventInterpreter;
	                }());
	                TouchUtils.TouchEventInterpreter = TouchEventInterpreter;
	            })(TouchUtils = controls.TouchUtils || (controls.TouchUtils = {}));
	        })(controls = visuals.controls || (visuals.controls = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 248 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var controls;
	        (function (controls) {
	            (function (TablixType) {
	                TablixType[TablixType["Matrix"] = 0] = "Matrix";
	                TablixType[TablixType["Table"] = 1] = "Table";
	            })(controls.TablixType || (controls.TablixType = {}));
	            var TablixType = controls.TablixType;
	        })(controls = visuals.controls || (visuals.controls = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 249 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var controls;
	        (function (controls) {
	            var PropAutoSizeWidth = controls.internal.TablixObjects.PropGeneralAutoSizeColumns;
	            var getMetadataObjects = controls.internal.TablixObjects.getMetadadataObjects;
	            var TablixColumnWidthManager = (function () {
	                function TablixColumnWidthManager(dataView, isMatrix, hostPersistCallBack, matrixLeafNodes) {
	                    this.columnWidthObjects = {};
	                    this.isMatrix = isMatrix;
	                    this.updateDataView(dataView, matrixLeafNodes);
	                    this.hostPersistCallBack = hostPersistCallBack;
	                    this.visualObjectInstancesToPersist = { merge: [], remove: [] };
	                }
	                // #region Update DataView
	                /**
	                 * Update the current DataView
	                 * @param {dataView} DataView new DataView
	                 * @param {MatrixVisualNode[]} matrixLeafNodes? (Optional)Matrix Leaf Nodes
	                 */
	                TablixColumnWidthManager.prototype.updateDataView = function (dataView, matrixLeafNodes) {
	                    this.previousDataView = this.currentDataView;
	                    if (this.previousDataView)
	                        this.previousAutoColumnSizePropertyValue = PropAutoSizeWidth.getValue(getMetadataObjects(this.previousDataView));
	                    else
	                        this.previousAutoColumnSizePropertyValue = undefined;
	                    this.currentDataView = dataView;
	                    if (this.currentDataView)
	                        this.currentAutoColumnSizePropertyValue = PropAutoSizeWidth.getValue(getMetadataObjects(this.currentDataView));
	                    else
	                        this.currentAutoColumnSizePropertyValue = undefined;
	                    this.matrixLeafNodes = matrixLeafNodes;
	                    this.updateColumnsMetadata();
	                    this.updateTablixColumnWidths();
	                };
	                /**
	                * Destroy columnWidthObjects and construct it again from the currently displayed Columns with initial width undefined
	                */
	                TablixColumnWidthManager.prototype.updateColumnsMetadata = function () {
	                    this.columnWidthObjects = {};
	                    if (this.isMatrix)
	                        this.updateMatrixColumnsMetadata();
	                    else
	                        this.updateTableColumnsMetadata();
	                };
	                TablixColumnWidthManager.prototype.updateTableColumnsMetadata = function () {
	                    if (this.currentDataView && this.currentDataView.table) {
	                        var columnMetaData = this.currentDataView.table.columns;
	                        for (var i = 0, len = columnMetaData.length; i < len; i++) {
	                            var queryName = columnMetaData[i].queryName;
	                            if (queryName)
	                                this.columnWidthObjects[queryName] = {
	                                    queryName: queryName,
	                                    width: undefined,
	                                    isFixed: false
	                                };
	                        }
	                    }
	                };
	                TablixColumnWidthManager.prototype.updateMatrixColumnsMetadata = function () {
	                    // Matrix visual columns are row headers and column hierarchy leaves
	                    if (this.currentDataView && this.currentDataView.matrix && this.currentDataView.matrix.rows) {
	                        // Get query names of row groups (row headers)
	                        // queryName is undefined for composite-group
	                        for (var i = 0, len = this.currentDataView.matrix.rows.levels.length; i < len; i++) {
	                            var rowGroup = this.currentDataView.matrix.rows.levels[i];
	                            if (rowGroup.sources.length === 1) {
	                                var queryName = rowGroup.sources[0].queryName;
	                                if (queryName)
	                                    this.columnWidthObjects[queryName] = {
	                                        queryName: queryName,
	                                        width: undefined,
	                                        isFixed: false
	                                    };
	                            }
	                        }
	                    }
	                    // Get query names of columns leaves or values
	                    // queryName is undefined for composite-group
	                    if (this.matrixLeafNodes) {
	                        for (var i = 0, len = this.matrixLeafNodes.length; i < len; i++) {
	                            var queryName = this.matrixLeafNodes[i].queryName;
	                            if (queryName)
	                                this.columnWidthObjects[queryName] = {
	                                    queryName: queryName,
	                                    width: undefined,
	                                    isFixed: false
	                                };
	                        }
	                    }
	                };
	                /**
	                 * Update the column widths after a dataViewChange
	                 */
	                TablixColumnWidthManager.prototype.updateTablixColumnWidths = function () {
	                    var columnMetaData = this.currentDataView && this.currentDataView.metadata && this.currentDataView.metadata.columns;
	                    if (columnMetaData) {
	                        // Auto-Size false to true.
	                        // Blow away any saved widths and revert back to default of calculating column sizes
	                        if (this.shouldClearAllColumnWidths()) {
	                            this.autoSizeAllColumns();
	                            return;
	                        }
	                        else {
	                            this.deserializeColumnsWidth(columnMetaData);
	                        }
	                    }
	                };
	                /**
	                 * Remove all persisted columns widths and Update visualObjectInstancesToPersist
	                 */
	                TablixColumnWidthManager.prototype.autoSizeAllColumns = function () {
	                    for (var queryName in this.columnWidthObjects) {
	                        this.visualObjectInstancesToPersist.remove.push(this.generateColumnWidthObjectToPersist(queryName, undefined));
	                    }
	                    this.callHostToPersist();
	                };
	                /**
	                 * Read the Column Widths from the Columns metadata
	                 * @param {DataViewMetadataColumn[]} columnMetadata Columns metadata
	                 */
	                TablixColumnWidthManager.prototype.deserializeColumnsWidth = function (columnsMetadata) {
	                    // Clear existing widths
	                    for (var colObj in this.columnWidthObjects) {
	                        this.columnWidthObjects[colObj].isFixed = !this.currentAutoColumnSizePropertyValue;
	                        this.columnWidthObjects[colObj].width = undefined;
	                    }
	                    for (var i = 0, len = columnsMetadata.length; i < len; i++) {
	                        var column = columnsMetadata[i];
	                        var queryName = column.queryName;
	                        var width = powerbi.DataViewObjects.getValue(column.objects, TablixColumnWidthManager.columnWidthProp);
	                        if (this.columnWidthObjects.hasOwnProperty(queryName) && width != null) {
	                            this.columnWidthObjects[queryName].width = width;
	                            this.columnWidthObjects[queryName].isFixed = true;
	                        }
	                    }
	                };
	                // #endregion
	                // #region AutoSize toggle
	                /**
	                 * Returns a value indicating that autoSizeColumns was flipped from true to false
	                 */
	                TablixColumnWidthManager.prototype.shouldPersistAllColumnWidths = function () {
	                    // We don't have a previous DataView -> Don't persist
	                    if (!this.previousDataView)
	                        return false;
	                    else
	                        return !this.currentAutoColumnSizePropertyValue && this.previousAutoColumnSizePropertyValue;
	                };
	                /**
	                 * Returns a value indicating that autoSizeColumns was flipped from false to true
	                 */
	                TablixColumnWidthManager.prototype.shouldClearAllColumnWidths = function () {
	                    return this.previousDataView != null && this.previousAutoColumnSizePropertyValue === false
	                        && this.currentDataView != null && this.currentAutoColumnSizePropertyValue === true;
	                };
	                // #endregion
	                /**
	                * Gets the QueryName associated with a Column (Column Header or Corner Item)
	                * @param {internal.TablixColumn} column TablixColumn
	                * @returns queryName
	                */
	                TablixColumnWidthManager.getColumnQueryName = function (column) {
	                    var headerCell = column.getTablixCell();
	                    switch (headerCell.type) {
	                        case 0 /* CornerCell */:
	                            if (headerCell.item == null // Corner item for Table hidden column
	                                || headerCell.item.metadata == null)
	                                return undefined;
	                            return headerCell.item.metadata.queryName;
	                        case 2 /* ColumnHeader */:
	                            debug.assert(headerCell.item != null, "Tablix Column without a ColumnMetadata");
	                            return headerCell.item.queryName;
	                        default:
	                            debug.assertFail("getColumnQueryName called with cellType: " + headerCell.type);
	                            return undefined;
	                    }
	                };
	                /**
	                 * Returns the current columnWidthObjects
	                 * @returns current columnWidthObjects including undefined widths for autosized or unknown columns
	                 */
	                TablixColumnWidthManager.prototype.getColumnWidthObjects = function () {
	                    return this.columnWidthObjects;
	                };
	                /**
	                 * Returns the current columnWidthObjects for only the fixed-size columns
	                 * @returns Returns the current columnWidthObjects excluding auto-sized columns
	                 */
	                TablixColumnWidthManager.prototype.getFixedColumnWidthObjects = function () {
	                    var fixedOnly = {};
	                    for (var queryName in this.columnWidthObjects) {
	                        var obj = this.columnWidthObjects[queryName];
	                        if (obj.isFixed) {
	                            fixedOnly[queryName] = obj;
	                        }
	                    }
	                    return fixedOnly;
	                };
	                /**
	                 * Get the persisted width of a certain column in px, or undefined if the columns is set to autosize or queryName is not found
	                 * @param {string} queryName queryName of the Column
	                 * @returns Column persisted width in pixel
	                 */
	                TablixColumnWidthManager.prototype.getPersistedColumnWidth = function (queryName) {
	                    var obj = this.columnWidthObjects[queryName];
	                    return obj && obj.width;
	                };
	                /**
	                 * Call the host to persist the data
	                 * @param {boolean} generateInstances
	                 */
	                TablixColumnWidthManager.prototype.callHostToPersist = function () {
	                    if (this.hostPersistCallBack) {
	                        this.hostPersistCallBack(this.visualObjectInstancesToPersist);
	                    }
	                    // Clears persisted objects list
	                    this.visualObjectInstancesToPersist = {
	                        merge: [],
	                        remove: [],
	                    };
	                };
	                /**
	                 * Handler for a column width change by the user
	                 * @param {string} queryName queryName of the Column
	                 * @param {number} width new width
	                 */
	                TablixColumnWidthManager.prototype.onColumnWidthChanged = function (queryName, width) {
	                    // Resizing an invalid column
	                    if (queryName == null || this.columnWidthObjects[queryName] == null)
	                        return;
	                    var resizedColumn = this.columnWidthObjects[queryName];
	                    if (width === -1) {
	                        // If AutoSize option is ON, remove the persisted value
	                        // Else, set value to unknown and expect to be called again soon
	                        resizedColumn.width = undefined;
	                        resizedColumn.isFixed = !this.currentAutoColumnSizePropertyValue;
	                        // Call persist anyway, if isFixed is true, it will be assined to the rendered width
	                        this.visualObjectInstancesToPersist.remove.push(this.generateColumnWidthObjectToPersist(resizedColumn.queryName, undefined));
	                        this.callHostToPersist();
	                    }
	                    else {
	                        resizedColumn.width = width;
	                        resizedColumn.isFixed = true;
	                        this.visualObjectInstancesToPersist.merge.push(this.generateColumnWidthObjectToPersist(queryName, width));
	                        this.callHostToPersist();
	                    }
	                };
	                /**
	                 * Event handler after rendering all columns. Setting any unknown column width.
	                 * Returns True if it calls persist
	                 * @param renderedColumns Rendered Columns
	                 */
	                TablixColumnWidthManager.prototype.onColumnsRendered = function (renderedColumns) {
	                    // Pick the maximum width for each queryName
	                    // This will ensure going from autoSize ON to OFF will not show any ellipsis
	                    var maxWidths = {};
	                    for (var i = 0, len = renderedColumns.length; i < len; i++) {
	                        var queryName = renderedColumns[i].queryName;
	                        var newWidth = renderedColumns[i].width;
	                        if (maxWidths[queryName] == null) {
	                            maxWidths[queryName] = {
	                                queryName: queryName,
	                                width: newWidth,
	                                isFixed: false // Unused
	                            };
	                        }
	                        else if (newWidth > maxWidths[queryName].width) {
	                            maxWidths[queryName].width = newWidth;
	                        }
	                    }
	                    var widthChanged = false;
	                    for (var queryName in this.columnWidthObjects) {
	                        if (maxWidths[queryName]) {
	                            var colWidthObj = this.columnWidthObjects[queryName];
	                            if (colWidthObj.isFixed && colWidthObj.width == null) {
	                                colWidthObj.width = maxWidths[queryName].width;
	                                this.visualObjectInstancesToPersist.merge.push(this.generateColumnWidthObjectToPersist(queryName, colWidthObj.width));
	                                widthChanged = true;
	                            }
	                        }
	                    }
	                    if (widthChanged)
	                        this.callHostToPersist();
	                    return widthChanged;
	                };
	                TablixColumnWidthManager.prototype.generateColumnWidthObjectToPersist = function (queryName, width) {
	                    return {
	                        selector: { metadata: queryName },
	                        objectName: 'general',
	                        properties: { columnWidth: width }
	                    };
	                };
	                /**
	                * PropertyID for Column Widths (General > columnWidth)
	                */
	                TablixColumnWidthManager.columnWidthProp = { objectName: 'general', propertyName: 'columnWidth' };
	                return TablixColumnWidthManager;
	            }());
	            controls.TablixColumnWidthManager = TablixColumnWidthManager;
	        })(controls = visuals.controls || (visuals.controls = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 250 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        /**
	         * Base class for values that are animated when resized.
	         */
	        var AnimatedText = (function () {
	            function AnimatedText(name) {
	                this.mainText = jsCommon.CssConstants.createClassAndSelector('mainText');
	                this.name = name;
	                this.visualConfiguration = { maxFontSize: 60 };
	            }
	            AnimatedText.prototype.getMetaDataColumn = function (dataView) {
	                if (dataView && dataView.metadata && dataView.metadata.columns) {
	                    for (var i = 0, ilen = dataView.metadata.columns.length; i < ilen; i++) {
	                        var column = dataView.metadata.columns[i];
	                        if (column.isMeasure) {
	                            this.metaDataColumn = column;
	                            break;
	                        }
	                    }
	                }
	            };
	            AnimatedText.prototype.getAdjustedFontHeight = function (availableWidth, textToMeasure, seedFontHeight) {
	                var textProperties = {
	                    fontFamily: null,
	                    fontSize: null,
	                    text: textToMeasure
	                };
	                var fontHeight = this.getAdjustedFontHeightCore(textProperties, availableWidth, seedFontHeight, 0);
	                return fontHeight;
	            };
	            AnimatedText.prototype.getAdjustedFontHeightCore = function (textProperties, availableWidth, seedFontHeight, iteration) {
	                // Too many attempts - just return what we have so we don't sacrifice perf
	                if (iteration > 10) {
	                    return seedFontHeight;
	                }
	                textProperties.fontSize = jsCommon.PixelConverter.toString(seedFontHeight);
	                var candidateLength = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
	                if (candidateLength < availableWidth)
	                    return seedFontHeight;
	                return this.getAdjustedFontHeightCore(textProperties, availableWidth, seedFontHeight * 0.9, iteration + 1);
	            };
	            AnimatedText.prototype.clear = function () {
	                this.svg.select(this.mainText.selector).text('');
	            };
	            AnimatedText.prototype.doValueTransition = function (startValue, endValue, displayUnitSystemType, animationOptions, duration, forceUpdate, formatter) {
	                if (!forceUpdate && startValue === endValue && endValue != null)
	                    return;
	                if (!startValue)
	                    startValue = 0;
	                var svg = this.svg, viewport = this.currentViewport, height = viewport.height, width = viewport.width, endValueArr = [endValue], seedFontHeight = this.getSeedFontHeight(width, height), translateX = this.getTranslateX(width), translateY = this.getTranslateY(seedFontHeight), metaDataColumn = this.metaDataColumn;
	                // Respect the formatter default value
	                if (!formatter) {
	                    formatter = visuals.valueFormatter.create({
	                        format: this.getFormatString(metaDataColumn),
	                        value: endValue,
	                        displayUnitSystemType: displayUnitSystemType,
	                        formatSingleValues: true,
	                        allowFormatBeautification: true,
	                        columnType: metaDataColumn ? metaDataColumn.type : undefined
	                    });
	                }
	                var startText = formatter.format(startValue), endText = formatter.format(endValue);
	                svg.attr('class', this.name);
	                var textElement = svg
	                    .selectAll('text')
	                    .data(endValueArr);
	                textElement
	                    .enter()
	                    .append('text')
	                    .attr('class', this.mainText.class);
	                var fontHeight = this.getAdjustedFontHeight(width, endText, seedFontHeight);
	                translateY = this.getTranslateY(fontHeight + (height - fontHeight) / 2);
	                var textElementUpdate = textElement
	                    .text(startText)
	                    .attr({
	                    'text-anchor': this.getTextAnchor(),
	                    'font-size': fontHeight,
	                    'transform': visuals.SVGUtil.translate(translateX, translateY),
	                })
	                    .style({
	                    'fill': this.style.titleText.color.value,
	                })
	                    .call(visuals.tooltipUtils.tooltipUpdate, [startText]);
	                if (endValue == null) {
	                    textElementUpdate.text(endText).call(visuals.tooltipUtils.tooltipUpdate, [endText]);
	                }
	                else if (metaDataColumn && visuals.AxisHelper.isDateTime(metaDataColumn.type)) {
	                    textElementUpdate.text(endText).call(visuals.tooltipUtils.tooltipUpdate, [endText]);
	                }
	                else {
	                    var interpolatedValue_1 = startValue;
	                    textElementUpdate
	                        .transition()
	                        .duration(duration)
	                        .tween('text', function (d) {
	                        var i = d3.interpolate(interpolatedValue_1, d);
	                        return function (t) {
	                            var num = i(t);
	                            this.textContent = formatter.format(num);
	                        };
	                    });
	                }
	                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(animationOptions);
	            };
	            AnimatedText.prototype.setTextColor = function (color) {
	                this.style.titleText.color.value = color;
	            };
	            AnimatedText.prototype.getSeedFontHeight = function (boundingWidth, boundingHeight) {
	                // Simply an estimate - it should eventually be modified based on the actual text length
	                var estimatedSize = Math.floor(Math.min(boundingWidth, boundingHeight) * 0.75);
	                var maxFontSize = this.visualConfiguration.maxFontSize;
	                if (maxFontSize)
	                    return Math.min(maxFontSize, estimatedSize);
	                return estimatedSize;
	            };
	            AnimatedText.prototype.getTranslateX = function (width) {
	                if (this.visualConfiguration) {
	                    switch (this.visualConfiguration.align) {
	                        case 'left':
	                            return 0;
	                        case 'right':
	                            return width;
	                    }
	                }
	                return width / 2;
	            };
	            AnimatedText.prototype.getTranslateY = function (height) {
	                return height;
	            };
	            AnimatedText.prototype.getTextAnchor = function () {
	                if (this.visualConfiguration) {
	                    switch (this.visualConfiguration.align) {
	                        case 'left':
	                            return 'start';
	                        case 'right':
	                            return 'end';
	                    }
	                }
	                return 'middle';
	            };
	            AnimatedText.prototype.getFormatString = function (column) {
	                debug.assertAnyValue(column, 'column');
	                return visuals.valueFormatter.getFormatString(column, AnimatedText.formatStringProp);
	            };
	            /** Note: Public for testability */
	            AnimatedText.formatStringProp = {
	                objectName: 'general',
	                propertyName: 'formatString',
	            };
	            return AnimatedText;
	        }());
	        visuals.AnimatedText = AnimatedText;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 251 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        /**
	         * Renders a number that can be animate change in value.
	         */
	        var AnimatedNumber = (function (_super) {
	            __extends(AnimatedNumber, _super);
	            function AnimatedNumber(svg, animator) {
	                _super.call(this, 'animatedNumber');
	                if (svg)
	                    this.svg = svg;
	                if (animator)
	                    this.animator = animator;
	            }
	            AnimatedNumber.prototype.init = function (options) {
	                this.options = options;
	                var element = options.element;
	                if (!this.svg)
	                    this.svg = d3.select(element.get(0)).append('svg');
	                this.currentViewport = options.viewport;
	                this.hostServices = options.host;
	                this.style = options.style;
	                this.updateViewportDependantProperties();
	            };
	            AnimatedNumber.prototype.updateViewportDependantProperties = function () {
	                var viewport = this.currentViewport;
	                this.svg.attr('width', viewport.width)
	                    .attr('height', viewport.height);
	            };
	            AnimatedNumber.prototype.update = function (options) {
	                debug.assertValue(options, 'options');
	                this.currentViewport = options.viewport;
	                var dataViews = this.dataViews = options.dataViews;
	                if (!dataViews || !dataViews[0]) {
	                    return;
	                }
	                var dataView = dataViews[0];
	                this.updateViewportDependantProperties();
	                this.getMetaDataColumn(dataView);
	                var newValue = dataView && dataView.single ? dataView.single.value : 0;
	                this.updateInternal(newValue, options.suppressAnimations, true, this.formatter);
	            };
	            AnimatedNumber.prototype.setFormatter = function (formatter) {
	                this.formatter = formatter;
	            };
	            AnimatedNumber.prototype.onDataChanged = function (options) {
	                // TODO: Remove onDataChanged & onResizing once all visuals have implemented update.
	                this.update({
	                    dataViews: options.dataViews,
	                    suppressAnimations: options.suppressAnimations,
	                    viewport: this.currentViewport
	                });
	            };
	            AnimatedNumber.prototype.onResizing = function (viewport) {
	                // TODO: Remove onDataChanged & onResizing once all visuals have implemented update.
	                this.update({
	                    dataViews: this.dataViews,
	                    suppressAnimations: true,
	                    viewport: viewport
	                });
	            };
	            AnimatedNumber.prototype.canResizeTo = function (viewport) {
	                // Temporarily disabling resize restriction.
	                return true;
	            };
	            AnimatedNumber.prototype.updateInternal = function (target, suppressAnimations, forceUpdate, formatter) {
	                if (forceUpdate === void 0) { forceUpdate = false; }
	                var start = this.value;
	                var duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
	                this.doValueTransition(start, target, 
	                /*displayUnitSystemType*/ null, this.options.animation, duration, forceUpdate, formatter);
	                this.value = target;
	            };
	            return AnimatedNumber;
	        }(visuals.AnimatedText));
	        visuals.AnimatedNumber = AnimatedNumber;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 252 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var BasicShapeVisual = (function () {
	            function BasicShapeVisual(options) {
	            }
	            Object.defineProperty(BasicShapeVisual.prototype, "shapeType", {
	                /**property for the shape line color */
	                get: function () {
	                    return this.data.shapeType;
	                },
	                set: function (shapeType) {
	                    this.data.shapeType = shapeType;
	                },
	                enumerable: true,
	                configurable: true
	            });
	            Object.defineProperty(BasicShapeVisual.prototype, "lineColor", {
	                /**property for the shape line color */
	                get: function () {
	                    return this.data ? this.data.lineColor : BasicShapeVisual.DefaultStrokeColor;
	                },
	                set: function (color) {
	                    this.data.lineColor = color;
	                },
	                enumerable: true,
	                configurable: true
	            });
	            Object.defineProperty(BasicShapeVisual.prototype, "lineTransparency", {
	                /**property for the shape line transparency */
	                get: function () {
	                    return this.data ? this.data.lineTransparency : BasicShapeVisual.DefaultLineTransValue;
	                },
	                set: function (trans) {
	                    this.data.lineTransparency = trans;
	                },
	                enumerable: true,
	                configurable: true
	            });
	            Object.defineProperty(BasicShapeVisual.prototype, "lineWeight", {
	                /**property for the shape line weight */
	                get: function () {
	                    return this.data ? this.data.lineWeight : BasicShapeVisual.DefaultWeightValue;
	                },
	                set: function (weight) {
	                    this.data.lineWeight = weight;
	                },
	                enumerable: true,
	                configurable: true
	            });
	            Object.defineProperty(BasicShapeVisual.prototype, "roundEdge", {
	                /**property for the shape round edge */
	                get: function () {
	                    return this.data ? this.data.roundEdge : BasicShapeVisual.DefaultRoundEdgeValue;
	                },
	                set: function (roundEdge) {
	                    this.data.roundEdge = roundEdge;
	                },
	                enumerable: true,
	                configurable: true
	            });
	            Object.defineProperty(BasicShapeVisual.prototype, "showFill", {
	                /**property for showing the fill properties */
	                get: function () {
	                    return this.data ? this.data.showFill : BasicShapeVisual.DefaultFillShowValue;
	                },
	                set: function (show) {
	                    this.data.showFill = show;
	                },
	                enumerable: true,
	                configurable: true
	            });
	            Object.defineProperty(BasicShapeVisual.prototype, "fillColor", {
	                /**property for the shape line color */
	                get: function () {
	                    return this.data ? this.data.fillColor : BasicShapeVisual.DefaultFillColor;
	                },
	                set: function (color) {
	                    this.data.fillColor = color;
	                },
	                enumerable: true,
	                configurable: true
	            });
	            Object.defineProperty(BasicShapeVisual.prototype, "shapeTransparency", {
	                /**property for the shape fill transparency */
	                get: function () {
	                    return this.data ? this.data.shapeTransparency : BasicShapeVisual.DefaultFillTransValue;
	                },
	                set: function (trans) {
	                    this.data.shapeTransparency = trans;
	                },
	                enumerable: true,
	                configurable: true
	            });
	            Object.defineProperty(BasicShapeVisual.prototype, "angle", {
	                /**property for the shape angle */
	                get: function () {
	                    return this.data ? this.data.angle : BasicShapeVisual.DefaultAngle;
	                },
	                set: function (angle) {
	                    this.data.angle = this.scaleTo360Deg(angle);
	                },
	                enumerable: true,
	                configurable: true
	            });
	            BasicShapeVisual.prototype.init = function (options) {
	                this.element = options.element;
	                this.selection = d3.select(this.element.context);
	                this.currentViewport = options.viewport;
	            };
	            BasicShapeVisual.prototype.update = function (options) {
	                debug.assertValue(options, 'options');
	                this.currentViewport = options.viewport;
	                var dataViews = options.dataViews;
	                if (!_.isEmpty(dataViews)) {
	                    var dataView = options.dataViews[0];
	                    if (dataView.metadata && dataView.metadata.objects) {
	                        var dataViewObject = options.dataViews[0].metadata.objects;
	                        this.data = this.getDataFromDataView(dataViewObject);
	                        this.render();
	                    }
	                }
	            };
	            BasicShapeVisual.prototype.getDataFromDataView = function (dataViewObject) {
	                if (dataViewObject) {
	                    return {
	                        shapeType: powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.general.shapeType, BasicShapeVisual.DefaultShape),
	                        lineColor: this.getValueFromColor(powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.line.lineColor, BasicShapeVisual.DefaultStrokeColor)),
	                        lineTransparency: powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.line.transparency, BasicShapeVisual.DefaultLineTransValue),
	                        lineWeight: powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.line.weight, BasicShapeVisual.DefaultWeightValue),
	                        roundEdge: powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.line.roundEdge, BasicShapeVisual.DefaultRoundEdgeValue),
	                        shapeTransparency: powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.fill.transparency, BasicShapeVisual.DefaultFillTransValue),
	                        fillColor: this.getValueFromColor(powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.fill.fillColor, BasicShapeVisual.DefaultFillColor)),
	                        showFill: powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.fill.show, BasicShapeVisual.DefaultFillShowValue),
	                        angle: this.scaleTo360Deg(powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.rotation.angle, BasicShapeVisual.DefaultAngle))
	                    };
	                }
	                return null;
	            };
	            BasicShapeVisual.prototype.scaleTo360Deg = function (angle) {
	                if (angle !== 0 && (Math.abs(angle) % 360) === 0)
	                    return angle;
	                angle = angle % 360;
	                angle = (angle + 360) % 360;
	                return angle;
	            };
	            BasicShapeVisual.prototype.getValueFromColor = function (color) {
	                return color.solid ? color.solid.color : color;
	            };
	            BasicShapeVisual.prototype.enumerateObjectInstances = function (options) {
	                var objectInstances = [];
	                if (!this.data) {
	                    return objectInstances;
	                }
	                switch (options.objectName) {
	                    case 'line':
	                        var instance = {
	                            selector: null,
	                            properties: {
	                                lineColor: this.lineColor,
	                                transparency: this.lineTransparency,
	                                weight: this.lineWeight
	                            },
	                            objectName: options.objectName
	                        };
	                        if (this.shapeType === visuals.basicShapeType.rectangle) {
	                            instance.properties['roundEdge'] = this.roundEdge;
	                        }
	                        objectInstances.push(instance);
	                        return objectInstances;
	                    case 'fill':
	                        if (this.shapeType !== visuals.basicShapeType.line) {
	                            objectInstances.push({
	                                selector: null,
	                                properties: {
	                                    show: this.showFill,
	                                    fillColor: this.fillColor,
	                                    transparency: this.shapeTransparency
	                                },
	                                objectName: options.objectName
	                            });
	                        }
	                        return objectInstances;
	                    case 'rotation':
	                        objectInstances.push({
	                            selector: null,
	                            properties: {
	                                angle: this.angle
	                            },
	                            objectName: options.objectName
	                        });
	                        return objectInstances;
	                }
	                return null;
	            };
	            BasicShapeVisual.prototype.render = function () {
	                this.selection.html('');
	                switch (this.shapeType) {
	                    case visuals.basicShapeType.rectangle:
	                        visuals.ShapeFactory.createRectangle(this.data, this.currentViewport.height, this.currentViewport.width, this.selection, this.angle);
	                        break;
	                    case visuals.basicShapeType.oval:
	                        visuals.ShapeFactory.createOval(this.data, this.currentViewport.height, this.currentViewport.width, this.selection, this.angle);
	                        break;
	                    case visuals.basicShapeType.line:
	                        visuals.ShapeFactory.createLine(this.data, this.currentViewport.height, this.currentViewport.width, this.selection, this.angle);
	                        break;
	                    case visuals.basicShapeType.arrow:
	                        visuals.ShapeFactory.createUpArrow(this.data, this.currentViewport.height, this.currentViewport.width, this.selection, this.angle);
	                        break;
	                    case visuals.basicShapeType.triangle:
	                        visuals.ShapeFactory.createTriangle(this.data, this.currentViewport.height, this.currentViewport.width, this.selection, this.angle);
	                        break;
	                    default:
	                        break;
	                }
	            };
	            BasicShapeVisual.DefaultShape = visuals.basicShapeType.rectangle;
	            BasicShapeVisual.DefaultStrokeColor = '#00B8AA';
	            BasicShapeVisual.DefaultFillColor = '#E6E6E6';
	            BasicShapeVisual.DefaultFillShowValue = true;
	            BasicShapeVisual.DefaultFillTransValue = 0;
	            BasicShapeVisual.DefaultWeightValue = 3;
	            BasicShapeVisual.DefaultLineTransValue = 0;
	            BasicShapeVisual.DefaultRoundEdgeValue = 0;
	            BasicShapeVisual.DefaultAngle = 0;
	            return BasicShapeVisual;
	        }());
	        visuals.BasicShapeVisual = BasicShapeVisual;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 253 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var EnumExtensions = jsCommon.EnumExtensions;
	        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
	        var DEFAULT_AXIS_SCALE_TYPE = visuals.axisScale.linear;
	        var COMBOCHART_DOMAIN_OVERLAP_TRESHOLD_PERCENTAGE = 0.1;
	        // the interactive right margin is set to be the circle selection radius of the hover line
	        var INTERACTIVITY_RIGHT_MARGIN = 6;
	        visuals.DEFAULT_AXIS_COLOR = '#777';
	        /**
	         * Renders a data series as a cartestian visual.
	         */
	        var CartesianChart = (function () {
	            function CartesianChart(options) {
	                this.xRefLine = createClassAndSelector('x-ref-line');
	                this.y1RefLine = createClassAndSelector('y1-ref-line');
	                var isScrollable = false;
	                this.trimOrdinalDataOnOverflow = true;
	                if (options) {
	                    this.tooltipsEnabled = options.tooltipsEnabled;
	                    this.tooltipBucketEnabled = options.tooltipBucketEnabled;
	                    this.forecastEnabled = options.forecastEnabled;
	                    this.type = options.chartType;
	                    this.isLabelInteractivityEnabled = options.isLabelInteractivityEnabled;
	                    this.advancedLineLabelsEnabled = options.advancedLineLabelsEnabled;
	                    if (options.trimOrdinalDataOnOverflow !== undefined)
	                        this.trimOrdinalDataOnOverflow = options.trimOrdinalDataOnOverflow;
	                    if (options.isScrollable)
	                        isScrollable = options.isScrollable;
	                    this.animator = options.animator;
	                    if (options.cartesianSmallViewPortProperties) {
	                        this.cartesianSmallViewPortProperties = options.cartesianSmallViewPortProperties;
	                    }
	                    if (options.behavior) {
	                        this.behavior = options.behavior;
	                    }
	                }
	                this.axes = new CartesianAxes(isScrollable, ScrollableAxes.ScrollbarWidth, this.trimOrdinalDataOnOverflow);
	                this.svgAxes = new SvgCartesianAxes(this.axes);
	                this.svgBrush = new SvgBrush(ScrollableAxes.ScrollbarWidth);
	                this.scrollableAxes = new ScrollableAxes(this.axes, this.svgBrush);
	            }
	            CartesianChart.getAxisVisibility = function (type) {
	                switch (type) {
	                    case 6 /* StackedBar */:
	                    case 5 /* ClusteredBar */:
	                    case 7 /* HundredPercentStackedBar */:
	                        return 1 /* ShowLinesOnXAxis */;
	                    case 9 /* Scatter */:
	                        return 3 /* ShowLinesOnBothAxis */;
	                    default:
	                        return 2 /* ShowLinesOnYAxis */;
	                }
	            };
	            CartesianChart.prototype.init = function (options) {
	                this.visualInitOptions = options;
	                this.layers = [];
	                var element = this.element = options.element;
	                this.currentViewport = options.viewport;
	                this.hostServices = options.host;
	                var chartAreaSvg = this.chartAreaSvg = d3.select(element.get(0)).append('svg');
	                chartAreaSvg.classed(CartesianChart.ClassName, true);
	                chartAreaSvg.style('position', 'absolute');
	                if (this.behavior) {
	                    this.clearCatcher = visuals.appendClearCatcher(chartAreaSvg);
	                    this.interactivityService = visuals.createInteractivityService(this.hostServices);
	                }
	                if (options.style.maxMarginFactor != null)
	                    this.axes.setMaxMarginFactor(options.style.maxMarginFactor);
	                var axisLinesVisibility = CartesianChart.getAxisVisibility(this.type);
	                this.axes.setAxisLinesVisibility(axisLinesVisibility);
	                this.svgAxes.init(chartAreaSvg);
	                this.svgBrush.init(chartAreaSvg);
	                this.sharedColorPalette = new SharedColorPalette(options.style.colorPalette.dataColors);
	                this.legend = visuals.createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, this.type !== 12 /* Waterfall */ ? this.interactivityService : undefined, this.axes.isScrollable);
	                this.isMobileChart = options.interactivity && options.interactivity.isInteractiveLegend;
	            };
	            CartesianChart.prototype.isPlayAxis = function () {
	                if (!this.dataViews || !this.dataViews[0])
	                    return false;
	                var dataView = this.dataViews[0];
	                var categoryRoleIsPlay = dataView.categorical
	                    && dataView.categorical.categories
	                    && dataView.categorical.categories[0]
	                    && dataView.categorical.categories[0].source
	                    && dataView.categorical.categories[0].source.roles
	                    && dataView.categorical.categories[0].source.roles['Play'];
	                return this.type === 9 /* Scatter */
	                    && (this.animator || this.isMobileChart)
	                    && dataView.matrix != null
	                    && (!dataView.categorical || categoryRoleIsPlay);
	            };
	            CartesianChart.getIsScalar = function (objects, propertyId, type, scalarKeys) {
	                if (!CartesianChart.supportsScalar(type, scalarKeys))
	                    return false;
	                var axisTypeValue = powerbi.DataViewObjects.getValue(objects, propertyId);
	                if (!objects || axisTypeValue == null)
	                    return true;
	                return (axisTypeValue === visuals.axisType.scalar);
	            };
	            CartesianChart.supportsScalar = function (type, scalarKeys) {
	                // if scalar key is present, it supports scalar
	                if (scalarKeys && !_.isEmpty(scalarKeys.values))
	                    return true;
	                // otherwise does not support scalar if the type is non-numeric.
	                return !visuals.AxisHelper.isOrdinal(type);
	            };
	            CartesianChart.getAdditionalTelemetry = function (dataView) {
	                var telemetry = {};
	                var categoryColumn = dataView && dataView.categorical && _.first(dataView.categorical.categories);
	                if (categoryColumn) {
	                    telemetry.axisType = visuals.CartesianChart.getIsScalar(dataView.metadata.objects, visuals.columnChartProps.categoryAxis.axisType, categoryColumn.source.type)
	                        ? 'scalar'
	                        : 'categorical';
	                }
	                return telemetry;
	            };
	            CartesianChart.detectScalarMapping = function (dataViewMapping) {
	                if (!dataViewMapping || !dataViewMapping.categorical || !dataViewMapping.categorical.categories)
	                    return false;
	                var dataViewCategories = dataViewMapping.categorical.categories;
	                var categoryItems = dataViewCategories.for.in.items;
	                if (_.isEmpty(categoryItems))
	                    return false;
	                var categoryType = categoryItems[0].type;
	                if (!dataViewMapping.metadata)
	                    return false;
	                var objects = dataViewMapping.metadata.objects;
	                return CartesianChart.getIsScalar(objects, visuals.columnChartProps.categoryAxis.axisType, categoryType);
	            };
	            CartesianChart.prototype.populateObjectProperties = function (dataViews) {
	                if (dataViews && dataViews.length > 0) {
	                    var dataViewMetadata = dataViews[0].metadata;
	                    if (dataViewMetadata) {
	                        this.legendObjectProperties = powerbi.DataViewObjects.getObject(dataViewMetadata.objects, 'legend', {});
	                        this.xAxisReferenceLines = powerbi.DataViewObjects.getUserDefinedObjects(dataViewMetadata.objects, 'xAxisReferenceLine');
	                        this.y1AxisReferenceLines = powerbi.DataViewObjects.getUserDefinedObjects(dataViewMetadata.objects, 'y1AxisReferenceLine');
	                        this.referenceLines = powerbi.DataViewObjects.getUserDefinedObjects(dataViewMetadata.objects, 'referenceLine');
	                    }
	                    else {
	                        this.legendObjectProperties = {};
	                    }
	                    this.categoryAxisProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataViewMetadata);
	                    this.valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataViewMetadata);
	                }
	            };
	            CartesianChart.prototype.updateInternal = function (options, operationKind) {
	                var dataViews = this.dataViews = options.dataViews;
	                this.currentViewport = options.viewport;
	                if (!dataViews)
	                    return;
	                if (this.layers.length === 0) {
	                    // Lazily instantiate the chart layers on the first data load.
	                    var objects = this.extractMetadataObjects(dataViews);
	                    this.layers = this.createAndInitLayers(objects);
	                    debug.assert(this.layers.length > 0, 'createAndInitLayers should update the layers.');
	                }
	                var layers = this.layers;
	                if (operationKind != null) {
	                    if (!_.isEmpty(dataViews)) {
	                        this.populateObjectProperties(dataViews);
	                        this.axes.update(dataViews);
	                        this.svgAxes.update(this.categoryAxisProperties, this.valueAxisProperties);
	                        var dataView = dataViews[0];
	                        if (dataView.metadata) {
	                            // flatten background data
	                            this.background = {
	                                image: powerbi.DataViewObjects.getValue(dataView.metadata.objects, visuals.scatterChartProps.plotArea.image),
	                                transparency: powerbi.DataViewObjects.getValue(dataView.metadata.objects, visuals.scatterChartProps.plotArea.transparency, visuals.visualBackgroundHelper.getDefaultTransparency()),
	                            };
	                            var isScalar = true;
	                            var categoryColumn = dataView && dataView.categorical && _.first(dataView.categorical.categories);
	                            if (categoryColumn && categoryColumn.source) {
	                                isScalar = visuals.CartesianChart.getIsScalar(dataView.metadata.objects, visuals.columnChartProps.categoryAxis.axisType, categoryColumn.source.type);
	                            }
	                            // Clear the load more handler if we're scalar and there's an existing handler. 
	                            // Setup a handler if we're categorical and don't have one.
	                            if (isScalar && this.loadMoreDataHandler) {
	                                this.loadMoreDataHandler = null;
	                            }
	                            else if (!isScalar && !this.loadMoreDataHandler) {
	                                this.loadMoreDataHandler = new CartesianLoadMoreDataHandler(null, this.hostServices.loadMoreData, CartesianChart.LoadMoreThreshold);
	                            }
	                        }
	                    }
	                    this.sharedColorPalette.clearPreferredScale();
	                    var layerDataViews = getLayerDataViews(dataViews);
	                    var trendLineDataViews = _.filter(dataViews, visuals.TrendLineHelper.isDataViewForRegression);
	                    this.trendLines = [];
	                    var forecastDataViews = _.filter(dataViews, visuals.ForecastHelper.isDataViewForForecast);
	                    this.forecastLine = null;
	                    for (var i = 0, layerCount = layers.length; i < layerCount; i++) {
	                        var layerDataView = layerDataViews[i];
	                        layers[i].setData(layerDataView ? [layerDataView] : []);
	                        if (this.supportsTrendLines(i)) {
	                            var trendLineDataView = trendLineDataViews[i];
	                            if (trendLineDataView) {
	                                var y2 = (i > 0);
	                                var trendLines = visuals.TrendLineHelper.readDataView(trendLineDataView, layerDataView, y2, this.sharedColorPalette);
	                                (_a = this.trendLines).push.apply(_a, trendLines);
	                            }
	                        }
	                        if (this.supportsForecast(i)) {
	                            var forecastDataView = forecastDataViews[i];
	                            if (forecastDataView) {
	                                var forecastLine = visuals.ForecastHelper.readDataView(forecastDataView, layerDataView, this.sharedColorPalette);
	                                this.forecastLine = forecastLine;
	                            }
	                        }
	                        if (layerCount > 1)
	                            this.sharedColorPalette.rotateScale();
	                    }
	                }
	                // If the data changed (there's an operationKind), say we're done loading data so logic 
	                // during the render phase can request more data if there is not enough.
	                if (this.loadMoreDataHandler && operationKind != null) {
	                    this.loadMoreDataHandler.onLoadMoreDataCompleted();
	                }
	                this.render(!this.hasSetData || options.suppressAnimations, options.resizeMode, operationKind);
	                this.hasSetData = this.hasSetData || (dataViews && dataViews.length > 0);
	                if (dataViews && dataViews.length > 0) {
	                    var warnings = visuals.getInvalidValueWarnings(dataViews, false /*supportsNaN*/, false /*supportsNegativeInfinity*/, false /*supportsPositiveInfinity*/);
	                    this.axes.addWarnings(warnings);
	                    if (warnings && warnings.length > 0)
	                        this.hostServices.setWarnings(warnings);
	                }
	                var _a;
	            };
	            // TODO: Remove onDataChanged & onResizing once we have a flag to distinguish between resize and data changed events.
	            CartesianChart.prototype.onDataChanged = function (options) {
	                this.updateInternal({
	                    dataViews: options.dataViews,
	                    suppressAnimations: options.suppressAnimations,
	                    viewport: this.currentViewport
	                }, options.operationKind != null ? options.operationKind : powerbi.VisualDataChangeOperationKind.Create);
	            };
	            // TODO: Remove onDataChanged & onResizing once we have a flag to distinguish between resize and data changed events.
	            CartesianChart.prototype.onResizing = function (viewport, resizeMode) {
	                this.updateInternal({
	                    dataViews: this.dataViews,
	                    suppressAnimations: true,
	                    viewport: viewport,
	                    resizeMode: resizeMode,
	                });
	            };
	            CartesianChart.prototype.scrollTo = function (position) {
	                this.scrollableAxes.scrollTo(position);
	            };
	            CartesianChart.prototype.enumerateObjectInstances = function (options) {
	                var enumeration = new visuals.ObjectEnumerationBuilder();
	                var layersLength = this.layers ? this.layers.length : 0;
	                if (options.objectName === 'legend') {
	                    if (!this.shouldShowLegendCard())
	                        return;
	                    var show = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.show, this.legend.isVisible());
	                    var showTitle = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.showTitle, true);
	                    var titleText = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.titleText, this.layerLegendData ? this.layerLegendData.title : '');
	                    var labelColor = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.labelColor, visuals.LegendData.DefaultLegendLabelFillColor);
	                    var fontSize = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.fontSize, this.layerLegendData && this.layerLegendData.fontSize ? this.layerLegendData.fontSize : visuals.SVGLegend.DefaultFontSizeInPt);
	                    var position = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.position, visuals.legendPosition.top);
	                    enumeration.pushInstance({
	                        selector: null,
	                        properties: {
	                            show: show,
	                            position: position,
	                            showTitle: showTitle,
	                            titleText: titleText,
	                            labelColor: labelColor,
	                            fontSize: fontSize,
	                        },
	                        objectName: options.objectName
	                    });
	                }
	                else if (options.objectName === 'categoryAxis' && this.axes.hasCategoryAxis()) {
	                    this.getCategoryAxisValues(enumeration);
	                }
	                else if (options.objectName === 'valueAxis') {
	                    this.getValueAxisValues(enumeration);
	                }
	                else if (options.objectName === 'y1AxisReferenceLine') {
	                    var refLinedefaultColor = this.sharedColorPalette.getColorByIndex(0).value;
	                    visuals.ReferenceLineHelper.enumerateObjectInstances(enumeration, this.y1AxisReferenceLines, refLinedefaultColor, options.objectName);
	                }
	                else if (options.objectName === 'xAxisReferenceLine') {
	                    var refLinedefaultColor = this.sharedColorPalette.getColorByIndex(0).value;
	                    visuals.ReferenceLineHelper.enumerateObjectInstances(enumeration, this.xAxisReferenceLines, refLinedefaultColor, options.objectName);
	                }
	                else if (options.objectName === 'referenceLine') {
	                    if (this.supportsDataBoundReferenceLines()) {
	                        var refLinedefaultColor = this.sharedColorPalette.getColorByIndex(0).value;
	                        visuals.ReferenceLineHelper.enumerateObjectInstances(enumeration, this.referenceLines, refLinedefaultColor, options.objectName);
	                    }
	                }
	                else if (options.objectName === 'trend') {
	                    if (this.supportsTrendLines()) {
	                        visuals.TrendLineHelper.enumerateObjectInstances(enumeration, this.trendLines);
	                    }
	                }
	                else if (options.objectName === 'forecast' && this.forecastEnabled) {
	                    if (this.supportsForecast()) {
	                        visuals.ForecastHelper.enumerateObjectInstances(enumeration, this.forecastLine);
	                    }
	                }
	                else if (options.objectName === 'plotArea') {
	                    visuals.visualBackgroundHelper.enumeratePlot(enumeration, this.background);
	                }
	                if (options.objectName === 'dataPoint' &&
	                    visuals.ComboChart.isComboChart(this.type)) {
	                    visuals.ComboChart.enumerateDataPoints(enumeration, options, this.layers);
	                }
	                else {
	                    for (var i = 0, len = layersLength; i < len; i++) {
	                        var layer = this.layers[i];
	                        if (layer.enumerateObjectInstances) {
	                            layer.enumerateObjectInstances(enumeration, options);
	                        }
	                    }
	                }
	                return enumeration.complete();
	            };
	            CartesianChart.prototype.supportsTrendLines = function (layerIndex) {
	                return this.allLayerSupports(function (layer) { return layer.supportsTrendLine && layer.supportsTrendLine(); }, layerIndex);
	            };
	            CartesianChart.prototype.supportsForecast = function (layerIndex) {
	                return this.allLayerSupports(function (layer) { return layer.supportsForecast && layer.supportsForecast(); }, layerIndex);
	            };
	            CartesianChart.prototype.supportsDataBoundReferenceLines = function (layerIndex) {
	                return this.allLayerSupports(function (layer) { return !layer.isStacked || !layer.isStacked(); }, layerIndex);
	            };
	            CartesianChart.prototype.allLayerSupports = function (predicate, layerIndex) {
	                var layerDataViews = getLayerDataViews(this.dataViews);
	                if (_.isEmpty(this.layers))
	                    return false;
	                // If layerIndex was not given then check all layers.
	                var layers = layerIndex == null ? this.layers : [this.layers[layerIndex]];
	                return _.all(layers, function (layer, index) {
	                    if (!layerDataViews[index])
	                        return true;
	                    return predicate(layer);
	                });
	            };
	            CartesianChart.prototype.shouldShowLegendCard = function () {
	                var layers = this.layers;
	                var dataViews = this.dataViews;
	                if (layers && dataViews) {
	                    var layersLength = layers.length;
	                    var layersWithValuesCtr = 0;
	                    for (var i = 0; i < layersLength; i++) {
	                        if (layers[i].hasLegend()) {
	                            return true;
	                        }
	                        // if there are at least two layers with values legend card should be shown (even if each of the individual layers don't have legend)
	                        var dataView = dataViews[i];
	                        if (dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.values.length > 0) {
	                            layersWithValuesCtr++;
	                            if (layersWithValuesCtr > 1) {
	                                return true;
	                            }
	                        }
	                    }
	                }
	                return false;
	            };
	            CartesianChart.prototype.getAxisScaleOptions = function (axisType) {
	                var scaleOptions = [DEFAULT_AXIS_SCALE_TYPE];
	                if (this.axes.isLogScaleAllowed(axisType))
	                    scaleOptions.push(visuals.axisScale.log);
	                return scaleOptions;
	            };
	            CartesianChart.prototype.getCategoryAxisValues = function (enumeration) {
	                if (!this.categoryAxisProperties) {
	                    return;
	                }
	                var supportedType = visuals.axisType.both;
	                var isScalar = false;
	                var scaleOptions = this.getAxisScaleOptions(0 /* X */);
	                if (this.layers && this.layers[0].getSupportedCategoryAxisType) {
	                    supportedType = this.layers[0].getSupportedCategoryAxisType();
	                    if (supportedType === visuals.axisType.scalar) {
	                        isScalar = true;
	                    }
	                    else {
	                        isScalar = visuals.CartesianHelper.isScalar(supportedType === visuals.axisType.both, this.categoryAxisProperties);
	                    }
	                }
	                if (!isScalar) {
	                    this.categoryAxisProperties['start'] = null;
	                    this.categoryAxisProperties['end'] = null;
	                }
	                var instance = {
	                    selector: null,
	                    properties: {},
	                    objectName: 'categoryAxis',
	                    validValues: {
	                        axisScale: scaleOptions,
	                        axisStyle: this.axes.categoryAxisHasUnitType ? [visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth] : [visuals.axisStyle.showTitleOnly]
	                    }
	                };
	                instance.properties['show'] = this.categoryAxisProperties['show'] != null ? this.categoryAxisProperties['show'] : true;
	                if (this.axes.isYAxisCategorical())
	                    instance.properties['position'] = this.valueAxisProperties && this.valueAxisProperties['position'] != null ? this.valueAxisProperties['position'] : visuals.yAxisPosition.left;
	                if (supportedType === visuals.axisType.both) {
	                    instance.properties['axisType'] = isScalar ? visuals.axisType.scalar : visuals.axisType.categorical;
	                }
	                if (isScalar) {
	                    instance.properties['axisScale'] = this.categoryAxisProperties['axisScale'] || DEFAULT_AXIS_SCALE_TYPE;
	                    instance.properties['start'] = this.categoryAxisProperties['start'];
	                    instance.properties['end'] = this.categoryAxisProperties['end'];
	                }
	                instance.properties['showAxisTitle'] = this.categoryAxisProperties['showAxisTitle'] != null ? this.categoryAxisProperties['showAxisTitle'] : false;
	                instance.properties['axisStyle'] = this.categoryAxisProperties['axisStyle'] ? this.categoryAxisProperties['axisStyle'] : visuals.axisStyle.showTitleOnly;
	                instance.properties['labelColor'] = this.categoryAxisProperties['labelColor'] || visuals.DEFAULT_AXIS_COLOR;
	                if (isScalar) {
	                    instance.properties['labelDisplayUnits'] = this.categoryAxisProperties['labelDisplayUnits'] ? this.categoryAxisProperties['labelDisplayUnits'] : 0;
	                    var labelPrecision = this.categoryAxisProperties['labelPrecision'];
	                    instance.properties['labelPrecision'] = (labelPrecision === undefined || labelPrecision < 0)
	                        ? visuals.dataLabelUtils.defaultLabelPrecision
	                        : labelPrecision;
	                }
	                enumeration.pushInstance(instance);
	            };
	            //TODO: wrap all these object getters and other related stuff into an interface.
	            CartesianChart.prototype.getValueAxisValues = function (enumeration) {
	                if (!this.valueAxisProperties) {
	                    return;
	                }
	                var scaleOptions = this.getAxisScaleOptions(1 /* Y1 */);
	                var secScaleOption = this.getAxisScaleOptions(2 /* Y2 */);
	                var instance = {
	                    selector: null,
	                    properties: {},
	                    objectName: 'valueAxis',
	                    validValues: {
	                        axisScale: scaleOptions,
	                        secAxisScale: secScaleOption,
	                        axisStyle: this.axes.valueAxisHasUnitType ? [visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth] : [visuals.axisStyle.showTitleOnly],
	                        secAxisStyle: this.axes.secondaryValueAxisHasUnitType ? [visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth] : [visuals.axisStyle.showTitleOnly],
	                    }
	                };
	                instance.properties['show'] = this.valueAxisProperties['show'] != null ? this.valueAxisProperties['show'] : true;
	                instance.properties['axisLabel'] = this.valueAxisProperties['axisLabel'];
	                if (!this.axes.isYAxisCategorical()) {
	                    instance.properties['position'] = this.valueAxisProperties['position'] != null ? this.valueAxisProperties['position'] : visuals.yAxisPosition.left;
	                }
	                instance.properties['axisScale'] = this.valueAxisProperties['axisScale'] || DEFAULT_AXIS_SCALE_TYPE;
	                instance.properties['start'] = this.valueAxisProperties['start'];
	                instance.properties['end'] = this.valueAxisProperties['end'];
	                instance.properties['showAxisTitle'] = this.valueAxisProperties['showAxisTitle'] != null ? this.valueAxisProperties['showAxisTitle'] : false;
	                instance.properties['axisStyle'] = this.valueAxisProperties['axisStyle'] != null ? this.valueAxisProperties['axisStyle'] : visuals.axisStyle.showTitleOnly;
	                instance.properties['labelColor'] = this.valueAxisProperties['labelColor'] || visuals.DEFAULT_AXIS_COLOR;
	                if (this.type !== 7 /* HundredPercentStackedBar */ && this.type !== 8 /* HundredPercentStackedColumn */) {
	                    instance.properties['labelDisplayUnits'] = this.valueAxisProperties['labelDisplayUnits'] ? this.valueAxisProperties['labelDisplayUnits'] : 0;
	                    var labelPrecision = this.valueAxisProperties['labelPrecision'];
	                    instance.properties['labelPrecision'] = (labelPrecision === undefined || labelPrecision < 0)
	                        ? visuals.dataLabelUtils.defaultLabelPrecision
	                        : labelPrecision;
	                }
	                if (this.layers.length === 2) {
	                    instance.properties['secShow'] = this.valueAxisProperties['secShow'] != null ? this.valueAxisProperties['secShow'] : this.axes.hasY2Axis();
	                }
	                if (this.axes.hasY2Axis() && instance.properties['secShow']) {
	                    instance.properties['secAxisLabel'] = '';
	                    instance.properties['secPosition'] = this.valueAxisProperties['secPosition'] != null ? this.valueAxisProperties['secPosition'] : visuals.yAxisPosition.right;
	                    instance.properties['secAxisScale'] = this.valueAxisProperties['secAxisScale'] || DEFAULT_AXIS_SCALE_TYPE;
	                    instance.properties['secStart'] = this.valueAxisProperties['secStart'];
	                    instance.properties['secEnd'] = this.valueAxisProperties['secEnd'];
	                    instance.properties['secShowAxisTitle'] = this.valueAxisProperties['secShowAxisTitle'] != null ? this.valueAxisProperties['secShowAxisTitle'] : false;
	                    instance.properties['secAxisStyle'] = this.valueAxisProperties['secAxisStyle'] ? this.valueAxisProperties['secAxisStyle'] : visuals.axisStyle.showTitleOnly;
	                    instance.properties['labelColor'] = this.valueAxisProperties['secLabelColor'];
	                    instance.properties['secLabelDisplayUnits'] = this.valueAxisProperties['secLabelDisplayUnits'] ? this.valueAxisProperties['secLabelDisplayUnits'] : 0;
	                    instance.properties['secLabelPrecision'] = this.valueAxisProperties['secLabelPrecision'] < 0 ? 0 : this.valueAxisProperties['secLabelPrecision'];
	                }
	                enumeration.pushInstance(instance);
	            };
	            CartesianChart.prototype.onClearSelection = function () {
	                if (this.hasSetData) {
	                    for (var i = 0, len = this.layers.length; i < len; i++) {
	                        var layer = this.layers[i];
	                        layer.onClearSelection();
	                        layer.render(true /* suppressAnimations */);
	                    }
	                }
	            };
	            CartesianChart.prototype.extractMetadataObjects = function (dataViews) {
	                var objects;
	                if (dataViews && dataViews.length > 0) {
	                    var dataViewMetadata = dataViews[0].metadata;
	                    if (dataViewMetadata)
	                        objects = dataViewMetadata.objects;
	                }
	                return objects;
	            };
	            CartesianChart.prototype.createAndInitLayers = function (objects) {
	                var _this = this;
	                // Create the layers
	                var layers = CartesianLayerFactory.createLayers(this.type, objects, this.interactivityService, this.animator, this.axes.isScrollable, this.tooltipsEnabled, this.tooltipBucketEnabled, this.advancedLineLabelsEnabled);
	                // Initialize the layers
	                var cartesianOptions = powerbi.Prototype.inherit(this.visualInitOptions);
	                cartesianOptions.svg = this.svgAxes.getScrollableRegion();
	                cartesianOptions.labelsContext = this.svgAxes.getLabelsRegion();
	                cartesianOptions.cartesianHost = {
	                    updateLegend: function (data) { return _this.legend.drawLegend(data, _this.currentViewport); },
	                    getSharedColors: function () { return _this.sharedColorPalette; },
	                    triggerRender: function (suppressAnimations) { return _this.render(suppressAnimations); },
	                };
	                cartesianOptions.chartType = this.type;
	                for (var i = 0, len = layers.length; i < len; i++)
	                    layers[i].init(cartesianOptions);
	                return layers;
	            };
	            CartesianChart.prototype.renderLegend = function () {
	                var layers = this.layers;
	                var legendData = { title: "", dataPoints: [] };
	                var _loop_1 = function(i, len) {
	                    this_1.layerLegendData = layers[i].calculateLegend();
	                    if (this_1.layerLegendData) {
	                        legendData.title = i === 0 ? this_1.layerLegendData.title || ""
	                            : legendData.title;
	                        legendData.labelColor = this_1.layerLegendData.labelColor;
	                        // Data points have have duplicate identities (ex. Combo Chart uses a measure in both line and column).
	                        // Add the layer number (if it's set) so the D3 keys are different.
	                        if (!_.isEmpty(this_1.layerLegendData.dataPoints)) {
	                            this_1.layerLegendData.dataPoints.forEach(function (dataPoint) { return dataPoint.layerNumber = i; });
	                        }
	                        legendData.dataPoints = legendData.dataPoints.concat(this_1.layerLegendData.dataPoints || []);
	                        legendData.fontSize = this_1.layerLegendData.fontSize || visuals.SVGLegend.DefaultFontSizeInPt;
	                        if (this_1.layerLegendData.grouped) {
	                            legendData.grouped = true;
	                        }
	                    }
	                };
	                var this_1 = this;
	                for (var i = 0, len = layers.length; i < len; i++) {
	                    _loop_1(i, len);
	                }
	                var legendProperties = this.legendObjectProperties;
	                if (legendProperties) {
	                    visuals.LegendData.update(legendData, legendProperties);
	                    var position = legendProperties[visuals.legendProps.position];
	                    if (position)
	                        this.legend.changeOrientation(visuals.LegendPosition[position]);
	                }
	                else {
	                    this.legend.changeOrientation(visuals.LegendPosition.Top);
	                }
	                if ((legendData.dataPoints.length === 1 && !legendData.grouped) || this.hideLegends()) {
	                    legendData.dataPoints = [];
	                }
	                this.legend.drawLegend(legendData, this.currentViewport);
	            };
	            CartesianChart.prototype.hideLegends = function () {
	                if (this.cartesianSmallViewPortProperties) {
	                    if (this.cartesianSmallViewPortProperties.hideLegendOnSmallViewPort && (this.currentViewport.height < this.cartesianSmallViewPortProperties.MinHeightLegendVisible)) {
	                        return true;
	                    }
	                }
	                return false;
	            };
	            CartesianChart.prototype.render = function (suppressAnimations, resizeMode, operationKind) {
	                var _this = this;
	                // Note: interactive legend shouldn't be rendered explicitly here
	                // The interactive legend is being rendered in the render method of ICartesianVisual
	                if (!(this.visualInitOptions.interactivity && this.visualInitOptions.interactivity.isInteractiveLegend)) {
	                    this.renderLegend();
	                }
	                var legendMargins = this.legendMargins = this.legend.getMargins();
	                var legendOrientation = this.legend.getOrientation();
	                var hideAxisLabels = this.hideAxisLabels(legendMargins);
	                var plotAreaViewport = {
	                    height: this.currentViewport.height - legendMargins.height,
	                    width: this.currentViewport.width - legendMargins.width
	                };
	                var padding = powerbi.Prototype.inherit(SvgCartesianAxes.AxisPadding);
	                var playAxisControlLayout;
	                if (this.isPlayAxis()) {
	                    plotAreaViewport.height -= CartesianChart.PlayAxisBottomMargin;
	                    playAxisControlLayout = {
	                        left: visuals.Legend.isLeft(legendOrientation) ? legendMargins.width : 0,
	                        top: visuals.Legend.isTop(legendOrientation) ? legendMargins.height + plotAreaViewport.height : plotAreaViewport.height,
	                        height: CartesianChart.PlayAxisBottomMargin,
	                        width: plotAreaViewport.width
	                    };
	                }
	                this.chartAreaSvg.attr({
	                    'width': plotAreaViewport.width,
	                    'height': plotAreaViewport.height,
	                });
	                visuals.Legend.positionChartArea(this.chartAreaSvg, this.legend);
	                var interactivityRightMargin = this.calculateInteractivityRightMargin();
	                var _a = this.getMinimumDomainExtents(), ensureXDomain = _a[0], ensureYDomain = _a[1];
	                // Even if the caller thinks animations are ok, now that we've laid out the axes and legend we should disable animations
	                // if the plot area changed. Animations for property changes like legend on/off are not desired.
	                var plotAreaHasChanged = !this.renderedPlotArea
	                    || (this.renderedPlotArea.height !== plotAreaViewport.height ||
	                        this.renderedPlotArea.width !== plotAreaViewport.width);
	                suppressAnimations = suppressAnimations || plotAreaHasChanged;
	                var axesLayout = this.axes.negotiateAxes(this.layers, plotAreaViewport, padding, playAxisControlLayout, hideAxisLabels, CartesianChart.AxisTextProperties, interactivityRightMargin, ensureXDomain, ensureYDomain);
	                var categoryAxis = axesLayout.axes.x.isCategoryAxis ? axesLayout.axes.x : axesLayout.axes.y1;
	                if (this.loadMoreDataHandler) {
	                    this.loadMoreDataHandler.setScale(categoryAxis.scale);
	                }
	                this.scrollableAxes.render(axesLayout, this.layers, suppressAnimations, function (layers, axesLayout, suppressAnimations) { return _this.renderPlotArea(layers, axesLayout, suppressAnimations, legendMargins, resizeMode); }, this.loadMoreDataHandler, operationKind === powerbi.VisualDataChangeOperationKind.Append /* preserveScrollbar */);
	                // attach scroll event
	                this.chartAreaSvg.on('wheel', function () {
	                    if (!(_this.axes.isXScrollBarVisible || _this.axes.isYScrollBarVisible))
	                        return;
	                    visuals.TooltipManager.ToolTipInstance.hide();
	                    var wheelEvent = d3.event;
	                    var dy = wheelEvent.deltaY;
	                    _this.scrollableAxes.scrollDelta(dy);
	                    wheelEvent.preventDefault();
	                });
	                this.renderedPlotArea = plotAreaViewport;
	            };
	            /**
	             * Gets any minimum domain extents.
	             * Reference lines and forecast lines may enforce minimum extents on X and/or Y domains.
	             */
	            CartesianChart.prototype.getMinimumDomainExtents = function () {
	                var xs = [];
	                var ys = [];
	                if (!_.isEmpty(this.xAxisReferenceLines)) {
	                    var xAxisReferenceLineProperties = this.xAxisReferenceLines[0].object;
	                    var value = visuals.ReferenceLineHelper.extractReferenceLineValue(xAxisReferenceLineProperties);
	                    xs.push(value);
	                }
	                if (!_.isEmpty(this.y1AxisReferenceLines)) {
	                    var y1AxisReferenceLineProperties = this.y1AxisReferenceLines[0].object;
	                    var value = visuals.ReferenceLineHelper.extractReferenceLineValue(y1AxisReferenceLineProperties);
	                    ys.push(value);
	                }
	                if (this.forecastLine && !_.isEmpty(this.forecastLine.points)) {
	                    xs.push.apply(xs, _.map(this.forecastLine.points, function (p) { return p.point.x; }));
	                    ys.push.apply(ys, _.map(this.forecastLine.points, function (p) { return p.point.y; }));
	                    xs.push.apply(xs, _.map(this.forecastLine.points, function (p) { return p.upperBound.x; }));
	                    ys.push.apply(ys, _.map(this.forecastLine.points, function (p) { return p.upperBound.y; }));
	                    xs.push.apply(xs, _.map(this.forecastLine.points, function (p) { return p.lowerBound.x; }));
	                    ys.push.apply(ys, _.map(this.forecastLine.points, function (p) { return p.lowerBound.y; }));
	                }
	                var ensureXDomain = {
	                    min: d3.min(xs),
	                    max: d3.max(xs)
	                };
	                var ensureYDomain = {
	                    min: d3.min(ys),
	                    max: d3.max(ys)
	                };
	                return [ensureXDomain, ensureYDomain];
	            };
	            CartesianChart.prototype.getPlotAreaRect = function (axesLayout, legendMargins) {
	                var rect = {
	                    left: axesLayout.margin.left,
	                    top: axesLayout.margin.top,
	                    width: axesLayout.plotArea.width,
	                    height: axesLayout.plotArea.height,
	                };
	                // Adjust the margins to the legend position 
	                if (this.legend) {
	                    var legendPosition_1 = this.legend.getOrientation();
	                    if (visuals.Legend.isTop(legendPosition_1)) {
	                        rect.top += legendMargins.height;
	                    }
	                    else if (visuals.Legend.isLeft(legendPosition_1)) {
	                        rect.left += legendMargins.width;
	                    }
	                }
	                return rect;
	            };
	            CartesianChart.prototype.renderBackgroundImage = function (layout) {
	                visuals.visualBackgroundHelper.renderBackgroundImage(this.background, this.element, layout);
	            };
	            CartesianChart.prototype.hideAxisLabels = function (legendMargins) {
	                if (this.cartesianSmallViewPortProperties) {
	                    if (this.cartesianSmallViewPortProperties.hideAxesOnSmallViewPort && (this.currentViewport.height < this.cartesianSmallViewPortProperties.MinHeightAxesVisible) && !this.visualInitOptions.interactivity.isInteractiveLegend) {
	                        return true;
	                    }
	                }
	                return false;
	            };
	            CartesianChart.prototype.calculateInteractivityRightMargin = function () {
	                // add right margin in order not to cut the circle selection of the hover line 
	                if (this.visualInitOptions.interactivity && this.visualInitOptions.interactivity.isInteractiveLegend && !this.trimOrdinalDataOnOverflow) {
	                    return INTERACTIVITY_RIGHT_MARGIN;
	                }
	                else {
	                    return 0;
	                }
	            };
	            CartesianChart.prototype.renderPlotArea = function (layers, axesLayout, suppressAnimations, legendMargins, resizeMode) {
	                debug.assertValue(layers, 'layers');
	                // some layer (e.g. scatterChart) may want to suppress animations. if any does, suppress for all.
	                suppressAnimations = suppressAnimations || _.any(layers, function (layer) { return layer.shouldSuppressAnimation && layer.shouldSuppressAnimation(); });
	                var axes = axesLayout.axes;
	                var plotArea = axesLayout.plotArea;
	                var plotAreaRect = this.getPlotAreaRect(axesLayout, legendMargins);
	                var duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
	                var easing = this.animator && this.animator.getEasing();
	                this.renderBackgroundImage(plotAreaRect);
	                if (!_.isEmpty(easing))
	                    this.svgAxes.renderAxes(axesLayout, duration, easing);
	                else
	                    this.svgAxes.renderAxes(axesLayout, duration);
	                this.renderReferenceLines(axesLayout);
	                this.renderLayers(layers, plotArea, axes, suppressAnimations, resizeMode);
	                this.renderTrendLines(axesLayout);
	                this.renderForecast(axesLayout, suppressAnimations);
	            };
	            CartesianChart.prototype.renderTrendLines = function (axesLayout) {
	                var scrollableRegion = this.svgAxes.getScrollableRegion();
	                visuals.TrendLineHelper.render(this.trendLines, scrollableRegion, axesLayout.axes, axesLayout.plotArea);
	            };
	            CartesianChart.prototype.renderForecast = function (axesLayout, suppressAnimations) {
	                var scrollableRegion = this.svgAxes.getScrollableRegion();
	                visuals.ForecastHelper.render(this.forecastLine, scrollableRegion, axesLayout.axes, axesLayout.plotArea, this.animator, suppressAnimations);
	            };
	            CartesianChart.prototype.renderReferenceLines = function (axesLayout) {
	                var axes = axesLayout.axes;
	                var plotArea = axesLayout.plotArea;
	                var scrollableRegion = this.svgAxes.getScrollableRegion();
	                var refLineDefaultColor = this.sharedColorPalette.getColorByIndex(0).value;
	                var showY1ReferenceLines = false;
	                if (this.y1AxisReferenceLines) {
	                    for (var _i = 0, _a = this.y1AxisReferenceLines; _i < _a.length; _i++) {
	                        var referenceLineProperties = _a[_i];
	                        var object = referenceLineProperties.object;
	                        if (object[visuals.ReferenceLineHelper.referenceLineProps.show]) {
	                            var isHorizontal = !axes.y1.isCategoryAxis;
	                            var y1RefLineOptions = {
	                                graphicContext: scrollableRegion,
	                                referenceLineProperties: object,
	                                axes: axes,
	                                viewport: plotArea,
	                                classAndSelector: this.y1RefLine,
	                                defaultColor: refLineDefaultColor,
	                                isHorizontal: isHorizontal
	                            };
	                            visuals.ReferenceLineHelper.render(y1RefLineOptions);
	                            showY1ReferenceLines = true;
	                        }
	                    }
	                }
	                if (!showY1ReferenceLines) {
	                    scrollableRegion.selectAll(this.y1RefLine.selector).remove();
	                }
	                var showXReferenceLines = false;
	                if (this.xAxisReferenceLines) {
	                    for (var _b = 0, _c = this.xAxisReferenceLines; _b < _c.length; _b++) {
	                        var referenceLineProperties = _c[_b];
	                        var object = referenceLineProperties.object;
	                        if (object[visuals.ReferenceLineHelper.referenceLineProps.show]) {
	                            var isHorizontal = false;
	                            var xRefLineOptions = {
	                                graphicContext: scrollableRegion,
	                                referenceLineProperties: object,
	                                axes: axes,
	                                viewport: plotArea,
	                                classAndSelector: this.xRefLine,
	                                defaultColor: refLineDefaultColor,
	                                isHorizontal: isHorizontal
	                            };
	                            visuals.ReferenceLineHelper.render(xRefLineOptions);
	                            showXReferenceLines = true;
	                        }
	                    }
	                }
	                if (!showXReferenceLines) {
	                    scrollableRegion.selectAll(this.xRefLine.selector).remove();
	                }
	            };
	            CartesianChart.prototype.getReferenceLineLabels = function (axes, plotArea) {
	                var refLineDefaultColor = this.sharedColorPalette.getColorByIndex(0).value;
	                var referenceLineLabels = [];
	                if (this.y1AxisReferenceLines) {
	                    for (var _i = 0, _a = this.y1AxisReferenceLines; _i < _a.length; _i++) {
	                        var referenceLineProperties = _a[_i];
	                        var object = referenceLineProperties.object;
	                        if (object[visuals.ReferenceLineHelper.referenceLineProps.show] && object[visuals.ReferenceLineHelper.referenceLineProps.dataLabelShow]) {
	                            var isHorizontal = !axes.y1.isCategoryAxis;
	                            var y1RefLineLabelOptions = {
	                                referenceLineProperties: object,
	                                axes: axes,
	                                viewport: plotArea,
	                                defaultColor: refLineDefaultColor,
	                                isHorizontal: isHorizontal,
	                                key: JSON.stringify({
	                                    type: 'y1AxisReferenceLine',
	                                    id: referenceLineProperties.id,
	                                }),
	                            };
	                            referenceLineLabels.push(visuals.ReferenceLineHelper.createLabelDataPoint(y1RefLineLabelOptions));
	                        }
	                    }
	                }
	                if (this.xAxisReferenceLines) {
	                    for (var _b = 0, _c = this.xAxisReferenceLines; _b < _c.length; _b++) {
	                        var referenceLineProperties = _c[_b];
	                        var object = referenceLineProperties.object;
	                        if (object[visuals.ReferenceLineHelper.referenceLineProps.show] && object[visuals.ReferenceLineHelper.referenceLineProps.dataLabelShow]) {
	                            var isHorizontal = false;
	                            var xRefLineLabelOptions = {
	                                referenceLineProperties: object,
	                                axes: axes,
	                                viewport: plotArea,
	                                defaultColor: refLineDefaultColor,
	                                isHorizontal: isHorizontal,
	                                key: JSON.stringify({
	                                    type: 'xAxisReferenceLine',
	                                    id: referenceLineProperties.id,
	                                }),
	                            };
	                            referenceLineLabels.push(visuals.ReferenceLineHelper.createLabelDataPoint(xRefLineLabelOptions));
	                        }
	                    }
	                }
	                return referenceLineLabels;
	            };
	            CartesianChart.prototype.renderDataLabels = function (labelDataPointGroups, labelsAreNumeric, plotArea, suppressAnimations, isCombo) {
	                var labelBackgroundRegion = this.svgAxes.getLabelBackground();
	                var labelRegion = this.svgAxes.getLabelsRegion();
	                if (this.behavior) {
	                    var labelLayoutOptions = visuals.NewDataLabelUtils.getDataLabelLayoutOptions(this.type);
	                    var labelLayout = new powerbi.LabelLayout(labelLayoutOptions);
	                    var dataLabels = labelLayout.layout(labelDataPointGroups, plotArea);
	                    if (isCombo) {
	                        visuals.NewDataLabelUtils.drawLabelBackground(labelBackgroundRegion, dataLabels, "#FFFFFF", 0.7);
	                    }
	                    var svgLabels = void 0;
	                    var animator = this.animator;
	                    if (animator && !suppressAnimations) {
	                        var isPlayAxis = this.isPlayAxis();
	                        var duration = isPlayAxis ? visuals.PlayChart.FrameAnimationDuration : animator.getDuration();
	                        svgLabels = visuals.NewDataLabelUtils.animateDefaultLabels(labelRegion, dataLabels, duration, labelsAreNumeric, isPlayAxis ? 'linear' : animator.getEasing());
	                    }
	                    else {
	                        svgLabels = visuals.NewDataLabelUtils.drawDefaultLabels(labelRegion, dataLabels, labelsAreNumeric);
	                    }
	                    if (labelLayoutOptions.allowLeaderLines) {
	                        var filteredLabels = _.filter(dataLabels, function (d) { return d.leaderLinePoints != null && !_.isEmpty(d.leaderLinePoints) && d.identity != null; });
	                        visuals.NewDataLabelUtils.drawLabelLeaderLines(labelRegion, filteredLabels, function (d) { return d.identity.getKey(); });
	                    }
	                    if (this.interactivityService && this.isLabelInteractivityEnabled) {
	                        var labelsBehaviorOptions = {
	                            labelItems: svgLabels,
	                        };
	                        this.interactivityService.bind(dataLabels, new visuals.LabelsBehavior(), labelsBehaviorOptions, { isLabels: true });
	                    }
	                }
	                else {
	                    var labelLayout = new powerbi.LabelLayout({
	                        maximumOffset: visuals.NewDataLabelUtils.maxLabelOffset,
	                        startingOffset: visuals.NewDataLabelUtils.startingLabelOffset,
	                        attemptToMoveLabelsIntoViewport: true,
	                    });
	                    var dataLabels = labelLayout.layout(labelDataPointGroups, plotArea);
	                    if (isCombo) {
	                        visuals.NewDataLabelUtils.drawLabelBackground(labelBackgroundRegion, dataLabels, "#FFFFFF", 0.7);
	                    }
	                    visuals.NewDataLabelUtils.drawDefaultLabels(labelRegion, dataLabels, labelsAreNumeric);
	                }
	            };
	            CartesianChart.prototype.renderLayers = function (layers, plotArea, axes, suppressAnimations, resizeMode) {
	                var labelDataPointGroups = [];
	                var dataPoints = [];
	                var layerBehaviorOptions = [];
	                var labelsAreNumeric = true;
	                // some layer (e.g. scatterChart) may want to suppress animations. if any does, suppress for all.
	                suppressAnimations = suppressAnimations || _.any(layers, function (layer) { return layer.shouldSuppressAnimation && layer.shouldSuppressAnimation(); });
	                for (var _i = 0, layers_1 = layers; _i < layers_1.length; _i++) {
	                    var layer = layers_1[_i];
	                    var result = layer.render(suppressAnimations, resizeMode);
	                    if (result) {
	                        if (this.behavior) {
	                            // NOTE: these are not needed if we don't have interactivity
	                            dataPoints = dataPoints.concat(result.dataPoints);
	                            layerBehaviorOptions.push(result.behaviorOptions);
	                        }
	                        if (result.labelDataPointGroups) {
	                            var resultLabelDataPointsGroups = result.labelDataPointGroups;
	                            for (var _a = 0, resultLabelDataPointsGroups_1 = resultLabelDataPointsGroups; _a < resultLabelDataPointsGroups_1.length; _a++) {
	                                var resultLabelDataPointsGroup = resultLabelDataPointsGroups_1[_a];
	                                if (!resultLabelDataPointsGroup)
	                                    continue;
	                                labelDataPointGroups.push({
	                                    labelDataPoints: visuals.NewDataLabelUtils.removeDuplicates(resultLabelDataPointsGroup.labelDataPoints || []),
	                                    maxNumberOfLabels: resultLabelDataPointsGroup.maxNumberOfLabels,
	                                });
	                            }
	                        }
	                        else {
	                            var resultsLabelDataPoints = result.labelDataPoints || [];
	                            labelDataPointGroups.push({
	                                labelDataPoints: visuals.NewDataLabelUtils.removeDuplicates(resultsLabelDataPoints),
	                                maxNumberOfLabels: resultsLabelDataPoints.length,
	                            });
	                        }
	                        labelsAreNumeric = labelsAreNumeric && result.labelsAreNumeric;
	                    }
	                }
	                var referenceLineLabels = this.getReferenceLineLabels(axes, plotArea);
	                if (!_.isEmpty(referenceLineLabels)) {
	                    labelDataPointGroups.unshift({
	                        labelDataPoints: referenceLineLabels,
	                        maxNumberOfLabels: referenceLineLabels.length,
	                    });
	                }
	                this.renderDataLabels(labelDataPointGroups, labelsAreNumeric, plotArea, suppressAnimations, visuals.ComboChart.isComboChart(this.type));
	                if (this.interactivityService) {
	                    var behaviorOptions = {
	                        layerOptions: layerBehaviorOptions,
	                        clearCatcher: this.clearCatcher,
	                    };
	                    this.interactivityService.bind(dataPoints, this.behavior, behaviorOptions);
	                }
	            };
	            /**
	             * Returns the actual viewportWidth if visual is not scrollable.
	             * @return If visual is scrollable, returns the plot area needed to draw all the datapoints.
	             */
	            CartesianChart.getPreferredPlotArea = function (categoryCount, categoryThickness, viewport, isScrollable, isScalar, margin, noOuterPadding) {
	                if (!margin)
	                    margin = { top: 0, right: 0, bottom: 0, left: 0 };
	                var plotArea = {
	                    height: viewport.height - margin.top - margin.bottom,
	                    width: viewport.width - margin.left - margin.right
	                };
	                if (!isScalar && isScrollable) {
	                    var preferredCategorySpan = CartesianChart.getPreferredCategorySpan(categoryCount, categoryThickness, noOuterPadding);
	                    plotArea.width = Math.max(preferredCategorySpan, plotArea.width);
	                }
	                return plotArea;
	            };
	            /**
	             * Returns preferred Category span if the visual is scrollable.
	             */
	            CartesianChart.getPreferredCategorySpan = function (categoryCount, categoryThickness, noOuterPadding) {
	                var span = (categoryThickness * categoryCount);
	                if (noOuterPadding)
	                    return span;
	                return span + (categoryThickness * CartesianChart.OuterPaddingRatio * 2);
	            };
	            /**
	             * Note: Public for testing access.
	             */
	            CartesianChart.getLayout = function (data, options) {
	                var categoryCount = options.categoryCount, availableWidth = options.availableWidth, domain = options.domain, trimOrdinalDataOnOverflow = options.trimOrdinalDataOnOverflow, isScalar = !!options.isScalar, isScrollable = !!options.isScrollable;
	                var categoryThickness = CartesianChart.getCategoryThickness(data ? data.series : null, categoryCount, availableWidth, domain, isScalar, trimOrdinalDataOnOverflow);
	                // Total width of the outer padding, the padding that exist on the far right and far left of the chart.
	                var totalOuterPadding = categoryThickness * CartesianChart.OuterPaddingRatio * 2;
	                // visibleCategoryCount will be used to discard data that overflows on ordinal-axis charts.
	                // Needed for dashboard visuals            
	                var calculatedBarCount = powerbi.Double.floorWithPrecision((availableWidth - totalOuterPadding) / categoryThickness);
	                var visibleCategoryCount = Math.min(calculatedBarCount, categoryCount);
	                var willScroll = visibleCategoryCount < categoryCount && isScrollable;
	                var outerPaddingRatio = CartesianChart.OuterPaddingRatio;
	                if (!isScalar && !willScroll) {
	                    // use dynamic outer padding to improve spacing when we have few categories
	                    var oneOuterPadding = (availableWidth - (categoryThickness * visibleCategoryCount)) / 2;
	                    outerPaddingRatio = oneOuterPadding / categoryThickness;
	                }
	                // If scrollable, visibleCategoryCount will be total categories
	                if (!isScalar && isScrollable)
	                    visibleCategoryCount = categoryCount;
	                return {
	                    categoryCount: visibleCategoryCount,
	                    categoryThickness: categoryThickness,
	                    outerPaddingRatio: outerPaddingRatio,
	                    isScalar: isScalar
	                };
	            };
	            /**
	             * Returns the thickness for each category.
	             * For clustered charts, you still need to divide by
	             * the number of series to get column width after calling this method.
	             * For linear or time scales, category thickness accomodates for
	             * the minimum interval between consequtive points.
	             * For all types, return value has accounted for outer padding,
	             * but not inner padding.
	             */
	            CartesianChart.getCategoryThickness = function (seriesList, numCategories, plotLength, domain, isScalar, trimOrdinalDataOnOverflow) {
	                var thickness;
	                if (numCategories < 2)
	                    thickness = plotLength * (1 - CartesianChart.OuterPaddingRatio);
	                else if (isScalar && domain && domain.length > 1) {
	                    // the smallest interval defines the column width.
	                    var minInterval = CartesianChart.getMinInterval(seriesList);
	                    var domainSpan = domain[domain.length - 1] - domain[0];
	                    // account for outside padding
	                    var ratio = minInterval / (domainSpan + (minInterval * CartesianChart.OuterPaddingRatio * 2));
	                    thickness = plotLength * ratio;
	                    thickness = Math.max(thickness, CartesianChart.MinScalarRectThickness);
	                }
	                else {
	                    // Divide the available width up including outer padding (in terms of category thickness) on
	                    // both sides of the chart, and categoryCount categories. Reverse math:
	                    // availableWidth = (categoryThickness * categoryCount) + (categoryThickness * (outerPadding * 2)),
	                    // availableWidth = categoryThickness * (categoryCount + (outerPadding * 2)),
	                    // categoryThickness = availableWidth / (categoryCount + (outerpadding * 2))
	                    thickness = plotLength / (numCategories + (CartesianChart.OuterPaddingRatio * 2));
	                    if (trimOrdinalDataOnOverflow) {
	                        thickness = Math.max(thickness, CartesianChart.MinOrdinalRectThickness);
	                    }
	                }
	                // spec calls for using the whole plot area, but the max rectangle thickness is "as if there were three categories"
	                // (outerPaddingRatio has the same units as '# of categories' so they can be added)
	                var maxRectThickness = plotLength / (3 + (CartesianChart.OuterPaddingRatio * 2));
	                thickness = Math.min(thickness, maxRectThickness);
	                if (!isScalar && numCategories >= 3 && trimOrdinalDataOnOverflow) {
	                    return Math.max(thickness, CartesianChart.MinOrdinalRectThickness);
	                }
	                return thickness;
	            };
	            CartesianChart.getMinInterval = function (seriesList) {
	                var minInterval = Number.MAX_VALUE;
	                if (seriesList.length > 0) {
	                    var series0data = seriesList[0].data.filter(function (d) { return !d.highlight; });
	                    for (var i = 0, ilen = series0data.length - 1; i < ilen; i++) {
	                        minInterval = Math.min(minInterval, Math.abs(series0data[i + 1].categoryValue - series0data[i].categoryValue));
	                    }
	                }
	                return minInterval;
	            };
	            /**
	             * Expands the category data reduction algorithm window if there are no series in any of the data view mappings.
	             */
	            CartesianChart.expandCategoryWindow = function (mappings) {
	                var NoSeriesWindowCount = 1000;
	                if (!shouldExpandCategoryWindow(mappings)) {
	                    return;
	                }
	                for (var _i = 0, mappings_1 = mappings; _i < mappings_1.length; _i++) {
	                    var mapping = mappings_1[_i];
	                    if (!mapping.categorical) {
	                        return;
	                    }
	                    var categories = mapping.categorical.categories;
	                    if (!categories) {
	                        return;
	                    }
	                    debug.assertValue(categories.dataReductionAlgorithm, 'categories does not have dataReductionAlgorithm');
	                    debug.assertValue(categories.dataReductionAlgorithm.window, 'dataReductionAlgorithm does not have a window');
	                    categories.dataReductionAlgorithm = {
	                        window: { count: NoSeriesWindowCount }
	                    };
	                }
	            };
	            CartesianChart.MinOrdinalRectThickness = 20;
	            CartesianChart.MinScalarRectThickness = 2;
	            CartesianChart.OuterPaddingRatio = 0.4;
	            CartesianChart.InnerPaddingRatio = 0.2;
	            CartesianChart.TickLabelPadding = 2; // between text labels, used by AxisHelper
	            CartesianChart.LoadMoreThreshold = 1; // Load more data 1 item before the last (so 2nd to last) item is shown
	            CartesianChart.ClassName = 'cartesianChart';
	            CartesianChart.PlayAxisBottomMargin = 80; //do not change unless we add dynamic label measurements for play slider
	            CartesianChart.FontSize = 11;
	            CartesianChart.FontSizeString = jsCommon.PixelConverter.toString(CartesianChart.FontSize);
	            CartesianChart.AxisTextProperties = {
	                fontFamily: visuals.Font.Family.regular.css,
	                fontSize: CartesianChart.FontSizeString,
	            };
	            return CartesianChart;
	        }());
	        visuals.CartesianChart = CartesianChart;
	        /**
	         * Determines if the category window should be expanded. The window should be expanded if there are no series in any of the data view mappings.
	         */
	        function shouldExpandCategoryWindow(mappings) {
	            if (_.isEmpty(mappings)) {
	                return false;
	            }
	            // Check if any of the mappings have series
	            var hasSeries = _.any(mappings, function (mapping) {
	                var categorical = mapping.categorical;
	                if (!categorical) {
	                    return false;
	                }
	                var categories = categorical.categories;
	                if (!categories) {
	                    return false;
	                }
	                var values = categorical.values;
	                return !!(values && values.group && values.group.by && !_.isEmpty(values.group.by.items));
	            });
	            return !hasSeries;
	        }
	        function getLayerDataViews(dataViews) {
	            if (_.isEmpty(dataViews))
	                return [];
	            // TODO: figure out a more general way to correlate between layers and input data views.
	            return _.filter(dataViews, function (dataView) { return !visuals.TrendLineHelper.isDataViewForRegression(dataView) && !visuals.ForecastHelper.isDataViewForForecast(dataView); });
	        }
	        function hasMultipleYAxes(layers) {
	            debug.assertValue(layers, 'layers');
	            return layers.length > 1;
	        }
	        /**
	         * Returns a boolean, that indicates if y axis title should be displayed.
	         * @return True if y axis title should be displayed,
	         * otherwise false.
	         */
	        function shouldShowYAxisLabel(layerNumber, valueAxisProperties, yAxisWillMerge) {
	            return ((layerNumber === 0 && !!valueAxisProperties && !!valueAxisProperties['showAxisTitle']) ||
	                (layerNumber === 1 && !yAxisWillMerge && !!valueAxisProperties && !!valueAxisProperties['secShowAxisTitle']));
	        }
	        function tryMergeYDomains(layers, visualOptions) {
	            debug.assert(layers.length < 3, 'merging of more than 2 layers is not supported');
	            var noMerge = {
	                domain: undefined,
	                merged: false,
	                tickCount: undefined
	            };
	            if (layers.length < 2)
	                return noMerge;
	            var min;
	            var max;
	            var minOfMax;
	            var maxOfMin;
	            // TODO: replace full calculateAxesProperties with just a data domain calc
	            // we need to be aware of which chart require zero (column/bar) and which don't (line)
	            var y1props = layers[0].calculateAxesProperties(visualOptions)[1];
	            var y2props = layers[1].calculateAxesProperties(visualOptions)[1];
	            var firstYDomain = y1props.scale.domain();
	            var secondYDomain = y2props.scale.domain();
	            if (y1props.values && y1props.values.length > 0 && y2props.values && y2props.values.length > 0) {
	                noMerge.tickCount = Math.max(y1props.values.length, y2props.values.length);
	            }
	            min = Math.min(firstYDomain[0], secondYDomain[0]);
	            max = Math.max(firstYDomain[1], secondYDomain[1]);
	            if (visualOptions.forceMerge) {
	                return {
	                    domain: [min, max],
	                    merged: true,
	                    tickCount: noMerge.tickCount
	                };
	            }
	            // If domains don't intersect don't merge axis.
	            if (firstYDomain[0] > secondYDomain[1] || firstYDomain[1] < secondYDomain[0])
	                return noMerge;
	            maxOfMin = Math.max(firstYDomain[0], secondYDomain[0]);
	            minOfMax = Math.min(firstYDomain[1], secondYDomain[1]);
	            var range = (max - min);
	            if (range === 0) {
	                return noMerge;
	            }
	            var intersection = Math.abs((minOfMax - maxOfMin) / range);
	            // Only merge if intersection of domains greater than 10% of total range.
	            if (intersection < COMBOCHART_DOMAIN_OVERLAP_TRESHOLD_PERCENTAGE)
	                return noMerge;
	            else
	                return {
	                    domain: [min, max],
	                    merged: true,
	                    tickCount: noMerge.tickCount
	                };
	        }
	        var SvgBrush = (function () {
	            function SvgBrush(brushWidth) {
	                this.brush = d3.svg.brush();
	                this.brushWidth = brushWidth;
	            }
	            SvgBrush.prototype.init = function (element) {
	                this.element = element;
	            };
	            SvgBrush.prototype.remove = function () {
	                this.element.selectAll(SvgBrush.Brush.selector).remove();
	                // Remove the listeners
	                this.brush
	                    .on(SvgBrush.events.brushStart, null)
	                    .on(SvgBrush.events.brush, null)
	                    .on(SvgBrush.events.brushEnd, null);
	                this.brushGraphicsContext = undefined;
	            };
	            SvgBrush.prototype.getExtent = function () {
	                return this.brush.extent();
	            };
	            SvgBrush.prototype.setExtent = function (extent) {
	                this.brush.extent(extent);
	            };
	            SvgBrush.prototype.setScale = function (scale) {
	                if (this.isHorizontal)
	                    this.brush.x(scale);
	                else
	                    this.brush.y(scale);
	            };
	            SvgBrush.prototype.setOrientation = function (isHorizontal) {
	                this.isHorizontal = isHorizontal;
	            };
	            SvgBrush.prototype.renderBrush = function (extentLength, brushX, brushY, scrollCallback) {
	                var _this = this;
	                // create graphics context if it doesn't exist
	                if (!this.brushGraphicsContext) {
	                    this.brushGraphicsContext = this.element.append("g")
	                        .classed(SvgBrush.Brush.class, true);
	                }
	                this.scrollCallback = scrollCallback;
	                // events
	                this.brush
	                    .on(SvgBrush.events.brushStart, function () { return _this.brushStartExtent = _this.brush.extent(); })
	                    .on(SvgBrush.events.brush, function () {
	                    window.requestAnimationFrame(scrollCallback);
	                })
	                    .on(SvgBrush.events.brushEnd, function () {
	                    _this.resizeExtent(extentLength);
	                    _this.updateExtentPosition(extentLength);
	                    _this.brushStartExtent = null;
	                });
	                // position the graphics context
	                var brushContext = this.brushGraphicsContext
	                    .attr({
	                    "transform": visuals.SVGUtil.translate(brushX, brushY),
	                    "drag-resize-disabled": "true" /* Disables resizing of the visual when dragging the scrollbar in edit mode */
	                })
	                    .call(this.brush);
	                // Disable the zooming feature by removing the resize elements
	                brushContext.selectAll(".resize")
	                    .remove();
	                if (this.isHorizontal)
	                    brushContext.selectAll("rect").attr("height", this.brushWidth);
	                else
	                    brushContext.selectAll("rect").attr("width", this.brushWidth);
	            };
	            SvgBrush.prototype.scroll = function (scrollBarLength) {
	                this.updateExtentPosition(scrollBarLength);
	                this.scrollCallback();
	            };
	            SvgBrush.prototype.updateExtentPosition = function (scrollBarLength) {
	                var extent = this.brush.extent();
	                debug.assertNonEmpty(extent, 'updateExtentPosition, extent');
	                var newStartPos = extent[0];
	                var halfScrollBarLen = scrollBarLength / 2;
	                if (extent[0] === extent[1]) {
	                    // user clicked on the brush background, width will be zero, offset x by half width
	                    newStartPos = newStartPos - halfScrollBarLen;
	                }
	                if (extent[1] - extent[0] > scrollBarLength) {
	                    // user is dragging one edge after mousedown in the background, figure out which side is moving
	                    // also, center up on the new extent center
	                    var halfDragLength = (extent[1] - extent[0]) / 2;
	                    if (extent[0] < this.brushStartExtent[0])
	                        newStartPos = extent[0] + halfDragLength - halfScrollBarLen;
	                    else
	                        newStartPos = extent[1] - halfDragLength - halfScrollBarLen;
	                }
	                if (this.isHorizontal)
	                    this.brushGraphicsContext.select(".extent").attr('x', newStartPos);
	                else
	                    this.brushGraphicsContext.select(".extent").attr('y', newStartPos);
	            };
	            SvgBrush.prototype.resizeExtent = function (extentLength) {
	                if (this.isHorizontal)
	                    this.brushGraphicsContext.select(".extent").attr("width", extentLength);
	                else
	                    this.brushGraphicsContext.select(".extent").attr("height", extentLength);
	            };
	            SvgBrush.events = {
	                brushStart: 'brushstart',
	                brush: 'brush',
	                brushEnd: 'brushend'
	            };
	            SvgBrush.Brush = createClassAndSelector('brush');
	            return SvgBrush;
	        }());
	        var ScrollableAxes = (function () {
	            function ScrollableAxes(axes, svgBrush) {
	                this.axes = axes;
	                this.brush = svgBrush;
	            }
	            ScrollableAxes.prototype.filterDataToViewport = function (mainAxisScale, layers, axes, scrollScale, extent, visibleCategoryCount) {
	                if (!scrollScale) {
	                    return;
	                }
	                var selected;
	                var data = [];
	                // NOTE: using start + numVisibleCategories to make sure we don't have issues with exactness related to extent start/end
	                //      (don't use extent[1])
	                /*
	                 When extent[0] and extent[1] are very close to the boundary of a new index, due to floating point err,
	                 the "start" might move to the next index but the "end" might not change until you slide one more pixel.
	                 It makes things really jittery during scrolling, sometimes you see N columns and sometimes you briefly see N+1.
	                */
	                var startIndex = visuals.AxisHelper.lookupOrdinalIndex(scrollScale, extent[0]);
	                var endIndex = startIndex + visibleCategoryCount; // NOTE: intentionally 1 past end index
	                var domain = scrollScale.domain();
	                selected = domain.slice(startIndex, endIndex); // NOTE: Up to but not including 'end'
	                if (_.isEqual(selected, mainAxisScale.domain())) {
	                    return; //no need to do any more work
	                }
	                if (selected && selected.length > 0) {
	                    for (var i = 0; i < layers.length; i++) {
	                        data[i] = layers[i].setFilteredData(selected[0], selected[selected.length - 1] + 1);
	                    }
	                    mainAxisScale.domain(selected);
	                    var axisPropsToUpdate = void 0;
	                    if (this.axes.isXScrollBarVisible) {
	                        axisPropsToUpdate = axes.x;
	                    }
	                    else {
	                        axisPropsToUpdate = axes.y1;
	                    }
	                    axisPropsToUpdate.axis.scale(mainAxisScale);
	                    axisPropsToUpdate.scale(mainAxisScale);
	                    // tick values are indices for ordinal axes
	                    axisPropsToUpdate.axis.ticks(selected.length);
	                    axisPropsToUpdate.axis.tickValues(selected);
	                    // use the original tick format to format the tick values
	                    var tickFormat_1 = axisPropsToUpdate.axis.tickFormat();
	                    axisPropsToUpdate.values = _.map(selected, function (d) { return tickFormat_1(d); });
	                }
	                return {
	                    startIndex: startIndex,
	                    endIndex: endIndex - 1 // Subtract 1 since it's actually 1 past the end index
	                };
	            };
	            ScrollableAxes.prototype.render = function (axesLayout, layers, suppressAnimations, renderDelegate, loadMoreDataHandler, preserveScrollPosition) {
	                var _this = this;
	                var plotArea = axesLayout.plotArea;
	                if (plotArea.width < 1 || plotArea.height < 1)
	                    return; //do nothing - too small
	                this.axisScale = null;
	                var brushX;
	                var brushY;
	                var scrollbarLength;
	                var numVisibleCategories;
	                var categoryThickness;
	                var newAxisLength;
	                var showingScrollBar = this.axes.isXScrollBarVisible || this.axes.isYScrollBarVisible;
	                // If the scrollbars are visible, calculate values.
	                // We also need to calculate values if we have a loadMoreData handler since they're used to make sure we have enough 
	                // data to fill the viewport (even if there aren't any scrollbars).
	                if (loadMoreDataHandler || showingScrollBar) {
	                    if (!this.axes.isYAxisCategorical()) {
	                        this.axisScale = axesLayout.axes.x.scale;
	                        brushX = axesLayout.margin.left;
	                        brushY = axesLayout.viewport.height;
	                        categoryThickness = axesLayout.axes.x.categoryThickness;
	                        var outerPadding = axesLayout.axes.x.outerPadding;
	                        numVisibleCategories = powerbi.Double.floorWithPrecision((plotArea.width - outerPadding * 2) / categoryThickness);
	                        scrollbarLength = (numVisibleCategories + 1) * categoryThickness;
	                        newAxisLength = plotArea.width;
	                    }
	                    else {
	                        this.axisScale = axesLayout.axes.y1.scale;
	                        brushX = axesLayout.viewport.width;
	                        brushY = axesLayout.margin.top;
	                        categoryThickness = axesLayout.axes.y1.categoryThickness;
	                        var outerPadding = axesLayout.axes.y1.outerPadding;
	                        numVisibleCategories = powerbi.Double.floorWithPrecision((plotArea.height - outerPadding * 2) / categoryThickness);
	                        scrollbarLength = (numVisibleCategories + 1) * categoryThickness;
	                        newAxisLength = plotArea.height;
	                    }
	                }
	                // No scrollbars, render the chart normally.
	                if (!showingScrollBar) {
	                    // Load more data if we don't have enough.
	                    // The window size should be big enough so we don't hit this code, but it's here as a backup.
	                    if (loadMoreDataHandler) {
	                        loadMoreDataHandler.viewportDataRange = { startIndex: 0, endIndex: numVisibleCategories };
	                        if (loadMoreDataHandler.shouldLoadMoreData()) {
	                            loadMoreDataHandler.loadMoreData();
	                        }
	                    }
	                    this.brush.remove();
	                    renderDelegate(layers, axesLayout, suppressAnimations);
	                    return;
	                }
	                // viewport is REALLY small
	                if (numVisibleCategories < 1) {
	                    return; // don't do anything
	                }
	                this.scrollScale = this.axisScale.copy();
	                this.scrollScale.rangeBands([0, scrollbarLength]); //no inner/outer padding, keep the math simple
	                this.brushMinExtent = this.scrollScale(numVisibleCategories - 1);
	                // Options: use newAxisLength to squeeze-pop and keep the chart balanced, 
	                //          or use scrollbarLength to keep rects still - but it leaves unbalanced right edge
	                // 1. newAxisLength ex: As you resize smaller we constantly adjust the inner/outer padding to keep things balanced with the same # of rects, 
	                //      when we need to drop a rect we pop out the rectangle and the padding seems to jump (to keep things cenetered and balanced). 
	                // 2. scrollbarLenghth ex: As you resize smaller we can leave all rectangles in the exact same place, no squeezing inner/outer padding,
	                //      when we need to drop a rect we just remove it - but this leaves the right side with lots of empty room (bad for dashboard tiles)
	                // we are using option 1 to squeeze pop and show balanced layout at all sizes, but this is the less ideal experience during resize.
	                // we should consider using option 2 during resize, then switch to option 1 when resize ends.
	                this.axisScale.rangeBands([0, newAxisLength], CartesianChart.InnerPaddingRatio, CartesianChart.OuterPaddingRatio);
	                this.brush.setOrientation(this.axes.isXScrollBarVisible);
	                this.brush.setScale(this.scrollScale);
	                this.brush.setExtent([0, this.brushMinExtent]);
	                // This function will be called whenever we scroll.
	                var renderOnScroll = function (extent, suppressAnimations) {
	                    var dataRange = _this.filterDataToViewport(_this.axisScale, layers, axesLayout.axes, _this.scrollScale, extent, numVisibleCategories);
	                    if (dataRange == null)
	                        return;
	                    if (loadMoreDataHandler) {
	                        loadMoreDataHandler.viewportDataRange = dataRange;
	                        if (loadMoreDataHandler.shouldLoadMoreData()) {
	                            loadMoreDataHandler.loadMoreData();
	                        }
	                    }
	                    renderDelegate(layers, axesLayout, suppressAnimations);
	                };
	                var scrollCallback = function () { return _this.onBrushed(scrollbarLength, renderOnScroll); };
	                this.brush.renderBrush(this.brushMinExtent, brushX, brushY, scrollCallback);
	                // Either scroll to the specified location or simply render the visual.
	                if (preserveScrollPosition && loadMoreDataHandler) {
	                    var startIndex = loadMoreDataHandler.viewportDataRange ? loadMoreDataHandler.viewportDataRange.startIndex : 0;
	                    // Clamp 1st to update the size of the extent, then scroll to the new index
	                    ScrollableAxes.clampBrushExtent(this.brush, scrollbarLength, this.brushMinExtent);
	                    // ScrollTo takes care of the rendering
	                    this.scrollTo(startIndex);
	                }
	                else {
	                    renderOnScroll(this.brush.getExtent(), suppressAnimations);
	                }
	            };
	            ScrollableAxes.prototype.scrollDelta = function (delta) {
	                if (this.axisScale && !_.isEmpty(this.axisScale.domain())) {
	                    var currentStartIndex = this.axisScale.domain()[0];
	                    var newStartIndex = currentStartIndex + Math.round(delta / CartesianChart.MinOrdinalRectThickness);
	                    this.scrollTo(newStartIndex);
	                }
	            };
	            // PUBLIC FOR UNIT TESTING ONLY
	            ScrollableAxes.prototype.scrollTo = function (startIndex) {
	                debug.assert(this.axes.isXScrollBarVisible || this.axes.isYScrollBarVisible, 'scrolling is not available');
	                debug.assertValue(this.scrollScale, 'scrollScale');
	                var lastIndex = _.last(this.scrollScale.domain());
	                startIndex = Math.max(0, Math.min(startIndex, lastIndex));
	                var extent = this.brush.getExtent();
	                var extentLength = extent[1] - extent[0];
	                var halfCategoryThickness = (this.scrollScale(1) - this.scrollScale(0)) / 2;
	                extent[0] = this.scrollScale(startIndex) + halfCategoryThickness;
	                extent[1] = extent[0] + extentLength + halfCategoryThickness;
	                this.brush.setExtent(extent);
	                var scrollbarLength = this.scrollScale.rangeExtent()[1];
	                ScrollableAxes.clampBrushExtent(this.brush, scrollbarLength, this.brushMinExtent);
	                this.brush.scroll(scrollbarLength);
	            };
	            ScrollableAxes.prototype.onBrushed = function (scrollbarLength, render) {
	                var brush = this.brush;
	                ScrollableAxes.clampBrushExtent(this.brush, scrollbarLength, this.brushMinExtent);
	                var extent = brush.getExtent();
	                render(extent, /*suppressAnimations*/ true);
	            };
	            ScrollableAxes.clampBrushExtent = function (brush, scrollbarLength, minExtent) {
	                var extent = brush.getExtent();
	                var width = extent[1] - extent[0];
	                if (width === minExtent && extent[1] <= scrollbarLength && extent[0] >= 0)
	                    return;
	                if (width > minExtent) {
	                    var padding = (width - minExtent) / 2;
	                    extent[0] += padding;
	                    extent[1] -= padding;
	                }
	                else if (width < minExtent) {
	                    var padding = (minExtent - width) / 2;
	                    extent[0] -= padding;
	                    extent[1] += padding;
	                }
	                if (extent[0] < 0) {
	                    extent[0] = 0;
	                    extent[1] = minExtent;
	                }
	                else if (extent[0] > scrollbarLength - minExtent) {
	                    extent[0] = scrollbarLength - minExtent;
	                    extent[1] = scrollbarLength;
	                }
	                brush.setExtent(extent);
	            };
	            ScrollableAxes.ScrollbarWidth = 10;
	            return ScrollableAxes;
	        }());
	        var SvgCartesianAxes = (function () {
	            function SvgCartesianAxes(axes) {
	                this.axes = axes;
	            }
	            SvgCartesianAxes.prototype.getScrollableRegion = function () {
	                return this.axisGraphicsContextScrollable;
	            };
	            SvgCartesianAxes.prototype.getLabelsRegion = function () {
	                return this.labelRegion;
	            };
	            SvgCartesianAxes.prototype.getLabelBackground = function () {
	                return this.labelBackgroundRegion;
	            };
	            SvgCartesianAxes.prototype.getXAxis = function () {
	                return this.xAxisGraphicsContext;
	            };
	            SvgCartesianAxes.prototype.getY1Axis = function () {
	                return this.y1AxisGraphicsContext;
	            };
	            SvgCartesianAxes.prototype.getY2Axis = function () {
	                return this.y2AxisGraphicsContext;
	            };
	            SvgCartesianAxes.prototype.update = function (categoryAxisProperties, valueAxisProperties) {
	                this.categoryAxisProperties = categoryAxisProperties;
	                this.valueAxisProperties = valueAxisProperties;
	            };
	            SvgCartesianAxes.prototype.init = function (svg) {
	                /*
	                    The layout of the visual will look like:
	                    <svg>
	                        <g>
	                            <nonscrollable axis/>
	                        </g>
	                        <svgScrollable>
	                            <g>
	                                <scrollable axis/>
	                            </g>
	                        </svgScrollable>
	                        <g xbrush/>
	                    </svg>
	    
	                */
	                var axisGraphicsContext = this.axisGraphicsContext = svg.append('g')
	                    .classed(SvgCartesianAxes.AxisGraphicsContext.class, true);
	                this.svgScrollable = svg.append('svg')
	                    .classed('svgScrollable', true)
	                    .style('overflow', 'hidden');
	                var axisGraphicsContextScrollable = this.axisGraphicsContextScrollable = this.svgScrollable.append('g')
	                    .classed(SvgCartesianAxes.AxisGraphicsContext.class, true);
	                this.labelBackgroundRegion = this.svgScrollable.append('g')
	                    .classed(visuals.NewDataLabelUtils.labelBackgroundGraphicsContextClass.class, true);
	                this.labelRegion = this.svgScrollable.append('g')
	                    .classed(visuals.NewDataLabelUtils.labelGraphicsContextClass.class, true);
	                var showLinesOnX = this.axes.showLinesOnX;
	                var showLinesOnY = this.axes.showLinesOnY;
	                // NOTE: We infer the axis which should scroll based on whether or not we draw grid lines for the other axis, and
	                // only allow one axis to scroll.
	                var scrollX = showLinesOnY;
	                var scrollY = !scrollX;
	                if (scrollY) {
	                    this.y1AxisGraphicsContext = axisGraphicsContextScrollable.append('g').attr('class', 'y axis');
	                    this.y2AxisGraphicsContext = axisGraphicsContextScrollable.append('g').attr('class', 'y axis');
	                }
	                else {
	                    this.y1AxisGraphicsContext = axisGraphicsContext.append('g').attr('class', 'y axis');
	                    this.y2AxisGraphicsContext = axisGraphicsContext.append('g').attr('class', 'y axis');
	                }
	                if (scrollX) {
	                    this.xAxisGraphicsContext = axisGraphicsContextScrollable.append('g').attr('class', 'x axis');
	                }
	                else {
	                    this.xAxisGraphicsContext = axisGraphicsContext.append('g').attr('class', 'x axis');
	                }
	                this.xAxisGraphicsContext.classed('showLinesOnAxis', showLinesOnX);
	                this.y1AxisGraphicsContext.classed('showLinesOnAxis', showLinesOnY);
	                this.y2AxisGraphicsContext.classed('showLinesOnAxis', showLinesOnY);
	                this.xAxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnX);
	                this.y1AxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnY);
	                this.y2AxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnY);
	            };
	            SvgCartesianAxes.updateAnimatedTickTooltips = function (axisSelection, values) {
	                axisSelection.each('end', function () {
	                    d3.select(this)
	                        .selectAll('text')
	                        .append('title')
	                        .text(function (d, i) { return values[i]; });
	                });
	            };
	            SvgCartesianAxes.updateTickTooltips = function (axisSelection, values) {
	                axisSelection.selectAll('text').append('title').text(function (d, i) { return values[i]; });
	            };
	            SvgCartesianAxes.prototype.renderAxes = function (axesLayout, duration, easing) {
	                if (easing === void 0) { easing = 'cubic-in-out'; }
	                var marginLimits = axesLayout.marginLimits;
	                var plotArea = axesLayout.plotArea;
	                var viewport = axesLayout.viewport;
	                var margin = axesLayout.margin;
	                var axes = axesLayout.axes;
	                var tickLabelMargins = axesLayout.tickLabelMargins;
	                var bottomMarginLimit = marginLimits.bottom;
	                var leftRightMarginLimit = marginLimits.left;
	                var xLabelColor;
	                var yLabelColor;
	                var y2LabelColor;
	                if (this.axes.shouldRenderAxis(axes.x)) {
	                    if (axes.x.isCategoryAxis) {
	                        xLabelColor = this.categoryAxisProperties && this.categoryAxisProperties['labelColor'] ? this.categoryAxisProperties['labelColor'] : null;
	                    }
	                    else {
	                        xLabelColor = this.valueAxisProperties && this.valueAxisProperties['labelColor'] ? this.valueAxisProperties['labelColor'] : null;
	                    }
	                    axes.x.axis.orient("bottom");
	                    // we only rotate ordinal tick labels
	                    if (!axes.x.willLabelsFit && visuals.AxisHelper.isOrdinalScale(axes.x.scale))
	                        axes.x.axis.tickPadding(SvgCartesianAxes.TickPaddingRotatedX);
	                    var xAxisGraphicsElement = this.xAxisGraphicsContext;
	                    if (duration) {
	                        xAxisGraphicsElement
	                            .transition()
	                            .duration(duration)
	                            .ease(easing)
	                            .call(axes.x.axis)
	                            .call(SvgCartesianAxes.updateAnimatedTickTooltips, axes.x.values);
	                    }
	                    else {
	                        xAxisGraphicsElement
	                            .call(axes.x.axis);
	                    }
	                    xAxisGraphicsElement
	                        .call(SvgCartesianAxes.darkenZeroLine)
	                        .call(SvgCartesianAxes.setAxisLabelColor, xLabelColor);
	                    var xAxisTextNodes = xAxisGraphicsElement.selectAll('text');
	                    if (axes.x.willLabelsWordBreak) {
	                        xAxisTextNodes
	                            .call(visuals.AxisHelper.LabelLayoutStrategy.wordBreak, axes.x, bottomMarginLimit);
	                    }
	                    else {
	                        xAxisTextNodes
	                            .call(visuals.AxisHelper.LabelLayoutStrategy.rotate, bottomMarginLimit, powerbi.TextMeasurementService.getTailoredTextOrDefault, CartesianChart.AxisTextProperties, !axes.x.willLabelsFit && visuals.AxisHelper.isOrdinalScale(axes.x.scale), bottomMarginLimit === tickLabelMargins.xMax, axes.x, margin, this.axes.isXScrollBarVisible || this.axes.isYScrollBarVisible);
	                    }
	                    if (!duration) {
	                        SvgCartesianAxes.updateTickTooltips(xAxisGraphicsElement, axes.x.values);
	                    }
	                }
	                else {
	                    this.xAxisGraphicsContext.selectAll('*').remove();
	                }
	                if (this.axes.shouldRenderAxis(axes.y1)) {
	                    if (axes.y1.isCategoryAxis) {
	                        yLabelColor = this.categoryAxisProperties && this.categoryAxisProperties['labelColor'] ? this.categoryAxisProperties['labelColor'] : null;
	                    }
	                    else {
	                        yLabelColor = this.valueAxisProperties && this.valueAxisProperties['labelColor'] ? this.valueAxisProperties['labelColor'] : null;
	                    }
	                    var showY1OnRight = this.axes.shouldShowY1OnRight();
	                    var y1TickPadding = showY1OnRight ? axesLayout.tickPadding.right : axesLayout.tickPadding.left;
	                    axes.y1.axis
	                        .tickSize(-plotArea.width)
	                        .tickPadding(y1TickPadding)
	                        .orient(this.axes.getYAxisOrientation().toLowerCase());
	                    var y1AxisGraphicsElement = this.y1AxisGraphicsContext;
	                    if (duration) {
	                        y1AxisGraphicsElement
	                            .transition()
	                            .duration(duration)
	                            .ease(easing)
	                            .call(axes.y1.axis)
	                            .call(SvgCartesianAxes.updateAnimatedTickTooltips, axes.y1.values);
	                    }
	                    else {
	                        y1AxisGraphicsElement
	                            .call(axes.y1.axis);
	                    }
	                    y1AxisGraphicsElement
	                        .call(SvgCartesianAxes.darkenZeroLine)
	                        .call(SvgCartesianAxes.setAxisLabelColor, yLabelColor);
	                    if (tickLabelMargins.yLeft >= leftRightMarginLimit) {
	                        y1AxisGraphicsElement.selectAll('text')
	                            .call(visuals.AxisHelper.LabelLayoutStrategy.clip, 
	                        // Can't use padding space to render text, so subtract that from available space for ellipses calculations
	                        leftRightMarginLimit - y1TickPadding, powerbi.TextMeasurementService.svgEllipsis);
	                    }
	                    if (!duration) {
	                        SvgCartesianAxes.updateTickTooltips(y1AxisGraphicsElement, axes.y1.values);
	                    }
	                    if (axes.y2 && (!this.valueAxisProperties || this.valueAxisProperties['secShow'] == null || this.valueAxisProperties['secShow'])) {
	                        y2LabelColor = this.valueAxisProperties && this.valueAxisProperties['secLabelColor'] ? this.valueAxisProperties['secLabelColor'] : null;
	                        var y2TickPadding = showY1OnRight ? axesLayout.tickPadding.left : axesLayout.tickPadding.right;
	                        axes.y2.axis
	                            .tickSize(SvgCartesianAxes.Y2TickSize)
	                            .tickPadding(y2TickPadding)
	                            .orient(showY1OnRight ? visuals.yAxisPosition.left.toLowerCase() : visuals.yAxisPosition.right.toLowerCase());
	                        var y2AxisGraphicsElement = this.y2AxisGraphicsContext;
	                        if (duration) {
	                            y2AxisGraphicsElement
	                                .transition()
	                                .duration(duration)
	                                .ease(easing)
	                                .call(axes.y2.axis)
	                                .call(SvgCartesianAxes.updateAnimatedTickTooltips, axes.y2.values);
	                        }
	                        else {
	                            y2AxisGraphicsElement
	                                .call(axes.y2.axis);
	                        }
	                        y2AxisGraphicsElement
	                            .call(SvgCartesianAxes.darkenZeroLine)
	                            .call(SvgCartesianAxes.setAxisLabelColor, y2LabelColor);
	                        if (tickLabelMargins.yRight >= leftRightMarginLimit) {
	                            y2AxisGraphicsElement.selectAll('text')
	                                .call(visuals.AxisHelper.LabelLayoutStrategy.clip, 
	                            // Can't use padding space to render text, so subtract that from available space for ellipses calculations
	                            leftRightMarginLimit - y2TickPadding, powerbi.TextMeasurementService.svgEllipsis);
	                        }
	                        if (!duration) {
	                            SvgCartesianAxes.updateTickTooltips(y2AxisGraphicsElement, axes.y2.values);
	                        }
	                    }
	                    else {
	                        this.y2AxisGraphicsContext.selectAll('*').remove();
	                    }
	                }
	                else {
	                    this.y1AxisGraphicsContext.selectAll('*').remove();
	                    this.y2AxisGraphicsContext.selectAll('*').remove();
	                }
	                // Axis labels
	                //TODO: Add label for second Y axis for combo chart
	                var axisLabels = axesLayout.axisLabels;
	                var chartHasAxisLabels = (axisLabels.x != null) || (axisLabels.y != null || axisLabels.y2 != null);
	                if (chartHasAxisLabels) {
	                    var hideXAxisTitle = !this.axes.shouldRenderAxisTitle(axes.x, /* defaultValue */ true, /* secondary */ false);
	                    var hideYAxisTitle = !this.axes.shouldRenderAxisTitle(axes.y1, /* defaultValue */ true, /* secondary */ false);
	                    var hideY2AxisTitle = !this.axes.shouldRenderAxisTitle(axes.y2, /* defaultValue */ false, /* secondary */ true);
	                    var renderAxisOptions = {
	                        axisLabels: axisLabels,
	                        viewport: viewport,
	                        margin: margin,
	                        hideXAxisTitle: hideXAxisTitle,
	                        hideYAxisTitle: hideYAxisTitle,
	                        hideY2AxisTitle: hideY2AxisTitle,
	                        xLabelColor: xLabelColor,
	                        yLabelColor: yLabelColor,
	                        y2LabelColor: y2LabelColor,
	                        fontSize: SvgCartesianAxes.AxisLabelFontSize,
	                    };
	                    this.renderAxesLabels(renderAxisOptions);
	                }
	                else {
	                    this.axisGraphicsContext.selectAll('.xAxisLabel').remove();
	                    this.axisGraphicsContext.selectAll('.yAxisLabel').remove();
	                }
	                this.translateAxes(viewport, margin);
	            };
	            SvgCartesianAxes.prototype.renderAxesLabels = function (options) {
	                debug.assertValue(options, 'options');
	                debug.assertValue(options.viewport, 'options.viewport');
	                debug.assertValue(options.axisLabels, 'options.axisLabels');
	                this.axisGraphicsContext.selectAll('.xAxisLabel').remove();
	                this.axisGraphicsContext.selectAll('.yAxisLabel').remove();
	                var margin = options.margin;
	                var width = options.viewport.width - (margin.left + margin.right);
	                var height = options.viewport.height;
	                var fontSize = options.fontSize;
	                var axisTextProperties = _.clone(CartesianChart.AxisTextProperties);
	                axisTextProperties.fontSize = fontSize + "px";
	                var showOnRight = this.axes.shouldShowY1OnRight();
	                if (!options.hideXAxisTitle) {
	                    axisTextProperties.text = options.axisLabels.x;
	                    var heightOffset_1 = powerbi.TextMeasurementService.estimateSvgTextHeight(axisTextProperties);
	                    var xAxisLabel = this.axisGraphicsContext.append("text")
	                        .style("text-anchor", "middle")
	                        .text(options.axisLabels.x)
	                        .call(function (text) {
	                        text.each(function () {
	                            var text = d3.select(this);
	                            text.attr({
	                                "class": "xAxisLabel",
	                                "transform": visuals.SVGUtil.translate(width / 2, height - heightOffset_1)
	                            });
	                        });
	                    });
	                    xAxisLabel.style("fill", options.xLabelColor ? options.xLabelColor.solid.color : null);
	                    xAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width, powerbi.TextMeasurementService.svgEllipsis)
	                        .call(visuals.tooltipUtils.tooltipUpdate, [options.axisLabels.x]);
	                }
	                if (!options.hideYAxisTitle) {
	                    axisTextProperties.text = options.axisLabels.y;
	                    var textHeight_1 = powerbi.TextMeasurementService.estimateSvgTextHeight(axisTextProperties);
	                    var yAxisLabel = this.axisGraphicsContext.append("text")
	                        .style("text-anchor", "middle")
	                        .text(options.axisLabels.y)
	                        .call(function (text) {
	                        text.each(function () {
	                            var text = d3.select(this);
	                            text.attr({
	                                "class": "yAxisLabel",
	                                "transform": "rotate(-90)",
	                                "y": showOnRight ? width + margin.right - textHeight_1 : -margin.left,
	                                "x": -((height - margin.top - margin.bottom) / 2),
	                                "dy": "1em",
	                            });
	                        });
	                    });
	                    yAxisLabel.style("fill", options.yLabelColor ? options.yLabelColor.solid.color : null);
	                    yAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis)
	                        .call(visuals.tooltipUtils.tooltipUpdate, [options.axisLabels.y]);
	                }
	                if (!options.hideY2AxisTitle && options.axisLabels.y2) {
	                    axisTextProperties.text = options.axisLabels.y2;
	                    var textHeight_2 = powerbi.TextMeasurementService.estimateSvgTextHeight(axisTextProperties);
	                    var y2AxisLabel = this.axisGraphicsContext.append("text")
	                        .style("text-anchor", "middle")
	                        .text(options.axisLabels.y2)
	                        .call(function (text) {
	                        text.each(function () {
	                            var text = d3.select(this);
	                            text.attr({
	                                "class": "yAxisLabel",
	                                "transform": "rotate(-90)",
	                                "y": showOnRight ? -margin.left : width + margin.right - textHeight_2,
	                                "x": -((height - margin.top - margin.bottom) / 2),
	                                "dy": "1em",
	                            });
	                        });
	                    });
	                    y2AxisLabel.style("fill", options.y2LabelColor ? options.y2LabelColor.solid.color : null);
	                    y2AxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis)
	                        .call(visuals.tooltipUtils.tooltipUpdate, [options.axisLabels.y2]);
	                }
	            };
	            SvgCartesianAxes.prototype.translateAxes = function (viewport, margin) {
	                var width = viewport.width - (margin.left + margin.right);
	                var height = viewport.height - (margin.top + margin.bottom);
	                var showY1OnRight = this.axes.shouldShowY1OnRight();
	                this.xAxisGraphicsContext
	                    .attr('transform', visuals.SVGUtil.translate(0, height));
	                this.y1AxisGraphicsContext
	                    .attr('transform', visuals.SVGUtil.translate(showY1OnRight ? width : 0, 0));
	                this.y2AxisGraphicsContext
	                    .attr('transform', visuals.SVGUtil.translate(showY1OnRight ? 0 : width, 0));
	                this.svgScrollable.attr({
	                    'x': 0,
	                    'width': viewport.width,
	                    'height': viewport.height
	                });
	                this.axisGraphicsContext.attr('transform', visuals.SVGUtil.translate(margin.left, margin.top));
	                this.axisGraphicsContextScrollable.attr('transform', visuals.SVGUtil.translate(margin.left, margin.top));
	                this.labelRegion.attr('transform', visuals.SVGUtil.translate(margin.left, margin.top));
	                this.labelBackgroundRegion.attr('transform', visuals.SVGUtil.translate(margin.left, margin.top));
	                if (this.axes.isXScrollBarVisible) {
	                    this.svgScrollable.attr({
	                        'x': margin.left
	                    });
	                    this.axisGraphicsContextScrollable.attr('transform', visuals.SVGUtil.translate(0, margin.top));
	                    this.labelRegion.attr('transform', visuals.SVGUtil.translate(0, margin.top));
	                    this.labelBackgroundRegion.attr('transform', visuals.SVGUtil.translate(0, margin.top));
	                    this.svgScrollable.attr('width', width);
	                }
	                else if (this.axes.isYScrollBarVisible) {
	                    this.svgScrollable.attr('height', height + margin.top);
	                }
	            };
	            /**
	             * Within the context of the given selection (g), find the offset of
	             * the zero tick using the d3 attached datum of g.tick elements.
	             * 'Classed' is undefined for transition selections
	             */
	            SvgCartesianAxes.darkenZeroLine = function (g) {
	                // remove zero-line class from all first, filtering can cause lines that are no longer zero to still be dark (since the key is index based)
	                g.selectAll('g.tick line').classed('zero-line', false);
	                var zeroTick = g.selectAll('g.tick').filter(function (data) { return data === 0; }).node();
	                if (zeroTick) {
	                    d3.select(zeroTick).select('line').classed('zero-line', true);
	                }
	            };
	            SvgCartesianAxes.setAxisLabelColor = function (g, fill) {
	                g.selectAll('g.tick text').style('fill', fill ? fill.solid.color : null);
	            };
	            // These match D3's internal axis padding values
	            SvgCartesianAxes.AxisPadding = {
	                left: 10,
	                right: 10,
	                top: 0,
	                bottom: 13,
	            };
	            SvgCartesianAxes.AxisGraphicsContext = createClassAndSelector('axisGraphicsContext');
	            SvgCartesianAxes.TickPaddingRotatedX = 5;
	            SvgCartesianAxes.AxisLabelFontSize = 11;
	            SvgCartesianAxes.Y2TickSize = -6;
	            return SvgCartesianAxes;
	        }());
	        visuals.SvgCartesianAxes = SvgCartesianAxes;
	        var CartesianAxes = (function () {
	            function CartesianAxes(isScrollable, scrollbarWidth, trimOrdinalDataOnOverflow) {
	                this.scrollbarWidth = scrollbarWidth;
	                this.isScrollable = isScrollable;
	                this.maxMarginFactor = CartesianAxes.MaxMarginFactor;
	                this.yAxisOrientation = visuals.yAxisPosition.left;
	                this.trimOrdinalDataOnOverflow = trimOrdinalDataOnOverflow;
	            }
	            CartesianAxes.prototype.shouldShowY1OnRight = function () {
	                return this.yAxisOrientation === visuals.yAxisPosition.right;
	            };
	            CartesianAxes.prototype.isYAxisCategorical = function () {
	                return this.layout && this.layout.axes.y1.isCategoryAxis;
	            };
	            CartesianAxes.prototype.hasCategoryAxis = function () {
	                var axes = this.layout && this.layout.axes;
	                if (!axes)
	                    return false;
	                return this.isYAxisCategorical()
	                    ? axes.y1 && axes.y1.axis != null
	                    : axes.x && axes.x.axis != null;
	            };
	            CartesianAxes.prototype.hasY2Axis = function () {
	                return this.layout && this.layout.axes.y2 != null;
	            };
	            CartesianAxes.prototype.getYAxisOrientation = function () {
	                return this.yAxisOrientation;
	            };
	            CartesianAxes.prototype.setAxisLinesVisibility = function (axisLinesVisibility) {
	                this.showLinesOnX = EnumExtensions.hasFlag(axisLinesVisibility, 3 /* ShowLinesOnBothAxis */) ||
	                    EnumExtensions.hasFlag(axisLinesVisibility, 1 /* ShowLinesOnXAxis */);
	                this.showLinesOnY = EnumExtensions.hasFlag(axisLinesVisibility, 3 /* ShowLinesOnBothAxis */) ||
	                    EnumExtensions.hasFlag(axisLinesVisibility, 2 /* ShowLinesOnYAxis */);
	            };
	            CartesianAxes.prototype.setMaxMarginFactor = function (factor) {
	                this.maxMarginFactor = factor;
	            };
	            CartesianAxes.prototype.update = function (dataViews) {
	                if (dataViews && dataViews.length > 0) {
	                    var dataViewMetadata = dataViews[0].metadata;
	                    this.categoryAxisProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataViewMetadata);
	                    this.valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataViewMetadata);
	                }
	                var axisPosition = this.valueAxisProperties['position'];
	                this.yAxisOrientation = axisPosition ? axisPosition.toString() : visuals.yAxisPosition.left;
	            };
	            CartesianAxes.prototype.addWarnings = function (warnings) {
	                var axes = this.layout && this.layout.axes;
	                if (axes && axes.x && axes.x.hasDisallowedZeroInDomain
	                    || axes.y1 && axes.y1.hasDisallowedZeroInDomain
	                    || axes.y2 && axes.y2.hasDisallowedZeroInDomain) {
	                    warnings.unshift(new visuals.ZeroValueWarning());
	                }
	            };
	            /**
	             * Computes the Cartesian Chart axes from the set of layers.
	             */
	            CartesianAxes.prototype.calculateAxes = function (layers, viewport, margin, playAxisControlLayout, textProperties, scrollbarVisible, existingAxisProperties, hideAxisTitles, ensureXDomain, ensureYDomain) {
	                debug.assertValue(layers, 'layers');
	                var visualOptions = {
	                    viewport: viewport,
	                    margin: margin,
	                    forcedXDomain: [this.categoryAxisProperties ? this.categoryAxisProperties['start'] : null, this.categoryAxisProperties ? this.categoryAxisProperties['end'] : null],
	                    forceMerge: this.valueAxisProperties && this.valueAxisProperties['secShow'] === false,
	                    showCategoryAxisLabel: false,
	                    showValueAxisLabel: false,
	                    trimOrdinalDataOnOverflow: this.trimOrdinalDataOnOverflow,
	                    categoryAxisScaleType: this.categoryAxisProperties && this.categoryAxisProperties['axisScale'] != null ? this.categoryAxisProperties['axisScale'] : DEFAULT_AXIS_SCALE_TYPE,
	                    valueAxisScaleType: this.valueAxisProperties && this.valueAxisProperties['axisScale'] != null ? this.valueAxisProperties['axisScale'] : DEFAULT_AXIS_SCALE_TYPE,
	                    categoryAxisDisplayUnits: this.categoryAxisProperties && this.categoryAxisProperties['labelDisplayUnits'] != null ? this.categoryAxisProperties['labelDisplayUnits'] : 0,
	                    valueAxisDisplayUnits: this.valueAxisProperties && this.valueAxisProperties['labelDisplayUnits'] != null ? this.valueAxisProperties['labelDisplayUnits'] : 0,
	                    categoryAxisPrecision: this.categoryAxisProperties ? visuals.CartesianHelper.getPrecision(this.categoryAxisProperties['labelPrecision']) : null,
	                    valueAxisPrecision: this.valueAxisProperties ? visuals.CartesianHelper.getPrecision(this.valueAxisProperties['labelPrecision']) : null,
	                    playAxisControlLayout: playAxisControlLayout,
	                    ensureXDomain: ensureXDomain,
	                    ensureYDomain: ensureYDomain,
	                };
	                var skipMerge = this.valueAxisProperties && this.valueAxisProperties['secShow'] === true;
	                var yAxisWillMerge = false;
	                var mergeResult;
	                if (hasMultipleYAxes(layers) && !skipMerge) {
	                    mergeResult = tryMergeYDomains(layers, visualOptions);
	                    yAxisWillMerge = mergeResult.merged;
	                    if (yAxisWillMerge) {
	                        visualOptions.forcedYDomain = mergeResult.domain;
	                    }
	                    else {
	                        visualOptions.forcedTickCount = mergeResult.tickCount;
	                    }
	                }
	                if (this.valueAxisProperties) {
	                    visualOptions.forcedYDomain = visuals.AxisHelper.applyCustomizedDomain([this.valueAxisProperties['start'], this.valueAxisProperties['end']], visualOptions.forcedYDomain);
	                }
	                var result;
	                for (var layerNumber = 0, len = layers.length; layerNumber < len; layerNumber++) {
	                    var currentlayer = layers[layerNumber];
	                    if (layerNumber === 1 && !yAxisWillMerge) {
	                        visualOptions.forcedYDomain = this.valueAxisProperties ? [this.valueAxisProperties['secStart'], this.valueAxisProperties['secEnd']] : null;
	                        visualOptions.valueAxisScaleType = this.valueAxisProperties && this.valueAxisProperties['secAxisScale'] != null ? this.valueAxisProperties['secAxisScale'] : DEFAULT_AXIS_SCALE_TYPE;
	                        visualOptions.valueAxisDisplayUnits = this.valueAxisProperties && this.valueAxisProperties['secLabelDisplayUnits'] != null ? this.valueAxisProperties['secLabelDisplayUnits'] : 0;
	                        visualOptions.valueAxisPrecision = this.valueAxisProperties ? visuals.CartesianHelper.getPrecision(this.valueAxisProperties['secLabelPrecision']) : null;
	                    }
	                    visualOptions.showCategoryAxisLabel = (!!this.categoryAxisProperties && !!this.categoryAxisProperties['showAxisTitle']); //here
	                    visualOptions.showValueAxisLabel = shouldShowYAxisLabel(layerNumber, this.valueAxisProperties, yAxisWillMerge);
	                    var axes = currentlayer.calculateAxesProperties(visualOptions);
	                    if (layerNumber === 0) {
	                        result = {
	                            x: axes[0],
	                            y1: axes[1]
	                        };
	                    }
	                    else if (axes && !result.y2) {
	                        if (result.x.usingDefaultDomain || _.isEmpty(result.x.dataDomain)) {
	                            visualOptions.showValueAxisLabel = (!!this.valueAxisProperties && !!this.valueAxisProperties['showAxisTitle']);
	                            var axes_1 = currentlayer.calculateAxesProperties(visualOptions);
	                            // no categories returned for the first layer, use second layer x-axis properties
	                            result.x = axes_1[0];
	                            // and 2nd value axis to be the primary
	                            result.y1 = axes_1[1];
	                        }
	                        else {
	                            // make sure all layers use the same x-axis/scale for drawing
	                            currentlayer.overrideXScale(result.x);
	                            if (!yAxisWillMerge && !axes[1].usingDefaultDomain)
	                                result.y2 = axes[1];
	                        }
	                    }
	                    if (existingAxisProperties && existingAxisProperties.x) {
	                        result.x.willLabelsFit = existingAxisProperties.x.willLabelsFit;
	                        result.x.willLabelsWordBreak = existingAxisProperties.x.willLabelsWordBreak;
	                    }
	                    else {
	                        var width = viewport.width - (margin.left + margin.right);
	                        result.x.willLabelsFit = visuals.AxisHelper.LabelLayoutStrategy.willLabelsFit(result.x, width, powerbi.TextMeasurementService.measureSvgTextWidth, textProperties);
	                        // If labels do not fit and we are not scrolling, try word breaking
	                        result.x.willLabelsWordBreak = (!result.x.willLabelsFit && !scrollbarVisible) && visuals.AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(result.x, margin, width, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, powerbi.TextMeasurementService.getTailoredTextOrDefault, textProperties);
	                    }
	                }
	                // Adjust for axis titles
	                if (hideAxisTitles) {
	                    result.x.axisLabel = null;
	                    result.y1.axisLabel = null;
	                    if (result.y2) {
	                        result.y2.axisLabel = null;
	                    }
	                }
	                this.addUnitTypeToAxisLabels(result);
	                return result;
	            };
	            /**
	             * Negotiate the axes regions, the plot area, and determine if we need a scrollbar for ordinal categories.
	             * @param layers an array of Cartesian layout layers (column, line, etc.)
	             * @param parentViewport the full viewport for the visual
	             * @param padding the D3 axis padding values
	             * @param playAxisControlLayout if this is a playable Cartesian chart, includes the layout for the play controls (start/stop, time slider)
	             * @param hideAxisLabels forces axis titles to be hidden
	             * @param textProperties text properties to be used by text measurement
	             * @param interactivityRightMargin extra right margin for the interactivity
	             * @param ensureXDomain if non null, includes values that must be part of the axis domain
	             * @param ensureYDomain if non null, includes values that must be part of the axis domain
	             */
	            CartesianAxes.prototype.negotiateAxes = function (layers, parentViewport, padding, playAxisControlLayout, hideAxisLabels, textProperties, interactivityRightMargin, ensureXDomain, ensureYDomain) {
	                // 1> MinMargins -> some initial axis properties / text
	                // 2> Get axis margins for the initial text, no rotateXTickLabels90. margins grown? -> axis properties / text again (possibly more tick labels now)
	                // ?> do we have more labels? do we need rotate? are we done?
	                // 3> margins again (rotate? margins grow?) -> text again (less tick labls now?)
	                // FREEZE PROPERTIES THAT CAN CHANGE
	                // 4> margins (final), axes (final)
	                // 1.a) initialize margins
	                var margin = powerbi.Prototype.inherit(CartesianAxes.MinimumMargin);
	                var viewport = powerbi.Prototype.inherit(parentViewport);
	                var leftRightMarginLimit = viewport.width * this.maxMarginFactor;
	                var bottomMarginLimit = Math.max(CartesianAxes.MinimumMargin.bottom, Math.ceil(viewport.height * this.maxMarginFactor));
	                var marginLimits = {
	                    left: leftRightMarginLimit,
	                    right: leftRightMarginLimit,
	                    top: 0,
	                    bottom: bottomMarginLimit,
	                };
	                // 1.b) Calculate axis properties using initial margins
	                var axes = this.calculateAxes(layers, viewport, margin, playAxisControlLayout, textProperties, 
	                /*scrollbarVisible*/ false, 
	                /*previousAxisProperties*/ null, hideAxisLabels, ensureXDomain, ensureYDomain);
	                // these are used by getTickLabelMargins
	                var renderXAxis = this.shouldRenderAxis(axes.x);
	                var renderY1Axis = this.shouldRenderAxis(axes.y1);
	                var renderY2Axis = this.shouldRenderAxis(axes.y2, true);
	                var showY1OnRight = this.shouldShowY1OnRight();
	                var plotArea = {
	                    width: viewport.width - (margin.left + margin.right),
	                    height: viewport.height - (margin.top + margin.bottom)
	                };
	                var isScalar = false;
	                if (!_.isEmpty(layers)) {
	                    if (layers[0].getVisualCategoryAxisIsScalar)
	                        isScalar = layers[0].getVisualCategoryAxisIsScalar();
	                }
	                // 2.a) calculate axis tick margins
	                var tickLabelMargins = undefined;
	                tickLabelMargins = visuals.AxisHelper.getTickLabelMargins(plotArea, marginLimits.left, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, axes, marginLimits.bottom, textProperties, 
	                /*scrolling*/ false, showY1OnRight, renderXAxis, renderY1Axis, renderY2Axis);
	                margin = this.updateAxisMargins(axes, tickLabelMargins, padding, showY1OnRight, renderY1Axis, renderY2Axis, isScalar ? 0 : interactivityRightMargin);
	                // if any of these change, we need to calculate margins again
	                var previousTickCountY1 = axes.y1 && axes.y1.values.length;
	                var previousTickCountY2 = axes.y2 && axes.y2.values.length;
	                var previousWillFitX = axes.x && axes.x.willLabelsFit;
	                var previousWillBreakX = axes.x && axes.x.willLabelsWordBreak;
	                // 2.b) Re-calculate the axes with the new margins.
	                axes = this.calculateAxes(layers, viewport, margin, playAxisControlLayout, textProperties, 
	                /*scrollbarVisible*/ false, 
	                /*previousAxes*/ null, hideAxisLabels, ensureXDomain, ensureYDomain);
	                plotArea.width = viewport.width - (margin.left + margin.right);
	                plotArea.height = viewport.height - (margin.top + margin.bottom);
	                // check properties that affect getTickLabelMargin - if these are the same, we don't need to calculate axis margins again
	                var preferredPlotArea = this.getPreferredPlotArea(axes, layers, isScalar);
	                var rotateXTickLabels90 = !this.willAllCategoriesFitInPlotArea(plotArea, preferredPlotArea);
	                var allDone = ((!axes.y1 || axes.y1.values.length === previousTickCountY1)
	                    && (!axes.y2 || axes.y2.values.length === previousTickCountY2)
	                    && (!axes.x || axes.x.willLabelsFit === previousWillFitX)
	                    && (!axes.x || axes.x.willLabelsWordBreak === previousWillBreakX)
	                    && !rotateXTickLabels90);
	                this.isXScrollBarVisible = false;
	                this.isYScrollBarVisible = false;
	                if (!allDone) {
	                    // 3.a) calculate axis tick margins
	                    tickLabelMargins = visuals.AxisHelper.getTickLabelMargins(plotArea, marginLimits.left, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, axes, marginLimits.bottom, textProperties, rotateXTickLabels90, showY1OnRight, renderXAxis, renderY1Axis, renderY2Axis);
	                    margin = this.updateAxisMargins(axes, tickLabelMargins, padding, showY1OnRight, renderY1Axis, renderY2Axis, isScalar ? 0 : interactivityRightMargin);
	                    // 3.b) Re-calculate the axes with the new final margins
	                    axes = this.calculateAxes(layers, viewport, margin, playAxisControlLayout, textProperties, 
	                    /*scrollbarVisible*/ rotateXTickLabels90, axes, hideAxisLabels, ensureXDomain, ensureYDomain);
	                    // now we can determine if we need actual scrolling
	                    // rotateXTickLabels90 will give more plotArea to categories since the left-overflow of a rotated category label doesn't exist anymore
	                    plotArea.width = viewport.width - (margin.left + margin.right);
	                    plotArea.height = viewport.height - (margin.top + margin.bottom);
	                    preferredPlotArea = this.getPreferredPlotArea(axes, layers, isScalar);
	                    var willScroll = !this.willAllCategoriesFitInPlotArea(plotArea, preferredPlotArea);
	                    if (willScroll) {
	                        if (this.showLinesOnY) {
	                            this.isXScrollBarVisible = true;
	                            plotArea.height -= this.scrollbarWidth;
	                            viewport.height -= this.scrollbarWidth;
	                        }
	                        if (this.showLinesOnX) {
	                            this.isYScrollBarVisible = true;
	                            plotArea.width -= this.scrollbarWidth;
	                            viewport.width -= this.scrollbarWidth;
	                        }
	                        // 3.c) Re-calculate the axes with the final margins (and the updated viewport - scrollbarWidth)
	                        axes = this.calculateAxes(layers, viewport, margin, playAxisControlLayout, textProperties, 
	                        /*scrollbarVisible*/ true, axes, hideAxisLabels, ensureXDomain, ensureYDomain);
	                    }
	                }
	                ///////DONE
	                var axisLabels = hideAxisLabels ?
	                    { x: null, y: null, y2: null } :
	                    { x: axes.x.axisLabel, y: axes.y1.axisLabel, y2: axes.y2 ? axes.y2.axisLabel : null };
	                this.layout = {
	                    axes: axes,
	                    axisLabels: axisLabels,
	                    margin: margin,
	                    marginLimits: marginLimits,
	                    viewport: viewport,
	                    plotArea: plotArea,
	                    preferredPlotArea: preferredPlotArea,
	                    tickLabelMargins: tickLabelMargins,
	                    tickPadding: padding,
	                    rotateXTickLabels90: rotateXTickLabels90,
	                };
	                return this.layout;
	            };
	            CartesianAxes.prototype.getPreferredPlotArea = function (axes, layers, isScalar) {
	                var preferredPlotArea;
	                if (!isScalar && this.isScrollable && !_.isEmpty(layers) && layers[0].getPreferredPlotArea) {
	                    var categoryThickness = this.showLinesOnY ? axes.x.categoryThickness : axes.y1.categoryThickness;
	                    var categoryCount = this.showLinesOnY ? axes.x.dataDomain.length : axes.y1.dataDomain.length;
	                    preferredPlotArea = layers[0].getPreferredPlotArea(isScalar, categoryCount, categoryThickness);
	                }
	                return preferredPlotArea;
	            };
	            CartesianAxes.prototype.willAllCategoriesFitInPlotArea = function (plotArea, preferredPlotArea) {
	                if (this.showLinesOnY && preferredPlotArea && powerbi.Double.greaterWithPrecision(preferredPlotArea.width, plotArea.width)) {
	                    return false;
	                }
	                if (this.showLinesOnX && preferredPlotArea && powerbi.Double.greaterWithPrecision(preferredPlotArea.height, plotArea.height)) {
	                    return false;
	                }
	                return true;
	            };
	            CartesianAxes.prototype.updateAxisMargins = function (axes, tickLabelMargins, padding, showY1OnRight, renderY1Axis, renderY2Axis, interactivityRightMargin) {
	                // We look at the y axes as main and second sides, if the y axis orientation is right then the main side represents the right side.
	                var maxY1Padding = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft, maxY2Padding = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight, maxXAxisBottom = tickLabelMargins.xMax;
	                maxY1Padding += padding.left;
	                if ((renderY2Axis && !showY1OnRight) || (showY1OnRight && renderY1Axis))
	                    maxY2Padding += padding.right;
	                maxXAxisBottom += padding.bottom;
	                var axisLabels = { x: axes.x.axisLabel, y: axes.y1.axisLabel, y2: axes.y2 ? axes.y2.axisLabel : null };
	                if (axisLabels.x != null)
	                    maxXAxisBottom += CartesianAxes.XAxisLabelPadding;
	                if (axisLabels.y != null)
	                    maxY1Padding += CartesianAxes.YAxisLabelPadding;
	                if (axisLabels.y2 != null)
	                    maxY2Padding += CartesianAxes.YAxisLabelPadding;
	                var margin = powerbi.Prototype.inherit(CartesianAxes.MinimumMargin);
	                margin.left = showY1OnRight ? maxY2Padding : maxY1Padding;
	                margin.right = showY1OnRight ? maxY1Padding : maxY2Padding;
	                margin.right += interactivityRightMargin; // for mobile interactive legend
	                margin.bottom = maxXAxisBottom;
	                return margin;
	            };
	            CartesianAxes.prototype.isLogScaleAllowed = function (axisType) {
	                var axes = this.layout && this.layout.axes;
	                if (!axes)
	                    return false;
	                switch (axisType) {
	                    case 0 /* X */:
	                        return axes.x.isLogScaleAllowed;
	                    case 1 /* Y1 */:
	                        return axes.y1.isLogScaleAllowed;
	                    case 2 /* Y2 */:
	                        return axes.y2 && axes.y2.isLogScaleAllowed;
	                }
	            };
	            CartesianAxes.prototype.axesHaveTicks = function (viewport) {
	                if (!this.layout)
	                    return false;
	                var margin = this.layout.margin;
	                var width = viewport.width - (margin.left + margin.right);
	                var height = viewport.height - (margin.top + margin.bottom);
	                // TODO: this is never the case, remove.
	                if (visuals.AxisHelper.getRecommendedNumberOfTicksForXAxis(width) === 0
	                    && visuals.AxisHelper.getRecommendedNumberOfTicksForYAxis(height) === 0) {
	                    return false;
	                }
	                return true;
	            };
	            CartesianAxes.prototype.shouldRenderAxisTitle = function (axisProperties, defaultValue, secondary) {
	                var propertyName = secondary ? 'secShowAxisTitle' : 'showAxisTitle';
	                return !!this.getAxisProperty(axisProperties, propertyName, defaultValue);
	            };
	            CartesianAxes.prototype.shouldRenderAxis = function (axisProperties, secondary) {
	                if (secondary === void 0) { secondary = false; }
	                if (!axisProperties)
	                    return false;
	                var propertyName = secondary ? 'secShow' : 'show';
	                return this.getAxisProperty(axisProperties, propertyName, true)
	                    && axisProperties.values
	                    && axisProperties.values.length > 0;
	            };
	            CartesianAxes.prototype.getAxisProperty = function (axisProperties, propertyName, defaultValue) {
	                if (!axisProperties)
	                    return defaultValue;
	                var properties = axisProperties.isCategoryAxis
	                    ? this.categoryAxisProperties
	                    : this.valueAxisProperties;
	                if (properties && properties[propertyName] != null)
	                    return properties[propertyName];
	                else
	                    return defaultValue;
	            };
	            // TODO: clean this up
	            CartesianAxes.prototype.addUnitTypeToAxisLabels = function (axes) {
	                var unitType = CartesianAxes.getUnitType(axes.x.formatter);
	                if (axes.x.isCategoryAxis) {
	                    this.categoryAxisHasUnitType = unitType != null;
	                }
	                else {
	                    this.valueAxisHasUnitType = unitType != null;
	                }
	                if (axes.x.axisLabel && unitType) {
	                    if (axes.x.isCategoryAxis) {
	                        axes.x.axisLabel = visuals.AxisHelper.createAxisLabel(this.categoryAxisProperties, axes.x.axisLabel, unitType);
	                    }
	                    else {
	                        axes.x.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, axes.x.axisLabel, unitType);
	                    }
	                }
	                unitType = CartesianAxes.getUnitType(axes.y1.formatter);
	                if (!axes.y1.isCategoryAxis) {
	                    this.valueAxisHasUnitType = unitType != null;
	                }
	                else {
	                    this.categoryAxisHasUnitType = unitType != null;
	                }
	                if (axes.y1.axisLabel && unitType) {
	                    if (!axes.y1.isCategoryAxis) {
	                        axes.y1.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, axes.y1.axisLabel, unitType);
	                    }
	                    else {
	                        axes.y1.axisLabel = visuals.AxisHelper.createAxisLabel(this.categoryAxisProperties, axes.y1.axisLabel, unitType);
	                    }
	                }
	                if (axes.y2) {
	                    var unitType_1 = CartesianAxes.getUnitType(axes.y2.formatter);
	                    this.secondaryValueAxisHasUnitType = unitType_1 != null;
	                    if (axes.y2.axisLabel && unitType_1) {
	                        axes.y2.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, axes.y2.axisLabel, unitType_1, true);
	                    }
	                }
	            };
	            CartesianAxes.getUnitType = function (formatter) {
	                if (formatter &&
	                    formatter.displayUnit &&
	                    formatter.displayUnit.value > 1)
	                    return formatter.displayUnit.title;
	            };
	            CartesianAxes.YAxisLabelPadding = 20;
	            CartesianAxes.XAxisLabelPadding = 18;
	            CartesianAxes.MaxMarginFactor = 0.25;
	            CartesianAxes.MinimumMargin = {
	                left: 1,
	                right: 1,
	                top: 8,
	                bottom: 25,
	            };
	            return CartesianAxes;
	        }());
	        visuals.CartesianAxes = CartesianAxes;
	        var CartesianLayerFactory;
	        (function (CartesianLayerFactory) {
	            function createLayers(type, objects, interactivityService, animator, isScrollable, tooltipsEnabled, tooltipBucketEnabled, advancedLineLabelsEnabled) {
	                if (isScrollable === void 0) { isScrollable = false; }
	                var layers = [];
	                var cartesianOptions = {
	                    isScrollable: isScrollable,
	                    animator: animator,
	                    interactivityService: interactivityService,
	                    tooltipsEnabled: tooltipsEnabled,
	                    tooltipBucketEnabled: tooltipBucketEnabled,
	                    advancedLineLabelsEnabled: advancedLineLabelsEnabled
	                };
	                switch (type) {
	                    case 1 /* Area */:
	                        layers.push(createLineChartLayer(2 /* area */, /* inComboChart */ false, cartesianOptions));
	                        //layers.push(createLineChartLayer(LineChartType.default, /* inComboChart */ false, cartesianOptions, true));
	                        break;
	                    case 0 /* Line */:
	                        layers.push(createLineChartLayer(1 /* default */, /* inComboChart */ false, cartesianOptions));
	                        //layers.push(createLineChartLayer(LineChartType.default, /* inComboChart */ false, cartesianOptions, true));
	                        break;
	                    case 2 /* StackedArea */:
	                        layers.push(createLineChartLayer(16 /* stackedArea */, /* inComboChart */ false, cartesianOptions));
	                        break;
	                    case 9 /* Scatter */:
	                        layers.push(createScatterChartLayer(cartesianOptions));
	                        //layers.push(createLineChartLayer(LineChartType.default, /* inComboChart */ false, cartesianOptions, true));
	                        break;
	                    case 12 /* Waterfall */:
	                        layers.push(createWaterfallChartLayer(cartesianOptions));
	                        break;
	                    case 11 /* DataDot */:
	                        layers.push(createDataDotChartLayer(cartesianOptions));
	                        break;
	                    case 4 /* StackedColumn */:
	                        layers.push(createColumnChartLayer(visuals.ColumnChartType.stackedColumn, cartesianOptions));
	                        break;
	                    case 3 /* ClusteredColumn */:
	                        layers.push(createColumnChartLayer(visuals.ColumnChartType.clusteredColumn, cartesianOptions));
	                        break;
	                    case 8 /* HundredPercentStackedColumn */:
	                        layers.push(createColumnChartLayer(visuals.ColumnChartType.hundredPercentStackedColumn, cartesianOptions));
	                        break;
	                    case 6 /* StackedBar */:
	                        layers.push(createColumnChartLayer(visuals.ColumnChartType.stackedBar, cartesianOptions));
	                        break;
	                    case 5 /* ClusteredBar */:
	                        layers.push(createColumnChartLayer(visuals.ColumnChartType.clusteredBar, cartesianOptions));
	                        break;
	                    case 7 /* HundredPercentStackedBar */:
	                        layers.push(createColumnChartLayer(visuals.ColumnChartType.hundredPercentStackedBar, cartesianOptions));
	                        break;
	                    case 10 /* ComboChart */:
	                        var columnType = getComboColumnType();
	                        layers.push(createColumnChartLayer(columnType, cartesianOptions));
	                        layers.push(createLineChartLayer(1 /* default */, /* inComboChart */ true, cartesianOptions));
	                        break;
	                    case 13 /* LineClusteredColumnCombo */:
	                        layers.push(createColumnChartLayer(visuals.ColumnChartType.clusteredColumn, cartesianOptions));
	                        layers.push(createLineChartLayer(1 /* default */, /* inComboChart */ true, cartesianOptions));
	                        break;
	                    case 14 /* LineStackedColumnCombo */:
	                        layers.push(createColumnChartLayer(visuals.ColumnChartType.stackedColumn, cartesianOptions));
	                        layers.push(createLineChartLayer(1 /* default */, /* inComboChart */ true, cartesianOptions));
	                        break;
	                    case 15 /* DataDotClusteredColumnCombo */:
	                        layers.push(createColumnChartLayer(visuals.ColumnChartType.clusteredColumn, cartesianOptions));
	                        layers.push(createDataDotChartLayer(cartesianOptions));
	                        break;
	                    case 16 /* DataDotStackedColumnCombo */:
	                        layers.push(createColumnChartLayer(visuals.ColumnChartType.stackedColumn, cartesianOptions));
	                        layers.push(createDataDotChartLayer(cartesianOptions));
	                        break;
	                }
	                return layers;
	            }
	            CartesianLayerFactory.createLayers = createLayers;
	            function createLineChartLayer(type, inComboChart, defaultOptions, isTrendLayer) {
	                var options = {
	                    animator: defaultOptions.animator,
	                    interactivityService: defaultOptions.interactivityService,
	                    isScrollable: defaultOptions.isScrollable,
	                    tooltipsEnabled: !isTrendLayer && defaultOptions.tooltipsEnabled,
	                    tooltipBucketEnabled: defaultOptions.tooltipBucketEnabled,
	                    chartType: type,
	                    advancedLineLabelsEnabled: defaultOptions.advancedLineLabelsEnabled
	                };
	                if (inComboChart) {
	                    options.chartType = options.chartType | 8 /* lineShadow */;
	                }
	                return new visuals.LineChart(options);
	            }
	            function createScatterChartLayer(defaultOptions) {
	                defaultOptions.isScrollable = false;
	                return new visuals.ScatterChart(defaultOptions);
	            }
	            function createWaterfallChartLayer(defaultOptions) {
	                return new visuals.WaterfallChart(defaultOptions);
	            }
	            function createDataDotChartLayer(defaultOptions) {
	                return new visuals.DataDotChart(defaultOptions);
	            }
	            function createColumnChartLayer(type, defaultOptions) {
	                var options = {
	                    animator: defaultOptions.animator,
	                    interactivityService: defaultOptions.interactivityService,
	                    isScrollable: defaultOptions.isScrollable,
	                    tooltipsEnabled: defaultOptions.tooltipsEnabled,
	                    tooltipBucketEnabled: defaultOptions.tooltipBucketEnabled,
	                    chartType: type
	                };
	                return new visuals.ColumnChart(options);
	            }
	            function getComboColumnType(objects) {
	                // This supports existing serialized forms of pinned combo-chart visuals
	                var columnType = visuals.ColumnChartType.clusteredColumn;
	                if (objects) {
	                    var comboChartTypes = objects.general;
	                    if (comboChartTypes) {
	                        switch (comboChartTypes.visualType1) {
	                            case 'Column':
	                                columnType = visuals.ColumnChartType.clusteredColumn;
	                                break;
	                            case 'ColumnStacked':
	                                columnType = visuals.ColumnChartType.stackedColumn;
	                                break;
	                            default:
	                                debug.assertFail('Unsupported cartesian chart type ' + comboChartTypes.visualType1);
	                        }
	                        // second visual is always LineChart (for now)
	                        if (comboChartTypes.visualType2) {
	                            debug.assert(comboChartTypes.visualType2 === 'Line', 'expecting a LineChart for VisualType2');
	                        }
	                    }
	                }
	                return columnType;
	            }
	        })(CartesianLayerFactory || (CartesianLayerFactory = {}));
	        var SharedColorPalette = (function () {
	            function SharedColorPalette(palette) {
	                this.palette = palette;
	                this.clearPreferredScale();
	            }
	            SharedColorPalette.prototype.getColorScaleByKey = function (scaleKey) {
	                this.setPreferredScale(scaleKey);
	                return this.preferredScale;
	            };
	            SharedColorPalette.prototype.getNewColorScale = function () {
	                return this.preferredScale;
	            };
	            SharedColorPalette.prototype.getColorByIndex = function (index) {
	                return this.palette.getColorByIndex(index);
	            };
	            SharedColorPalette.prototype.getSentimentColors = function () {
	                return this.palette.getSentimentColors();
	            };
	            SharedColorPalette.prototype.getBasePickerColors = function () {
	                return this.palette.getBasePickerColors();
	            };
	            SharedColorPalette.prototype.clearPreferredScale = function () {
	                this.preferredScale = this.palette.getNewColorScale();
	                this.rotated = false;
	            };
	            SharedColorPalette.prototype.rotateScale = function () {
	                // We create a new rotated the scale such that the first color of the new scale is the first
	                // free color of the previous scale. Note that the new scale does not have any colors allocated
	                // to particular keys.
	                this.preferredScale = this.preferredScale.clone();
	                this.preferredScale.clearAndRotateScale();
	                this.rotated = true;
	            };
	            SharedColorPalette.prototype.setPreferredScale = function (scaleKey) {
	                if (!this.rotated) {
	                    // The first layer to express a preference sets the preferred scale.
	                    this.preferredScale = this.palette.getColorScaleByKey(scaleKey);
	                }
	            };
	            return SharedColorPalette;
	        }());
	        visuals.SharedColorPalette = SharedColorPalette;
	        var CartesianLoadMoreDataHandler = (function () {
	            /**
	             * Constructs the handler.
	             * @param scale - The scale for the loaded data.
	             * @param loadMoreCallback - The callback to execute to load more data.
	             * @param loadMoreThreshold - How many indexes before the last index loading more data will be triggered.
	             * Ex: loadMoreThreshold = 2, dataLength = 10 (last index = 9) will trigger a load when item with index 9 - 2 = 7 or greater is displayed.
	             */
	            function CartesianLoadMoreDataHandler(scale, loadMoreCallback, loadMoreThreshold) {
	                if (loadMoreThreshold === void 0) { loadMoreThreshold = 0; }
	                debug.assertValue(loadMoreCallback, 'loadMoreCallback');
	                debug.assert(loadMoreThreshold >= 0, 'loadMoreThreshold must be greater than or equal to 0');
	                this.loadMoreThreshold = loadMoreThreshold;
	                this.loadMoreCallback = loadMoreCallback;
	                this.setScale(scale);
	            }
	            CartesianLoadMoreDataHandler.prototype.setScale = function (scale) {
	                if (!scale) {
	                    return;
	                }
	                // Length of the scale is the amount of data we have loaded. Subtract 1 to get the index.
	                // Subtract the threshold to calculate the index at which we need to load more data.
	                this.loadMoreThresholdIndex = scale.domain().length - 1 - this.loadMoreThreshold;
	            };
	            CartesianLoadMoreDataHandler.prototype.isLoadingMoreData = function () {
	                return this.loadingMoreData;
	            };
	            CartesianLoadMoreDataHandler.prototype.onLoadMoreDataCompleted = function () {
	                this.loadingMoreData = false;
	            };
	            CartesianLoadMoreDataHandler.prototype.shouldLoadMoreData = function () {
	                var viewportDataRange = this.viewportDataRange;
	                if (!viewportDataRange || this.isLoadingMoreData()) {
	                    return false;
	                }
	                // If the index of the data we're displaying is more than the threshold, return true.
	                return viewportDataRange.endIndex >= this.loadMoreThresholdIndex;
	            };
	            CartesianLoadMoreDataHandler.prototype.loadMoreData = function () {
	                if (this.isLoadingMoreData()) {
	                    return;
	                }
	                this.loadingMoreData = true;
	                this.loadMoreCallback();
	            };
	            return CartesianLoadMoreDataHandler;
	        }());
	        visuals.CartesianLoadMoreDataHandler = CartesianLoadMoreDataHandler;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 254 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var EnumExtensions = jsCommon.EnumExtensions;
	        var DataRoleHelper = powerbi.data.DataRoleHelper;
	        var flagBar = 1 << 1;
	        var flagColumn = 1 << 2;
	        var flagClustered = 1 << 3;
	        var flagStacked = 1 << 4;
	        var flagStacked100 = flagStacked | (1 << 5);
	        (function (ColumnChartType) {
	            ColumnChartType[ColumnChartType["clusteredBar"] = flagBar | flagClustered] = "clusteredBar";
	            ColumnChartType[ColumnChartType["clusteredColumn"] = flagColumn | flagClustered] = "clusteredColumn";
	            ColumnChartType[ColumnChartType["hundredPercentStackedBar"] = flagBar | flagStacked100] = "hundredPercentStackedBar";
	            ColumnChartType[ColumnChartType["hundredPercentStackedColumn"] = flagColumn | flagStacked100] = "hundredPercentStackedColumn";
	            ColumnChartType[ColumnChartType["stackedBar"] = flagBar | flagStacked] = "stackedBar";
	            ColumnChartType[ColumnChartType["stackedColumn"] = flagColumn | flagStacked] = "stackedColumn";
	        })(visuals.ColumnChartType || (visuals.ColumnChartType = {}));
	        var ColumnChartType = visuals.ColumnChartType;
	        var RoleNames = {
	            category: 'Category',
	            series: 'Series',
	            y: 'Y',
	        };
	        /**
	         * Renders a stacked and clustered column chart.
	         */
	        var ColumnChart = (function () {
	            function ColumnChart(options) {
	                debug.assertValue(options, 'options');
	                var chartType = options.chartType;
	                debug.assertValue(chartType, 'chartType');
	                this.chartType = chartType;
	                this.categoryAxisType = null;
	                this.animator = options.animator;
	                this.isScrollable = options.isScrollable;
	                this.tooltipsEnabled = options.tooltipsEnabled;
	                this.tooltipBucketEnabled = options.tooltipBucketEnabled;
	                this.interactivityService = options.interactivityService;
	            }
	            ColumnChart.customizeQuery = function (options) {
	                var dataViewMapping = options.dataViewMappings[0];
	                if (!dataViewMapping || !dataViewMapping.categorical || !dataViewMapping.categorical.categories)
	                    return;
	                dataViewMapping.categorical.dataVolume = 4;
	                if (visuals.CartesianChart.detectScalarMapping(dataViewMapping)) {
	                    var dataViewCategories = dataViewMapping.categorical.categories;
	                    dataViewCategories.dataReductionAlgorithm = { sample: {} };
	                    var values = dataViewMapping.categorical.values;
	                    if (values && values.group) {
	                        values.group.dataReductionAlgorithm = { top: {} };
	                    }
	                }
	                else {
	                    visuals.CartesianChart.expandCategoryWindow([dataViewMapping]);
	                }
	            };
	            ColumnChart.getSortableRoles = function (options) {
	                var dataViewMapping = options.dataViewMappings[0];
	                if (!dataViewMapping || !dataViewMapping.categorical || !dataViewMapping.categorical.categories)
	                    return null;
	                var dataViewCategories = dataViewMapping.categorical.categories;
	                var categoryItems = dataViewCategories.for.in.items;
	                if (!_.isEmpty(categoryItems)) {
	                    var categoryType = categoryItems[0].type;
	                    var objects = void 0;
	                    if (dataViewMapping.metadata)
	                        objects = dataViewMapping.metadata.objects;
	                    //TODO: column chart should be sortable by X if it has scalar axis
	                    // But currenly it doesn't support this. Return 'category' once
	                    // it is supported.
	                    if (!visuals.CartesianChart.getIsScalar(objects, visuals.columnChartProps.categoryAxis.axisType, categoryType)) {
	                        return ['Category', 'Y'];
	                    }
	                }
	                return null;
	            };
	            ColumnChart.prototype.updateVisualMetadata = function (x, y, margin) {
	                this.xAxisProperties = x;
	                this.yAxisProperties = y;
	                this.margin = margin;
	            };
	            ColumnChart.prototype.init = function (options) {
	                this.svg = options.svg;
	                this.svg.classed(ColumnChart.ColumnChartClassName, true);
	                this.unclippedGraphicsContext = this.svg.append('g').classed('columnChartUnclippedGraphicsContext', true);
	                this.mainGraphicsContext = this.unclippedGraphicsContext.append('svg').classed('mainGraphicsContext', true);
	                this.style = options.style;
	                this.currentViewport = options.viewport;
	                this.hostService = options.host;
	                this.interactivity = options.interactivity;
	                this.colors = this.style.colorPalette.dataColors;
	                this.cartesianVisualHost = options.cartesianHost;
	                this.options = options;
	                this.isComboChart = visuals.ComboChart.isComboChart(options.chartType);
	                this.element = options.element;
	            };
	            ColumnChart.prototype.getCategoryLayout = function (numCategoryValues, options) {
	                var availableWidth;
	                if (ColumnChart.isBar(this.chartType)) {
	                    availableWidth = this.currentViewport.height - (this.margin.top + this.margin.bottom);
	                }
	                else {
	                    availableWidth = this.currentViewport.width - (this.margin.left + this.margin.right);
	                }
	                var metaDataColumn = this.data ? this.data.categoryMetadata : undefined;
	                var categoryDataType = visuals.AxisHelper.getCategoryValueType(metaDataColumn);
	                var isScalar = this.data ? this.data.scalarCategoryAxis : false;
	                var domain = visuals.AxisHelper.createDomain(this.data.series, categoryDataType, isScalar, options.forcedXDomain, options.ensureXDomain);
	                return visuals.CartesianChart.getLayout(this.data, {
	                    availableWidth: availableWidth,
	                    categoryCount: numCategoryValues,
	                    domain: domain,
	                    isScalar: isScalar,
	                    isScrollable: this.isScrollable,
	                    trimOrdinalDataOnOverflow: options.trimOrdinalDataOnOverflow
	                });
	            };
	            ColumnChart.converter = function (dataView, colors, is100PercentStacked, isScalar, dataViewMetadata, chartType, interactivityService, tooltipsEnabled, tooltipBucketEnabled) {
	                if (is100PercentStacked === void 0) { is100PercentStacked = false; }
	                if (isScalar === void 0) { isScalar = false; }
	                if (dataViewMetadata === void 0) { dataViewMetadata = null; }
	                if (tooltipsEnabled === void 0) { tooltipsEnabled = true; }
	                debug.assertValue(dataView, 'dataView');
	                debug.assertValue(colors, 'colors');
	                var xAxisCardProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataViewMetadata);
	                var valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataViewMetadata);
	                isScalar = visuals.CartesianHelper.isScalar(isScalar, xAxisCardProperties);
	                var dataViewCat = visuals.ColumnUtil.applyUserMinMax(isScalar, dataView.categorical, xAxisCardProperties);
	                var converterStrategy = new ColumnChartConverterHelper(dataView);
	                var categoryInfo = visuals.converterHelper.getPivotedCategories(dataViewCat, visuals.columnChartProps.general.formatString);
	                var categories = categoryInfo.categories, categoryFormatter = categoryInfo.categoryFormatter, categoryIdentities = categoryInfo.categoryIdentities, categoryMetadata = dataViewCat && dataViewCat.categories && dataViewCat.categories.length > 0 ? dataViewCat.categories[0].source : undefined;
	                var labelSettings = visuals.dataLabelUtils.getDefaultColumnLabelSettings(is100PercentStacked || ColumnChart.isStacked(chartType));
	                var defaultLegendLabelColor = visuals.LegendData.DefaultLegendLabelFillColor;
	                var defaultDataPointColor = undefined;
	                var showAllDataPoints = undefined;
	                if (dataViewMetadata && dataViewMetadata.objects) {
	                    var objects = dataViewMetadata.objects;
	                    defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.columnChartProps.dataPoint.defaultColor);
	                    showAllDataPoints = powerbi.DataViewObjects.getValue(objects, visuals.columnChartProps.dataPoint.showAllDataPoints);
	                    defaultLegendLabelColor = powerbi.DataViewObjects.getFillColor(objects, visuals.columnChartProps.legend.labelColor, visuals.LegendData.DefaultLegendLabelFillColor);
	                    var labelsObj = objects['labels'];
	                    visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, labelSettings);
	                }
	                // Allocate colors
	                var legendAndSeriesInfo = converterStrategy.getLegend(colors, defaultLegendLabelColor, defaultDataPointColor);
	                var legend = legendAndSeriesInfo.legend.dataPoints;
	                var seriesSources = legendAndSeriesInfo.seriesSources;
	                // Determine data points
	                var result = ColumnChart.createDataPoints(dataView, categories, categoryIdentities, legend, legendAndSeriesInfo.seriesObjects, converterStrategy, labelSettings, is100PercentStacked, isScalar, visuals.converterHelper.categoryIsAlsoSeriesRole(dataView, RoleNames.series, RoleNames.category), categoryInfo.categoryObjects, defaultDataPointColor, chartType, categoryMetadata, tooltipsEnabled, tooltipBucketEnabled);
	                var columnSeries = result.series;
	                var valuesMetadata = [];
	                for (var j = 0, jlen = legend.length; j < jlen; j++) {
	                    valuesMetadata.push(seriesSources[j]);
	                }
	                var labels = visuals.converterHelper.createAxesLabels(xAxisCardProperties, valueAxisProperties, categoryMetadata, valuesMetadata);
	                if (!ColumnChart.isColumn(chartType)) {
	                    // Replace between x and y axes
	                    var temp = labels.xAxisLabel;
	                    labels.xAxisLabel = labels.yAxisLabel;
	                    labels.yAxisLabel = temp;
	                }
	                if (interactivityService) {
	                    for (var _i = 0, columnSeries_1 = columnSeries; _i < columnSeries_1.length; _i++) {
	                        var series = columnSeries_1[_i];
	                        interactivityService.applySelectionStateToData(series.data);
	                    }
	                    interactivityService.applySelectionStateToData(legendAndSeriesInfo.legend.dataPoints);
	                }
	                return {
	                    categories: categories,
	                    categoryFormatter: categoryFormatter,
	                    series: columnSeries,
	                    valuesMetadata: valuesMetadata,
	                    legendData: legendAndSeriesInfo.legend,
	                    hasHighlights: result.hasHighlights,
	                    categoryMetadata: categoryMetadata,
	                    scalarCategoryAxis: isScalar,
	                    labelSettings: labelSettings,
	                    axesLabels: { x: labels.xAxisLabel, y: labels.yAxisLabel },
	                    hasDynamicSeries: result.hasDynamicSeries,
	                    isMultiMeasure: result.isMultiMeasure,
	                    defaultDataPointColor: defaultDataPointColor,
	                    showAllDataPoints: showAllDataPoints,
	                };
	            };
	            ColumnChart.canSupportOverflow = function (chartType, seriesCount) {
	                return !ColumnChart.isStacked(chartType) || seriesCount === 1;
	            };
	            ColumnChart.createDataPoints = function (dataView, categories, categoryIdentities, legend, seriesObjectsList, converterStrategy, defaultLabelSettings, is100PercentStacked, isScalar, isCategoryAlsoSeries, categoryObjectsList, defaultDataPointColor, chartType, categoryMetadata, tooltipsEnabled, tooltipBucketEnabled) {
	                if (is100PercentStacked === void 0) { is100PercentStacked = false; }
	                if (isScalar === void 0) { isScalar = false; }
	                var dataViewCat = dataView.categorical;
	                var reader = powerbi.data.createIDataViewCategoricalReader(dataView);
	                var grouped = dataViewCat && dataViewCat.values ? dataViewCat.values.grouped() : undefined;
	                var categoryCount = categories.length;
	                var seriesCount = reader.hasValues('Y') ? reader.getSeriesCount('Y') : undefined;
	                var columnSeries = [];
	                if (seriesCount < 1 || categoryCount < 1)
	                    return { series: columnSeries, hasHighlights: false, hasDynamicSeries: false, isMultiMeasure: false };
	                var dvCategories = dataViewCat.categories;
	                categoryMetadata = !_.isEmpty(dvCategories) ? dvCategories[0].source : null;
	                var categoryType = visuals.AxisHelper.getCategoryValueType(categoryMetadata);
	                var isDateTime = visuals.AxisHelper.isDateTime(categoryType);
	                var baseValuesPos = [], baseValuesNeg = [];
	                var rawValues = [];
	                var rawHighlightValues = [];
	                var hasDynamicSeries = !!(dataViewCat.values && dataViewCat.values.source);
	                var isMultiMeasure = !hasDynamicSeries && seriesCount > 1;
	                var highlightsOverflow = false; // Overflow means the highlight larger than value or the signs being different
	                var hasHighlights = converterStrategy.hasHighlightValues(0);
	                for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
	                    var seriesValues = [];
	                    var seriesHighlightValues = [];
	                    for (var categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) {
	                        var value = converterStrategy.getValueBySeriesAndCategory(seriesIndex, categoryIndex);
	                        seriesValues[categoryIndex] = value;
	                        if (hasHighlights) {
	                            var highlightValue = converterStrategy.getHighlightBySeriesAndCategory(seriesIndex, categoryIndex);
	                            seriesHighlightValues[categoryIndex] = highlightValue;
	                            // There are two cases where we don't use overflow logic; if all are false, use overflow logic appropriate for the chart.
	                            if (!((value >= 0 && highlightValue >= 0 && value >= highlightValue) ||
	                                (value <= 0 && highlightValue <= 0 && value <= highlightValue))) {
	                                highlightsOverflow = true;
	                            }
	                        }
	                    }
	                    rawValues.push(seriesValues);
	                    if (hasHighlights) {
	                        rawHighlightValues.push(seriesHighlightValues);
	                    }
	                }
	                if (highlightsOverflow && !ColumnChart.canSupportOverflow(chartType, seriesCount)) {
	                    highlightsOverflow = false;
	                    hasHighlights = false;
	                    rawValues = rawHighlightValues;
	                }
	                var dataPointObjects = categoryObjectsList, formatStringProp = visuals.columnChartProps.general.formatString;
	                for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
	                    var seriesDataPoints = [], legendItem = legend[seriesIndex], seriesLabelSettings = void 0;
	                    if (!hasDynamicSeries) {
	                        var labelsSeriesGroup = !_.isEmpty(grouped) && grouped[0].values ? grouped[0].values[seriesIndex] : null;
	                        var labelObjects = (labelsSeriesGroup && labelsSeriesGroup.source && labelsSeriesGroup.source.objects) ? labelsSeriesGroup.source.objects['labels'] : null;
	                        if (labelObjects) {
	                            seriesLabelSettings = powerbi.Prototype.inherit(defaultLabelSettings);
	                            visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelObjects, seriesLabelSettings);
	                        }
	                    }
	                    columnSeries.push({
	                        displayName: legendItem.label,
	                        key: 'series' + seriesIndex,
	                        index: seriesIndex,
	                        data: seriesDataPoints,
	                        identity: legendItem.identity,
	                        color: legendItem.color,
	                        labelSettings: seriesLabelSettings,
	                    });
	                    if (seriesCount > 1)
	                        dataPointObjects = seriesObjectsList[seriesIndex];
	                    var valueColumnMetadata = reader.getValueMetadataColumn('Y', seriesIndex);
	                    var gradientMeasureIndex = visuals.GradientUtils.getGradientMeasureIndex(dataViewCat);
	                    var gradientValueColumn = visuals.GradientUtils.getGradientValueColumn(dataViewCat);
	                    var valueMeasureIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Y");
	                    var pctFormatString = visuals.valueFormatter.getLocalizedString('Percentage');
	                    for (var categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) {
	                        if (seriesIndex === 0) {
	                            baseValuesPos.push(0);
	                            baseValuesNeg.push(0);
	                        }
	                        var value = visuals.AxisHelper.normalizeNonFiniteNumber(rawValues[seriesIndex][categoryIndex]);
	                        if (value == null) {
	                            // Optimization: Ignore null dataPoints from the fabricated category/series combination in the self cross-join.
	                            // However, we must retain the first series because it is used to compute things like axis scales, and value lookups.
	                            if (seriesIndex > 0)
	                                continue;
	                        }
	                        var originalValue = value;
	                        var categoryValue = categories[categoryIndex];
	                        // ignore variant measures
	                        if (isDateTime && categoryValue != null && !(categoryValue instanceof Date))
	                            continue;
	                        if (isDateTime && categoryValue)
	                            categoryValue = categoryValue.getTime();
	                        if (isScalar && (categoryValue == null || isNaN(categoryValue)))
	                            continue;
	                        var multipliers = void 0;
	                        if (is100PercentStacked)
	                            multipliers = visuals.StackedUtil.getStackedMultiplier(dataViewCat, categoryIndex, seriesCount, categoryCount, converterStrategy);
	                        var unadjustedValue = value, isNegative = value < 0;
	                        if (multipliers) {
	                            if (isNegative)
	                                value *= multipliers.neg;
	                            else
	                                value *= multipliers.pos;
	                        }
	                        var valueAbsolute = Math.abs(value);
	                        var position = void 0;
	                        if (isNegative) {
	                            position = baseValuesNeg[categoryIndex];
	                            if (!isNaN(valueAbsolute))
	                                baseValuesNeg[categoryIndex] -= valueAbsolute;
	                        }
	                        else {
	                            if (!isNaN(valueAbsolute))
	                                baseValuesPos[categoryIndex] += valueAbsolute;
	                            position = baseValuesPos[categoryIndex];
	                        }
	                        var seriesGroup = grouped && grouped.length > seriesIndex && grouped[seriesIndex].values ? grouped[seriesIndex].values[valueMeasureIndex] : null;
	                        var category = !_.isEmpty(dataViewCat.categories) ? dataViewCat.categories[0] : null;
	                        var identity = visuals.SelectionIdBuilder.builder()
	                            .withCategory(category, categoryIndex)
	                            .withSeries(dataViewCat.values, seriesGroup)
	                            .withMeasure(converterStrategy.getMeasureNameByIndex(seriesIndex))
	                            .createSelectionId();
	                        var rawCategoryValue = reader.getCategoryValue('Category', categoryIndex);
	                        var color = ColumnChart.getDataPointColor(legendItem, categoryIndex, dataPointObjects);
	                        var gradientColumnForTooltip = gradientMeasureIndex === 0 ? null : gradientValueColumn;
	                        var valueHighlight = void 0;
	                        var unadjustedValueHighlight = void 0;
	                        var absoluteValueHighlight = void 0;
	                        var highlightValue = void 0;
	                        var highlightPosition = void 0;
	                        var highlightIdentity = void 0;
	                        if (hasHighlights) {
	                            valueHighlight = reader.getHighlight('Y', categoryIndex, seriesIndex);
	                            unadjustedValueHighlight = valueHighlight;
	                            var highlightedTooltip = true;
	                            if (valueHighlight === null) {
	                                valueHighlight = 0;
	                                highlightedTooltip = false;
	                            }
	                            if (is100PercentStacked) {
	                                valueHighlight *= multipliers.pos;
	                            }
	                            absoluteValueHighlight = Math.abs(valueHighlight);
	                            highlightPosition = position;
	                            if (valueHighlight > 0) {
	                                highlightPosition -= valueAbsolute - absoluteValueHighlight;
	                            }
	                            else if (valueHighlight === 0 && value > 0) {
	                                highlightPosition -= valueAbsolute;
	                            }
	                            highlightIdentity = visuals.SelectionId.createWithHighlight(identity);
	                            var highlightedValueAndPct = void 0;
	                            var highlightedValueFormat = void 0;
	                            if (highlightedTooltip && unadjustedValueHighlight != null && valueHighlight != null) {
	                                var highlightedPct = visuals.valueFormatter.format(valueHighlight, pctFormatString);
	                                highlightedValueFormat = visuals.converterHelper.formatFromMetadataColumn(unadjustedValueHighlight, valueColumnMetadata, formatStringProp);
	                                highlightedValueAndPct = highlightedValueFormat + ' (' + highlightedPct + ')';
	                            }
	                            if (is100PercentStacked) {
	                                highlightValue = highlightedValueAndPct;
	                            }
	                            else {
	                                highlightValue = highlightedValueFormat;
	                            }
	                        }
	                        var tooltipInfo = void 0;
	                        if (tooltipsEnabled) {
	                            tooltipInfo = [];
	                            if (category) {
	                                tooltipInfo.push({
	                                    displayName: reader.getCategoryDisplayName('Category'),
	                                    value: visuals.converterHelper.formatFromMetadataColumn(rawCategoryValue, category.source, formatStringProp),
	                                });
	                            }
	                            if (hasDynamicSeries) {
	                                if (!category || category.source !== dataViewCat.values.source) {
	                                    // Category/series on the same column -- don't repeat its value in the tooltip.
	                                    tooltipInfo.push({
	                                        displayName: dataViewCat.values.source.displayName,
	                                        value: visuals.converterHelper.formatFromMetadataColumn(grouped[seriesIndex].name, dataViewCat.values.source, formatStringProp),
	                                    });
	                                }
	                            }
	                            if (originalValue != null) {
	                                var valueString = void 0;
	                                var formattedOriginalValue = visuals.converterHelper.formatFromMetadataColumn(originalValue, valueColumnMetadata, formatStringProp);
	                                if (is100PercentStacked) {
	                                    var originalPct = visuals.valueFormatter.format(valueAbsolute, pctFormatString);
	                                    valueString = formattedOriginalValue + ' (' + originalPct + ')';
	                                }
	                                else {
	                                    valueString = formattedOriginalValue;
	                                }
	                                tooltipInfo.push({
	                                    displayName: valueColumnMetadata.displayName,
	                                    value: valueString,
	                                });
	                            }
	                            if (highlightValue != null) {
	                                tooltipInfo.push({
	                                    displayName: visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName,
	                                    value: highlightValue,
	                                });
	                            }
	                            if (gradientColumnForTooltip && gradientColumnForTooltip.values[categoryIndex] != null) {
	                                tooltipInfo.push({
	                                    displayName: gradientColumnForTooltip.source.displayName,
	                                    value: visuals.converterHelper.formatFromMetadataColumn(gradientColumnForTooltip.values[categoryIndex], gradientColumnForTooltip.source, formatStringProp),
	                                });
	                            }
	                            if (tooltipBucketEnabled) {
	                                visuals.TooltipBuilder.addTooltipBucketItem(reader, tooltipInfo, categoryIndex, hasDynamicSeries ? seriesIndex : undefined);
	                            }
	                        }
	                        var series = columnSeries[seriesIndex];
	                        var dataPointLabelSettings = (series.labelSettings) ? series.labelSettings : defaultLabelSettings;
	                        var labelColor = dataPointLabelSettings.labelColor;
	                        var lastValue = undefined;
	                        //Stacked column/bar label color is white by default (except last series)
	                        if ((ColumnChart.isStacked(chartType))) {
	                            lastValue = this.getStackedLabelColor(isNegative, seriesIndex, seriesCount, categoryIndex, rawValues);
	                            labelColor = (lastValue || (seriesIndex === seriesCount - 1 && !isNegative)) ? labelColor : visuals.dataLabelUtils.defaultInsideLabelColor;
	                        }
	                        var dataPoint = {
	                            categoryValue: categoryValue,
	                            value: value,
	                            position: position,
	                            valueAbsolute: valueAbsolute,
	                            valueOriginal: unadjustedValue,
	                            seriesIndex: seriesIndex,
	                            labelSettings: dataPointLabelSettings,
	                            categoryIndex: categoryIndex,
	                            color: color,
	                            selected: false,
	                            originalValue: value,
	                            originalPosition: position,
	                            originalValueAbsolute: valueAbsolute,
	                            identity: identity,
	                            key: identity.getKey(),
	                            tooltipInfo: tooltipInfo,
	                            labelFill: labelColor,
	                            labelFormatString: valueColumnMetadata.format,
	                            lastSeries: lastValue,
	                            chartType: chartType
	                        };
	                        seriesDataPoints.push(dataPoint);
	                        if (hasHighlights) {
	                            var highlightDataPoint = {
	                                categoryValue: categoryValue,
	                                value: valueHighlight,
	                                position: highlightPosition,
	                                valueAbsolute: absoluteValueHighlight,
	                                valueOriginal: unadjustedValueHighlight,
	                                seriesIndex: seriesIndex,
	                                labelSettings: dataPointLabelSettings,
	                                categoryIndex: categoryIndex,
	                                color: color,
	                                selected: false,
	                                highlight: true,
	                                originalValue: value,
	                                originalPosition: position,
	                                originalValueAbsolute: valueAbsolute,
	                                drawThinner: highlightsOverflow,
	                                identity: highlightIdentity,
	                                key: highlightIdentity.getKey(),
	                                tooltipInfo: tooltipInfo,
	                                labelFormatString: valueColumnMetadata.format,
	                                labelFill: labelColor,
	                                lastSeries: lastValue,
	                                chartType: chartType
	                            };
	                            seriesDataPoints.push(highlightDataPoint);
	                        }
	                    }
	                }
	                return {
	                    series: columnSeries,
	                    hasHighlights: hasHighlights,
	                    hasDynamicSeries: hasDynamicSeries,
	                    isMultiMeasure: isMultiMeasure,
	                };
	            };
	            ColumnChart.getDataPointColor = function (legendItem, categoryIndex, dataPointObjects) {
	                debug.assertValue(legendItem, 'legendItem');
	                debug.assertValue(categoryIndex, 'categoryIndex');
	                debug.assertAnyValue(dataPointObjects, 'dataPointObjects');
	                if (dataPointObjects) {
	                    var colorOverride = powerbi.DataViewObjects.getFillColor(dataPointObjects[categoryIndex], visuals.columnChartProps.dataPoint.fill);
	                    if (colorOverride)
	                        return colorOverride;
	                }
	                return legendItem.color;
	            };
	            ColumnChart.getStackedLabelColor = function (isNegative, seriesIndex, seriesCount, categoryIndex, rawValues) {
	                var lastValue = !(isNegative && seriesIndex === seriesCount - 1 && seriesCount !== 1);
	                //run for the next series and check if current series is last
	                for (var i = seriesIndex + 1; i < seriesCount; i++) {
	                    var nextValues = visuals.AxisHelper.normalizeNonFiniteNumber(rawValues[i][categoryIndex]);
	                    if ((nextValues !== null) && (((!isNegative || (isNegative && seriesIndex === 0)) && nextValues > 0) || (isNegative && seriesIndex !== 0))) {
	                        lastValue = false;
	                        break;
	                    }
	                }
	                return lastValue;
	            };
	            ColumnChart.sliceSeries = function (series, endIndex, startIndex) {
	                if (startIndex === void 0) { startIndex = 0; }
	                var newSeries = [];
	                if (series && series.length > 0) {
	                    for (var i = 0, len = series.length; i < len; i++) {
	                        var iNewSeries = newSeries[i] = powerbi.Prototype.inherit(series[i]);
	                        // TODO: [investigate] possible perf improvement.
	                        // if data[n].categoryIndex > endIndex implies data[n+1].categoryIndex > endIndex
	                        // then we could short circuit the filter loop.
	                        iNewSeries.data = series[i].data.filter(function (d) { return d.categoryIndex >= startIndex && d.categoryIndex < endIndex; });
	                    }
	                }
	                return newSeries;
	            };
	            ColumnChart.getInteractiveColumnChartDomElement = function (element) {
	                return element.children("svg").get(0);
	            };
	            ColumnChart.prototype.setData = function (dataViews) {
	                debug.assertValue(dataViews, "dataViews");
	                var is100PctStacked = ColumnChart.isStacked100(this.chartType);
	                this.data = {
	                    categories: [],
	                    categoryFormatter: null,
	                    series: [],
	                    valuesMetadata: [],
	                    legendData: null,
	                    hasHighlights: false,
	                    categoryMetadata: null,
	                    scalarCategoryAxis: false,
	                    labelSettings: visuals.dataLabelUtils.getDefaultColumnLabelSettings(is100PctStacked || ColumnChart.isStacked(this.chartType)),
	                    axesLabels: { x: null, y: null },
	                    hasDynamicSeries: false,
	                    defaultDataPointColor: null,
	                    isMultiMeasure: false,
	                };
	                if (dataViews.length > 0) {
	                    var dataView = this.dataView = dataViews[0];
	                    if (dataView && dataView.categorical) {
	                        var dvCategories = dataView.categorical.categories;
	                        var categoryMetadata = (dvCategories && dvCategories.length > 0)
	                            ? dvCategories[0].source
	                            : null;
	                        var categoryType = visuals.AxisHelper.getCategoryValueType(categoryMetadata);
	                        this.data = ColumnChart.converter(dataView, this.cartesianVisualHost.getSharedColors(), is100PctStacked, visuals.CartesianChart.getIsScalar(dataView.metadata ? dataView.metadata.objects : null, visuals.columnChartProps.categoryAxis.axisType, categoryType), dataView.metadata, this.chartType, this.interactivityService, this.tooltipsEnabled, this.tooltipBucketEnabled);
	                    }
	                }
	                this.setChartStrategy();
	            };
	            ColumnChart.prototype.setChartStrategy = function () {
	                switch (this.chartType) {
	                    case ColumnChartType.clusteredBar:
	                        this.columnChart = new visuals.ClusteredBarChartStrategy();
	                        break;
	                    case ColumnChartType.clusteredColumn:
	                        this.columnChart = new visuals.ClusteredColumnChartStrategy();
	                        break;
	                    case ColumnChartType.stackedBar:
	                    case ColumnChartType.hundredPercentStackedBar:
	                        this.columnChart = new visuals.StackedBarChartStrategy();
	                        break;
	                    case ColumnChartType.stackedColumn:
	                    case ColumnChartType.hundredPercentStackedColumn:
	                    default:
	                        this.columnChart = new visuals.StackedColumnChartStrategy();
	                        break;
	                }
	                // For single series, render stacked as a clustered
	                if (ColumnChart.isStacked(this.chartType) && this.data.series.length === 1) {
	                    switch (this.chartType) {
	                        case (ColumnChartType.stackedBar):
	                            this.columnChart = new visuals.ClusteredBarChartStrategy();
	                            break;
	                        case (ColumnChartType.stackedColumn):
	                            this.columnChart = new visuals.ClusteredColumnChartStrategy();
	                            break;
	                    }
	                }
	            };
	            ColumnChart.prototype.calculateLegend = function () {
	                // if we're in interactive mode, return the interactive legend
	                if (this.interactivity && this.interactivity.isInteractiveLegend) {
	                    return this.createInteractiveLegendDataPoints(0);
	                }
	                var legendData = this.data ? this.data.legendData : null;
	                var legendDataPoints = legendData ? legendData.dataPoints : [];
	                if (_.isEmpty(legendDataPoints))
	                    return null;
	                return legendData;
	            };
	            ColumnChart.prototype.hasLegend = function () {
	                return this.data && (this.data.hasDynamicSeries || (this.data.series && this.data.series.length > 1));
	            };
	            ColumnChart.prototype.enumerateObjectInstances = function (enumeration, options) {
	                switch (options.objectName) {
	                    case 'dataPoint':
	                        if (this.dataView && !visuals.GradientUtils.hasGradientRole(this.dataView.categorical))
	                            this.enumerateDataPoints(enumeration);
	                        break;
	                    case 'labels':
	                        this.enumerateDataLabels(enumeration);
	                        break;
	                }
	            };
	            ColumnChart.prototype.enumerateDataLabels = function (enumeration) {
	                var data = this.data, labelSettings = this.data.labelSettings, seriesCount = data.series.length, showLabelPerSeries = !data.hasDynamicSeries && (seriesCount > 1 || !data.categoryMetadata);
	                //Draw default settings
	                visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings, null, showLabelPerSeries));
	                if (seriesCount === 0)
	                    return;
	                //Draw series settings
	                if (showLabelPerSeries && labelSettings.showLabelPerSeries) {
	                    for (var i = 0; i < seriesCount; i++) {
	                        var series = data.series[i], labelSettings_1 = (series.labelSettings) ? series.labelSettings : this.data.labelSettings;
	                        enumeration.pushContainer({ displayName: series.displayName });
	                        visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings_1, series));
	                        enumeration.popContainer();
	                    }
	                }
	            };
	            ColumnChart.prototype.getLabelSettingsOptions = function (enumeration, labelSettings, series, showAll) {
	                return {
	                    enumeration: enumeration,
	                    dataLabelsSettings: labelSettings,
	                    show: true,
	                    displayUnits: !ColumnChart.isStacked100(this.chartType),
	                    precision: true,
	                    selector: series && series.identity ? series.identity.getSelector() : null,
	                    showAll: showAll,
	                    fontSize: true,
	                };
	            };
	            ColumnChart.prototype.enumerateDataPoints = function (enumeration) {
	                var data = this.data;
	                if (!data)
	                    return;
	                var seriesCount = data.series.length;
	                if (seriesCount === 0)
	                    return;
	                if (data.hasDynamicSeries || seriesCount > 1 || !data.categoryMetadata) {
	                    for (var i = 0; i < seriesCount; i++) {
	                        var series = data.series[i];
	                        enumeration.pushInstance({
	                            objectName: 'dataPoint',
	                            displayName: series.displayName,
	                            selector: visuals.ColorHelper.normalizeSelector(series.identity.getSelector()),
	                            properties: {
	                                fill: { solid: { color: series.color } }
	                            },
	                        });
	                    }
	                }
	                else {
	                    // For single-category, single-measure column charts, the user can color the individual bars.
	                    var singleSeriesData = data.series[0].data;
	                    var categoryFormatter = data.categoryFormatter;
	                    // Add default color and show all slices
	                    enumeration.pushInstance({
	                        objectName: 'dataPoint',
	                        selector: null,
	                        properties: {
	                            defaultColor: { solid: { color: data.defaultDataPointColor || this.colors.getColorByIndex(0).value } }
	                        }
	                    }).pushInstance({
	                        objectName: 'dataPoint',
	                        selector: null,
	                        properties: {
	                            showAllDataPoints: !!data.showAllDataPoints
	                        }
	                    });
	                    if (data.showAllDataPoints) {
	                        for (var i = 0; i < singleSeriesData.length; i++) {
	                            var singleSeriesDataPoints = singleSeriesData[i], categoryValue = data.categories[i];
	                            enumeration.pushInstance({
	                                objectName: 'dataPoint',
	                                displayName: categoryFormatter ? categoryFormatter.format(categoryValue) : categoryValue,
	                                selector: visuals.ColorHelper.normalizeSelector(singleSeriesDataPoints.identity.getSelector(), /*isSingleSeries*/ true),
	                                properties: {
	                                    fill: { solid: { color: singleSeriesDataPoints.color } }
	                                },
	                            });
	                        }
	                    }
	                }
	            };
	            ColumnChart.prototype.calculateAxesProperties = function (options) {
	                var data = this.data;
	                this.currentViewport = options.viewport;
	                var margin = this.margin = options.margin;
	                var origCatgSize = (data && data.categories) ? data.categories.length : 0;
	                var chartLayout = data ? this.getCategoryLayout(origCatgSize, options) : {
	                    categoryCount: 0,
	                    categoryThickness: visuals.CartesianChart.MinOrdinalRectThickness,
	                    outerPaddingRatio: visuals.CartesianChart.OuterPaddingRatio,
	                    isScalar: false
	                };
	                this.categoryAxisType = chartLayout.isScalar ? visuals.axisType.scalar : null;
	                if (data && !chartLayout.isScalar && !this.isScrollable && options.trimOrdinalDataOnOverflow) {
	                    // trim data that doesn't fit on dashboard
	                    var catgSize = Math.min(origCatgSize, chartLayout.categoryCount);
	                    if (catgSize !== origCatgSize) {
	                        data = powerbi.Prototype.inherit(data);
	                        data.series = ColumnChart.sliceSeries(data.series, catgSize);
	                        data.categories = data.categories.slice(0, catgSize);
	                    }
	                }
	                this.columnChart.setData(data);
	                var preferredPlotArea = this.getPreferredPlotArea(chartLayout.isScalar, chartLayout.categoryCount, chartLayout.categoryThickness);
	                var is100Pct = ColumnChart.isStacked100(this.chartType);
	                var chartContext = {
	                    height: preferredPlotArea.height,
	                    width: preferredPlotArea.width,
	                    duration: 0,
	                    hostService: this.hostService,
	                    unclippedGraphicsContext: this.unclippedGraphicsContext,
	                    mainGraphicsContext: this.mainGraphicsContext,
	                    margin: this.margin,
	                    layout: chartLayout,
	                    animator: this.animator,
	                    interactivityService: this.interactivityService,
	                    viewportHeight: this.currentViewport.height - (margin.top + margin.bottom),
	                    viewportWidth: this.currentViewport.width - (margin.left + margin.right),
	                    is100Pct: is100Pct,
	                    isComboChart: this.isComboChart,
	                };
	                this.ApplyInteractivity(chartContext);
	                this.columnChart.setupVisualProps(chartContext);
	                var ensureXDomain;
	                var ensureYDomain;
	                var isBarChart = ColumnChart.isBar(this.chartType);
	                if (isBarChart) {
	                    var temp = options.forcedXDomain;
	                    options.forcedXDomain = options.forcedYDomain;
	                    options.forcedYDomain = temp;
	                    // In the case of clustered and stacked bar charts, the y1 reference line is a vertical line
	                    ensureXDomain = options.ensureYDomain;
	                }
	                else {
	                    ensureYDomain = options.ensureYDomain;
	                }
	                this.xAxisProperties = this.columnChart.setXScale(is100Pct, options.forcedTickCount, options.forcedXDomain, isBarChart ? options.valueAxisScaleType : options.categoryAxisScaleType, isBarChart ? options.valueAxisDisplayUnits : options.categoryAxisDisplayUnits, isBarChart ? options.valueAxisPrecision : options.categoryAxisPrecision, ensureXDomain);
	                this.yAxisProperties = this.columnChart.setYScale(is100Pct, options.forcedTickCount, options.forcedYDomain, isBarChart ? options.categoryAxisScaleType : options.valueAxisScaleType, isBarChart ? options.categoryAxisDisplayUnits : options.valueAxisDisplayUnits, isBarChart ? options.categoryAxisPrecision : options.valueAxisPrecision, ensureYDomain);
	                if (options.showCategoryAxisLabel && this.xAxisProperties.isCategoryAxis || options.showValueAxisLabel && !this.xAxisProperties.isCategoryAxis) {
	                    this.xAxisProperties.axisLabel = data.axesLabels.x;
	                }
	                else {
	                    this.xAxisProperties.axisLabel = null;
	                }
	                if (options.showValueAxisLabel && !this.yAxisProperties.isCategoryAxis || options.showCategoryAxisLabel && this.yAxisProperties.isCategoryAxis) {
	                    this.yAxisProperties.axisLabel = data.axesLabels.y;
	                }
	                else {
	                    this.yAxisProperties.axisLabel = null;
	                }
	                return [this.xAxisProperties, this.yAxisProperties];
	            };
	            ColumnChart.prototype.getPreferredPlotArea = function (isScalar, categoryCount, categoryThickness) {
	                var plotArea = {
	                    height: this.currentViewport.height - this.margin.top - this.margin.bottom,
	                    width: this.currentViewport.width - this.margin.left - this.margin.right
	                };
	                if (this.isScrollable && !isScalar) {
	                    var preferredCategorySpan = visuals.CartesianChart.getPreferredCategorySpan(categoryCount, categoryThickness);
	                    if (ColumnChart.isBar(this.chartType)) {
	                        plotArea.height = Math.max(preferredCategorySpan, plotArea.height);
	                    }
	                    else
	                        plotArea.width = Math.max(preferredCategorySpan, plotArea.width);
	                }
	                return plotArea;
	            };
	            ColumnChart.prototype.ApplyInteractivity = function (chartContext) {
	                var _this = this;
	                var interactivity = this.interactivity;
	                if (interactivity) {
	                    if (interactivity.dragDataPoint) {
	                        chartContext.onDragStart = function (datum) {
	                            if (!datum.identity)
	                                return;
	                            _this.hostService.onDragStart({
	                                event: d3.event,
	                                data: {
	                                    data: datum.identity.getSelector()
	                                }
	                            });
	                        };
	                    }
	                    if (interactivity.isInteractiveLegend) {
	                        var dragMove = function () {
	                            var mousePoint = d3.mouse(_this.mainGraphicsContext[0][0]); // get the x and y for the column area itself
	                            var x = mousePoint[0];
	                            var y = mousePoint[1];
	                            var index = _this.columnChart.getClosestColumnIndex(x, y);
	                            _this.selectColumn(index);
	                        };
	                        var ColumnChartSvg = ColumnChart.getInteractiveColumnChartDomElement(this.element);
	                        //set click interaction on the visual
	                        this.svg.on('click', dragMove);
	                        //set click interaction on the background
	                        d3.select(ColumnChartSvg)
	                            .on('click', dragMove)
	                            .style('touch-action', 'none');
	                        var drag = d3.behavior.drag()
	                            .origin(Object)
	                            .on("drag", dragMove);
	                        //set drag interaction on the visual
	                        this.svg.call(drag);
	                        //set drag interaction on the background
	                        d3.select(ColumnChartSvg).call(drag);
	                    }
	                }
	            };
	            ColumnChart.prototype.selectColumn = function (indexOfColumnSelected, force) {
	                if (force === void 0) { force = false; }
	                if (!force && this.lastInteractiveSelectedColumnIndex === indexOfColumnSelected)
	                    return; // same column, nothing to do here
	                var legendData = this.createInteractiveLegendDataPoints(indexOfColumnSelected);
	                var legendDataPoints = legendData.dataPoints;
	                this.cartesianVisualHost.updateLegend(legendData);
	                if (legendDataPoints.length > 0) {
	                    this.columnChart.selectColumn(indexOfColumnSelected, this.lastInteractiveSelectedColumnIndex);
	                }
	                this.lastInteractiveSelectedColumnIndex = indexOfColumnSelected;
	            };
	            ColumnChart.prototype.createInteractiveLegendDataPoints = function (columnIndex) {
	                var data = this.data;
	                if (!data || _.isEmpty(data.series))
	                    return { dataPoints: [] };
	                var formatStringProp = visuals.columnChartProps.general.formatString;
	                var legendDataPoints = [];
	                var category = data.categories && data.categories[columnIndex];
	                var allSeries = data.series;
	                var dataPoints = data.legendData && data.legendData.dataPoints;
	                var converterStrategy = new ColumnChartConverterHelper(this.dataView);
	                for (var i = 0, len = allSeries.length; i < len; i++) {
	                    var measure = converterStrategy.getValueBySeriesAndCategory(i, columnIndex);
	                    var valueMetadata = data.valuesMetadata[i];
	                    var formattedLabel = visuals.converterHelper.getFormattedLegendLabel(valueMetadata, this.dataView.categorical.values, formatStringProp);
	                    var dataPointColor = void 0;
	                    if (allSeries.length === 1) {
	                        var series = allSeries[0];
	                        dataPointColor = series.data.length > columnIndex && series.data[columnIndex].color;
	                    }
	                    else {
	                        dataPointColor = dataPoints.length > i && dataPoints[i].color;
	                    }
	                    legendDataPoints.push({
	                        color: dataPointColor,
	                        icon: visuals.LegendIcon.Box,
	                        label: formattedLabel,
	                        category: data.categoryFormatter ? data.categoryFormatter.format(category) : category,
	                        measure: visuals.valueFormatter.format(measure, visuals.valueFormatter.getFormatString(valueMetadata, formatStringProp)),
	                        identity: visuals.SelectionId.createNull(),
	                        selected: false
	                    });
	                }
	                return { dataPoints: legendDataPoints };
	            };
	            ColumnChart.prototype.overrideXScale = function (xProperties) {
	                this.xAxisProperties = xProperties;
	            };
	            ColumnChart.prototype.render = function (suppressAnimations) {
	                var columnChartDrawInfo = this.columnChart.drawColumns(!suppressAnimations /* useAnimations */);
	                var data = this.data;
	                var margin = this.margin;
	                var viewport = this.currentViewport;
	                var height = viewport.height - (margin.top + margin.bottom);
	                var width = viewport.width - (margin.left + margin.right);
	                this.mainGraphicsContext
	                    .attr('height', height)
	                    .attr('width', width);
	                if (this.tooltipsEnabled)
	                    visuals.TooltipManager.addTooltip(columnChartDrawInfo.eventGroup, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
	                var allDataPoints = [];
	                var behaviorOptions = undefined;
	                if (this.interactivityService) {
	                    for (var i = 0, ilen = data.series.length; i < ilen; i++) {
	                        allDataPoints = allDataPoints.concat(data.series[i].data);
	                    }
	                    behaviorOptions = {
	                        datapoints: allDataPoints,
	                        eventGroup: columnChartDrawInfo.eventGroup,
	                        bars: columnChartDrawInfo.shapesSelection,
	                        hasHighlights: data.hasHighlights,
	                        mainGraphicsContext: this.mainGraphicsContext,
	                        viewport: columnChartDrawInfo.viewport,
	                        axisOptions: columnChartDrawInfo.axisOptions,
	                        showLabel: data.labelSettings.show
	                    };
	                }
	                if (this.interactivity && this.interactivity.isInteractiveLegend) {
	                    if (this.data.series.length > 0) {
	                        this.selectColumn(visuals.CartesianHelper.findMaxCategoryIndex(this.data.series), true); // start with the last column
	                    }
	                }
	                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
	                return { dataPoints: allDataPoints, behaviorOptions: behaviorOptions, labelDataPoints: columnChartDrawInfo.labelDataPoints, labelsAreNumeric: true };
	            };
	            ColumnChart.prototype.onClearSelection = function () {
	                if (this.interactivityService) {
	                    this.interactivityService.clearSelection();
	                }
	            };
	            ColumnChart.prototype.getVisualCategoryAxisIsScalar = function () {
	                return this.data ? this.data.scalarCategoryAxis : false;
	            };
	            ColumnChart.prototype.getSupportedCategoryAxisType = function () {
	                var metaDataColumn = this.data ? this.data.categoryMetadata : undefined;
	                var valueType = visuals.AxisHelper.getCategoryValueType(metaDataColumn);
	                var isOrdinal = visuals.AxisHelper.isOrdinal(valueType);
	                return isOrdinal ? visuals.axisType.categorical : visuals.axisType.both;
	            };
	            ColumnChart.prototype.setFilteredData = function (startIndex, endIndex) {
	                var data = powerbi.Prototype.inherit(this.data);
	                data.series = ColumnChart.sliceSeries(data.series, endIndex, startIndex);
	                data.categories = data.categories.slice(startIndex, endIndex);
	                this.columnChart.setData(data);
	                return data;
	            };
	            ColumnChart.getLabelFill = function (labelColor, isInside, isCombo) {
	                if (labelColor) {
	                    return labelColor;
	                }
	                if (isInside && !isCombo) {
	                    return visuals.NewDataLabelUtils.defaultInsideLabelColor;
	                }
	                return visuals.NewDataLabelUtils.defaultLabelColor;
	            };
	            ColumnChart.prototype.supportsTrendLine = function () {
	                var dataView = this.dataView;
	                var reader = powerbi.data.createIDataViewCategoricalReader(dataView);
	                var isScalar = this.data ? this.data.scalarCategoryAxis : false;
	                return this.chartType === ColumnChartType.clusteredColumn && isScalar && reader.hasValues("Y");
	            };
	            ColumnChart.prototype.isStacked = function () {
	                return ColumnChart.isStacked(this.chartType);
	            };
	            ColumnChart.isBar = function (chartType) {
	                return EnumExtensions.hasFlag(chartType, flagBar);
	            };
	            ColumnChart.isColumn = function (chartType) {
	                return EnumExtensions.hasFlag(chartType, flagColumn);
	            };
	            ColumnChart.isClustered = function (chartType) {
	                return EnumExtensions.hasFlag(chartType, flagClustered);
	            };
	            ColumnChart.isStacked = function (chartType) {
	                return EnumExtensions.hasFlag(chartType, flagStacked);
	            };
	            ColumnChart.isStacked100 = function (chartType) {
	                return EnumExtensions.hasFlag(chartType, flagStacked100);
	            };
	            ColumnChart.ColumnChartClassName = 'columnChart';
	            ColumnChart.clusteredValidLabelPositions = [16 /* OutsideEnd */, 4 /* InsideEnd */, 1 /* InsideCenter */, 2 /* InsideBase */];
	            ColumnChart.stackedValidLabelPositions = [1 /* InsideCenter */, 4 /* InsideEnd */, 2 /* InsideBase */];
	            ColumnChart.SeriesClasses = jsCommon.CssConstants.createClassAndSelector('series');
	            return ColumnChart;
	        }());
	        visuals.ColumnChart = ColumnChart;
	        var ColumnChartConverterHelper = (function () {
	            function ColumnChartConverterHelper(dataView) {
	                this.dataView = dataView && dataView.categorical;
	                this.reader = powerbi.data.createIDataViewCategoricalReader(dataView);
	            }
	            ColumnChartConverterHelper.prototype.getLegend = function (colors, defaultLegendLabelColor, defaultColor) {
	                var legend = [];
	                var seriesSources = [];
	                var seriesObjects = [];
	                var grouped = false;
	                var reader = this.reader;
	                var colorHelper = new visuals.ColorHelper(colors, visuals.columnChartProps.dataPoint.fill, defaultColor);
	                var legendTitle = undefined;
	                if (this.dataView && this.dataView.values) {
	                    var allValues = this.dataView.values;
	                    var valueGroups = allValues.grouped();
	                    var hasDynamicSeries = !!(allValues && allValues.source);
	                    var formatStringProp = visuals.columnChartProps.general.formatString;
	                    for (var valueGroupsIndex = 0, valueGroupsLen = valueGroups.length; valueGroupsIndex < valueGroupsLen; valueGroupsIndex++) {
	                        var valueGroup = valueGroups[valueGroupsIndex], valueGroupObjects = valueGroup.objects, values = valueGroup.values;
	                        for (var valueIndex = 0, valuesLen = values.length; valueIndex < valuesLen; valueIndex++) {
	                            var series = values[valueIndex];
	                            var source = series.source;
	                            // Gradient and tooltips measures do not create series.
	                            if ((DataRoleHelper.hasRole(source, 'Gradient') || DataRoleHelper.hasRole(source, 'Tooltips')) && !DataRoleHelper.hasRole(source, 'Y'))
	                                continue;
	                            seriesSources.push(source);
	                            seriesObjects.push(series.objects);
	                            var selectionIdBuilder = new visuals.SelectionIdBuilder();
	                            selectionIdBuilder = selectionIdBuilder.withMeasure(this.getMeasureNameByIndex(valueIndex));
	                            if (reader.hasDynamicSeries()) {
	                                selectionIdBuilder = selectionIdBuilder.withSeries(reader.getSeriesValueColumns(), reader.getSeriesValueColumnGroup(valueGroupsIndex));
	                            }
	                            var selectionId = selectionIdBuilder.createSelectionId();
	                            var label = visuals.converterHelper.getFormattedLegendLabel(source, allValues, formatStringProp);
	                            var color = hasDynamicSeries
	                                ? colorHelper.getColorForSeriesValue(valueGroupObjects, allValues.identityFields, source.groupName)
	                                : colorHelper.getColorForMeasure(source.objects, source.queryName);
	                            legend.push({
	                                icon: visuals.LegendIcon.Box,
	                                color: color,
	                                label: label,
	                                identity: selectionId,
	                                selected: false,
	                            });
	                            if (series.identity && source.groupName !== undefined) {
	                                grouped = true;
	                            }
	                        }
	                    }
	                    var dvValues = this.dataView.values;
	                    legendTitle = dvValues && dvValues.source ? dvValues.source.displayName : "";
	                }
	                var legendData = {
	                    title: legendTitle,
	                    dataPoints: legend,
	                    grouped: grouped,
	                    labelColor: defaultLegendLabelColor,
	                };
	                return {
	                    legend: legendData,
	                    seriesSources: seriesSources,
	                    seriesObjects: seriesObjects,
	                };
	            };
	            ColumnChartConverterHelper.prototype.getValueBySeriesAndCategory = function (series, category) {
	                return this.reader.getValue('Y', category, series);
	            };
	            ColumnChartConverterHelper.prototype.getMeasureNameByIndex = function (index) {
	                return this.dataView.values[index].source.queryName;
	            };
	            ColumnChartConverterHelper.prototype.hasHighlightValues = function (series) {
	                var column = this.dataView && this.dataView.values ? this.dataView.values[series] : undefined;
	                return column && !!column.highlights;
	            };
	            ColumnChartConverterHelper.prototype.getHighlightBySeriesAndCategory = function (series, category) {
	                return this.dataView.values[series].highlights[category];
	            };
	            return ColumnChartConverterHelper;
	        }());
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 255 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var PixelConverter = jsCommon.PixelConverter;
	        var ClusteredColumnChartStrategy = (function () {
	            function ClusteredColumnChartStrategy() {
	            }
	            ClusteredColumnChartStrategy.prototype.setupVisualProps = function (columnChartProps) {
	                this.graphicsContext = columnChartProps;
	                this.margin = columnChartProps.margin;
	                this.width = this.graphicsContext.width;
	                this.height = this.graphicsContext.height;
	                this.categoryLayout = columnChartProps.layout;
	                this.animator = columnChartProps.animator;
	                this.interactivityService = columnChartProps.interactivityService;
	                this.viewportHeight = columnChartProps.viewportHeight;
	                this.viewportWidth = columnChartProps.viewportWidth;
	                this.isComboChart = columnChartProps.isComboChart;
	            };
	            ClusteredColumnChartStrategy.prototype.setData = function (data) {
	                this.data = data;
	            };
	            ClusteredColumnChartStrategy.prototype.setXScale = function (is100Pct, forcedTickCount, forcedXDomain, axisScaleType, axisDisplayUnits, axisPrecision, ensureXDomain) {
	                var width = this.width;
	                var forcedXMin, forcedXMax;
	                if (forcedXDomain && forcedXDomain.length === 2) {
	                    forcedXMin = forcedXDomain[0];
	                    forcedXMax = forcedXDomain[1];
	                }
	                var props = this.xProps = visuals.ColumnUtil.getCategoryAxis(this.data, width, this.categoryLayout, false, forcedXMin, forcedXMax, axisScaleType, axisDisplayUnits, axisPrecision, ensureXDomain);
	                // create clustered offset scale
	                var seriesLength = this.data.series.length;
	                var columnWidth = (this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio)) / seriesLength;
	                this.seriesOffsetScale = d3.scale.ordinal()
	                    .domain(this.data.series.map(function (s) { return s.index; }))
	                    .rangeBands([0, seriesLength * columnWidth]);
	                return props;
	            };
	            ClusteredColumnChartStrategy.prototype.setYScale = function (is100Pct, forcedTickCount, forcedYDomain, axisScaleType, axisDisplayUnits, axisPrecision, ensureYDomain) {
	                debug.assert(!is100Pct, 'Cannot have 100% clustered chart.');
	                var height = this.viewportHeight;
	                var valueDomain = visuals.AxisHelper.createValueDomain(this.data.series, true) || visuals.emptyDomain;
	                var combinedDomain = visuals.AxisHelper.combineDomain(forcedYDomain, valueDomain, ensureYDomain);
	                var shouldClamp = visuals.AxisHelper.scaleShouldClamp(combinedDomain, valueDomain);
	                this.yProps = visuals.AxisHelper.createAxis({
	                    pixelSpan: height,
	                    dataDomain: combinedDomain,
	                    metaDataColumn: this.data.valuesMetadata[0],
	                    formatString: visuals.valueFormatter.getFormatString(this.data.valuesMetadata[0], visuals.columnChartProps.general.formatString),
	                    outerPadding: 0,
	                    isScalar: true,
	                    isVertical: true,
	                    forcedTickCount: forcedTickCount,
	                    useTickIntervalForDisplayUnits: true,
	                    isCategoryAxis: false,
	                    scaleType: axisScaleType,
	                    axisDisplayUnits: axisDisplayUnits,
	                    axisPrecision: axisPrecision,
	                    shouldClamp: shouldClamp,
	                });
	                return this.yProps;
	            };
	            ClusteredColumnChartStrategy.prototype.drawColumns = function (useAnimation) {
	                var data = this.data;
	                debug.assertValue(data, 'data could not be null or undefined');
	                this.columnsCenters = null; // invalidate the columnsCenters so that will be calculated again
	                var categoryWidth = (this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio));
	                var columnWidth = categoryWidth / data.series.length;
	                var axisOptions = {
	                    columnWidth: columnWidth,
	                    categoryWidth: categoryWidth,
	                    xScale: this.xProps.scale,
	                    yScale: this.yProps.scale,
	                    seriesOffsetScale: this.seriesOffsetScale,
	                    isScalar: this.categoryLayout.isScalar,
	                    margin: this.margin,
	                };
	                var clusteredColumnLayout = this.layout = ClusteredColumnChartStrategy.getLayout(data, axisOptions);
	                var dataLabelSettings = data.labelSettings;
	                var labelDataPoints = [];
	                if (dataLabelSettings && dataLabelSettings.show) {
	                    labelDataPoints = this.createLabelDataPoints();
	                }
	                var result;
	                var shapes;
	                var series = visuals.ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);
	                if (this.animator && useAnimation) {
	                    result = this.animator.animate({
	                        viewModel: data,
	                        series: series,
	                        layout: clusteredColumnLayout,
	                        itemCS: ClusteredColumnChartStrategy.classes.item,
	                        interactivityService: this.interactivityService,
	                        mainGraphicsContext: this.graphicsContext.mainGraphicsContext,
	                        viewPort: { height: this.height, width: this.width }
	                    });
	                    shapes = result.shapes;
	                }
	                if (!this.animator || !useAnimation || result.failed) {
	                    shapes = visuals.ColumnUtil.drawDefaultShapes(data, series, clusteredColumnLayout, ClusteredColumnChartStrategy.classes.item, !this.animator, this.interactivityService && this.interactivityService.hasSelection());
	                }
	                visuals.ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart);
	                return {
	                    eventGroup: this.graphicsContext.mainGraphicsContext,
	                    shapesSelection: shapes,
	                    viewport: { height: this.height, width: this.width },
	                    axisOptions: axisOptions,
	                    labelDataPoints: labelDataPoints,
	                };
	            };
	            ClusteredColumnChartStrategy.prototype.selectColumn = function (selectedColumnIndex, lastSelectedColumnIndex) {
	                visuals.ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, ClusteredColumnChartStrategy.classes.item.selector, selectedColumnIndex, lastSelectedColumnIndex);
	                this.moveHandle(selectedColumnIndex);
	            };
	            ClusteredColumnChartStrategy.prototype.getClosestColumnIndex = function (x, y) {
	                return visuals.ColumnUtil.getClosestColumnIndex(x, this.getColumnsCenters());
	            };
	            /**
	             * Get the chart's columns centers (x value).
	             */
	            ClusteredColumnChartStrategy.prototype.getColumnsCenters = function () {
	                var _this = this;
	                if (!this.columnsCenters) {
	                    var categoryWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
	                    // use the axis scale and first series data to get category centers
	                    if (this.data.series.length > 0) {
	                        var xScaleOffset_1 = 0;
	                        if (!this.categoryLayout.isScalar)
	                            xScaleOffset_1 = categoryWidth / 2;
	                        var firstSeries = this.data.series[0];
	                        this.columnsCenters = firstSeries.data.map(function (d) { return _this.xProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + xScaleOffset_1; });
	                    }
	                }
	                return this.columnsCenters;
	            };
	            ClusteredColumnChartStrategy.prototype.moveHandle = function (selectedColumnIndex) {
	                var columnCenters = this.getColumnsCenters();
	                var x = columnCenters[selectedColumnIndex];
	                var hoverLine = d3.select('.interactive-hover-line');
	                if (!hoverLine.empty() && !this.columnSelectionLineHandle) {
	                    this.columnSelectionLineHandle = d3.select(hoverLine.node().parentNode);
	                }
	                if (!this.columnSelectionLineHandle) {
	                    var handle = this.columnSelectionLineHandle = this.graphicsContext.unclippedGraphicsContext.append('g');
	                    handle.append('line')
	                        .classed('interactive-hover-line', true)
	                        .attr({
	                        x1: x,
	                        x2: x,
	                        y1: 0,
	                        y2: this.height,
	                    });
	                    handle.append('circle')
	                        .attr({
	                        cx: x,
	                        cy: this.height,
	                        r: '6px',
	                    })
	                        .classed('drag-handle', true);
	                }
	                else {
	                    var handle = this.columnSelectionLineHandle;
	                    handle.select('line').attr({ x1: x, x2: x });
	                    handle.select('circle').attr({ cx: x });
	                }
	            };
	            ClusteredColumnChartStrategy.getLayout = function (data, axisOptions) {
	                var columnWidth = axisOptions.columnWidth;
	                var halfColumnWidth = 0.5 * columnWidth;
	                var quarterColumnWidth = halfColumnWidth / 2;
	                var isScalar = axisOptions.isScalar;
	                var xScale = axisOptions.xScale;
	                var yScale = axisOptions.yScale;
	                var seriesOffsetScale = axisOptions.seriesOffsetScale;
	                var scaledY0 = yScale(0);
	                var xScaleOffset = 0;
	                if (isScalar)
	                    xScaleOffset = axisOptions.categoryWidth / 2;
	                return {
	                    shapeLayout: {
	                        width: function (d) { return d.drawThinner ? halfColumnWidth : columnWidth; },
	                        x: function (d) { return xScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - xScaleOffset + (d.drawThinner ? quarterColumnWidth : 0); },
	                        y: function (d) { return scaledY0 + visuals.AxisHelper.diffScaled(yScale, Math.max(0, d.value), 0); },
	                        height: function (d) { return Math.abs(visuals.AxisHelper.diffScaled(yScale, 0, d.value)); },
	                    },
	                    shapeLayoutWithoutHighlights: {
	                        width: function (d) { return columnWidth; },
	                        x: function (d) { return xScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - xScaleOffset; },
	                        y: function (d) { return scaledY0 + visuals.AxisHelper.diffScaled(yScale, Math.max(0, d.originalValue), 0); },
	                        height: function (d) { return Math.abs(visuals.AxisHelper.diffScaled(yScale, 0, d.originalValue)); },
	                    },
	                    zeroShapeLayout: {
	                        width: function (d) { return d.drawThinner ? halfColumnWidth : columnWidth; },
	                        x: function (d) { return xScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - xScaleOffset + (d.drawThinner ? quarterColumnWidth : 0); },
	                        y: function (d) { return scaledY0; },
	                        height: function (d) { return 0; },
	                    },
	                };
	            };
	            ClusteredColumnChartStrategy.prototype.createLabelDataPoints = function () {
	                var labelDataPoints = [];
	                var data = this.data;
	                var series = data.series;
	                var formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager();
	                var shapeLayout = this.layout.shapeLayout;
	                for (var _i = 0, series_1 = series; _i < series_1.length; _i++) {
	                    var currentSeries = series_1[_i];
	                    var labelSettings = currentSeries.labelSettings ? currentSeries.labelSettings : data.labelSettings;
	                    if (!labelSettings.show)
	                        continue;
	                    var axisFormatter = visuals.NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yProps.formatter, labelSettings);
	                    for (var _a = 0, _b = currentSeries.data; _a < _b.length; _a++) {
	                        var dataPoint = _b[_a];
	                        if ((data.hasHighlights && !dataPoint.highlight) || dataPoint.value == null) {
	                            continue;
	                        }
	                        // Calculate parent rectangle
	                        var parentRect = {
	                            left: shapeLayout.x(dataPoint),
	                            top: shapeLayout.y(dataPoint),
	                            width: shapeLayout.width(dataPoint),
	                            height: shapeLayout.height(dataPoint),
	                        };
	                        // Calculate label text
	                        var formatString = dataPoint.labelFormatString;
	                        var formatter = formattersCache.getOrCreate(formatString, labelSettings, axisFormatter);
	                        var text = visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(dataPoint.value));
	                        // Calculate text size
	                        var properties = {
	                            text: text,
	                            fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
	                            fontSize: PixelConverter.fromPoint(labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt),
	                            fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight,
	                        };
	                        var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
	                        var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, true /* tightFitForNumeric */);
	                        labelDataPoints.push({
	                            isPreferred: true,
	                            text: text,
	                            textSize: {
	                                width: textWidth,
	                                height: textHeight,
	                            },
	                            outsideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, false, this.isComboChart),
	                            insideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, true, this.isComboChart),
	                            parentType: 1 /* Rectangle */,
	                            parentShape: {
	                                rect: parentRect,
	                                orientation: dataPoint.value >= 0 ? 1 /* VerticalBottomBased */ : 2 /* VerticalTopBased */,
	                                validPositions: visuals.ColumnChart.clusteredValidLabelPositions,
	                            },
	                            identity: dataPoint.identity,
	                            fontSize: labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt,
	                        });
	                    }
	                }
	                return labelDataPoints;
	            };
	            ClusteredColumnChartStrategy.classes = {
	                item: {
	                    class: 'column',
	                    selector: '.column',
	                },
	            };
	            return ClusteredColumnChartStrategy;
	        }());
	        visuals.ClusteredColumnChartStrategy = ClusteredColumnChartStrategy;
	        var ClusteredBarChartStrategy = (function () {
	            function ClusteredBarChartStrategy() {
	            }
	            ClusteredBarChartStrategy.prototype.setupVisualProps = function (barChartProps) {
	                this.graphicsContext = barChartProps;
	                this.margin = barChartProps.margin;
	                this.width = this.graphicsContext.width;
	                this.height = this.graphicsContext.height;
	                this.categoryLayout = barChartProps.layout;
	                this.animator = barChartProps.animator;
	                this.interactivityService = barChartProps.interactivityService;
	                this.viewportHeight = barChartProps.viewportHeight;
	                this.viewportWidth = barChartProps.viewportWidth;
	                this.isComboChart = barChartProps.isComboChart;
	            };
	            ClusteredBarChartStrategy.prototype.setData = function (data) {
	                this.data = data;
	            };
	            ClusteredBarChartStrategy.prototype.setYScale = function (is100Pct, forcedTickCount, forcedYDomain, axisScaleType, axisDisplayUnits, axisPrecision, ensureYDomain) {
	                var height = this.height;
	                var forcedYMin, forcedYMax;
	                if (forcedYDomain && forcedYDomain.length === 2) {
	                    forcedYMin = forcedYDomain[0];
	                    forcedYMax = forcedYDomain[1];
	                }
	                var props = this.yProps = visuals.ColumnUtil.getCategoryAxis(this.data, height, this.categoryLayout, true, forcedYMin, forcedYMax, axisScaleType, axisDisplayUnits, axisPrecision, ensureYDomain);
	                // create clustered offset scale
	                var seriesLength = this.data.series.length;
	                var columnWidth = (this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio)) / seriesLength;
	                this.seriesOffsetScale = d3.scale.ordinal()
	                    .domain(this.data.series.map(function (s) { return s.index; }))
	                    .rangeBands([0, seriesLength * columnWidth]);
	                return props;
	            };
	            ClusteredBarChartStrategy.prototype.setXScale = function (is100Pct, forcedTickCount, forcedXDomain, axisScaleType, axisDisplayUnits, axisPrecision, ensureXDomain) {
	                debug.assert(!is100Pct, 'Cannot have 100% clustered chart.');
	                debug.assert(forcedTickCount === undefined, 'Cannot have clustered bar chart as combo chart.');
	                var width = this.width;
	                var valueDomain = visuals.AxisHelper.createValueDomain(this.data.series, true) || visuals.emptyDomain;
	                var combinedDomain = visuals.AxisHelper.combineDomain(forcedXDomain, valueDomain, ensureXDomain);
	                var shouldClamp = visuals.AxisHelper.scaleShouldClamp(combinedDomain, valueDomain);
	                this.xProps = visuals.AxisHelper.createAxis({
	                    pixelSpan: width,
	                    dataDomain: combinedDomain,
	                    metaDataColumn: this.data.valuesMetadata[0],
	                    formatString: visuals.valueFormatter.getFormatString(this.data.valuesMetadata[0], visuals.columnChartProps.general.formatString),
	                    outerPadding: 0,
	                    isScalar: true,
	                    isVertical: false,
	                    forcedTickCount: forcedTickCount,
	                    useTickIntervalForDisplayUnits: true,
	                    isCategoryAxis: false,
	                    scaleType: axisScaleType,
	                    axisDisplayUnits: axisDisplayUnits,
	                    axisPrecision: axisPrecision,
	                    shouldClamp: shouldClamp,
	                });
	                this.xProps.axis.tickSize(-this.viewportHeight, 0);
	                return this.xProps;
	            };
	            ClusteredBarChartStrategy.prototype.drawColumns = function (useAnimation) {
	                var data = this.data;
	                debug.assertValue(data, 'data could not be null or undefined');
	                this.barsCenters = null; // invalidate the columnsCenters so that will be calculated again
	                var categoryWidth = (this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio));
	                var columnWidth = categoryWidth / data.series.length;
	                var axisOptions = {
	                    columnWidth: columnWidth,
	                    categoryWidth: categoryWidth,
	                    xScale: this.xProps.scale,
	                    yScale: this.yProps.scale,
	                    seriesOffsetScale: this.seriesOffsetScale,
	                    isScalar: this.categoryLayout.isScalar,
	                    margin: this.margin,
	                };
	                var clusteredBarLayout = this.layout = ClusteredBarChartStrategy.getLayout(data, axisOptions);
	                var dataLabelSettings = data.labelSettings;
	                var labelDataPoints = [];
	                if (dataLabelSettings && dataLabelSettings.show) {
	                    labelDataPoints = this.createLabelDataPoints();
	                }
	                var result;
	                var shapes;
	                var series = visuals.ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);
	                if (this.animator && useAnimation) {
	                    result = this.animator.animate({
	                        viewModel: data,
	                        series: series,
	                        layout: clusteredBarLayout,
	                        itemCS: ClusteredBarChartStrategy.classes.item,
	                        interactivityService: this.interactivityService,
	                        mainGraphicsContext: this.graphicsContext.mainGraphicsContext,
	                        viewPort: { height: this.height, width: this.width }
	                    });
	                    shapes = result.shapes;
	                }
	                if (!this.animator || !useAnimation || result.failed) {
	                    shapes = visuals.ColumnUtil.drawDefaultShapes(data, series, clusteredBarLayout, ClusteredBarChartStrategy.classes.item, !this.animator, this.interactivityService && this.interactivityService.hasSelection());
	                }
	                visuals.ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart);
	                return {
	                    eventGroup: this.graphicsContext.mainGraphicsContext,
	                    shapesSelection: shapes,
	                    viewport: { height: this.height, width: this.width },
	                    axisOptions: axisOptions,
	                    labelDataPoints: labelDataPoints,
	                };
	            };
	            ClusteredBarChartStrategy.prototype.selectColumn = function (selectedColumnIndex, lastSelectedColumnIndex) {
	                visuals.ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, ClusteredBarChartStrategy.classes.item.selector, selectedColumnIndex, lastSelectedColumnIndex);
	                this.moveHandle(selectedColumnIndex);
	            };
	            ClusteredBarChartStrategy.prototype.getClosestColumnIndex = function (x, y) {
	                return visuals.ColumnUtil.getClosestColumnIndex(y, this.getBarsCenters());
	            };
	            /**
	             * Get the chart's columns centers (y value).
	             */
	            ClusteredBarChartStrategy.prototype.getBarsCenters = function () {
	                var _this = this;
	                if (!this.barsCenters) {
	                    var barWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
	                    // use the axis scale and first series data to get category centers
	                    if (this.data.series.length > 0) {
	                        var yScaleOffset_1 = 0;
	                        if (!this.categoryLayout.isScalar)
	                            yScaleOffset_1 = barWidth / 2;
	                        var firstSeries = this.data.series[0];
	                        this.barsCenters = firstSeries.data.map(function (d) { return _this.yProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + yScaleOffset_1; });
	                    }
	                }
	                return this.barsCenters;
	            };
	            ClusteredBarChartStrategy.prototype.moveHandle = function (selectedColumnIndex) {
	                var barCenters = this.getBarsCenters();
	                var y = barCenters[selectedColumnIndex];
	                var hoverLine = d3.select('.interactive-hover-line');
	                if (!hoverLine.empty() && !this.columnSelectionLineHandle) {
	                    this.columnSelectionLineHandle = d3.select(hoverLine.node().parentNode);
	                }
	                if (!this.columnSelectionLineHandle) {
	                    var handle = this.columnSelectionLineHandle = this.graphicsContext.unclippedGraphicsContext.append('g');
	                    handle.append('line')
	                        .classed('interactive-hover-line', true)
	                        .attr({
	                        x1: 0,
	                        x2: this.width,
	                        y1: y,
	                        y2: y,
	                    });
	                    handle.append('circle')
	                        .attr({
	                        cx: 0,
	                        cy: y,
	                        r: '6px',
	                    })
	                        .classed('drag-handle', true);
	                }
	                else {
	                    var handle = this.columnSelectionLineHandle;
	                    handle.select('line').attr({ y1: y, y2: y });
	                    handle.select('circle').attr({ cy: y });
	                }
	            };
	            ClusteredBarChartStrategy.getLayout = function (data, axisOptions) {
	                var columnWidth = axisOptions.columnWidth;
	                var halfColumnWidth = 0.5 * columnWidth;
	                var quarterColumnWidth = halfColumnWidth / 2;
	                var isScalar = axisOptions.isScalar;
	                var xScale = axisOptions.xScale;
	                var yScale = axisOptions.yScale;
	                var seriesOffsetScale = axisOptions.seriesOffsetScale;
	                var scaledX0 = xScale(0);
	                var yScaleOffset = 0;
	                if (isScalar)
	                    yScaleOffset = axisOptions.categoryWidth / 2;
	                return {
	                    shapeLayout: {
	                        width: function (d) { return Math.abs(visuals.AxisHelper.diffScaled(xScale, 0, d.value)); },
	                        x: function (d) { return scaledX0 + visuals.AxisHelper.diffScaled(xScale, Math.min(0, d.value), 0); },
	                        y: function (d) { return yScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - yScaleOffset + (d.drawThinner ? quarterColumnWidth : 0); },
	                        height: function (d) { return d.drawThinner ? halfColumnWidth : columnWidth; },
	                    },
	                    shapeLayoutWithoutHighlights: {
	                        width: function (d) { return Math.abs(visuals.AxisHelper.diffScaled(xScale, 0, d.originalValue)); },
	                        x: function (d) { return scaledX0 + visuals.AxisHelper.diffScaled(xScale, Math.min(0, d.originalValue), 0); },
	                        y: function (d) { return yScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - yScaleOffset; },
	                        height: function (d) { return columnWidth; },
	                    },
	                    zeroShapeLayout: {
	                        width: function (d) { return 0; },
	                        x: function (d) { return scaledX0 + visuals.AxisHelper.diffScaled(xScale, Math.min(0, d.value), 0); },
	                        y: function (d) { return yScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - yScaleOffset + (d.drawThinner ? quarterColumnWidth : 0); },
	                        height: function (d) { return d.drawThinner ? halfColumnWidth : columnWidth; },
	                    },
	                };
	            };
	            ClusteredBarChartStrategy.prototype.createLabelDataPoints = function () {
	                var labelDataPoints = [];
	                var data = this.data;
	                var series = data.series;
	                var formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager();
	                var shapeLayout = this.layout.shapeLayout;
	                for (var _i = 0, series_2 = series; _i < series_2.length; _i++) {
	                    var currentSeries = series_2[_i];
	                    var labelSettings = currentSeries.labelSettings ? currentSeries.labelSettings : data.labelSettings;
	                    if (!labelSettings.show)
	                        continue;
	                    var axisFormatter = visuals.NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yProps.formatter, labelSettings);
	                    for (var _a = 0, _b = currentSeries.data; _a < _b.length; _a++) {
	                        var dataPoint = _b[_a];
	                        if ((data.hasHighlights && !dataPoint.highlight) || dataPoint.value == null) {
	                            continue;
	                        }
	                        // Calculate label text
	                        var formatString = dataPoint.labelFormatString;
	                        var formatter = formattersCache.getOrCreate(formatString, labelSettings, axisFormatter);
	                        var text = visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(dataPoint.value));
	                        // Calculate text size
	                        var properties = {
	                            text: text,
	                            fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
	                            fontSize: PixelConverter.fromPoint(labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt),
	                            fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight,
	                        };
	                        var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
	                        var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, true /* tightFitForNumeric */);
	                        // Calculate parent rectangle
	                        var parentRect = {
	                            left: shapeLayout.x(dataPoint),
	                            top: shapeLayout.y(dataPoint),
	                            width: shapeLayout.width(dataPoint),
	                            height: shapeLayout.height(dataPoint),
	                        };
	                        labelDataPoints.push({
	                            isPreferred: true,
	                            text: text,
	                            textSize: {
	                                width: textWidth,
	                                height: textHeight,
	                            },
	                            outsideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, false, this.isComboChart),
	                            insideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, true, this.isComboChart),
	                            parentType: 1 /* Rectangle */,
	                            parentShape: {
	                                rect: parentRect,
	                                orientation: dataPoint.value >= 0 ? 3 /* HorizontalLeftBased */ : 4 /* HorizontalRightBased */,
	                                validPositions: visuals.ColumnChart.clusteredValidLabelPositions,
	                            },
	                            identity: dataPoint.identity,
	                            fontSize: labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt,
	                        });
	                    }
	                }
	                return labelDataPoints;
	            };
	            ClusteredBarChartStrategy.classes = {
	                item: {
	                    class: 'bar',
	                    selector: '.bar'
	                },
	            };
	            return ClusteredBarChartStrategy;
	        }());
	        visuals.ClusteredBarChartStrategy = ClusteredBarChartStrategy;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 256 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var PixelConverter = jsCommon.PixelConverter;
	        var StackedColumnChartStrategy = (function () {
	            function StackedColumnChartStrategy() {
	            }
	            StackedColumnChartStrategy.prototype.setupVisualProps = function (columnChartProps) {
	                this.graphicsContext = columnChartProps;
	                this.margin = columnChartProps.margin;
	                this.width = this.graphicsContext.width;
	                this.height = this.graphicsContext.height;
	                this.categoryLayout = columnChartProps.layout;
	                this.animator = columnChartProps.animator;
	                this.interactivityService = columnChartProps.interactivityService;
	                this.viewportHeight = columnChartProps.viewportHeight;
	                this.viewportWidth = columnChartProps.viewportWidth;
	                this.isComboChart = columnChartProps.isComboChart;
	            };
	            StackedColumnChartStrategy.prototype.setData = function (data) {
	                this.data = data;
	            };
	            StackedColumnChartStrategy.prototype.setXScale = function (is100Pct, forcedTickCount, forcedXDomain, axisScaleType, axisDisplayUnits, axisPrecision, xReferenceLineValue) {
	                var width = this.width;
	                var forcedXMin, forcedXMax;
	                if (forcedXDomain && forcedXDomain.length === 2) {
	                    forcedXMin = forcedXDomain[0];
	                    forcedXMax = forcedXDomain[1];
	                }
	                var props = this.xProps = visuals.ColumnUtil.getCategoryAxis(this.data, width, this.categoryLayout, false, forcedXMin, forcedXMax, axisScaleType, axisDisplayUnits, axisPrecision, xReferenceLineValue);
	                return props;
	            };
	            StackedColumnChartStrategy.prototype.setYScale = function (is100Pct, forcedTickCount, forcedYDomain, axisScaleType, axisDisplayUnits, axisPrecision, y1ReferenceLineValue) {
	                var height = this.viewportHeight;
	                var valueDomain = visuals.StackedUtil.calcValueDomain(this.data.series, is100Pct);
	                var valueDomainArr = [valueDomain.min, valueDomain.max];
	                var combinedDomain = visuals.AxisHelper.combineDomain(forcedYDomain, valueDomainArr, y1ReferenceLineValue);
	                var shouldClamp = visuals.AxisHelper.scaleShouldClamp(combinedDomain, valueDomainArr);
	                var metadataColumn = this.data.valuesMetadata[0];
	                var formatString = is100Pct ?
	                    this.graphicsContext.hostService.getLocalizedString('Percentage')
	                    : visuals.valueFormatter.getFormatString(metadataColumn, visuals.columnChartProps.general.formatString);
	                this.yProps = visuals.AxisHelper.createAxis({
	                    pixelSpan: height,
	                    dataDomain: combinedDomain,
	                    metaDataColumn: metadataColumn,
	                    formatString: formatString,
	                    outerPadding: 0,
	                    isScalar: true,
	                    isVertical: true,
	                    forcedTickCount: forcedTickCount,
	                    useTickIntervalForDisplayUnits: true,
	                    isCategoryAxis: false,
	                    scaleType: axisScaleType,
	                    axisDisplayUnits: axisDisplayUnits,
	                    axisPrecision: axisPrecision,
	                    is100Pct: is100Pct,
	                    shouldClamp: shouldClamp,
	                });
	                return this.yProps;
	            };
	            StackedColumnChartStrategy.prototype.drawColumns = function (useAnimation) {
	                var data = this.data;
	                debug.assertValue(data, 'data should not be null or undefined');
	                this.columnsCenters = null; // invalidate the columnsCenters so that will be calculated again
	                var axisOptions = {
	                    columnWidth: this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio),
	                    xScale: this.xProps.scale,
	                    yScale: this.yProps.scale,
	                    isScalar: this.categoryLayout.isScalar,
	                    margin: this.margin,
	                };
	                var stackedColumnLayout = this.layout = StackedColumnChartStrategy.getLayout(data, axisOptions);
	                var dataLabelSettings = data.labelSettings;
	                var labelDataPoints = [];
	                if (dataLabelSettings && dataLabelSettings.show) {
	                    labelDataPoints = this.createLabelDataPoints();
	                }
	                var result;
	                var shapes;
	                var series = visuals.ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);
	                if (this.animator && useAnimation) {
	                    result = this.animator.animate({
	                        viewModel: data,
	                        series: series,
	                        layout: stackedColumnLayout,
	                        itemCS: StackedColumnChartStrategy.classes.item,
	                        interactivityService: this.interactivityService,
	                        mainGraphicsContext: this.graphicsContext.mainGraphicsContext,
	                        viewPort: { height: this.height, width: this.width },
	                    });
	                    shapes = result.shapes;
	                }
	                if (!this.animator || !useAnimation || result.failed) {
	                    shapes = visuals.ColumnUtil.drawDefaultShapes(data, series, stackedColumnLayout, StackedColumnChartStrategy.classes.item, !this.animator, this.interactivityService && this.interactivityService.hasSelection());
	                }
	                visuals.ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart);
	                return {
	                    eventGroup: this.graphicsContext.mainGraphicsContext,
	                    shapesSelection: shapes,
	                    viewport: { height: this.height, width: this.width },
	                    axisOptions: axisOptions,
	                    labelDataPoints: labelDataPoints,
	                };
	            };
	            StackedColumnChartStrategy.prototype.selectColumn = function (selectedColumnIndex, lastSelectedColumnIndex) {
	                visuals.ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, StackedColumnChartStrategy.classes.item.selector, selectedColumnIndex, lastSelectedColumnIndex);
	                this.moveHandle(selectedColumnIndex);
	            };
	            StackedColumnChartStrategy.prototype.getClosestColumnIndex = function (x, y) {
	                return visuals.ColumnUtil.getClosestColumnIndex(x, this.getColumnsCenters());
	            };
	            /**
	             * Get the chart's columns centers (x value).
	             */
	            StackedColumnChartStrategy.prototype.getColumnsCenters = function () {
	                var _this = this;
	                if (!this.columnsCenters) {
	                    var categoryWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
	                    // use the axis scale and first series data to get category centers
	                    if (this.data.series.length > 0) {
	                        var xScaleOffset_1 = 0;
	                        if (!this.categoryLayout.isScalar)
	                            xScaleOffset_1 = categoryWidth / 2;
	                        var firstSeries = this.data.series[0];
	                        this.columnsCenters = firstSeries.data.map(function (d) { return _this.xProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + xScaleOffset_1; });
	                    }
	                }
	                return this.columnsCenters;
	            };
	            StackedColumnChartStrategy.prototype.moveHandle = function (selectedColumnIndex) {
	                var columnCenters = this.getColumnsCenters();
	                var x = columnCenters[selectedColumnIndex];
	                var hoverLine = d3.select('.interactive-hover-line');
	                if (!hoverLine.empty() && !this.columnSelectionLineHandle) {
	                    this.columnSelectionLineHandle = d3.select(hoverLine.node().parentNode);
	                }
	                if (!this.columnSelectionLineHandle) {
	                    var handle = this.columnSelectionLineHandle = this.graphicsContext.unclippedGraphicsContext.append('g');
	                    handle.append('line')
	                        .classed('interactive-hover-line', true)
	                        .attr({
	                        x1: x,
	                        x2: x,
	                        y1: 0,
	                        y2: this.height,
	                    });
	                    handle.append('circle')
	                        .attr({
	                        cx: x,
	                        cy: this.height,
	                        r: '6px',
	                    })
	                        .classed('drag-handle', true);
	                }
	                else {
	                    var handle = this.columnSelectionLineHandle;
	                    handle.select('line').attr({ x1: x, x2: x });
	                    handle.select('circle').attr({ cx: x });
	                }
	            };
	            StackedColumnChartStrategy.getLayout = function (data, axisOptions) {
	                var columnWidth = axisOptions.columnWidth;
	                var isScalar = axisOptions.isScalar;
	                var xScale = axisOptions.xScale;
	                var yScale = axisOptions.yScale;
	                var xScaleOffset = 0;
	                if (isScalar)
	                    xScaleOffset = columnWidth / 2;
	                // d.position is the top left corner (for drawing) - set in columnChart.converter
	                // for positive values, this is the previous stack position + the new value,
	                // for negative values it is just the previous stack position
	                return {
	                    shapeLayout: {
	                        width: function (d) { return columnWidth; },
	                        x: function (d) { return xScale(isScalar ? d.categoryValue : d.categoryIndex) - xScaleOffset; },
	                        y: function (d) { return yScale(d.position); },
	                        height: function (d) { return yScale(d.position - d.valueAbsolute) - yScale(d.position); },
	                    },
	                    shapeLayoutWithoutHighlights: {
	                        width: function (d) { return columnWidth; },
	                        x: function (d) { return xScale(isScalar ? d.categoryValue : d.categoryIndex) - xScaleOffset; },
	                        y: function (d) { return yScale(d.originalPosition); },
	                        height: function (d) { return yScale(d.originalPosition - d.originalValueAbsolute) - yScale(d.originalPosition); },
	                    },
	                    zeroShapeLayout: {
	                        width: function (d) { return columnWidth; },
	                        x: function (d) { return xScale(isScalar ? d.categoryValue : d.categoryIndex) - xScaleOffset; },
	                        y: function (d) { return d.value >= 0 ? yScale(d.position - d.valueAbsolute) : yScale(d.position); },
	                        height: function (d) { return 0; }
	                    },
	                };
	            };
	            StackedColumnChartStrategy.prototype.createLabelDataPoints = function () {
	                var labelDataPoints = [];
	                var data = this.data;
	                var series = data.series;
	                var formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager();
	                var shapeLayout = this.layout.shapeLayout;
	                for (var _i = 0, series_1 = series; _i < series_1.length; _i++) {
	                    var currentSeries = series_1[_i];
	                    var labelSettings = currentSeries.labelSettings ? currentSeries.labelSettings : data.labelSettings;
	                    if (!labelSettings.show)
	                        continue;
	                    var axisFormatter = visuals.NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yProps.formatter, labelSettings);
	                    for (var _a = 0, _b = currentSeries.data; _a < _b.length; _a++) {
	                        var dataPoint = _b[_a];
	                        if ((data.hasHighlights && !dataPoint.highlight) || dataPoint.value == null) {
	                            continue;
	                        }
	                        // Calculate parent rectangle
	                        var parentRect = {
	                            left: shapeLayout.x(dataPoint),
	                            top: shapeLayout.y(dataPoint),
	                            width: shapeLayout.width(dataPoint),
	                            height: shapeLayout.height(dataPoint),
	                        };
	                        // Calculate label text
	                        var formatString = "";
	                        if (this.graphicsContext.is100Pct) {
	                            formatString = visuals.NewDataLabelUtils.hundredPercentFormat;
	                        }
	                        else {
	                            formatString = dataPoint.labelFormatString;
	                        }
	                        var formatter = formattersCache.getOrCreate(formatString, labelSettings, axisFormatter);
	                        var text = visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(dataPoint.value));
	                        // Calculate text size
	                        var properties = {
	                            text: text,
	                            fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
	                            fontSize: PixelConverter.fromPoint(labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt),
	                            fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight,
	                        };
	                        var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
	                        var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, true /* tightFitForNumeric */);
	                        labelDataPoints.push({
	                            isPreferred: true,
	                            text: text,
	                            textSize: {
	                                width: textWidth,
	                                height: textHeight,
	                            },
	                            outsideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, false, this.isComboChart),
	                            insideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, true, this.isComboChart),
	                            parentType: 1 /* Rectangle */,
	                            parentShape: {
	                                rect: parentRect,
	                                orientation: dataPoint.value >= 0 ? 1 /* VerticalBottomBased */ : 2 /* VerticalTopBased */,
	                                validPositions: visuals.ColumnChart.stackedValidLabelPositions,
	                            },
	                            identity: dataPoint.identity,
	                            fontSize: labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt,
	                        });
	                    }
	                }
	                return labelDataPoints;
	            };
	            StackedColumnChartStrategy.classes = {
	                item: {
	                    class: 'column',
	                    selector: '.column'
	                },
	                highlightItem: {
	                    class: 'highlightColumn',
	                    selector: '.highlightColumn'
	                },
	            };
	            return StackedColumnChartStrategy;
	        }());
	        visuals.StackedColumnChartStrategy = StackedColumnChartStrategy;
	        var StackedBarChartStrategy = (function () {
	            function StackedBarChartStrategy() {
	            }
	            StackedBarChartStrategy.prototype.setupVisualProps = function (barChartProps) {
	                this.graphicsContext = barChartProps;
	                this.margin = barChartProps.margin;
	                this.width = this.graphicsContext.width;
	                this.height = this.graphicsContext.height;
	                this.categoryLayout = barChartProps.layout;
	                this.animator = barChartProps.animator;
	                this.interactivityService = barChartProps.interactivityService;
	                this.viewportHeight = barChartProps.viewportHeight;
	                this.viewportWidth = barChartProps.viewportWidth;
	                this.isComboChart = barChartProps.isComboChart;
	            };
	            StackedBarChartStrategy.prototype.setData = function (data) {
	                this.data = data;
	            };
	            StackedBarChartStrategy.prototype.setYScale = function (is100Pct, forcedTickCount, forcedYDomain, axisScaleType, axisDisplayUnits, axisPrecision, ensureYDomain) {
	                var height = this.height;
	                var forcedYMin, forcedYMax;
	                if (forcedYDomain && forcedYDomain.length === 2) {
	                    forcedYMin = forcedYDomain[0];
	                    forcedYMax = forcedYDomain[1];
	                }
	                var props = this.yProps = visuals.ColumnUtil.getCategoryAxis(this.data, height, this.categoryLayout, true, forcedYMin, forcedYMax, axisScaleType, axisDisplayUnits, axisPrecision, ensureYDomain);
	                return props;
	            };
	            StackedBarChartStrategy.prototype.setXScale = function (is100Pct, forcedTickCount, forcedXDomain, axisScaleType, axisDisplayUnits, axisPrecision, ensureXDomain) {
	                debug.assert(forcedTickCount === undefined, 'Cannot have stacked bar chart as combo chart.');
	                var width = this.width;
	                var valueDomain = visuals.StackedUtil.calcValueDomain(this.data.series, is100Pct);
	                var valueDomainArr = [valueDomain.min, valueDomain.max];
	                var combinedDomain = visuals.AxisHelper.combineDomain(forcedXDomain, valueDomainArr, ensureXDomain);
	                var shouldClamp = visuals.AxisHelper.scaleShouldClamp(combinedDomain, valueDomainArr);
	                var metadataColumn = this.data.valuesMetadata[0];
	                var formatString = is100Pct ?
	                    this.graphicsContext.hostService.getLocalizedString('Percentage')
	                    : visuals.valueFormatter.getFormatString(metadataColumn, visuals.columnChartProps.general.formatString);
	                this.xProps = visuals.AxisHelper.createAxis({
	                    pixelSpan: width,
	                    dataDomain: combinedDomain,
	                    metaDataColumn: metadataColumn,
	                    formatString: formatString,
	                    outerPadding: 0,
	                    isScalar: true,
	                    isVertical: false,
	                    forcedTickCount: forcedTickCount,
	                    useTickIntervalForDisplayUnits: true,
	                    isCategoryAxis: false,
	                    scaleType: axisScaleType,
	                    axisDisplayUnits: axisDisplayUnits,
	                    axisPrecision: axisPrecision,
	                    is100Pct: is100Pct,
	                    shouldClamp: shouldClamp,
	                });
	                this.xProps.axis.tickSize(-this.viewportHeight, 0);
	                return this.xProps;
	            };
	            StackedBarChartStrategy.prototype.drawColumns = function (useAnimation) {
	                var data = this.data;
	                debug.assertValue(data, 'data should not be null or undefined');
	                this.barsCenters = null; // invalidate the barsCenters so that will be calculated again
	                var axisOptions = {
	                    columnWidth: this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio),
	                    xScale: this.xProps.scale,
	                    yScale: this.yProps.scale,
	                    isScalar: this.categoryLayout.isScalar,
	                    margin: this.margin,
	                };
	                var stackedBarLayout = this.layout = StackedBarChartStrategy.getLayout(data, axisOptions);
	                var dataLabelSettings = data.labelSettings;
	                var labelDataPoints = [];
	                if (dataLabelSettings && dataLabelSettings.show) {
	                    labelDataPoints = this.createLabelDataPoints();
	                }
	                var result;
	                var shapes;
	                var series = visuals.ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);
	                if (this.animator && useAnimation) {
	                    result = this.animator.animate({
	                        viewModel: data,
	                        series: series,
	                        layout: stackedBarLayout,
	                        itemCS: StackedBarChartStrategy.classes.item,
	                        interactivityService: this.interactivityService,
	                        mainGraphicsContext: this.graphicsContext.mainGraphicsContext,
	                        viewPort: { height: this.height, width: this.width },
	                    });
	                    shapes = result.shapes;
	                }
	                if (!this.animator || !useAnimation || result.failed) {
	                    shapes = visuals.ColumnUtil.drawDefaultShapes(data, series, stackedBarLayout, StackedBarChartStrategy.classes.item, !this.animator, this.interactivityService && this.interactivityService.hasSelection());
	                }
	                visuals.ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart);
	                return {
	                    eventGroup: this.graphicsContext.mainGraphicsContext,
	                    shapesSelection: shapes,
	                    viewport: { height: this.height, width: this.width },
	                    axisOptions: axisOptions,
	                    labelDataPoints: labelDataPoints,
	                };
	            };
	            StackedBarChartStrategy.prototype.selectColumn = function (selectedColumnIndex, lastInteractiveSelectedColumnIndex) {
	                visuals.ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, StackedBarChartStrategy.classes.item.selector, selectedColumnIndex, lastInteractiveSelectedColumnIndex);
	                this.moveHandle(selectedColumnIndex);
	            };
	            StackedBarChartStrategy.prototype.getClosestColumnIndex = function (x, y) {
	                return visuals.ColumnUtil.getClosestColumnIndex(y, this.getBarsCenters());
	            };
	            /**
	             * Get the chart's columns centers (y value).
	             */
	            StackedBarChartStrategy.prototype.getBarsCenters = function () {
	                var _this = this;
	                if (!this.barsCenters) {
	                    var barWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
	                    // use the axis scale and first series data to get category centers
	                    if (this.data.series.length > 0) {
	                        var yScaleOffset_1 = 0;
	                        if (!this.categoryLayout.isScalar)
	                            yScaleOffset_1 = barWidth / 2;
	                        var firstSeries = this.data.series[0];
	                        this.barsCenters = firstSeries.data.map(function (d) { return _this.yProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + yScaleOffset_1; });
	                    }
	                }
	                return this.barsCenters;
	            };
	            StackedBarChartStrategy.prototype.moveHandle = function (selectedColumnIndex) {
	                var barCenters = this.getBarsCenters();
	                var y = barCenters[selectedColumnIndex];
	                var hoverLine = d3.select('.interactive-hover-line');
	                if (!hoverLine.empty() && !this.columnSelectionLineHandle) {
	                    this.columnSelectionLineHandle = d3.select(hoverLine.node().parentNode);
	                }
	                if (!this.columnSelectionLineHandle) {
	                    var handle = this.columnSelectionLineHandle = this.graphicsContext.unclippedGraphicsContext.append('g');
	                    handle.append('line')
	                        .classed('interactive-hover-line', true)
	                        .attr({
	                        x1: 0,
	                        x2: this.width,
	                        y1: y,
	                        y2: y
	                    });
	                    handle.append('circle')
	                        .classed('drag-handle', true)
	                        .attr({
	                        cx: 0,
	                        cy: y,
	                        r: '6px',
	                    });
	                }
	                else {
	                    var handle = this.columnSelectionLineHandle;
	                    handle.select('line').attr({ y1: y, y2: y });
	                    handle.select('circle').attr({ cy: y });
	                }
	            };
	            StackedBarChartStrategy.getLayout = function (data, axisOptions) {
	                var columnWidth = axisOptions.columnWidth;
	                var isScalar = axisOptions.isScalar;
	                var xScale = axisOptions.xScale;
	                var yScale = axisOptions.yScale;
	                var yScaleOffset = 0;
	                if (isScalar)
	                    yScaleOffset = columnWidth / 2;
	                // d.position is the top right corner for bars - set in columnChart.converter
	                // for positive values, this is the previous stack position + the new value,
	                // for negative values it is just the previous stack position
	                return {
	                    shapeLayout: {
	                        width: function (d) { return xScale(d.position) - xScale(d.position - d.valueAbsolute); },
	                        x: function (d) { return xScale(d.position - d.valueAbsolute); },
	                        y: function (d) { return yScale(isScalar ? d.categoryValue : d.categoryIndex) - yScaleOffset; },
	                        height: function (d) { return columnWidth; },
	                    },
	                    shapeLayoutWithoutHighlights: {
	                        width: function (d) { return xScale(d.originalPosition) - xScale(d.originalPosition - d.originalValueAbsolute); },
	                        x: function (d) { return xScale(d.originalPosition - d.originalValueAbsolute); },
	                        y: function (d) { return yScale(isScalar ? d.categoryValue : d.categoryIndex) - yScaleOffset; },
	                        height: function (d) { return columnWidth; },
	                    },
	                    zeroShapeLayout: {
	                        width: function (d) { return 0; },
	                        x: function (d) { return d.value >= 0 ? xScale(d.position - d.valueAbsolute) : xScale(d.position); },
	                        y: function (d) { return yScale(isScalar ? d.categoryValue : d.categoryIndex) - yScaleOffset; },
	                        height: function (d) { return columnWidth; },
	                    },
	                };
	            };
	            StackedBarChartStrategy.prototype.createLabelDataPoints = function () {
	                var labelDataPoints = [];
	                var data = this.data;
	                var series = data.series;
	                var formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager();
	                var shapeLayout = this.layout.shapeLayout;
	                for (var _i = 0, series_2 = series; _i < series_2.length; _i++) {
	                    var currentSeries = series_2[_i];
	                    var labelSettings = currentSeries.labelSettings ? currentSeries.labelSettings : data.labelSettings;
	                    if (!labelSettings.show)
	                        continue;
	                    var axisFormatter = visuals.NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yProps.formatter, labelSettings);
	                    for (var _a = 0, _b = currentSeries.data; _a < _b.length; _a++) {
	                        var dataPoint = _b[_a];
	                        if ((data.hasHighlights && !dataPoint.highlight) || dataPoint.value == null) {
	                            continue;
	                        }
	                        // Calculate label text
	                        var formatString = undefined;
	                        if (this.graphicsContext.is100Pct) {
	                            formatString = visuals.NewDataLabelUtils.hundredPercentFormat;
	                        }
	                        else {
	                            formatString = dataPoint.labelFormatString;
	                        }
	                        var formatter = formattersCache.getOrCreate(formatString, labelSettings, axisFormatter);
	                        var text = visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(dataPoint.value));
	                        // Calculate text size
	                        var properties = {
	                            text: text,
	                            fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
	                            fontSize: PixelConverter.fromPoint(labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt),
	                            fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight,
	                        };
	                        var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
	                        var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, true /* tightFitForNumeric */);
	                        // Calculate parent rectangle
	                        var parentRect = {
	                            left: shapeLayout.x(dataPoint),
	                            top: shapeLayout.y(dataPoint),
	                            width: shapeLayout.width(dataPoint),
	                            height: shapeLayout.height(dataPoint),
	                        };
	                        labelDataPoints.push({
	                            isPreferred: true,
	                            text: text,
	                            textSize: {
	                                width: textWidth,
	                                height: textHeight,
	                            },
	                            outsideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, false, this.isComboChart),
	                            insideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, true, this.isComboChart),
	                            parentType: 1 /* Rectangle */,
	                            parentShape: {
	                                rect: parentRect,
	                                orientation: dataPoint.value >= 0 ? 3 /* HorizontalLeftBased */ : 4 /* HorizontalRightBased */,
	                                validPositions: visuals.ColumnChart.stackedValidLabelPositions,
	                            },
	                            identity: dataPoint.identity,
	                            fontSize: labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt,
	                        });
	                    }
	                }
	                return labelDataPoints;
	            };
	            StackedBarChartStrategy.classes = {
	                item: {
	                    class: 'bar',
	                    selector: '.bar'
	                },
	                highlightItem: {
	                    class: 'highlightBar',
	                    selector: '.highlightBar'
	                },
	            };
	            return StackedBarChartStrategy;
	        }());
	        visuals.StackedBarChartStrategy = StackedBarChartStrategy;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 257 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var samples;
	        (function (samples) {
	            var SelectionManager = visuals.utility.SelectionManager;
	            var HelloIVisual = (function () {
	                function HelloIVisual() {
	                }
	                HelloIVisual.converter = function (dataView) {
	                    var viewModel = {
	                        size: HelloIVisual.getSize(dataView),
	                        color: HelloIVisual.getFill(dataView).solid.color,
	                        text: HelloIVisual.DefaultText,
	                        toolTipInfo: [{
	                                displayName: 'Test',
	                                value: '1...2....3... can you see me? I am sending random strings to the tooltip',
	                            }],
	                        selector: visuals.SelectionId.createNull()
	                    };
	                    var table = dataView.table;
	                    if (!table)
	                        return viewModel;
	                    viewModel.text = table.rows[0][0];
	                    if (dataView.categorical) {
	                        viewModel.selector = dataView.categorical.categories[0].identity
	                            ? visuals.SelectionId.createWithId(dataView.categorical.categories[0].identity[0])
	                            : visuals.SelectionId.createNull();
	                    }
	                    return viewModel;
	                };
	                HelloIVisual.prototype.init = function (options) {
	                    this.root = d3.select(options.element.get(0))
	                        .append('svg')
	                        .classed('hello', true);
	                    this.svgText = this.root
	                        .append('text')
	                        .style('cursor', 'pointer')
	                        .style('stroke', 'green')
	                        .style('stroke-width', '0px')
	                        .attr('text-anchor', 'middle');
	                    this.selectiionManager = new SelectionManager({ hostServices: options.host });
	                };
	                HelloIVisual.prototype.update = function (options) {
	                    if (!options.dataViews && !options.dataViews[0])
	                        return;
	                    var dataView = this.dataView = options.dataViews[0];
	                    var viewport = options.viewport;
	                    var viewModel = HelloIVisual.converter(dataView);
	                    this.root.attr({
	                        'height': viewport.height,
	                        'width': viewport.width
	                    });
	                    var textProperties = {
	                        fontFamily: 'tahoma',
	                        fontSize: viewModel.size + 'px',
	                        text: viewModel.text
	                    };
	                    var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties);
	                    var selectionManager = this.selectiionManager;
	                    this.svgText.style({
	                        'fill': viewModel.color,
	                        'font-size': textProperties.fontSize,
	                        'font-family': textProperties.fontFamily,
	                    }).attr({
	                        'y': viewport.height / 2 + textHeight / 3 + 'px',
	                        'x': viewport.width / 2,
	                    }).text(viewModel.text)
	                        .on('click', function () {
	                        var _this = this;
	                        selectionManager
	                            .select(viewModel.selector)
	                            .then(function (ids) { return d3.select(_this).style('stroke-width', ids.length > 0 ? '2px' : '0px'); });
	                    })
	                        .data([viewModel]);
	                    visuals.TooltipManager.addTooltip(this.svgText, function (tooltipEvent) { return tooltipEvent.data.toolTipInfo; });
	                };
	                HelloIVisual.getFill = function (dataView) {
	                    if (dataView) {
	                        var objects = dataView.metadata.objects;
	                        if (objects) {
	                            var general = objects['general'];
	                            if (general) {
	                                var fill = general['fill'];
	                                if (fill)
	                                    return fill;
	                            }
	                        }
	                    }
	                    return { solid: { color: 'red' } };
	                };
	                HelloIVisual.getSize = function (dataView) {
	                    if (dataView) {
	                        var objects = dataView.metadata.objects;
	                        if (objects) {
	                            var general = objects['general'];
	                            if (general) {
	                                var size = general['size'];
	                                if (size)
	                                    return size;
	                            }
	                        }
	                    }
	                    return 100;
	                };
	                HelloIVisual.prototype.enumerateObjectInstances = function (options) {
	                    var instances = [];
	                    var dataView = this.dataView;
	                    switch (options.objectName) {
	                        case 'general':
	                            var general = {
	                                objectName: 'general',
	                                displayName: 'General',
	                                selector: null,
	                                properties: {
	                                    fill: HelloIVisual.getFill(dataView),
	                                    size: HelloIVisual.getSize(dataView)
	                                }
	                            };
	                            instances.push(general);
	                            break;
	                    }
	                    return instances;
	                };
	                HelloIVisual.prototype.destroy = function () {
	                    this.root = null;
	                };
	                HelloIVisual.capabilities = {
	                    dataRoles: [{
	                            displayName: 'Values',
	                            name: 'Values',
	                            kind: powerbi.VisualDataRoleKind.GroupingOrMeasure
	                        }],
	                    dataViewMappings: [{
	                            table: {
	                                rows: {
	                                    for: { in: 'Values' },
	                                    dataReductionAlgorithm: { window: { count: 100 } }
	                                },
	                                rowCount: { preferred: { min: 1 } }
	                            },
	                        }],
	                    objects: {
	                        general: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
	                            properties: {
	                                fill: {
	                                    type: { fill: { solid: { color: true } } },
	                                    displayName: 'Fill'
	                                },
	                                size: {
	                                    type: { numeric: true },
	                                    displayName: 'Size'
	                                }
	                            },
	                        }
	                    },
	                };
	                HelloIVisual.DefaultText = 'Invalid DV';
	                return HelloIVisual;
	            }());
	            samples.HelloIVisual = HelloIVisual;
	        })(samples = visuals.samples || (visuals.samples = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 258 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        /**
	         * This module only supplies the capabilities for comboCharts.
	         * Implementation is in cartesianChart and the various ICartesianVisual implementations.
	         */
	        var ComboChart;
	        (function (ComboChart) {
	            ComboChart.capabilities = visuals.comboChartCapabilities;
	            /**
	             * Handles the case of a column layer in a combo chart. In this case, the column layer is enumearated last.
	             */
	            function enumerateDataPoints(enumeration, options, layers) {
	                if (!layers)
	                    return;
	                var columnChartLayerIndex;
	                var layersLength = layers.length;
	                for (var layerIndex = 0; layerIndex < layersLength; layerIndex++) {
	                    var layer = layers[layerIndex];
	                    if (layer.enumerateObjectInstances) {
	                        if (layer instanceof visuals.ColumnChart) {
	                            columnChartLayerIndex = layerIndex;
	                            continue;
	                        }
	                        layer.enumerateObjectInstances(enumeration, options);
	                    }
	                }
	                if (columnChartLayerIndex !== undefined)
	                    layers[columnChartLayerIndex].enumerateObjectInstances(enumeration, options);
	            }
	            ComboChart.enumerateDataPoints = enumerateDataPoints;
	            function customizeQuery(options) {
	                // If there is a dynamic series but no values on the column data view mapping, remove the dynamic series
	                var columnMapping = !_.isEmpty(options.dataViewMappings) && options.dataViewMappings[0];
	                if (columnMapping) {
	                    var columnValuesMapping = columnMapping.categorical && columnMapping.categorical.values;
	                    var seriesSelect = columnValuesMapping.group && !_.isEmpty(columnValuesMapping.group.select) && columnValuesMapping.group.select[0];
	                    if (_.isEmpty(seriesSelect.for.in.items))
	                        columnValuesMapping.group.by.items = undefined;
	                }
	                var isScalar = visuals.CartesianChart.detectScalarMapping(columnMapping);
	                if (columnMapping && columnMapping.categorical) {
	                    columnMapping.categorical.dataVolume = 4;
	                    if (isScalar) {
	                        var dataViewCategories = columnMapping.categorical.categories;
	                        dataViewCategories.dataReductionAlgorithm = { sample: {} };
	                        var values = columnMapping.categorical.values;
	                        if (values && values.group) {
	                            values.group.dataReductionAlgorithm = { top: {} };
	                        }
	                    }
	                }
	                var lineMapping = options.dataViewMappings.length > 1 && options.dataViewMappings[1];
	                if (lineMapping && lineMapping.categorical) {
	                    lineMapping.categorical.dataVolume = 4;
	                    if (isScalar) {
	                        var dataViewCategories = lineMapping.categorical.categories;
	                        dataViewCategories.dataReductionAlgorithm = { sample: {} };
	                        var values = lineMapping.categorical.values;
	                        if (values && values.group) {
	                            values.group.dataReductionAlgorithm = { top: {} };
	                        }
	                    }
	                }
	                if (!isScalar) {
	                    visuals.CartesianChart.expandCategoryWindow(options.dataViewMappings);
	                }
	            }
	            ComboChart.customizeQuery = customizeQuery;
	            function getSortableRoles(options) {
	                if (options && options.dataViewMappings.length > 0) {
	                    var dataViewMapping = options.dataViewMappings[0];
	                    //TODO: column chart should be sortable by X if it has scalar axis
	                    // But currenly it doesn't support this. Return 'category' once
	                    // it is supported.
	                    if (!visuals.CartesianChart.detectScalarMapping(dataViewMapping))
	                        return ['Category', 'Y', 'Y2'];
	                }
	                return null;
	            }
	            ComboChart.getSortableRoles = getSortableRoles;
	            function isComboChart(chartType) {
	                return chartType === 10 /* ComboChart */
	                    || chartType === 13 /* LineClusteredColumnCombo */
	                    || chartType === 14 /* LineStackedColumnCombo */
	                    || chartType === 15 /* DataDotClusteredColumnCombo */
	                    || chartType === 16 /* DataDotStackedColumnCombo */;
	            }
	            ComboChart.isComboChart = isComboChart;
	        })(ComboChart = visuals.ComboChart || (visuals.ComboChart = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 259 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="./_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var ArrayExtensions = jsCommon.ArrayExtensions;
	        var DataColorPalette = (function () {
	            /**
	             * Creates a DataColorPalette using the given theme, or the default theme.
	             */
	            function DataColorPalette(colors, sentimentcolors) {
	                // Hardcoded values for Color Picker.
	                this.basePickerColors = [
	                    { value: '#FFFFFF' },
	                    { value: '#000000' },
	                    { value: '#00B8AA' },
	                    { value: '#374649' },
	                    { value: '#FD625E' },
	                    { value: '#F2C811' },
	                    { value: '#5F6B6D' },
	                    { value: '#8AD4EB' },
	                    { value: '#FE9666' },
	                    { value: '#A66999' }
	                ];
	                // TODO: Default theme is currently hardcoded. Theme should eventually come from PV and be added as a parameter in the ctor. 
	                this.colors = colors || ThemeManager.getDefaultTheme();
	                this.sentimentColors = sentimentcolors || ThemeManager.defaultSentimentColors;
	                this.scales = {};
	            }
	            DataColorPalette.prototype.getColorScaleByKey = function (key) {
	                var scale = this.scales[key];
	                if (scale === undefined) {
	                    scale = this.createScale();
	                    this.scales[key] = scale;
	                }
	                return scale;
	            };
	            DataColorPalette.prototype.getNewColorScale = function () {
	                return this.createScale();
	            };
	            DataColorPalette.prototype.getColorByIndex = function (index) {
	                debug.assert(index >= 0 && index < this.colors.length, 'index is out of bounds');
	                return this.colors[index];
	            };
	            DataColorPalette.prototype.getSentimentColors = function () {
	                return this.sentimentColors;
	            };
	            DataColorPalette.prototype.getBasePickerColors = function () {
	                return this.basePickerColors;
	            };
	            DataColorPalette.prototype.getAllColors = function () {
	                return this.colors;
	            };
	            DataColorPalette.prototype.createScale = function () {
	                return D3ColorScale.createFromColors(this.colors);
	            };
	            return DataColorPalette;
	        }());
	        visuals.DataColorPalette = DataColorPalette;
	        var D3ColorScale = (function () {
	            function D3ColorScale(scale) {
	                this.scale = scale;
	            }
	            D3ColorScale.prototype.getColor = function (key) {
	                return this.scale(key);
	            };
	            D3ColorScale.prototype.clearAndRotateScale = function () {
	                var offset = this.scale.domain().length;
	                var rotatedColors = ArrayExtensions.rotate(this.scale.range(), offset);
	                this.scale = d3.scale.ordinal().range(rotatedColors);
	            };
	            D3ColorScale.prototype.clone = function () {
	                return new D3ColorScale(this.scale.copy());
	            };
	            D3ColorScale.prototype.getDomain = function () {
	                return this.scale.domain();
	            };
	            D3ColorScale.createFromColors = function (colors) {
	                return new D3ColorScale(d3.scale.ordinal().range(colors));
	            };
	            return D3ColorScale;
	        }());
	        visuals.D3ColorScale = D3ColorScale;
	        // TODO: When theming support is added, this should be changed into a fully fledged service. For now though we will
	        var ThemeManager = (function () {
	            function ThemeManager() {
	            }
	            ThemeManager.getDefaultTheme = function () {
	                if (!ThemeManager.defaultTheme) {
	                    // Extend the list of available colors by cycling the base colors
	                    ThemeManager.defaultTheme = [];
	                    var baseColors = ThemeManager.defaultBaseColors;
	                    for (var i = 0; i < ThemeManager.colorSectorCount; ++i) {
	                        for (var j = 0, jlen = baseColors.length; j < jlen; ++j) {
	                            ThemeManager.defaultTheme.push({
	                                value: jsCommon.Color.rotate(baseColors[j].value, i / ThemeManager.colorSectorCount)
	                            });
	                        }
	                    }
	                }
	                return ThemeManager.defaultTheme;
	            };
	            ThemeManager.colorSectorCount = 12;
	            // declare the Theme code as a private implementation detail inside the DataColorPalette so that the code stays hidden
	            // until it's ready for wider use.
	            ThemeManager.defaultBaseColors = [
	                // First loop
	                { value: '#01B8AA' },
	                { value: '#374649' },
	                { value: '#FD625E' },
	                { value: '#F2C80F' },
	                { value: '#5F6B6D' },
	                { value: '#8AD4EB' },
	                { value: '#FE9666' },
	                { value: '#A66999' },
	                { value: '#3599B8' },
	                { value: '#DFBFBF' },
	                // Second loop
	                { value: '#4AC5BB' },
	                { value: '#5F6B6D' },
	                { value: '#FB8281' },
	                { value: '#F4D25A' },
	                { value: '#7F898A' },
	                { value: '#A4DDEE' },
	                { value: '#FDAB89' },
	                { value: '#B687AC' },
	                { value: '#28738A' },
	                { value: '#A78F8F' },
	                // Third loop
	                { value: '#168980' },
	                { value: '#293537' },
	                { value: '#BB4A4A' },
	                { value: '#B59525' },
	                { value: '#475052' },
	                { value: '#6A9FB0' },
	                { value: '#BD7150' },
	                { value: '#7B4F71' },
	                { value: '#1B4D5C' },
	                { value: '#706060' },
	                // Fourth loop
	                { value: '#0F5C55' },
	                { value: '#1C2325' },
	                { value: '#7D3231' },
	                { value: '#796419' },
	                { value: '#303637' },
	                { value: '#476A75' },
	                { value: '#7E4B36' },
	                { value: '#52354C' },
	                { value: '#0D262E' },
	                { value: '#544848' },
	            ];
	            ThemeManager.defaultSentimentColors = [
	                { value: '#C0433A' },
	                { value: '#E8D62E' },
	                { value: '#79C75B' },
	            ];
	            return ThemeManager;
	        }());
	        visuals.ThemeManager = ThemeManager;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 260 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/**
	 * IMPORTANT: This chart is not currently enabled in the PBI system and is under development.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        /**
	         * The data dot chart shows a set of circles with the data value inside them.
	         * The circles are regularly spaced similar to column charts.
	         * The radius of all dots is the same across the chart.
	         * This is most often combined with a column chart to create the 'chicken pox' chart.
	         * If any of the data values do not fit within the circles, then the data values are hidden
	         * and the y axis for the dots is displayed instead.
	         * This chart only supports a single series of data.
	         * This chart does not display a legend.
	         */
	        var DataDotChart = (function () {
	            function DataDotChart(options) {
	                this.isScrollable = options.isScrollable;
	                this.interactivityService = options.interactivityService;
	            }
	            DataDotChart.prototype.init = function (options) {
	                this.options = options;
	                // Common properties
	                this.svg = options.svg;
	                this.svg.classed(DataDotChart.ClassName, true);
	                this.mainGraphicsG = this.svg.append('g')
	                    .classed('dataDotChartMainGraphicsContext', true);
	                this.mainGraphicsContext = this.mainGraphicsG.append('svg');
	                this.currentViewport = options.viewport;
	                this.hostService = options.host;
	                this.cartesianVisualHost = options.cartesianHost;
	                this.style = options.style;
	                this.colors = this.style.colorPalette.dataColors;
	                // Interactivity properties
	                this.interactivity = options.interactivity;
	                this.element = options.element;
	            };
	            DataDotChart.prototype.setData = function (dataViews) {
	                this.data = {
	                    series: {
	                        data: []
	                    },
	                    hasHighlights: false,
	                    hasDynamicSeries: false,
	                };
	                if (dataViews.length > 0) {
	                    // I only handle a single data view
	                    var dataView = dataViews[0];
	                    if (dataView && dataView.categorical) {
	                        var dataViewCategorical = this.dataViewCategorical = dataView.categorical;
	                        var dvCategories = dataViewCategorical.categories;
	                        // I default to text unless there is a category type
	                        var categoryType = powerbi.ValueType.fromDescriptor({ text: true });
	                        if (dvCategories && dvCategories.length > 0 && dvCategories[0].source && dvCategories[0].source.type)
	                            categoryType = dvCategories[0].source.type;
	                        this.data = DataDotChart.converter(dataView, visuals.valueFormatter.format(null), this.interactivityService);
	                    }
	                }
	            };
	            DataDotChart.prototype.setFilteredData = function (startIndex, endIndex) {
	                var data = this.clippedData = powerbi.Prototype.inherit(this.data);
	                if (data && data.series && data.series.data)
	                    data.series = { data: data.series.data.slice(startIndex, endIndex), xCol: data.series.xCol, yCol: data.series.yCol };
	                return data;
	            };
	            DataDotChart.prototype.calculateAxesProperties = function (options) {
	                var _this = this;
	                this.currentViewport = options.viewport;
	                this.margin = options.margin;
	                var data = this.clippedData = this.data;
	                var viewport = this.currentViewport;
	                var margin = this.margin;
	                var series = data ? data.series : null;
	                var seriesArray = series && series.data && series.data.length > 0 ? [series] : [];
	                var categoryCount = series && series.data ? series.data.length : 0;
	                // If there are highlights, then the series is 2x in length and highlights are interwoven.
	                if (data.hasHighlights) {
	                    categoryCount = categoryCount / 2;
	                }
	                var width = viewport.width - (margin.left + margin.right);
	                var height = viewport.height - (margin.top + margin.bottom);
	                var xMetaDataColumn;
	                var yMetaDataColumn;
	                if (DataDotChart.hasDataPoint(series)) {
	                    xMetaDataColumn = series.xCol;
	                    yMetaDataColumn = series.yCol;
	                }
	                var layout = visuals.CartesianChart.getLayout(null, {
	                    availableWidth: width,
	                    categoryCount: categoryCount,
	                    domain: null,
	                    isScalar: false,
	                    isScrollable: this.isScrollable,
	                    trimOrdinalDataOnOverflow: options.trimOrdinalDataOnOverflow
	                });
	                var outerPadding = layout.categoryThickness * visuals.CartesianChart.OuterPaddingRatio;
	                // clip data that won't fit
	                if (!this.isScrollable) {
	                    this.clippedData = DataDotChart.createClippedDataIfOverflowed(data, layout.categoryCount);
	                }
	                var yDomain = visuals.AxisHelper.createValueDomain(seriesArray, /*includeZero:*/ true) || visuals.emptyDomain;
	                var combinedDomain = visuals.AxisHelper.combineDomain(options.forcedYDomain, yDomain, options.ensureYDomain);
	                this.yAxisProperties = visuals.AxisHelper.createAxis({
	                    pixelSpan: height,
	                    dataDomain: combinedDomain,
	                    metaDataColumn: yMetaDataColumn,
	                    formatString: visuals.valueFormatter.getFormatString(yMetaDataColumn, DataDotChart.formatStringProp),
	                    outerPadding: 0,
	                    isScalar: true,
	                    isVertical: true,
	                    forcedTickCount: options.forcedTickCount,
	                    useTickIntervalForDisplayUnits: true,
	                    isCategoryAxis: false
	                });
	                var axisType = this.xAxisProperties ? this.xAxisProperties.axisType : powerbi.ValueType.fromDescriptor({ text: true });
	                var xDomain = visuals.AxisHelper.createDomain(seriesArray, axisType, /*isScalar:*/ false, options.forcedXDomain, options.ensureXDomain);
	                this.xAxisProperties = visuals.AxisHelper.createAxis({
	                    pixelSpan: width,
	                    dataDomain: xDomain,
	                    metaDataColumn: xMetaDataColumn,
	                    formatString: visuals.valueFormatter.getFormatString(xMetaDataColumn, DataDotChart.formatStringProp),
	                    outerPadding: outerPadding,
	                    isScalar: false,
	                    isVertical: false,
	                    forcedTickCount: options.forcedTickCount,
	                    useTickIntervalForDisplayUnits: true,
	                    categoryThickness: layout.categoryThickness,
	                    getValueFn: function (index, type) { return _this.lookupXValue(index, type); },
	                    isCategoryAxis: true
	                });
	                return [this.xAxisProperties, this.yAxisProperties];
	            };
	            DataDotChart.createClippedDataIfOverflowed = function (data, categoryCount) {
	                // If there are highlights, then the series is 2x in length and highlights are interwoven.
	                var requiredLength = data.hasHighlights ? Math.min(data.series.data.length, categoryCount * 2) : Math.min(data.series.data.length, categoryCount);
	                if (requiredLength >= data.series.data.length) {
	                    return data;
	                }
	                var clipped = powerbi.Prototype.inherit(data);
	                clipped.series = powerbi.Prototype.inherit(data.series); // This prevents clipped and data from sharing the series object
	                clipped.series.data = clipped.series.data.slice(0, requiredLength);
	                return clipped;
	            };
	            DataDotChart.hasDataPoint = function (series) {
	                return (series && series.data && series.data.length > 0);
	            };
	            DataDotChart.prototype.lookupXValue = function (index, type) {
	                var data = this.data;
	                var isDateTime = visuals.AxisHelper.isDateTime(type);
	                if (isDateTime)
	                    return new Date(index);
	                if (data && data.series) {
	                    var seriesData = data.series.data;
	                    if (seriesData) {
	                        var dataAtIndex = seriesData[index];
	                        if (dataAtIndex) {
	                            return dataAtIndex.categoryValue;
	                        }
	                    }
	                }
	                return index;
	            };
	            DataDotChart.prototype.overrideXScale = function (xProperties) {
	                this.xAxisProperties = xProperties;
	            };
	            DataDotChart.prototype.render = function (suppressAnimations) {
	                var _this = this;
	                if (!this.clippedData)
	                    return;
	                var data = this.clippedData;
	                var dataPoints = data.series.data;
	                var hasHighlights = data.hasHighlights;
	                var margin = this.margin;
	                var viewport = this.currentViewport;
	                var width = viewport.width - (margin.left + margin.right);
	                var height = viewport.height - (margin.top + margin.bottom);
	                var xScale = this.xAxisProperties.scale;
	                var yScale = this.yAxisProperties.scale;
	                var dotWidth = this.xAxisProperties.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
	                var dotRadius = dotWidth / 2;
	                var dotColor = this.cartesianVisualHost.getSharedColors().getNewColorScale().getColor(DataDotChart.DotColorKey);
	                var hasSelection = this.interactivityService ? this.interactivityService.hasSelection() : false;
	                this.mainGraphicsContext.attr('width', width)
	                    .attr('height', height);
	                var dots = this.mainGraphicsContext.selectAll(DataDotChart.DotClassSelector).data(dataPoints, function (d) { return d.identity.getKey(); });
	                dots.enter()
	                    .append('circle')
	                    .classed(DataDotChart.DotClassName, true);
	                dots
	                    .style({ 'fill': dotColor.value })
	                    .style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, hasHighlights); })
	                    .classed('null-value', function (d) { return d.value === null; })
	                    .attr({
	                    r: function (d) { return dotRadius; },
	                    cx: function (d) { return xScale(d.categoryIndex) + dotRadius; },
	                    cy: function (d) { return yScale(d.value); }
	                });
	                dots.exit().remove();
	                var dotLabels = this.mainGraphicsContext.selectAll(DataDotChart.DotLabelClassSelector).data(dataPoints, function (d) { return d.identity.getKey(); });
	                dotLabels.enter()
	                    .append('text')
	                    .classed(DataDotChart.DotLabelClassName, true)
	                    .attr({
	                    'text-anchor': DataDotChart.DotLabelTextAnchor,
	                    dy: DataDotChart.DotLabelVerticalOffset
	                });
	                dotLabels
	                    .classed('null-value', function (d) { return d.value === null; })
	                    .classed('overflowed', false)
	                    .attr({
	                    x: function (d) { return xScale(d.categoryIndex) + dotRadius; },
	                    y: function (d) { return yScale(d.value); }
	                })
	                    .text(function (d) { return _this.yAxisProperties.formatter.format(d.value); });
	                var overflowed = false;
	                dotLabels
	                    .each(function () {
	                    // jQuery fails to properly inspect SVG class elements, the $('<div>') notation works around it.
	                    if (!overflowed && !$("<div>").addClass($(this).attr("class")).hasClass("null-value")) {
	                        var width_1 = powerbi.TextMeasurementService.measureSvgTextElementWidth(this);
	                        if (width_1 > dotWidth) {
	                            dotLabels.classed('overflowed', true);
	                            overflowed = true;
	                        }
	                    }
	                });
	                dotLabels.exit().remove();
	                var behaviorOptions = undefined;
	                if (this.interactivityService) {
	                    behaviorOptions = {
	                        dots: dots,
	                        dotLabels: dotLabels,
	                        datapoints: dataPoints
	                    };
	                }
	                // This should always be the last line in the render code.
	                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
	                return { dataPoints: dataPoints, behaviorOptions: behaviorOptions, labelDataPoints: [], labelsAreNumeric: true };
	            };
	            DataDotChart.prototype.calculateLegend = function () {
	                return this.createLegendDataPoints(0); // start with index 0
	            };
	            DataDotChart.prototype.hasLegend = function () {
	                return this.data && this.data.hasDynamicSeries;
	            };
	            DataDotChart.prototype.createLegendDataPoints = function (columnIndex) {
	                var data = this.data;
	                if (!data)
	                    return null;
	                var series = data.series;
	                var seriesData = series.data;
	                var legendDataPoints = [];
	                var category;
	                var axisType = this.xAxisProperties ? this.xAxisProperties.axisType : powerbi.ValueType.fromDescriptor({ text: true });
	                // Category will be the same for all series. This is an optimization.
	                if (data.series && data.series.data) {
	                    var firstDataPoint = data.series.data[0];
	                    category = firstDataPoint && this.lookupXValue(firstDataPoint.categoryValue, axisType);
	                }
	                // Create a legend data point for the specified column                
	                if (series.yCol) {
	                    var formatStringProp = DataDotChart.formatStringProp;
	                    var lineDataPoint = seriesData[columnIndex];
	                    var measure = lineDataPoint && lineDataPoint.value;
	                    var label = visuals.converterHelper.getFormattedLegendLabel(series.yCol, this.dataViewCategorical.values, formatStringProp);
	                    var dotColor = this.cartesianVisualHost.getSharedColors().getNewColorScale().getColor(DataDotChart.DotColorKey);
	                    var dataViewCategoricalValues = this.dataViewCategorical.values;
	                    var identity = dataViewCategoricalValues && dataViewCategoricalValues.length > columnIndex ?
	                        visuals.SelectionId.createWithIdAndMeasure(dataViewCategoricalValues[columnIndex].identity, dataViewCategoricalValues[columnIndex].source.queryName) :
	                        visuals.SelectionId.createWithMeasure(dataViewCategoricalValues.source.queryName);
	                    legendDataPoints.push({
	                        color: dotColor.value,
	                        icon: visuals.LegendIcon.Line,
	                        label: label,
	                        category: visuals.valueFormatter.format(category, visuals.valueFormatter.getFormatString(series.xCol, formatStringProp)),
	                        measure: visuals.valueFormatter.format(measure, visuals.valueFormatter.getFormatString(series.yCol, formatStringProp)),
	                        identity: identity,
	                        selected: false
	                    });
	                }
	                return { dataPoints: legendDataPoints };
	            };
	            DataDotChart.prototype.onClearSelection = function () {
	                if (this.interactivityService)
	                    this.interactivityService.clearSelection();
	                // cartesianChart handles calling render again.
	            };
	            DataDotChart.converter = function (dataView, blankCategoryValue, interactivityService) {
	                var categorical = dataView.categorical;
	                var category = categorical.categories && categorical.categories.length > 0
	                    ? categorical.categories[0]
	                    : {
	                        source: undefined,
	                        values: [blankCategoryValue],
	                        identity: undefined
	                    };
	                var categoryType = visuals.AxisHelper.getCategoryValueType(category.source);
	                var isDateTime = visuals.AxisHelper.isDateTime(categoryType);
	                var categoryValues = category.values;
	                // I only handle a single series
	                if (!_.isEmpty(categorical.values)) {
	                    var measure = categorical.values[0];
	                    var hasHighlights = !!measure.highlights;
	                    var dataPoints = [];
	                    for (var categoryIndex = 0, len = measure.values.length; categoryIndex < len; categoryIndex++) {
	                        debug.assert(!category.identity || categoryIndex < category.identity.length, 'Category identities is smaller than category values.');
	                        // I create the identity from the category.  If there is no category, then I use the measure name to create identity
	                        var idBuilder = new visuals.SelectionIdBuilder();
	                        if (category.identity) {
	                            idBuilder = idBuilder.withCategory(category, categoryIndex);
	                        }
	                        var identity = idBuilder
	                            .withMeasure(measure.source.queryName)
	                            .createSelectionId();
	                        var categoryValue = categoryValues[categoryIndex];
	                        // ignore variant measures
	                        if (isDateTime && categoryValue != null && !(categoryValue instanceof Date))
	                            continue;
	                        dataPoints.push({
	                            categoryValue: isDateTime && categoryValue ? categoryValue.getTime() : categoryValue,
	                            value: measure.values[categoryIndex],
	                            categoryIndex: categoryIndex,
	                            seriesIndex: 0,
	                            selected: false,
	                            identity: identity,
	                            highlight: false
	                        });
	                        if (hasHighlights) {
	                            var highlightIdentity = visuals.SelectionId.createWithHighlight(identity);
	                            var highlightValue = measure.highlights[categoryIndex];
	                            dataPoints.push({
	                                categoryValue: isDateTime && categoryValue ? categoryValue.getTime() : categoryValue,
	                                value: highlightValue,
	                                categoryIndex: categoryIndex,
	                                seriesIndex: 0,
	                                selected: false,
	                                identity: highlightIdentity,
	                                highlight: true
	                            });
	                        }
	                    }
	                    if (interactivityService)
	                        interactivityService.applySelectionStateToData(dataPoints);
	                    return {
	                        series: {
	                            xCol: category.source,
	                            yCol: measure.source,
	                            data: dataPoints
	                        },
	                        hasHighlights: hasHighlights,
	                        hasDynamicSeries: true,
	                    };
	                }
	                return {
	                    series: {
	                        data: []
	                    },
	                    hasHighlights: false,
	                    hasDynamicSeries: false,
	                };
	            };
	            DataDotChart.formatStringProp = { objectName: 'general', propertyName: 'formatString' };
	            DataDotChart.ClassName = 'dataDotChart';
	            DataDotChart.DotClassName = 'dot';
	            DataDotChart.DotClassSelector = '.dot';
	            DataDotChart.DotColorKey = 'dataDot';
	            DataDotChart.DotLabelClassName = 'label';
	            DataDotChart.DotLabelClassSelector = '.label';
	            DataDotChart.DotLabelVerticalOffset = '0.4em';
	            DataDotChart.DotLabelTextAnchor = 'middle';
	            return DataDotChart;
	        }());
	        visuals.DataDotChart = DataDotChart;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 261 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
	        var PixelConverter = jsCommon.PixelConverter;
	        var LabelUtils = visuals.NewDataLabelUtils;
	        /**
	         * Renders a funnel chart.
	         */
	        var FunnelChart = (function () {
	            function FunnelChart(options) {
	                this.labelPositionObjects = [visuals.labelPosition.outsideEnd, visuals.labelPosition.insideCenter];
	                if (options) {
	                    this.tooltipsEnabled = options.tooltipsEnabled;
	                    this.tooltipBucketEnabled = options.tooltipBucketEnabled;
	                    if (options.funnelSmallViewPortProperties) {
	                        this.funnelSmallViewPortProperties = options.funnelSmallViewPortProperties;
	                    }
	                    if (options.animator) {
	                        this.animator = options.animator;
	                    }
	                    if (options.behavior) {
	                        this.behavior = options.behavior;
	                    }
	                }
	            }
	            FunnelChart.converter = function (dataView, colors, hostServices, defaultDataPointColor, tooltipsEnabled, tooltipBucketEnabled) {
	                if (tooltipsEnabled === void 0) { tooltipsEnabled = true; }
	                var reader = powerbi.data.createIDataViewCategoricalReader(dataView);
	                var dataPoints = [];
	                var formatStringProp = visuals.funnelChartProps.general.formatString;
	                var categorical = dataView.categorical;
	                var hasHighlights = reader.hasHighlights("Y");
	                var valueMetaData = [];
	                for (var seriesIndex = 0, seriesCount = reader.getSeriesCount("Y"); seriesIndex < seriesCount; seriesIndex++) {
	                    valueMetaData.push(reader.getValueMetadataColumn("Y", seriesIndex));
	                }
	                var highlightsOverflow = false;
	                var hasNegativeValues = false;
	                var allValuesAreNegative = false;
	                var categoryLabels = [];
	                var dataLabelsSettings = this.getDefaultLabelSettings();
	                var percentBarLabelSettings = this.getDefaultPercentLabelSettings();
	                var colorHelper = new visuals.ColorHelper(colors, visuals.funnelChartProps.dataPoint.fill, defaultDataPointColor);
	                var firstValue;
	                var firstHighlight;
	                var previousValue;
	                var previousHighlight;
	                var gradientValueColumn = visuals.GradientUtils.getGradientValueColumn(categorical);
	                if (dataView && dataView.metadata && dataView.metadata.objects) {
	                    var labelsObj = dataView.metadata.objects['labels'];
	                    if (labelsObj)
	                        visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, dataLabelsSettings);
	                    var percentLabelsObj = dataView.metadata.objects['percentBarLabel'];
	                    if (percentLabelsObj)
	                        visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(percentLabelsObj, percentBarLabelSettings);
	                }
	                // If we don't have a valid value column, just return
	                if (!reader.hasValues("Y"))
	                    return {
	                        dataPoints: dataPoints,
	                        categoryLabels: categoryLabels,
	                        valuesMetadata: valueMetaData,
	                        hasHighlights: hasHighlights,
	                        highlightsOverflow: highlightsOverflow,
	                        canShowDataLabels: true,
	                        dataLabelsSettings: dataLabelsSettings,
	                        hasNegativeValues: hasNegativeValues,
	                        allValuesAreNegative: allValuesAreNegative,
	                        percentBarLabelSettings: percentBarLabelSettings,
	                    };
	                // Calculate the first value for percent tooltip values
	                firstValue = reader.getValue("Y", 0, 0);
	                if (hasHighlights) {
	                    firstHighlight = reader.getHighlight("Y", 0, 0);
	                }
	                var pctFormatString = visuals.valueFormatter.getLocalizedString('Percentage');
	                if (reader.hasCategories()) {
	                    // Funnel chart with categories
	                    for (var categoryIndex = 0, categoryCount = reader.getCategoryCount(); categoryIndex < categoryCount; categoryIndex++) {
	                        var categoryColumn = reader.getCategoryColumn("Category");
	                        var categoryValue = reader.getCategoryValue("Category", categoryIndex);
	                        var valueMetadataColumn = reader.getValueMetadataColumn("Y");
	                        var identity = visuals.SelectionIdBuilder.builder()
	                            .withCategory(categoryColumn, categoryIndex)
	                            .withMeasure(valueMetadataColumn.queryName)
	                            .createSelectionId();
	                        var value = reader.getValue("Y", categoryIndex);
	                        var formattedCategoryValue = visuals.converterHelper.formatFromMetadataColumn(categoryValue, categoryColumn.source, formatStringProp);
	                        var tooltipInfo = void 0;
	                        if (tooltipsEnabled) {
	                            tooltipInfo = [];
	                            tooltipInfo.push({
	                                displayName: categoryColumn.source.displayName,
	                                value: formattedCategoryValue,
	                            });
	                            if (value != null) {
	                                tooltipInfo.push({
	                                    displayName: valueMetadataColumn.displayName,
	                                    value: visuals.converterHelper.formatFromMetadataColumn(value, valueMetadataColumn, formatStringProp),
	                                });
	                            }
	                            var highlightValue = void 0;
	                            if (hasHighlights) {
	                                highlightValue = reader.getHighlight("Y", categoryIndex);
	                                if (highlightValue != null) {
	                                    tooltipInfo.push({
	                                        displayName: visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName,
	                                        value: visuals.converterHelper.formatFromMetadataColumn(highlightValue, valueMetadataColumn, formatStringProp),
	                                    });
	                                }
	                            }
	                            var gradientColumnMetadata = gradientValueColumn ? gradientValueColumn.source : undefined;
	                            if (gradientColumnMetadata && gradientColumnMetadata !== valueMetadataColumn && gradientValueColumn.values[categoryIndex] != null) {
	                                tooltipInfo.push({
	                                    displayName: gradientColumnMetadata.displayName,
	                                    value: visuals.converterHelper.formatFromMetadataColumn(reader.getValue("Gradient", categoryIndex), gradientColumnMetadata, formatStringProp),
	                                });
	                            }
	                            if (hasHighlights) {
	                                FunnelChart.addFunnelPercentsToTooltip(pctFormatString, tooltipInfo, hostServices, firstHighlight ? highlightValue / firstHighlight : null, previousHighlight ? highlightValue / previousHighlight : null, true);
	                            }
	                            else {
	                                FunnelChart.addFunnelPercentsToTooltip(pctFormatString, tooltipInfo, hostServices, firstValue ? value / firstValue : null, previousValue ? value / previousValue : null);
	                            }
	                            if (tooltipBucketEnabled) {
	                                visuals.TooltipBuilder.addTooltipBucketItem(reader, tooltipInfo, categoryIndex);
	                            }
	                        }
	                        // Same color for all bars
	                        var color = colorHelper.getColorForMeasure(reader.getCategoryObjects("Category", categoryIndex), '');
	                        dataPoints.push({
	                            label: formattedCategoryValue,
	                            value: value,
	                            originalValue: value,
	                            categoryOrMeasureIndex: categoryIndex,
	                            identity: identity,
	                            selected: false,
	                            key: identity.getKey(),
	                            tooltipInfo: tooltipInfo,
	                            color: color,
	                            labelFill: dataLabelsSettings.labelColor,
	                        });
	                        if (hasHighlights) {
	                            var highlightIdentity = visuals.SelectionId.createWithHighlight(identity);
	                            var highlightValue = reader.getHighlight("Y", categoryIndex);
	                            dataPoints.push({
	                                label: formattedCategoryValue,
	                                value: value,
	                                originalValue: value,
	                                categoryOrMeasureIndex: categoryIndex,
	                                identity: highlightIdentity,
	                                selected: false,
	                                key: highlightIdentity.getKey(),
	                                highlight: true,
	                                highlightValue: highlightValue,
	                                originalHighlightValue: highlightValue,
	                                tooltipInfo: tooltipInfo,
	                                color: color,
	                            });
	                            previousHighlight = highlightValue;
	                        }
	                        previousValue = value;
	                    }
	                }
	                else {
	                    // Non-categorical static series
	                    var categoryIndex = 0; // For non-categorical data, we use categoryIndex = 0
	                    for (var seriesIndex = 0, seriesCount = reader.getSeriesCount("Y"); seriesIndex < seriesCount; seriesIndex++) {
	                        var value = reader.getValue("Y", categoryIndex, seriesIndex);
	                        var valueMetadataColumn = reader.getValueMetadataColumn("Y", seriesIndex);
	                        var identity = visuals.SelectionId.createWithMeasure(valueMetadataColumn.queryName);
	                        var tooltipInfo = void 0;
	                        // Same color for all bars
	                        var color = colorHelper.getColorForMeasure(valueMetadataColumn.objects, '');
	                        if (tooltipsEnabled) {
	                            tooltipInfo = [];
	                            if (value != null) {
	                                tooltipInfo.push({
	                                    displayName: valueMetadataColumn.displayName,
	                                    value: visuals.converterHelper.formatFromMetadataColumn(value, valueMetadataColumn, formatStringProp),
	                                });
	                            }
	                            if (hasHighlights) {
	                                var highlightValue = reader.getHighlight("Y", categoryIndex, seriesIndex);
	                                if (highlightValue != null) {
	                                    tooltipInfo.push({
	                                        displayName: visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName,
	                                        value: visuals.converterHelper.formatFromMetadataColumn(highlightValue, valueMetadataColumn, formatStringProp),
	                                    });
	                                }
	                                FunnelChart.addFunnelPercentsToTooltip(pctFormatString, tooltipInfo, hostServices, firstHighlight ? highlightValue / firstHighlight : null, previousHighlight ? highlightValue / previousHighlight : null, true);
	                            }
	                            else {
	                                FunnelChart.addFunnelPercentsToTooltip(pctFormatString, tooltipInfo, hostServices, firstValue ? value / firstValue : null, previousValue ? value / previousValue : null);
	                            }
	                            if (tooltipBucketEnabled) {
	                                var tooltipValues = reader.getAllValuesForRole("Tooltips", categoryIndex, undefined);
	                                var tooltipMetadataColumns = reader.getAllValueMetadataColumnsForRole("Tooltips", undefined);
	                                if (tooltipValues && tooltipMetadataColumns) {
	                                    for (var j = 0; j < tooltipValues.length; j++) {
	                                        if (tooltipValues[j] != null) {
	                                            tooltipInfo.push({
	                                                displayName: tooltipMetadataColumns[j].displayName,
	                                                value: visuals.converterHelper.formatFromMetadataColumn(tooltipValues[j], tooltipMetadataColumns[j], formatStringProp),
	                                            });
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                        dataPoints.push({
	                            label: valueMetadataColumn.displayName,
	                            value: value,
	                            originalValue: value,
	                            categoryOrMeasureIndex: seriesIndex,
	                            identity: identity,
	                            selected: false,
	                            key: identity.getKey(),
	                            tooltipInfo: tooltipInfo,
	                            color: color,
	                            labelFill: dataLabelsSettings.labelColor,
	                        });
	                        if (hasHighlights) {
	                            var highlightIdentity = visuals.SelectionId.createWithHighlight(identity);
	                            var highlight = reader.getHighlight("Y", categoryIndex, seriesIndex);
	                            dataPoints.push({
	                                label: valueMetadataColumn.displayName,
	                                value: value,
	                                originalValue: value,
	                                categoryOrMeasureIndex: seriesIndex,
	                                identity: highlightIdentity,
	                                key: highlightIdentity.getKey(),
	                                selected: false,
	                                highlight: true,
	                                originalHighlightValue: highlight,
	                                highlightValue: highlight,
	                                tooltipInfo: tooltipInfo,
	                                color: color,
	                            });
	                            previousHighlight = highlight;
	                        }
	                        previousValue = value;
	                    }
	                }
	                for (var i = 0; i < dataPoints.length; i += hasHighlights ? 2 : 1) {
	                    var dataPoint = dataPoints[i];
	                    categoryLabels.push(dataPoint.label);
	                }
	                // Calculate negative value warning flags
	                allValuesAreNegative = dataPoints.length > 0 && _.every(dataPoints, function (dataPoint) { return (dataPoint.highlight ? dataPoint.highlightValue <= 0 : true) && dataPoint.value < 0; });
	                for (var _i = 0, dataPoints_1 = dataPoints; _i < dataPoints_1.length; _i++) {
	                    var dataPoint = dataPoints_1[_i];
	                    if (allValuesAreNegative) {
	                        dataPoint.value = Math.abs(dataPoint.value);
	                        if (dataPoint.highlight)
	                            dataPoint.highlightValue = Math.abs(dataPoint.highlightValue);
	                    }
	                    else {
	                        var value = dataPoint.value;
	                        var isValueNegative = value < 0;
	                        if (isValueNegative)
	                            dataPoint.value = 0;
	                        var isHighlightValueNegative = false;
	                        if (dataPoint.highlight) {
	                            var highlightValue = dataPoint.highlightValue;
	                            isHighlightValueNegative = highlightValue < 0;
	                            dataPoint.highlightValue = isHighlightValueNegative ? 0 : highlightValue;
	                        }
	                        if (!hasNegativeValues)
	                            hasNegativeValues = isValueNegative || isHighlightValueNegative;
	                    }
	                    if (dataPoint.highlightValue > dataPoint.value) {
	                        highlightsOverflow = true;
	                    }
	                }
	                return {
	                    dataPoints: dataPoints,
	                    categoryLabels: categoryLabels,
	                    valuesMetadata: valueMetaData,
	                    hasHighlights: hasHighlights,
	                    highlightsOverflow: highlightsOverflow,
	                    canShowDataLabels: true,
	                    dataLabelsSettings: dataLabelsSettings,
	                    hasNegativeValues: hasNegativeValues,
	                    allValuesAreNegative: allValuesAreNegative,
	                    percentBarLabelSettings: percentBarLabelSettings,
	                };
	            };
	            FunnelChart.prototype.enumerateObjectInstances = function (options) {
	                var enumeration = new visuals.ObjectEnumerationBuilder();
	                switch (options.objectName) {
	                    case 'dataPoint':
	                        var dataViewCat = this.dataViews && this.dataViews.length > 0 && this.dataViews[0] && this.dataViews[0].categorical;
	                        var hasGradientRole = visuals.GradientUtils.hasGradientRole(dataViewCat);
	                        if (!hasGradientRole) {
	                            this.enumerateDataPoints(enumeration);
	                        }
	                        break;
	                    case 'labels':
	                        var labelSettingsOptions = FunnelChart.getLabelSettingsOptions(enumeration, this.data.dataLabelsSettings, true, this.labelPositionObjects);
	                        visuals.dataLabelUtils.enumerateDataLabels(labelSettingsOptions);
	                        break;
	                    case 'percentBarLabel':
	                        var percentLabelSettingOptions = FunnelChart.getLabelSettingsOptions(enumeration, this.data.percentBarLabelSettings, false);
	                        visuals.dataLabelUtils.enumerateDataLabels(percentLabelSettingOptions);
	                        break;
	                }
	                return enumeration.complete();
	            };
	            FunnelChart.getLabelSettingsOptions = function (enumeration, labelSettings, isDataLabels, positionObject) {
	                return {
	                    enumeration: enumeration,
	                    dataLabelsSettings: labelSettings,
	                    show: true,
	                    displayUnits: isDataLabels,
	                    precision: isDataLabels,
	                    position: isDataLabels,
	                    positionObject: positionObject,
	                    fontSize: true,
	                };
	            };
	            FunnelChart.prototype.enumerateDataPoints = function (enumeration) {
	                var data = this.data;
	                if (!data)
	                    return;
	                var dataPoints = data.dataPoints;
	                enumeration.pushInstance({
	                    objectName: 'dataPoint',
	                    selector: null,
	                    properties: {
	                        defaultColor: { solid: { color: this.defaultDataPointColor || this.colors.getColorByIndex(0).value } }
	                    },
	                });
	                for (var i = 0; i < dataPoints.length; i++) {
	                    var dataPont = dataPoints[i];
	                    if (dataPont.highlight)
	                        continue;
	                    var color = dataPont.color;
	                    var selector = dataPont.identity.getSelector();
	                    var isSingleSeries = !!selector.data;
	                    enumeration.pushInstance({
	                        objectName: 'dataPoint',
	                        displayName: dataPont.label,
	                        selector: visuals.ColorHelper.normalizeSelector(selector, isSingleSeries),
	                        properties: {
	                            fill: { solid: { color: color } }
	                        },
	                    });
	                }
	            };
	            FunnelChart.prototype.init = function (options) {
	                this.options = options;
	                var element = options.element;
	                var svg = this.svg = d3.select(element.get(0))
	                    .append('svg')
	                    .classed(FunnelChart.VisualClassName, true);
	                if (this.behavior)
	                    this.clearCatcher = visuals.appendClearCatcher(this.svg);
	                this.currentViewport = options.viewport;
	                this.margin = {
	                    left: 5,
	                    right: 5,
	                    top: 0,
	                    bottom: 0
	                };
	                var style = options.style;
	                this.colors = style.colorPalette.dataColors;
	                this.hostServices = options.host;
	                if (this.behavior) {
	                    this.interactivityService = visuals.createInteractivityService(this.hostServices);
	                }
	                this.percentGraphicsContext = svg.append('g').classed(FunnelChart.Selectors.percentBar.root.class, true);
	                this.funnelGraphicsContext = svg.append('g');
	                this.axisGraphicsContext = svg.append('g');
	                this.labelGraphicsContext = svg
	                    .append("g")
	                    .classed(LabelUtils.labelGraphicsContextClass.class, true);
	                this.updateViewportProperties();
	            };
	            FunnelChart.prototype.updateViewportProperties = function () {
	                var viewport = this.currentViewport;
	                this.svg.attr('width', viewport.width)
	                    .attr('height', viewport.height);
	            };
	            FunnelChart.prototype.update = function (options) {
	                debug.assertValue(options, 'options');
	                this.data = {
	                    dataPoints: [],
	                    categoryLabels: [],
	                    valuesMetadata: [],
	                    hasHighlights: false,
	                    highlightsOverflow: false,
	                    canShowDataLabels: true,
	                    dataLabelsSettings: visuals.dataLabelUtils.getDefaultLabelSettings(),
	                    hasNegativeValues: false,
	                    allValuesAreNegative: false,
	                    percentBarLabelSettings: visuals.dataLabelUtils.getDefaultLabelSettings(true),
	                };
	                var dataViews = this.dataViews = options.dataViews;
	                this.currentViewport = options.viewport;
	                if (dataViews && dataViews.length > 0) {
	                    var dataView = dataViews[0];
	                    if (dataView.metadata && dataView.metadata.objects) {
	                        var defaultColor = powerbi.DataViewObjects.getFillColor(dataView.metadata.objects, visuals.funnelChartProps.dataPoint.defaultColor);
	                        if (defaultColor)
	                            this.defaultDataPointColor = defaultColor;
	                    }
	                    if (dataView.categorical) {
	                        this.data = FunnelChart.converter(dataView, this.colors, this.hostServices, this.defaultDataPointColor, this.tooltipsEnabled, this.tooltipBucketEnabled);
	                        if (this.interactivityService) {
	                            this.interactivityService.applySelectionStateToData(this.data.dataPoints);
	                        }
	                    }
	                    var warnings = visuals.getInvalidValueWarnings(dataViews, false /*supportsNaN*/, false /*supportsNegativeInfinity*/, false /*supportsPositiveInfinity*/);
	                    if (this.data.allValuesAreNegative) {
	                        warnings.push(new visuals.AllNegativeValuesWarning());
	                    }
	                    else if (this.data.hasNegativeValues) {
	                        warnings.push(new visuals.NegativeValuesNotSupportedWarning());
	                    }
	                    this.hostServices.setWarnings(warnings);
	                }
	                this.updateViewportProperties();
	                this.updateInternal(options.suppressAnimations);
	            };
	            // TODO: Remove onDataChanged & onResizing once all visuals have implemented update.
	            FunnelChart.prototype.onDataChanged = function (options) {
	                this.update({
	                    dataViews: options.dataViews,
	                    suppressAnimations: options.suppressAnimations,
	                    viewport: this.currentViewport
	                });
	            };
	            // TODO: Remove onDataChanged & onResizing once all visuals have implemented update.
	            FunnelChart.prototype.onResizing = function (viewport) {
	                this.currentViewport = viewport;
	                this.update({
	                    dataViews: this.dataViews,
	                    suppressAnimations: true,
	                    viewport: this.currentViewport
	                });
	            };
	            FunnelChart.prototype.getMaxLabelLength = function (labels, properties) {
	                var max = 0;
	                var textMeasurer = powerbi.TextMeasurementService.measureSvgTextWidth;
	                for (var i = 0, len = labels.length; i < len; i++) {
	                    properties.text = labels[i];
	                    max = Math.max(max, textMeasurer(properties));
	                }
	                return max + FunnelChart.LabelFunnelPadding;
	            };
	            FunnelChart.prototype.updateInternal = function (suppressAnimations) {
	                if (this.data == null)
	                    return;
	                var data = this.data;
	                var dataPoints = data.dataPoints;
	                var dataPointsWithoutHighlights = dataPoints.filter(function (d) { return !d.highlight; });
	                var isHidingPercentBars = this.isHidingPercentBars();
	                var axisOptions = this.setUpAxis();
	                var margin = axisOptions.margin;
	                var funnelContext = this.funnelGraphicsContext.attr('transform', visuals.SVGUtil.translate(margin.left, margin.top));
	                var labelContext = this.labelGraphicsContext.attr('transform', visuals.SVGUtil.translate(margin.left, margin.top));
	                this.percentGraphicsContext.attr('transform', visuals.SVGUtil.translate(margin.left, margin.top));
	                this.svg.style('font-family', visuals.dataLabelUtils.StandardFontFamily);
	                var layout = FunnelChart.getLayout(data, axisOptions);
	                var labels = this.getLabels(layout);
	                var result;
	                var shapes;
	                if (this.animator && !suppressAnimations) {
	                    var animationOptions = {
	                        viewModel: data,
	                        interactivityService: this.interactivityService,
	                        layout: layout,
	                        axisGraphicsContext: this.axisGraphicsContext,
	                        shapeGraphicsContext: funnelContext,
	                        percentGraphicsContext: this.percentGraphicsContext,
	                        labelGraphicsContext: this.labelGraphicsContext,
	                        axisOptions: axisOptions,
	                        dataPointsWithoutHighlights: dataPointsWithoutHighlights,
	                        labelLayout: labels,
	                        isHidingPercentBars: isHidingPercentBars,
	                        visualInitOptions: this.options,
	                    };
	                    result = this.animator.animate(animationOptions);
	                    shapes = result.shapes;
	                }
	                if (!this.animator || suppressAnimations || result.failed) {
	                    FunnelChart.drawDefaultAxis(this.axisGraphicsContext, axisOptions, isHidingPercentBars);
	                    shapes = FunnelChart.drawDefaultShapes(data, dataPoints, funnelContext, layout, this.interactivityService && this.interactivityService.hasSelection());
	                    FunnelChart.drawPercentBars(data, this.percentGraphicsContext, layout, isHidingPercentBars);
	                    LabelUtils.drawDefaultLabels(labelContext, labels, false);
	                }
	                if (this.interactivityService) {
	                    var interactors = FunnelChart.drawInteractorShapes(dataPoints, funnelContext, layout);
	                    var behaviorOptions = {
	                        bars: shapes,
	                        interactors: interactors,
	                        clearCatcher: this.clearCatcher,
	                        hasHighlights: data.hasHighlights,
	                    };
	                    this.interactivityService.bind(dataPoints, this.behavior, behaviorOptions);
	                    if (this.tooltipsEnabled) {
	                        visuals.TooltipManager.addTooltip(interactors, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
	                    }
	                }
	                if (this.tooltipsEnabled) {
	                    visuals.TooltipManager.addTooltip(shapes, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
	                }
	                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
	            };
	            FunnelChart.prototype.getUsableVerticalSpace = function () {
	                var categoryLabels = this.data.categoryLabels;
	                var margin = this.margin;
	                var verticalSpace = this.currentViewport.height - (margin.top + margin.bottom);
	                return verticalSpace - (FunnelChart.MinBarThickness * categoryLabels.length);
	            };
	            FunnelChart.prototype.isHidingPercentBars = function () {
	                var data = this.data;
	                if (data.percentBarLabelSettings.show) {
	                    var percentBarTextHeight = this.getPercentBarTextHeight();
	                    var verticalSpace = this.getUsableVerticalSpace() - (2 * FunnelChart.MinBarThickness * FunnelChart.PercentBarToBarRatio) - (2 * percentBarTextHeight);
	                    return verticalSpace <= 0;
	                }
	                return true;
	            };
	            FunnelChart.prototype.isSparklines = function () {
	                return this.getUsableVerticalSpace() <= 0;
	            };
	            FunnelChart.prototype.setUpAxis = function () {
	                var data = this.data;
	                var dataPoints = data.dataPoints;
	                var categoryLabels = data.categoryLabels;
	                var viewport = this.currentViewport;
	                var margin = this.margin;
	                var isSparklines = this.isSparklines();
	                var isHidingPercentBars = this.isHidingPercentBars();
	                var percentBarTextHeight = isHidingPercentBars ? 0 : this.getPercentBarTextHeight();
	                var verticalRange = viewport.height - (margin.top + margin.bottom) - (2 * percentBarTextHeight);
	                var maxMarginFactor = FunnelChart.MaxMarginFactor;
	                if (categoryLabels.length > 0 && isSparklines) {
	                    categoryLabels = [];
	                    data.canShowDataLabels = false;
	                }
	                else if (this.showCategoryLabels()) {
	                    var textProperties = FunnelChart.getTextProperties();
	                    // Get the amount of space needed for the labels, then add the minimum level of padding for the axis.
	                    var longestLabelLength = this.getMaxLabelLength(categoryLabels, textProperties);
	                    var maxLabelLength = viewport.width * maxMarginFactor;
	                    var labelLength = Math.min(longestLabelLength, maxLabelLength);
	                    margin.left = labelLength + FunnelChart.YAxisPadding;
	                }
	                else {
	                    categoryLabels = [];
	                }
	                var horizontalRange = viewport.width - (margin.left + margin.right);
	                var barToSpaceRatio = FunnelChart.BarToSpaceRatio;
	                var maxScore = d3.max(dataPoints.map(function (d) { return d.value; }));
	                if (data.hasHighlights) {
	                    var maxHighlight = d3.max(dataPoints.map(function (d) { return d.highlightValue; }));
	                    maxScore = d3.max([maxScore, maxHighlight]);
	                }
	                var minScore = 0;
	                var rangeStart = 0;
	                var rangeEnd = verticalRange;
	                var delta;
	                if (isHidingPercentBars)
	                    delta = verticalRange - (categoryLabels.length * FunnelChart.MaxBarHeight);
	                else
	                    delta = verticalRange - (categoryLabels.length * FunnelChart.MaxBarHeight) - (2 * FunnelChart.MaxBarHeight * FunnelChart.PercentBarToBarRatio);
	                if (categoryLabels.length > 0 && delta > 0) {
	                    rangeStart = Math.ceil(delta / 2);
	                    rangeEnd = Math.ceil(verticalRange - delta / 2);
	                }
	                // Offset funnel axis start and end by percent bar text height
	                if (!isHidingPercentBars) {
	                    rangeStart += percentBarTextHeight;
	                    rangeEnd += percentBarTextHeight;
	                }
	                var valueScale = d3.scale.linear()
	                    .domain([minScore, maxScore])
	                    .range([horizontalRange, 0]);
	                var categoryScale = d3.scale.ordinal()
	                    .domain(d3.range(0, data.categoryLabels.length))
	                    .rangeBands([rangeStart, rangeEnd], barToSpaceRatio, isHidingPercentBars ? barToSpaceRatio : FunnelChart.PercentBarToBarRatio);
	                return {
	                    margin: margin,
	                    valueScale: valueScale,
	                    categoryScale: categoryScale,
	                    maxScore: maxScore,
	                    maxWidth: horizontalRange,
	                    rangeStart: rangeStart,
	                    rangeEnd: rangeEnd,
	                    barToSpaceRatio: barToSpaceRatio,
	                    categoryLabels: categoryLabels,
	                };
	            };
	            FunnelChart.prototype.getPercentBarTextHeight = function () {
	                var percentBarTextProperties = FunnelChart.getTextProperties(this.data.percentBarLabelSettings.fontSize);
	                return powerbi.TextMeasurementService.estimateSvgTextHeight(percentBarTextProperties);
	            };
	            FunnelChart.prototype.onClearSelection = function () {
	                if (this.interactivityService)
	                    this.interactivityService.clearSelection();
	            };
	            FunnelChart.getLayout = function (data, axisOptions) {
	                var highlightsOverflow = data.highlightsOverflow;
	                var categoryScale = axisOptions.categoryScale;
	                var valueScale = axisOptions.valueScale;
	                var maxScore = axisOptions.maxScore;
	                var columnHeight = categoryScale.rangeBand();
	                var percentBarTickHeight = Math.ceil(columnHeight / 2);
	                var overFlowHighlightColumnWidth = columnHeight * FunnelChart.OverflowingHighlightWidthRatio;
	                var overFlowHighlightOffset = overFlowHighlightColumnWidth / 2;
	                var lastCategoryIndex = axisOptions.categoryLabels.length - 1;
	                var horizontalDistance = Math.abs(valueScale(maxScore) - valueScale(0));
	                var emptyHorizontalSpace = function (value) { return (horizontalDistance - Math.abs(valueScale(value) - valueScale(0))) / 2; };
	                var getMinimumShapeSize = function (value) { return Math.max(FunnelChart.MinimumInteractorSize, Math.abs(valueScale(value) - valueScale(0))); };
	                var percentBarFontSize = PixelConverter.fromPoint(data.percentBarLabelSettings.fontSize);
	                var percentBarTextProperties = FunnelChart.getTextProperties(data.percentBarLabelSettings.fontSize);
	                var baselineDelta = powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(percentBarTextProperties);
	                var percentBarYOffset = powerbi.TextMeasurementService.estimateSvgTextHeight(percentBarTextProperties) - baselineDelta;
	                return {
	                    percentBarLayout: {
	                        mainLine: {
	                            x2: function (d) { return Math.abs(valueScale(d.value) - valueScale(0)); },
	                            transform: function (d) {
	                                var xOffset = valueScale(d.value) - emptyHorizontalSpace(d.value);
	                                var yOffset = d.isTop
	                                    ? categoryScale(0) - percentBarTickHeight
	                                    : categoryScale(lastCategoryIndex) + columnHeight + percentBarTickHeight;
	                                return visuals.SVGUtil.translate(xOffset, yOffset);
	                            },
	                        },
	                        leftTick: {
	                            y2: function (d) { return percentBarTickHeight; },
	                            transform: function (d) {
	                                var xOffset = valueScale(d.value) - emptyHorizontalSpace(d.value);
	                                var yOffset = d.isTop
	                                    ? categoryScale(0) - percentBarTickHeight - (percentBarTickHeight / 2)
	                                    : categoryScale(lastCategoryIndex) + columnHeight + percentBarTickHeight - (percentBarTickHeight / 2);
	                                return visuals.SVGUtil.translate(xOffset, yOffset);
	                            },
	                        },
	                        rightTick: {
	                            y2: function (d) { return percentBarTickHeight; },
	                            transform: function (d) {
	                                var columnOffset = valueScale(d.value) - emptyHorizontalSpace(d.value);
	                                var columnWidth = Math.abs(valueScale(d.value) - valueScale(0));
	                                var xOffset = columnOffset + columnWidth;
	                                var yOffset = d.isTop
	                                    ? categoryScale(0) - percentBarTickHeight - (percentBarTickHeight / 2)
	                                    : categoryScale(lastCategoryIndex) + columnHeight + percentBarTickHeight - (percentBarTickHeight / 2);
	                                return visuals.SVGUtil.translate(xOffset, yOffset);
	                            },
	                        },
	                        text: {
	                            x: function (d) { return Math.ceil((Math.abs(valueScale(maxScore) - valueScale(0)) / 2)); },
	                            y: function (d) {
	                                return d.isTop
	                                    ? -percentBarTickHeight / 2 - baselineDelta
	                                    : percentBarYOffset + (percentBarTickHeight / 2);
	                            },
	                            style: function () { return ("font-size: " + percentBarFontSize + ";"); },
	                            transform: function (d) {
	                                var xOffset = d.isTop
	                                    ? categoryScale(0) - percentBarTickHeight
	                                    : categoryScale(lastCategoryIndex) + columnHeight + percentBarTickHeight;
	                                return visuals.SVGUtil.translate(0, xOffset);
	                            },
	                            fill: data.percentBarLabelSettings.labelColor,
	                            maxWidth: horizontalDistance,
	                        },
	                    },
	                    shapeLayout: {
	                        height: (function (d) { return d.highlight && highlightsOverflow ? overFlowHighlightColumnWidth : columnHeight; }),
	                        width: function (d) {
	                            return Math.abs(valueScale(FunnelChart.getValueFromDataPoint(d)) - valueScale(0));
	                        },
	                        y: function (d) {
	                            return categoryScale(d.categoryOrMeasureIndex) + (d.highlight && highlightsOverflow ? overFlowHighlightOffset : 0);
	                        },
	                        x: function (d) {
	                            var value = FunnelChart.getValueFromDataPoint(d);
	                            return valueScale(value) - emptyHorizontalSpace(value);
	                        },
	                    },
	                    shapeLayoutWithoutHighlights: {
	                        height: (function (d) { return columnHeight; }),
	                        width: function (d) {
	                            return Math.abs(valueScale(d.value) - valueScale(0));
	                        },
	                        y: function (d) {
	                            return categoryScale(d.categoryOrMeasureIndex) + (0);
	                        },
	                        x: function (d) {
	                            return valueScale(d.value) - emptyHorizontalSpace(d.value);
	                        },
	                    },
	                    zeroShapeLayout: {
	                        height: (function (d) { return d.highlight && highlightsOverflow ? overFlowHighlightColumnWidth : columnHeight; }),
	                        width: function (d) { return 0; },
	                        y: function (d) {
	                            return categoryScale(d.categoryOrMeasureIndex) + (d.highlight && highlightsOverflow ? overFlowHighlightOffset : 0);
	                        },
	                        x: function (d) {
	                            return valueScale((valueScale.domain()[0] + valueScale.domain()[1]) / 2);
	                        },
	                    },
	                    interactorLayout: {
	                        height: (function (d) { return d.highlight && highlightsOverflow ? overFlowHighlightColumnWidth : columnHeight; }),
	                        width: function (d) { return getMinimumShapeSize(FunnelChart.getValueFromDataPoint(d)); },
	                        y: function (d) {
	                            return categoryScale(d.categoryOrMeasureIndex) + (d.highlight && highlightsOverflow ? overFlowHighlightOffset : 0);
	                        },
	                        x: function (d) {
	                            var size = getMinimumShapeSize(FunnelChart.getValueFromDataPoint(d));
	                            return (horizontalDistance - size) / 2;
	                        },
	                    },
	                };
	            };
	            FunnelChart.drawDefaultAxis = function (graphicsContext, axisOptions, isHidingPercentBars) {
	                //Generate ordinal domain
	                var indices = d3.range(0, axisOptions.categoryLabels.length);
	                var xScaleForAxis = d3.scale.ordinal()
	                    .domain(indices)
	                    .rangeBands([axisOptions.rangeStart, axisOptions.rangeEnd], axisOptions.barToSpaceRatio, isHidingPercentBars ? axisOptions.barToSpaceRatio : FunnelChart.PercentBarToBarRatio);
	                var xAxis = d3.svg.axis()
	                    .scale(xScaleForAxis)
	                    .orient("right")
	                    .tickPadding(FunnelChart.TickPadding)
	                    .innerTickSize(FunnelChart.InnerTickSize)
	                    .ticks(indices.length)
	                    .tickValues(indices)
	                    .tickFormat(function (i) { return axisOptions.categoryLabels[i]; }); //To output the category label
	                graphicsContext.attr('class', 'axis hideLinesOnAxis')
	                    .attr('transform', visuals.SVGUtil.translate(0, axisOptions.margin.top))
	                    .call(xAxis);
	                graphicsContext.selectAll('.tick')
	                    .call(visuals.tooltipUtils.tooltipUpdate, axisOptions.categoryLabels);
	                // Subtract the padding from the margin since we can't have text there. Then shorten the labels if necessary.
	                var leftRightMarginLimit = axisOptions.margin.left - FunnelChart.LabelFunnelPadding;
	                graphicsContext.selectAll('.tick text')
	                    .call(visuals.AxisHelper.LabelLayoutStrategy.clip, leftRightMarginLimit, powerbi.TextMeasurementService.svgEllipsis);
	            };
	            FunnelChart.drawDefaultShapes = function (data, dataPoints, graphicsContext, layout, hasSelection) {
	                var hasHighlights = data.hasHighlights;
	                var columns = graphicsContext.selectAll(FunnelChart.Selectors.funnel.bars.selector).data(dataPoints, function (d) { return d.key; });
	                columns.enter()
	                    .append('rect')
	                    .attr("class", function (d) { return d.highlight ? FunnelChart.FunnelBarHighlightClass : FunnelChart.Selectors.funnel.bars.class; });
	                columns
	                    .style("fill", function (d) {
	                    return d.color;
	                })
	                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, hasHighlights); })
	                    .attr(layout.shapeLayout);
	                columns.exit().remove();
	                return columns;
	            };
	            FunnelChart.getValueFromDataPoint = function (dataPoint, asOriginal) {
	                if (asOriginal === void 0) { asOriginal = false; }
	                if (asOriginal)
	                    return dataPoint.highlight ? (dataPoint.originalHighlightValue) : dataPoint.originalValue;
	                else
	                    return dataPoint.highlight ? dataPoint.highlightValue : dataPoint.value;
	            };
	            FunnelChart.drawInteractorShapes = function (dataPoints, graphicsContext, layout) {
	                // Draw invsible ineractors for just data points which are below threshold
	                var interactorsData = dataPoints.filter(function (d) {
	                    return !d.highlight && layout.interactorLayout.width(d) === FunnelChart.MinimumInteractorSize;
	                });
	                var columns = graphicsContext.selectAll(FunnelChart.Selectors.funnel.interactors.selector).data(interactorsData, function (d) { return d.key; });
	                columns.enter()
	                    .append('rect')
	                    .attr("class", FunnelChart.Selectors.funnel.interactors.class);
	                columns
	                    .style("fill-opacity", 0)
	                    .attr(layout.interactorLayout);
	                columns.exit().remove();
	                return columns;
	            };
	            FunnelChart.drawPercentBarComponents = function (graphicsContext, data, layout, percentLabelSettings) {
	                // Main line
	                var mainLine = graphicsContext.selectAll(FunnelChart.Selectors.percentBar.mainLine.selector).data(data);
	                mainLine.exit().remove();
	                mainLine.enter()
	                    .append('line')
	                    .classed(FunnelChart.Selectors.percentBar.mainLine.class, true);
	                mainLine
	                    .attr(layout.percentBarLayout.mainLine);
	                // Left tick
	                var leftTick = graphicsContext.selectAll(FunnelChart.Selectors.percentBar.leftTick.selector).data(data);
	                leftTick.exit().remove();
	                leftTick.enter()
	                    .append('line')
	                    .classed(FunnelChart.Selectors.percentBar.leftTick.class, true);
	                leftTick
	                    .attr(layout.percentBarLayout.leftTick);
	                // Right tick
	                var rightTick = graphicsContext.selectAll(FunnelChart.Selectors.percentBar.rightTick.selector).data(data);
	                rightTick.exit().remove();
	                rightTick.enter()
	                    .append('line')
	                    .classed(FunnelChart.Selectors.percentBar.rightTick.class, true);
	                rightTick
	                    .attr(layout.percentBarLayout.rightTick);
	                // Text
	                var text = graphicsContext.selectAll(FunnelChart.Selectors.percentBar.text.selector).data(data);
	                var localizedString = visuals.valueFormatter.getLocalizedString("Percentage1");
	                text.exit().remove();
	                text.enter().append('text').classed(FunnelChart.Selectors.percentBar.text.class, true);
	                text
	                    .attr(layout.percentBarLayout.text)
	                    .text(function (fp) {
	                    return visuals.dataLabelUtils.getLabelFormattedText({
	                        label: fp.percent,
	                        format: localizedString,
	                        fontSize: percentLabelSettings.fontSize,
	                        maxWidth: layout.percentBarLayout.text.maxWidth,
	                    });
	                })
	                    .append('title').text(function (d) { return powerbi.formattingService.formatValue(d.percent, localizedString); });
	            };
	            FunnelChart.drawPercentBars = function (data, graphicsContext, layout, isHidingPercentBars) {
	                if (isHidingPercentBars || !data.dataPoints || (data.hasHighlights ? data.dataPoints.length / 2 : data.dataPoints.length) < 2) {
	                    FunnelChart.drawPercentBarComponents(graphicsContext, [], layout, data.percentBarLabelSettings);
	                    return;
	                }
	                var dataPoints = [data.dataPoints[data.hasHighlights ? 1 : 0], data.dataPoints[data.dataPoints.length - 1]];
	                var baseline = FunnelChart.getValueFromDataPoint(dataPoints[0]);
	                if (baseline <= 0) {
	                    FunnelChart.drawPercentBarComponents(graphicsContext, [], layout, data.percentBarLabelSettings);
	                    return;
	                }
	                var percentData = [
	                    {
	                        value: FunnelChart.getValueFromDataPoint(dataPoints[0]),
	                        percent: 1,
	                        isTop: true,
	                    },
	                    {
	                        value: FunnelChart.getValueFromDataPoint(dataPoints[1]),
	                        percent: FunnelChart.getValueFromDataPoint(dataPoints[1]) / baseline,
	                        isTop: false,
	                    },
	                ];
	                FunnelChart.drawPercentBarComponents(graphicsContext, percentData, layout, data.percentBarLabelSettings);
	            };
	            FunnelChart.prototype.showCategoryLabels = function () {
	                if (this.funnelSmallViewPortProperties) {
	                    if ((this.funnelSmallViewPortProperties.hideFunnelCategoryLabelsOnSmallViewPort) && (this.currentViewport.height < this.funnelSmallViewPortProperties.minHeightFunnelCategoryLabelsVisible)) {
	                        return false;
	                    }
	                }
	                return true;
	            };
	            FunnelChart.addFunnelPercentsToTooltip = function (pctFormatString, tooltipInfo, hostServices, percentOfFirst, percentOfPrevious, highlight) {
	                if (percentOfFirst != null) {
	                    tooltipInfo.push({
	                        displayName: hostServices.getLocalizedString("Funnel_PercentOfFirst" + (highlight ? "_Highlight" : "")),
	                        value: visuals.valueFormatter.format(percentOfFirst, pctFormatString),
	                    });
	                }
	                if (percentOfPrevious != null) {
	                    tooltipInfo.push({
	                        displayName: hostServices.getLocalizedString("Funnel_PercentOfPrevious" + (highlight ? "_Highlight" : "")),
	                        value: visuals.valueFormatter.format(percentOfPrevious, pctFormatString),
	                    });
	                }
	            };
	            FunnelChart.getTextProperties = function (fontSize) {
	                return {
	                    fontSize: PixelConverter.fromPoint(fontSize || visuals.dataLabelUtils.DefaultFontSizeInPt),
	                    fontFamily: FunnelChart.DefaultFontFamily,
	                };
	            };
	            FunnelChart.getDefaultLabelSettings = function () {
	                return {
	                    show: true,
	                    position: powerbi.visuals.labelPosition.insideCenter,
	                    displayUnits: 0,
	                    labelColor: null,
	                    fontSize: LabelUtils.DefaultLabelFontSizeInPt,
	                };
	            };
	            FunnelChart.getDefaultPercentLabelSettings = function () {
	                return {
	                    show: true,
	                    position: 0 /* Above */,
	                    displayUnits: 0,
	                    labelColor: LabelUtils.defaultLabelColor,
	                    fontSize: LabelUtils.DefaultLabelFontSizeInPt,
	                };
	            };
	            /**
	             * Creates labels layout.
	             */
	            FunnelChart.prototype.getLabels = function (layout) {
	                var labels = [];
	                if (this.data.dataLabelsSettings.show && this.data.canShowDataLabels) {
	                    var labelDataPoints = this.createLabelDataPoints(layout.shapeLayout, this.data.dataLabelsSettings);
	                    var newLabelLayout = new powerbi.LabelLayout({
	                        maximumOffset: LabelUtils.maxLabelOffset,
	                        startingOffset: LabelUtils.startingLabelOffset
	                    });
	                    var labelDataPointsGroup = {
	                        labelDataPoints: labelDataPoints,
	                        maxNumberOfLabels: labelDataPoints.length
	                    };
	                    var labelViewport = {
	                        width: this.currentViewport.width - this.margin.left,
	                        height: this.currentViewport.height - this.margin.top
	                    };
	                    labels = newLabelLayout.layout([labelDataPointsGroup], labelViewport);
	                }
	                return labels;
	            };
	            /**
	             * Creates labelDataPoints for rendering labels
	             */
	            FunnelChart.prototype.createLabelDataPoints = function (shapeLayout, visualSettings) {
	                var data = this.data;
	                var dataPoints = data.dataPoints;
	                if (_.isEmpty(dataPoints)) {
	                    return [];
	                }
	                var points = new Array();
	                // Because labels share the same formatting use the first one as default.
	                var generalSettings = dataPoints[0];
	                // Shape
	                var validPositions = FunnelChart.LabelInsidePosition;
	                var height = shapeLayout.height(generalSettings);
	                if (visualSettings.position && visualSettings.position === visuals.labelPosition.outsideEnd) {
	                    validPositions = FunnelChart.LabelOutsidePosition;
	                }
	                var maxAbsoluteValue = null;
	                // Formatter
	                if (visualSettings.displayUnits === 0 /* Auto */) {
	                    // if display unit is auto let formatter decide what scale to use based on maximum value.
	                    maxAbsoluteValue = data.dataPoints.reduce(function (memo, value) { return Math.abs(memo.value) > Math.abs(value.value) ? memo : value; }).value;
	                }
	                var formatString = visuals.valueFormatter.getFormatString(data.valuesMetadata[0], visuals.funnelChartProps.general.formatString);
	                var formattersCache = LabelUtils.createColumnFormatterCacheManager();
	                // Text Properties
	                var fontSize = visualSettings.fontSize;
	                var properties = {
	                    fontFamily: LabelUtils.LabelTextProperties.fontFamily,
	                    fontSize: PixelConverter.fromPoint(fontSize || LabelUtils.DefaultLabelFontSizeInPt),
	                    fontWeight: LabelUtils.LabelTextProperties.fontWeight,
	                };
	                var outsideFill = generalSettings.labelFill || LabelUtils.defaultLabelColor;
	                var insideFill = generalSettings.labelFill || LabelUtils.defaultInsideLabelColor;
	                for (var _i = 0, dataPoints_2 = dataPoints; _i < dataPoints_2.length; _i++) {
	                    var dataPoint = dataPoints_2[_i];
	                    var value = FunnelChart.getValueFromDataPoint(dataPoint, true /* asOriginal */);
	                    if (value == null
	                        || (data.hasHighlights && !dataPoint.highlight)) {
	                        continue;
	                    }
	                    var labelFormatString = (formatString != null) ? formatString : generalSettings.labelFormatString;
	                    var formatter = formattersCache.getOrCreate(labelFormatString, visualSettings, maxAbsoluteValue);
	                    var labelText = formatter.format(value);
	                    properties.text = labelText;
	                    var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
	                    var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
	                    var parentType = 1 /* Rectangle */;
	                    var shape = {
	                        rect: {
	                            left: shapeLayout.x(dataPoint),
	                            top: shapeLayout.y(dataPoint),
	                            width: shapeLayout.width(dataPoint),
	                            height: height
	                        },
	                        orientation: FunnelChart.LabelOrientation,
	                        validPositions: validPositions
	                    };
	                    var point = {
	                        isPreferred: true,
	                        // text
	                        text: labelText,
	                        textSize: {
	                            width: textWidth,
	                            height: textHeight
	                        },
	                        fontSize: fontSize,
	                        // parent shape
	                        parentType: parentType,
	                        parentShape: shape,
	                        // colors
	                        insideFill: insideFill,
	                        outsideFill: outsideFill,
	                        // additional properties
	                        identity: dataPoint.identity,
	                        hasBackground: false
	                    };
	                    // For zero value we are using point in order to center text position.
	                    if (dataPoint.value === 0) {
	                        shape = {
	                            validPositions: [256 /* Center */],
	                            point: {
	                                x: shapeLayout.x(dataPoint),
	                                y: shapeLayout.y(dataPoint) + height / 2
	                            }
	                        };
	                        parentType = 0 /* Point */;
	                        point.parentShape = shape;
	                        point.parentType = parentType;
	                        point.insideFill = point.outsideFill;
	                    }
	                    points.push(point);
	                }
	                return points;
	            };
	            FunnelChart.LabelInsidePosition = [1 /* InsideCenter */, 16 /* OutsideEnd */];
	            FunnelChart.LabelOutsidePosition = [16 /* OutsideEnd */, 4 /* InsideEnd */];
	            FunnelChart.LabelOrientation = 3 /* HorizontalLeftBased */;
	            FunnelChart.DefaultBarOpacity = 1;
	            FunnelChart.DimmedBarOpacity = 0.4;
	            FunnelChart.PercentBarToBarRatio = 0.75;
	            FunnelChart.TickPadding = 0;
	            FunnelChart.InnerTickSize = 0;
	            FunnelChart.MinimumInteractorSize = 15;
	            FunnelChart.InnerTextClassName = 'labelSeries';
	            FunnelChart.Selectors = {
	                funnel: {
	                    bars: createClassAndSelector('funnelBar'),
	                    highlights: createClassAndSelector('highlight'),
	                    interactors: createClassAndSelector('funnelBarInteractor'),
	                },
	                percentBar: {
	                    root: createClassAndSelector('percentBars'),
	                    mainLine: createClassAndSelector('mainLine'),
	                    leftTick: createClassAndSelector('leftTick'),
	                    rightTick: createClassAndSelector('rightTick'),
	                    text: createClassAndSelector('value'),
	                },
	            };
	            FunnelChart.FunnelBarHighlightClass = [FunnelChart.Selectors.funnel.bars.class, FunnelChart.Selectors.funnel.highlights.class].join(' ');
	            FunnelChart.YAxisPadding = 10;
	            FunnelChart.VisualClassName = 'funnelChart';
	            FunnelChart.DefaultFontFamily = visuals.Font.Family.regularSecondary.css;
	            FunnelChart.BarToSpaceRatio = 0.1;
	            FunnelChart.MaxBarHeight = 40;
	            FunnelChart.MinBarThickness = 12;
	            FunnelChart.LabelFunnelPadding = 6;
	            FunnelChart.OverflowingHighlightWidthRatio = 0.5;
	            FunnelChart.MaxMarginFactor = 0.25;
	            return FunnelChart;
	        }());
	        visuals.FunnelChart = FunnelChart;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 262 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
	        var PixelConverter = jsCommon.PixelConverter;
	        var DataRoleHelper = powerbi.data.DataRoleHelper;
	        /**
	         * Renders a number that can be animate change in value.
	         */
	        var Gauge = (function () {
	            function Gauge(options) {
	                this.lastAngle = -Math.PI / 2;
	                if (options) {
	                    if (options.gaugeSmallViewPortProperties) {
	                        this.gaugeSmallViewPortProperties = options.gaugeSmallViewPortProperties;
	                    }
	                    this.animator = options.animator;
	                    this.tooltipsEnabled = options.tooltipsEnabled;
	                    this.tooltipBucketEnabled = options.tooltipBucketEnabled;
	                }
	            }
	            Gauge.prototype.enumerateObjectInstances = function (options) {
	                var enumeration = new visuals.ObjectEnumerationBuilder();
	                switch (options.objectName) {
	                    case 'axis':
	                        this.enumerateAxis(enumeration);
	                        break;
	                    case 'labels': {
	                        var labelSettings = this.data ? this.data.dataLabelsSettings : visuals.dataLabelUtils.getDefaultGaugeLabelSettings();
	                        visuals.dataLabelUtils.enumerateDataLabels(this.getDataLabelSettingsOptions(enumeration, labelSettings));
	                        break;
	                    }
	                    case 'calloutValue': {
	                        var labelSettings = this.data ? this.data.calloutValueLabelsSettings : visuals.dataLabelUtils.getDefaultGaugeLabelSettings();
	                        visuals.dataLabelUtils.enumerateDataLabels(this.getDataLabelSettingsOptions(enumeration, labelSettings));
	                        break;
	                    }
	                    case 'dataPoint': {
	                        this.enumerateDataPoint(enumeration);
	                        break;
	                    }
	                }
	                return enumeration.complete();
	            };
	            Gauge.prototype.getDataLabelSettingsOptions = function (enumeration, labelSettings) {
	                return {
	                    dataLabelsSettings: labelSettings,
	                    show: true,
	                    precision: true,
	                    displayUnits: true,
	                    fontSize: true,
	                    enumeration: enumeration,
	                };
	            };
	            Gauge.prototype.enumerateAxis = function (enumeration) {
	                var dataView = this.dataView;
	                if (dataView && dataView.metadata) {
	                    var properties = Gauge.getGaugeObjectsProperties(dataView);
	                    enumeration.pushInstance({
	                        selector: null,
	                        objectName: 'axis',
	                        properties: properties,
	                    });
	                }
	            };
	            Gauge.prototype.enumerateDataPoint = function (enumeration) {
	                var dataPointSettings = this.data ? this.data.dataPointSettings : Gauge.DefaultDataPointSettings;
	                var properties = {};
	                properties.fill = { solid: { color: dataPointSettings.fillColor } };
	                if (dataPointSettings.targetColor != null) {
	                    properties.target = { solid: { color: dataPointSettings.targetColor } };
	                }
	                enumeration.pushInstance({
	                    selector: null,
	                    objectName: visuals.gaugeProps.dataPoint.target.objectName,
	                    properties: properties
	                });
	            };
	            Gauge.getGaugeObjectsProperties = function (dataView) {
	                var properties = {};
	                var objects = dataView.metadata.objects;
	                var hasAxisObject = !!objects && !!objects.axis;
	                if (!DataRoleHelper.hasRoleInDataView(dataView, visuals.gaugeRoleNames.minValue))
	                    properties.min = hasAxisObject ? objects.axis.min : undefined;
	                if (!DataRoleHelper.hasRoleInDataView(dataView, visuals.gaugeRoleNames.maxValue))
	                    properties.max = hasAxisObject ? objects.axis.max : undefined;
	                if (!DataRoleHelper.hasRoleInDataView(dataView, visuals.gaugeRoleNames.targetValue))
	                    properties.target = hasAxisObject ? objects.axis.target : undefined;
	                return properties;
	            };
	            Gauge.prototype.init = function (options) {
	                this.element = options.element;
	                this.currentViewport = options.viewport;
	                this.style = options.style;
	                this.options = options;
	                this.settings = Gauge.DefaultStyleProperties;
	                this.targetSettings = Gauge.DefaultTargetSettings;
	                this.setMargins();
	                this.color = d3.scale.ordinal().range(this.style.colorPalette.dataColors.getSentimentColors().map(function (color) { return color.value; }));
	                this.hostService = options.host;
	                var svg = this.svg = d3.select(this.element.get(0)).append('svg');
	                svg.classed(Gauge.VisualClassName, true);
	                var mainGraphicsContext = this.mainGraphicsContext = svg.append('g');
	                mainGraphicsContext.attr('class', Gauge.MainGaugeGroupClassName);
	                this.initKpiBands();
	                var backgroundArc = this.backgroundArc = d3.svg.arc()
	                    .innerRadius(0)
	                    .outerRadius(0)
	                    .startAngle(-Math.PI / 2)
	                    .endAngle(Math.PI / 2);
	                var foregroundArc = this.foregroundArc = d3.svg.arc()
	                    .innerRadius(0)
	                    .outerRadius(0)
	                    .startAngle(-Math.PI / 2);
	                this.backgroundArcPath = mainGraphicsContext.append('path')
	                    .classed('backgroundArc', true)
	                    .attr('d', backgroundArc);
	                this.foregroundArcPath = mainGraphicsContext.append('path')
	                    .datum({ endAngle: -Math.PI / 2 })
	                    .classed('foregroundArc', true)
	                    .attr('d', foregroundArc);
	                var g = this.animatedNumberGrapicsContext = svg.append('g');
	                this.animatedNumber = new visuals.AnimatedNumber(g);
	                this.animatedNumber.init(options);
	                var gaugeDrawingOptions = this.gaugeVisualProperties = this.getGaugeVisualProperties();
	                var animatedNumberProperties = this.getAnimatedNumberProperties(gaugeDrawingOptions.radius, gaugeDrawingOptions.innerRadiusFactor, gaugeDrawingOptions.top, gaugeDrawingOptions.left);
	                this.animatedNumberGrapicsContext.attr('transform', animatedNumberProperties.transformString);
	                this.animatedNumber.onResizing(animatedNumberProperties.viewport);
	            };
	            Gauge.prototype.update = function (options) {
	                debug.assertValue(options, 'options');
	                this.currentViewport = options.viewport;
	                if (!options.dataViews || !options.dataViews[0]) {
	                    return;
	                }
	                var dataView = this.dataView = options.dataViews[0];
	                var reader = powerbi.data.createIDataViewCategoricalReader(dataView);
	                this.data = Gauge.converter(reader, this.tooltipBucketEnabled);
	                this.targetSettings = this.data.targetSettings;
	                this.dataView.single = { value: this.data.total };
	                this.labels = this.createLabels();
	                // Only show the target label if:
	                //   1. There is a target
	                //   2. The target is inside boundaries
	                //   3. The viewport width is big enough for a target
	                //   4. We're showing label text for side numbers
	                //   5. Data label settings specify to show
	                this.showTargetLabel = this.targetSettings.target != null
	                    && (this.targetSettings.target >= this.targetSettings.min && this.targetSettings.target <= this.targetSettings.max)
	                    && (this.currentViewport.width > Gauge.MinWidthForTargetLabel || this.getLabelsPosition() !== 2 /* Bottom */)
	                    && this.showSideNumbersLabelText()
	                    && this.data.dataLabelsSettings.show;
	                this.setMargins();
	                this.gaugeVisualProperties = this.getGaugeVisualProperties();
	                this.drawViewPort(this.gaugeVisualProperties);
	                this.updateInternal(options.suppressAnimations);
	                this.updateCalloutValue(options.suppressAnimations);
	                var warnings = visuals.getInvalidValueWarnings([dataView], false /*supportsNaN*/, false /*supportsNegativeInfinity*/, false /*supportsPositiveInfinity*/);
	                this.hostService.setWarnings(warnings);
	            };
	            Gauge.prototype.updateCalloutValue = function (suppressAnimations) {
	                if (this.data.calloutValueLabelsSettings.show) {
	                    var animatedNumberProperties = this.getAnimatedNumberProperties(this.gaugeVisualProperties.radius, this.gaugeVisualProperties.innerRadiusFactor, this.gaugeVisualProperties.top, this.gaugeVisualProperties.left);
	                    this.animatedNumberGrapicsContext.attr('transform', animatedNumberProperties.transformString);
	                    this.animatedNumber.setTextColor(this.data.calloutValueLabelsSettings.labelColor);
	                    var calloutValue = this.data ? this.data.total : null;
	                    var formatter = this.getFormatter(this.data.calloutValueLabelsSettings, this.data.metadataColumn, calloutValue);
	                    this.animatedNumber.setFormatter(formatter);
	                    this.animatedNumber.update({
	                        viewport: animatedNumberProperties.viewport,
	                        dataViews: [this.dataView],
	                        suppressAnimations: suppressAnimations,
	                    });
	                    this.animatedNumberGrapicsContext.selectAll('title').remove();
	                    this.animatedNumberGrapicsContext.append('title').text([formatter.format(calloutValue)]);
	                }
	                else {
	                    this.animatedNumber.clear();
	                    this.animatedNumberGrapicsContext.selectAll('title').remove();
	                }
	            };
	            Gauge.prototype.onDataChanged = function (options) {
	                // TODO: Remove onDataChanged & onResizing once all visuals have implemented update.
	                this.update({
	                    dataViews: options.dataViews,
	                    suppressAnimations: options.suppressAnimations,
	                    viewport: this.currentViewport
	                });
	            };
	            Gauge.prototype.onResizing = function (viewport) {
	                // TODO: Remove onDataChanged & onResizing once all visuals have implemented update.
	                this.update({
	                    dataViews: [this.dataView],
	                    suppressAnimations: true,
	                    viewMode: 0 /* View */,
	                    viewport: viewport
	                });
	            };
	            /**
	             * Populates Gauge data based on roles or axis settings.
	             */
	            Gauge.parseGaugeData = function (reader, tooltipBucketEnabled) {
	                var dataViewObjects = reader.getStaticObjects();
	                var valueMetadata = reader.getValueMetadataColumn(visuals.gaugeRoleNames.y);
	                var axisObject = dataViewObjects ? dataViewObjects.axis : null;
	                var isValueDefined = reader.hasValues(visuals.gaugeRoleNames.y);
	                var isMaxDefined = reader.hasValues(visuals.gaugeRoleNames.maxValue);
	                var isMinDefined = reader.hasValues(visuals.gaugeRoleNames.minValue);
	                var valueIndex = 0;
	                var data = {
	                    max: null,
	                    min: null,
	                    target: null,
	                    value: null,
	                    tooltipItems: []
	                };
	                // Set value
	                if (isValueDefined) {
	                    data.value = reader.getValue(visuals.gaugeRoleNames.y, valueIndex);
	                    var value = visuals.converterHelper.formatFromMetadataColumn(data.value, valueMetadata, Gauge.formatStringProp);
	                    data.tooltipItems.push({ displayName: reader.getValueDisplayName(visuals.gaugeRoleNames.y), value: value });
	                }
	                // Set target
	                if (reader.hasValues(visuals.gaugeRoleNames.targetValue)) {
	                    var targetMetadata = reader.getValueMetadataColumn(visuals.gaugeRoleNames.targetValue);
	                    data.target = reader.getValue(visuals.gaugeRoleNames.targetValue, valueIndex);
	                    var value = visuals.converterHelper.formatFromMetadataColumn(data.target, targetMetadata, Gauge.formatStringProp);
	                    data.tooltipItems.push({ displayName: reader.getValueDisplayName(visuals.gaugeRoleNames.targetValue), value: value });
	                }
	                else if (axisObject) {
	                    data.target = axisObject.target;
	                }
	                // For maxumum we set values in such priority: 
	                // 1. Maximum column
	                // 2. Property pane axis settings
	                // 3. If the value column is specified and it has no percent formatting and min is undefined: 
	                //                                                      a. 2 * value if value > 0
	                //                                                      b. 0 if value < 0
	                // 4. Use Default Max value what is 1 right now. 
	                if (isMaxDefined) {
	                    data.max = reader.getValue(visuals.gaugeRoleNames.maxValue, valueIndex);
	                }
	                else if (axisObject && axisObject.max != null) {
	                    data.max = axisObject.max;
	                }
	                else {
	                    data.max = Gauge.DEFAULT_MAX;
	                    if (isValueDefined && data.value && data.value !== 0) {
	                        var hasPercent = false;
	                        if (valueMetadata) {
	                            var formatString = visuals.valueFormatter.getFormatString(valueMetadata, Gauge.formatStringProp, true);
	                            if (formatString != null) {
	                                hasPercent = visuals.valueFormatter.getFormatMetadata(formatString).hasPercent;
	                            }
	                        }
	                        if (!hasPercent && !isMinDefined) {
	                            data.max = data.value < 0 ? Gauge.DEFAULT_MIN : 2 * data.value;
	                        }
	                    }
	                }
	                // For minimum we set values in such priority: 
	                // 1. Minimum column.
	                // 2. Property pane axis settings.
	                // 3. Use Default Min value what is 0 right now for value >= 0.
	                // 4. Use value * 2 for value < 0 and max hasn't been specified.
	                if (isMinDefined) {
	                    data.min = reader.getValue(visuals.gaugeRoleNames.minValue, valueIndex);
	                }
	                else if (axisObject && axisObject.min != null) {
	                    data.min = axisObject.min;
	                }
	                else {
	                    data.min = Gauge.DEFAULT_MIN;
	                    if (!isMaxDefined && isValueDefined && data.value != null && data.value < 0) {
	                        data.min = 2 * data.value;
	                    }
	                }
	                if (tooltipBucketEnabled) {
	                    visuals.TooltipBuilder.addTooltipBucketItem(reader, data.tooltipItems, 0);
	                }
	                return data;
	            };
	            /** Note: Made public for testability */
	            Gauge.converter = function (reader, tooltipBucketEnabled) {
	                if (tooltipBucketEnabled === void 0) { tooltipBucketEnabled = true; }
	                var objectSettings = reader.getStaticObjects();
	                var metadataColumn = reader.getValueMetadataColumn(visuals.gaugeRoleNames.y);
	                var gaugeData = Gauge.parseGaugeData(reader, tooltipBucketEnabled);
	                var value = gaugeData.value;
	                return {
	                    total: value,
	                    tooltipInfo: gaugeData.tooltipItems,
	                    maxColumnMetadata: reader.getValueMetadataColumn(visuals.gaugeRoleNames.maxValue),
	                    minColumnMetadata: reader.getValueMetadataColumn(visuals.gaugeRoleNames.minValue),
	                    targetColumnMetadata: reader.getValueMetadataColumn(visuals.gaugeRoleNames.targetValue),
	                    metadataColumn: metadataColumn,
	                    targetSettings: { min: gaugeData.min, max: gaugeData.max, target: gaugeData.target },
	                    dataLabelsSettings: Gauge.convertDataLabelSettings(objectSettings, "labels"),
	                    calloutValueLabelsSettings: Gauge.convertDataLabelSettings(objectSettings, "calloutValue"),
	                    dataPointSettings: Gauge.convertDataPointSettings(objectSettings, gaugeData)
	                };
	            };
	            Gauge.convertDataLabelSettings = function (objects, objectName) {
	                var dataLabelsSettings = visuals.dataLabelUtils.getDefaultGaugeLabelSettings();
	                if (objects) {
	                    // Handle label settings
	                    var labelsObj = objects[objectName];
	                    visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, dataLabelsSettings);
	                }
	                return dataLabelsSettings;
	            };
	            Gauge.convertDataPointSettings = function (objects, targetSettings) {
	                // Default the fill color the the default fill color. Default the target to undefined as it's only used if there's a target.
	                var fillColor = Gauge.DefaultDataPointSettings.fillColor;
	                var targetColor;
	                if (objects) {
	                    fillColor = powerbi.DataViewObjects.getFillColor(objects, visuals.gaugeProps.dataPoint.fill, Gauge.DefaultDataPointSettings.fillColor);
	                    if (targetSettings && (targetSettings.target != null)) {
	                        targetColor = powerbi.DataViewObjects.getFillColor(objects, visuals.gaugeProps.dataPoint.target, Gauge.DefaultDataPointSettings.targetColor);
	                    }
	                }
	                else if (targetSettings && (targetSettings.target != null)) {
	                    // If there isn't metadata, but a target is set, default to the default target color
	                    targetColor = Gauge.DefaultDataPointSettings.targetColor;
	                }
	                return {
	                    fillColor: fillColor,
	                    targetColor: targetColor
	                };
	            };
	            Gauge.prototype.initKpiBands = function () {
	                if (!this.settings.kpiBands.show)
	                    return;
	                var kpiArcs = this.kpiArcs = [];
	                var kpiArcPaths = this.kpiArcPaths = [];
	                var mainGraphicsContext = this.mainGraphicsContext;
	                for (var i = 0; i < 3; i++) {
	                    var arc = d3.svg.arc()
	                        .innerRadius(0)
	                        .outerRadius(0)
	                        .startAngle(0)
	                        .endAngle(0);
	                    kpiArcs.push(arc);
	                    var arcPath = mainGraphicsContext.append('path')
	                        .attr("d", arc);
	                    kpiArcPaths.push(arcPath);
	                }
	            };
	            /**
	             * Indicates whether gauge arc is valid.
	             */
	            Gauge.prototype.isValid = function () {
	                if (!this.data || !this.data.targetSettings)
	                    return false;
	                var targetSettings = this.data.targetSettings;
	                return $.isNumeric(targetSettings.min) && $.isNumeric(targetSettings.max) || targetSettings.min > targetSettings.max;
	            };
	            Gauge.prototype.updateKpiBands = function (radius, innerRadiusFactor, tString, kpiAngleAttr) {
	                if (!this.settings.kpiBands.show)
	                    return;
	                for (var i = 0; i < kpiAngleAttr.length; i++) {
	                    this.kpiArcs[i]
	                        .innerRadius(radius * innerRadiusFactor - (Gauge.KpiBandDistanceFromMainArc + this.settings.kpiBands.thickness))
	                        .outerRadius(radius * innerRadiusFactor - Gauge.KpiBandDistanceFromMainArc)
	                        .startAngle(kpiAngleAttr[i].start)
	                        .endAngle(kpiAngleAttr[i].end);
	                    this.kpiArcPaths[i]
	                        .attr('fill', kpiAngleAttr[i].fill)
	                        .attr('d', this.kpiArcs[i])
	                        .attr('transform', tString);
	                }
	            };
	            Gauge.prototype.removeTargetElements = function () {
	                if (this.targetLine) {
	                    this.targetLine.remove();
	                    this.targetText.remove();
	                    this.targetConnector.remove();
	                    this.targetLine = this.targetConnector = this.targetText = null;
	                }
	            };
	            Gauge.prototype.getTargetRatio = function () {
	                var targetSettings = this.targetSettings;
	                var range = targetSettings.max - targetSettings.min;
	                if (range !== 0)
	                    return (targetSettings.target - targetSettings.min) / range;
	                return 0;
	            };
	            Gauge.prototype.updateTargetLine = function (radius, innerRadius, left, top) {
	                if (!this.targetLine) {
	                    this.targetLine = this.mainGraphicsContext.append('line');
	                }
	                var angle = this.getTargetRatio() * Math.PI;
	                var outY = top - radius * Math.sin(angle);
	                var outX = left - radius * Math.cos(angle);
	                var inY = top - innerRadius * Math.sin(angle);
	                var inX = left - innerRadius * Math.cos(angle);
	                this.targetLine.attr({
	                    x1: inX,
	                    y1: inY,
	                    x2: outX,
	                    y2: outY
	                });
	            };
	            /** Note: public for testability */
	            Gauge.prototype.getAnimatedNumberProperties = function (radius, innerRadiusFactor, top, left) {
	                var boxAngle = Math.PI / 4;
	                var scale = 1;
	                var innerRadiusOfArc = radius * innerRadiusFactor;
	                var innerRadiusForTextBoundingBox = innerRadiusOfArc - (this.settings.kpiBands.show
	                    ? (Gauge.KpiBandDistanceFromMainArc + this.settings.kpiBands.thickness)
	                    : 0);
	                var innerRCos = innerRadiusForTextBoundingBox * Math.cos(boxAngle);
	                var innerRSin = innerRadiusForTextBoundingBox * Math.sin(boxAngle);
	                var innerY = top - innerRSin;
	                var innerX = left - innerRCos;
	                innerY = innerY * scale;
	                innerX = innerX * scale;
	                var animatedNumberWidth = innerRCos * 2;
	                var properties = {
	                    transformString: visuals.SVGUtil.translate(innerX, innerY),
	                    viewport: { height: innerRSin, width: animatedNumberWidth }
	                };
	                return properties;
	            };
	            /** Note: public for testability */
	            Gauge.prototype.getGaugeVisualProperties = function () {
	                var viewport = this.currentViewport;
	                var margin = this.margin;
	                var width = viewport.width - margin.right - margin.left;
	                var halfWidth = width / 2;
	                var height = viewport.height - margin.top - margin.bottom;
	                var radius = Math.min(halfWidth, height);
	                var innerRadiusFactor = Gauge.InnerRadiusFactor;
	                var left = margin.left + halfWidth;
	                var top = radius + (height - radius) / 2 + margin.top;
	                var tString = visuals.SVGUtil.translate(left, top);
	                var innerRadiusOfArc = radius * innerRadiusFactor;
	                var gaugeData = {
	                    radius: radius,
	                    innerRadiusOfArc: innerRadiusOfArc,
	                    left: left,
	                    top: top,
	                    height: height,
	                    width: width,
	                    margin: margin,
	                    transformString: tString,
	                    innerRadiusFactor: innerRadiusFactor
	                };
	                return gaugeData;
	            };
	            /** Note: public for testability */
	            Gauge.prototype.drawViewPort = function (drawOptions) {
	                debug.assertAnyValue(drawOptions, "Gauge options");
	                var separation = this.settings.kpiBands.separationRadians;
	                var innerRadiusFactor = Gauge.InnerRadiusFactor;
	                var backgroudArc = this.backgroundArc;
	                var color = this.color;
	                var attrs = [{
	                        fill: color(0),
	                        start: -Math.PI / 2,
	                        end: -Math.PI / 2 + Math.PI / 4 - separation
	                    }, {
	                        fill: color(1),
	                        start: -Math.PI / 2 + Math.PI * 1 / 4 + separation,
	                        end: -Math.PI / 2 + Math.PI * 3 / 4 - separation
	                    }, {
	                        fill: color(2),
	                        start: -Math.PI / 2 + Math.PI * 3 / 4 + separation,
	                        end: Math.PI / 2
	                    }];
	                var radius = drawOptions.radius;
	                var transformString = drawOptions.transformString;
	                this.updateKpiBands(radius, innerRadiusFactor, transformString, attrs);
	                backgroudArc
	                    .innerRadius(radius * innerRadiusFactor)
	                    .outerRadius(radius)
	                    .startAngle(-Math.PI / 2)
	                    .endAngle(Math.PI / 2);
	                this.backgroundArcPath
	                    .attr("d", backgroudArc)
	                    .attr("transform", transformString);
	                var foregroundArc = this.foregroundArc;
	                foregroundArc
	                    .innerRadius(radius * innerRadiusFactor)
	                    .outerRadius(radius)
	                    .startAngle(-Math.PI / 2);
	                this.foregroundArcPath
	                    .datum({ endAngle: this.lastAngle })
	                    .attr("transform", transformString)
	                    .attr("d", foregroundArc);
	                var innerRadiusOfArc = drawOptions.innerRadiusOfArc;
	                var left = drawOptions.left;
	                var top = drawOptions.top;
	                var margin = drawOptions.margin;
	                var height = drawOptions.height;
	                var targetSettings = this.targetSettings;
	                if (!this.settings.targetLine.show || !this.isValid() || !$.isNumeric(targetSettings.target)) {
	                    this.removeTargetElements();
	                }
	                else {
	                    if (targetSettings.min > targetSettings.target || targetSettings.max < targetSettings.target) {
	                        this.removeTargetElements();
	                    }
	                    else {
	                        this.updateTargetLine(radius, innerRadiusOfArc, left, top);
	                        this.renderTarget(radius, height, drawOptions.width, margin);
	                    }
	                }
	                this.svg.attr('height', this.currentViewport.height).attr('width', this.currentViewport.width);
	            };
	            Gauge.prototype.getValueAngle = function () {
	                var settings = this.data.targetSettings;
	                var total = this.data.total;
	                if (!this.isValid() || !$.isNumeric(total)) {
	                    return 0;
	                }
	                var adjustedTotal = Math.min(Math.max(total, settings.min), settings.max);
	                var angle = (adjustedTotal - settings.min) / (settings.max - settings.min);
	                return angle;
	            };
	            Gauge.prototype.createLabels = function () {
	                var targetSettings = this.targetSettings;
	                var arr = [];
	                var label = null;
	                var textProperties = {
	                    fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
	                    fontSize: PixelConverter.fromPoint(this.data.dataLabelsSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt),
	                    fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight,
	                };
	                var minFormatter = this.getFormatter(this.data.dataLabelsSettings, this.data.minColumnMetadata, targetSettings.max);
	                textProperties.text = minFormatter.format(targetSettings.min);
	                label = {
	                    size: {
	                        width: powerbi.TextMeasurementService.measureSvgTextWidth(textProperties),
	                        height: powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties)
	                    },
	                    text: textProperties.text
	                };
	                arr.push(label);
	                var maxFormatter = this.getFormatter(this.data.dataLabelsSettings, this.data.maxColumnMetadata, targetSettings.max);
	                textProperties.text = maxFormatter.format(targetSettings.max);
	                label = {
	                    size: {
	                        width: powerbi.TextMeasurementService.measureSvgTextWidth(textProperties),
	                        height: powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties)
	                    },
	                    text: textProperties.text
	                };
	                arr.push(label);
	                return arr;
	            };
	            Gauge.prototype.updateInternal = function (suppressAnimations) {
	                var height = this.gaugeVisualProperties.height;
	                var width = this.gaugeVisualProperties.width;
	                var radius = this.gaugeVisualProperties.radius;
	                var margin = this.margin;
	                var duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
	                var data = this.data;
	                var lastAngle = this.lastAngle = -Math.PI / 2 + Math.PI * this.getValueAngle();
	                this.foregroundArcPath
	                    .transition()
	                    .ease(this.settings.transition.ease)
	                    .duration(duration)
	                    .call(this.arcTween, [lastAngle, this.foregroundArc]);
	                this.renderMinMaxLabels(this.labels, radius, height, width, margin);
	                this.updateVisualConfigurations();
	                this.updateVisualStyles();
	                if (this.tooltipsEnabled) {
	                    visuals.TooltipManager.addTooltip(this.foregroundArcPath, function (tooltipEvent) { return data.tooltipInfo; });
	                    visuals.TooltipManager.addTooltip(this.backgroundArcPath, function (tooltipEvent) { return data.tooltipInfo; });
	                }
	            };
	            Gauge.prototype.updateVisualStyles = function () {
	                var fillColor = this.data.dataLabelsSettings.labelColor || this.style.labelText.color.value;
	                this.mainGraphicsContext.selectAll('text')
	                    .style({
	                    'fill': fillColor,
	                });
	            };
	            Gauge.prototype.updateVisualConfigurations = function () {
	                var configOptions = this.settings;
	                var dataPointSettings = this.data.dataPointSettings;
	                this.mainGraphicsContext
	                    .select('line')
	                    .attr({
	                    stroke: dataPointSettings.targetColor,
	                    'stroke-width': configOptions.targetLine.thickness,
	                });
	                this.backgroundArcPath.style('fill', configOptions.arcColors.background);
	                this.foregroundArcPath.style('fill', dataPointSettings.fillColor);
	            };
	            Gauge.prototype.renderMinMaxLabels = function (ticks, radius, height, width, margin) {
	                this.svg.selectAll(Gauge.LabelText.selector).remove();
	                if (!this.data.dataLabelsSettings.show)
	                    return;
	                var total = ticks.length;
	                var divisor = total - 1;
	                var position = this.getLabelsPosition();
	                var fontSize = PixelConverter.fromPoint(this.data.dataLabelsSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt);
	                var padding = this.settings.labels.padding;
	                for (var index = 0; index < total; index++) {
	                    var y = this.gaugeVisualProperties.top;
	                    var textProperties = {
	                        text: ticks[index].text,
	                        fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
	                        fontSize: PixelConverter.fromPoint(this.data.dataLabelsSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt),
	                        fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight,
	                    };
	                    if (this.showSideNumbersLabelText()) {
	                        var x = (margin.left + width / 2) - (radius * Math.cos(Math.PI * index / divisor));
	                        var anchor = void 0;
	                        var onRight = index === 1;
	                        var onBottom = false;
	                        if (position === 2 /* Bottom */) {
	                            // If this is a min or max label and we're showing them on the bottom rather than the sides
	                            // Adjust the label display properties to appear under the arc
	                            onBottom = true;
	                            y += padding;
	                            // Align the labels with the outer edge of the arc
	                            anchor = onRight ? 'end' : 'start';
	                            textProperties.text = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, radius);
	                        }
	                        else {
	                            // For all other labels, display around the arc
	                            anchor = onRight ? 'start' : 'end';
	                            x += padding * (onRight ? 1 : -1);
	                        }
	                        var text = this.mainGraphicsContext
	                            .append('text')
	                            .attr({
	                            'x': x,
	                            'y': y,
	                            'dy': onBottom ? fontSize : 0,
	                            'class': Gauge.LabelText.class
	                        })
	                            .style({
	                            'text-anchor': anchor,
	                            'font-size': fontSize
	                        })
	                            .text(textProperties.text)
	                            .append('title').text(textProperties.text);
	                        if (!onBottom)
	                            this.truncateTextIfNeeded(text, x, onRight);
	                    }
	                }
	            };
	            Gauge.prototype.truncateTextIfNeeded = function (text, positionX, onRight) {
	                var availableSpace = (onRight ? this.currentViewport.width - positionX : positionX);
	                text.call(visuals.AxisHelper.LabelLayoutStrategy.clip, availableSpace, powerbi.TextMeasurementService.svgEllipsis);
	            };
	            Gauge.prototype.getFormatter = function (dataLabelSettings, metadataColumn, maxValue) {
	                var max = dataLabelSettings.displayUnits === 0 ? maxValue : null;
	                if (!metadataColumn || !metadataColumn.objects || _.isEmpty(powerbi.DataViewObjects.getValue(metadataColumn.objects, Gauge.formatStringProp))) {
	                    metadataColumn = this.data.metadataColumn;
	                }
	                var formatString = visuals.valueFormatter.getFormatString(metadataColumn, Gauge.formatStringProp);
	                var precision = visuals.dataLabelUtils.getLabelPrecision(dataLabelSettings.precision, formatString);
	                var valueFormatterOptions = visuals.dataLabelUtils.getOptionsForLabelFormatter(dataLabelSettings, formatString, max, precision);
	                valueFormatterOptions.formatSingleValues = dataLabelSettings.displayUnits > 0 ? false : true;
	                return visuals.valueFormatter.create(valueFormatterOptions);
	            };
	            Gauge.prototype.renderTarget = function (radius, height, width, margin) {
	                var targetSettings = this.targetSettings;
	                var target = targetSettings.target;
	                var tRatio = this.getTargetRatio();
	                var top = (radius + (height - radius) / 2 + margin.top);
	                var flag = tRatio > 0.5;
	                var padding = this.settings.labels.padding;
	                var anchor = flag ? 'start' : 'end';
	                var formatter = this.getFormatter(this.data.dataLabelsSettings, this.data.targetColumnMetadata, targetSettings.max);
	                var maxRatio = Math.asin(Gauge.MinDistanceFromBottom / radius) / Math.PI;
	                var finalRatio = tRatio < maxRatio || tRatio > (1 - maxRatio)
	                    ? flag
	                        ? 1 - maxRatio
	                        : maxRatio
	                    : tRatio;
	                var targetX = (margin.left + width / 2) - ((radius + padding) * Math.cos(Math.PI * finalRatio));
	                var targetY = top - ((radius + padding) * Math.sin(Math.PI * finalRatio));
	                if (!this.targetText) {
	                    this.targetText = this.mainGraphicsContext
	                        .append('text')
	                        .classed(Gauge.TargetText.class, true);
	                }
	                this.targetText
	                    .attr({
	                    'x': targetX,
	                    'y': targetY,
	                })
	                    .style({
	                    'text-anchor': anchor,
	                    'display': this.showTargetLabel ? '' : 'none',
	                    'font-size': this.style.labelText.fontSize
	                })
	                    .text(formatter.format(target));
	                this.truncateTextIfNeeded(this.targetText, targetX, flag);
	                this.targetText.call(visuals.tooltipUtils.tooltipUpdate, [formatter.format(target)]);
	                if (!this.targetConnector) {
	                    this.targetConnector = this.mainGraphicsContext
	                        .append('line')
	                        .classed(Gauge.TargetConnector.class, true);
	                }
	                // Hide the target connector if the text is going to align with the target line in the arc
	                // It should only be shown if the target text is displaced (ex. when the target is very close to min/max)
	                if (tRatio === finalRatio) {
	                    this.targetConnector.style('display', 'none');
	                }
	                else {
	                    this.targetConnector
	                        .attr({
	                        'x1': (margin.left + width / 2) - (radius * Math.cos(Math.PI * tRatio)),
	                        'y1': top - (radius * Math.sin(Math.PI * tRatio)),
	                        'x2': targetX,
	                        'y2': targetY
	                    })
	                        .style({
	                        'stroke-width': this.settings.targetLine.thickness,
	                        'stroke': this.settings.targetLine.color,
	                        'display': ''
	                    });
	                }
	            };
	            Gauge.prototype.arcTween = function (transition, arr) {
	                transition.attrTween('d', function (d) {
	                    var interpolate = d3.interpolate(d.endAngle, arr[0]);
	                    return function (t) {
	                        d.endAngle = interpolate(t);
	                        return arr[1](d);
	                    };
	                });
	            };
	            Gauge.prototype.getLabelsPosition = function () {
	                if (!this.data || !this.data.dataLabelsSettings.show || _.isEmpty(this.labels)) {
	                    return 0 /* None */;
	                }
	                var textWidth = this.labels[0].size.width + this.labels[1].size.width;
	                var textHeight = this.labels[0].size.height;
	                if (this.currentViewport.height - textHeight > (this.currentViewport.width - textWidth) / 2) {
	                    return 2 /* Bottom */;
	                }
	                // We want to show the start/end ticks on the bottom when there
	                // is insufficient space for the left and right label text
	                if (this.gaugeVisualProperties) {
	                    var labels = this.labels;
	                    var visualWhitespace = (this.currentViewport.width - (this.gaugeVisualProperties.radius * 2)) / 2;
	                    var maxLabelWidth = visualWhitespace - this.settings.labels.padding;
	                    for (var _i = 0, labels_1 = labels; _i < labels_1.length; _i++) {
	                        var label = labels_1[_i];
	                        if (label.size.width > maxLabelWidth)
	                            return 2 /* Bottom */;
	                    }
	                }
	                return 1 /* LeftRight */;
	            };
	            Gauge.prototype.setMargins = function () {
	                // Used for mobile phones.
	                if (this.gaugeSmallViewPortProperties) {
	                    if (this.gaugeSmallViewPortProperties.smallGaugeMarginsOnSmallViewPort && (this.currentViewport.height < this.gaugeSmallViewPortProperties.MinHeightGaugeSideNumbersVisible)) {
	                        var margins = this.gaugeSmallViewPortProperties.GaugeMarginsOnSmallViewPort;
	                        this.margin = { top: margins, bottom: margins, left: margins, right: margins };
	                        return;
	                    }
	                }
	                var labelsPosition = this.getLabelsPosition();
	                this.margin = {
	                    bottom: 0,
	                    left: 0,
	                    right: 0,
	                    top: this.showTargetLabel ? Gauge.DefaultTopBottomMargin : 0
	                };
	                if (labelsPosition === 2 /* Bottom */) {
	                    this.margin.bottom = this.labels[0].size.height + this.settings.labels.padding * 2;
	                    if (this.showTargetLabel) {
	                        var targetSettings = this.targetSettings;
	                        // If we're showing the target label, only reduce the margin on the side that doesn't have a target label
	                        var tRatio = (targetSettings.target - targetSettings.min) / (targetSettings.max - targetSettings.min);
	                        if (tRatio > 0.5)
	                            this.margin.left = Gauge.ReducedLeftRightMargin;
	                        else
	                            this.margin.right = Gauge.ReducedLeftRightMargin;
	                    }
	                }
	                else if (labelsPosition === 1 /* LeftRight */) {
	                    var padding = this.settings.labels.padding * 2;
	                    this.margin.left = this.labels[0].size.width + padding;
	                    this.margin.right = this.labels[1].size.width + padding;
	                    this.margin.bottom = padding;
	                }
	            };
	            Gauge.prototype.showSideNumbersLabelText = function () {
	                if (this.gaugeSmallViewPortProperties) {
	                    if (this.gaugeSmallViewPortProperties.hideGaugeSideNumbersOnSmallViewPort) {
	                        if (this.currentViewport.height < this.gaugeSmallViewPortProperties.MinHeightGaugeSideNumbersVisible) {
	                            return false;
	                        }
	                    }
	                }
	                return true;
	            };
	            Gauge.MinDistanceFromBottom = 10;
	            Gauge.MinWidthForTargetLabel = 150;
	            Gauge.DefaultTopBottomMargin = 20;
	            Gauge.ReducedLeftRightMargin = 15;
	            Gauge.DEFAULT_MAX = 1;
	            Gauge.DEFAULT_MIN = 0;
	            Gauge.VisualClassName = 'gauge';
	            Gauge.DefaultStyleProperties = {
	                transition: {
	                    ease: 'cubic-in-out'
	                },
	                arcColors: {
	                    background: '#e9e9e9',
	                    foreground: '#00B8AA'
	                },
	                targetLine: {
	                    show: true,
	                    color: '#666666',
	                    thickness: 2
	                },
	                labels: {
	                    count: 2,
	                    padding: 5,
	                    fontSize: visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt,
	                },
	                kpiBands: {
	                    show: false,
	                    separationRadians: Math.PI / 128,
	                    thickness: 5
	                },
	            };
	            Gauge.DefaultTargetSettings = {
	                min: 0,
	                max: 1,
	                target: undefined
	            };
	            Gauge.DefaultDataPointSettings = {
	                fillColor: Gauge.DefaultStyleProperties.arcColors.foreground,
	                targetColor: Gauge.DefaultStyleProperties.targetLine.color
	            };
	            Gauge.InnerRadiusFactor = 0.7;
	            Gauge.KpiBandDistanceFromMainArc = 2;
	            Gauge.MainGaugeGroupClassName = 'mainGroup';
	            Gauge.LabelText = createClassAndSelector('labelText');
	            Gauge.TargetConnector = createClassAndSelector('targetConnector');
	            Gauge.TargetText = createClassAndSelector('targetText');
	            /** Note: Public for testability */
	            Gauge.formatStringProp = {
	                objectName: 'general',
	                propertyName: 'formatString',
	            };
	            return Gauge;
	        }());
	        visuals.Gauge = Gauge;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 263 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var Utility = jsCommon.Utility;
	        var ImageVisual = (function () {
	            function ImageVisual() {
	                this.scalingType = visuals.imageScalingType.normal;
	            }
	            ImageVisual.prototype.init = function (options) {
	                this.element = options.element;
	            };
	            ImageVisual.prototype.enumerateObjectInstances = function (options) {
	                switch (options.objectName) {
	                    case 'imageScaling':
	                        return this.enumerateImageScaling();
	                }
	                return null;
	            };
	            ImageVisual.prototype.enumerateImageScaling = function () {
	                return [{
	                        selector: null,
	                        objectName: 'imageScaling',
	                        properties: {
	                            imageScalingType: this.scalingType,
	                        }
	                    }];
	            };
	            ImageVisual.prototype.update = function (options) {
	                var dataViews = options.dataViews;
	                if (!dataViews || dataViews.length === 0)
	                    return;
	                var objects = dataViews[0].metadata.objects;
	                if (!objects || !objects.general)
	                    return;
	                var div = this.imageBackgroundElement;
	                if (!div) {
	                    div = $("<div class='imageBackground' />");
	                    this.imageBackgroundElement = div;
	                    this.imageBackgroundElement.appendTo(this.element);
	                }
	                var viewport = options.viewport;
	                div.css('height', viewport.height);
	                if (objects.imageScaling)
	                    this.scalingType = objects.imageScaling.imageScalingType.toString();
	                else
	                    this.scalingType = visuals.imageScalingType.normal;
	                var imageUrl = objects.general.imageUrl;
	                if (Utility.isLocalUrl(imageUrl))
	                    div.css("backgroundImage", "url(" + imageUrl + ")");
	                if (this.scalingType === visuals.imageScalingType.fit)
	                    div.css("background-size", "100% 100%");
	                else if (this.scalingType === visuals.imageScalingType.fill)
	                    div.css("background-size", "cover");
	                else
	                    div.css("background-size", "contain");
	            };
	            return ImageVisual;
	        }());
	        visuals.ImageVisual = ImageVisual;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 264 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var DataRoleHelper = powerbi.data.DataRoleHelper;
	        var KPIStatusWithHistory = (function () {
	            function KPIStatusWithHistory() {
	            }
	            KPIStatusWithHistory.prototype.init = function (options) {
	                KPIStatusWithHistory.getLocalizedString = options.host.getLocalizedString;
	                this.rootElement = d3.select(options.element.get(0)).append('div').attr('text-align', 'center').classed('kpiVisual', true);
	                this.svg = this.rootElement.append('svg');
	                var mainGroupElement = this.mainGroupElement = this.svg.append('g');
	                this.areaFill = mainGroupElement.append("path");
	                this.textContainer = this.rootElement.append("div").classed('textContainer', true);
	                this.indicatorTextContainer = this.textContainer.append("div").classed('indicatorText', true);
	                this.absoluteGoalDistanceText = this.textContainer.append("div").classed('goalText', true);
	                this.kpiActualText = this.indicatorTextContainer.append("div").attr('id', 'indicatorText');
	                this.initIcons();
	                this.host = options.host;
	            };
	            KPIStatusWithHistory.prototype.update = function (options) {
	                if (!options.dataViews || !options.dataViews[0])
	                    return;
	                var dataView = this.dataView = options.dataViews[0];
	                var viewport = options.viewport;
	                // We must have at least one measure
	                if ((!dataView.categorical || !dataView.categorical.values || dataView.categorical.values.length < 1) &&
	                    (!dataView.categorical || !dataView.categorical.categories || dataView.categorical.categories.length < 1)) {
	                    this.svg.attr("visibility", "hidden");
	                    this.textContainer.attr("style", "display:none");
	                    return;
	                }
	                this.svg.attr("visibility", "visible");
	                var kpiViewModel = KPIStatusWithHistory.converter(dataView, viewport, KPIStatusWithHistory.getProp_KPIDirection(dataView));
	                this.render(kpiViewModel, viewport);
	            };
	            KPIStatusWithHistory.prototype.initIcons = function () {
	                this.successMarkIcon = this.indicatorTextContainer.append("div").classed('powervisuals-glyph checkmark kpi-visual-green', true);
	                this.betweenIcon = this.indicatorTextContainer.append('div').classed('powervisuals-glyph circle-small kpi-visual-yellow', true);
	                this.exclamationMarkIcon = this.indicatorTextContainer.append("div").classed('powervisuals-glyph exclamation kpi-visual-red', true);
	                this.successMarkIcon.attr('style', 'display:none');
	                this.betweenIcon.attr('style', 'display:none');
	                this.exclamationMarkIcon.attr('style', 'display:none');
	            };
	            KPIStatusWithHistory.prototype.render = function (kpiViewModel, viewport) {
	                this.setShowDataMissingWarning(!(kpiViewModel.indicatorExists && kpiViewModel.trendExists));
	                if (kpiViewModel.dataPoints.length === 0 || !kpiViewModel.indicatorExists || !kpiViewModel.trendExists) {
	                    this.areaFill.attr("visibility", "hidden");
	                    this.svg.attr("visibility", "hidden");
	                    this.textContainer.attr("style", "display:none");
	                    return;
	                }
	                this.svg.attr({
	                    'height': viewport.height,
	                    'width': viewport.width,
	                });
	                var status = KPIStatusWithHistory.status.NOGOAL;
	                if (kpiViewModel.targetExists && kpiViewModel.indicatorExists && kpiViewModel.trendExists) {
	                    status = GetStatus(kpiViewModel.actual, kpiViewModel.goals, kpiViewModel.directionType);
	                }
	                var actualText = kpiViewModel.formattedValue;
	                var calculatedHeight = KPIStatusWithHistory.indicatorTextSizeInPx;
	                this.textContainer
	                    .attr('style', "width:" + viewport.width + "px;" +
	                    "top:" + ((viewport.height - calculatedHeight) / 2) + "px");
	                this.kpiActualText
	                    .classed(KPIStatusWithHistory.allColorClasses, false)
	                    .classed(GetTextColorClassByStatus(status), true)
	                    .attr("text-anchor", "middle")
	                    .text(actualText);
	                var icon = null;
	                switch (status) {
	                    case KPIStatusWithHistory.status.INCREASE:
	                        icon = this.successMarkIcon;
	                        this.exclamationMarkIcon.attr("style", "display:none");
	                        this.betweenIcon.attr("style", "display:none");
	                        break;
	                    case KPIStatusWithHistory.status.IN_BETWEEN:
	                        icon = this.betweenIcon;
	                        this.exclamationMarkIcon.attr("style", "display:none");
	                        this.successMarkIcon.attr("style", "display:none");
	                        break;
	                    case KPIStatusWithHistory.status.DROP:
	                        icon = this.exclamationMarkIcon;
	                        this.successMarkIcon.attr("style", "display:none");
	                        this.betweenIcon.attr("style", "display:none");
	                        break;
	                    default:
	                        this.exclamationMarkIcon.attr("style", "display:none");
	                        this.successMarkIcon.attr("style", "display:none");
	                        this.betweenIcon.attr("style", "display:none");
	                }
	                if (icon) {
	                    icon.attr('style', 'font-size:12px');
	                }
	                var shownGoalString = kpiViewModel.showGoal ? kpiViewModel.formattedGoalString + " " : "";
	                var shownDistanceFromGoalString = kpiViewModel.showDistanceFromGoal ? getDistanceFromGoalInPercentageString(kpiViewModel.actual, kpiViewModel.goals, kpiViewModel.directionType) : "";
	                this.absoluteGoalDistanceText
	                    .attr("text-anchor", "middle")
	                    .text(shownGoalString + shownDistanceFromGoalString);
	                if (kpiViewModel.showTrendLine && kpiViewModel.historyExists) {
	                    var area = d3.svg.area()
	                        .x(function (d) { return d.x; })
	                        .y0(viewport.height)
	                        .y1(function (d) { return d.y; });
	                    this.areaFill
	                        .classed(KPIStatusWithHistory.allColorClasses, false)
	                        .classed(GetGraphColorClassByStatus(status), true)
	                        .attr("d", area(kpiViewModel.dataPoints))
	                        .attr("stroke", "none")
	                        .attr("visibility", "visible")
	                        .attr('fill-opacity', 0.2);
	                }
	                else {
	                    this.areaFill.attr("visibility", "hidden");
	                }
	            };
	            KPIStatusWithHistory.prototype.setShowDataMissingWarning = function (show) {
	                this.host.setWarnings(show ? [new visuals.VisualKPIDataMissingWarning()] : []);
	            };
	            KPIStatusWithHistory.getDefaultFormatSettings = function () {
	                return {
	                    labelSettings: visuals.dataLabelUtils.getDefaultLabelSettings(true, visuals.Card.DefaultStyle.value.color),
	                    textSize: 27,
	                    wordWrap: false
	                };
	            };
	            KPIStatusWithHistory.getFormatString = function (column) {
	                debug.assertAnyValue(column, 'column');
	                return visuals.valueFormatter.getFormatString(column, visuals.AnimatedText.formatStringProp);
	            };
	            KPIStatusWithHistory.getProp_Show_KPIGoal = function (dataView) {
	                if (dataView && dataView.metadata) {
	                    return powerbi.DataViewObjects.getValue(dataView.metadata.objects, KPIStatusWithHistory.showKPIGoal, true);
	                }
	                return true;
	            };
	            KPIStatusWithHistory.getProp_Show_KPITrendLine = function (dataView) {
	                if (dataView && dataView.metadata) {
	                    return powerbi.DataViewObjects.getValue(dataView.metadata.objects, KPIStatusWithHistory.showKPITrendLine, true);
	                }
	                return true;
	            };
	            KPIStatusWithHistory.getProp_Show_KPIDistance = function (dataView) {
	                if (dataView && dataView.metadata) {
	                    return powerbi.DataViewObjects.getValue(dataView.metadata.objects, KPIStatusWithHistory.showKPIDistance, true);
	                }
	                return true;
	            };
	            KPIStatusWithHistory.getProp_KPIDirection = function (dataView) {
	                if (dataView && dataView.metadata) {
	                    return powerbi.DataViewObjects.getValue(dataView.metadata.objects, KPIStatusWithHistory.directionTypeStringProp, visuals.kpiDirection.positive);
	                }
	                return visuals.kpiDirection.positive;
	            };
	            KPIStatusWithHistory.getProp_Indicator_DisplayUnits = function (dataView) {
	                KPIStatusWithHistory.initDefaultLabelSettings();
	                if (dataView && dataView.metadata) {
	                    return powerbi.DataViewObjects.getValue(dataView.metadata.objects, KPIStatusWithHistory.indicatorDisplayUnitsProp, KPIStatusWithHistory.defaultLabelSettings.displayUnits);
	                }
	                return KPIStatusWithHistory.defaultLabelSettings.displayUnits;
	            };
	            KPIStatusWithHistory.getProp_Indicator_Precision = function (dataView) {
	                KPIStatusWithHistory.initDefaultLabelSettings();
	                if (dataView && dataView.metadata) {
	                    return powerbi.DataViewObjects.getValue(dataView.metadata.objects, KPIStatusWithHistory.indicatorPrecisionProp, KPIStatusWithHistory.defaultLabelSettings.precision);
	                }
	                return KPIStatusWithHistory.defaultLabelSettings.precision;
	            };
	            KPIStatusWithHistory.initDefaultLabelSettings = function () {
	                if (!KPIStatusWithHistory.defaultCardFormatSetting) {
	                    KPIStatusWithHistory.defaultCardFormatSetting = KPIStatusWithHistory.getDefaultFormatSettings();
	                    KPIStatusWithHistory.defaultLabelSettings = KPIStatusWithHistory.defaultCardFormatSetting.labelSettings;
	                }
	            };
	            KPIStatusWithHistory.getFormattedValue = function (metaDataColumn, theValue, precision, displayUnits, displayUnitSystemType) {
	                if (displayUnitSystemType === void 0) { displayUnitSystemType = powerbi.DisplayUnitSystemType.WholeUnits; }
	                var isDefaultDisplayUnit = displayUnits === 0;
	                var formatter = visuals.valueFormatter.create({
	                    format: KPIStatusWithHistory.getFormatString(metaDataColumn),
	                    value: displayUnits,
	                    precision: precision,
	                    displayUnitSystemType: displayUnitSystemType,
	                    formatSingleValues: isDefaultDisplayUnit ? true : false,
	                    allowFormatBeautification: true,
	                    columnType: metaDataColumn ? metaDataColumn.type : undefined
	                });
	                return formatter.format(theValue);
	            };
	            KPIStatusWithHistory.getFormattedGoalString = function (metaDataColumn, goals, precision, displayUnits) {
	                if (!goals || goals.length === 0) {
	                    return "";
	                }
	                var goalsString = KPIStatusWithHistory.getLocalizedString('Visual_KPI_Goal_Title') + ": " + KPIStatusWithHistory.getFormattedValue(metaDataColumn, goals[0], precision, displayUnits);
	                if (goals.length === 2) {
	                    goalsString += ", " + KPIStatusWithHistory.getFormattedValue(metaDataColumn, goals[1], precision, displayUnits);
	                }
	                return goalsString;
	            };
	            KPIStatusWithHistory.converter = function (dataView, viewPort, directionType) {
	                var dataPoints = [];
	                var catDv = dataView.categorical;
	                var indicatorMetadataColumn = null;
	                var goalMetadataColumn = null;
	                var formattedGoalString = "";
	                var formattedValue = "";
	                var targetExists = false;
	                var indicatorExists = false;
	                var trendExists = false;
	                var historyExists = true;
	                if (!dataView.categorical.categories) {
	                    historyExists = false;
	                }
	                var values = catDv.values;
	                var columns = dataView.metadata.columns;
	                for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {
	                    var column = columns_1[_i];
	                    if (DataRoleHelper.hasRole(column, 'Indicator')) {
	                        indicatorExists = true;
	                        indicatorMetadataColumn = column;
	                    }
	                    if (DataRoleHelper.hasRole(column, 'TrendLine')) {
	                        trendExists = true;
	                    }
	                    if (DataRoleHelper.hasRole(column, 'Goal')) {
	                        targetExists = true;
	                        goalMetadataColumn = column;
	                    }
	                }
	                if (!indicatorExists || !trendExists || !values || values.length === 0 || !values[0].values || !dataView.categorical.values) {
	                    return {
	                        dataPoints: dataPoints,
	                        directionType: directionType,
	                        actual: 0,
	                        goals: [],
	                        formattedGoalString: formattedGoalString,
	                        targetExists: targetExists,
	                        historyExists: historyExists,
	                        indicatorExists: indicatorExists,
	                        trendExists: trendExists,
	                        formattedValue: formattedValue,
	                        showGoal: false,
	                        showDistanceFromGoal: false,
	                        showTrendLine: false
	                    };
	                }
	                var category, categoryValues;
	                if (historyExists) {
	                    category = catDv.categories[0]; // This only works if we have a category axis
	                    categoryValues = category.values;
	                }
	                var historyActualData = [];
	                var historyGoalData = [];
	                var indicatorColumns = KPIStatusWithHistory.getColumnsByRole(values, "Indicator");
	                var goalColumns = KPIStatusWithHistory.getColumnsByRole(values, "Goal");
	                var actualValue;
	                for (var i = 0, len = values[0].values.length; i < len; i++) {
	                    actualValue = indicatorColumns[0].values[i];
	                    var goals_1 = [];
	                    for (var goalCnt = 0; goalCnt < goalColumns.length; goalCnt++) {
	                        goals_1.push(goalColumns[goalCnt].values[i]);
	                    }
	                    historyGoalData.push(goals_1);
	                    historyActualData.push(actualValue);
	                }
	                var maxActualData = Math.max.apply(Math, historyActualData);
	                var minActualData = Math.min.apply(Math, historyActualData);
	                var areaMaxHight = viewPort.height * KPIStatusWithHistory.trendAreaFilePercentage;
	                var precision = KPIStatusWithHistory.getProp_Indicator_Precision(dataView);
	                var displayUnits = KPIStatusWithHistory.getProp_Indicator_DisplayUnits(dataView);
	                for (var i = 0; i < historyActualData.length; i++) {
	                    var yPos = areaMaxHight * (historyActualData[i] - minActualData) / (maxActualData - minActualData);
	                    var selectorId = null;
	                    if (historyExists) {
	                        selectorId = visuals.SelectionId.createWithId(category.identity[i]).getSelector();
	                    }
	                    dataPoints.push({
	                        x: i * viewPort.width / (historyActualData.length - 1),
	                        y: viewPort.height - yPos,
	                        actual: historyActualData[i],
	                        goals: historyGoalData[i],
	                    });
	                }
	                var actual, goals;
	                if (dataPoints.length > 0) {
	                    actual = dataPoints[dataPoints.length - 1].actual;
	                    goals = dataPoints[dataPoints.length - 1].goals;
	                }
	                if (dataPoints.length === 1) {
	                    historyExists = false;
	                }
	                formattedValue = KPIStatusWithHistory.getFormattedValue(indicatorMetadataColumn, actual, precision, displayUnits, powerbi.DisplayUnitSystemType.DataLabels);
	                formattedGoalString = KPIStatusWithHistory.getFormattedGoalString(goalMetadataColumn, goals, precision, displayUnits);
	                var showGoal = KPIStatusWithHistory.getProp_Show_KPIGoal(dataView);
	                var showDistanceFromGoal = KPIStatusWithHistory.getProp_Show_KPIDistance(dataView);
	                var showTrendLine = KPIStatusWithHistory.getProp_Show_KPITrendLine(dataView);
	                return {
	                    dataPoints: dataPoints,
	                    directionType: directionType,
	                    actual: actual,
	                    goals: goals,
	                    formattedGoalString: formattedGoalString,
	                    targetExists: targetExists,
	                    historyExists: historyExists,
	                    indicatorExists: indicatorExists,
	                    trendExists: trendExists,
	                    formattedValue: formattedValue,
	                    showGoal: showGoal,
	                    showDistanceFromGoal: showDistanceFromGoal,
	                    showTrendLine: showTrendLine
	                };
	            };
	            KPIStatusWithHistory.getColumnsByRole = function (values, roleString) {
	                var retval = [];
	                for (var i = 0; i < values.length; i++) {
	                    if (DataRoleHelper.hasRole(values[i].source, roleString)) {
	                        retval.push(values[i]);
	                    }
	                }
	                return retval;
	            };
	            KPIStatusWithHistory.prototype.enumerateObjectInstances = function (options) {
	                var instances = [];
	                var dataView = this.dataView;
	                switch (options.objectName) {
	                    case 'indicator':
	                        instances.push({
	                            selector: null,
	                            objectName: 'indicator',
	                            properties: {
	                                indicatorDisplayUnits: KPIStatusWithHistory.getProp_Indicator_DisplayUnits(dataView),
	                                indicatorPrecision: KPIStatusWithHistory.getProp_Indicator_Precision(dataView)
	                            }
	                        });
	                    case 'trendline':
	                        instances.push({
	                            selector: null,
	                            objectName: 'trendline',
	                            properties: {
	                                show: KPIStatusWithHistory.getProp_Show_KPITrendLine(dataView)
	                            }
	                        });
	                    case 'goals':
	                        instances.push({
	                            selector: null,
	                            objectName: 'goals',
	                            properties: {
	                                showGoal: KPIStatusWithHistory.getProp_Show_KPIGoal(dataView),
	                                showDistance: KPIStatusWithHistory.getProp_Show_KPIDistance(dataView)
	                            }
	                        });
	                    case 'status':
	                        instances.push({
	                            selector: null,
	                            objectName: 'status',
	                            properties: {
	                                direction: KPIStatusWithHistory.getProp_KPIDirection(dataView)
	                            }
	                        });
	                }
	                return instances;
	            };
	            KPIStatusWithHistory.prototype.destroy = function () {
	                this.svg = null;
	            };
	            KPIStatusWithHistory.directionTypeStringProp = { objectName: 'status', propertyName: 'direction' };
	            KPIStatusWithHistory.showKPIGoal = { objectName: 'goals', propertyName: 'showGoal' };
	            KPIStatusWithHistory.showKPIDistance = { objectName: 'goals', propertyName: 'showDistance' };
	            KPIStatusWithHistory.showKPITrendLine = { objectName: 'trendline', propertyName: 'show' };
	            KPIStatusWithHistory.indicatorDisplayUnitsProp = { objectName: 'indicator', propertyName: 'indicatorDisplayUnits' };
	            KPIStatusWithHistory.indicatorPrecisionProp = { objectName: 'indicator', propertyName: 'indicatorPrecision' };
	            KPIStatusWithHistory.status = { INCREASE: "increase", DROP: "drop", IN_BETWEEN: "in-between", NOGOAL: "no-goal" };
	            KPIStatusWithHistory.statusBandingType = { Below: "BELOW", Above: "ABOVE" };
	            KPIStatusWithHistory.actualTextConsts = { VERTICAL_OFFSET_FROM_HALF_HEIGHT: 20, FONT_WIDTH_FACTOR: 14, RIGHT_MARGIN: 10 };
	            KPIStatusWithHistory.kpiRedClass = 'kpi-visual-red';
	            KPIStatusWithHistory.kpiYellowClass = 'kpi-visual-yellow';
	            KPIStatusWithHistory.kpiGreenClass = 'kpi-visual-green';
	            KPIStatusWithHistory.kpiTextGreyClass = 'kpi-visual-text-grey';
	            KPIStatusWithHistory.kpiGraphGreyClass = 'kpi-visual-graph-grey';
	            KPIStatusWithHistory.allColorClasses = KPIStatusWithHistory.kpiRedClass + ' ' + KPIStatusWithHistory.kpiYellowClass + ' ' + KPIStatusWithHistory.kpiGreenClass + ' ' + KPIStatusWithHistory.kpiTextGreyClass + ' ' + KPIStatusWithHistory.kpiGraphGreyClass;
	            KPIStatusWithHistory.trendAreaFilePercentage = 1;
	            KPIStatusWithHistory.estimatedIconHeightInPx = 9;
	            KPIStatusWithHistory.indicatorTextSizeInPx = 60;
	            return KPIStatusWithHistory;
	        }());
	        visuals.KPIStatusWithHistory = KPIStatusWithHistory;
	        function GetStatus(actual, goals, directionType) {
	            if (!goals || goals.length === 0) {
	                return KPIStatusWithHistory.status.NOGOAL;
	            }
	            var maxGoal, minGoal;
	            if (goals.length === 2) {
	                maxGoal = Math.max.apply(Math, goals);
	                minGoal = Math.min.apply(Math, goals);
	                if (actual >= minGoal && actual <= maxGoal) {
	                    return KPIStatusWithHistory.status.IN_BETWEEN;
	                }
	            }
	            else {
	                maxGoal = goals[0];
	                minGoal = goals[0];
	            }
	            switch (directionType) {
	                case visuals.kpiDirection.positive:
	                    if (actual < minGoal) {
	                        return KPIStatusWithHistory.status.DROP;
	                    }
	                    break;
	                case visuals.kpiDirection.negative:
	                    if (actual > maxGoal) {
	                        return KPIStatusWithHistory.status.DROP;
	                    }
	                    break;
	                default:
	                    break;
	            }
	            return KPIStatusWithHistory.status.INCREASE;
	        }
	        function getDistanceFromGoalInPercentageString(actual, goals, directionType) {
	            if (!goals || goals.length !== 1 || goals[0] === 0) {
	                return "";
	            }
	            var sign = "+";
	            var distance;
	            var goal = goals[0];
	            distance = Math.abs(actual - goal);
	            switch (directionType) {
	                case visuals.kpiDirection.positive:
	                    if (actual < goal) {
	                        sign = "-";
	                    }
	                    break;
	                case visuals.kpiDirection.negative:
	                    if (actual > goal) {
	                        sign = "-";
	                    }
	                    break;
	            }
	            var percent = Number((100 * distance / goal).toFixed(2));
	            return "(" + sign + percent + "%)";
	        }
	        function GetTextColorClassByStatus(status) {
	            switch (status) {
	                case KPIStatusWithHistory.status.NOGOAL:
	                    return KPIStatusWithHistory.kpiTextGreyClass;
	                case KPIStatusWithHistory.status.INCREASE:
	                    return KPIStatusWithHistory.kpiGreenClass;
	                case KPIStatusWithHistory.status.IN_BETWEEN:
	                    return KPIStatusWithHistory.kpiYellowClass;
	                case KPIStatusWithHistory.status.DROP:
	                    return KPIStatusWithHistory.kpiRedClass;
	            }
	        }
	        function GetGraphColorClassByStatus(status) {
	            switch (status) {
	                case KPIStatusWithHistory.status.NOGOAL:
	                    return KPIStatusWithHistory.kpiGraphGreyClass;
	                case KPIStatusWithHistory.status.INCREASE:
	                    return KPIStatusWithHistory.kpiGreenClass;
	                case KPIStatusWithHistory.status.IN_BETWEEN:
	                    return KPIStatusWithHistory.kpiYellowClass;
	                case KPIStatusWithHistory.status.DROP:
	                    return KPIStatusWithHistory.kpiRedClass;
	            }
	        }
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 265 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var EnumExtensions = jsCommon.EnumExtensions;
	        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
	        var PixelConverter = jsCommon.PixelConverter;
	        ;
	        /**
	         * Renders a data series as a line visual.
	         */
	        var LineChart = (function () {
	            function LineChart(options) {
	                var _this = this;
	                this.pathXAdjustment = 0;
	                this.deferDragMoveOperation = jsCommon.DeferUtility.deferUntilNextFrame(function () {
	                    if (_this.lastDragMoveXPosition) {
	                        var index = _this.findIndex(_this.lastDragMoveXPosition - _this.margin.left);
	                        _this.selectColumn(index);
	                        _this.lastDragMoveXPosition = undefined;
	                    }
	                });
	                this.isScrollable = options.isScrollable ? options.isScrollable : false;
	                this.tooltipsEnabled = options.tooltipsEnabled;
	                this.lineType = options.chartType ? options.chartType : 1 /* default */;
	                this.interactivityService = options.interactivityService;
	                this.animator = options.animator;
	                this.lineClassAndSelector = LineChart.LineClassSelector;
	                this.tooltipBucketEnabled = options.tooltipBucketEnabled;
	                this.advancedLineLabelsEnabled = options.advancedLineLabelsEnabled;
	            }
	            LineChart.customizeQuery = function (options) {
	                var dataViewMapping = options.dataViewMappings[0];
	                if (!dataViewMapping || !dataViewMapping.categorical || !dataViewMapping.categorical.categories)
	                    return;
	                dataViewMapping.categorical.dataVolume = 4;
	                var dataViewCategories = dataViewMapping.categorical.categories;
	                // Opt in to scalar key
	                var usingScalarKey = false;
	                var roleItems = dataViewCategories.for.in.items;
	                if (roleItems && LineChart.shouldUseScalarKey(dataViewMapping, roleItems)) {
	                    for (var _i = 0, roleItems_1 = roleItems; _i < roleItems_1.length; _i++) {
	                        var item = roleItems_1[_i];
	                        if (item.hasScalarKey) {
	                            item.scalarKeyMinProperty = visuals.lineChartProps.scalarKey.scalarKeyMin;
	                            usingScalarKey = true;
	                            break;
	                        }
	                    }
	                }
	                if (visuals.CartesianChart.detectScalarMapping(dataViewMapping) || usingScalarKey) {
	                    dataViewCategories.dataReductionAlgorithm = { sample: {} };
	                    var values = dataViewMapping.categorical.values;
	                    if (values && values.group) {
	                        values.group.dataReductionAlgorithm = { top: {} };
	                    }
	                }
	                else {
	                    _.remove(options.dataViewMappings, function (dataViewMapping) { return dataViewMapping.usage && dataViewMapping.usage.forecast; });
	                    visuals.CartesianChart.expandCategoryWindow([dataViewMapping]);
	                }
	            };
	            LineChart.shouldUseScalarKey = function (dataViewMapping, categoryRoleItems) {
	                // If explicitly categorical axis, no scalar keys
	                var axisTypeValue = powerbi.DataViewObjects.getValue(dataViewMapping.metadata.objects, visuals.lineChartProps.categoryAxis.axisType);
	                if (axisTypeValue === visuals.axisType.categorical)
	                    return false;
	                // If we are sorting by something other than this group, the scalar key is of no value
	                var columns = dataViewMapping.metadata && dataViewMapping.metadata.columns;
	                var sortedColumns;
	                if (columns)
	                    sortedColumns = _.filter(columns, function (c) { return c.sort !== undefined; });
	                if (!_.isEmpty(sortedColumns)) {
	                    // If we are sorting by something other than category, we won't be positioning by scalar key
	                    if (_.any(sortedColumns, function (c) { return !_.find(categoryRoleItems, function (ri) { return c.queryName === ri.queryName; }); }))
	                        return false;
	                    // Make sure all of the sorted items are in the same direction, otherwise a scalar key won't make sense
	                    if (_.any(sortedColumns, function (c) { return c.sort !== sortedColumns[0].sort; }))
	                        return false;
	                }
	                return true;
	            };
	            LineChart.getSortableRoles = function (options) {
	                var dataViewMapping = options.dataViewMappings[0];
	                if (!dataViewMapping || !dataViewMapping.categorical || !dataViewMapping.categorical.categories)
	                    return null;
	                var dataViewCategories = dataViewMapping.categorical.categories;
	                var categoryItems = dataViewCategories.for.in.items;
	                if (!_.isEmpty(categoryItems)) {
	                    var categoryType = categoryItems[0].type;
	                    var objects = void 0;
	                    if (dataViewMapping.metadata)
	                        objects = dataViewMapping.metadata.objects;
	                    //TODO: line chart should be sortable by X if it has scalar axis
	                    // But currently it doesn't support this. Always return 'category'
	                    // once it is supported.
	                    if (!visuals.CartesianChart.getIsScalar(objects, visuals.lineChartProps.categoryAxis.axisType, categoryType))
	                        return ['Category', 'Y'];
	                }
	                return null;
	            };
	            LineChart.converter = function (dataView, blankCategoryValue, colors, isScalar, interactivityService, shouldCalculateStacked, isComboChart, tooltipsEnabled, tooltipBucketEnabled) {
	                if (tooltipsEnabled === void 0) { tooltipsEnabled = true; }
	                if (tooltipBucketEnabled === void 0) { tooltipBucketEnabled = false; }
	                var reader = powerbi.data.createIDataViewCategoricalReader(dataView);
	                var valueRoleName = isComboChart ? 'Y2' : 'Y';
	                var categorical = dataView.categorical;
	                var category = categorical.categories && categorical.categories.length > 0
	                    ? categorical.categories[0]
	                    : {
	                        source: undefined,
	                        values: [blankCategoryValue],
	                        identity: undefined,
	                    };
	                var xAxisCardProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataView.metadata);
	                isScalar = visuals.CartesianHelper.isScalar(isScalar, xAxisCardProperties);
	                var scalarKeys = LineChart.getScalarKeys(category);
	                var useScalarKeys = isScalar && scalarKeys && !_.isEmpty(scalarKeys.values);
	                // if scalar and scalar keys defined, use scalar keys for xAxis labels
	                var scalarMetadataColumn;
	                if (useScalarKeys)
	                    scalarMetadataColumn = {
	                        displayName: null,
	                        type: {
	                            dateTime: true
	                        },
	                    };
	                categorical = visuals.ColumnUtil.applyUserMinMax(isScalar, categorical, xAxisCardProperties);
	                var formatStringProp = visuals.lineChartProps.general.formatString;
	                var categoryType = visuals.AxisHelper.getCategoryValueType(category.source, isScalar);
	                var isDateTime = visuals.AxisHelper.isDateTime(categoryType);
	                var categoryValues = category.values;
	                var categoryData = [];
	                var categoryIdentities = [];
	                var series = [];
	                var seriesCount = reader.getSeriesCount(valueRoleName);
	                var hasDynamicSeries = !!(categorical.values && categorical.values.source);
	                var values = categorical.values;
	                var defaultLabelSettings = visuals.dataLabelUtils.getDefaultLineChartLabelSettings(isComboChart);
	                var defaultSeriesColor;
	                if (dataView.metadata && dataView.metadata.objects) {
	                    var objects = dataView.metadata.objects;
	                    // If the line layer is in a combo chart, the "Default Column Color" slice's value (lineChartProps.dataPoint.defaultColor) will not affect the line series as well
	                    defaultSeriesColor = isComboChart ? undefined : powerbi.DataViewObjects.getFillColor(objects, visuals.lineChartProps.dataPoint.defaultColor);
	                    var labelsObj = objects['labels'];
	                    visuals.dataLabelUtils.updateLineChartLabelSettingsFromLabelsObject(labelsObj, defaultLabelSettings);
	                }
	                var colorHelper = new visuals.ColorHelper(colors, visuals.lineChartProps.dataPoint.fill, defaultSeriesColor);
	                var grouped;
	                if (dataView.categorical.values)
	                    grouped = dataView.categorical.values.grouped();
	                var stackedValues;
	                if (shouldCalculateStacked) {
	                    //initialize array with zeros
	                    stackedValues = categorical.values && categorical.values.length > 0 ? _.times(categorical.values[0].values.length, function () { return 0; }) : [];
	                }
	                if (reader.hasValues(valueRoleName)) {
	                    for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
	                        var column = reader.getValueColumn(valueRoleName, seriesIndex);
	                        var valuesMetadata = column.source;
	                        var dataPoints = [];
	                        var groupedIdentity = grouped[seriesIndex];
	                        var identity = visuals.SelectionIdBuilder.builder()
	                            .withSeries(categorical.values, column)
	                            .withMeasure(reader.getValueMetadataColumn(valueRoleName, seriesIndex).queryName)
	                            .createSelectionId();
	                        var key = identity.getKey();
	                        var color = this.getColor(colorHelper, hasDynamicSeries, values, grouped, seriesIndex, groupedIdentity);
	                        var seriesLabelSettings = void 0;
	                        if (!hasDynamicSeries) {
	                            var labelsSeriesGroup = grouped && grouped.length > 0 && grouped[0].values ? grouped[0].values[seriesIndex] : null;
	                            var labelObjects = (labelsSeriesGroup && labelsSeriesGroup.source && labelsSeriesGroup.source.objects) ? labelsSeriesGroup.source.objects['labels'] : null;
	                            if (labelObjects) {
	                                seriesLabelSettings = powerbi.Prototype.inherit(defaultLabelSettings);
	                                visuals.dataLabelUtils.updateLineChartLabelSettingsFromLabelsObject(labelObjects, seriesLabelSettings);
	                            }
	                        }
	                        var dataPointLabelSettings = (seriesLabelSettings) ? seriesLabelSettings : defaultLabelSettings;
	                        var useHighlightValues = column.highlights && column.highlights.length > 0;
	                        var categoryCount = reader.hasCategories() ? reader.getCategoryCount() : 1;
	                        // NOTE: line capabilities don't allow highlights, but comboChart does - so only use highlight values if we are in "combo" mode
	                        for (var categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) {
	                            var categoryValue = categoryValues[categoryIndex];
	                            var xAxisValue = useScalarKeys ? scalarKeys.values[categoryIndex].min : categoryValue;
	                            var value = visuals.AxisHelper.normalizeNonFiniteNumber(useHighlightValues ? reader.getHighlight(valueRoleName, categoryIndex, seriesIndex) : reader.getValue(valueRoleName, categoryIndex, seriesIndex));
	                            // When Scalar, skip null categories and null values so we draw connected lines and never draw isolated dots.
	                            if (isScalar && (xAxisValue == null || value == null))
	                                continue;
	                            // ignore variant measures
	                            if (isDateTime && categoryValue != null && !(categoryValue instanceof Date))
	                                continue;
	                            var categorical_1 = dataView.categorical;
	                            var tooltipInfo = void 0;
	                            var extraTooltipInfo = void 0;
	                            if (tooltipsEnabled) {
	                                // This tooltip is using in combo chart and mobile tooltip.
	                                tooltipInfo = [];
	                                if (category.source) {
	                                    tooltipInfo.push({
	                                        displayName: category.source.displayName,
	                                        value: visuals.converterHelper.formatFromMetadataColumn(categoryValue, category.source, formatStringProp),
	                                    });
	                                }
	                                // This dynamicSeries tooltip is only using in mobile tooltip.
	                                if (hasDynamicSeries) {
	                                    if (!category.source || category.source !== categorical_1.values.source) {
	                                        // Category/series on the same column -- don't repeat its value in the tooltip.
	                                        tooltipInfo.push({
	                                            displayName: categorical_1.values.source.displayName,
	                                            value: visuals.converterHelper.formatFromMetadataColumn(grouped[seriesIndex].name, categorical_1.values.source, formatStringProp),
	                                        });
	                                    }
	                                }
	                                if (value != null) {
	                                    tooltipInfo.push({
	                                        displayName: valuesMetadata.displayName,
	                                        value: visuals.converterHelper.formatFromMetadataColumn(value, valuesMetadata, formatStringProp),
	                                    });
	                                }
	                                if (tooltipBucketEnabled) {
	                                    extraTooltipInfo = [];
	                                    visuals.TooltipBuilder.addTooltipBucketItem(reader, extraTooltipInfo, categoryIndex, hasDynamicSeries ? seriesIndex : undefined);
	                                }
	                            }
	                            var idBuilder = new visuals.SelectionIdBuilder();
	                            if (reader.hasCategories()) {
	                                idBuilder = idBuilder.withCategory(reader.getCategoryColumn("Category"), categoryIndex);
	                            }
	                            if (hasDynamicSeries) {
	                                idBuilder = idBuilder.withSeries(dataView.categorical.values, reader.getValueColumn(valueRoleName, seriesIndex));
	                            }
	                            var specificIdentity = idBuilder
	                                .withMeasure(reader.getValueMetadataColumn(valueRoleName, seriesIndex).queryName)
	                                .createSelectionId();
	                            var categoryKey = category && !_.isEmpty(category.identity) && category.identity[categoryIndex] ? category.identity[categoryIndex].key : categoryIndex;
	                            var dataPoint = {
	                                categoryValue: ((isDateTime || useScalarKeys) && xAxisValue) ? xAxisValue.getTime() : xAxisValue,
	                                value: value,
	                                categoryIndex: categoryIndex,
	                                seriesIndex: seriesIndex,
	                                tooltipInfo: tooltipInfo,
	                                selected: false,
	                                identity: identity,
	                                specificIdentity: specificIdentity,
	                                key: JSON.stringify({ series: key, category: categoryKey }),
	                                labelFill: dataPointLabelSettings.labelColor,
	                                labelFormatString: valuesMetadata.format,
	                                labelSettings: dataPointLabelSettings,
	                                extraTooltipInfo: extraTooltipInfo,
	                            };
	                            if (shouldCalculateStacked) {
	                                stackedValues[categoryIndex] += value;
	                                dataPoint.stackedValue = stackedValues[categoryIndex];
	                            }
	                            if (category.objects && category.objects[categoryIndex]) {
	                                dataPoint['pointColor'] = powerbi.DataViewObjects.getFillColor(category.objects[categoryIndex], visuals.lineChartProps.dataPoint.fill);
	                            }
	                            dataPoints.push(dataPoint);
	                            if (!categoryData[categoryIndex]) {
	                                categoryData[categoryIndex] = dataPoint;
	                            }
	                            if (!categoryIdentities[categoryIndex] && reader.hasCategories()) {
	                                var categoryIdBuilder = new visuals.SelectionIdBuilder();
	                                categoryIdentities[categoryIndex] = categoryIdBuilder
	                                    .withCategory(reader.getCategoryColumn("Category"), categoryIndex)
	                                    .withMeasure(reader.getValueMetadataColumn(valueRoleName, seriesIndex).queryName)
	                                    .createSelectionId();
	                            }
	                        }
	                        if (interactivityService) {
	                            interactivityService.applySelectionStateToData(dataPoints);
	                        }
	                        if (dataPoints.length > 0) {
	                            series.push({
	                                displayName: visuals.converterHelper.formatFromMetadataColumn(reader.getValueDisplayName(valueRoleName, seriesIndex), reader.getValueMetadataColumn(valueRoleName, seriesIndex), formatStringProp),
	                                dynamicDisplayName: hasDynamicSeries ? visuals.converterHelper.formatFromMetadataColumn(reader.getSeriesName(seriesIndex), reader.getSeriesMetadataColumn(), formatStringProp) : undefined,
	                                key: key,
	                                lineIndex: seriesIndex,
	                                color: color,
	                                xCol: useScalarKeys ? scalarMetadataColumn : category.source,
	                                yCol: reader.getValueMetadataColumn(valueRoleName, seriesIndex),
	                                data: dataPoints,
	                                identity: identity,
	                                selected: false,
	                                labelSettings: seriesLabelSettings,
	                            });
	                        }
	                    }
	                }
	                xAxisCardProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataView.metadata);
	                var valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataView.metadata);
	                // Convert to DataViewMetadataColumn
	                var valuesMetadataArray = [];
	                if (values) {
	                    for (var i = 0; i < values.length; i++) {
	                        if (values[i] && values[i].source && values[i].source.displayName) {
	                            valuesMetadataArray.push({ displayName: values[i].source.displayName });
	                        }
	                    }
	                }
	                var axesLabels = visuals.converterHelper.createAxesLabels(xAxisCardProperties, valueAxisProperties, category.source, valuesMetadataArray);
	                if (interactivityService) {
	                    interactivityService.applySelectionStateToData(series);
	                }
	                return {
	                    series: series,
	                    isScalar: isScalar,
	                    dataLabelsSettings: defaultLabelSettings,
	                    axesLabels: { x: axesLabels.xAxisLabel, y: axesLabels.yAxisLabel },
	                    hasDynamicSeries: hasDynamicSeries,
	                    categoryMetadata: category.source,
	                    scalarMetadata: scalarMetadataColumn,
	                    scalarKeyCount: useScalarKeys ? scalarKeys.values.length : undefined,
	                    categories: categoryValues,
	                    categoryData: categoryData,
	                    seriesDisplayName: hasDynamicSeries && reader.hasValues(valueRoleName) ? visuals.converterHelper.formatFromMetadataColumn(reader.getSeriesDisplayName(), reader.getSeriesMetadataColumn(), formatStringProp) : undefined,
	                    hasValues: reader.hasValues(valueRoleName),
	                    categoryIdentities: categoryIdentities,
	                };
	            };
	            LineChart.getInteractiveLineChartDomElement = function (element) {
	                return element.children("svg").get(0);
	            };
	            LineChart.getColor = function (colorHelper, hasDynamicSeries, values, grouped, seriesIndex, groupedIdentity) {
	                var objects;
	                if (hasDynamicSeries) {
	                    if (grouped && grouped[seriesIndex])
	                        objects = grouped[seriesIndex].objects;
	                }
	                else if (values[seriesIndex]) {
	                    objects = values[seriesIndex].source.objects;
	                }
	                return hasDynamicSeries && groupedIdentity
	                    ? colorHelper.getColorForSeriesValue(objects, values.identityFields, groupedIdentity.name)
	                    : colorHelper.getColorForMeasure(objects, values[seriesIndex].source.queryName);
	            };
	            LineChart.createStackedValueDomain = function (data) {
	                debug.assertValue(data, 'data');
	                if (data.length === 0)
	                    return null;
	                var minY = d3.min(data, function (kv) { return d3.min(kv.data, function (d) { return d.stackedValue; }); });
	                var maxY = d3.max(data, function (kv) { return d3.max(kv.data, function (d) { return d.stackedValue; }); });
	                return [minY, maxY];
	            };
	            LineChart.prototype.init = function (options) {
	                var _this = this;
	                this.options = options;
	                this.element = options.element;
	                this.cartesainSVG = options.svg;
	                this.host = options.host;
	                this.currentViewport = options.viewport;
	                this.colors = options.style.colorPalette.dataColors;
	                this.isInteractiveChart = options.interactivity && options.interactivity.isInteractiveLegend;
	                this.cartesianVisualHost = options.cartesianHost;
	                this.scaleDetector = new visuals.SVGScaleDetector(this.cartesainSVG);
	                var chartType = options.chartType;
	                this.isComboChart = chartType === 10 /* ComboChart */ || chartType === 13 /* LineClusteredColumnCombo */ || chartType === 14 /* LineStackedColumnCombo */;
	                var svg = options.svg;
	                svg.classed(LineChart.ClassName, true);
	                var graphicsContextParent = this.mainGraphicsSVG = svg.append('svg')
	                    .classed('lineChartSVG', true);
	                if (!this.isComboChart && !this.isInteractiveChart) {
	                    this.overlayRect = graphicsContextParent
	                        .append(LineChart.RectOverlayName)
	                        .style("opacity", visuals.SVGUtil.AlmostZero);
	                }
	                this.mainGraphicsContext = graphicsContextParent
	                    .append('g')
	                    .classed(LineChart.MainGraphicsContextClassName, true);
	                this.hoverLineContext = svg.append('g')
	                    .classed('hover-line', true);
	                this.hoverLineContext.append(LineChart.LineElementName)
	                    .attr("x1", 0).attr("x2", 0)
	                    .attr("y1", 0).attr("y2", 0);
	                var hoverLine = this.hoverLine = this.hoverLineContext.select(LineChart.LineElementName);
	                if (this.isInteractiveChart) {
	                    hoverLine.classed('interactive', true);
	                }
	                hoverLine.style('opacity', visuals.SVGUtil.AlmostZero);
	                // define circles object - which will hold the handle circles.
	                // this object will be populated on render() function, with number of circles which matches the nubmer of lines.
	                this.selectionCircles = [];
	                this.xAxisProperties = {
	                    axis: null,
	                    scale: null,
	                    axisType: null,
	                    formatter: null,
	                    graphicsContext: null,
	                    values: null,
	                    axisLabel: null,
	                    isCategoryAxis: true
	                };
	                if (this.isInteractiveChart) {
	                    var rootSvg_1 = LineChart.getInteractiveLineChartDomElement(this.element);
	                    var dragMove = function () {
	                        _this.lastDragMoveXPosition = d3.mouse(rootSvg_1)[0];
	                        _this.deferDragMoveOperation();
	                    };
	                    // assign drag and onClick events
	                    var drag = d3.behavior.drag()
	                        .origin(Object)
	                        .on("drag", dragMove);
	                    d3.select(rootSvg_1)
	                        .style('touch-action', 'none')
	                        .call(drag)
	                        .on('click', dragMove);
	                }
	                // Internet Explorer and Edge use the stroke edge, not the path edge for the mouse coordinate's origin.
	                //   We need to adjust mouse events on the interactivity lines to account for this.
	                if (jsCommon.BrowserUtils.isInternetExplorerOrEdge()) {
	                    this.pathXAdjustment = 5;
	                }
	                else if (jsCommon.BrowserUtils.isFirefox()) {
	                    this.pathXAdjustment = LineChart.interactivityStrokeWidth * 2;
	                }
	            };
	            LineChart.prototype.setData = function (dataViews) {
	                this.data = {
	                    series: [],
	                    dataLabelsSettings: visuals.dataLabelUtils.getDefaultLineChartLabelSettings(this.isComboChart),
	                    axesLabels: { x: null, y: null },
	                    hasDynamicSeries: false,
	                    categories: [],
	                    categoryMetadata: undefined,
	                    categoryData: [],
	                    categoryIdentities: [],
	                };
	                if (dataViews.length > 0) {
	                    var dataView = dataViews[0];
	                    if (dataView) {
	                        if (dataView.categorical) {
	                            var dataViewCat = this.dataViewCat = dataView.categorical;
	                            var dvCategories = dataViewCat.categories;
	                            var categoryType = { text: true };
	                            var scalarKeys = void 0;
	                            if (dvCategories && !_.isEmpty(dvCategories)) {
	                                if (dvCategories[0].source && dvCategories[0].source.type)
	                                    categoryType = dvCategories[0].source.type;
	                                scalarKeys = LineChart.getScalarKeys(dvCategories[0]);
	                            }
	                            var convertedData = LineChart.converter(dataView, visuals.valueFormatter.format(null), this.cartesianVisualHost.getSharedColors(), visuals.CartesianChart.getIsScalar(dataView.metadata ? dataView.metadata.objects : null, visuals.lineChartProps.categoryAxis.axisType, categoryType, scalarKeys), this.interactivityService, EnumExtensions.hasFlag(this.lineType, 16 /* stackedArea */), this.isComboChart, this.tooltipsEnabled, this.tooltipBucketEnabled);
	                            this.data = convertedData;
	                            var previousCategoryIds = this.previousCategoryIds;
	                            var currentCategoryIds = convertedData.categoryIdentities;
	                            if (previousCategoryIds != null && !(previousCategoryIds.length > visuals.AnimatorCommon.MaxDataPointsToAnimate || currentCategoryIds.length > visuals.AnimatorCommon.MaxDataPointsToAnimate)) {
	                                this.suppressAnimation = false;
	                                for (var categoryIndex = 0, categoryCount = Math.min(previousCategoryIds.length, currentCategoryIds.length); categoryIndex < categoryCount; categoryIndex++) {
	                                    if (!previousCategoryIds[categoryIndex].equals(currentCategoryIds[categoryIndex])) {
	                                        this.suppressAnimation = true;
	                                        break;
	                                    }
	                                }
	                            }
	                            this.previousCategoryIds = currentCategoryIds;
	                        }
	                    }
	                }
	            };
	            LineChart.prototype.calculateLegend = function () {
	                return this.createLegendDataPoints(0); // start with index 0
	            };
	            LineChart.prototype.hasLegend = function () {
	                return this.data && (this.data.hasDynamicSeries || (this.data.series && this.data.series.length > 1));
	            };
	            LineChart.prototype.setFilteredData = function (startIndex, endIndex) {
	                var catgSize = endIndex - startIndex;
	                var data = this.clippedData = powerbi.Prototype.inherit(this.data);
	                data.series = LineChart.sliceSeries(data.series, catgSize, startIndex);
	                data.categories = data.categories.slice(startIndex, endIndex);
	                return data;
	            };
	            LineChart.prototype.calculateAxesProperties = function (options) {
	                var _this = this;
	                var data = this.data;
	                var viewport = options.viewport;
	                var margin = options.margin;
	                this.currentViewport = viewport;
	                this.margin = margin;
	                var origCatgSize = data.series && data.series.length > 0 ? data.series[0].data.length : 0;
	                var categoryWidth = visuals.CartesianChart.MinOrdinalRectThickness;
	                var isScalar = this.data.isScalar;
	                var trimOrdinalDataOnOverflow = options.trimOrdinalDataOnOverflow;
	                var preferredPlotArea = this.getPreferredPlotArea(isScalar, origCatgSize, categoryWidth);
	                this.clippedData = undefined;
	                if (data && !isScalar && !this.isScrollable && trimOrdinalDataOnOverflow) {
	                    // trim data that doesn't fit on dashboard
	                    var categoryCount = this.getCategoryCount(origCatgSize);
	                    var catgSize = Math.min(origCatgSize, categoryCount);
	                    if (catgSize !== origCatgSize) {
	                        data = this.clippedData = powerbi.Prototype.inherit(data);
	                        this.clippedData.series = LineChart.sliceSeries(data.series, catgSize);
	                    }
	                }
	                var xMetaDataColumn;
	                var yMetaDataColumn;
	                if (data.series && data.series.length > 0) {
	                    xMetaDataColumn = data.series[0].xCol;
	                    yMetaDataColumn = data.series[0].yCol;
	                }
	                var valueDomain = EnumExtensions.hasFlag(this.lineType, 16 /* stackedArea */) ? LineChart.createStackedValueDomain(data.series) : visuals.AxisHelper.createValueDomain(data.series, false);
	                var hasZeroValueInYDomain = options.valueAxisScaleType === visuals.axisScale.log && !visuals.AxisHelper.isLogScalePossible(valueDomain);
	                var combinedDomain = visuals.AxisHelper.combineDomain(options.forcedYDomain, valueDomain, options.ensureYDomain);
	                this.yAxisProperties = visuals.AxisHelper.createAxis({
	                    pixelSpan: preferredPlotArea.height,
	                    dataDomain: combinedDomain,
	                    metaDataColumn: yMetaDataColumn,
	                    formatString: visuals.valueFormatter.getFormatString(yMetaDataColumn, visuals.lineChartProps.general.formatString),
	                    outerPadding: 0,
	                    isScalar: true,
	                    isVertical: true,
	                    forcedTickCount: options.forcedTickCount,
	                    useTickIntervalForDisplayUnits: true,
	                    isCategoryAxis: false,
	                    scaleType: options.valueAxisScaleType,
	                    axisDisplayUnits: options.valueAxisDisplayUnits,
	                    axisPrecision: options.valueAxisPrecision,
	                    shouldClamp: false,
	                });
	                var metaDataColumn = data.scalarMetadata ? data.scalarMetadata : data.categoryMetadata;
	                var xAxisDataType = visuals.AxisHelper.getCategoryValueType(metaDataColumn);
	                var xDomain = visuals.AxisHelper.createDomain(data.series, xAxisDataType, this.data.isScalar, options.forcedXDomain, options.ensureXDomain);
	                var hasZeroValueInXDomain = options.categoryAxisScaleType === visuals.axisScale.log && !visuals.AxisHelper.isLogScalePossible(xDomain);
	                this.xAxisProperties = visuals.AxisHelper.createAxis({
	                    pixelSpan: preferredPlotArea.width,
	                    dataDomain: xDomain,
	                    metaDataColumn: xMetaDataColumn,
	                    formatString: visuals.valueFormatter.getFormatString(xMetaDataColumn, visuals.lineChartProps.general.formatString),
	                    outerPadding: this.data.isScalar ? LineChart.ScalarOuterPadding : 0,
	                    isScalar: this.data.isScalar,
	                    isVertical: false,
	                    forcedTickCount: options.forcedTickCount,
	                    maxTickCount: data.scalarKeyCount,
	                    useTickIntervalForDisplayUnits: true,
	                    getValueFn: function (index, type) { return visuals.CartesianHelper.lookupXValue(_this.data, index, type, _this.data.isScalar); },
	                    categoryThickness: visuals.CartesianChart.getCategoryThickness(data.series, origCatgSize, this.getAvailableWidth(), xDomain, isScalar, trimOrdinalDataOnOverflow),
	                    isCategoryAxis: true,
	                    scaleType: options.categoryAxisScaleType,
	                    axisDisplayUnits: options.categoryAxisDisplayUnits,
	                    axisPrecision: options.categoryAxisPrecision
	                });
	                this.xAxisProperties.axisLabel = options.showCategoryAxisLabel ? data.axesLabels.x : null;
	                this.yAxisProperties.axisLabel = options.showValueAxisLabel ? data.axesLabels.y : null;
	                this.xAxisProperties.hasDisallowedZeroInDomain = hasZeroValueInXDomain;
	                this.yAxisProperties.hasDisallowedZeroInDomain = hasZeroValueInYDomain;
	                return [this.xAxisProperties, this.yAxisProperties];
	            };
	            LineChart.prototype.enumerateObjectInstances = function (enumeration, options) {
	                switch (options.objectName) {
	                    case 'dataPoint':
	                        this.enumerateDataPoints(enumeration);
	                        break;
	                    case 'labels':
	                        this.enumerateDataLabels(enumeration);
	                        break;
	                }
	            };
	            LineChart.prototype.enumerateDataPoints = function (enumeration) {
	                var data = this.data;
	                if (!data || !data.series || data.series.length === 0)
	                    return;
	                var formatStringProp = visuals.lineChartProps.general.formatString;
	                var singleSeriesData = data.series;
	                var seriesLength = singleSeriesData.length;
	                for (var i = 0; i < seriesLength; i++) {
	                    var selector = visuals.ColorHelper.normalizeSelector(singleSeriesData[i].identity.getSelector());
	                    var label = visuals.converterHelper.getFormattedLegendLabel(singleSeriesData[i].yCol, this.dataViewCat.values, formatStringProp);
	                    enumeration.pushInstance({
	                        objectName: 'dataPoint',
	                        displayName: label,
	                        selector: selector,
	                        properties: {
	                            fill: { solid: { color: data.defaultSeriesColor || singleSeriesData[i].color } }
	                        },
	                    });
	                }
	            };
	            LineChart.prototype.enumerateDataLabels = function (enumeration) {
	                var data = this.data, labelSettings = this.data.dataLabelsSettings, seriesCount = data.series.length, showLabelPerSeries = this.showLabelPerSeries();
	                //Draw default settings
	                visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings, null, showLabelPerSeries));
	                if (seriesCount === 0)
	                    return;
	                //Draw series settings
	                if (showLabelPerSeries && labelSettings.showLabelPerSeries) {
	                    for (var i = 0; i < seriesCount; i++) {
	                        var series = data.series[i], labelSettings_1 = (series.labelSettings) ? series.labelSettings : this.data.dataLabelsSettings;
	                        enumeration.pushContainer({ displayName: series.displayName });
	                        visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings_1, series));
	                        enumeration.popContainer();
	                    }
	                }
	            };
	            LineChart.prototype.supportsTrendLine = function () {
	                var isScalar = this.data ? this.data.isScalar : false;
	                return !EnumExtensions.hasFlag(this.lineType, 16 /* stackedArea */) && isScalar && this.data.hasValues;
	            };
	            LineChart.prototype.supportsForecast = function () {
	                var isScalar = this.data ? this.data.isScalar : false;
	                return !EnumExtensions.hasFlag(this.lineType, 16 /* stackedArea */) && isScalar && this.data.hasValues && this.data.series.length === 1;
	            };
	            LineChart.prototype.isStacked = function () {
	                return EnumExtensions.hasFlag(this.lineType, 16 /* stackedArea */);
	            };
	            LineChart.prototype.shouldSuppressAnimation = function () {
	                return !!this.suppressAnimation;
	            };
	            LineChart.prototype.showLabelPerSeries = function () {
	                var data = this.data;
	                return !data.hasDynamicSeries && (data.series.length > 1 || !data.categoryMetadata);
	            };
	            LineChart.prototype.getLabelSettingsOptions = function (enumeration, labelSettings, series, showAll) {
	                return {
	                    enumeration: enumeration,
	                    dataLabelsSettings: labelSettings,
	                    show: true,
	                    displayUnits: true,
	                    precision: true,
	                    selector: series && series.identity ? series.identity.getSelector() : null,
	                    showAll: showAll,
	                    fontSize: true,
	                    labelDensity: (this.isComboChart ? this.data.series.length > 0 : true) && this.advancedLineLabelsEnabled && this.data.isScalar,
	                };
	            };
	            LineChart.prototype.overrideXScale = function (xProperties) {
	                this.xAxisProperties = xProperties;
	            };
	            LineChart.prototype.onClearSelection = function () {
	                if (this.interactivityService)
	                    this.interactivityService.clearSelection();
	            };
	            LineChart.prototype.render = function (suppressAnimations) {
	                var duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
	                if (this.suppressAnimation) {
	                    duration = 0;
	                }
	                this.previousCategoryCount = this.data.categoryData.length;
	                var result;
	                if (!this.isInteractiveChart)
	                    result = this.renderNew(duration);
	                else
	                    result = this.renderOld(duration);
	                // This should always be the last line in the render code.
	                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
	                return result;
	            };
	            LineChart.prototype.renderNew = function (duration) {
	                var _this = this;
	                var data = this.clippedData ? this.clippedData : this.data;
	                if (!data)
	                    return;
	                var dataPointCount = data.categories.length * data.series.length;
	                if (dataPointCount > visuals.AnimatorCommon.MaxDataPointsToAnimate) {
	                    // Too many data points to animate.
	                    duration = 0;
	                }
	                var isStackedArea = EnumExtensions.hasFlag(this.lineType, 16 /* stackedArea */);
	                var margin = this.margin;
	                var viewport = this.currentViewport;
	                var height = viewport.height - (margin.top + margin.bottom);
	                var width = viewport.width - (margin.left + margin.right);
	                var xScale = this.xAxisProperties.scale;
	                var yScale = this.yAxisProperties.scale;
	                var horizontalOffset = this.getXOfFirstCategory();
	                var hasSelection = this.interactivityService && this.interactivityService.hasSelection();
	                var renderAreas = EnumExtensions.hasFlag(this.lineType, 2 /* area */) || EnumExtensions.hasFlag(this.lineType, 16 /* stackedArea */);
	                var xPosition = function (d) { return xScale(_this.getXValue(d)) + horizontalOffset; };
	                var y0Position, yPosition;
	                if (isStackedArea) {
	                    y0Position = function (d) { return yScale(d.stackedValue - d.value); };
	                    yPosition = function (d) { return yScale(d.stackedValue); };
	                }
	                else {
	                    y0Position = yScale(0);
	                    yPosition = function (d) { return yScale(d.value); };
	                }
	                var area;
	                if (renderAreas) {
	                    area = d3.svg.area()
	                        .x(xPosition)
	                        .y0(y0Position)
	                        .y1(yPosition)
	                        .defined(function (d) { return d.value !== null; });
	                }
	                var line = d3.svg.line()
	                    .x(xPosition)
	                    .y(yPosition)
	                    .defined(function (d) {
	                    return d.value !== null;
	                });
	                if (EnumExtensions.hasFlag(this.lineType, 4 /* smooth */)) {
	                    line.interpolate('basis');
	                    if (area) {
	                        area.interpolate('basis');
	                    }
	                }
	                this.mainGraphicsSVG
	                    .attr('height', height)
	                    .attr('width', width);
	                var areas = undefined;
	                // Render Areas
	                if (renderAreas) {
	                    areas = this.mainGraphicsContext.selectAll(LineChart.CategoryAreaSelector.selector).data(data.series, function (d) { return d.identity.getKey(); });
	                    areas.enter()
	                        .append(LineChart.PathElementName)
	                        .classed(LineChart.CategoryAreaSelector.class, true);
	                    areas
	                        .style('fill', function (d) { return d.color; })
	                        .style('fill-opacity', function (d) { return (hasSelection && !d.selected) ? LineChart.DimmedAreaFillOpacity : LineChart.AreaFillOpacity; })
	                        .transition()
	                        .ease('linear')
	                        .duration(duration)
	                        .attr('d', function (d) { return area(d.data); });
	                    areas.exit()
	                        .remove();
	                }
	                // Render Lines
	                var lines = this.mainGraphicsContext.selectAll(this.lineClassAndSelector.selector).data(data.series, function (d) { return d.identity.getKey(); });
	                lines.enter()
	                    .append(LineChart.PathElementName)
	                    .classed(this.lineClassAndSelector.class, true);
	                lines
	                    .style('stroke', function (d) { return d.color; })
	                    .style('stroke-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); })
	                    .transition()
	                    .ease('linear')
	                    .duration(duration)
	                    .attr('d', function (d) {
	                    return line(d.data);
	                });
	                lines.exit()
	                    .remove();
	                // Render extra lines that are wider and invisible used for better interactivity
	                var interactivityLines = this.mainGraphicsContext.selectAll(".interactivity-line").data(data.series, function (d) { return d.identity.getKey(); });
	                interactivityLines.enter()
	                    .append(LineChart.PathElementName)
	                    .classed('interactivity-line', true)
	                    .style('stroke-width', LineChart.interactivityStrokeWidth);
	                interactivityLines
	                    .attr('d', function (d) {
	                    return line(d.data);
	                });
	                interactivityLines.exit()
	                    .remove();
	                // Prepare grouping for dots
	                var dotGroups = this.mainGraphicsContext.selectAll(LineChart.CategorySelector.selector)
	                    .data(data.series, function (d) { return d.identity.getKey(); });
	                dotGroups.enter()
	                    .append('g')
	                    .classed(LineChart.CategorySelector.class, true);
	                dotGroups.exit()
	                    .remove();
	                // Render dots
	                var dots = dotGroups.selectAll(LineChart.CategoryValuePoint.selector)
	                    .data(function (series) {
	                    return series.data.filter(function (value, i) {
	                        return _this.shouldDrawCircle(series, i);
	                    });
	                }, function (d) { return d.key; });
	                dots.enter()
	                    .append(LineChart.CircleElementName)
	                    .classed(LineChart.CategoryValuePoint.class, true);
	                dots
	                    .style('fill', function () {
	                    var lineSeries = d3.select(this.parentNode).datum();
	                    return lineSeries.color;
	                })
	                    .style('fill-opacity', function () {
	                    var lineSeries = d3.select(this.parentNode).datum();
	                    return visuals.ColumnUtil.getFillOpacity(lineSeries.selected, false, hasSelection, false);
	                })
	                    .transition()
	                    .duration(duration)
	                    .attr({
	                    cx: function (d, i) { return xScale(_this.getXValue(d)) + horizontalOffset; },
	                    cy: function (d, i) { return yScale(isStackedArea ? d.stackedValue : d.value); },
	                    r: LineChart.CircleRadius
	                });
	                dots.exit()
	                    .remove();
	                // Render explicit dots
	                var explicitDots;
	                if (!this.isComboChart) {
	                    explicitDots = dotGroups.selectAll(LineChart.CategoryPointSelector.selector)
	                        .data(function (series) {
	                        return _.filter(series.data, function (value) { return value.pointColor != null; });
	                    }, function (d) { return d.key; });
	                    explicitDots.enter()
	                        .append(LineChart.CircleElementName)
	                        .classed(LineChart.CategoryPointSelector.class, true);
	                    explicitDots
	                        .style('fill', function (d) { return d.pointColor; })
	                        .transition()
	                        .duration(duration)
	                        .attr({
	                        cx: function (d) { return xScale(_this.getXValue(d)); },
	                        cy: function (d) { return yScale(isStackedArea ? d.stackedValue : d.value); },
	                        r: LineChart.PointRadius
	                    });
	                    explicitDots.exit()
	                        .remove();
	                }
	                // Add data labels
	                var labelDataPointGroups;
	                if (data.dataLabelsSettings.show)
	                    labelDataPointGroups = this.createLabelDataPoints();
	                if (this.tooltipsEnabled) {
	                    if (!this.isComboChart) {
	                        this.overlayRect
	                            .attr({
	                            x: 0,
	                            width: width,
	                            height: height
	                        });
	                        var seriesTooltipApplier = function (tooltipEvent) {
	                            var pointX = tooltipEvent.elementCoordinates[0];
	                            var index = _this.getCategoryIndexFromTooltipEvent(tooltipEvent, pointX);
	                            var categoryData = _this.selectColumnForTooltip(index);
	                            return _this.getSeriesTooltipInfo(categoryData);
	                        };
	                        var clearHoverLine = function () {
	                            _this.hoverLine.style('opacity', visuals.SVGUtil.AlmostZero);
	                            _this.hoverLineContext.selectAll(LineChart.HoverLineCircleDot.selector).remove();
	                        };
	                        visuals.TooltipManager.addTooltip(this.mainGraphicsSVG, seriesTooltipApplier, true, clearHoverLine);
	                    }
	                    else {
	                        var seriesTooltipApplier = function (tooltipEvent) {
	                            var pointX = tooltipEvent.elementCoordinates[0];
	                            return _this.getTooltipInfoForCombo(tooltipEvent, pointX);
	                        };
	                        if (interactivityLines)
	                            visuals.TooltipManager.addTooltip(interactivityLines, seriesTooltipApplier, true);
	                        visuals.TooltipManager.addTooltip(dots, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; }, true);
	                        if (explicitDots)
	                            visuals.TooltipManager.addTooltip(explicitDots, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; }, true);
	                    }
	                }
	                var dataPointsToBind = undefined;
	                var behaviorOptions = undefined;
	                if (this.interactivityService) {
	                    // Register interactivity
	                    dataPointsToBind = data.series.slice();
	                    for (var i = 0, ilen = data.series.length; i < ilen; i++) {
	                        dataPointsToBind = dataPointsToBind.concat(data.series[i].data);
	                    }
	                    behaviorOptions = {
	                        lines: lines,
	                        interactivityLines: interactivityLines,
	                        dots: dots,
	                        areas: areas,
	                        tooltipOverlay: this.overlayRect,
	                        getCategoryIndex: function (seriesData, pointX) {
	                            return _this.getCategoryIndexFromSeriesAndPointX(seriesData, pointX);
	                        },
	                        categoryIdentities: data.categoryIdentities,
	                    };
	                }
	                return {
	                    dataPoints: dataPointsToBind,
	                    behaviorOptions: behaviorOptions,
	                    labelDataPoints: [],
	                    labelsAreNumeric: true,
	                    labelDataPointGroups: labelDataPointGroups,
	                };
	            };
	            LineChart.prototype.renderOld = function (duration) {
	                var _this = this;
	                var data = this.clippedData ? this.clippedData : this.data;
	                if (!data)
	                    return;
	                var margin = this.margin;
	                var viewport = this.currentViewport;
	                var height = viewport.height - (margin.top + margin.bottom);
	                var xScale = this.xAxisProperties.scale;
	                var yScale = this.yAxisProperties.scale;
	                var hasSelection = this.interactivityService && this.interactivityService.hasSelection();
	                var area;
	                if (EnumExtensions.hasFlag(this.lineType, 2 /* area */)) {
	                    area = d3.svg.area()
	                        .x(function (d) { return xScale(_this.getXValue(d)); })
	                        .y0(height)
	                        .y1(function (d) { return yScale(d.value); })
	                        .defined(function (d) { return d.value !== null; });
	                }
	                var line = d3.svg.line()
	                    .x(function (d) {
	                    return xScale(_this.getXValue(d));
	                })
	                    .y(function (d) {
	                    return yScale(d.value);
	                })
	                    .defined(function (d) {
	                    return d.value !== null;
	                });
	                if (EnumExtensions.hasFlag(this.lineType, 4 /* smooth */)) {
	                    line.interpolate('basis');
	                    if (area) {
	                        area.interpolate('basis');
	                    }
	                }
	                var firstCategoryOffset = this.getXOfFirstCategory();
	                this.mainGraphicsContext.attr('transform', visuals.SVGUtil.translate(firstCategoryOffset, 0));
	                this.mainGraphicsSVG.attr('height', this.getAvailableHeight())
	                    .attr('width', this.getAvailableWidth());
	                this.hoverLineContext.attr('transform', visuals.SVGUtil.translate(firstCategoryOffset, 0));
	                if (EnumExtensions.hasFlag(this.lineType, 2 /* area */)) {
	                    var catAreaSelect = this.mainGraphicsContext.selectAll(LineChart.CategoryAreaSelector.selector)
	                        .data(data.series, function (d) { return d.identity.getKey(); });
	                    var catAreaEnter = catAreaSelect
	                        .enter().append('g')
	                        .classed(LineChart.CategoryAreaSelector.class, true);
	                    catAreaEnter.append(LineChart.PathElementName);
	                    var catAreaUpdate = this.mainGraphicsContext.selectAll(LineChart.CategoryAreaSelector.selector);
	                    catAreaUpdate.select(LineChart.PathElementName)
	                        .transition()
	                        .ease('linear')
	                        .duration(duration)
	                        .attr('d', function (d) { return area(d.data); })
	                        .style('fill', function (d) { return d.color; })
	                        .style('fill-opacity', function (d) { return (hasSelection && !d.selected) ? LineChart.DimmedAreaFillOpacity : LineChart.AreaFillOpacity; });
	                    catAreaSelect.exit().remove();
	                }
	                var catSelect = this.mainGraphicsContext.selectAll(LineChart.CategorySelector.selector)
	                    .data(data.series, function (d) { return d.identity.getKey(); });
	                var catEnter = catSelect
	                    .enter()
	                    .append('g')
	                    .classed(LineChart.CategorySelector.class, true);
	                catEnter.append(LineChart.PathElementName);
	                catEnter.selectAll(LineChart.CategoryValuePoint.selector)
	                    .data(function (d) { return d.data; })
	                    .enter()
	                    .append(LineChart.CircleElementName)
	                    .classed(LineChart.CategoryValuePoint.class, true);
	                // moving this up to avoid using the svg path generator with NaN values
	                // do not move this without validating that no errors are thrown in the browser console
	                catSelect.exit().remove();
	                // add the drag handle, if needed
	                if (this.isInteractiveChart && !this.dragHandle) {
	                    var handleTop = this.getAvailableHeight();
	                    this.dragHandle = this.hoverLineContext.append('circle')
	                        .attr('cx', 0)
	                        .attr('cy', handleTop)
	                        .attr('r', '6px')
	                        .classed('drag-handle', true);
	                }
	                // Create the selection circles
	                var linesCount = catSelect.data().length; // number of lines plotted
	                while (this.selectionCircles.length < linesCount) {
	                    var addedCircle = this.hoverLineContext.append(LineChart.CircleElementName)
	                        .classed(LineChart.CircleClassName, true)
	                        .attr('r', LineChart.CircleRadius).style('opacity', 0);
	                    this.selectionCircles.push(addedCircle);
	                }
	                while (this.selectionCircles.length > linesCount) {
	                    this.selectionCircles.pop().remove();
	                }
	                var catUpdate = this.mainGraphicsContext.selectAll(LineChart.CategorySelector.selector);
	                var lineSelection = catUpdate.select(LineChart.PathElementName)
	                    .classed(this.lineClassAndSelector.class, true)
	                    .style('stroke', function (d) { return d.color; })
	                    .style('stroke-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); });
	                lineSelection
	                    .transition()
	                    .ease('linear')
	                    .duration(duration)
	                    .attr('d', function (d) {
	                    return line(d.data);
	                });
	                var that = this;
	                var updateSelection = catUpdate.selectAll(LineChart.CategoryValuePoint.selector);
	                var transitions = updateSelection
	                    .style('fill', function () {
	                    var lineSeries = d3.select(this.parentNode).datum();
	                    return lineSeries.color;
	                })
	                    .style('fill-opacity', function () {
	                    var lineSeries = d3.select(this.parentNode).datum();
	                    return visuals.ColumnUtil.getFillOpacity(lineSeries.selected, false, hasSelection, false);
	                })
	                    .transition()
	                    .duration(duration)
	                    .attr({
	                    'cx': function (d, i) {
	                        var lineSeries = d3.select(this.parentNode).datum();
	                        var circleIndex = that.shouldDrawCircle(lineSeries, i);
	                        return circleIndex ? xScale(that.getXValue(d)) : 0;
	                    },
	                    'cy': function (d, i) {
	                        var lineSeries = d3.select(this.parentNode).datum();
	                        var circleIndex = that.shouldDrawCircle(lineSeries, i);
	                        return circleIndex ? yScale(d.value) : 0;
	                    },
	                    'r': function (d, i) {
	                        var lineSeries = d3.select(this.parentNode).datum();
	                        var circleIndex = that.shouldDrawCircle(lineSeries, i);
	                        return circleIndex ? LineChart.CircleRadius : 0;
	                    }
	                });
	                if (this.isInteractiveChart && this.hasDataPoint(data.series)) {
	                    var selectionSize_1 = updateSelection.size();
	                    var endedTransitionCount_1 = 0;
	                    transitions.each('end', function () {
	                        // When transitions finish, and it's an interactive chart - select the last column (draw the legend and the handle)
	                        endedTransitionCount_1++;
	                        if (endedTransitionCount_1 === selectionSize_1) {
	                            _this.selectColumn(visuals.CartesianHelper.findMaxCategoryIndex(data.series), true);
	                        }
	                    });
	                }
	                var dataPoints = null;
	                if (data.dataLabelsSettings.show) {
	                    dataPoints = [];
	                    for (var i = 0, ilen = data.series.length; i < ilen; i++) {
	                        Array.prototype.push.apply(dataPoints, data.series[i].data);
	                    }
	                }
	                catSelect.exit().remove();
	                // # Code from here is taken from renderNew:
	                // Add data labels
	                var labelDataPointsGroups;
	                if (data.dataLabelsSettings.show)
	                    labelDataPointsGroups = this.createLabelDataPoints();
	                return dataPoints == null ? null : {
	                    dataPoints: dataPoints,
	                    behaviorOptions: null,
	                    labelDataPoints: null,
	                    labelsAreNumeric: null,
	                    labelDataPointGroups: labelDataPointsGroups
	                };
	            };
	            /**
	             * Note: Public for tests.
	             */
	            LineChart.prototype.getSeriesTooltipInfo = function (pointData) {
	                if (_.isEmpty(pointData)) {
	                    return null;
	                }
	                var transparentColor = "#000000";
	                var hiddenItemOpacity = "0";
	                var tooltipinfo = [];
	                var maxNumberOfItems = 10; // to limit the number of rows we display
	                var hasDynamicSeries = !_.isEmpty(pointData) && pointData[0].seriesDisplayName;
	                // count to the maximum number of rows we can display
	                var count = 0;
	                if (!_.any(pointData, function (point) { return !_.isEmpty(point.extraTooltipInfo); })) {
	                    for (var _i = 0, pointData_1 = pointData; _i < pointData_1.length; _i++) {
	                        var point = pointData_1[_i];
	                        if (count >= maxNumberOfItems)
	                            break;
	                        if (point.value != null) {
	                            tooltipinfo.push({
	                                header: point.category,
	                                color: point.color,
	                                displayName: point.seriesName || point.measureDisplayName,
	                                value: point.measure
	                            });
	                            count++;
	                        }
	                    }
	                }
	                else {
	                    for (var _a = 0, pointData_2 = pointData; _a < pointData_2.length; _a++) {
	                        var point = pointData_2[_a];
	                        if (count >= maxNumberOfItems)
	                            break;
	                        if (point.value != null) {
	                            // Add series data
	                            if (hasDynamicSeries) {
	                                tooltipinfo.push({
	                                    header: point.category,
	                                    displayName: point.seriesDisplayName,
	                                    value: point.seriesName,
	                                });
	                            }
	                            // Add value data
	                            tooltipinfo.push({
	                                header: point.category,
	                                color: point.color,
	                                displayName: point.measureDisplayName,
	                                value: point.measure
	                            });
	                            count += 2;
	                            // Add tooltip bucket data for each point for dynamic series
	                            if (hasDynamicSeries && !_.isEmpty(point.extraTooltipInfo)) {
	                                for (var _b = 0, _c = point.extraTooltipInfo; _b < _c.length; _b++) {
	                                    var extraTooltipInfo = _c[_b];
	                                    if (count >= maxNumberOfItems)
	                                        break;
	                                    tooltipinfo.push({
	                                        header: point.category,
	                                        color: transparentColor,
	                                        displayName: extraTooltipInfo.displayName,
	                                        value: extraTooltipInfo.value,
	                                        opacity: hiddenItemOpacity,
	                                    });
	                                    count++;
	                                }
	                            }
	                        }
	                    }
	                    // Add tooltip bucket data to the end once for static series
	                    if (!hasDynamicSeries) {
	                        for (var _d = 0, _e = pointData[0].extraTooltipInfo; _d < _e.length; _d++) {
	                            var extraTooltipInfo = _e[_d];
	                            if (count >= maxNumberOfItems)
	                                break;
	                            tooltipinfo.push({
	                                header: pointData[0].category,
	                                color: transparentColor,
	                                displayName: extraTooltipInfo.displayName,
	                                value: extraTooltipInfo.value,
	                                opacity: hiddenItemOpacity,
	                            });
	                            count++;
	                        }
	                    }
	                }
	                if (tooltipinfo.length === 0)
	                    return null; //don't draw an empty tooltip container
	                return tooltipinfo;
	            };
	            /**
	             * Note: Public for tests.
	             */
	            LineChart.prototype.getTooltipInfoForCombo = function (tooltipEvent, pointX) {
	                // update pointX, the mouse coordinate, with the left-offset of the SVGRect from the x-scale space so we can use the d3.scale to get the index.
	                var categoryIndex = this.getCategoryIndexFromTooltipEvent(tooltipEvent, pointX);
	                var seriesData = tooltipEvent.data;
	                var dataPoint;
	                if (seriesData && seriesData.data && seriesData.data.length) {
	                    dataPoint = _.find(seriesData.data, function (dp) { return dp.categoryIndex === categoryIndex; });
	                }
	                if (dataPoint)
	                    return dataPoint.tooltipInfo;
	                // return undefined so we don't show an empty tooltip
	            };
	            /**
	             * Note: Public for tests.
	             */
	            LineChart.prototype.getCategoryIndexFromTooltipEvent = function (tooltipEvent, pointX) {
	                if (tooltipEvent.data && tooltipEvent.data.categoryIndex != null) {
	                    // Tooltip originated with a dot; simply return the categoryIndex from the dot's bound data
	                    return tooltipEvent.data.categoryIndex;
	                }
	                var seriesData = tooltipEvent.data;
	                return this.getCategoryIndexFromSeriesAndPointX(seriesData, pointX);
	            };
	            LineChart.prototype.getCategoryIndexFromSeriesAndPointX = function (seriesData, pointX) {
	                var offsetX = 0; // Offset based on the firstCategoryOffset (since lines don't start at x = 0) as well as the offset due to lines that may not start at the first category
	                if (seriesData && !_.isEmpty(seriesData.data) && this.xAxisProperties) {
	                    // Tooltip originated from a path; determine series offset from the first point that is part of a path
	                    pointX = this.adjustPathXCoordinate(pointX);
	                    var firstPathPoint = _.find(seriesData.data, function (dataPoint, index, dataPoints) {
	                        var nextDataPoint = dataPoints[index + 1];
	                        return dataPoint.value != null && nextDataPoint && nextDataPoint.value != null;
	                    });
	                    debug.assertValue(firstPathPoint, "If there is data on the tooltipEvent but no categoryIndex, there should always be two consecutive non-null values");
	                    offsetX = this.xAxisProperties.scale(this.getXValue(firstPathPoint)) + this.getXOfFirstCategory();
	                }
	                // else: Tooltip originated from the background; no offsetX is needed
	                return this.findIndex(pointX, offsetX);
	            };
	            LineChart.prototype.getVisualCategoryAxisIsScalar = function () {
	                return this.data ? this.data.isScalar : false;
	            };
	            LineChart.prototype.getSupportedCategoryAxisType = function () {
	                var dvCategories = this.dataViewCat ? this.dataViewCat.categories : undefined;
	                var categoryType = { text: true };
	                if (!_.isEmpty(dvCategories)) {
	                    var scalarKeys = LineChart.getScalarKeys(dvCategories[0]);
	                    if (scalarKeys && !_.isEmpty(scalarKeys.values))
	                        return visuals.axisType.both;
	                    if (dvCategories[0].source && dvCategories[0].source.type)
	                        categoryType = dvCategories[0].source.type;
	                }
	                var isOrdinal = visuals.AxisHelper.isOrdinal(categoryType);
	                return isOrdinal ? visuals.axisType.categorical : visuals.axisType.both;
	            };
	            LineChart.prototype.getPreferredPlotArea = function (isScalar, categoryCount, categoryThickness) {
	                return visuals.CartesianChart.getPreferredPlotArea(categoryCount, categoryThickness, this.currentViewport, this.isScrollable, isScalar, this.margin, true);
	            };
	            LineChart.prototype.getCategoryCount = function (origCatgSize) {
	                var availableWidth = this.getAvailableWidth();
	                var categoryThickness = visuals.CartesianChart.MinOrdinalRectThickness;
	                return Math.min(Math.round((availableWidth - categoryThickness * visuals.CartesianChart.OuterPaddingRatio * 2) / categoryThickness), origCatgSize);
	            };
	            LineChart.prototype.getAvailableWidth = function () {
	                return this.currentViewport.width - (this.margin.left + this.margin.right);
	            };
	            LineChart.prototype.getAvailableHeight = function () {
	                return this.currentViewport.height - (this.margin.top + this.margin.bottom);
	            };
	            LineChart.sliceSeries = function (series, newLength, startIndex) {
	                if (startIndex === void 0) { startIndex = 0; }
	                var newSeries = [];
	                if (series && series.length > 0) {
	                    debug.assert(series[0].data.length >= newLength, "invalid newLength");
	                    for (var i = 0, len = series.length; i < len; i++) {
	                        newSeries[i] = powerbi.Prototype.inherit(series[i]);
	                        newSeries[i].data = series[i].data.slice(startIndex, startIndex + newLength);
	                    }
	                }
	                return newSeries;
	            };
	            LineChart.getScalarKeys = function (dataViewCategoryColumn) {
	                var categoryColumnObjects;
	                if (dataViewCategoryColumn)
	                    categoryColumnObjects = dataViewCategoryColumn.objects;
	                if (!_.isEmpty(categoryColumnObjects)) {
	                    var scalarKeys = void 0;
	                    var categoryObjectsLength = categoryColumnObjects.length;
	                    for (var i = 0; i < categoryObjectsLength; i++) {
	                        var categoryObjects = categoryColumnObjects[i];
	                        var scalarKey = powerbi.DataViewObjects.getValue(categoryObjects, visuals.lineChartProps.scalarKey.scalarKeyMin);
	                        if (scalarKey !== undefined) {
	                            if (!scalarKeys) {
	                                scalarKeys = {
	                                    values: new Array(categoryObjectsLength)
	                                };
	                            }
	                            var key = { min: scalarKey };
	                            scalarKeys.values[i] = key;
	                        }
	                    }
	                    return scalarKeys;
	                }
	            };
	            LineChart.prototype.getXOfFirstCategory = function () {
	                if (!this.data.isScalar) {
	                    // This will place the line points in the middle of the bands
	                    // So they center with Labels when scale is ordinal.
	                    var xScale = this.xAxisProperties.scale;
	                    if (xScale.rangeBand) {
	                        return xScale.rangeBand() / 2;
	                    }
	                }
	                return 0;
	            };
	            LineChart.prototype.hasDataPoint = function (series) {
	                if (series.length === 0)
	                    return false;
	                for (var i = 0, len = series.length; i < len; i++) {
	                    if (series[i].data.length > 0)
	                        return true;
	                }
	                return false;
	            };
	            LineChart.prototype.getXValue = function (d) {
	                return this.data.isScalar ? d.categoryValue : d.categoryIndex;
	            };
	            /**
	              * This checks to see if a data point is isolated, which means
	              * the previous and next data point are both null.
	              */
	            LineChart.prototype.shouldDrawCircle = function (d, i) {
	                var dataLength = d.data.length;
	                var isLastPoint = i === (dataLength - 1);
	                var isFirstPoint = i === 0;
	                if (i > dataLength - 1 || d.data[i] === null || d.data[i].value === null)
	                    return false;
	                if (isFirstPoint && isLastPoint)
	                    return true;
	                if (isFirstPoint && dataLength > 1 && d.data[i + 1].value === null)
	                    return true;
	                if (!isFirstPoint && isLastPoint && d.data[i - 1].value === null)
	                    return true;
	                if (!isFirstPoint && !isLastPoint && d.data[i - 1].value === null && d.data[i + 1].value === null)
	                    return true;
	                return false;
	            };
	            LineChart.prototype.selectColumnForTooltip = function (columnIndex, force) {
	                if (force === void 0) { force = false; }
	                var x = this.getChartX(columnIndex) + this.getXOfFirstCategory();
	                var dataPoints = this.createTooltipDataPoints(columnIndex);
	                if (dataPoints.length > 0) {
	                    this.setHoverLineForTooltip(x);
	                }
	                this.setDotsForTooltip(x, dataPoints);
	                return dataPoints;
	            };
	            LineChart.prototype.setHoverLineForTooltip = function (chartX) {
	                chartX = chartX || 0;
	                this.hoverLine
	                    .attr('x1', chartX)
	                    .attr('x2', chartX)
	                    .attr("y1", 0)
	                    .attr("y2", this.getAvailableHeight())
	                    .style('opacity', 1);
	            };
	            LineChart.prototype.setDotsForTooltip = function (chartX, dataPoints) {
	                var _this = this;
	                var isStackedArea = EnumExtensions.hasFlag(this.lineType, 16 /* stackedArea */);
	                var dotYPosition = isStackedArea ? function (d) { return _this.yAxisProperties.scale(d.stackedValue); } : function (d) { return _this.yAxisProperties.scale(d.value); };
	                var tooltipDots = this.hoverLineContext.selectAll(LineChart.HoverLineCircleDot.selector).data(dataPoints);
	                tooltipDots
	                    .enter()
	                    .append(LineChart.CircleElementName)
	                    .classed(LineChart.HoverLineCircleDot.class, true);
	                tooltipDots
	                    .filter(function (d) { return d.value; })
	                    .attr('fill', function (d) { return d.color; })
	                    .attr("r", 3)
	                    .attr("cx", chartX)
	                    .attr("cy", dotYPosition);
	                tooltipDots.exit().remove();
	            };
	            /**
	             * Updates the hover line and the legend with the selected colums (given by columnIndex).
	             * This is for the Mobile renderer with InteractiveLegend
	             */
	            LineChart.prototype.selectColumn = function (columnIndex, force) {
	                if (force === void 0) { force = false; }
	                if (!force && this.lastInteractiveSelectedColumnIndex === columnIndex)
	                    return; // same column, nothing to do here
	                this.lastInteractiveSelectedColumnIndex = columnIndex;
	                var x = this.getChartX(columnIndex);
	                this.setHoverLine(x, columnIndex);
	                var legendItems = this.createLegendDataPoints(columnIndex);
	                if (legendItems)
	                    this.options.cartesianHost.updateLegend(legendItems);
	            };
	            LineChart.prototype.setHoverLine = function (chartX, columnIndex) {
	                this.hoverLine
	                    .attr('x1', chartX)
	                    .attr('x2', chartX)
	                    .attr("y1", 0).attr("y2", this.getAvailableHeight())
	                    .style('opacity', 1);
	                var that = this;
	                this.mainGraphicsContext
	                    .selectAll(LineChart.CategorySelector.selector)
	                    .selectAll(LineChart.PathElementName)
	                    .each(function (series) {
	                    var _this = this;
	                    // Get the item color for the handle dots
	                    var color = series.color;
	                    var circleToChange = that.selectionCircles[series.lineIndex];
	                    if (circleToChange) {
	                        circleToChange
	                            .attr({
	                            'cx': chartX,
	                            'cy': function () {
	                                var pathElement = d3.select(_this).node();
	                                var pos = that.getPosition(chartX, pathElement);
	                                return pos.y;
	                            }
	                        })
	                            .style({
	                            'opacity': function () { return _.some(series.data, function (value) { return value.categoryIndex === columnIndex; }) ? 1 : 0; },
	                            'fill': color
	                        });
	                    }
	                    if (that.dragHandle)
	                        that.dragHandle.attr('cx', chartX);
	                });
	            };
	            LineChart.prototype.getChartX = function (columnIndex) {
	                var x = 0;
	                if (this.data.isScalar) {
	                    if (columnIndex >= 0 && columnIndex < this.data.categoryData.length)
	                        x = Math.max(0, this.xAxisProperties.scale(this.data.categoryData[columnIndex].categoryValue));
	                }
	                else {
	                    x = Math.max(0, this.xAxisProperties.scale(columnIndex));
	                }
	                var rangeEnd = powerbi.visuals.AxisHelper.extent(this.xAxisProperties.scale)[1];
	                x = Math.min(x, rangeEnd);
	                if (!isNaN(x))
	                    return x;
	                return 0;
	            };
	            /**
	             * Finds the index of the category of the given x coordinate given.
	             * pointX is in non-scaled screen-space, and offsetX is in render-space.
	             * offsetX does not need any scaling adjustment.
	             * @param {number} pointX The mouse coordinate in screen-space, without scaling applied
	             * @param {number} offsetX Any left offset in d3.scale render-space
	             * @return {number}
	             */
	            LineChart.prototype.findIndex = function (pointX, offsetX) {
	                // we are using mouse coordinates that do not know about any potential CSS transform scale
	                var xScale = this.scaleDetector.getScale().x;
	                if (!powerbi.Double.equalWithPrecision(xScale, 1.0, 0.00001)) {
	                    pointX = pointX / xScale;
	                }
	                if (offsetX) {
	                    pointX += offsetX;
	                }
	                var index = powerbi.visuals.AxisHelper.invertScale(this.xAxisProperties.scale, pointX);
	                if (this.data.isScalar) {
	                    // When we have scalar data the inverted scale produces a category value, so we need to search for the closest index.
	                    index = visuals.AxisHelper.findClosestXAxisIndex(index, this.data.categoryData);
	                }
	                return index;
	            };
	            LineChart.prototype.getPosition = function (x, pathElement) {
	                var pathLength = pathElement.getTotalLength();
	                var pos;
	                var beginning = 0, end = pathLength, target;
	                while (true) {
	                    target = Math.floor((beginning + end) / 2);
	                    pos = pathElement.getPointAtLength(target);
	                    visuals.SVGUtil.ensureValidSVGPoint(pos);
	                    if ((target === end || target === beginning) && pos.x !== x)
	                        break;
	                    if (pos.x > x)
	                        end = target;
	                    else if (pos.x < x)
	                        beginning = target;
	                    else
	                        break;
	                }
	                return pos;
	            };
	            LineChart.prototype.createTooltipDataPoints = function (columnIndex) {
	                var data = this.data;
	                if (!data || data.series.length === 0 || !data.categories || !data.categoryData)
	                    return [];
	                var dataPoints = [];
	                var category;
	                debug.assert(columnIndex < data.categoryData.length, 'category index out of range (categoryData)');
	                debug.assert(columnIndex < data.categories.length, 'category index out of range (categories)');
	                var categoryDataPoint = data.categoryData[columnIndex];
	                if (this.data.isScalar) {
	                    if (categoryDataPoint) {
	                        if (visuals.AxisHelper.isDateTime(this.xAxisProperties.axisType) && !data.scalarMetadata) {
	                            category = visuals.CartesianHelper.lookupXValue(this.data, categoryDataPoint.categoryValue, this.xAxisProperties.axisType, this.data.isScalar);
	                        }
	                        else {
	                            category = data.categories[columnIndex];
	                        }
	                    }
	                }
	                else {
	                    category = visuals.CartesianHelper.lookupXValue(this.data, columnIndex, this.xAxisProperties.axisType, this.data.isScalar);
	                }
	                var formatStringProp = visuals.lineChartProps.general.formatString;
	                for (var _i = 0, _a = data.series; _i < _a.length; _i++) {
	                    var series = _a[_i];
	                    var lineData = series.data;
	                    var lineDataPoint = void 0;
	                    if (this.data.isScalar) {
	                        if (categoryDataPoint) {
	                            lineDataPoint = lineData.filter(function (data) {
	                                return data.categoryValue === categoryDataPoint.categoryValue;
	                            })[0];
	                        }
	                    }
	                    else {
	                        lineDataPoint = lineData[columnIndex];
	                    }
	                    var value = lineDataPoint && lineDataPoint.value;
	                    if (value != null) {
	                        var dataPoint = {
	                            color: series.color,
	                            category: visuals.valueFormatter.format(category, visuals.valueFormatter.getFormatString(series.xCol, formatStringProp)),
	                            measureDisplayName: series.displayName,
	                            measure: visuals.valueFormatter.format(value, visuals.valueFormatter.getFormatString(series.yCol, formatStringProp)),
	                            value: value,
	                            stackedValue: lineDataPoint.stackedValue,
	                            extraTooltipInfo: lineDataPoint.extraTooltipInfo,
	                        };
	                        if (data.hasDynamicSeries) {
	                            dataPoint.seriesDisplayName = data.seriesDisplayName;
	                            dataPoint.seriesName = series.dynamicDisplayName;
	                        }
	                        dataPoints.push(dataPoint);
	                    }
	                }
	                return dataPoints;
	            };
	            LineChart.prototype.createLegendDataPoints = function (columnIndex) {
	                var data = this.data;
	                if (!data || !data.series || data.series.length < 1)
	                    return;
	                var legendDataPoints = [];
	                var category;
	                // 'category' and 'measure' are only for Mobile interactive legend, Minerva legend does not need them
	                var categoryDataPoint = data.categoryData[columnIndex];
	                if (this.isInteractiveChart && categoryDataPoint) {
	                    if (this.data.isScalar) {
	                        category = categoryDataPoint.categoryValue;
	                        if (visuals.AxisHelper.isDateTime(this.xAxisProperties.axisType))
	                            category = new Date(category);
	                    }
	                    else {
	                        category = visuals.CartesianHelper.lookupXValue(this.data, columnIndex, this.xAxisProperties.axisType, this.data.isScalar);
	                    }
	                }
	                var formatStringProp = visuals.lineChartProps.general.formatString;
	                var seriesYCol = null;
	                // iterating over the line data (i is for a line)
	                for (var i = 0, len = data.series.length; i < len; i++) {
	                    var series = data.series[i];
	                    var lineData = series.data;
	                    // 'category' and 'measure' are only for Mobile interactive legend, Minerva legend does not need them
	                    var measure = void 0;
	                    if (this.isInteractiveChart) {
	                        var lineDataPoint = void 0;
	                        if (this.data.isScalar) {
	                            // Scalar series skip null values, and therefore do not share the same category index
	                            // Search this series for the categoryValue - it may not exist
	                            if (categoryDataPoint) {
	                                var targetCategoryValue = categoryDataPoint.categoryValue;
	                                for (var i_1 = 0; i_1 < lineData.length; i_1++) {
	                                    if (lineData[i_1].categoryValue === targetCategoryValue) {
	                                        lineDataPoint = lineData[i_1];
	                                        break;
	                                    }
	                                }
	                            }
	                        }
	                        else {
	                            // ordinal series all share the same x-indicies
	                            lineDataPoint = lineData[columnIndex];
	                        }
	                        measure = lineDataPoint && lineDataPoint.value;
	                    }
	                    var label = visuals.converterHelper.getFormattedLegendLabel(series.yCol, this.dataViewCat.values, formatStringProp);
	                    seriesYCol = series.yCol;
	                    legendDataPoints.push({
	                        color: series.color,
	                        icon: visuals.LegendIcon.Line,
	                        label: label,
	                        // TODO: category: CartesianChartInteractiveLegend only needs one category value for part of the Title, we don't need to put it on each point.
	                        category: visuals.valueFormatter.format(category, visuals.valueFormatter.getFormatString(series.xCol, formatStringProp)),
	                        measure: visuals.valueFormatter.format(measure, visuals.valueFormatter.getFormatString(series.yCol, formatStringProp)),
	                        identity: series.identity,
	                        selected: series.selected,
	                    });
	                }
	                var dvValues = this.dataViewCat ? this.dataViewCat.values : null;
	                var title = dvValues && dvValues.source ? dvValues.source.displayName : "";
	                return {
	                    title: title,
	                    dataPoints: legendDataPoints,
	                    grouped: data.hasDynamicSeries,
	                };
	            };
	            LineChart.prototype.createLabelDataPoints = function () {
	                var _this = this;
	                var xScale = this.xAxisProperties.scale;
	                var yScale = this.yAxisProperties.scale;
	                var lineshift = this.getXOfFirstCategory();
	                var data = this.data;
	                var series = this.clippedData ? this.clippedData.series : data.series;
	                var baseLabelSettings = data.dataLabelsSettings;
	                var formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager();
	                var isStackedArea = EnumExtensions.hasFlag(this.lineType, 16 /* stackedArea */);
	                var labelDataPointGroups = [];
	                var labelSettings;
	                var axisFormatter;
	                var seriesLabelDataPoints;
	                var seriesDataPointsCandidates;
	                var seriesIndex;
	                var seriesCount;
	                var currentSeries;
	                var _loop_1 = function() {
	                    currentSeries = series[seriesIndex];
	                    labelSettings = currentSeries.labelSettings || baseLabelSettings;
	                    var densityAtMax = labelSettings.labelDensity === "100";
	                    var maxNumberOfLabels = this_1.advancedLineLabelsEnabled && !densityAtMax && data.isScalar ? LineChart.getNumberOfLabelsToRender(this_1.currentViewport.width, _.parseInt(labelSettings.labelDensity)) : currentSeries.data.length;
	                    if (!labelSettings.show) {
	                        labelDataPointGroups[seriesIndex] = {
	                            labelDataPoints: [],
	                            maxNumberOfLabels: 0,
	                        };
	                        return "continue";
	                    }
	                    axisFormatter = visuals.NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this_1.yAxisProperties.formatter, labelSettings);
	                    var dataPoints = currentSeries.data;
	                    seriesLabelDataPoints = [];
	                    seriesDataPointsCandidates = [];
	                    var createLabelDataPoint = function (dataPoint, categoryIndex) {
	                        if (dataPoint.value == null)
	                            return null;
	                        var formatString = dataPoint.labelFormatString;
	                        var formatter = formattersCache.getOrCreate(formatString, labelSettings, axisFormatter);
	                        var text = visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(dataPoint.value));
	                        var properties = {
	                            text: text,
	                            fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
	                            fontSize: PixelConverter.fromPoint(labelSettings.fontSize),
	                            fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight,
	                        };
	                        var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties) + visuals.NewDataLabelUtils.LabelDensityPadding;
	                        var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, true /* tightFitForNumeric */);
	                        var parentShape;
	                        var isParentRect = false;
	                        if (isStackedArea) {
	                            var bottomPos = Math.max(dataPoint.stackedValue - dataPoint.value, yScale.domain()[0]); //this is to make sure the bottom position doesn't go below the domain
	                            var areaWidth = _this.currentViewport.width; // Conceptually, we allow line labels to fill the full plot area, so the width is equal to the plot area
	                            parentShape = {
	                                rect: {
	                                    left: xScale(_this.getXValue(dataPoint)) - areaWidth / 2,
	                                    top: yScale(Math.max(dataPoint.stackedValue, dataPoint.stackedValue - dataPoint.value)),
	                                    width: areaWidth,
	                                    height: Math.abs(yScale(dataPoint.stackedValue) - yScale(bottomPos))
	                                },
	                                orientation: dataPoint.value >= 0 ? 1 /* VerticalBottomBased */ : 2 /* VerticalTopBased */,
	                                validPositions: LineChart.validStackedLabelPositions,
	                            };
	                            isParentRect = true;
	                        }
	                        else {
	                            parentShape = {
	                                point: {
	                                    x: xScale(_this.getXValue(dataPoint)) + lineshift,
	                                    y: yScale(dataPoint.value),
	                                },
	                                radius: 0,
	                                validPositions: densityAtMax ? [1 /* Above */] : _this.getValidLabelPositions(currentSeries, categoryIndex),
	                            };
	                        }
	                        var labelDataPoint = {
	                            isPreferred: false,
	                            text: text,
	                            textSize: {
	                                width: textWidth,
	                                height: textHeight,
	                            },
	                            outsideFill: labelSettings.labelColor ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultLabelColor,
	                            insideFill: labelSettings.labelColor && isStackedArea ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultInsideLabelColor,
	                            parentType: isParentRect ? 1 /* Rectangle */ : 0 /* Point */,
	                            parentShape: parentShape,
	                            fontSize: labelSettings.fontSize,
	                            identity: dataPoint.identity,
	                            key: dataPoint.key,
	                        };
	                        return labelDataPoint;
	                    };
	                    if (!_.isEmpty(dataPoints)) {
	                        for (var categoryIndex = 0, categoryCount = dataPoints.length; categoryIndex < categoryCount; categoryIndex++) {
	                            var labelDataPoint = createLabelDataPoint(dataPoints[categoryIndex], categoryIndex);
	                            if (labelDataPoint)
	                                seriesLabelDataPoints.push(labelDataPoint);
	                        }
	                    }
	                    labelDataPointGroups[seriesIndex] = {
	                        labelDataPoints: seriesLabelDataPoints,
	                        maxNumberOfLabels: maxNumberOfLabels,
	                    };
	                };
	                var this_1 = this;
	                for (seriesIndex = 0, seriesCount = series.length; seriesIndex < seriesCount; seriesIndex++) {
	                    var state_1 = _loop_1();
	                    if (state_1 === "continue") continue;
	                }
	                if (this.advancedLineLabelsEnabled && this.lineType !== 16 /* stackedArea */) {
	                    var sorter = new visuals.MinMaxLabelDataPointSorter({
	                        unsortedLabelDataPointGroups: labelDataPointGroups,
	                        series: series,
	                        viewport: this.currentViewport,
	                        yAxisProperties: this.yAxisProperties,
	                    });
	                    return sorter.getSortedDataLabels();
	                }
	                return labelDataPointGroups;
	            };
	            LineChart.getNumberOfLabelsToRender = function (viewPortWidth, labelDensity) {
	                if (labelDensity == null || labelDensity === 0) {
	                    return LineChart.minimumLabelsToRender;
	                }
	                var parsedAndNormalizedDensity = labelDensity / 100;
	                var maxNumberForViewport = Math.ceil(viewPortWidth / visuals.MinMaxLabelDataPointSorter.estimatedLabelWidth);
	                if (parsedAndNormalizedDensity === 1) {
	                    return maxNumberForViewport;
	                }
	                return LineChart.minimumLabelsToRender + Math.floor(parsedAndNormalizedDensity * (maxNumberForViewport - LineChart.minimumLabelsToRender));
	            };
	            /**
	             * Adjust a mouse coordinate originating from a path; used to fix
	             * an inconsistency between Internet Explorer and other browsers.
	             *
	             * Internet explorer places the origin for the coordinate system of
	             * mouse events based on the stroke, so that the very edge of the stroke
	             * is zero.  Chrome places the 0 on the edge of the path so that the
	             * edge of the stroke is -(strokeWidth / 2).  We adjust coordinates
	             * to match Chrome.
	             *
	             * @param value The x coordinate to be adjusted
	             */
	            LineChart.prototype.adjustPathXCoordinate = function (x) {
	                var xScale = this.scaleDetector.getScale().x;
	                if (!powerbi.Double.equalWithPrecision(xScale, 1.0, 0.00001)) {
	                    x -= this.pathXAdjustment * xScale;
	                }
	                else {
	                    x -= this.pathXAdjustment;
	                }
	                return x;
	            };
	            /**
	             * Obtains the pointLabelPosition for the category index within the given series
	             *
	             * Rules for line chart data labels:
	             * 1. Top and bottom > left and right
	             * 2. Top > bottom unless we're at a local minimum
	             * 3. Right > left unless:
	             *    a. There is no data point to the left and there is one to the right
	             *    b. There is an equal data point to the right, but not to the left
	             */
	            LineChart.prototype.getValidLabelPositions = function (series, categoryIndex) {
	                if (!this.advancedLineLabelsEnabled) {
	                    return [1 /* Above */];
	                }
	                var data = series.data;
	                var dataLength = data.length;
	                var isLastPoint = categoryIndex === (dataLength - 1);
	                var isFirstPoint = categoryIndex === 0;
	                var currentValue = data[categoryIndex].value;
	                var previousValue = !isFirstPoint ? data[categoryIndex - 1].value : undefined;
	                var nextValue = !isLastPoint ? data[categoryIndex + 1].value : undefined;
	                var previousRelativePosition = 1 /* Equal */;
	                var nextRelativePosition = 1 /* Equal */;
	                if (previousValue == null) {
	                    previousRelativePosition = 0 /* None */;
	                }
	                else if (previousValue > currentValue) {
	                    previousRelativePosition = 3 /* Greater */;
	                }
	                else if (previousValue < currentValue) {
	                    previousRelativePosition = 2 /* Lesser */;
	                }
	                if (nextValue === null) {
	                    nextRelativePosition = 0 /* None */;
	                }
	                else if (nextValue > currentValue) {
	                    nextRelativePosition = 3 /* Greater */;
	                }
	                else if (nextValue < currentValue) {
	                    nextRelativePosition = 2 /* Lesser */;
	                }
	                if (isFirstPoint) {
	                    switch (nextRelativePosition) {
	                        case 3 /* Greater */:
	                            return [2 /* Below */, 1 /* Above */];
	                        default:
	                            return [1 /* Above */, 2 /* Below */];
	                    }
	                }
	                if (isLastPoint) {
	                    switch (previousRelativePosition) {
	                        case 3 /* Greater */:
	                            return [2 /* Below */, 1 /* Above */];
	                        default:
	                            return [1 /* Above */, 2 /* Below */];
	                    }
	                }
	                switch (previousRelativePosition) {
	                    case 0 /* None */:
	                        switch (nextRelativePosition) {
	                            case 0 /* None */:
	                                return [1 /* Above */, 2 /* Below */, 8 /* Right */, 4 /* Left */];
	                            case 1 /* Equal */:
	                                return [1 /* Above */, 2 /* Below */, 4 /* Left */, 8 /* Right */];
	                            case 3 /* Greater */:
	                                return [2 /* Below */, 1 /* Above */, 4 /* Left */, 8 /* Right */];
	                            case 2 /* Lesser */:
	                                return [1 /* Above */, 2 /* Below */, 4 /* Left */, 8 /* Right */];
	                        }
	                    case 1 /* Equal */:
	                        switch (nextRelativePosition) {
	                            case 0 /* None */:
	                                return [1 /* Above */, 2 /* Below */, 8 /* Right */, 4 /* Left */];
	                            case 1 /* Equal */:
	                                return [1 /* Above */, 2 /* Below */, 8 /* Right */, 4 /* Left */];
	                            case 3 /* Greater */:
	                                return [2 /* Below */, 1 /* Above */, 8 /* Right */, 4 /* Left */];
	                            case 2 /* Lesser */:
	                                return [1 /* Above */, 2 /* Below */, 8 /* Right */, 4 /* Left */];
	                        }
	                    case 3 /* Greater */:
	                        switch (nextRelativePosition) {
	                            case 0 /* None */:
	                                return [2 /* Below */, 1 /* Above */, 8 /* Right */, 4 /* Left */];
	                            case 1 /* Equal */:
	                                return [2 /* Below */, 1 /* Above */, 4 /* Left */, 8 /* Right */];
	                            case 3 /* Greater */:
	                                return [2 /* Below */, 1 /* Above */, 8 /* Right */, 4 /* Left */];
	                            case 2 /* Lesser */:
	                                return [1 /* Above */, 2 /* Below */, 8 /* Right */, 4 /* Left */];
	                        }
	                    case 2 /* Lesser */:
	                        switch (nextRelativePosition) {
	                            case 0 /* None */:
	                                return [1 /* Above */, 2 /* Below */, 8 /* Right */, 4 /* Left */];
	                            case 1 /* Equal */:
	                                return [1 /* Above */, 2 /* Below */, 4 /* Left */, 8 /* Right */];
	                            case 3 /* Greater */:
	                                return [1 /* Above */, 2 /* Below */, 8 /* Right */, 4 /* Left */];
	                            case 2 /* Lesser */:
	                                return [1 /* Above */, 2 /* Below */, 8 /* Right */, 4 /* Left */];
	                        }
	                }
	            };
	            LineChart.ClassName = 'lineChart';
	            LineChart.MainGraphicsContextClassName = 'mainGraphicsContext';
	            LineChart.CategorySelector = createClassAndSelector('cat');
	            LineChart.CategoryValuePoint = createClassAndSelector('dot');
	            LineChart.CategoryPointSelector = createClassAndSelector('point');
	            LineChart.CategoryAreaSelector = createClassAndSelector('catArea');
	            LineChart.HoverLineCircleDot = createClassAndSelector('circle-item');
	            LineChart.LineClassSelector = createClassAndSelector('line');
	            LineChart.PointRadius = 5;
	            LineChart.CircleRadius = 4;
	            LineChart.PathElementName = 'path';
	            LineChart.CircleElementName = 'circle';
	            LineChart.CircleClassName = 'selection-circle';
	            LineChart.LineElementName = 'line';
	            LineChart.RectOverlayName = 'rect';
	            LineChart.ScalarOuterPadding = 10;
	            LineChart.interactivityStrokeWidth = 10;
	            LineChart.minimumLabelsToRender = 4;
	            LineChart.AreaFillOpacity = 0.4;
	            LineChart.DimmedAreaFillOpacity = 0.2;
	            LineChart.validStackedLabelPositions = [1 /* InsideCenter */, 4 /* InsideEnd */, 2 /* InsideBase */];
	            return LineChart;
	        }());
	        visuals.LineChart = LineChart;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 266 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var Color = jsCommon.Color;
	        var PixelConverter = jsCommon.PixelConverter;
	        var Polygon = visuals.shapes.Polygon;
	        var DataRoleHelper = powerbi.data.DataRoleHelper;
	        visuals.MaxLevelOfDetail = 23;
	        visuals.MinLevelOfDetail = 1;
	        visuals.DefaultFillOpacity = 0.5;
	        visuals.DefaultBackgroundColor = "#000000";
	        visuals.LeaderLineColor = "#000000";
	        var MapBubbleDataPointRenderer = (function () {
	            function MapBubbleDataPointRenderer(tooltipsEnabled) {
	                this.tooltipsEnabled = tooltipsEnabled;
	            }
	            MapBubbleDataPointRenderer.prototype.init = function (mapControl, mapDiv, addClearCatcher) {
	                /*
	                    The layout of the visual would look like :
	                    <div class="visual mapControl">
	                        <div class="MicrosoftMap">
	                            <!-- Bing maps stuff -->
	                            <svg>
	                                <rect class="clearCatcher"></rect>
	                            </svg>
	                        </div>
	                        <svg>
	                            <g class="mapBubbles>
	                                <!-- our geometry -->
	                            </g>
	                            <g class="mapSlices>
	                                <!-- our geometry -->
	                            </g>
	                        </svg>
	                    </div>
	    
	                */
	                this.mapControl = mapControl;
	                this.root = mapDiv;
	                var root = d3.select(mapDiv[0]);
	                root.attr("drag-resize-disabled", "true"); // Enable panning within the maps in IE
	                var svg = this.svg = root
	                    .append('svg')
	                    .style("position", "absolute") // Absolute position so that the svg will overlap with the canvas.
	                    .style("pointer-events", "none");
	                if (addClearCatcher) {
	                    var clearSvg = this.clearSvg = d3.select(this.mapControl.getRootElement())
	                        .append('svg')
	                        .style('position', 'absolute'); // Absolute position so that the svg will overlap with the canvas.
	                    this.clearCatcher = visuals.appendClearCatcher(clearSvg);
	                }
	                this.bubbleGraphicsContext = svg
	                    .append("g")
	                    .classed("mapBubbles", true);
	                this.sliceGraphicsContext = svg
	                    .append("g")
	                    .classed("mapSlices", true);
	                this.labelBackgroundGraphicsContext = svg
	                    .append("g")
	                    .classed(visuals.NewDataLabelUtils.labelBackgroundGraphicsContextClass.class, true);
	                this.labelGraphicsContext = svg
	                    .append("g")
	                    .classed(visuals.NewDataLabelUtils.labelGraphicsContextClass.class, true);
	                this.sliceLayout = d3.layout.pie()
	                    .sort(null)
	                    .value(function (d) {
	                    return d.value;
	                });
	                this.arc = d3.svg.arc();
	                this.clearMaxDataPointRadius();
	                this.dataLabelsSettings = visuals.dataLabelUtils.getDefaultMapLabelSettings();
	            };
	            MapBubbleDataPointRenderer.prototype.setData = function (data) {
	                this.mapData = data;
	            };
	            MapBubbleDataPointRenderer.prototype.clearDataPoints = function () {
	                this.mapData = {
	                    dataPoints: [],
	                    geocodingCategory: null,
	                    hasDynamicSeries: false,
	                    hasSize: false,
	                };
	            };
	            MapBubbleDataPointRenderer.prototype.getDataPointCount = function () {
	                if (!this.mapData)
	                    return 0;
	                // Filter out any data points without a location since those aren't actually being drawn
	                return _.filter(this.mapData.dataPoints, function (value) { return !!value.location; }).length;
	            };
	            MapBubbleDataPointRenderer.prototype.getDataPointPadding = function () {
	                return this.maxDataPointRadius * 2;
	            };
	            MapBubbleDataPointRenderer.prototype.clearMaxDataPointRadius = function () {
	                this.maxDataPointRadius = 0;
	            };
	            MapBubbleDataPointRenderer.prototype.setMaxDataPointRadius = function (dataPointRadius) {
	                this.maxDataPointRadius = Math.max(dataPointRadius, this.maxDataPointRadius);
	            };
	            MapBubbleDataPointRenderer.prototype.getDefaultMap = function (geocodingCategory, dataPointCount) {
	                this.clearDataPoints();
	            };
	            MapBubbleDataPointRenderer.prototype.converter = function (viewport, dataView, labelSettings, interactivityService, tooltipsEnabled) {
	                if (tooltipsEnabled === void 0) { tooltipsEnabled = true; }
	                var mapControl = this.mapControl;
	                var widthOverTwo = viewport.width / 2;
	                var heightOverTwo = viewport.height / 2;
	                var strokeWidth = 1;
	                //update data label settings
	                this.dataLabelsSettings = labelSettings;
	                // See MapSeriesPresenter::GetDataPointRadius for the PV behavior
	                var radiusScale = Math.min(viewport.width, viewport.height) / 384;
	                this.clearMaxDataPointRadius();
	                var bubbleData = [];
	                var sliceData = [];
	                var categorical = dataView ? dataView.categorical : null;
	                var grouped;
	                var sizeIndex = -1;
	                var dataValuesSource;
	                if (categorical && categorical.values) {
	                    grouped = categorical.values.grouped();
	                    sizeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Size");
	                    dataValuesSource = categorical.values.source;
	                }
	                var dataPoints = this.mapData ? this.mapData.dataPoints : [];
	                var hasSize = this.mapData.hasSize;
	                for (var categoryIndex = 0, categoryCount = dataPoints.length; categoryIndex < categoryCount; categoryIndex++) {
	                    var dataPoint = dataPoints[categoryIndex];
	                    var categoryValue = dataPoint.categoryValue;
	                    var location_1 = dataPoint.location;
	                    if (location_1) {
	                        var xy = mapControl.tryLocationToPixel(new Microsoft.Maps.Location(location_1.latitude, location_1.longitude));
	                        var x = xy.x + widthOverTwo;
	                        var y = xy.y + heightOverTwo;
	                        var radius = dataPoint.radius * radiusScale;
	                        this.setMaxDataPointRadius(radius);
	                        var subDataPoints = dataPoint.subDataPoints;
	                        var seriesCount = subDataPoints.length;
	                        if (seriesCount === 1) {
	                            var subDataPoint = subDataPoints[0];
	                            bubbleData.push({
	                                x: x,
	                                y: y,
	                                labeltext: categoryValue,
	                                radius: radius,
	                                fill: subDataPoint.fill,
	                                stroke: subDataPoint.stroke,
	                                strokeWidth: strokeWidth,
	                                tooltipInfo: subDataPoint.tooltipInfo,
	                                identity: subDataPoint.identity,
	                                selected: false,
	                                labelFill: labelSettings.labelColor,
	                            });
	                        }
	                        else {
	                            var slices = [];
	                            for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
	                                var subDataPoint = subDataPoints[seriesIndex];
	                                var value = hasSize ? subDataPoint.value : 1; // Normalize values if there is no size in the data
	                                slices.push({
	                                    x: x,
	                                    y: y,
	                                    labeltext: categoryValue,
	                                    radius: radius,
	                                    fill: subDataPoint.fill,
	                                    stroke: subDataPoint.stroke,
	                                    strokeWidth: strokeWidth,
	                                    value: value,
	                                    tooltipInfo: subDataPoint.tooltipInfo,
	                                    identity: subDataPoint.identity,
	                                    selected: false,
	                                    labelFill: labelSettings.labelColor,
	                                });
	                            }
	                            if (interactivityService) {
	                                interactivityService.applySelectionStateToData(slices);
	                            }
	                            sliceData.push(slices);
	                        }
	                    }
	                }
	                if (interactivityService) {
	                    interactivityService.applySelectionStateToData(bubbleData);
	                }
	                return { bubbleData: bubbleData, sliceData: sliceData };
	            };
	            MapBubbleDataPointRenderer.prototype.updateInternal = function (data, viewport, dataChanged, interactivityService, redrawDataLabels) {
	                debug.assertValue(viewport, "viewport");
	                Map.removeTransform3d(this.root);
	                this.mapRendererData = data;
	                if (this.svg) {
	                    this.svg
	                        .style("width", viewport.width.toString() + "px")
	                        .style("height", viewport.height.toString() + "px");
	                }
	                if (this.clearSvg) {
	                    this.clearSvg
	                        .style("width", viewport.width.toString() + "px")
	                        .style("height", viewport.height.toString() + "px");
	                }
	                var arc = this.arc;
	                var hasSelection = interactivityService && interactivityService.hasSelection();
	                var bubbles = this.bubbleGraphicsContext.selectAll(".bubble").data(data.bubbleData, function (d) { return d.identity.getKey(); });
	                bubbles.enter()
	                    .append("circle")
	                    .classed("bubble", true);
	                bubbles
	                    .attr("cx", function (d) { return d.x; })
	                    .attr("cy", function (d) { return d.y; })
	                    .attr("r", function (d) { return d.radius; })
	                    .style("fill", function (d) { return d.fill; })
	                    .style("stroke", function (d) { return d.stroke; })
	                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); })
	                    .style("strokeWidth", function (d) { return d.strokeWidth; })
	                    .style("stroke-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); })
	                    .style("cursor", "default");
	                bubbles.exit().remove();
	                if (this.tooltipsEnabled) {
	                    visuals.TooltipManager.addTooltip(this.bubbleGraphicsContext, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
	                    bubbles.style("pointer-events", "all");
	                }
	                var sliceData = data.sliceData;
	                var sliceContainers = this.sliceGraphicsContext.selectAll(".sliceContainer").data(sliceData);
	                sliceContainers.enter()
	                    .append("g")
	                    .classed("sliceContainer", true);
	                sliceContainers.exit().remove();
	                var sliceLayout = this.sliceLayout;
	                var slices = sliceContainers.selectAll(".slice")
	                    .data(function (d) {
	                    return sliceLayout(d);
	                }, function (d) { return d.data.identity.getKey(); });
	                slices.enter()
	                    .append("path")
	                    .classed("slice", true);
	                slices
	                    .style("fill", function (t) { return t.data.fill; })
	                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, hasSelection, false); })
	                    .style("stroke", function (t) { return t.data.stroke; })
	                    .style("strokeWidth", function (t) { return t.data.strokeWidth; })
	                    .style("stroke-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, hasSelection, false); })
	                    .style("cursor", "default")
	                    .attr("transform", function (t) { return visuals.SVGUtil.translate(t.data.x, t.data.y); })
	                    .attr('d', function (t) {
	                    return arc.innerRadius(0).outerRadius(function (t) { return t.data.radius; })(t);
	                });
	                slices.exit().remove();
	                this.updateInternalDataLabels(viewport, redrawDataLabels);
	                if (this.tooltipsEnabled) {
	                    visuals.TooltipManager.addTooltip(this.sliceGraphicsContext, function (tooltipEvent) { return tooltipEvent.data.data.tooltipInfo; });
	                    slices.style("pointer-events", "all");
	                }
	                var allData = data.bubbleData.slice();
	                for (var i = 0, ilen = sliceData.length; i < ilen; i++) {
	                    allData.push.apply(allData, sliceData[i]);
	                }
	                var behaviorOptions = {
	                    bubbleEventGroup: this.bubbleGraphicsContext,
	                    sliceEventGroup: this.sliceGraphicsContext,
	                    bubbles: bubbles,
	                    slices: slices,
	                    clearCatcher: this.clearCatcher,
	                    dataPoints: allData,
	                };
	                return behaviorOptions;
	            };
	            MapBubbleDataPointRenderer.prototype.updateInternalDataLabels = function (viewport, redrawDataLabels) {
	                var labelSettings = this.dataLabelsSettings;
	                var dataLabels = [];
	                if (labelSettings && (labelSettings.show || labelSettings.showCategory)) {
	                    var labelDataPoints = this.createLabelDataPoints();
	                    var labelLayout = new powerbi.LabelLayout({
	                        maximumOffset: visuals.NewDataLabelUtils.maxLabelOffset,
	                        startingOffset: visuals.NewDataLabelUtils.startingLabelOffset
	                    });
	                    var labelDataPointsGroup = {
	                        labelDataPoints: labelDataPoints,
	                        maxNumberOfLabels: labelDataPoints.length
	                    };
	                    dataLabels = labelLayout.layout([labelDataPointsGroup], { width: viewport.width, height: viewport.height });
	                }
	                visuals.NewDataLabelUtils.drawLabelBackground(this.labelGraphicsContext, dataLabels, powerbi.visuals.DefaultBackgroundColor, powerbi.visuals.DefaultFillOpacity);
	                visuals.NewDataLabelUtils.drawDefaultLabels(this.labelGraphicsContext, dataLabels, false); // Once we properly split up and handle show and showCategory, the false here should change to !labelSettings.showCategory
	            };
	            MapBubbleDataPointRenderer.prototype.createLabelDataPoints = function () {
	                var data = this.mapRendererData;
	                var labelDataPoints = [];
	                var dataPoints = data.bubbleData;
	                dataPoints = dataPoints.concat(_.map(data.sliceData, function (value) { return value[0]; }));
	                var labelSettings = this.dataLabelsSettings;
	                for (var _i = 0, dataPoints_1 = dataPoints; _i < dataPoints_1.length; _i++) {
	                    var dataPoint = dataPoints_1[_i];
	                    debug.assertValue(dataPoint, 'dataPoint should never be null/undefined');
	                    var text = dataPoint.labeltext;
	                    var properties = {
	                        text: text,
	                        fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
	                        fontSize: PixelConverter.fromPoint(labelSettings.fontSize),
	                        fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight,
	                    };
	                    var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
	                    var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
	                    labelDataPoints.push({
	                        isPreferred: true,
	                        text: text,
	                        textSize: {
	                            width: textWidth,
	                            height: textHeight,
	                        },
	                        outsideFill: labelSettings.labelColor ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultInsideLabelColor,
	                        insideFill: visuals.NewDataLabelUtils.defaultInsideLabelColor,
	                        parentType: 0 /* Point */,
	                        parentShape: {
	                            point: {
	                                x: dataPoint.x,
	                                y: dataPoint.y,
	                            },
	                            radius: dataPoint.radius,
	                            validPositions: MapBubbleDataPointRenderer.validLabelPositions,
	                        },
	                        fontSize: labelSettings.fontSize,
	                        identity: undefined,
	                        hasBackground: true,
	                    });
	                }
	                return labelDataPoints;
	            };
	            MapBubbleDataPointRenderer.validLabelPositions = [1 /* Above */, 2 /* Below */, 4 /* Left */, 8 /* Right */];
	            return MapBubbleDataPointRenderer;
	        }());
	        visuals.MapBubbleDataPointRenderer = MapBubbleDataPointRenderer;
	        var MapShapeDataPointRenderer = (function () {
	            function MapShapeDataPointRenderer(fillMapDataLabelsEnabled, tooltipsEnabled) {
	                this.filledMapDataLabelsEnabled = fillMapDataLabelsEnabled;
	                this.tooltipsEnabled = tooltipsEnabled;
	            }
	            MapShapeDataPointRenderer.getFilledMapParams = function (category, dataCount) {
	                switch (category) {
	                    case visuals.MapUtil.CategoryTypes.Continent:
	                    case visuals.MapUtil.CategoryTypes.CountryRegion:
	                        if (dataCount < 10) {
	                            return { level: 1, maxPolygons: 50, strokeWidth: 0 };
	                        }
	                        else if (dataCount < 30) {
	                            return { level: 1, maxPolygons: 20, strokeWidth: 0 };
	                        }
	                        return { level: 1, maxPolygons: 5, strokeWidth: 0 };
	                    default:
	                        if (dataCount < 100) {
	                            return { level: 1, maxPolygons: 5, strokeWidth: 6 };
	                        }
	                        if (dataCount < 200) {
	                            return { level: 0, maxPolygons: 5, strokeWidth: 6 };
	                        }
	                        return { level: 0, maxPolygons: 5, strokeWidth: 0 };
	                }
	            };
	            MapShapeDataPointRenderer.buildPaths = function (locations) {
	                var paths = [];
	                for (var i = 0; i < locations.length; i++) {
	                    var location_2 = locations[i];
	                    var polygon = location_2.geographic;
	                    if (polygon.length > 2) {
	                        paths.push(location_2);
	                    }
	                }
	                return paths;
	            };
	            MapShapeDataPointRenderer.prototype.init = function (mapControl, mapDiv, addClearCatcher) {
	                /*
	                    The layout of the visual would look like :
	                    <div class="visual mapControl">
	                        <div class="MicrosoftMap">
	                            <!-- Bing maps stuff -->
	                            <svg>
	                                <rect class="clearCatcher"></rect>
	                            </svg>
	                        </div>
	                        <svg>
	                            <g class="mapShapes>
	                                <!-- our geometry -->
	                            </g>
	                        </svg>
	                    </div>
	    
	                */
	                this.mapControl = mapControl;
	                this.polygonInfo = new visuals.MapPolygonInfo();
	                this.root = mapDiv;
	                var root = d3.select(mapDiv[0]);
	                root.attr('drag-resize-disabled', 'true'); // Enable panning within the maps in IE
	                var svg = this.svg = root
	                    .append('svg')
	                    .style('position', 'absolute') // Absolute position so that the svg will overlap with the canvas.
	                    .style("pointer-events", "none");
	                if (addClearCatcher) {
	                    var clearSvg = this.clearSvg = d3.select(this.mapControl.getRootElement())
	                        .append('svg')
	                        .style('position', 'absolute'); // Absolute position so that the svg will overlap with the canvas.
	                    this.clearCatcher = visuals.appendClearCatcher(clearSvg);
	                }
	                this.shapeGraphicsContext = svg
	                    .append('g')
	                    .classed('mapShapes', true);
	                this.labelBackgroundGraphicsContext = svg
	                    .append("g")
	                    .classed(visuals.NewDataLabelUtils.labelBackgroundGraphicsContextClass.class, true);
	                this.labelGraphicsContext = svg
	                    .append("g")
	                    .classed(visuals.NewDataLabelUtils.labelGraphicsContextClass.class, true);
	                this.clearMaxShapeDimension();
	                this.dataLabelsSettings = visuals.dataLabelUtils.getDefaultMapLabelSettings();
	            };
	            MapShapeDataPointRenderer.prototype.setData = function (data) {
	                this.mapData = data;
	            };
	            MapShapeDataPointRenderer.prototype.clearDataPoints = function () {
	                this.mapData = {
	                    dataPoints: [],
	                    geocodingCategory: null,
	                    hasDynamicSeries: false,
	                    hasSize: false,
	                };
	            };
	            MapShapeDataPointRenderer.prototype.getDataPointCount = function () {
	                if (!this.mapData)
	                    return 0;
	                // Filter out any data points without a location since those aren't actually being drawn
	                return _.filter(this.mapData.dataPoints, function (value) { return !!value.paths; }).length;
	            };
	            MapShapeDataPointRenderer.prototype.converter = function (viewport, dataView, labelSettings, interactivityService) {
	                this.clearMaxShapeDimension();
	                this.dataLabelsSettings = labelSettings;
	                var strokeWidth = 1;
	                var shapeData = [];
	                var dataPoints = this.mapData ? this.mapData.dataPoints : [];
	                for (var categoryIndex = 0, categoryCount = dataPoints.length; categoryIndex < categoryCount; categoryIndex++) {
	                    var categorical = dataView ? dataView.categorical : null;
	                    var dataPoint = dataPoints[categoryIndex];
	                    var subDataPoint = dataPoint.subDataPoints[0];
	                    var paths = dataPoint.paths;
	                    var grouped = void 0;
	                    var sizeIndex = -1;
	                    var dataValuesSource = void 0;
	                    if (categorical && categorical.values) {
	                        grouped = categorical.values.grouped();
	                        sizeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Size");
	                        dataValuesSource = categorical.values.source;
	                    }
	                    if (paths) {
	                        var value = dataPoint.value;
	                        var categoryValue = dataPoint.categoryValue;
	                        var identity = subDataPoint.identity;
	                        var idKey = identity.getKey();
	                        var formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager();
	                        //Determine Largest Shape
	                        var mainShapeIndex = MapShapeDataPointRenderer.getIndexOfLargestShape(paths);
	                        for (var pathIndex = 0, pathCount = paths.length; pathIndex < pathCount; pathIndex++) {
	                            var path = paths[pathIndex];
	                            var labelFormatString = (dataView && dataView.categorical && !_.isEmpty(dataView.categorical.values)) ? visuals.valueFormatter.getFormatString(dataView.categorical.values[0].source, visuals.filledMapProps.general.formatString) : undefined;
	                            this.setMaxShapeDimension(path.absoluteBounds.width, path.absoluteBounds.height);
	                            var formatter = formattersCache.getOrCreate(labelFormatString, labelSettings);
	                            shapeData.push({
	                                absolutePointArray: path.absolute,
	                                path: path.absoluteString,
	                                fill: subDataPoint.fill,
	                                stroke: subDataPoint.stroke,
	                                strokeWidth: strokeWidth,
	                                tooltipInfo: subDataPoint.tooltipInfo,
	                                identity: identity,
	                                selected: false,
	                                key: JSON.stringify({ id: idKey, pIdx: pathIndex }),
	                                displayLabel: pathIndex === mainShapeIndex,
	                                labeltext: categoryValue,
	                                catagoryLabeltext: (value != null) ? visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(value)) : undefined,
	                                labelFormatString: labelFormatString,
	                            });
	                        }
	                    }
	                }
	                if (interactivityService)
	                    interactivityService.applySelectionStateToData(shapeData);
	                return { shapeData: shapeData };
	            };
	            MapShapeDataPointRenderer.prototype.updateInternal = function (data, viewport, dataChanged, interactivityService, redrawDataLabels) {
	                debug.assertValue(viewport, "viewport");
	                Map.removeTransform3d(this.root);
	                this.mapRendererData = data;
	                if (this.svg) {
	                    this.svg
	                        .style("width", viewport.width.toString() + "px")
	                        .style("height", viewport.height.toString() + "px");
	                }
	                if (this.clearSvg) {
	                    this.clearSvg
	                        .style("width", viewport.width.toString() + "px")
	                        .style("height", viewport.height.toString() + "px");
	                }
	                this.polygonInfo.reCalc(this.mapControl, viewport.width, viewport.height);
	                this.shapeGraphicsContext.attr("transform", this.polygonInfo.transformToString(this.polygonInfo.transform));
	                var hasSelection = interactivityService && interactivityService.hasSelection();
	                var shapes = this.shapeGraphicsContext.selectAll("polygon").data(data.shapeData, function (d) { return d.key; });
	                shapes.enter()
	                    .append("polygon")
	                    .classed("shape", true)
	                    .attr("points", function (d) {
	                    return d.path;
	                });
	                shapes
	                    .style("fill", function (d) { return d.fill; })
	                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); })
	                    .style("cursor", "default");
	                if (dataChanged) {
	                    // We only update the paths of existing shapes if we have a change in the data.  Updating the lengthy path
	                    // strings every update during resize or zooming/panning is extremely bad for performance.
	                    shapes
	                        .attr("points", function (d) {
	                        return d.path;
	                    });
	                }
	                shapes.exit()
	                    .remove();
	                this.updateInternalDataLabels(viewport, redrawDataLabels);
	                if (this.tooltipsEnabled) {
	                    visuals.TooltipManager.addTooltip(this.shapeGraphicsContext, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
	                    shapes.style("pointer-events", "all");
	                }
	                var behaviorOptions = {
	                    shapeEventGroup: this.shapeGraphicsContext,
	                    shapes: shapes,
	                    clearCatcher: this.clearCatcher,
	                    dataPoints: data.shapeData,
	                };
	                return behaviorOptions;
	            };
	            MapShapeDataPointRenderer.prototype.getDataPointPadding = function () {
	                return 12;
	            };
	            MapShapeDataPointRenderer.getIndexOfLargestShape = function (paths) {
	                var largestShapeIndex = 0;
	                var largestShapeArea = 0;
	                for (var pathIndex = 0, pathCount = paths.length; pathIndex < pathCount; pathIndex++) {
	                    var path = paths[pathIndex];
	                    // Using the area of the polygon (and taking the largest)
	                    var polygon = new Polygon(path.absolute);
	                    var currentShapeArea = Math.abs(Polygon.calculateAbsolutePolygonArea(polygon.polygonPoints));
	                    if (currentShapeArea > largestShapeArea) {
	                        largestShapeIndex = pathIndex;
	                        largestShapeArea = currentShapeArea;
	                    }
	                }
	                return largestShapeIndex;
	            };
	            MapShapeDataPointRenderer.prototype.updateInternalDataLabels = function (viewport, redrawDataLabels) {
	                var labelSettings = this.dataLabelsSettings;
	                var labels;
	                if (labelSettings && (labelSettings.show || labelSettings.showCategory)) {
	                    var labelDataPoints = this.createLabelDataPoints();
	                    if (this.labelLayout === undefined) {
	                        this.labelLayout = new powerbi.FilledMapLabelLayout();
	                    }
	                    labels = this.labelLayout.layout(labelDataPoints, { width: viewport.width, height: viewport.height }, this.polygonInfo.transform, redrawDataLabels);
	                }
	                this.drawLabelStems(this.labelGraphicsContext, labels, labelSettings.show, labelSettings.showCategory);
	                visuals.NewDataLabelUtils.drawLabelBackground(this.labelGraphicsContext, labels, powerbi.visuals.DefaultBackgroundColor, powerbi.visuals.DefaultFillOpacity);
	                visuals.NewDataLabelUtils.drawDefaultLabels(this.labelGraphicsContext, labels, false, labelSettings.show && labelSettings.showCategory);
	            };
	            MapShapeDataPointRenderer.prototype.clearMaxShapeDimension = function () {
	                this.maxShapeDimension = 0;
	            };
	            MapShapeDataPointRenderer.prototype.setMaxShapeDimension = function (width, height) {
	                this.maxShapeDimension = Math.max(width, this.maxShapeDimension);
	                this.maxShapeDimension = Math.max(height, this.maxShapeDimension);
	            };
	            MapShapeDataPointRenderer.prototype.createLabelDataPoints = function () {
	                var data = this.mapRendererData;
	                var labelDataPoints = [];
	                if (this.filledMapDataLabelsEnabled) {
	                    var dataShapes = data.shapeData;
	                    var labelSettings = this.dataLabelsSettings;
	                    for (var _i = 0, dataShapes_1 = dataShapes; _i < dataShapes_1.length; _i++) {
	                        var dataShape = dataShapes_1[_i];
	                        if (!dataShape.displayLabel) {
	                            continue;
	                        }
	                        var text = void 0, secondRowText = void 0;
	                        var secondRowTextWidth = 0;
	                        var hasSecondRow = false;
	                        if (this.dataLabelsSettings.show && !this.dataLabelsSettings.showCategory) {
	                            text = dataShape.catagoryLabeltext;
	                            if (text === undefined)
	                                continue;
	                        }
	                        else if (this.dataLabelsSettings.showCategory && !this.dataLabelsSettings.show) {
	                            text = dataShape.labeltext;
	                            if (text === undefined)
	                                continue;
	                        }
	                        else if (this.dataLabelsSettings.showCategory && this.dataLabelsSettings.show) {
	                            text = dataShape.catagoryLabeltext;
	                            secondRowText = dataShape.labeltext;
	                            if (text === undefined && secondRowText === undefined)
	                                continue;
	                            hasSecondRow = true;
	                        }
	                        if (hasSecondRow) {
	                            var secondRowProperties = {
	                                text: secondRowText,
	                                fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
	                                fontSize: visuals.NewDataLabelUtils.LabelTextProperties.fontSize,
	                                fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight,
	                            };
	                            secondRowTextWidth = powerbi.TextMeasurementService.measureSvgTextWidth(secondRowProperties);
	                        }
	                        var firstRowProperties = {
	                            text: text,
	                            fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
	                            fontSize: visuals.NewDataLabelUtils.LabelTextProperties.fontSize,
	                            fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight,
	                        };
	                        var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(firstRowProperties);
	                        var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(firstRowProperties);
	                        if (secondRowText && dataShape.labeltext !== undefined && dataShape.catagoryLabeltext !== undefined) {
	                            textHeight = textHeight * 2;
	                        }
	                        var labelDataPoint = {
	                            parentType: 2 /* Polygon */,
	                            parentShape: {
	                                polygon: new Polygon(dataShape.absolutePointArray),
	                                validPositions: MapShapeDataPointRenderer.validLabelPolygonPositions,
	                            },
	                            text: text,
	                            secondRowText: secondRowText,
	                            textSize: {
	                                width: Math.max(textWidth, secondRowTextWidth),
	                                height: textHeight,
	                            },
	                            insideFill: labelSettings.labelColor,
	                            outsideFill: labelSettings.labelColor ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultInsideLabelColor,
	                            isPreferred: false,
	                            identity: undefined,
	                            hasBackground: true,
	                        };
	                        labelDataPoints.push(labelDataPoint);
	                    }
	                }
	                return labelDataPoints;
	            };
	            MapShapeDataPointRenderer.prototype.drawLabelStems = function (labelsContext, dataLabels, showText, showCategory) {
	                var filteredLabels = _.filter(dataLabels, function (d) { return d.isVisible; });
	                var key = function (d, index) { return d.identity ? d.identity.getKeyWithoutHighlight() : index; };
	                visuals.NewDataLabelUtils.drawLabelLeaderLines(labelsContext, filteredLabels, key, visuals.LeaderLineColor);
	            };
	            MapShapeDataPointRenderer.validLabelPolygonPositions = [256 /* Center */, 2 /* Below */, 1 /* Above */, 8 /* Right */, 4 /* Left */, 16 /* BelowRight */, 32 /* BelowLeft */, 64 /* AboveRight */, 128 /* AboveLeft */];
	            return MapShapeDataPointRenderer;
	        }());
	        visuals.MapShapeDataPointRenderer = MapShapeDataPointRenderer;
	        var DefaultLocationZoomLevel = 11;
	        var Map = (function () {
	            function Map(options) {
	                this.isDestroyed = false;
	                if (options.filledMap) {
	                    this.dataPointRenderer = new MapShapeDataPointRenderer(options.filledMapDataLabelsEnabled, options.tooltipsEnabled);
	                    this.filledMapDataLabelsEnabled = options.filledMapDataLabelsEnabled;
	                    this.isFilledMap = true;
	                }
	                else {
	                    this.dataPointRenderer = new MapBubbleDataPointRenderer(options.tooltipsEnabled);
	                    this.isFilledMap = false;
	                }
	                this.mapControlFactory = options.mapControlFactory ? options.mapControlFactory : this.getDefaultMapControlFactory();
	                this.behavior = options.behavior;
	                this.tooltipsEnabled = options.tooltipsEnabled;
	                this.tooltipBucketEnabled = options.tooltipBucketEnabled;
	                this.disableZooming = options.disableZooming;
	                this.disablePanning = options.disablePanning;
	                this.isLegendScrollable = !!options.behavior;
	                this.viewChangeThrottleInterval = options.viewChangeThrottleInterval;
	                this.enableCurrentLocation = options.enableCurrentLocation;
	                this.boundsHaveBeenUpdated = false;
	            }
	            Map.prototype.init = function (options) {
	                var _this = this;
	                debug.assertValue(options, 'options');
	                var element = this.element = options.element;
	                this.pendingGeocodingRender = false;
	                this.currentViewport = options.viewport;
	                this.style = options.style;
	                this.colors = this.style.colorPalette.dataColors;
	                if (this.behavior)
	                    this.interactivityService = visuals.createInteractivityService(options.host);
	                this.dataLabelsSettings = visuals.dataLabelUtils.getDefaultMapLabelSettings();
	                this.legend = powerbi.visuals.createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, this.interactivityService, this.isLegendScrollable);
	                this.legendHeight = 0;
	                this.legendData = { dataPoints: [] };
	                this.geoTaggingAnalyzerService = powerbi.createGeoTaggingAnalyzerService(options.host.getLocalizedString);
	                this.host = options.host;
	                if (options.host.locale)
	                    this.locale = options.host.locale();
	                this.geocoder = options.host.geocoder();
	                this.promiseFactory = options.host.promiseFactory();
	                this.resetBounds();
	                this.isDestroyed = false;
	                this.mapControlFactory.ensureMap(this.locale, function () {
	                    if (_this.isDestroyed)
	                        return;
	                    Map.removeHillShading();
	                    Microsoft.Maps.loadModule('Microsoft.Maps.Overlays.Style', {
	                        callback: function () {
	                            if (_this.isDestroyed)
	                                return;
	                            _this.initialize(element[0]);
	                            if (_this.enableCurrentLocation) {
	                                _this.createCurrentLocation(element);
	                            }
	                        }
	                    });
	                });
	            };
	            Map.prototype.destroy = function () {
	                this.isDestroyed = true;
	                if (this.geocodingContext && this.geocodingContext.timeout) {
	                    this.geocodingContext.timeout.resolve(null);
	                }
	            };
	            Map.prototype.createCurrentLocation = function (element) {
	                var _this = this;
	                var myLocBtn = InJs.DomFactory.div().addClass("mapCurrentLocation").appendTo(element);
	                var pushpin;
	                myLocBtn.on('click', function () {
	                    if (_this.isCurrentLocation) {
	                        // Restore previous map view and remove pushpin
	                        if (pushpin) {
	                            _this.mapControl.entities.remove(pushpin);
	                        }
	                        _this.updateInternal(false, false);
	                        _this.isCurrentLocation = false;
	                    }
	                    else {
	                        _this.host.geolocation().getCurrentPosition(function (position) {
	                            var location = new Microsoft.Maps.Location(position.coords.latitude, position.coords.longitude);
	                            if (pushpin) {
	                                _this.mapControl.entities.remove(pushpin);
	                            }
	                            pushpin = visuals.MapUtil.CurrentLocation.createPushpin(location);
	                            _this.mapControl.entities.push(pushpin);
	                            _this.updateMapView(location, DefaultLocationZoomLevel);
	                            _this.isCurrentLocation = true;
	                        });
	                    }
	                });
	            };
	            Map.prototype.addDataPoint = function (dataPoint) {
	                var location = dataPoint.location;
	                this.updateBounds(location.latitude, location.longitude);
	                this.scheduleRedraw();
	            };
	            Map.prototype.scheduleRedraw = function () {
	                var _this = this;
	                if (!this.pendingGeocodingRender && this.mapControl) {
	                    this.pendingGeocodingRender = true;
	                    // Maintain a 3 second delay between redraws from geocoded geometry
	                    setTimeout(function () {
	                        _this.updateInternal(true, true);
	                        _this.pendingGeocodingRender = false;
	                    }, Map.ScheduleRedrawInterval);
	                }
	            };
	            Map.prototype.enqueueGeoCode = function (dataPoint) {
	                var _this = this;
	                var location = this.geocoder.tryGeocodeImmediate(dataPoint.geocodingQuery, this.geocodingCategory);
	                if (location)
	                    this.completeGeoCode(dataPoint, location);
	                else {
	                    var geocodingContext_1 = this.geocodingContext;
	                    this.geocoder.geocode(dataPoint.geocodingQuery, this.geocodingCategory, { timeout: geocodingContext_1.timeout.promise }).then(function (location) {
	                        if (!_this.isDestroyed && location && geocodingContext_1 === _this.geocodingContext) {
	                            _this.completeGeoCode(dataPoint, location);
	                        }
	                    });
	                }
	            };
	            Map.prototype.completeGeoCode = function (dataPoint, location) {
	                dataPoint.location = location;
	                this.addDataPoint(dataPoint);
	            };
	            Map.prototype.enqueueGeoCodeAndGeoShape = function (dataPoint, params) {
	                var _this = this;
	                var location = this.geocoder.tryGeocodeImmediate(dataPoint.geocodingQuery, this.geocodingCategory);
	                if (location)
	                    this.completeGeoCodeAndGeoShape(dataPoint, params, location);
	                else {
	                    var geocodingContext_2 = this.geocodingContext;
	                    this.geocoder.geocode(dataPoint.geocodingQuery, this.geocodingCategory, { timeout: geocodingContext_2.timeout.promise }).then(function (location) {
	                        if (!_this.isDestroyed && location && geocodingContext_2 === _this.geocodingContext) {
	                            _this.completeGeoCodeAndGeoShape(dataPoint, params, location);
	                        }
	                    });
	                }
	            };
	            Map.prototype.completeGeoCodeAndGeoShape = function (dataPoint, params, location) {
	                dataPoint.location = location;
	                this.enqueueGeoShape(dataPoint, params);
	            };
	            Map.prototype.enqueueGeoShape = function (dataPoint, params) {
	                var _this = this;
	                debug.assertValue(dataPoint.location, "cachedLocation");
	                var result = this.geocoder.tryGeocodeBoundaryImmediate(dataPoint.location.latitude, dataPoint.location.longitude, this.geocodingCategory, params.level, params.maxPolygons);
	                if (result)
	                    this.completeGeoShape(dataPoint, params, result);
	                else {
	                    var geocodingContext_3 = this.geocodingContext;
	                    this.geocoder.geocodeBoundary(dataPoint.location.latitude, dataPoint.location.longitude, this.geocodingCategory, params.level, params.maxPolygons, { timeout: geocodingContext_3.timeout.promise })
	                        .then(function (result) {
	                        if (!_this.isDestroyed && result && geocodingContext_3 === _this.geocodingContext)
	                            _this.completeGeoShape(dataPoint, params, result);
	                    });
	                }
	            };
	            Map.prototype.completeGeoShape = function (dataPoint, params, result) {
	                var paths;
	                if (result.locations.length === 0 || result.locations[0].geographic) {
	                    paths = MapShapeDataPointRenderer.buildPaths(result.locations);
	                }
	                else {
	                    visuals.MapUtil.calcGeoData(result);
	                    paths = MapShapeDataPointRenderer.buildPaths(result.locations);
	                }
	                dataPoint.paths = paths;
	                this.addDataPoint(dataPoint);
	            };
	            Map.prototype.getOptimumLevelOfDetail = function (width, height) {
	                var dataPointCount = this.dataPointRenderer.getDataPointCount();
	                if (dataPointCount === 0)
	                    return visuals.MapUtil.MinLevelOfDetail;
	                var threshold = this.dataPointRenderer.getDataPointPadding();
	                for (var levelOfDetail = visuals.MapUtil.MaxLevelOfDetail; levelOfDetail >= visuals.MapUtil.MinLevelOfDetail; levelOfDetail--) {
	                    var minXmaxY = visuals.MapUtil.latLongToPixelXY(this.minLatitude, this.minLongitude, levelOfDetail);
	                    var maxXminY = visuals.MapUtil.latLongToPixelXY(this.maxLatitude, this.maxLongitude, levelOfDetail);
	                    if (maxXminY.x - minXmaxY.x + threshold <= width && minXmaxY.y - maxXminY.y + threshold <= height) {
	                        // if we have less than 2 data points we should not zoom in "too much"
	                        if (dataPointCount < 2)
	                            levelOfDetail = Math.min(visuals.MapUtil.MaxAutoZoomLevel, levelOfDetail);
	                        return levelOfDetail;
	                    }
	                }
	                return visuals.MapUtil.MinLevelOfDetail;
	            };
	            Map.prototype.getViewCenter = function (levelOfDetail) {
	                var minXmaxY = visuals.MapUtil.latLongToPixelXY(this.minLatitude, this.minLongitude, levelOfDetail);
	                var maxXminY = visuals.MapUtil.latLongToPixelXY(this.maxLatitude, this.maxLongitude, levelOfDetail);
	                return visuals.MapUtil.pixelXYToLocation((minXmaxY.x + maxXminY.x) / 2.0, (maxXminY.y + minXmaxY.y) / 2.0, levelOfDetail);
	            };
	            Map.prototype.resetBounds = function () {
	                this.boundsHaveBeenUpdated = false;
	                this.minLongitude = visuals.MapUtil.MaxAllowedLongitude;
	                this.maxLongitude = visuals.MapUtil.MinAllowedLongitude;
	                this.minLatitude = visuals.MapUtil.MaxAllowedLatitude;
	                this.maxLatitude = visuals.MapUtil.MinAllowedLatitude;
	            };
	            Map.prototype.updateBounds = function (latitude, longitude) {
	                this.boundsHaveBeenUpdated = true;
	                if (longitude < this.minLongitude) {
	                    this.minLongitude = longitude;
	                }
	                if (longitude > this.maxLongitude) {
	                    this.maxLongitude = longitude;
	                }
	                if (latitude < this.minLatitude) {
	                    this.minLatitude = latitude;
	                }
	                if (latitude > this.maxLatitude) {
	                    this.maxLatitude = latitude;
	                }
	            };
	            Map.legendObject = function (dataView) {
	                return dataView &&
	                    dataView.metadata &&
	                    dataView.metadata.objects &&
	                    dataView.metadata.objects['legend'];
	            };
	            Map.isLegendHidden = function (dataView) {
	                var legendObject = Map.legendObject(dataView);
	                return legendObject != null && legendObject[visuals.legendProps.show] === false;
	            };
	            Map.legendPosition = function (dataView) {
	                var legendObject = Map.legendObject(dataView);
	                return legendObject && visuals.LegendPosition[legendObject[visuals.legendProps.position]];
	            };
	            Map.getLegendFontSize = function (dataView) {
	                var legendObject = Map.legendObject(dataView);
	                return (legendObject && legendObject[visuals.legendProps.fontSize]) || visuals.SVGLegend.DefaultFontSizeInPt;
	            };
	            Map.isShowLegendTitle = function (dataView) {
	                var legendObject = Map.legendObject(dataView);
	                return legendObject && legendObject[visuals.legendProps.showTitle];
	            };
	            Map.prototype.legendTitle = function () {
	                var legendObject = Map.legendObject(this.dataView);
	                return (legendObject && legendObject[visuals.legendProps.titleText]) || this.legendData.title;
	            };
	            Map.prototype.renderLegend = function (legendData) {
	                var hideLegend = Map.isLegendHidden(this.dataView);
	                var showTitle = Map.isShowLegendTitle(this.dataView);
	                var title = this.legendTitle();
	                // Update the legendData based on the hide flag.  Cartesian passes in no-datapoints. OnResize reuses the legendData, so this can't mutate.
	                var clonedLegendData = {
	                    dataPoints: hideLegend ? [] : legendData.dataPoints,
	                    grouped: legendData.grouped,
	                    title: showTitle ? title : "",
	                    fontSize: Map.getLegendFontSize(this.dataView)
	                };
	                // Update the orientation to match what's in the dataView
	                var targetOrientation = Map.legendPosition(this.dataView);
	                if (targetOrientation !== undefined) {
	                    this.legend.changeOrientation(targetOrientation);
	                }
	                else {
	                    this.legend.changeOrientation(visuals.LegendPosition.Top);
	                }
	                this.legend.drawLegend(clonedLegendData, this.currentViewport);
	            };
	            /** Note: public for UnitTest */
	            Map.calculateGroupSizes = function (categorical, grouped, groupSizeTotals, sizeMeasureIndex, currentValueScale) {
	                var categoryCount = categorical.values[0].values.length;
	                var seriesCount = grouped.length;
	                for (var i = 0, len = categoryCount; i < len; ++i) {
	                    var groupTotal = null;
	                    if (sizeMeasureIndex >= 0) {
	                        for (var j = 0; j < seriesCount; ++j) {
	                            var value = grouped[j].values[sizeMeasureIndex].values[i];
	                            if (value) {
	                                if (groupTotal === null) {
	                                    groupTotal = value;
	                                }
	                                else {
	                                    groupTotal += value;
	                                }
	                            }
	                        }
	                    }
	                    groupSizeTotals.push(groupTotal);
	                    if (groupTotal) {
	                        if (!currentValueScale) {
	                            currentValueScale = {
	                                min: groupTotal,
	                                max: groupTotal
	                            };
	                        }
	                        else {
	                            currentValueScale.min = Math.min(currentValueScale.min, groupTotal);
	                            currentValueScale.max = Math.max(currentValueScale.max, groupTotal);
	                        }
	                    }
	                }
	                return currentValueScale;
	            };
	            /** Note: public for UnitTest */
	            Map.calculateRadius = function (range, value) {
	                var rangeDiff = range ? range.max - range.min : 0;
	                var radius = 6;
	                if (range != null && value != null && rangeDiff !== 0) {
	                    radius = (14 * ((value - range.min) / rangeDiff)) + 6;
	                }
	                return radius;
	            };
	            /** Note: public for UnitTest */
	            Map.getGeocodingCategory = function (categorical, geoTaggingAnalyzerService) {
	                if (categorical && categorical.categories && categorical.categories.length > 0 && categorical.categories[0].source) {
	                    // Check categoryString for manually specified information in the model
	                    var type = categorical.categories[0].source.type;
	                    if (type && type.categoryString) {
	                        return geoTaggingAnalyzerService.getFieldType(type.categoryString);
	                    }
	                    // Check the category name
	                    var categoryName = categorical.categories[0].source.displayName;
	                    var geotaggedResult = geoTaggingAnalyzerService.getFieldType(categoryName);
	                    if (geotaggedResult)
	                        return geotaggedResult;
	                    // Checking roles for VRM backwards compatibility
	                    var roles = categorical.categories[0].source.roles;
	                    if (roles) {
	                        var roleNames = Object.keys(roles);
	                        for (var i = 0, len = roleNames.length; i < len; ++i) {
	                            var typeFromRoleName = geoTaggingAnalyzerService.getFieldType(roleNames[i]);
	                            if (typeFromRoleName)
	                                return typeFromRoleName;
	                        }
	                    }
	                }
	                return undefined;
	            };
	            /** Note: public for UnitTest */
	            Map.hasSizeField = function (values, defaultIndexIfNoRole) {
	                if (_.isEmpty(values))
	                    return false;
	                for (var i = 0, ilen = values.length; i < ilen; i++) {
	                    var roles = values[i].source.roles;
	                    // case for Power Q&A since Power Q&A does not assign role to measures.
	                    if (!roles && i === defaultIndexIfNoRole && values[i].source.type.numeric)
	                        return true;
	                    if (roles) {
	                        var roleNames = Object.keys(roles);
	                        for (var j = 0, jlen = roleNames.length; j < jlen; j++) {
	                            var role = roleNames[j];
	                            if (role === "Size")
	                                return true;
	                        }
	                    }
	                }
	                return false;
	            };
	            Map.shouldEnumerateDataPoints = function (dataView, usesSizeForGradient) {
	                var hasSeries = DataRoleHelper.hasRoleInDataView(dataView, 'Series');
	                var gradientRole = usesSizeForGradient ? 'Size' : 'Gradient';
	                var hasGradientRole = DataRoleHelper.hasRoleInDataView(dataView, gradientRole);
	                return hasSeries || !hasGradientRole;
	            };
	            Map.shouldEnumerateCategoryLabels = function (isFilledMap, filledMapDataLabelsEnabled) {
	                return (!isFilledMap || filledMapDataLabelsEnabled);
	            };
	            Map.prototype.enumerateObjectInstances = function (options) {
	                var enumeration = new visuals.ObjectEnumerationBuilder();
	                switch (options.objectName) {
	                    case 'dataPoint':
	                        if (Map.shouldEnumerateDataPoints(this.dataView, this.isFilledMap)) {
	                            var bubbleData = [];
	                            //TODO: better way of getting this data
	                            var hasDynamicSeries = this.hasDynamicSeries;
	                            if (!hasDynamicSeries) {
	                                var mapData = this.dataPointRenderer.converter(this.getMapViewPort(), this.dataView, this.dataLabelsSettings, this.interactivityService, this.tooltipsEnabled);
	                                bubbleData = mapData.bubbleData;
	                            }
	                            Map.enumerateDataPoints(enumeration, this.dataPointsToEnumerate, this.colors, hasDynamicSeries, this.defaultDataPointColor, this.showAllDataPoints, bubbleData);
	                        }
	                        break;
	                    case 'categoryLabels':
	                        if (Map.shouldEnumerateCategoryLabels(this.isFilledMap, this.filledMapDataLabelsEnabled)) {
	                            visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, this.dataLabelsSettings, true, true);
	                        }
	                        break;
	                    case 'legend':
	                        if (this.hasDynamicSeries) {
	                            Map.enumerateLegend(enumeration, this.dataView, this.legend, this.legendTitle());
	                        }
	                        break;
	                    case 'labels':
	                        if (this.filledMapDataLabelsEnabled) {
	                            this.dataLabelsSettings = this.dataLabelsSettings ? this.dataLabelsSettings : visuals.dataLabelUtils.getDefaultMapLabelSettings();
	                            var labelSettingOptions = {
	                                enumeration: enumeration,
	                                dataLabelsSettings: this.dataLabelsSettings,
	                                show: true,
	                                displayUnits: true,
	                                precision: true,
	                            };
	                            visuals.dataLabelUtils.enumerateDataLabels(labelSettingOptions);
	                        }
	                        break;
	                }
	                return enumeration.complete();
	            };
	            Map.enumerateDataPoints = function (enumeration, dataPoints, colors, hasDynamicSeries, defaultDataPointColor, showAllDataPoints, bubbleData) {
	                var seriesLength = dataPoints && dataPoints.length;
	                if (hasDynamicSeries) {
	                    for (var i = 0; i < seriesLength; i++) {
	                        var dataPoint = dataPoints[i];
	                        enumeration.pushInstance({
	                            objectName: 'dataPoint',
	                            displayName: dataPoint.label,
	                            selector: visuals.ColorHelper.normalizeSelector(dataPoint.identity.getSelector()),
	                            properties: {
	                                fill: { solid: { color: dataPoint.color } }
	                            },
	                        });
	                    }
	                }
	                else {
	                    enumeration.pushInstance({
	                        objectName: 'dataPoint',
	                        selector: null,
	                        properties: {
	                            defaultColor: { solid: { color: defaultDataPointColor || colors.getColorByIndex(0).value } }
	                        },
	                    }).pushInstance({
	                        objectName: 'dataPoint',
	                        selector: null,
	                        properties: {
	                            showAllDataPoints: !!showAllDataPoints
	                        },
	                    });
	                    if (bubbleData) {
	                        for (var i = 0; i < bubbleData.length; i++) {
	                            var bubbleDataPoint = bubbleData[i];
	                            enumeration.pushInstance({
	                                objectName: 'dataPoint',
	                                displayName: bubbleDataPoint.labeltext,
	                                selector: visuals.ColorHelper.normalizeSelector(bubbleDataPoint.identity.getSelector()),
	                                properties: {
	                                    fill: { solid: { color: Color.normalizeToHexString(bubbleDataPoint.fill) } }
	                                },
	                            });
	                        }
	                    }
	                }
	            };
	            Map.enumerateLegend = function (enumeration, dataView, legend, legendTitle) {
	                enumeration.pushInstance({
	                    selector: null,
	                    properties: {
	                        show: !Map.isLegendHidden(dataView),
	                        position: visuals.LegendPosition[legend.getOrientation()],
	                        showTitle: Map.isShowLegendTitle(dataView),
	                        titleText: legendTitle,
	                        fontSize: Map.getLegendFontSize(dataView)
	                    },
	                    objectName: 'legend'
	                });
	            };
	            Map.prototype.onDataChanged = function (options) {
	                var _this = this;
	                debug.assertValue(options, 'options');
	                this.resetBounds();
	                if (this.geocodingContext && this.geocodingContext.timeout) {
	                    this.geocodingContext.timeout.resolve(null);
	                }
	                this.geocodingContext = {
	                    timeout: this.promiseFactory.defer(),
	                };
	                if (this.behavior)
	                    this.behavior.resetZoomPan();
	                this.dataLabelsSettings = visuals.dataLabelUtils.getDefaultMapLabelSettings();
	                this.defaultDataPointColor = null;
	                this.showAllDataPoints = null;
	                var dataView = this.dataView = options.dataViews[0];
	                var isFilledMap = this.isFilledMap;
	                var warnings = [];
	                var data = {
	                    dataPoints: [],
	                    geocodingCategory: null,
	                    hasDynamicSeries: false,
	                    hasSize: false,
	                };
	                if (dataView) {
	                    // Handle object-based settings
	                    if (dataView.metadata && dataView.metadata.objects) {
	                        var objects = dataView.metadata.objects;
	                        this.defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.mapProps.dataPoint.defaultColor);
	                        this.showAllDataPoints = powerbi.DataViewObjects.getValue(objects, visuals.mapProps.dataPoint.showAllDataPoints);
	                        this.dataLabelsSettings.showCategory = powerbi.DataViewObjects.getValue(objects, visuals.filledMapProps.categoryLabels.show, this.dataLabelsSettings.showCategory);
	                        if (isFilledMap) {
	                            this.dataLabelsSettings.precision = powerbi.DataViewObjects.getValue(objects, visuals.filledMapProps.labels.labelPrecision, this.dataLabelsSettings.precision);
	                            this.dataLabelsSettings.precision = (this.dataLabelsSettings.precision !== visuals.dataLabelUtils.defaultLabelPrecision && this.dataLabelsSettings.precision < 0) ? 0 : this.dataLabelsSettings.precision;
	                            this.dataLabelsSettings.displayUnits = powerbi.DataViewObjects.getValue(objects, visuals.filledMapProps.labels.labelDisplayUnits, this.dataLabelsSettings.displayUnits);
	                            var datalabelsObj = objects['labels'];
	                            if (datalabelsObj) {
	                                this.dataLabelsSettings.show = (datalabelsObj['show'] !== undefined) ? datalabelsObj['show'] : this.dataLabelsSettings.show;
	                                if (datalabelsObj['color'] !== undefined) {
	                                    this.dataLabelsSettings.labelColor = datalabelsObj['color'].solid.color;
	                                }
	                            }
	                        }
	                        else {
	                            var categoryLabelsObj = objects['categoryLabels'];
	                            if (categoryLabelsObj)
	                                visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(categoryLabelsObj, this.dataLabelsSettings);
	                        }
	                    }
	                    // Convert data
	                    var colorHelper = new visuals.ColorHelper(this.colors, visuals.mapProps.dataPoint.fill, this.defaultDataPointColor);
	                    data = Map.converter(dataView, colorHelper, this.geoTaggingAnalyzerService, isFilledMap, this.tooltipBucketEnabled);
	                    this.hasDynamicSeries = data.hasDynamicSeries;
	                    // Create legend
	                    this.legendData = Map.createLegendData(dataView, colorHelper);
	                    this.dataPointsToEnumerate = this.legendData.dataPoints;
	                    this.renderLegend(this.legendData);
	                    // Start geocoding or geoshaping
	                    if (data != null) {
	                        this.geocodingCategory = data.geocodingCategory;
	                        this.mapControlFactory.ensureMap(this.locale, function () {
	                            if (_this.isDestroyed)
	                                return;
	                            Map.removeHillShading();
	                            var params;
	                            if (isFilledMap) {
	                                params = MapShapeDataPointRenderer.getFilledMapParams(_this.geocodingCategory, data.dataPoints.length);
	                            }
	                            for (var _i = 0, _a = data.dataPoints; _i < _a.length; _i++) {
	                                var dataPoint = _a[_i];
	                                if (!dataPoint.location) {
	                                    var categoryValue = dataPoint.categoryValue;
	                                    if (categoryValue != null && categoryValue !== "") {
	                                        if (isFilledMap)
	                                            _this.enqueueGeoCodeAndGeoShape(dataPoint, params);
	                                        else
	                                            _this.enqueueGeoCode(dataPoint);
	                                    }
	                                }
	                                else if (isFilledMap && !dataPoint.paths) {
	                                    _this.enqueueGeoShape(dataPoint, params);
	                                }
	                                else {
	                                    _this.addDataPoint(dataPoint);
	                                }
	                            }
	                        });
	                    }
	                    else {
	                        // No data from conversion, so clear data points
	                        this.clearDataPoints();
	                    }
	                    if (isFilledMap) {
	                        if (!this.geocodingCategory || !this.geoTaggingAnalyzerService.isGeoshapable(this.geocodingCategory)) {
	                            warnings.push(new visuals.FilledMapWithoutValidGeotagCategoryWarning());
	                        }
	                    }
	                }
	                else {
	                    this.clearDataPoints();
	                    this.renderLegend({
	                        dataPoints: [],
	                        title: undefined,
	                    });
	                    this.dataPointsToEnumerate = [];
	                }
	                if (!_.isEmpty(warnings))
	                    this.host.setWarnings(warnings);
	                this.dataPointRenderer.setData(data);
	                this.updateInternal(true /* dataChanged */, true /* redrawDataLabels */);
	            };
	            Map.converter = function (dataView, colorHelper, geoTaggingAnalyzerService, isFilledMap, tooltipBucketEnabled) {
	                var reader = powerbi.data.createIDataViewCategoricalReader(dataView);
	                var dataPoints = [];
	                var hasDynamicSeries = reader.hasDynamicSeries();
	                var seriesColumnIdentifier = reader.getSeriesColumnIdentityFields();
	                var sizeQueryName = reader.getMeasureQueryName('Size');
	                if (sizeQueryName == null)
	                    sizeQueryName = '';
	                var hasSize = reader.hasValues('Size');
	                var geocodingCategory = null;
	                var formatStringProp = visuals.mapProps.general.formatString;
	                if (reader.hasCategories()) {
	                    // Calculate category totals and range for radius calculation
	                    var categoryTotals = [];
	                    var categoryTotalRange = void 0;
	                    if (hasSize) {
	                        var categoryMin = undefined;
	                        var categoryMax = undefined;
	                        for (var categoryIndex = 0, categoryCount = reader.getCategoryCount(); categoryIndex < categoryCount; categoryIndex++) {
	                            var categoryTotal = void 0;
	                            for (var seriesIndex = 0, seriesCount = reader.getSeriesCount(); seriesIndex < seriesCount; seriesIndex++) {
	                                var currentValue = reader.getValue('Size', categoryIndex, seriesIndex);
	                                // Dont initialze categoryTotal to zero until you find a null value so that it remains undefined for categories that have no non-null values (0 is rendered by filled map while null is not)
	                                if (categoryTotal == null && currentValue != null)
	                                    categoryTotal = 0;
	                                if (categoryTotal != null)
	                                    categoryTotal += currentValue;
	                            }
	                            categoryTotals.push(categoryTotal);
	                            if (categoryTotal != null) {
	                                if (categoryMin === undefined || categoryTotal < categoryMin)
	                                    categoryMin = categoryTotal;
	                                if (categoryMax === undefined || categoryTotal > categoryMax)
	                                    categoryMax = categoryTotal;
	                            }
	                        }
	                        categoryTotalRange = (categoryMin !== undefined && categoryMax !== undefined) ? {
	                            max: categoryMax,
	                            min: categoryMin,
	                        } : undefined;
	                    }
	                    var hasLatLongGroup = reader.hasCompositeCategories() && reader.hasCategoryWithRole('X') && reader.hasCategoryWithRole('Y');
	                    var hasCategoryGroup = reader.hasCategoryWithRole('Category');
	                    geocodingCategory = Map.getGeocodingCategory(dataView.categorical, geoTaggingAnalyzerService);
	                    if (hasLatLongGroup || hasCategoryGroup) {
	                        // Create data points
	                        for (var categoryIndex = 0, categoryCount = reader.getCategoryCount(); categoryIndex < categoryCount; categoryIndex++) {
	                            // Get category information
	                            var categoryValue = undefined;
	                            // The category objects should come from whichever category exists; in the case of a composite category, the objects should be the same for
	                            //   both categories, so we only need to obtain them from one role.
	                            var categoryObjects = hasCategoryGroup ? reader.getCategoryObjects('Category', categoryIndex) : reader.getCategoryObjects('Y', categoryIndex);
	                            var location_3 = void 0;
	                            var categoryTooltipItem = void 0;
	                            var latitudeTooltipItem = void 0;
	                            var longitudeTooltipItem = void 0;
	                            var seriesTooltipItem = void 0;
	                            var sizeTooltipItem = void 0;
	                            var gradientTooltipItem = void 0;
	                            if (hasCategoryGroup) {
	                                // Set category value
	                                categoryValue = visuals.converterHelper.formatFromMetadataColumn(reader.getCategoryValue('Category', categoryIndex), reader.getCategoryMetadataColumn('Category'), formatStringProp);
	                                categoryTooltipItem = {
	                                    displayName: reader.getCategoryDisplayName('Category'),
	                                    value: categoryValue,
	                                };
	                                // Create location from latitude and longitude if they exist as values
	                                if (reader.hasValues('Y') && reader.hasValues('X')) {
	                                    var latitude = reader.getFirstNonNullValueForCategory('Y', categoryIndex);
	                                    var longitude = reader.getFirstNonNullValueForCategory('X', categoryIndex);
	                                    if (latitude != null && longitude != null) {
	                                        location_3 = { latitude: latitude, longitude: longitude };
	                                    }
	                                    latitudeTooltipItem = {
	                                        displayName: reader.getValueDisplayName('Y'),
	                                        value: visuals.converterHelper.formatFromMetadataColumn(latitude, reader.getValueMetadataColumn('Y'), formatStringProp),
	                                    };
	                                    longitudeTooltipItem = {
	                                        displayName: reader.getValueDisplayName('X'),
	                                        value: visuals.converterHelper.formatFromMetadataColumn(longitude, reader.getValueMetadataColumn('X'), formatStringProp),
	                                    };
	                                }
	                            }
	                            else {
	                                var latitude = reader.getCategoryValue('Y', categoryIndex);
	                                var longitude = reader.getCategoryValue('X', categoryIndex);
	                                if (latitude != null && longitude != null) {
	                                    // Combine latitude and longitude to create the category value
	                                    categoryValue = latitude + ', ' + longitude;
	                                    // Create location from latitude and longitude
	                                    location_3 = { latitude: latitude, longitude: longitude };
	                                    latitudeTooltipItem = {
	                                        displayName: reader.getCategoryDisplayName('Y'),
	                                        value: visuals.converterHelper.formatFromMetadataColumn(latitude, reader.getCategoryMetadataColumn('Y'), formatStringProp),
	                                    };
	                                    longitudeTooltipItem = {
	                                        displayName: reader.getCategoryDisplayName('X'),
	                                        value: visuals.converterHelper.formatFromMetadataColumn(longitude, reader.getCategoryMetadataColumn('X'), formatStringProp),
	                                    };
	                                }
	                            }
	                            var value = hasSize ? categoryTotals[categoryIndex] : undefined;
	                            // Calculate sub data points by series
	                            var subDataPoints = [];
	                            var seriesCount = reader.getSeriesCount();
	                            if (!hasSize && !hasDynamicSeries) {
	                                seriesCount = 1;
	                            }
	                            for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
	                                var color = void 0;
	                                if (hasDynamicSeries) {
	                                    color = colorHelper.getColorForSeriesValue(reader.getSeriesObjects(seriesIndex), seriesColumnIdentifier, (reader.getSeriesName(seriesIndex)));
	                                }
	                                else if (reader.hasCategoryWithRole('Series')) {
	                                    color = colorHelper.getColorForSeriesValue(reader.getCategoryObjects('Series', categoryIndex), reader.getCategoryColumnIdentityFields('Series'), categoryValue);
	                                }
	                                else {
	                                    color = colorHelper.getColorForMeasure(categoryObjects, sizeQueryName);
	                                }
	                                var colorRgb = Color.parseColorString(color);
	                                var stroke = Color.hexString(Color.darken(colorRgb, Map.StrokeDarkenColorValue));
	                                colorRgb.A = 0.6;
	                                var fill = Color.rgbString(colorRgb);
	                                var identityBuilder = new visuals.SelectionIdBuilder()
	                                    .withCategory(reader.getCategoryColumn(hasCategoryGroup ? 'Category' : 'Y'), categoryIndex)
	                                    .withMeasure(sizeQueryName);
	                                if (hasDynamicSeries) {
	                                    identityBuilder = identityBuilder.withSeries(reader.getSeriesValueColumns(), reader.getSeriesValueColumnGroup(seriesIndex));
	                                }
	                                if (hasDynamicSeries) {
	                                    seriesTooltipItem = {
	                                        displayName: reader.getSeriesDisplayName(),
	                                        value: visuals.converterHelper.formatFromMetadataColumn(reader.getSeriesName(seriesIndex), reader.getSeriesMetadataColumn(), formatStringProp),
	                                    };
	                                }
	                                var subsliceValue = void 0;
	                                if (hasSize) {
	                                    subsliceValue = reader.getValue('Size', categoryIndex, seriesIndex);
	                                    sizeTooltipItem = {
	                                        displayName: reader.getValueDisplayName('Size'),
	                                        value: visuals.converterHelper.formatFromMetadataColumn(subsliceValue, reader.getValueMetadataColumn('Size', seriesIndex), formatStringProp),
	                                    };
	                                }
	                                if (reader.hasValues('Gradient')) {
	                                    gradientTooltipItem = {
	                                        displayName: reader.getValueDisplayName('Gradient'),
	                                        value: visuals.converterHelper.formatFromMetadataColumn(reader.getValue('Gradient', categoryIndex, seriesIndex), reader.getValueMetadataColumn('Gradient', seriesIndex), formatStringProp),
	                                    };
	                                }
	                                // Combine any existing tooltip items
	                                var tooltipInfo = [];
	                                if (categoryTooltipItem)
	                                    tooltipInfo.push(categoryTooltipItem);
	                                if (seriesTooltipItem)
	                                    tooltipInfo.push(seriesTooltipItem);
	                                if (latitudeTooltipItem)
	                                    tooltipInfo.push(latitudeTooltipItem);
	                                if (longitudeTooltipItem)
	                                    tooltipInfo.push(longitudeTooltipItem);
	                                if (sizeTooltipItem)
	                                    tooltipInfo.push(sizeTooltipItem);
	                                if (gradientTooltipItem)
	                                    tooltipInfo.push(gradientTooltipItem);
	                                if (tooltipBucketEnabled) {
	                                    visuals.TooltipBuilder.addTooltipBucketItem(reader, tooltipInfo, categoryIndex, seriesIndex);
	                                }
	                                // Do not create subslices for data points with null or zero if not filled map
	                                if (subsliceValue || !hasSize || (subsliceValue === 0 && isFilledMap)) {
	                                    subDataPoints.push({
	                                        value: subsliceValue,
	                                        fill: fill,
	                                        stroke: stroke,
	                                        identity: identityBuilder.createSelectionId(),
	                                        tooltipInfo: tooltipInfo,
	                                    });
	                                }
	                            }
	                            // Skip data points that have a null or zero if not filled map
	                            if (value || !hasSize || (value === 0 && isFilledMap)) {
	                                dataPoints.push({
	                                    geocodingQuery: categoryValue,
	                                    value: value,
	                                    categoryValue: categoryValue,
	                                    subDataPoints: subDataPoints,
	                                    radius: Map.calculateRadius(categoryTotalRange, value),
	                                    location: location_3,
	                                });
	                            }
	                        }
	                    }
	                }
	                var mapData = {
	                    dataPoints: dataPoints,
	                    geocodingCategory: geocodingCategory,
	                    hasDynamicSeries: hasDynamicSeries,
	                    hasSize: hasSize,
	                };
	                return mapData;
	            };
	            Map.createLegendData = function (dataView, colorHelper) {
	                var reader = powerbi.data.createIDataViewCategoricalReader(dataView);
	                var legendDataPoints = [];
	                var legendTitle;
	                if (reader.hasDynamicSeries()) {
	                    legendTitle = reader.getSeriesDisplayName();
	                    var seriesColumnIdentifier = reader.getSeriesColumnIdentityFields();
	                    for (var seriesIndex = 0, seriesCount = reader.getSeriesCount(); seriesIndex < seriesCount; seriesIndex++) {
	                        var color = colorHelper.getColorForSeriesValue(reader.getSeriesObjects(seriesIndex), seriesColumnIdentifier, reader.getSeriesName(seriesIndex));
	                        var identity = new visuals.SelectionIdBuilder().withSeries(reader.getSeriesValueColumns(), reader.getSeriesValueColumnGroup(seriesIndex)).createSelectionId();
	                        legendDataPoints.push({
	                            color: color,
	                            label: visuals.valueFormatter.format(reader.getSeriesName(seriesIndex)),
	                            icon: visuals.LegendIcon.Circle,
	                            identity: identity,
	                            selected: false,
	                        });
	                    }
	                }
	                var legendData = {
	                    dataPoints: legendDataPoints,
	                    title: legendTitle,
	                };
	                return legendData;
	            };
	            Map.prototype.swapLogoContainerChildElement = function () {
	                // This is a workaround that allow maps to be printed from the IE and Edge browsers.
	                // For some unknown reason, the presence of an <a> child element in the .LogoContainer
	                // prevents dashboard map visuals from showing up when printed.
	                // The trick is to swap out the <a> element with a <div> container.
	                // There are no user impacts or visual changes.
	                var logoContainer = this.element.find('.LogoContainer');
	                if (logoContainer) {
	                    var aNode = logoContainer.find('a');
	                    if (aNode == null)
	                        return;
	                    var divNode = $('<div>');
	                    aNode.children().clone().appendTo(divNode);
	                    aNode.remove();
	                    divNode.appendTo(logoContainer);
	                }
	            };
	            Map.prototype.onResizing = function (viewport) {
	                if (this.currentViewport.width !== viewport.width || this.currentViewport.height !== viewport.height) {
	                    this.currentViewport = viewport;
	                    this.renderLegend(this.legendData);
	                    this.updateInternal(false /* dataChanged */, false);
	                }
	            };
	            Map.prototype.initialize = function (container) {
	                var _this = this;
	                var mapOptions = {
	                    credentials: visuals.MapUtil.Settings.BingKey,
	                    showMapTypeSelector: false,
	                    enableClickableLogo: false,
	                    enableSearchLogo: false,
	                    mapTypeId: Microsoft.Maps.MapTypeId.road,
	                    customizeOverlays: true,
	                    showDashboard: false,
	                    showScalebar: false,
	                    disableKeyboardInput: true,
	                    disableZooming: this.disableZooming,
	                    disablePanning: this.disablePanning,
	                };
	                var divQuery = this.root = InJs.DomFactory.div().addClass(Map.MapContainer.cssClass).appendTo(container);
	                this.mapControl = this.mapControlFactory.createMapControl(divQuery[0], mapOptions);
	                if (this.viewChangeThrottleInterval !== undefined) {
	                    Microsoft.Maps.Events.addThrottledHandler(this.mapControl, 'viewchange', function () { _this.onViewChanged(); }, this.viewChangeThrottleInterval);
	                }
	                else {
	                    Microsoft.Maps.Events.addHandler(this.mapControl, 'viewchange', function () { _this.onViewChanged(); });
	                }
	                Microsoft.Maps.Events.addHandler(this.mapControl, "viewchangeend", function () { _this.onViewChangeEnded(); });
	                this.dataPointRenderer.init(this.mapControl, divQuery, !!this.behavior);
	                if (!this.pendingGeocodingRender) {
	                    this.updateInternal(true /* dataChanged */, true);
	                }
	            };
	            Map.prototype.onViewChanged = function () {
	                this.updateOffsets(false, false /* dataChanged */);
	                if (this.behavior)
	                    this.behavior.viewChanged();
	                this.swapLogoContainerChildElement();
	            };
	            Map.prototype.onViewChangeEnded = function () {
	                this.dataPointRenderer.updateInternalDataLabels(this.currentViewport, true);
	            };
	            Map.prototype.getMapViewPort = function () {
	                var currentViewport = this.currentViewport;
	                var legendMargins = this.legend.getMargins();
	                var mapViewport = {
	                    width: currentViewport.width - legendMargins.width,
	                    height: currentViewport.height - legendMargins.height,
	                };
	                return mapViewport;
	            };
	            Map.removeTransform3d = function (mapRoot) {
	                // don't remove transform3d from bing maps images in safari (using applewebkit engine)
	                var userAgent = window.navigator.userAgent.toLowerCase();
	                if (mapRoot && userAgent.indexOf('applewebkit') === -1) {
	                    var imageTiles = mapRoot.find('img');
	                    imageTiles.css('transform', '');
	                }
	            };
	            Map.prototype.updateInternal = function (dataChanged, redrawDataLabels) {
	                if (this.mapControl) {
	                    var isLegendVisible = this.legend.isVisible();
	                    if (!isLegendVisible)
	                        this.legendData = { dataPoints: [] };
	                    var mapDiv = this.element.children(Map.MapContainer.selector);
	                    var mapViewport = this.getMapViewPort();
	                    mapDiv.height(mapViewport.height);
	                    mapDiv.width(mapViewport.width);
	                    // With the risk of double drawing, if the position updates to nearly the same, the map control won't call viewchange, so explicitly update the points
	                    this.updateOffsets(dataChanged, redrawDataLabels);
	                    // Set zoom level after we rendered that map as we need the max size of the bubbles/ pie slices to calculate it
	                    if (this.boundsHaveBeenUpdated && !(this.behavior && this.behavior.hasReceivedZoomOrPanEvent())) {
	                        var levelOfDetail = this.getOptimumLevelOfDetail(mapViewport.width, mapViewport.height);
	                        var center = this.getViewCenter(levelOfDetail);
	                        this.updateMapView(center, levelOfDetail);
	                    }
	                }
	            };
	            Map.prototype.updateMapView = function (center, levelOfDetail) {
	                this.mapControl.setView({ center: center, zoom: levelOfDetail, animate: true });
	            };
	            Map.prototype.updateOffsets = function (dataChanged, redrawDataLabels) {
	                var dataView = this.dataView;
	                var data;
	                var viewport = this.getMapViewPort();
	                if (dataView && dataView.categorical) {
	                    // currentViewport may not exist in UnitTests
	                    data = this.dataPointRenderer.converter(viewport, this.dataView, this.dataLabelsSettings, this.interactivityService, this.tooltipsEnabled);
	                }
	                else {
	                    data = {
	                        bubbleData: [],
	                        shapeData: [],
	                        sliceData: [],
	                    };
	                }
	                var behaviorOptions = this.dataPointRenderer.updateInternal(data, viewport, dataChanged, this.interactivityService, redrawDataLabels);
	                visuals.Legend.positionChartArea(d3.select(this.root[0]), this.legend);
	                if (this.interactivityService && behaviorOptions) {
	                    this.interactivityService.bind(behaviorOptions.dataPoints, this.behavior, behaviorOptions);
	                }
	            };
	            Map.prototype.onClearSelection = function () {
	                this.interactivityService.clearSelection();
	                this.updateOffsets(false, false /* dataChanged */);
	            };
	            Map.prototype.clearDataPoints = function () {
	                this.dataPointRenderer.clearDataPoints();
	                this.legend.drawLegend({ dataPoints: [] }, this.currentViewport);
	            };
	            Map.prototype.getDefaultMapControlFactory = function () {
	                return {
	                    createMapControl: function (element, options) { return new Microsoft.Maps.Map(element, options); },
	                    ensureMap: jsCommon.ensureMap,
	                };
	            };
	            Map.removeHillShading = function () {
	                Microsoft.Maps.Globals.roadUriFormat = Microsoft.Maps.Globals.roadUriFormat.replace('&shading=hill', '');
	            };
	            Map.MapContainer = {
	                cssClass: 'mapControl',
	                selector: '.mapControl'
	            };
	            Map.StrokeDarkenColorValue = 255 * 0.25;
	            Map.ScheduleRedrawInterval = 3000;
	            return Map;
	        }());
	        visuals.Map = Map;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 267 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var getKpiImageMetadata = powerbi.visuals.KpiUtil.getKpiImageMetadata;
	        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
	        var PixelConverter = jsCommon.PixelConverter;
	        var UrlUtils = jsCommon.UrlUtils;
	        var EdgeSettings = powerbi.visuals.controls.internal.TablixUtils.EdgeSettings;
	        var TitleFontFamily = visuals.Font.Family.semibold.css;
	        var DefaultFontFamily = visuals.Font.Family.regular.css;
	        var DefaultCaptionFontSizeInPt = 10;
	        var DefaultTitleFontSizeInPt = 13;
	        var DefaultDetailFontSizeInPt = 9;
	        var DefaultTitleColor = '#767676';
	        var DefaultTextColor = '#333333';
	        var DefaultCategoryColor = '#ACACAC';
	        var DefaultOutline = visuals.outline.none;
	        var DefaultOutlineColor = '#E8E8E8';
	        var DefaultOutlineWeight = 1;
	        var DefaultBarShow = true;
	        var DefaultBarColor = '#A6A6A6';
	        var DefaultBarOutline = visuals.outline.leftOnly;
	        var DefaultBarWeight = 3;
	        var MultiRowCard = (function () {
	            function MultiRowCard() {
	                this.isInteractivityOverflowHidden = false;
	            }
	            MultiRowCard.prototype.init = function (options) {
	                debug.assertValue(options, 'options');
	                this.options = options;
	                this.style = options.style;
	                var viewport = this.currentViewport = options.viewport;
	                var interactivity = this.interactivity = options.interactivity;
	                if (interactivity && interactivity.overflow === 'hidden')
	                    this.isInteractivityOverflowHidden = true;
	                var multiRowCardDiv = this.element = $('<div/>')
	                    .addClass(MultiRowCard.MultiRowCardRoot.class)
	                    .css({
	                    'height': getPixelString(viewport.height),
	                });
	                options.element.append(multiRowCardDiv);
	                this.initializeCardRowSelection();
	            };
	            MultiRowCard.prototype.onDataChanged = function (options) {
	                debug.assertValue(options, 'options');
	                var dataViews = options.dataViews;
	                if (dataViews && dataViews.length > 0) {
	                    var dataView = this.dataView = dataViews[0];
	                    var columnMetadata = dataView.table.columns;
	                    var tableRows = dataView.table.rows;
	                    var resetScrollbarPosition = options.operationKind !== powerbi.VisualDataChangeOperationKind.Append;
	                    var data_1 = this.data = MultiRowCard.converter(dataView, columnMetadata.length, tableRows.length, this.isInteractivityOverflowHidden);
	                    this.setCardDimensions();
	                    this.listView.data(data_1.dataModel, function (d) { return data_1.dataModel.indexOf(d); }, resetScrollbarPosition);
	                }
	                else {
	                    this.data = {
	                        dataModel: [],
	                        dataColumnCount: 0,
	                        cardTitleSettings: visuals.dataLabelUtils.getDefaultLabelSettings(true, DefaultTitleColor, DefaultTitleFontSizeInPt),
	                        categoryLabelsSettings: visuals.dataLabelUtils.getDefaultLabelSettings(true, DefaultCategoryColor, DefaultDetailFontSizeInPt),
	                        dataLabelsSettings: visuals.dataLabelUtils.getDefaultLabelSettings(true, DefaultTextColor, DefaultCaptionFontSizeInPt),
	                        cardSettings: MultiRowCard.getCardSettings(null)
	                    };
	                }
	                this.waitingForData = false;
	            };
	            MultiRowCard.getCardSettings = function (dataView) {
	                var objects = dataView && dataView.metadata && dataView.metadata.objects ? dataView.metadata.objects : null;
	                var outlineSettings = {
	                    outline: powerbi.DataViewObjects.getValue(objects, visuals.multiRowCardProps.card.outline, DefaultOutline),
	                    color: powerbi.DataViewObjects.getFillColor(objects, visuals.multiRowCardProps.card.outlineColor, DefaultOutlineColor),
	                    weight: powerbi.DataViewObjects.getValue(objects, visuals.multiRowCardProps.card.outlineWeight, DefaultOutlineWeight),
	                };
	                var barShow = powerbi.DataViewObjects.getValue(objects, visuals.multiRowCardProps.card.barShow, DefaultBarShow);
	                var barSettings = {
	                    // If the bar is hidden, set the outline to none
	                    outline: barShow ? DefaultBarOutline : visuals.outline.none,
	                    color: powerbi.DataViewObjects.getFillColor(objects, visuals.multiRowCardProps.card.barColor, DefaultBarColor),
	                    weight: powerbi.DataViewObjects.getValue(objects, visuals.multiRowCardProps.card.barWeight, DefaultBarWeight),
	                };
	                var cardPadding = powerbi.DataViewObjects.getValue(objects, visuals.multiRowCardProps.card.cardPadding, MultiRowCard.DefaultStyle.row.marginBottom);
	                var cardBackground = powerbi.DataViewObjects.getFillColor(objects, visuals.multiRowCardProps.card.cardBackground, MultiRowCard.DefaultStyle.row.background);
	                return {
	                    outlineSettings: outlineSettings,
	                    barSettings: barSettings,
	                    cardPadding: cardPadding,
	                    cardBackground: cardBackground
	                };
	            };
	            MultiRowCard.prototype.onResizing = function (viewport) {
	                var heightNotChanged = (this.currentViewport.height === viewport.height);
	                this.currentViewport = viewport;
	                this.element.css('height', getPixelString(viewport.height));
	                if (!this.dataView)
	                    return;
	                var previousMaxColPerRow = this.maxColPerRow;
	                this.maxColPerRow = this.getMaxColPerRow();
	                var widthNotChanged = (previousMaxColPerRow === this.maxColPerRow);
	                if (heightNotChanged && widthNotChanged)
	                    return;
	                this.listView.viewport(viewport);
	            };
	            MultiRowCard.converter = function (dataView, columnCount, maxCards, isDashboardVisual) {
	                if (isDashboardVisual === void 0) { isDashboardVisual = false; }
	                var details = [];
	                var tableDataRows = dataView.table.rows;
	                var columnMetadata = dataView.table.columns;
	                var cardTitleSettings, dataLabelsSettings, categoryLabelsSettings;
	                cardTitleSettings = visuals.dataLabelUtils.getDefaultLabelSettings(true, DefaultTitleColor, DefaultTitleFontSizeInPt);
	                dataLabelsSettings = visuals.dataLabelUtils.getDefaultLabelSettings(true, DefaultTextColor, DefaultCaptionFontSizeInPt);
	                categoryLabelsSettings = visuals.dataLabelUtils.getDefaultLabelSettings(true, DefaultCategoryColor, DefaultDetailFontSizeInPt);
	                if (dataView.metadata && dataView.metadata.objects) {
	                    var cardTitleLabelObjects = powerbi.DataViewObjects.getObject(dataView.metadata.objects, 'cardTitle');
	                    visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(cardTitleLabelObjects, cardTitleSettings);
	                    var dataLabelObject = powerbi.DataViewObjects.getObject(dataView.metadata.objects, 'dataLabels');
	                    visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(dataLabelObject, dataLabelsSettings);
	                    var categoryLabelObject = powerbi.DataViewObjects.getObject(dataView.metadata.objects, 'categoryLabels');
	                    visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(categoryLabelObject, categoryLabelsSettings);
	                }
	                for (var i = 0, len = maxCards; i < len; i++) {
	                    var row = tableDataRows[i];
	                    var isValuePromoted = undefined;
	                    var title = undefined;
	                    var showTitleAsURL = false;
	                    var showTitleAsImage = false;
	                    var showTitleAsKPI = false;
	                    var cardData = [];
	                    for (var j = 0; j < columnCount; j++) {
	                        var column = columnMetadata[j];
	                        var statusGraphicInfo = getKpiImageMetadata(column, row[j]);
	                        var columnCaption = void 0;
	                        var statusGraphic = void 0;
	                        if (statusGraphicInfo) {
	                            columnCaption = statusGraphicInfo.class;
	                            statusGraphic = statusGraphicInfo.statusGraphic;
	                        }
	                        //TODO: seems we are duplicating this logic in many places. Consider putting it in KPIUtil
	                        if (!columnCaption)
	                            columnCaption = visuals.valueFormatter.format(row[j], visuals.valueFormatter.getFormatString(column, MultiRowCard.formatStringProp));
	                        var showKPI = statusGraphicInfo !== undefined && statusGraphicInfo.caption !== undefined;
	                        // The columnDetail represents column name. In card the column name is shown as details
	                        var columnDetail = columnMetadata[j].displayName;
	                        //Title is shown only on Canvas and only if there is one Category field.
	                        if (!isDashboardVisual && !column.type.numeric) {
	                            if (isValuePromoted === undefined) {
	                                isValuePromoted = true;
	                                title = columnCaption;
	                                showTitleAsURL = visuals.converterHelper.isWebUrlColumn(column) && UrlUtils.isValidUrl(title);
	                                showTitleAsImage = visuals.converterHelper.isImageUrlColumn(column) && UrlUtils.isValidImageUrl(columnCaption);
	                                showTitleAsKPI = showKPI;
	                            }
	                            else if (isValuePromoted) {
	                                isValuePromoted = false;
	                            }
	                        }
	                        cardData.push({
	                            caption: columnCaption,
	                            details: columnDetail,
	                            showURL: visuals.converterHelper.isWebUrlColumn(column) && UrlUtils.isValidUrl(columnCaption),
	                            showImage: visuals.converterHelper.isImageUrlColumn(column) && UrlUtils.isValidImageUrl(columnCaption),
	                            showKPI: showKPI,
	                            columnIndex: j
	                        });
	                    }
	                    details.push({
	                        title: isValuePromoted ? title : undefined,
	                        showTitleAsURL: showTitleAsURL,
	                        showTitleAsImage: showTitleAsImage,
	                        showTitleAsKPI: showTitleAsKPI,
	                        cardItemsData: isValuePromoted ? cardData.filter(function (d) { return d.caption !== title; }) : cardData
	                    });
	                }
	                return {
	                    dataModel: details,
	                    dataColumnCount: details[0] ? details[0].cardItemsData.length : 0,
	                    cardTitleSettings: cardTitleSettings,
	                    categoryLabelsSettings: categoryLabelsSettings,
	                    dataLabelsSettings: dataLabelsSettings,
	                    cardSettings: MultiRowCard.getCardSettings(dataView)
	                };
	            };
	            MultiRowCard.getSortableRoles = function (options) {
	                if (!options || !options.dataViewMappings || _.isEmpty(options.dataViewMappings)) {
	                    return;
	                }
	                for (var _i = 0, _a = options.dataViewMappings; _i < _a.length; _i++) {
	                    var dataViewMapping = _a[_i];
	                    if (dataViewMapping.table) {
	                        var rows = dataViewMapping.table.rows;
	                        if (rows && rows.for && rows.for.in && rows.for.in.items) {
	                            return [MultiRowCard.ValuesRole];
	                        }
	                    }
	                }
	                return;
	            };
	            MultiRowCard.prototype.initializeCardRowSelection = function () {
	                var _this = this;
	                var isDashboardVisual = this.isInteractivityOverflowHidden;
	                var rowEnter = function (rowSelection) {
	                    var cardRow = rowSelection
	                        .append("div")
	                        .classed(MultiRowCard.Card.class, true);
	                    // The card top padding is not needed when card items are wrapped as top padding is added to each carditemcontainer when wrapped
	                    if (isDashboardVisual) {
	                        cardRow.classed('mrtile', true);
	                    }
	                    else {
	                        if (_this.cardHasTitle) {
	                            cardRow.append("div").classed(MultiRowCard.Title.class, true)
	                                .each(function (d) {
	                                if (d.showTitleAsImage)
	                                    appendImage(d3.select(this));
	                                else if (d.showTitleAsURL)
	                                    d3.select(this).append('a');
	                                else if (d.showTitleAsKPI)
	                                    d3.select(this).append('div')
	                                        .classed(MultiRowCard.KPITitle.class, true)
	                                        .classed(d.title, true)
	                                        .style({
	                                        display: 'inline-block',
	                                        verticalAlign: 'sub'
	                                    });
	                            });
	                        }
	                    }
	                    var cardItem = cardRow
	                        .selectAll(MultiRowCard.CardItemContainer.selector)
	                        .data(function (d) { return d.cardItemsData; })
	                        .enter()
	                        .append('div')
	                        .classed(MultiRowCard.CardItemContainer.class, true);
	                    cardItem
	                        .append('div')
	                        .classed(MultiRowCard.Caption.class, true)
	                        .each(function (d) {
	                        if (d.showURL) {
	                            d3.select(this).append('a');
	                        }
	                        else if (d.showImage) {
	                            appendImage(d3.select(this));
	                        }
	                        else if (d.showKPI) {
	                            d3.select(this).append('div')
	                                .classed(d.caption, true)
	                                .style({
	                                display: 'inline-block',
	                                verticalAlign: 'sub'
	                            });
	                        }
	                    });
	                    cardItem
	                        .append('div')
	                        .classed(MultiRowCard.Details.class, true);
	                };
	                /**
	                * Row update should:
	                * 1. bind Data
	                * 2. Manipulate DOM (likely just updating CSS properties) affected by data
	                */
	                var rowUpdate = function (rowSelection) {
	                    var style = _this.getStyle();
	                    var dataLabelHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(MultiRowCard.getTextProperties(false, style.caption.fontSize));
	                    var categoryLabelHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(MultiRowCard.getTextProperties(false, style.details.fontSize));
	                    var titleLabelHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(MultiRowCard.getTextProperties(true, style.title.fontSize));
	                    var rowBorderStyle = _this.getBorderStyles(style.row.border, style.row.padding);
	                    rowSelection
	                        .style(rowBorderStyle)
	                        .style({
	                        'margin-bottom': isDashboardVisual ? '0px' : (_this.isSingleRowCard ? '0px' : getPixelString(style.row.marginBottom)),
	                        'background': style.row.background
	                    });
	                    if (!isDashboardVisual && _this.cardHasTitle) {
	                        rowSelection.selectAll(MultiRowCard.Title.selector)
	                            .filter(function (d) { return !d.showTitleAsImage && !d.showTitleAsKPI; })
	                            .style({
	                            'font-size': PixelConverter.fromPoint(style.title.fontSize),
	                            'line-height': PixelConverter.toString(titleLabelHeight),
	                            'color': style.title.color,
	                        });
	                        rowSelection.selectAll(MultiRowCard.Title.selector)
	                            .filter(function (d) { return !d.showTitleAsURL && !d.showTitleAsImage && !d.showTitleAsKPI; })
	                            .text(function (d) { return d.title; })
	                            .attr('title', function (d) { return d.title; });
	                        rowSelection
	                            .selectAll(MultiRowCard.TitleUrlSelector)
	                            .text(function (d) { return d.title; })
	                            .attr({
	                            'href': function (d) { return d.title; },
	                            'target': '_blank',
	                        });
	                        rowSelection
	                            .selectAll(MultiRowCard.TitleImageSelector)
	                            .attr('src', function (d) { return d.title; });
	                        setImageStyle(rowSelection.selectAll(MultiRowCard.Title.selector), style.imageTitle);
	                        rowSelection
	                            .selectAll(MultiRowCard.KPITitle.selector)
	                            .each(function (d) {
	                            var element = d3.select(this);
	                            element.classed(d.title);
	                        });
	                    }
	                    var cardSelection = rowSelection.selectAll(MultiRowCard.Card.selector);
	                    var cardBorderStyle = _this.getBorderStyles(style.card.border, style.card.padding);
	                    cardSelection.style(cardBorderStyle);
	                    cardSelection
	                        .selectAll(MultiRowCard.Caption.selector)
	                        .filter(function (d) { return !d.showImage; })
	                        .style({
	                        'line-height': PixelConverter.toString(dataLabelHeight),
	                        'font-size': PixelConverter.fromPoint(style.caption.fontSize),
	                    })
	                        .filter(function (d) { return !d.showKPI; })
	                        .style({
	                        'color': style.caption.color,
	                    })
	                        .filter(function (d) { return !d.showURL; })
	                        .text(function (d) { return d.caption; })
	                        .attr('title', function (d) { return d.caption; });
	                    cardSelection
	                        .selectAll(MultiRowCard.CaptionImageSelector)
	                        .attr('src', function (d) { return d.caption; })
	                        .style(style.imageCaption);
	                    var cardPaddingTop = getPixelString(style.cardItemContainer.padding.top);
	                    cardSelection
	                        .selectAll(MultiRowCard.CardItemContainer.selector)
	                        .style({
	                        'padding-top': function (d) {
	                            return _this.isInFirstRow(d.columnIndex) ? '' : cardPaddingTop;
	                        },
	                        'padding-right': function (d) {
	                            return _this.isLastRowItem(d.columnIndex, _this.dataView.metadata.columns.length) ? '0px' : getPixelString(style.cardItemContainer.paddingRight);
	                        },
	                        'width': function (d) {
	                            return _this.getColumnWidth(d.columnIndex, _this.data.dataColumnCount);
	                        }
	                    });
	                    setImageStyle(cardSelection.selectAll(MultiRowCard.Caption.selector), style.imageCaption);
	                    cardSelection
	                        .selectAll(MultiRowCard.CaptionUrlSelector)
	                        .attr({
	                        'href': function (d) { return d.caption; },
	                        'target': '_blank',
	                    })
	                        .text(function (d) { return d.caption; });
	                    if (style.details.isVisible) {
	                        cardSelection
	                            .selectAll(MultiRowCard.Details.selector)
	                            .text(function (d) { return d.details; })
	                            .style({
	                            'font-size': PixelConverter.fromPoint(style.details.fontSize),
	                            'line-height': PixelConverter.toString(categoryLabelHeight),
	                            'color': style.details.color
	                        })
	                            .attr('title', function (d) { return d.details; });
	                    }
	                };
	                var rowExit = function (rowSelection) {
	                    rowSelection.remove();
	                };
	                var listViewOptions = {
	                    rowHeight: undefined,
	                    enter: rowEnter,
	                    exit: rowExit,
	                    update: rowUpdate,
	                    loadMoreData: function () { return _this.onLoadMoreData(); },
	                    viewport: this.currentViewport,
	                    baseContainer: d3.select(this.element.get(0)),
	                    scrollEnabled: !this.isInteractivityOverflowHidden,
	                    isReadMode: function () {
	                        return (_this.options.host.getViewMode() !== 1 /* Edit */);
	                    }
	                };
	                this.listView = visuals.ListViewFactory.createListView(listViewOptions);
	            };
	            MultiRowCard.prototype.getBorderStyles = function (border, padding) {
	                var hasBorder = {
	                    top: border != null && border.top != null,
	                    right: border != null && border.right != null,
	                    bottom: border != null && border.bottom != null,
	                    left: border != null && border.left != null
	                };
	                var hasPadding = {
	                    top: padding != null && padding.top != null,
	                    right: padding != null && padding.right != null,
	                    bottom: padding != null && padding.bottom != null,
	                    left: padding != null && padding.left != null
	                };
	                return {
	                    'border-top': hasBorder.top ? border.top.getCSS() : '',
	                    'border-right': hasBorder.right ? border.right.getCSS() : '',
	                    'border-bottom': hasBorder.bottom ? border.bottom.getCSS() : '',
	                    'border-left': hasBorder.left ? border.left.getCSS() : '',
	                    'padding-top': hasBorder.top && hasPadding.top ? getPixelString(padding.top) : '',
	                    'padding-right': hasBorder.right && hasPadding.right ? getPixelString(padding.right) : '',
	                    'padding-bottom': hasBorder.bottom && hasPadding.bottom ? getPixelString(padding.bottom) : '',
	                    'padding-left': hasBorder.left && hasPadding.left ? getPixelString(padding.left) : '',
	                };
	            };
	            MultiRowCard.prototype.getMaxColPerRow = function () {
	                var rowWidth = this.currentViewport.width;
	                var minColumnWidth = this.getStyle().cardItemContainer.minWidth;
	                var columnCount = this.data.dataColumnCount;
	                //atleast one column fits in a row
	                var maxColumnPerRow = Math.floor(rowWidth / minColumnWidth) || 1;
	                return Math.min(columnCount, maxColumnPerRow);
	            };
	            MultiRowCard.prototype.getRowIndex = function (fieldIndex) {
	                return Math.floor((fieldIndex * 1.0) / this.getMaxColPerRow());
	            };
	            MultiRowCard.prototype.getStyle = function () {
	                var defaultStyles = MultiRowCard.DefaultStyle;
	                var customStyles = this.getCustomStyles();
	                if (!this.isInteractivityOverflowHidden)
	                    return $.extend(true, {}, defaultStyles, customStyles);
	                var viewportWidth = this.currentViewport.width;
	                var overrideStyle = {};
	                for (var _i = 0, _a = MultiRowCard.tileMediaQueries; _i < _a.length; _i++) {
	                    var currentQuery = _a[_i];
	                    if (viewportWidth <= currentQuery.maxWidth) {
	                        overrideStyle = currentQuery.style;
	                        break;
	                    }
	                }
	                return $.extend(true, {}, defaultStyles, customStyles, overrideStyle);
	            };
	            MultiRowCard.prototype.getSurroundSettings = function (outlineSettings) {
	                var edge = new EdgeSettings(outlineSettings.weight, outlineSettings.color);
	                var outlineProp = outlineSettings.outline;
	                return {
	                    top: visuals.outline.showTop(outlineProp) ? edge : null,
	                    right: visuals.outline.showRight(outlineProp) ? edge : null,
	                    bottom: visuals.outline.showBottom(outlineProp) ? edge : null,
	                    left: visuals.outline.showLeft(outlineProp) ? edge : null,
	                };
	            };
	            MultiRowCard.prototype.getCustomStyles = function () {
	                var dataLabelsSettings = this.data.dataLabelsSettings;
	                var categoryLabelSettings = this.data.categoryLabelsSettings;
	                var titleLabelSettings = this.data.cardTitleSettings;
	                var cardSettings = this.data.cardSettings;
	                var customStyle = {
	                    row: {
	                        border: this.getSurroundSettings(cardSettings.outlineSettings),
	                        marginBottom: cardSettings.cardPadding,
	                        background: cardSettings.cardBackground
	                    },
	                    card: {
	                        border: this.getSurroundSettings(cardSettings.barSettings)
	                    },
	                    details: {
	                        fontSize: categoryLabelSettings.fontSize,
	                        color: categoryLabelSettings.labelColor,
	                        isVisible: categoryLabelSettings.show,
	                    },
	                    caption: {
	                        fontSize: dataLabelsSettings.fontSize,
	                        color: dataLabelsSettings.labelColor,
	                    },
	                    title: {
	                        fontSize: titleLabelSettings.fontSize,
	                        color: titleLabelSettings.labelColor,
	                    }
	                };
	                return customStyle;
	            };
	            MultiRowCard.getTextProperties = function (isTitle, fontSizeInPt) {
	                return {
	                    fontFamily: isTitle ? TitleFontFamily : DefaultFontFamily,
	                    fontSize: PixelConverter.fromPoint(fontSizeInPt),
	                };
	            };
	            MultiRowCard.prototype.getColumnWidth = function (fieldIndex, columnCount) {
	                //atleast one column fits in a row
	                var maxColumnPerRow = this.getMaxColPerRow();
	                if (maxColumnPerRow >= columnCount)
	                    //all columns fit in the same row, divide the space equaly
	                    return (100.0 / columnCount) + '%';
	                //calculate the number of items apearing in the same row as the columnIndex
	                var rowIndex = this.getRowIndex(fieldIndex);
	                var totalRows = Math.ceil((columnCount * 1.0) / maxColumnPerRow);
	                var lastRowCount = columnCount % maxColumnPerRow;
	                if (rowIndex < totalRows || lastRowCount === 0)
	                    // items is not on the last row or last row contains max columns allowed per row
	                    return (100.0 / maxColumnPerRow) + '%';
	                // items is on the last row
	                return (100.0 / lastRowCount) + '%';
	            };
	            MultiRowCard.prototype.isLastRowItem = function (fieldIndex, columnCount) {
	                if (fieldIndex + 1 === columnCount)
	                    return true;
	                var maxColumnPerRow = this.getMaxColPerRow();
	                if (maxColumnPerRow - (fieldIndex % maxColumnPerRow) === 1)
	                    return true;
	                return false;
	            };
	            MultiRowCard.prototype.isInFirstRow = function (fieldIndex) {
	                return fieldIndex < this.getMaxColPerRow();
	            };
	            /**
	             * This contains the card column wrapping logic.
	             * Determines how many columns can be shown per each row inside a Card.
	             * To place the fields evenly along the card,
	             * the width of each card item is calculated based on the available viewport width.
	             */
	            MultiRowCard.prototype.setCardDimensions = function () {
	                this.cardHasTitle = false;
	                var dataModel = this.data.dataModel;
	                if (!this.isInteractivityOverflowHidden && dataModel && dataModel.length > 0) {
	                    this.cardHasTitle = dataModel[0].title !== undefined;
	                    this.isSingleRowCard = dataModel.length === 1 ? true : false;
	                }
	            };
	            MultiRowCard.prototype.onLoadMoreData = function () {
	                if (!this.waitingForData && this.dataView.metadata && this.dataView.metadata.segment) {
	                    this.options.host.loadMoreData();
	                    this.waitingForData = true;
	                }
	            };
	            MultiRowCard.getDataLabelSettingsOptions = function (enumeration, labelSettings, show) {
	                if (show === void 0) { show = false; }
	                return {
	                    enumeration: enumeration,
	                    dataLabelsSettings: labelSettings,
	                    show: show,
	                    fontSize: true,
	                };
	            };
	            MultiRowCard.prototype.enumerateObjectInstances = function (options) {
	                var enumeration = new visuals.ObjectEnumerationBuilder();
	                var cardTitleSettings = this.data.cardTitleSettings;
	                var dataLabelsSettings = this.data.dataLabelsSettings;
	                var categoryLabelsSettings = this.data.categoryLabelsSettings;
	                switch (options.objectName) {
	                    case 'cardTitle':
	                        //display title options only if title visible
	                        if (!this.isInteractivityOverflowHidden && this.cardHasTitle)
	                            visuals.dataLabelUtils.enumerateDataLabels(MultiRowCard.getDataLabelSettingsOptions(enumeration, cardTitleSettings));
	                        break;
	                    case 'dataLabels':
	                        visuals.dataLabelUtils.enumerateDataLabels(MultiRowCard.getDataLabelSettingsOptions(enumeration, dataLabelsSettings));
	                        break;
	                    case 'categoryLabels':
	                        visuals.dataLabelUtils.enumerateDataLabels(MultiRowCard.getDataLabelSettingsOptions(enumeration, categoryLabelsSettings, true));
	                        break;
	                    case visuals.multiRowCardProps.card.outline.objectName:
	                        this.enumerateCard(enumeration);
	                        break;
	                }
	                return enumeration.complete();
	            };
	            MultiRowCard.prototype.enumerateCard = function (enumeration) {
	                var cardSettings = this.data.cardSettings;
	                var propNames = visuals.multiRowCardProps.card;
	                var properties = {};
	                var outlineSettings = cardSettings.outlineSettings;
	                properties[propNames.outline.propertyName] = outlineSettings.outline;
	                if (outlineSettings.outline !== visuals.outline.none) {
	                    properties[propNames.outlineColor.propertyName] = outlineSettings.color;
	                    properties[propNames.outlineWeight.propertyName] = outlineSettings.weight;
	                }
	                var barSettings = cardSettings.barSettings;
	                // The bar is shown if the outline value is not none
	                var barShow = barSettings.outline !== visuals.outline.none;
	                properties[propNames.barShow.propertyName] = barShow;
	                if (barShow) {
	                    properties[propNames.barColor.propertyName] = barSettings.color;
	                    properties[propNames.barWeight.propertyName] = barSettings.weight;
	                }
	                properties[propNames.cardPadding.propertyName] = cardSettings.cardPadding;
	                properties[propNames.cardBackground.propertyName] = cardSettings.cardBackground;
	                enumeration.pushInstance({
	                    selector: null,
	                    objectName: propNames.outline.objectName,
	                    properties: properties
	                });
	            };
	            /**
	             * Note: Public for testability.
	             */
	            MultiRowCard.formatStringProp = {
	                objectName: 'general',
	                propertyName: 'formatString',
	            };
	            MultiRowCard.MultiRowCardRoot = createClassAndSelector('multiRowCard');
	            MultiRowCard.Card = createClassAndSelector('card');
	            MultiRowCard.Title = createClassAndSelector('title');
	            MultiRowCard.CardItemContainer = createClassAndSelector('cardItemContainer');
	            MultiRowCard.Caption = createClassAndSelector('caption');
	            MultiRowCard.Details = createClassAndSelector('details');
	            MultiRowCard.TitleUrlSelector = MultiRowCard.Title.selector + ' a';
	            MultiRowCard.CaptionUrlSelector = MultiRowCard.Caption.selector + ' a';
	            MultiRowCard.TitleImageSelector = MultiRowCard.Title.selector + ' img';
	            MultiRowCard.CaptionImageSelector = MultiRowCard.Caption.selector + ' img';
	            MultiRowCard.KPITitle = createClassAndSelector('kpiTitle');
	            MultiRowCard.ValuesRole = 'Values';
	            /**
	             * Cards have specific styling so defined inline styles and also to support theming and improve performance.
	             */
	            MultiRowCard.DefaultStyle = {
	                row: {
	                    border: null,
	                    marginBottom: 20,
	                    background: undefined,
	                    padding: {
	                        top: 5,
	                        right: 5,
	                        bottom: 5,
	                        left: 5
	                    }
	                },
	                card: {
	                    border: null,
	                    padding: {
	                        top: 10,
	                        right: 10,
	                        bottom: 10,
	                        left: 10
	                    }
	                },
	                cardItemContainer: {
	                    paddingRight: 20,
	                    minWidth: 120,
	                    padding: {
	                        top: 7
	                    }
	                },
	                imageCaption: {
	                    maxHeight: 75,
	                    maxWidth: 100,
	                },
	                imageTitle: {
	                    maxHeight: 75,
	                    maxWidth: 100,
	                }
	            };
	            // queries should be ordered by maxWidth in ascending order
	            MultiRowCard.tileMediaQueries = [
	                {
	                    maxWidth: 250,
	                    style: {
	                        cardItemContainer: {
	                            minWidth: 110,
	                        },
	                        imageCaption: {
	                            maxHeight: 45,
	                        }
	                    }
	                },
	                {
	                    maxWidth: 490,
	                    style: {
	                        cardItemContainer: {
	                            minWidth: 130,
	                        },
	                        imageCaption: {
	                            maxHeight: 52,
	                        }
	                    }
	                },
	                {
	                    maxWidth: 750,
	                    style: {
	                        cardItemContainer: {
	                            minWidth: 120,
	                        },
	                        imageCaption: {
	                            maxHeight: 53,
	                        }
	                    }
	                },
	                {
	                    maxWidth: Number.MAX_VALUE,
	                    style: {
	                        cardItemContainer: {
	                            padding: {
	                                top: 5
	                            }
	                        }
	                    }
	                }
	            ];
	            return MultiRowCard;
	        }());
	        visuals.MultiRowCard = MultiRowCard;
	        function appendImage(selection) {
	            selection
	                .append('div')
	                .classed('imgCon', true)
	                .append('img');
	        }
	        function setImageStyle(selection, imageStyle) {
	            selection
	                .selectAll('.imgCon')
	                .style({
	                'height': getPixelString(imageStyle.maxHeight),
	            })
	                .selectAll('img')
	                .style({
	                'max-height': getPixelString(imageStyle.maxHeight),
	                'max-width': getPixelString(imageStyle.maxWidth),
	            });
	        }
	        function getPixelString(value) {
	            return value + "px";
	        }
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 268 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
	        var KeyUtils = jsCommon.KeyUtils;
	        var StringExtensions = jsCommon.StringExtensions;
	        var UrlUtils = jsCommon.UrlUtils;
	        /** Represents a rich text box that supports view & edit mode. */
	        var Textbox = (function () {
	            function Textbox() {
	            }
	            Textbox.prototype.init = function (options) {
	                this.element = options.element;
	                this.host = options.host;
	                this.viewport = options.viewport;
	                this.readOnly = (this.host.getViewMode() === 0 /* View */);
	                this.paragraphs = [];
	                this.refreshView();
	            };
	            Textbox.prototype.onResizing = function (viewport) {
	                this.viewport = viewport;
	                this.updateSize();
	            };
	            Textbox.prototype.onDataChanged = function (options) {
	                debug.assertValue(options, 'options');
	                var dataViews = options.dataViews;
	                this.paragraphs = [];
	                if (dataViews && dataViews.length > 0) {
	                    var objects = dataViews[0].metadata.objects;
	                    if (objects && objects.general)
	                        this.paragraphs = objects.general.paragraphs;
	                }
	                this.refreshView();
	            };
	            Textbox.prototype.destroy = function () {
	            };
	            Textbox.prototype.focus = function () {
	                if (!this.editor)
	                    return;
	                this.editor.focus();
	                return true;
	            };
	            Textbox.prototype.onViewModeChanged = function (viewMode) {
	                this.readOnly = (viewMode === 0 /* View */);
	                this.refreshView();
	            };
	            Textbox.prototype.setSelection = function (start, end) {
	                debug.assertValue(this.editor, 'editor');
	                if (this.editor)
	                    this.editor.setSelection(start, end);
	            };
	            Textbox.prototype.refreshView = function () {
	                var _this = this;
	                if (this.readOnly) {
	                    // Showing just HTML, no editor.
	                    // If we are in view-mode and we have an editor, we can remove it (after saving).
	                    if (this.editor) {
	                        this.saveContents();
	                        this.editor.destroy();
	                        this.editor = null;
	                    }
	                    this.element.empty();
	                    var htmlContent = RichTextConversion.convertParagraphsToHtml(this.paragraphs);
	                    htmlContent.addClass(Textbox.ClassName);
	                    htmlContent.css({
	                        'font-family': RichText.defaultFont,
	                        'font-size': RichText.defaultFontSize,
	                    });
	                    this.element.append(htmlContent);
	                }
	                else {
	                    // Showing the Quill editor.
	                    // If we are in edit-mode and we don't have an editor we need to create it.
	                    if (!this.editor) {
	                        this.editor = new RichText.QuillWrapper(this.readOnly, this.host);
	                        this.editor.textChanged = function (delta, source) { return _this.saveContents(); };
	                        this.element.empty();
	                        var editorElement = this.editor.getElement();
	                        editorElement.addClass(Textbox.ClassName);
	                        editorElement.css({
	                            'font-family': RichText.defaultFont,
	                            'font-size': RichText.defaultFontSize,
	                        });
	                        this.element.append(editorElement);
	                    }
	                    this.editor.setContents(RichTextConversion.convertParagraphsToOps(this.paragraphs));
	                }
	                this.updateSize();
	            };
	            Textbox.prototype.saveContents = function () {
	                // It's possible to get here via a throttled text-changed event after a view-mode change has occured and
	                // we are now in view mode. Since we save changes on view-mode change it is safe to ignore this call.
	                if (!this.editor)
	                    return;
	                var contents = this.editor.getContents();
	                this.paragraphs = RichTextConversion.convertDeltaToParagraphs(contents);
	                var changes = [{
	                        objectName: 'general',
	                        properties: {
	                            paragraphs: this.paragraphs
	                        },
	                        selector: null,
	                    }];
	                this.host.persistProperties(changes);
	            };
	            Textbox.prototype.updateSize = function () {
	                if (this.editor)
	                    this.editor.resize(this.viewport);
	            };
	            Textbox.ClassName = 'textbox';
	            return Textbox;
	        }());
	        visuals.Textbox = Textbox;
	        var RichTextConversion;
	        (function (RichTextConversion) {
	            function convertDeltaToParagraphs(contents) {
	                var paragraphs = [];
	                var paragraph = { textRuns: [] };
	                for (var i = 0, len = contents.ops.length; i < len; i++) {
	                    var insertOp = contents.ops[i];
	                    debug.assertValue(insertOp, "operation should be an insert");
	                    if (typeof insertOp.insert === "string") {
	                        // string insert values represent text.
	                        var text = insertOp.insert;
	                        var attributes = insertOp.attributes;
	                        if (attributes && attributes.align) {
	                            // Sometimes horizontal alignment is set after the first "insert" of the paragraph, which is likely a bug
	                            // in Quill. In any case we should never see different horizontal alignments in a single paragraph.
	                            debug.assert(paragraph.horizontalTextAlignment === undefined || paragraph.horizontalTextAlignment === attributes.align, 'paragraph should not have more than one horizontal alignment');
	                            paragraph.horizontalTextAlignment = attributes.align;
	                        }
	                        // Quill gives us back text runs that may have \n's in them. We want to create a new paragraph for each \n we see.
	                        var start = 0;
	                        var end = 0;
	                        var newParagraph = void 0;
	                        do {
	                            end = text.indexOf('\n', start);
	                            if (end < 0) {
	                                newParagraph = false;
	                                end = text.length;
	                            }
	                            else {
	                                newParagraph = true;
	                            }
	                            if (end - start > 0) {
	                                var span = text.substring(start, end);
	                                var textRun = { value: span };
	                                if (attributes) {
	                                    if (attributes.link !== undefined && UrlUtils.isValidUrl(attributes.link))
	                                        textRun.url = attributes.link;
	                                    var textStyle = convertFormatAttributesToTextStyle(attributes);
	                                    if (textStyle)
	                                        textRun.textStyle = textStyle;
	                                }
	                                paragraph.textRuns.push(textRun);
	                            }
	                            // If we actually saw a '\n' then create a new paragraph
	                            if (newParagraph) {
	                                if (paragraph.textRuns.length === 0)
	                                    paragraph.textRuns.push({ value: '' });
	                                paragraphs.push(paragraph);
	                                paragraph = { textRuns: [] };
	                            }
	                            start = end + 1;
	                        } while (start < text.length);
	                    }
	                    else {
	                        // numeric insert values represent embeds.
	                        debug.assertFail("embeds not supported");
	                    }
	                }
	                if (paragraph.textRuns.length > 0) {
	                    // Quill appears to always insert an extra '\n' at the end of the text, skip it
	                    if (paragraph.textRuns[0].value.length > 0)
	                        paragraphs.push(paragraph);
	                }
	                return paragraphs;
	            }
	            RichTextConversion.convertDeltaToParagraphs = convertDeltaToParagraphs;
	            function convertParagraphsToHtml(paragraphs) {
	                var $paragraphs = $();
	                for (var paragraphIndex = 0, len = paragraphs.length; paragraphIndex < len; ++paragraphIndex) {
	                    var paragraphDef = paragraphs[paragraphIndex];
	                    var isParagraphEmpty = true;
	                    var $paragraph = $('<div>');
	                    if (paragraphDef.horizontalTextAlignment)
	                        $paragraph.css('text-align', paragraphDef.horizontalTextAlignment);
	                    for (var textRunIndex = 0, jlen = paragraphDef.textRuns.length; textRunIndex < jlen; ++textRunIndex) {
	                        var textRunDef = paragraphDef.textRuns[textRunIndex];
	                        var $textRun = $('<span>');
	                        var styleDef = textRunDef.textStyle;
	                        if (styleDef) {
	                            var css = {};
	                            if (styleDef.fontFamily) {
	                                css['font-family'] = RichText.getCssFontFamily(removeQuotes(styleDef.fontFamily));
	                            }
	                            if (styleDef.fontSize) {
	                                css['font-size'] = styleDef.fontSize;
	                            }
	                            if (styleDef.fontStyle) {
	                                css['font-style'] = styleDef.fontStyle;
	                            }
	                            if (styleDef.fontWeight) {
	                                css['font-weight'] = styleDef.fontWeight;
	                            }
	                            if (styleDef.textDecoration) {
	                                css['text-decoration'] = styleDef.textDecoration;
	                            }
	                            $textRun.css(css);
	                        }
	                        var text = textRunDef.value;
	                        if (!_.isEmpty(text))
	                            isParagraphEmpty = false;
	                        if (textRunDef.url !== undefined) {
	                            var $link = void 0;
	                            if (UrlUtils.isValidUrl(textRunDef.url)) {
	                                $link = $('<a>')
	                                    .attr('href', textRunDef.url)
	                                    .attr('target', '_blank')
	                                    .text(text);
	                            }
	                            else {
	                                $link = $('<span>').text(text);
	                            }
	                            $textRun.append($link);
	                        }
	                        else {
	                            $textRun.text(text);
	                        }
	                        $paragraph.append($textRun);
	                    }
	                    // If the entire paragraph is empty we need to make sure we enforce a line-break.
	                    if (isParagraphEmpty)
	                        $paragraph.append($('<br>'));
	                    $paragraphs = $paragraphs.add($paragraph);
	                }
	                return $paragraphs;
	            }
	            RichTextConversion.convertParagraphsToHtml = convertParagraphsToHtml;
	            function convertParagraphsToOps(paragraphs) {
	                var ops = [];
	                for (var paragraphIndex = 0, len = paragraphs.length; paragraphIndex < len; ++paragraphIndex) {
	                    var paragraphDef = paragraphs[paragraphIndex];
	                    for (var textRunIndex = 0, jlen = paragraphDef.textRuns.length; textRunIndex < jlen; ++textRunIndex) {
	                        var textRunDef = paragraphDef.textRuns[textRunIndex];
	                        var formats = {};
	                        if (paragraphDef.horizontalTextAlignment)
	                            formats.align = paragraphDef.horizontalTextAlignment;
	                        var styleDef = textRunDef.textStyle;
	                        if (styleDef) {
	                            if (styleDef.fontFamily) {
	                                formats.font = RichText.getCssFontFamily(removeQuotes(styleDef.fontFamily));
	                            }
	                            if (styleDef.fontSize) {
	                                formats.size = styleDef.fontSize;
	                            }
	                            formats.italic = (styleDef.fontStyle === 'italic');
	                            formats.bold = (styleDef.fontWeight === 'bold');
	                            formats.underline = (styleDef.textDecoration === 'underline');
	                        }
	                        var text = textRunDef.value;
	                        if (textRunDef.url && UrlUtils.isValidUrl(textRunDef.url))
	                            formats.link = textRunDef.url;
	                        var op = {
	                            insert: text,
	                            attributes: formats,
	                        };
	                        ops.push(op);
	                        // The last text run of the paragraph needs to end with '\n' to get Quill to handle the text alignment correctly.
	                        if (textRunIndex === (jlen - 1) && !StringExtensions.endsWith(text, '\n')) {
	                            ops.push({
	                                insert: '\n',
	                                attributes: formats,
	                            });
	                        }
	                    }
	                }
	                return ops;
	            }
	            RichTextConversion.convertParagraphsToOps = convertParagraphsToOps;
	            function convertFormatAttributesToTextStyle(attributes) {
	                var style = {};
	                // NOTE: Align is taken care of when converting to paragraphs.
	                if (attributes.bold) {
	                    style.fontWeight = 'bold';
	                }
	                if (attributes.font) {
	                    // We should always save font names without any quotes.
	                    var font = removeQuotes(attributes.font);
	                    // Convert built-in font families back into their proper font families (e.g. wf_segoe-ui_normal -> Segoe UI)
	                    font = RichText.getFontFamilyForBuiltInFont(font);
	                    style.fontFamily = font;
	                }
	                if (attributes.italic) {
	                    style.fontStyle = 'italic';
	                }
	                if (attributes.size) {
	                    style.fontSize = attributes.size;
	                }
	                if (attributes.underline) {
	                    style.textDecoration = 'underline';
	                }
	                /*
	                TODO:
	                if (attributes.background) {
	                }
	                if (attributes.color) {
	                }
	                */
	                return style;
	            }
	            function removeQuotes(text) {
	                // If it doesn't start with a quote or contains a comma (multiple fonts), don't remove quotes.
	                if (!StringExtensions.startsWith(text, "'") || StringExtensions.containsIgnoreCase(text, ","))
	                    return text;
	                debug.assert(StringExtensions.endsWith(text, "'"), "mismatched quotes");
	                return text.slice(1, text.length - 1);
	            }
	        })(RichTextConversion || (RichTextConversion = {}));
	        var RichText;
	        (function (RichText) {
	            /**
	             * These fonts are embedded using CSS, or are aliases to other fonts.
	             */
	            var fontMap = {
	                'Segoe (Bold)': visuals.Font.Family.bold.css,
	                'Segoe UI': visuals.Font.Family.regular.css,
	                'Segoe UI Light': visuals.Font.Family.light.css,
	                'Heading': visuals.Font.Family.light.css,
	                'Body': visuals.Font.Family.regular.css
	            };
	            var fonts = [
	                'Arial',
	                'Arial Black',
	                'Arial Unicode MS',
	                'Calibri',
	                'Cambria',
	                'Cambria Math',
	                'Candara',
	                'Comic Sans MS',
	                'Consolas',
	                'Constantia',
	                'Corbel',
	                'Courier New',
	                'Georgia',
	                'Lucida Sans Unicode',
	                'Segoe (Bold)',
	                'Segoe UI',
	                'Segoe UI Light',
	                'Symbol',
	                'Tahoma',
	                'Times New Roman',
	                'Trebuchet MS',
	                'Verdana',
	                'Wingdings',
	            ].map(function (font) { return { label: font, value: getCssFontFamily(font) }; });
	            RichText.defaultFont = getCssFontFamily('Segoe UI Light');
	            var fontSizes = [
	                '8', '9', '10', '10.5', '11', '12', '14', '16', '18', '20', '24', '28', '32', '36', '40', '42', '44', '54', '60', '66', '72', '80', '88', '96'
	            ].map(function (size) { return { label: size, value: size + 'px' }; });
	            RichText.defaultFontSize = '14px';
	            var textAlignments = [
	                'Left',
	                'Center',
	                'Right',
	            ].map(function (alignment) { return { label: alignment, value: alignment.toLowerCase() }; });
	            /**
	             * Given a font family returns the value we should use for the font-family css property.
	             */
	            function getCssFontFamily(font) {
	                var family = fontMap[font];
	                if (family == null)
	                    family = font;
	                return family;
	            }
	            RichText.getCssFontFamily = getCssFontFamily;
	            /**
	             * Convert built-in font families back into their proper font families (e.g. wf_segoe-ui_normal -> Segoe UI)
	             */
	            function getFontFamilyForBuiltInFont(font) {
	                var fontFamily = _.findKey(fontMap, function (value) { return value === font || value.indexOf(font) > 0; });
	                return fontFamily || font;
	            }
	            RichText.getFontFamilyForBuiltInFont = getFontFamilyForBuiltInFont;
	            var QuillWrapper = (function () {
	                /**
	                 * JavaScript and CSS resources are typically resolved asynchronously.
	                 * This means we potentially defer certain events which typically occur
	                 * synchronously until resources are loaded.
	                 * Setting the global loadQuillResources flag to true will override
	                 * this behavior and cause the wrapper to assume these resources are already loaded
	                 * and not try to load them asynchronously (e.g. for use in unit tests).
	                 */
	                function QuillWrapper(readOnly, host) {
	                    var _this = this;
	                    this.QuillPackage = {
	                        javaScriptFiles: QuillWrapper.quillJsFiles,
	                        cssFiles: QuillWrapper.quillCssFiles,
	                    };
	                    this.textChanged = function (d, s) { };
	                    this.host = host;
	                    this.$container = $('<div>');
	                    this.readOnly = readOnly;
	                    this.localizationProvider = {
	                        get: function (stringId) { return _this.host.getLocalizedString(stringId); },
	                        getOptional: function (stringId) { return _this.host.getLocalizedString(stringId); }
	                    };
	                    this.dependenciesLoaded = $.Deferred();
	                    if (QuillWrapper.loadQuillResources) {
	                        // Defer creation of the editor until after resources are loaded.
	                        this.initialized = false;
	                        // Note that these are called in the order registered so this will always be called before other callbacks.
	                        this.dependenciesLoaded.done(function () {
	                            _this.rebuildQuillEditor();
	                            _this.initialized = true;
	                        });
	                        jsCommon.requires(this.QuillPackage, function () { return _this.dependenciesLoaded.resolve(); });
	                    }
	                    else {
	                        this.rebuildQuillEditor();
	                        this.initialized = true;
	                        this.dependenciesLoaded.resolve();
	                    }
	                }
	                QuillWrapper.prototype.addModule = function (name, options) {
	                    if (this.editor)
	                        return this.editor.addModule(name, options);
	                };
	                QuillWrapper.prototype.getElement = function () {
	                    return this.$container;
	                };
	                QuillWrapper.prototype.getContents = function () {
	                    if (this.initialized)
	                        return this.editor.getContents();
	                };
	                QuillWrapper.prototype.setContents = function (contents) {
	                    var _this = this;
	                    // If we haven't loaded the editor yet, defer this call until we do
	                    // TODO: prevent these from stacking up?
	                    if (!this.initialized) {
	                        this.dependenciesLoaded.done(function () { return _this.setContents(contents); });
	                        return;
	                    }
	                    this.editor.setHTML('', 'api'); // Clear contents
	                    if (contents)
	                        this.editor.setContents(contents, 'api');
	                };
	                QuillWrapper.prototype.resize = function (viewport) {
	                    this.$container.width(viewport.width);
	                    this.$container.height(viewport.height);
	                };
	                QuillWrapper.prototype.setReadOnly = function (readOnly) {
	                    var readOnlyChanged = readOnly !== this.readOnly;
	                    this.readOnly = readOnly;
	                    if (this.initialized && readOnlyChanged) {
	                        this.rebuildQuillEditor();
	                    }
	                };
	                QuillWrapper.prototype.setSelection = function (start, end) {
	                    if (this.editor)
	                        this.editor.setSelection(start, end, 'api');
	                };
	                QuillWrapper.prototype.getSelection = function () {
	                    if (this.editor)
	                        return this.editor.getSelection();
	                };
	                QuillWrapper.prototype.focus = function () {
	                    if (!this.editor)
	                        return;
	                    if ($(document.activeElement).closest(this.$container).length === 0)
	                        this.editor.focus();
	                };
	                QuillWrapper.prototype.destroy = function () {
	                    this.host.setToolbar(null);
	                    this.$container.remove();
	                    this.$container = null;
	                    this.$toolbarDiv = null;
	                    this.$editorDiv = null;
	                    this.editor = null;
	                };
	                QuillWrapper.prototype.getSelectionAtCursor = function () {
	                    var text = this.getTextWithoutTrailingBreak();
	                    // Ensure editor has focus before selection interactions
	                    this.editor.focus();
	                    var selection = this.getSelection();
	                    if (selection && selection.start === selection.end) {
	                        return jsCommon.WordBreaker.find(selection.start, text);
	                    }
	                    return selection;
	                };
	                QuillWrapper.prototype.getWord = function () {
	                    var selection = this.getSelectionAtCursor();
	                    return this.getTextWithoutTrailingBreak().slice(selection.start, selection.end);
	                };
	                QuillWrapper.prototype.insertLinkAtCursor = function (link, index) {
	                    var endIndex = index + link.length;
	                    this.editor.insertText(index, link, 'api');
	                    this.editor.formatText(index, endIndex, 'link', link, 'api');
	                    this.setSelection(index, endIndex);
	                    this.onTextChanged(null, null);
	                    return endIndex;
	                };
	                QuillWrapper.prototype.getEditorContainer = function () {
	                    if (this.editor)
	                        return $(this.editor.container);
	                };
	                ;
	                QuillWrapper.prototype.getTextWithoutTrailingBreak = function () {
	                    return this.editor.getText().slice(0, -1);
	                };
	                QuillWrapper.prototype.rebuildQuillEditor = function () {
	                    var _this = this;
	                    // Preserve contents if we already have an editor.
	                    var contents = null;
	                    if (this.editor) {
	                        this.editor.removeAllListeners();
	                        contents = this.editor.getContents();
	                    }
	                    this.$container.empty();
	                    // Prevent parent elements from handling keyboard shortcuts (e.g. ctrl+a) that have special meaning for textboxes.
	                    // Quill will also capture and prevent bubbling of some keyboard shortcuts, such as ctrl+c, ctrl+b, etc.
	                    this.$container.keydown(function (e) {
	                        var which = e.which;
	                        if (e.ctrlKey && KeyUtils.isCtrlDefaultKey(which))
	                            e.stopPropagation();
	                        if (KeyUtils.isArrowKey(which) || KeyUtils.isNudgeModifierKey(which))
	                            e.stopPropagation();
	                    });
	                    var $editorDiv = this.$editorDiv = $('<div>');
	                    // HACK: Quill does not apply the correct default styling if you clear all the content and add new content.
	                    $editorDiv.css('font-family', RichText.defaultFont);
	                    $editorDiv.css('font-size', RichText.defaultFontSize);
	                    var configs = {
	                        readOnly: this.readOnly,
	                        formats: ['bold', 'italic', 'underline', 'font', 'size', 'link', 'align',],
	                        styles: false,
	                    };
	                    this.editor = new Quill($editorDiv.get(0), configs);
	                    // If not readonly we add a toolbar and disable drag/resize
	                    if (!this.readOnly) {
	                        var $toolbarDiv = this.$toolbarDiv;
	                        if (!$toolbarDiv) {
	                            this.$toolbarDiv = $toolbarDiv = Toolbar.buildToolbar(this, this.localizationProvider);
	                        }
	                        $toolbarDiv.addClass('unselectable');
	                        this.host.setToolbar($toolbarDiv);
	                        this.editor.addModule('toolbar', { container: $toolbarDiv.get(0) });
	                        // Disable this so we can select text in the editor.
	                        $editorDiv.attr('drag-resize-disabled', 'true');
	                    }
	                    this.$container.append($editorDiv);
	                    if (contents)
	                        this.setContents(contents);
	                    // Throttle text-changed events to not more frequent than once per 200ms
	                    var textChangeThrottler = new jsCommon.ThrottleUtility(QuillWrapper.textChangeThrottle);
	                    this.editor.on('text-change', function (delta, source) {
	                        if (source !== 'api')
	                            textChangeThrottler.run(function () { return _this.onTextChanged(delta, source); });
	                    });
	                    /*
	                        Webkit browsers have a bug with regard to focus on div elements
	                        with the contenteditable attribute:
	    
	                        https://bugs.webkit.org/show_bug.cgi?id=38696
	    
	                        When we blur our rich text box editor the focus remains with the selection
	                        instead of the focused element. This allows the user to continue typing as
	                        if focus remains within the RichTextbox.
	    
	                        To fix this issue we add an event listener to the contenteditable div
	                        which listens for the 'blur' event and will properly blur our quill
	                        editor as well.
	    
	                        http://quilljs.com/docs/api/#quillprototypesetselection
	    
	                        Verified in Chrome 43.0.2357.130 m
	    
	                        In IE10+ the setSelection method explicitly sets focus to the body which
	                        causes a bug where the user must click twice when attempting to interact
	                        with a <select> element. To prevent this issue we explicitly do not call
	                        setSelection to blur if the user is changing focus to a <select> element.
	                        This issue is also present for link tooltips from the Quill module which
	                        will cause a blur onto the tooltip.
	                    */
	                    this.editor.root.addEventListener('blur', function (event) {
	                        var target = (event.relatedTarget || document.activeElement);
	                        // The browser will handle moving the cursor and setting focus properly for these types of elements.
	                        if (target &&
	                            target.tagName === 'SELECT' || target.tagName === 'INPUT' || target.getAttribute('contentEditable')) {
	                            return;
	                        }
	                        _this.setSelection(null, null);
	                    }, false);
	                };
	                QuillWrapper.prototype.onTextChanged = function (delta, source) {
	                    this.textChanged(delta, source);
	                };
	                QuillWrapper.textChangeThrottle = 200; // ms
	                QuillWrapper.loadQuillResources = true;
	                // TODO: How to choose between minified/unminified?
	                // TODO: Consider loading this from the CDN.
	                QuillWrapper.quillJsFiles = [powerbi.build + '/externals/quill.min.js'];
	                QuillWrapper.quillCssFiles = [powerbi.build + '/externals/quill.base.css'];
	                return QuillWrapper;
	            }());
	            RichText.QuillWrapper = QuillWrapper;
	            var Toolbar;
	            (function (Toolbar) {
	                var DefaultLinkInputValue = 'http://';
	                Toolbar.selectors = {
	                    linkTooltip: createClassAndSelector('ql-link-tooltip'),
	                    toolbarUrlInput: createClassAndSelector('toolbar-url-input'),
	                };
	                function buildToolbar(quillWrapper, localizationProvider) {
	                    // Module for adding custom hyperlinks
	                    var linkTooltipTemplate = buildToolbarLinkInputTemplate(localizationProvider);
	                    quillWrapper.addModule('link-tooltip', { template: linkTooltipTemplate });
	                    var toolbarLinkInput = buildToolbarLinkInput(quillWrapper, getTooltip('Link', localizationProvider), localizationProvider.get('RichTextbox_Link_DefaultText'));
	                    var fontPicker = picker(getTooltip('Font', localizationProvider), fonts, 'font', RichText.defaultFont, 
	                    // Show the fonts in their own font face.
	                    function ($option, option) { $option.css('font-family', option.value); return $option; });
	                    var $container = div()
	                        .addClass('toolbar ql-toolbar')
	                        .append(formatGroup()
	                        .append(label(localizationProvider.get('RichTextbox_Font_Label')))
	                        .append(fontPicker)
	                        .append(picker(getTooltip('Size', localizationProvider), fontSizes, 'size', RichText.defaultFontSize)))
	                        .append(formatGroup()
	                        .append(formatButton(getTooltip('Bold', localizationProvider), 'bold'))
	                        .append(formatButton(getTooltip('Italic', localizationProvider), 'italic'))
	                        .append(formatButton(getTooltip('Underline', localizationProvider), 'underline')))
	                        .append(formatGroup()
	                        .append(toggleGroup('Text Alignment', textAlignments, 'align', 'Left', localizationProvider)))
	                        .append(toolbarLinkInput);
	                    // Prevent mousedown from triggering subsequent blur on editor
	                    $container.on('mousedown', function (event) {
	                        var target = (event.target || document.activeElement);
	                        if (target.tagName !== 'INPUT' && target.tagName !== 'SELECT')
	                            event.preventDefault();
	                    });
	                    return $container;
	                }
	                Toolbar.buildToolbar = buildToolbar;
	                function setSelectValue($select, value) {
	                    $select.val(value);
	                    // NOTE: The 'change' event is not raised when the value of the SELECT element is changed programatically,
	                    // and Quill uses it's own, non-JQuery, method to hook up to the 'change' event, therefore, we need to dispatch
	                    // this event manually on the SELECT element.
	                    var evt = document.createEvent('UIEvent');
	                    evt.initUIEvent('change', false, false, null, 0);
	                    $select.get(0).dispatchEvent(evt);
	                }
	                Toolbar.setSelectValue = setSelectValue;
	                function linkTooltipTemplateGenerator(removeText, doneText) {
	                    return $("\n                        <a href=\"#\" class=\"url\" target=\"_blank\"></a>\n                        <input class=\"input\" type=\"text\">\n                        <span class=\"bar\">&nbsp;|&nbsp;</span>\n                        <a class=\"change\"></a>\n                        <a class=\"remove\">" + removeText + "</a>\n                        <a class=\"done\">" + doneText + "</a>\n                    ");
	                }
	                ;
	                function buildToolbarLinkInputTemplate(localizationProvider) {
	                    var template = div();
	                    var doneText = localizationProvider.get('RichTextbox_Link_Done');
	                    var removeText = localizationProvider.get('RichTextbox_Link_Remove');
	                    template.append(linkTooltipTemplateGenerator(removeText, doneText));
	                    return template.html();
	                }
	                function formatGroup() {
	                    return span()
	                        .addClass('ql-format-group')
	                        .attr('drag-resize-disabled', 'true');
	                }
	                function label(text) {
	                    return $('<label>').text(text);
	                }
	                function div() {
	                    return $('<div>');
	                }
	                function span() {
	                    return $('<span>');
	                }
	                function toggleGroup(title, list, format, defaultValue, localizationProvider) {
	                    var tooltip = getTooltip(title, localizationProvider);
	                    var $group = span()
	                        .attr('title', tooltip)
	                        .addClass('ql-toggle-group');
	                    // Hidden selector that Quill will use to hook up change listeners.
	                    var $select = selector(tooltip, list, defaultValue)
	                        .addClass('ql-picker ql-' + format)
	                        .css('display', 'none');
	                    var $buttons = list.map(function (option) {
	                        var $button = formatButton(getTooltip(option.label, localizationProvider), 'align' + option.value)
	                            .attr('data-value', option.value)
	                            .click(function (e) { return setSelectValue($select, option.value); });
	                        return $button;
	                    });
	                    // Quill will change the value of the selector when the text selection changes, so we need to set the state of the buttons to match.
	                    $select.change(function (e) {
	                        var newValue = $select.val();
	                        for (var i = 0; i < $buttons.length; i++) {
	                            $buttons[i].toggleClass('ql-active', $buttons[i].attr('data-value') === newValue);
	                        }
	                    });
	                    $group.append($select);
	                    $group.append($buttons);
	                    return $group;
	                }
	                function picker(tooltip, list, format, defaultValue, optionModifier) {
	                    var $selector = selector(tooltip, list, defaultValue, optionModifier)
	                        .addClass('ql-picker ql-' + format);
	                    return $selector;
	                }
	                function selector(tooltip, list, defaultValue, optionModifier) {
	                    var $selector = $('<select>')
	                        .attr('title', tooltip);
	                    for (var i = 0; i < list.length; i++) {
	                        var option = list[i];
	                        var $option = $('<option>')
	                            .attr('value', option.value)
	                            .text(option.label);
	                        if (option.value === defaultValue)
	                            $option.attr('selected', 'selected');
	                        if (optionModifier !== undefined)
	                            $option = optionModifier($option, option);
	                        $selector.append($option);
	                    }
	                    return $selector;
	                }
	                function formatButton(tooltip, format) {
	                    var $button = span()
	                        .addClass('ql-format-button');
	                    if (tooltip != null)
	                        $button.attr('title', tooltip);
	                    if (format != null) {
	                        $button.addClass('ql-' + format);
	                        $button.addClass('powervisuals-glyph ' + format);
	                    }
	                    return $button;
	                }
	                function getTooltip(name, localizationProvider) {
	                    return localizationProvider.get('RichTextbox_' + name + '_ToolTip');
	                }
	                function clearLinkInput(linkTooltip) {
	                    linkTooltip.removeClass('editing');
	                    linkTooltip.removeClass('blank-editing');
	                    linkTooltip.find('.input').val(DefaultLinkInputValue);
	                }
	                function buildToolbarLinkInput(quillWrapper, buttonTooltip, defaultLinkText) {
	                    // Pull out link tooltip
	                    var linkTooltip = quillWrapper.getEditorContainer().find(Toolbar.selectors.linkTooltip.selector);
	                    // Append link tooltip to a new toolbar format group
	                    var toolbarLinkInput = formatGroup()
	                        .addClass(Toolbar.selectors.toolbarUrlInput.class)
	                        .append(formatButton(buttonTooltip, 'link').append('<div>'))
	                        .append(linkTooltip);
	                    // Special case for blank selection (no text near cursor) when enter key or done button clicked
	                    toolbarLinkInput.on('keydown mousedown', function (event) {
	                        if (event.keyCode === jsCommon.DOMConstants.enterKeyCode || event.target.classList.contains('done')) {
	                            if (!linkTooltip.hasClass('blank-editing'))
	                                return true;
	                            // Only perform these steps if tooltip was not in editing mode (special case for blank)
	                            var link = toolbarLinkInput.find('.input').val();
	                            var selection = quillWrapper.getSelectionAtCursor();
	                            var word = quillWrapper.getWord();
	                            if (!word) {
	                                // Insert the input text as a link
	                                var endCursor = quillWrapper.insertLinkAtCursor(link, selection.start);
	                                clearLinkInput(linkTooltip);
	                                quillWrapper.setSelection(endCursor, endCursor);
	                                return false;
	                            }
	                        }
	                    });
	                    toolbarLinkInput.find('.input').blur(function (event) {
	                        var blurTarget = event.relatedTarget;
	                        // Remove editing class from insert link tooltip (to hide via CSS)
	                        // only when we are not blurring to the 'done' button (tab from input field)
	                        if (blurTarget === null || blurTarget && !blurTarget.classList.contains('done'))
	                            clearLinkInput(linkTooltip);
	                    });
	                    toolbarLinkInput.find('.ql-link div')
	                        .click(function (event) {
	                        // Handle click on button before Quill removes link (default behavior)
	                        var target = event.target.parentElement;
	                        if (target && target.classList.contains('ql-active')) {
	                            toolbarLinkInput.find('.change')[0].click();
	                            return false;
	                        }
	                        // If blank selection (no text near cursor), special case for link button
	                        var word = quillWrapper.getWord();
	                        if (!word) {
	                            linkTooltip.addClass('editing blank-editing');
	                            var inputElem = toolbarLinkInput.find('.input').get(0);
	                            inputElem.value = DefaultLinkInputValue;
	                            inputElem.selectionStart = inputElem.selectionEnd = DefaultLinkInputValue.length;
	                            inputElem.focus();
	                            return false;
	                        }
	                    })
	                        .mousedown(function (event) {
	                        // Properly set selection before we handle the click
	                        var linkButton = event.target.parentElement;
	                        if (linkButton && !linkButton.classList.contains('ql-active')) {
	                            var selection = quillWrapper.getSelectionAtCursor();
	                            quillWrapper.setSelection(selection.start, selection.end);
	                        }
	                    });
	                    return toolbarLinkInput;
	                }
	            })(Toolbar || (Toolbar = {}));
	        })(RichText = visuals.RichText || (visuals.RichText = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 269 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	*  Power BI Visualizations
	*
	*  Copyright (c) Microsoft Corporation
	*  All rights reserved.
	*  MIT License
	*
	*  Permission is hereby granted, free of charge, to any person obtaining a copy
	*  of this software and associated documentation files (the ""Software""), to deal
	*  in the Software without restriction, including without limitation the rights
	*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	*  copies of the Software, and to permit persons to whom the Software is
	*  furnished to do so, subject to the following conditions:
	*
	*  The above copyright notice and this permission notice shall be included in
	*  all copies or substantial portions of the Software.
	*
	*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	*  THE SOFTWARE.
	*/
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var SelectionManager = visuals.utility.SelectionManager;
	        visuals.cheerMeterProps = {
	            dataPoint: {
	                defaultColor: {
	                    objectName: 'dataPoint',
	                    propertyName: 'defaultColor'
	                },
	                fill: {
	                    objectName: 'dataPoint',
	                    propertyName: 'fill'
	                },
	            },
	        };
	        var CheerMeter = (function () {
	            function CheerMeter() {
	                this.isFirstTime = true;
	            }
	            CheerMeter.converter = function (dataView) {
	                if (!dataView.categorical || !dataView.categorical.categories)
	                    return null;
	                var cat = dataView.categorical.categories[0];
	                if (!cat)
	                    return null;
	                var catValues = cat.values;
	                if (!catValues || _.isEmpty(dataView.categorical.values))
	                    return null;
	                var values = dataView.categorical.values[0].values;
	                var objects = dataView.categorical.categories[0].objects;
	                var object1 = objects && objects.length > 0 ? objects[0] : undefined;
	                var object2 = objects && objects.length > 1 ? objects[1] : undefined;
	                var metadataObjects = dataView.metadata.objects;
	                var backgroundColor = CheerMeter.DefaultBackgroundColor;
	                if (metadataObjects) {
	                    var general = metadataObjects['general'];
	                    if (general) {
	                        var fill = general['fill'];
	                        if (fill) {
	                            backgroundColor = fill.solid.color;
	                        }
	                    }
	                }
	                var color1 = powerbi.DataViewObjects.getFillColor(object1, visuals.cheerMeterProps.dataPoint.fill, CheerMeter.DefaultFontColor);
	                var color2 = powerbi.DataViewObjects.getFillColor(object2, visuals.cheerMeterProps.dataPoint.fill, CheerMeter.DefaultFontColor);
	                var idn1 = visuals.SelectionIdBuilder.builder()
	                    .withCategory(cat, 0)
	                    .createSelectionId();
	                var idn2 = visuals.SelectionIdBuilder.builder()
	                    .withCategory(cat, 1)
	                    .createSelectionId();
	                var data = {
	                    teamA: {
	                        name: catValues[0],
	                        value: values[0],
	                        color: color1,
	                        identity: idn1
	                    },
	                    teamB: {
	                        name: catValues[1],
	                        value: values[1],
	                        color: color2,
	                        identity: idn2
	                    },
	                    background: backgroundColor
	                };
	                return data;
	            };
	            CheerMeter.prototype.init = function (options) {
	                this.selectionManager = new SelectionManager({ hostServices: options.host });
	                var svg = this.svg = d3.select(options.element.get(0)).append('svg');
	                this.textOne = svg.append('text')
	                    .style('font-family', CheerMeter.DefaultFontFamily);
	                this.textTwo = svg.append('text')
	                    .style('font-family', CheerMeter.DefaultFontFamily);
	            };
	            CheerMeter.prototype.update = function (options) {
	                if (!options.dataViews[0]) {
	                    return;
	                }
	                var data = this.data = CheerMeter.converter(options.dataViews[0]);
	                if (!data)
	                    return;
	                var duration = options.suppressAnimations ? 0 : visuals.AnimatorCommon.MinervaAnimationDuration;
	                this.draw(data, duration, options.viewport);
	            };
	            CheerMeter.prototype.getRecomendedFontProperties = function (text1, text2, parentViewport) {
	                var textProperties = {
	                    fontSize: '',
	                    fontFamily: CheerMeter.DefaultFontFamily,
	                    text: text1 + text2
	                };
	                var min = 1;
	                var max = 1000;
	                var i;
	                var maxWidth = parentViewport.width;
	                var width = 0;
	                while (min <= max) {
	                    i = (min + max) / 2 | 0;
	                    textProperties.fontSize = i + 'px';
	                    width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
	                    if (maxWidth > width)
	                        min = i + 1;
	                    else if (maxWidth < width)
	                        max = i - 1;
	                    else
	                        break;
	                }
	                textProperties.fontSize = i + 'px';
	                width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
	                if (width > maxWidth) {
	                    i--;
	                    textProperties.fontSize = i + 'px';
	                }
	                return textProperties;
	            };
	            CheerMeter.prototype.calculateLayout = function (data, viewport) {
	                var text1 = data.teamA.name;
	                var text2 = data.teamB.name;
	                var avaliableViewport = {
	                    height: viewport.height,
	                    width: viewport.width - CheerMeter.PaddingBetweenText
	                };
	                var recomendedFontProperties = this.getRecomendedFontProperties(text1, text2, avaliableViewport);
	                recomendedFontProperties.text = text1;
	                var width1 = powerbi.TextMeasurementService.measureSvgTextWidth(recomendedFontProperties) | 0;
	                recomendedFontProperties.text = text2;
	                var width2 = powerbi.TextMeasurementService.measureSvgTextWidth(recomendedFontProperties) | 0;
	                var padding = ((viewport.width - width1 - width2 - CheerMeter.PaddingBetweenText) / 2) | 0;
	                recomendedFontProperties.text = text1 + text2;
	                var offsetHeight = (powerbi.TextMeasurementService.measureSvgTextHeight(recomendedFontProperties)) | 0;
	                var max = data.teamA.value + data.teamB.value;
	                var availableHeight = viewport.height - offsetHeight;
	                var y1 = (((max - data.teamA.value) / max) * availableHeight + offsetHeight / 2) | 0;
	                var y2 = (((max - data.teamB.value) / max) * availableHeight + offsetHeight / 2) | 0;
	                return {
	                    x1: padding,
	                    x2: padding + width1 + CheerMeter.PaddingBetweenText,
	                    y1: y1,
	                    y2: y2,
	                    fontSize: recomendedFontProperties.fontSize
	                };
	            };
	            CheerMeter.prototype.ensureStartState = function (layout, viewport) {
	                if (this.isFirstTime) {
	                    this.isFirstTime = false;
	                    var startY = viewport.height / 2;
	                    this.textOne.attr({
	                        'x': layout.x1,
	                        'y': startY
	                    });
	                    this.textTwo.attr({
	                        'x': layout.x2,
	                        'y': startY
	                    });
	                }
	            };
	            CheerMeter.prototype.clearSelection = function () {
	                var _this = this;
	                this.selectionManager.clear().then(function () {
	                    _this.clearSelectionUI();
	                });
	            };
	            CheerMeter.prototype.clearSelectionUI = function () {
	                this.textOne.style('stroke', '#FFF').style('stroke-width', 0);
	                this.textTwo.style('stroke', '#FFF').style('stroke-width', 0);
	            };
	            CheerMeter.prototype.updateSelectionUI = function (ids) {
	                this.textOne.style('stroke', '#FFF').style('stroke-width', SelectionManager.containsSelection(ids, this.data.teamA.identity) ? '2px' : '0px');
	                this.textTwo.style('stroke', '#FFF').style('stroke-width', SelectionManager.containsSelection(ids, this.data.teamB.identity) ? '2px' : '0px');
	            };
	            CheerMeter.prototype.draw = function (data, duration, viewport) {
	                var _this = this;
	                var easeName = 'back';
	                var textOne = this.textOne;
	                var textTwo = this.textTwo;
	                this.svg
	                    .attr({
	                    'height': viewport.height,
	                    'width': viewport.width
	                })
	                    .on('click', function () {
	                    _this.clearSelection();
	                })
	                    .style('background-color', data.background);
	                var layout = this.calculateLayout(data, viewport);
	                this.ensureStartState(layout, viewport);
	                textOne
	                    .style('font-size', layout.fontSize)
	                    .style('fill', data.teamA.color)
	                    .on('click', function () {
	                    _this.selectionManager.select(data.teamA.identity, d3.event.ctrlKey).then(function (ids) {
	                        _this.updateSelectionUI(ids);
	                    });
	                    d3.event.stopPropagation();
	                })
	                    .text(data.teamA.name);
	                textTwo
	                    .style('font-size', layout.fontSize)
	                    .style('fill', data.teamB.color)
	                    .on('click', function () {
	                    _this.selectionManager.select(data.teamB.identity, d3.event.ctrlKey).then(function (ids) {
	                        _this.updateSelectionUI(ids);
	                    });
	                    d3.event.stopPropagation();
	                })
	                    .text(data.teamB.name);
	                textOne.transition()
	                    .duration(duration)
	                    .ease(easeName)
	                    .attr({
	                    y: layout.y1,
	                    x: layout.x1
	                });
	                textTwo.transition()
	                    .duration(duration)
	                    .ease(easeName)
	                    .attr({
	                    y: layout.y2,
	                    x: layout.x2
	                });
	            };
	            CheerMeter.prototype.destroy = function () {
	                this.svg = null;
	                this.textOne = this.textTwo = null;
	            };
	            CheerMeter.prototype.enumerateObjectInstances = function (options) {
	                var instances = [];
	                var data = this.data;
	                switch (options.objectName) {
	                    case 'dataPoint':
	                        if (data) {
	                            var teams = [data.teamA, data.teamB];
	                            for (var i = 0; i < teams.length; i++) {
	                                var slice = teams[i];
	                                var color = slice.color;
	                                var selector = slice.identity;
	                                var dataPointInstance = {
	                                    objectName: 'dataPoint',
	                                    displayName: slice.name,
	                                    selector: selector,
	                                    properties: {
	                                        fill: { solid: { color: color } }
	                                    },
	                                };
	                                instances.push(dataPointInstance);
	                            }
	                            ;
	                        }
	                        break;
	                    case 'general':
	                        var general = {
	                            objectName: 'general',
	                            displayName: 'General',
	                            selector: null,
	                            properties: {
	                                fill: { solid: { color: data ? data.background : CheerMeter.DefaultBackgroundColor } }
	                            }
	                        };
	                        instances.push(general);
	                        break;
	                }
	                return instances;
	            };
	            CheerMeter.capabilities = {
	                dataRoles: [
	                    {
	                        displayName: 'Category',
	                        name: 'Category',
	                        kind: powerbi.VisualDataRoleKind.Grouping,
	                    },
	                    {
	                        displayName: 'Noise Measure',
	                        name: 'Y',
	                        kind: powerbi.VisualDataRoleKind.Measure,
	                    },
	                ],
	                dataViewMappings: [{
	                        categorical: {
	                            categories: {
	                                for: { in: 'Category' },
	                            },
	                            values: {
	                                select: [{ bind: { to: 'Y' } }]
	                            },
	                        },
	                    }],
	                objects: {
	                    dataPoint: {
	                        displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
	                        description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
	                        properties: {
	                            fill: {
	                                displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
	                                type: { fill: { solid: { color: true } } }
	                            },
	                            width: {
	                                displayName: '',
	                                type: { numeric: true }
	                            }
	                        }
	                    },
	                    general: {
	                        displayName: 'General',
	                        properties: {
	                            fill: {
	                                displayName: 'Background color',
	                                type: { fill: { solid: { color: true } } }
	                            },
	                        }
	                    }
	                }
	            };
	            CheerMeter.DefaultFontFamily = 'cursive';
	            CheerMeter.DefaultFontColor = 'rgb(165, 172, 175)';
	            CheerMeter.DefaultBackgroundColor = '#243C18';
	            CheerMeter.PaddingBetweenText = 15;
	            return CheerMeter;
	        }());
	        visuals.CheerMeter = CheerMeter;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 270 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var Color = jsCommon.Color;
	        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
	        var PixelConverter = jsCommon.PixelConverter;
	        var DataRoleHelper = powerbi.data.DataRoleHelper;
	        var ScatterChart = (function () {
	            function ScatterChart(options) {
	                if (options) {
	                    this.tooltipsEnabled = options.tooltipsEnabled;
	                    this.tooltipBucketEnabled = options.tooltipBucketEnabled;
	                    this.interactivityService = options.interactivityService;
	                    this.animator = options.animator;
	                }
	                this.renderer = new SvgRenderer();
	            }
	            ScatterChart.prototype.init = function (options) {
	                this.options = options;
	                this.element = options.element;
	                this.currentViewport = options.viewport;
	                this.style = options.style;
	                this.host = options.host;
	                this.colors = this.style.colorPalette.dataColors;
	                this.interactivity = options.interactivity;
	                this.cartesianVisualHost = options.cartesianHost;
	                this.isMobileChart = options.interactivity && options.interactivity.isInteractiveLegend;
	                var svg = this.svg = options.svg;
	                // TODO: should we always be adding the playchart class name?
	                svg.classed(ScatterChart.ClassName + ' ' + visuals.PlayChart.ClassName, true);
	                this.renderer.init(svg, options.labelsContext, this.isMobileChart, this.tooltipsEnabled);
	            };
	            ScatterChart.getAdditionalTelemetry = function (dataView) {
	                var telemetry = {
	                    hasSize: DataRoleHelper.hasRoleInDataView(dataView, 'Size'),
	                    hasPlayAxis: DataRoleHelper.hasRoleInDataView(dataView, 'Play'),
	                };
	                return telemetry;
	            };
	            ScatterChart.getObjectProperties = function (dataView, dataLabelsSettings) {
	                var objects;
	                if (dataView && dataView.metadata && dataView.metadata.objects)
	                    objects = dataView.metadata.objects;
	                else
	                    objects = {};
	                var objectProperties = {};
	                objectProperties.defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.columnChartProps.dataPoint.defaultColor);
	                objectProperties.showAllDataPoints = powerbi.DataViewObjects.getValue(objects, visuals.columnChartProps.dataPoint.showAllDataPoints, false);
	                var labelsObj = objects['categoryLabels'];
	                if (labelsObj && dataLabelsSettings)
	                    visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, dataLabelsSettings);
	                // NOTE: "fill point" defaults to on when we have a gradient role.
	                var hasGradient = dataView && visuals.GradientUtils.hasGradientRole(dataView.categorical);
	                objectProperties.fillPoint = powerbi.DataViewObjects.getValue(objects, visuals.scatterChartProps.fillPoint.show, hasGradient);
	                objectProperties.colorBorder = powerbi.DataViewObjects.getValue(objects, visuals.scatterChartProps.colorBorder.show, false);
	                objectProperties.colorByCategory = powerbi.DataViewObjects.getValue(objects, visuals.scatterChartProps.colorByCategory.show, false);
	                return objectProperties;
	            };
	            ScatterChart.converter = function (dataView, options, playFrameInfo, tooltipsEnabled, tooltipBucketEnabled) {
	                if (tooltipsEnabled === void 0) { tooltipsEnabled = true; }
	                var reader = powerbi.data.createIDataViewCategoricalReader(dataView);
	                var categoryValues, categoryFormatter, categoryObjects, categoryIdentities, categoryQueryName;
	                var currentViewport = options.viewport;
	                var colorPalette = options.colors;
	                var interactivityService = options.interactivityService;
	                var categoryAxisProperties = options.categoryAxisProperties;
	                var valueAxisProperties = options.valueAxisProperties;
	                var dataViewCategorical = dataView.categorical;
	                var gradientValueColumn = visuals.GradientUtils.getGradientValueColumn(dataViewCategorical);
	                if (dataViewCategorical.categories && dataViewCategorical.categories.length > 0) {
	                    categoryValues = dataViewCategorical.categories[0].values;
	                    categoryFormatter = visuals.valueFormatter.create({ format: visuals.valueFormatter.getFormatString(dataViewCategorical.categories[0].source, visuals.scatterChartProps.general.formatString), value: categoryValues[0], value2: categoryValues[categoryValues.length - 1] });
	                    categoryIdentities = dataViewCategorical.categories[0].identity;
	                    categoryObjects = dataViewCategorical.categories[0].objects;
	                    categoryQueryName = dataViewCategorical.categories[0].source.queryName;
	                }
	                else {
	                    categoryValues = [null];
	                    // creating default formatter for null value (to get the right string of empty value from the locale)
	                    categoryFormatter = visuals.valueFormatter.createDefaultFormatter(null);
	                }
	                var categories = dataViewCategorical.categories;
	                var dataValues = dataViewCategorical.values;
	                var hasDynamicSeries = !!dataValues.source;
	                var grouped = dataValues.grouped();
	                var dvSource = dataValues.source;
	                var scatterMetadata = ScatterChart.getMetadata(grouped, dvSource);
	                var dataLabelsSettings = visuals.dataLabelUtils.getDefaultPointLabelSettings();
	                var sizeRange = ScatterChart.getSizeRangeForGroups(grouped, scatterMetadata.idx.size);
	                var objProps = ScatterChart.getObjectProperties(dataView, dataLabelsSettings);
	                var dataPointSeries = ScatterChart.createDataPointSeries(reader, dataValues, scatterMetadata, categories, categoryValues, categoryFormatter, categoryIdentities, categoryObjects, colorPalette, currentViewport, hasDynamicSeries, dataLabelsSettings, gradientValueColumn, objProps.defaultDataPointColor, categoryQueryName, objProps.colorByCategory, playFrameInfo, tooltipsEnabled, tooltipBucketEnabled);
	                var dataPoints = _.reduce(dataPointSeries, function (a, s) { return a.concat(s.dataPoints); }, []);
	                var legendItems = hasDynamicSeries
	                    ? ScatterChart.createSeriesLegend(dataValues, colorPalette, dataValues, visuals.valueFormatter.getFormatString(dvSource, visuals.scatterChartProps.general.formatString), objProps.defaultDataPointColor)
	                    : [];
	                var legendTitle = dataValues && dvSource ? dvSource.displayName : "";
	                if (!legendTitle) {
	                    legendTitle = categories && categories.length > 0 && categories[0].source.displayName ? categories[0].source.displayName : "";
	                }
	                if (categoryAxisProperties && categoryAxisProperties["showAxisTitle"] !== null && categoryAxisProperties["showAxisTitle"] === false) {
	                    scatterMetadata.axesLabels.x = null;
	                }
	                if (valueAxisProperties && valueAxisProperties["showAxisTitle"] !== null && valueAxisProperties["showAxisTitle"] === false) {
	                    scatterMetadata.axesLabels.y = null;
	                }
	                if (interactivityService) {
	                    interactivityService.applySelectionStateToData(dataPoints);
	                    interactivityService.applySelectionStateToData(legendItems);
	                }
	                return {
	                    xCol: scatterMetadata.cols.x,
	                    yCol: scatterMetadata.cols.y,
	                    dataPoints: dataPoints,
	                    dataPointSeries: dataPointSeries,
	                    legendData: { title: legendTitle, dataPoints: legendItems, grouped: hasDynamicSeries },
	                    axesLabels: scatterMetadata.axesLabels,
	                    size: scatterMetadata.cols.size,
	                    sizeRange: sizeRange,
	                    dataLabelsSettings: dataLabelsSettings,
	                    defaultDataPointColor: objProps.defaultDataPointColor,
	                    hasDynamicSeries: hasDynamicSeries,
	                    showAllDataPoints: objProps.showAllDataPoints,
	                    fillPoint: objProps.fillPoint,
	                    colorBorder: objProps.colorBorder,
	                    colorByCategory: objProps.colorByCategory,
	                };
	            };
	            ScatterChart.getSizeRangeForGroups = function (dataViewValueGroups, sizeColumnIndex) {
	                var result = {};
	                if (dataViewValueGroups) {
	                    dataViewValueGroups.forEach(function (group) {
	                        var sizeColumn = ScatterChart.getMeasureValue(sizeColumnIndex, group.values);
	                        var currentRange = visuals.AxisHelper.getRangeForColumn(sizeColumn);
	                        if (result.min == null || result.min > currentRange.min) {
	                            result.min = currentRange.min;
	                        }
	                        if (result.max == null || result.max < currentRange.max) {
	                            result.max = currentRange.max;
	                        }
	                    });
	                }
	                return result;
	            };
	            ScatterChart.createDataPointSeries = function (reader, dataValues, metadata, categories, categoryValues, categoryFormatter, categoryIdentities, categoryObjects, colorPalette, viewport, hasDynamicSeries, labelSettings, gradientValueColumn, defaultDataPointColor, categoryQueryName, colorByCategory, playFrameInfo, tooltipsEnabled, tooltipBucketEnabled) {
	                var hasX = reader.hasValues("X");
	                var hasY = reader.hasValues("Y");
	                if (!hasX && !hasY) {
	                    return [];
	                }
	                var dataPointSeries = [], indicies = metadata.idx, formatStringProp = visuals.scatterChartProps.general.formatString, dataValueSource = dataValues.source, grouped = dataValues.grouped();
	                var colorHelper = new visuals.ColorHelper(colorPalette, visuals.scatterChartProps.dataPoint.fill, defaultDataPointColor);
	                for (var seriesIndex = 0, len = grouped.length; seriesIndex < len; seriesIndex++) {
	                    var grouping = grouped[seriesIndex];
	                    var seriesValues = grouping.values;
	                    var measureX = ScatterChart.getMeasureValue(indicies.x, seriesValues);
	                    var measureY = ScatterChart.getMeasureValue(indicies.y, seriesValues);
	                    var measureSize = ScatterChart.getMeasureValue(indicies.size, seriesValues);
	                    var seriesColor = void 0;
	                    if (hasDynamicSeries) {
	                        seriesColor = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name);
	                    }
	                    else if (!colorByCategory && !categoryObjects) {
	                        // If we have no Size measure then use a blank query name
	                        var measureSource = (measureSize != null)
	                            ? measureSize.source.queryName
	                            : '';
	                        seriesColor = colorHelper.getColorForMeasure(null, measureSource);
	                    }
	                    var series = {
	                        identityKey: (grouping && grouping.identity && grouping.identity.key) || "",
	                        dataPoints: [],
	                        hasSize: !!(measureSize && measureSize.values),
	                        fill: seriesColor,
	                    };
	                    dataPointSeries.push(series);
	                    for (var categoryIndex = 0, ilen = categoryValues.length; categoryIndex < ilen; categoryIndex++) {
	                        var categoryValue = categoryValues[categoryIndex];
	                        // Zero out X and Y if the role doesn't exist, so you still get a set of vertical/horizontal dots
	                        var xVal = hasX ? visuals.AxisHelper.normalizeNonFiniteNumber(reader.getValue("X", categoryIndex, seriesIndex)) : 0;
	                        var yVal = hasY ? visuals.AxisHelper.normalizeNonFiniteNumber(reader.getValue("Y", categoryIndex, seriesIndex)) : 0;
	                        // Undefined size is handled later if we don't have a size role, so this is fine to just be undefined
	                        var size = visuals.AxisHelper.normalizeNonFiniteNumber(reader.getValue("Size", categoryIndex, seriesIndex));
	                        // Do not render a dot if X or Y are null
	                        if (xVal == null || yVal == null)
	                            continue;
	                        var color = void 0;
	                        if (hasDynamicSeries) {
	                            color = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name);
	                        }
	                        else if (colorByCategory) {
	                            color = colorHelper.getColorForSeriesValue(categoryObjects && categoryObjects[categoryIndex], dataValues.identityFields, categoryValue);
	                        }
	                        else {
	                            // If we have no Size measure then use a blank query name
	                            var measureSource = (measureSize != null)
	                                ? measureSize.source.queryName
	                                : '';
	                            color = colorHelper.getColorForMeasure(categoryObjects && categoryObjects[categoryIndex], measureSource);
	                        }
	                        var category = !_.isEmpty(categories) ? categories[0] : null;
	                        var identity = visuals.SelectionIdBuilder.builder()
	                            .withCategory(category, categoryIndex)
	                            .withSeries(dataValues, grouping)
	                            .createSelectionId();
	                        var tooltipInfo = void 0;
	                        if (tooltipsEnabled) {
	                            tooltipInfo = [];
	                            if (category) {
	                                tooltipInfo.push({
	                                    displayName: category.source.displayName,
	                                    value: visuals.converterHelper.formatFromMetadataColumn(categoryValue, category.source, formatStringProp),
	                                });
	                            }
	                            if (hasDynamicSeries) {
	                                // Dynamic series
	                                if (!category || category.source !== dataValueSource) {
	                                    tooltipInfo.push({
	                                        displayName: dataValueSource.displayName,
	                                        value: visuals.converterHelper.formatFromMetadataColumn(grouping.name, dataValueSource, formatStringProp),
	                                    });
	                                }
	                            }
	                            if (measureX && xVal != null) {
	                                tooltipInfo.push({
	                                    displayName: measureX.source.displayName,
	                                    value: visuals.converterHelper.formatFromMetadataColumn(xVal, measureX.source, formatStringProp),
	                                });
	                            }
	                            if (measureY && yVal != null) {
	                                tooltipInfo.push({
	                                    displayName: measureY.source.displayName,
	                                    value: visuals.converterHelper.formatFromMetadataColumn(yVal, measureY.source, formatStringProp),
	                                });
	                            }
	                            if (measureSize && measureSize.values[categoryIndex] != null) {
	                                tooltipInfo.push({
	                                    displayName: measureSize.source.displayName,
	                                    value: visuals.converterHelper.formatFromMetadataColumn(measureSize.values[categoryIndex], measureSize.source, formatStringProp),
	                                });
	                            }
	                            if (gradientValueColumn && gradientValueColumn.values[categoryIndex] != null) {
	                                tooltipInfo.push({
	                                    displayName: gradientValueColumn.source.displayName,
	                                    value: visuals.converterHelper.formatFromMetadataColumn(gradientValueColumn.values[categoryIndex], gradientValueColumn.source, formatStringProp),
	                                });
	                            }
	                            if (playFrameInfo) {
	                                tooltipInfo.push({
	                                    displayName: playFrameInfo.column.displayName,
	                                    value: visuals.converterHelper.formatFromMetadataColumn(playFrameInfo.label, playFrameInfo.column, formatStringProp),
	                                });
	                            }
	                            if (tooltipBucketEnabled) {
	                                visuals.TooltipBuilder.addTooltipBucketItem(reader, tooltipInfo, categoryIndex, seriesIndex);
	                            }
	                        }
	                        var dataPoint = {
	                            x: xVal,
	                            y: yVal,
	                            size: size,
	                            radius: { sizeMeasure: measureSize, index: categoryIndex },
	                            fill: color,
	                            formattedCategory: ScatterChart.createLazyFormattedCategory(categoryFormatter, categories != null ? categoryValue : grouping.name),
	                            selected: false,
	                            identity: identity,
	                            tooltipInfo: tooltipInfo,
	                            labelFill: labelSettings.labelColor,
	                        };
	                        series.dataPoints.push(dataPoint);
	                    }
	                }
	                return dataPointSeries;
	            };
	            ScatterChart.createLazyFormattedCategory = function (formatter, value) {
	                return new jsCommon.Lazy(function () { return formatter.format(value); });
	            };
	            ScatterChart.createSeriesLegend = function (dataValues, colorPalette, categorical, formatString, defaultDataPointColor) {
	                var grouped = dataValues.grouped();
	                var colorHelper = new visuals.ColorHelper(colorPalette, visuals.scatterChartProps.dataPoint.fill, defaultDataPointColor);
	                var legendItems = [];
	                for (var i = 0, len = grouped.length; i < len; i++) {
	                    var grouping = grouped[i];
	                    var color = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name);
	                    var identity = visuals.SelectionIdBuilder.builder()
	                        .withSeries(categorical, grouped[i])
	                        .createSelectionId();
	                    legendItems.push({
	                        color: color,
	                        icon: visuals.LegendIcon.Circle,
	                        label: visuals.valueFormatter.format(grouping.name, formatString),
	                        identity: identity,
	                        selected: false
	                    });
	                }
	                return legendItems;
	            };
	            ScatterChart.getBubbleRadius = function (radiusData, sizeRange, viewport) {
	                var actualSizeDataRange = null;
	                var bubblePixelAreaSizeRange = null;
	                var measureSize = radiusData.sizeMeasure;
	                if (!measureSize)
	                    return ScatterChart.BubbleRadius;
	                var minSize = sizeRange.min ? sizeRange.min : 0;
	                var maxSize = sizeRange.max ? sizeRange.max : 0;
	                var min = Math.min(minSize, 0);
	                var max = Math.max(maxSize, 0);
	                actualSizeDataRange = {
	                    minRange: min,
	                    maxRange: max,
	                    delta: max - min
	                };
	                bubblePixelAreaSizeRange = ScatterChart.getBubblePixelAreaSizeRange(viewport, ScatterChart.MinSizeRange, ScatterChart.MaxSizeRange);
	                if (measureSize.values) {
	                    var sizeValue = measureSize.values[radiusData.index];
	                    if (sizeValue != null) {
	                        return ScatterChart.projectSizeToPixels(sizeValue, actualSizeDataRange, bubblePixelAreaSizeRange) / 2;
	                    }
	                }
	                return ScatterChart.BubbleRadius;
	            };
	            ScatterChart.getMeasureValue = function (measureIndex, seriesValues) {
	                if (measureIndex >= 0)
	                    return seriesValues[measureIndex];
	                return null;
	            };
	            ScatterChart.getMetadata = function (grouped, source) {
	                var xIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'X');
	                var yIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Y');
	                var sizeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Size');
	                var xCol;
	                var yCol;
	                var sizeCol;
	                var xAxisLabel = "";
	                var yAxisLabel = "";
	                if (grouped && grouped.length) {
	                    var firstGroup = grouped[0];
	                    if (xIndex >= 0) {
	                        xCol = firstGroup.values[xIndex].source;
	                        xAxisLabel = firstGroup.values[xIndex].source.displayName;
	                    }
	                    if (yIndex >= 0) {
	                        yCol = firstGroup.values[yIndex].source;
	                        yAxisLabel = firstGroup.values[yIndex].source.displayName;
	                    }
	                    if (sizeIndex >= 0) {
	                        sizeCol = firstGroup.values[sizeIndex].source;
	                    }
	                }
	                return {
	                    idx: {
	                        x: xIndex,
	                        y: yIndex,
	                        size: sizeIndex,
	                    },
	                    cols: {
	                        x: xCol,
	                        y: yCol,
	                        size: sizeCol,
	                    },
	                    axesLabels: {
	                        x: xAxisLabel,
	                        y: yAxisLabel
	                    }
	                };
	            };
	            /** Create a new viewmodel with default data. */
	            ScatterChart.getDefaultData = function () {
	                return {
	                    xCol: undefined,
	                    yCol: undefined,
	                    dataPoints: [],
	                    dataPointSeries: [],
	                    legendData: { dataPoints: [] },
	                    axesLabels: { x: '', y: '' },
	                    sizeRange: [],
	                    dataLabelsSettings: visuals.dataLabelUtils.getDefaultPointLabelSettings(),
	                    defaultDataPointColor: null,
	                    hasDynamicSeries: false,
	                };
	            };
	            ScatterChart.prototype.renderAtFrame = function (data) {
	                this.data = data;
	                this.cartesianVisualHost.triggerRender(false);
	            };
	            ScatterChart.prototype.setData = function (dataViews) {
	                var _this = this;
	                this.data = ScatterChart.getDefaultData();
	                if (this.playAxis && this.playAxis.isCurrentlyPlaying())
	                    this.playAxis.stop();
	                if (dataViews.length > 0) {
	                    var dataView = dataViews[0] || dataViews[1];
	                    if (dataView) {
	                        this.categoryAxisProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataView.metadata, true);
	                        this.valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataView.metadata, true);
	                        this.dataView = dataView;
	                        var converterOptions_1 = {
	                            viewport: this.currentViewport,
	                            colors: this.colors,
	                            interactivityService: this.interactivityService,
	                            categoryAxisProperties: this.categoryAxisProperties,
	                            valueAxisProperties: this.valueAxisProperties,
	                        };
	                        if (visuals.PlayChart.isDataViewPlayable(dataView)) {
	                            if (!this.playAxis) {
	                                this.playAxis = new visuals.PlayAxis({
	                                    animator: this.animator,
	                                    interactivityService: this.interactivityService,
	                                    isScrollable: false,
	                                });
	                                this.playAxis.init(this.options);
	                            }
	                            var playData = this.playAxis.setData(dataView, function (dataView, playFrameInfo) {
	                                return ScatterChart.converter(dataView, converterOptions_1, playFrameInfo, _this.tooltipsEnabled, _this.tooltipBucketEnabled);
	                            });
	                            this.mergeSizeRanges(playData);
	                            this.data = playData.currentViewModel;
	                            this.playAxis.setRenderFunction(function (data) { return _this.renderAtFrame(data); });
	                        }
	                        else {
	                            if (this.playAxis) {
	                                this.playAxis.remove();
	                                this.playAxis = null;
	                            }
	                            if (dataView.categorical && dataView.categorical.values) {
	                                this.data = ScatterChart.converter(dataView, converterOptions_1, undefined, this.tooltipsEnabled, this.tooltipBucketEnabled);
	                            }
	                        }
	                    }
	                }
	                else if (this.playAxis) {
	                    this.playAxis.remove();
	                    this.playAxis = null;
	                }
	            };
	            ScatterChart.prototype.mergeSizeRanges = function (playData) {
	                if (playData && playData.currentViewModel) {
	                    var mergedSizeRange = playData.currentViewModel.sizeRange;
	                    for (var _i = 0, _a = playData.allViewModels; _i < _a.length; _i++) {
	                        var data_1 = _a[_i];
	                        var sizeRange = data_1.sizeRange;
	                        if (sizeRange.min != null)
	                            mergedSizeRange.min = Math.min(mergedSizeRange.min, sizeRange.min);
	                        if (sizeRange.max != null)
	                            mergedSizeRange.max = Math.max(mergedSizeRange.max, sizeRange.max);
	                    }
	                    for (var _b = 0, _c = playData.allViewModels; _b < _c.length; _b++) {
	                        var data_2 = _c[_b];
	                        data_2.sizeRange = mergedSizeRange;
	                    }
	                }
	            };
	            ScatterChart.prototype.calculateLegend = function () {
	                return this.data && this.data.legendData;
	            };
	            ScatterChart.prototype.hasLegend = function () {
	                return this.data && this.data.hasDynamicSeries;
	            };
	            ScatterChart.prototype.enumerateObjectInstances = function (enumeration, options) {
	                switch (options.objectName) {
	                    case 'colorByCategory':
	                        if (this.data) {
	                            // Color by Legend takes precedent during render. Hide the slice but keep the colorByCategory value unchanged in case they remove the Legend field.
	                            if (!this.data.hasDynamicSeries) {
	                                enumeration.pushInstance({
	                                    objectName: 'colorByCategory',
	                                    selector: null,
	                                    properties: {
	                                        show: this.data.colorByCategory,
	                                    },
	                                });
	                            }
	                        }
	                        break;
	                    case 'dataPoint':
	                        // TODO: DataViewMatix (for PlayAxis) doesn't support category- or series-specific properties yet.
	                        if (!this.playAxis) {
	                            var categoricalDataView = this.dataView && this.dataView.categorical ? this.dataView.categorical : null;
	                            if (!visuals.GradientUtils.hasGradientRole(categoricalDataView))
	                                return this.enumerateDataPoints(enumeration);
	                        }
	                        break;
	                    case 'categoryAxis':
	                        enumeration.pushInstance({
	                            selector: null,
	                            properties: {
	                                showAxisTitle: !this.categoryAxisProperties || this.categoryAxisProperties["showAxisTitle"] == null ? true : this.categoryAxisProperties["showAxisTitle"]
	                            },
	                            objectName: 'categoryAxis'
	                        });
	                        break;
	                    case 'valueAxis':
	                        enumeration.pushInstance({
	                            selector: null,
	                            properties: {
	                                showAxisTitle: !this.valueAxisProperties || this.valueAxisProperties["showAxisTitle"] == null ? true : this.valueAxisProperties["showAxisTitle"]
	                            },
	                            objectName: 'valueAxis'
	                        });
	                        break;
	                    case 'categoryLabels':
	                        if (this.data)
	                            visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, this.data.dataLabelsSettings, true);
	                        else
	                            visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, null, true);
	                        break;
	                    case 'fillPoint':
	                        // Check if the card should be shown or not based on the existence of size measure
	                        if (this.hasSizeMeasure())
	                            return;
	                        enumeration.pushInstance({
	                            objectName: 'fillPoint',
	                            selector: null,
	                            properties: {
	                                show: this.data.fillPoint,
	                            },
	                        });
	                        break;
	                    case 'colorBorder':
	                        // Check if the card should be shown or not based on the existence of size measure
	                        if (this.hasSizeMeasure())
	                            enumeration.pushInstance({
	                                objectName: 'colorBorder',
	                                selector: null,
	                                properties: {
	                                    show: this.data.colorBorder,
	                                },
	                            });
	                        break;
	                }
	            };
	            ScatterChart.prototype.hasSizeMeasure = function () {
	                var sizeRange = this.data.sizeRange;
	                return sizeRange && sizeRange.min !== undefined;
	            };
	            ScatterChart.prototype.enumerateDataPoints = function (enumeration) {
	                var data = this.data;
	                if (!data)
	                    return;
	                var seriesCount = data.dataPoints.length;
	                if (!data.hasDynamicSeries) {
	                    enumeration.pushInstance({
	                        objectName: 'dataPoint',
	                        selector: null,
	                        properties: {
	                            defaultColor: { solid: { color: data.defaultDataPointColor || this.colors.getColorByIndex(0).value } }
	                        }
	                    }).pushInstance({
	                        objectName: 'dataPoint',
	                        selector: null,
	                        properties: {
	                            showAllDataPoints: !!data.showAllDataPoints
	                        }
	                    });
	                    for (var i = 0; i < seriesCount; i++) {
	                        var seriesDataPoints = data.dataPoints[i];
	                        enumeration.pushInstance({
	                            objectName: 'dataPoint',
	                            displayName: seriesDataPoints.formattedCategory.getValue(),
	                            selector: visuals.ColorHelper.normalizeSelector(seriesDataPoints.identity.getSelector(), /*isSingleSeries*/ true),
	                            properties: {
	                                fill: { solid: { color: seriesDataPoints.fill } }
	                            },
	                        });
	                    }
	                }
	                else {
	                    var legendDataPointLength = data.legendData.dataPoints.length;
	                    for (var i = 0; i < legendDataPointLength; i++) {
	                        var series = data.legendData.dataPoints[i];
	                        enumeration.pushInstance({
	                            objectName: 'dataPoint',
	                            displayName: series.label,
	                            selector: visuals.ColorHelper.normalizeSelector(series.identity.getSelector()),
	                            properties: {
	                                fill: { solid: { color: series.color } }
	                            },
	                        });
	                    }
	                }
	            };
	            ScatterChart.prototype.supportsTrendLine = function () {
	                var data = this.data;
	                if (!data)
	                    return false;
	                var dataView = this.dataView;
	                var reader = powerbi.data.createIDataViewCategoricalReader(dataView);
	                return !this.hasSizeMeasure() && data.dataPointSeries.length > 0 && reader.hasValues("X") && reader.hasValues("Y");
	            };
	            ScatterChart.getExtents = function (data) {
	                var dps = data.dataPoints;
	                if (_.isEmpty(dps)) {
	                    return {
	                        minY: 0,
	                        maxY: 0,
	                        minX: 0,
	                        maxX: 0,
	                    };
	                }
	                return {
	                    minY: d3.min(dps, function (d) { return d.y; }),
	                    maxY: d3.max(dps, function (d) { return d.y; }),
	                    minX: d3.min(dps, function (d) { return d.x; }),
	                    maxX: d3.max(dps, function (d) { return d.x; }),
	                };
	            };
	            ScatterChart.prototype.calculateAxesProperties = function (options) {
	                var data = this.data;
	                var viewport = this.currentViewport = options.viewport;
	                var margin = options.margin;
	                this.currentViewport = viewport;
	                this.margin = margin;
	                var width = viewport.width - (margin.left + margin.right);
	                var height = viewport.height - (margin.top + margin.bottom);
	                var extents = {
	                    minY: 0,
	                    maxY: 10,
	                    minX: 0,
	                    maxX: 10
	                };
	                if (this.playAxis) {
	                    extents = this.playAxis.getCartesianExtents(extents, ScatterChart.getExtents);
	                    this.playAxis.setPlayControlPosition(options.playAxisControlLayout);
	                }
	                else if (!_.isEmpty(data.dataPoints)) {
	                    extents = ScatterChart.getExtents(data);
	                }
	                var xDomain = [extents.minX, extents.maxX];
	                var combinedXDomain = visuals.AxisHelper.combineDomain(options.forcedXDomain, xDomain, options.ensureXDomain);
	                this.xAxisProperties = visuals.AxisHelper.createAxis({
	                    pixelSpan: width,
	                    dataDomain: combinedXDomain,
	                    metaDataColumn: data.xCol,
	                    formatString: visuals.valueFormatter.getFormatString(data.xCol, visuals.scatterChartProps.general.formatString),
	                    outerPadding: 0,
	                    isScalar: true,
	                    isVertical: false,
	                    forcedTickCount: options.forcedTickCount,
	                    useTickIntervalForDisplayUnits: true,
	                    isCategoryAxis: true,
	                    scaleType: options.categoryAxisScaleType,
	                    axisDisplayUnits: options.categoryAxisDisplayUnits,
	                    axisPrecision: options.categoryAxisPrecision
	                });
	                this.xAxisProperties.axis.tickSize(-height, 0);
	                this.xAxisProperties.axisLabel = this.data.axesLabels.x;
	                var combinedDomain = visuals.AxisHelper.combineDomain(options.forcedYDomain, [extents.minY, extents.maxY], options.ensureYDomain);
	                this.yAxisProperties = visuals.AxisHelper.createAxis({
	                    pixelSpan: height,
	                    dataDomain: combinedDomain,
	                    metaDataColumn: data.yCol,
	                    formatString: visuals.valueFormatter.getFormatString(data.yCol, visuals.scatterChartProps.general.formatString),
	                    outerPadding: 0,
	                    isScalar: true,
	                    isVertical: true,
	                    forcedTickCount: options.forcedTickCount,
	                    useTickIntervalForDisplayUnits: true,
	                    isCategoryAxis: false,
	                    scaleType: options.valueAxisScaleType,
	                    axisDisplayUnits: options.valueAxisDisplayUnits,
	                    axisPrecision: options.valueAxisPrecision
	                });
	                this.yAxisProperties.axisLabel = this.data.axesLabels.y;
	                // TODO: these should be passed into the render method.
	                return [this.xAxisProperties, this.yAxisProperties];
	            };
	            ScatterChart.prototype.overrideXScale = function (xProperties) {
	                this.xAxisProperties = xProperties;
	            };
	            ScatterChart.prototype.shouldSuppressAnimation = function () {
	                return this.data && this.data.dataPoints && this.data.dataPoints.length > ScatterChart.NoAnimationThreshold;
	            };
	            ScatterChart.prototype.render = function (suppressAnimations, resizeMode) {
	                if (!this.data)
	                    return;
	                var data = this.data;
	                var margin = this.margin;
	                var viewport = this.currentViewport;
	                var hasSelection = this.interactivityService && this.interactivityService.hasSelection();
	                var plotArea = {
	                    width: viewport.width - (margin.left + margin.right),
	                    height: viewport.height - (margin.top + margin.bottom)
	                };
	                var duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
	                if (this.playAxis && this.playAxis.isCurrentlyPlaying() && (this.isMobileChart || duration > 0)) {
	                    duration = visuals.PlayChart.FrameAnimationDuration;
	                }
	                var easeType = this.playAxis ? 'linear' : 'cubic-in-out'; // cubic-in-out is the d3.ease default
	                var fillMarkers = (!data.sizeRange || !data.sizeRange.min) && data.fillPoint;
	                var drawBubbles = this.hasSizeMeasure();
	                var suppressDataPointRendering = resizeMode === 1 /* Resizing */ && data.dataPoints && data.dataPoints.length > ScatterChart.NoRenderResizeThreshold;
	                var viewModel = {
	                    data: data,
	                    drawBubbles: drawBubbles,
	                    isPlay: !!this.playAxis,
	                    xAxisProperties: this.xAxisProperties,
	                    yAxisProperties: this.yAxisProperties,
	                    viewport: plotArea,
	                    hasSelection: hasSelection,
	                    animationDuration: duration,
	                    animationOptions: this.options.animation,
	                    fillMarkers: fillMarkers,
	                    easeType: easeType,
	                    suppressDataPointRendering: suppressDataPointRendering,
	                };
	                if (drawBubbles) {
	                    // Bubbles must be drawn from largest to smallest.
	                    var sortedData = data.dataPoints.sort(ScatterChart.sortBubbles);
	                    viewModel.data = powerbi.Prototype.inherit(viewModel.data);
	                    viewModel.data.dataPoints = sortedData;
	                }
	                var labelDataPoints = [];
	                if (data.dataLabelsSettings && data.dataLabelsSettings.show || data.dataLabelsSettings.showCategory) {
	                    labelDataPoints = ScatterChartDataLabels.createLabelDataPoints(viewModel);
	                }
	                var behaviorOptions = this.renderer.render(viewModel, this.interactivityService);
	                if (this.isMobileChart) {
	                    behaviorOptions = {
	                        data: behaviorOptions.data,
	                        dataPointsSelection: behaviorOptions.dataPointsSelection,
	                        eventGroup: behaviorOptions.eventGroup,
	                        plotContext: behaviorOptions.plotContext,
	                        host: this.cartesianVisualHost,
	                        root: this.svg,
	                        visualInitOptions: this.options,
	                        xAxisProperties: this.xAxisProperties,
	                        yAxisProperties: this.yAxisProperties,
	                        background: d3.select(this.element.get(0)),
	                    };
	                }
	                var playRenderResult;
	                if (this.playAxis) {
	                    playRenderResult = this.playAxis.render(suppressAnimations, viewModel, viewport, margin);
	                    if (this.interactivityService) {
	                        var playBehaviorOptions = {
	                            traceLineRenderer: this.renderer.createTraceLineRenderer(playRenderResult.viewModel),
	                        };
	                        if (hasSelection) {
	                            visuals.PlayChart.renderTraceLines(playRenderResult.allDataPoints, playBehaviorOptions.traceLineRenderer, !suppressAnimations);
	                        }
	                        behaviorOptions.playOptions = playBehaviorOptions;
	                    }
	                }
	                return {
	                    dataPoints: playRenderResult ? playRenderResult.allDataPoints : data.dataPoints,
	                    behaviorOptions: behaviorOptions,
	                    labelDataPoints: labelDataPoints,
	                    labelsAreNumeric: false,
	                };
	            };
	            ScatterChart.getStrokeFill = function (d, colorBorder) {
	                if (d.size != null && colorBorder) {
	                    var colorRgb = Color.parseColorString(d.fill);
	                    return Color.hexString(Color.darken(colorRgb, ScatterChart.StrokeDarkenColorValue));
	                }
	                return d.fill;
	            };
	            ScatterChart.getBubblePixelAreaSizeRange = function (viewPort, minSizeRange, maxSizeRange) {
	                var ratio = 1.0;
	                if (viewPort.height > 0 && viewPort.width > 0) {
	                    var minSize = Math.min(viewPort.height, viewPort.width);
	                    ratio = (minSize * minSize) / ScatterChart.AreaOf300By300Chart;
	                }
	                var minRange = Math.round(minSizeRange * ratio);
	                var maxRange = Math.round(maxSizeRange * ratio);
	                return {
	                    minRange: minRange,
	                    maxRange: maxRange,
	                    delta: maxRange - minRange
	                };
	            };
	            ScatterChart.project = function (value, actualSizeDataRange, bubblePixelAreaSizeRange) {
	                if (actualSizeDataRange.delta === 0 || bubblePixelAreaSizeRange.delta === 0) {
	                    return (ScatterChart.rangeContains(actualSizeDataRange, value)) ? bubblePixelAreaSizeRange.minRange : null;
	                }
	                var relativeX = (value - actualSizeDataRange.minRange) / actualSizeDataRange.delta;
	                return bubblePixelAreaSizeRange.minRange + relativeX * bubblePixelAreaSizeRange.delta;
	            };
	            ScatterChart.projectSizeToPixels = function (size, actualSizeDataRange, bubblePixelAreaSizeRange) {
	                var projectedSize = 0;
	                if (actualSizeDataRange) {
	                    // Project value on the required range of bubble area sizes
	                    projectedSize = bubblePixelAreaSizeRange.maxRange;
	                    if (actualSizeDataRange.delta !== 0) {
	                        var value = Math.min(Math.max(size, actualSizeDataRange.minRange), actualSizeDataRange.maxRange);
	                        projectedSize = ScatterChart.project(value, actualSizeDataRange, bubblePixelAreaSizeRange);
	                    }
	                    projectedSize = Math.sqrt(projectedSize / Math.PI) * 2;
	                }
	                return Math.round(projectedSize);
	            };
	            ScatterChart.rangeContains = function (range, value) {
	                return range.minRange <= value && value <= range.maxRange;
	            };
	            ScatterChart.getMarkerFillOpacity = function (hasSize, shouldEnableFill, hasSelection, isSelected) {
	                if (hasSize || shouldEnableFill) {
	                    if (hasSelection && !isSelected) {
	                        return ScatterChart.DimmedBubbleOpacity;
	                    }
	                    return ScatterChart.DefaultBubbleOpacity;
	                }
	                else {
	                    return 0;
	                }
	            };
	            ScatterChart.getMarkerStrokeOpacity = function (hasSize, colorBorder, hasSelection, isSelected) {
	                if (hasSize && colorBorder) {
	                    return 1;
	                }
	                else {
	                    if (hasSelection && !isSelected) {
	                        return ScatterChart.DimmedBubbleOpacity;
	                    }
	                    return ScatterChart.DefaultBubbleOpacity;
	                }
	            };
	            ScatterChart.getMarkerStrokeFill = function (hasSize, colorBorder, fill) {
	                if (hasSize && colorBorder) {
	                    var colorRgb = Color.parseColorString(fill);
	                    return Color.hexString(Color.darken(colorRgb, ScatterChart.StrokeDarkenColorValue));
	                }
	                return fill;
	            };
	            ScatterChart.getMarkerStyle = function (d, colorBorder, hasSelection, fillMarkers) {
	                return {
	                    'stroke-opacity': ScatterChart.getMarkerStrokeOpacity(d.size != null, colorBorder, hasSelection, d.selected),
	                    stroke: ScatterChart.getMarkerStrokeFill(d.size != null, colorBorder, d.fill),
	                    fill: d.fill,
	                    'fill-opacity': ScatterChart.getMarkerFillOpacity(d.size != null, fillMarkers, hasSelection, d.selected),
	                };
	            };
	            ScatterChart.getSeriesStyle = function (hasSize, colorBorder, hasSelection, fillMarkers, fill) {
	                return {
	                    'stroke-opacity': ScatterChart.getMarkerStrokeOpacity(hasSize, colorBorder, hasSelection, false),
	                    stroke: ScatterChart.getMarkerStrokeFill(hasSize, colorBorder, fill),
	                    fill: fill,
	                    'fill-opacity': ScatterChart.getMarkerFillOpacity(hasSize, fillMarkers, hasSelection, false),
	                };
	            };
	            ScatterChart.getBubbleOpacity = function (d, hasSelection) {
	                if (hasSelection && !d.selected) {
	                    return ScatterChart.DimmedBubbleOpacity;
	                }
	                return ScatterChart.DefaultBubbleOpacity;
	            };
	            ScatterChart.prototype.onClearSelection = function () {
	                if (this.interactivityService)
	                    this.interactivityService.clearSelection();
	            };
	            ScatterChart.prototype.getSupportedCategoryAxisType = function () {
	                return visuals.axisType.scalar;
	            };
	            ScatterChart.sortBubbles = function (a, b) {
	                var diff = (b.radius.sizeMeasure.values[b.radius.index] - a.radius.sizeMeasure.values[a.radius.index]);
	                if (diff !== 0)
	                    return diff;
	                // Tie-break equal size bubbles using identity.
	                return b.identity.getKey().localeCompare(a.identity.getKey());
	            };
	            ScatterChart.BubbleRadius = 3 * 2;
	            ScatterChart.DefaultBubbleOpacity = 0.85;
	            ScatterChart.DimmedBubbleOpacity = 0.4;
	            ScatterChart.StrokeDarkenColorValue = 255 * 0.25;
	            //label layout settings
	            ScatterChart.dataLabelLayoutStartingOffset = 2;
	            ScatterChart.dataLabelLayoutOffsetIterationDelta = 6;
	            ScatterChart.dataLabelLayoutMaximumOffset = ScatterChart.dataLabelLayoutStartingOffset + (2 * ScatterChart.dataLabelLayoutOffsetIterationDelta);
	            // Chart Area and size range values as defined by PV charts
	            ScatterChart.AreaOf300By300Chart = 90000;
	            ScatterChart.MinSizeRange = 200;
	            ScatterChart.MaxSizeRange = 3000;
	            ScatterChart.ClassName = 'scatterChart';
	            // Animated rendering threshold - if more than this number of data points, rendering is grouped by series and not animated
	            ScatterChart.NoAnimationThreshold = 1000;
	            // No render resize threshold - if more than this number of data points, rendering is suppressed during resize
	            ScatterChart.NoRenderResizeThreshold = 1000;
	            return ScatterChart;
	        }());
	        visuals.ScatterChart = ScatterChart;
	        var SvgRenderer = (function () {
	            function SvgRenderer() {
	            }
	            SvgRenderer.prototype.init = function (element, labelsContext, isMobileChart, tooltipsEnabled) {
	                this.mainGraphicsG = element.append('g')
	                    .classed(SvgRenderer.MainGraphicsContext.class, true);
	                this.isMobileChart = isMobileChart;
	                if (isMobileChart) {
	                    // The backgroundRect catch user interactions when clicking/dragging on the background of the chart.
	                    this.mainGraphicsBackgroundRect = this.mainGraphicsG
	                        .append("rect")
	                        .classed("backgroundRect", true)
	                        .attr({ width: "100%", height: "100%" });
	                }
	                this.mainGraphicsContext = this.mainGraphicsG.append('svg');
	                this.labelGraphicsContext = labelsContext;
	                this.tooltipsEnabled = tooltipsEnabled;
	                // common rendering attributes
	                this.mainGraphicsContext.attr('stroke-width', "1");
	            };
	            SvgRenderer.prototype.render = function (viewModel, interactivityService) {
	                var viewport = viewModel.viewport;
	                this.mainGraphicsContext
	                    .attr({
	                    'width': viewport.width,
	                    'height': viewport.height
	                });
	                var scatterMarkers;
	                if (viewModel.suppressDataPointRendering) {
	                    scatterMarkers = this.removeScatterMarkers();
	                }
	                else if (viewModel.animationDuration > 0) {
	                    scatterMarkers = this.drawScatterMarkers(viewModel);
	                }
	                else {
	                    scatterMarkers = this.drawScatterMarkersNoAnimation(viewModel, viewModel.drawBubbles);
	                }
	                if (viewModel.drawBubbles)
	                    scatterMarkers.order();
	                if (this.tooltipsEnabled) {
	                    visuals.TooltipManager.addTooltip(this.mainGraphicsContext, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
	                }
	                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(viewModel.animationOptions);
	                return {
	                    dataPointsSelection: scatterMarkers,
	                    eventGroup: this.mainGraphicsG,
	                    data: viewModel.data,
	                    plotContext: this.mainGraphicsContext,
	                };
	            };
	            SvgRenderer.prototype.createTraceLineRenderer = function (viewModel) {
	                return new ScatterTraceLineRenderer(viewModel, this.mainGraphicsContext, this.tooltipsEnabled);
	            };
	            SvgRenderer.prototype.removeScatterMarkers = function () {
	                this.mainGraphicsContext.selectAll(SvgRenderer.ScatterMarkerSeriesGroup.selector)
	                    .remove();
	                return this.mainGraphicsContext.selectAll(SvgRenderer.DotClass.selector);
	            };
	            SvgRenderer.prototype.drawScatterMarkers = function (viewModel) {
	                var data = viewModel.data;
	                var xScale = viewModel.xAxisProperties.scale;
	                var yScale = viewModel.yAxisProperties.scale;
	                // put all the markers in a single fake group. keeps the dom structure consistent between
	                // drawScatterMarkers and drawScatterMarkersGrouped.
	                var fakeDataPointSeries = [
	                    {
	                        identityKey: "",
	                        dataPoints: data.dataPoints,
	                    },
	                ];
	                var fakeSeriesGroups = this.mainGraphicsContext.selectAll(SvgRenderer.ScatterMarkerSeriesGroup.selector)
	                    .data(fakeDataPointSeries, function (s) { return s.identityKey; });
	                fakeSeriesGroups.enter()
	                    .append('g')
	                    .classed(SvgRenderer.ScatterMarkerSeriesGroup.class, true);
	                // groups for real series may have been inserted by drawScatterMarkersGrouped, remove them
	                fakeSeriesGroups.exit()
	                    .remove();
	                var markers = fakeSeriesGroups.selectAll(SvgRenderer.DotClass.selector)
	                    .data(function (s) { return s.dataPoints; }, function (d) { return d.identity.getKey(); });
	                markers.enter().append('circle')
	                    .classed(SvgRenderer.DotClass.class, true)
	                    .style('opacity', 0) // Fade new bubbles into visibility
	                    .attr('r', 0);
	                markers
	                    .style({
	                    'stroke-opacity': function (d) { return ScatterChart.getMarkerStrokeOpacity(d.size != null, data.colorBorder, viewModel.hasSelection, d.selected); },
	                    'stroke': function (d) { return ScatterChart.getStrokeFill(d, data.colorBorder); },
	                    'fill': function (d) { return d.fill; },
	                    'fill-opacity': function (d) { return ScatterChart.getMarkerFillOpacity(d.size != null, viewModel.fillMarkers, viewModel.hasSelection, d.selected); },
	                })
	                    .transition()
	                    .ease(viewModel.easeType)
	                    .duration(viewModel.animationDuration)
	                    .style('opacity', 1) // Fill-opacity is used for selected / highlight changes, opacity is for enter/exit fadein/fadeout
	                    .attr({
	                    r: function (d) { return ScatterChart.getBubbleRadius(d.radius, data.sizeRange, viewModel.viewport); },
	                    cx: function (d) { return xScale(d.x); },
	                    cy: function (d) { return yScale(d.y); },
	                });
	                markers
	                    .exit()
	                    .transition()
	                    .ease(viewModel.easeType)
	                    .duration(viewModel.animationDuration)
	                    .style('opacity', 0) // Fade out bubbles that are removed
	                    .attr('r', 0)
	                    .remove();
	                return markers;
	            };
	            SvgRenderer.prototype.drawScatterMarkersNoAnimation = function (viewModel, isBubble) {
	                var data = viewModel.data;
	                var xScale = viewModel.xAxisProperties.scale;
	                var yScale = viewModel.yAxisProperties.scale;
	                var seriesGroups;
	                if (isBubble) {
	                    var fakeDataPointSeries = [
	                        {
	                            identityKey: "",
	                            dataPoints: data.dataPoints,
	                        },
	                    ];
	                    seriesGroups = this.mainGraphicsContext.selectAll(SvgRenderer.ScatterMarkerSeriesGroup.selector)
	                        .data(fakeDataPointSeries, function (s) { return s.identityKey; });
	                }
	                else {
	                    seriesGroups = this.mainGraphicsContext.selectAll(SvgRenderer.ScatterMarkerSeriesGroup.selector).data(data.dataPointSeries, function (s) { return s.identityKey; });
	                }
	                // a group for each series
	                seriesGroups.enter()
	                    .append('g')
	                    .classed(SvgRenderer.ScatterMarkerSeriesGroup.class, true);
	                // this will also remove the fake group that might have been created by drawScatterMarkers
	                seriesGroups.exit()
	                    .remove();
	                seriesGroups
	                    .each(function (s) {
	                    var seriesStyle = ScatterChart.getSeriesStyle(s.hasSize, data.colorBorder, viewModel.hasSelection, viewModel.fillMarkers, s.fill);
	                    var g = d3.select(this);
	                    SvgRenderer.applyStyle(this, seriesStyle);
	                    var markers = g.selectAll(SvgRenderer.DotClass.selector).data(s.dataPoints, function (m) { return m.identity.getKey(); });
	                    markers.interrupt();
	                    markers.enter()
	                        .append('circle')
	                        .classed(SvgRenderer.DotClass.class, true);
	                    markers.exit()
	                        .remove();
	                    markers.each(function (d) {
	                        var style = ScatterChart.getMarkerStyle(d, data.colorBorder, viewModel.hasSelection, viewModel.fillMarkers);
	                        SvgRenderer.styleException(style, seriesStyle);
	                        SvgRenderer.applyStyle(this, style);
	                    });
	                    markers.attr({
	                        r: function (d) { return ScatterChart.getBubbleRadius(d.radius, data.sizeRange, viewModel.viewport); },
	                        cx: function (d) { return xScale(d.x); },
	                        cy: function (d) { return yScale(d.y); },
	                    });
	                });
	                return this.mainGraphicsContext.selectAll(SvgRenderer.DotClass.selector);
	            };
	            SvgRenderer.styleException = function (elementStyle, seriesStyle) {
	                if (seriesStyle) {
	                    for (var name_1 in elementStyle) {
	                        if (elementStyle[name_1] === seriesStyle[name_1]) {
	                            elementStyle[name_1] = null;
	                        }
	                    }
	                }
	            };
	            SvgRenderer.applyStyle = function (element, style) {
	                for (var name_2 in style) {
	                    var elementValue = element.style[name_2];
	                    var styleValue = style[name_2];
	                    if (styleValue == null) {
	                        if (elementValue === "")
	                            continue;
	                    }
	                    else {
	                        styleValue = styleValue.toString();
	                        if (styleValue === elementValue)
	                            continue;
	                    }
	                    element.style[name_2] = styleValue;
	                }
	            };
	            SvgRenderer.DotClass = createClassAndSelector('dot');
	            SvgRenderer.MainGraphicsContext = createClassAndSelector('mainGraphicsContext');
	            SvgRenderer.ScatterMarkerSeriesGroup = createClassAndSelector('scatterMarkerSeriesGroup');
	            return SvgRenderer;
	        }());
	        var ScatterChartDataLabels;
	        (function (ScatterChartDataLabels) {
	            var validLabelPositions = [
	                2 /* Below */,
	                1 /* Above */,
	                8 /* Right */,
	                4 /* Left */,
	                16 /* BelowRight */,
	                32 /* BelowLeft */,
	                64 /* AboveRight */,
	                128 /* AboveLeft */
	            ];
	            function createLabelDataPoints(viewModel) {
	                var xScale = viewModel.xAxisProperties.scale;
	                var yScale = viewModel.yAxisProperties.scale;
	                var sizeRange = viewModel.data.sizeRange;
	                var labelDataPoints = [];
	                var dataPoints = viewModel.data.dataPoints;
	                var labelSettings = viewModel.data.dataLabelsSettings;
	                var preferredLabelsKeys = getPreferredLabelsKeys(viewModel);
	                for (var _i = 0, dataPoints_1 = dataPoints; _i < dataPoints_1.length; _i++) {
	                    var dataPoint = dataPoints_1[_i];
	                    var text = dataPoint.formattedCategory.getValue();
	                    var properties = {
	                        text: text,
	                        fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
	                        fontSize: PixelConverter.fromPoint(labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt),
	                        fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight,
	                    };
	                    var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
	                    var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
	                    labelDataPoints.push({
	                        isPreferred: preferredLabelsKeys ? isLabelPreferred(dataPoint.identity.getKey(), preferredLabelsKeys) : false,
	                        text: text,
	                        textSize: {
	                            width: textWidth,
	                            height: textHeight,
	                        },
	                        outsideFill: labelSettings.labelColor ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultLabelColor,
	                        insideFill: visuals.NewDataLabelUtils.defaultInsideLabelColor,
	                        parentType: 0 /* Point */,
	                        parentShape: {
	                            point: {
	                                x: xScale(dataPoint.x),
	                                y: yScale(dataPoint.y),
	                            },
	                            radius: ScatterChart.getBubbleRadius(dataPoint.radius, sizeRange, viewModel.viewport),
	                            validPositions: validLabelPositions,
	                        },
	                        identity: dataPoint.identity,
	                        fontSize: labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt,
	                    });
	                }
	                return labelDataPoints;
	            }
	            ScatterChartDataLabels.createLabelDataPoints = createLabelDataPoints;
	            function getPreferredLabelsKeys(viewModel) {
	                var width = viewModel.viewport.width;
	                var height = viewModel.viewport.height;
	                var visualCenter = new visuals.Point(width / 2, height / 2);
	                var quadrantsCenters = getQuadrantsCenters(width, height);
	                return getCandidateLabels(visualCenter, quadrantsCenters, viewModel);
	            }
	            function getQuadrantsCenters(visualWidth, visualHeight) {
	                var quadrantsCenters = [];
	                var quarterWidth = visualWidth / 4;
	                var quarterHeight = visualHeight / 4;
	                quadrantsCenters.push(new visuals.Point(quarterWidth, quarterHeight));
	                quadrantsCenters.push(new visuals.Point(quarterWidth * 3, quarterHeight));
	                quadrantsCenters.push(new visuals.Point(quarterWidth, quarterHeight * 3));
	                quadrantsCenters.push(new visuals.Point(quarterWidth * 3, quarterHeight * 3));
	                return quadrantsCenters;
	            }
	            function getCandidateLabels(visualCenter, quadrantsCenters, viewModel) {
	                var minDistances = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE];
	                var ids = [];
	                var xScale = viewModel.xAxisProperties.scale;
	                var yScale = viewModel.yAxisProperties.scale;
	                var distance;
	                for (var _i = 0, _a = viewModel.data.dataPoints; _i < _a.length; _i++) {
	                    var dp = _a[_i];
	                    var x = xScale(dp.x);
	                    var y = yScale(dp.y);
	                    var quadrantNumber = getPointQuadrantNumber(x, y, visualCenter);
	                    if (viewModel.drawBubbles) {
	                        // Since the array is sorted by size the preferred label will be the first label in the quadrant
	                        if (!ids[quadrantNumber])
	                            ids[quadrantNumber] = dp.identity;
	                    }
	                    else {
	                        distance = getDistanceBetweenPoints(quadrantsCenters[quadrantNumber].x, quadrantsCenters[quadrantNumber].y, x, y);
	                        if (distance < minDistances[quadrantNumber]) {
	                            ids[quadrantNumber] = dp.identity;
	                            minDistances[quadrantNumber] = distance;
	                        }
	                    }
	                }
	                var preferredLabelsKeys = [];
	                for (var _b = 0, ids_1 = ids; _b < ids_1.length; _b++) {
	                    var id = ids_1[_b];
	                    if (id)
	                        preferredLabelsKeys.push(id.getKey());
	                }
	                return preferredLabelsKeys;
	            }
	            function getPointQuadrantNumber(x, y, centerPoint) {
	                if (x > centerPoint.x && y <= centerPoint.y)
	                    return 0 /* First */;
	                if (x <= centerPoint.x && y <= centerPoint.y)
	                    return 1 /* Second */;
	                if (x <= centerPoint.x && y > centerPoint.y)
	                    return 2 /* Third */;
	                else
	                    return 3 /* Fourth */;
	            }
	            function getDistanceBetweenPoints(x1, y1, x2, y2) {
	                return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
	            }
	            function isLabelPreferred(key, preferredLabelsKeys) {
	                for (var _i = 0, preferredLabelsKeys_1 = preferredLabelsKeys; _i < preferredLabelsKeys_1.length; _i++) {
	                    var preferredLabel = preferredLabelsKeys_1[_i];
	                    if (key.localeCompare(preferredLabel) === 0)
	                        return true;
	                }
	                return false;
	            }
	        })(ScatterChartDataLabels || (ScatterChartDataLabels = {}));
	        var ScatterTraceLineRenderer = (function () {
	            function ScatterTraceLineRenderer(viewModel, element, tooltipsEnabled) {
	                this.viewModel = viewModel;
	                this.element = element;
	                this.tooltipsEnabled = tooltipsEnabled;
	            }
	            ScatterTraceLineRenderer.prototype.remove = function () {
	                this.element.selectAll(ScatterTraceLineRenderer.TraceLine.selector).remove();
	                this.element.selectAll(ScatterTraceLineRenderer.TraceBubble.selector).remove();
	            };
	            ScatterTraceLineRenderer.prototype.render = function (selectedPoints, shouldAnimate) {
	                var viewModel = this.viewModel;
	                var scatterViewModel = viewModel.viewModel;
	                var seriesPoints = [];
	                if (!_.isEmpty(selectedPoints) && !scatterViewModel.suppressDataPointRendering) {
	                    var currentFrameIndex_1 = viewModel.data.currentFrameIndex;
	                    // filter to the selected identity, only up to and including the current frame. Add frames during play.
	                    var hasBubbleAtCurrentFrame = [];
	                    for (var selectedIndex = 0, selectedLen = selectedPoints.length; selectedIndex < selectedLen; selectedIndex++) {
	                        seriesPoints[selectedIndex] = [];
	                        hasBubbleAtCurrentFrame[selectedIndex] = false;
	                        for (var frameIndex = 0, frameLen = viewModel.data.allViewModels.length; frameIndex < frameLen && frameIndex <= currentFrameIndex_1; frameIndex++) {
	                            var value = _.find(viewModel.data.allViewModels[frameIndex].dataPoints, function (value, index) {
	                                return value.identity.getKey() === selectedPoints[selectedIndex].identity.getKey();
	                            });
	                            if (value != null) {
	                                // TODO: Revisit this, we should be able to keep track without modifying Scatter's data points.
	                                value.frameIndex = frameIndex;
	                                seriesPoints[selectedIndex].push(value);
	                                if (frameIndex === currentFrameIndex_1)
	                                    hasBubbleAtCurrentFrame[selectedIndex] = true;
	                            }
	                        }
	                    }
	                    var xScale_1 = scatterViewModel.xAxisProperties.scale;
	                    var yScale_1 = scatterViewModel.yAxisProperties.scale;
	                    var line_1 = d3.svg.line()
	                        .x(function (d) { return xScale_1(d.x); })
	                        .y(function (d) { return yScale_1(d.y); })
	                        .defined(function (d) { return d.x !== null && d.y !== null; });
	                    // Render Lines
	                    var traceLines = this.element.selectAll(ScatterTraceLineRenderer.TraceLine.selector)
	                        .data(selectedPoints, function (sp) { return sp.identity.getKey(); });
	                    traceLines.enter()
	                        .append('path')
	                        .classed(ScatterTraceLineRenderer.TraceLine.class, true);
	                    // prepare array of new/previous lengths
	                    // NOTE: can't use lambda because we need the "this" context to be the DOM Element associated with the .each()
	                    var previousLengths_1 = [], newLengths_1 = [];
	                    var reverse_1 = false;
	                    traceLines.each(function (d, i) {
	                        var existingPath = this;
	                        var previousLength = existingPath.hasAttribute('d') ? existingPath.getTotalLength() : 0;
	                        previousLengths_1.push(previousLength);
	                        // create offline SVG for new path measurement
	                        var tempSvgPath = $('<svg><path></path></svg>');
	                        var tempPath = $('path', tempSvgPath);
	                        tempPath.attr('d', line_1(seriesPoints[i]));
	                        var newLength = seriesPoints[i].length > 0 ? tempPath.get()[0].getTotalLength() : 0;
	                        newLengths_1.push(newLength);
	                        reverse_1 = reverse_1 || (newLength < previousLength);
	                    });
	                    // animate using stroke-dash* trick
	                    if (!reverse_1) {
	                        // growing line
	                        traceLines
	                            .style('stroke', function (d) { return ScatterChart.getStrokeFill(d, true); })
	                            .attr({
	                            'd': function (d, i) {
	                                return line_1(seriesPoints[i]);
	                            },
	                            'stroke-dasharray': function (d, i) { return newLengths_1[i] + " " + newLengths_1[i]; },
	                            'stroke-dashoffset': function (d, i) { return newLengths_1[i] - previousLengths_1[i]; },
	                        });
	                        if (shouldAnimate) {
	                            traceLines
	                                .transition()
	                                .ease('linear')
	                                .duration(visuals.PlayChart.FrameAnimationDuration)
	                                .attr('stroke-dashoffset', 0);
	                        }
	                        else {
	                            traceLines.attr('stroke-dashoffset', 0);
	                        }
	                    }
	                    else {
	                        // shrinking line
	                        if (shouldAnimate) {
	                            traceLines
	                                .transition()
	                                .ease('linear')
	                                .duration(visuals.PlayChart.FrameAnimationDuration)
	                                .attr('stroke-dashoffset', function (d, i) { return previousLengths_1[i] - newLengths_1[i]; })
	                                .transition()
	                                .ease('linear')
	                                .duration(1) // animate the shrink first, then update with new line properties
	                                .delay(visuals.PlayChart.FrameAnimationDuration)
	                                .style('stroke', function (d) { return ScatterChart.getStrokeFill(d, true); })
	                                .attr({
	                                'd': function (d, i) {
	                                    return line_1(seriesPoints[i]);
	                                },
	                                'stroke-dasharray': function (d, i) { return newLengths_1[i] + " " + newLengths_1[i]; },
	                                'stroke-dashoffset': 0,
	                            });
	                        }
	                        else {
	                            traceLines
	                                .style('stroke', function (d) { return ScatterChart.getStrokeFill(d, true); })
	                                .attr({
	                                'd': function (d, i) {
	                                    return line_1(seriesPoints[i]);
	                                },
	                                'stroke-dasharray': function (d, i) { return newLengths_1[i] + " " + newLengths_1[i]; },
	                                'stroke-dashoffset': 0,
	                            });
	                        }
	                    }
	                    traceLines.exit()
	                        .remove();
	                    // Render circles
	                    var circlePoints = [];
	                    for (var selectedIndex_1 = 0; selectedIndex_1 < seriesPoints.length; selectedIndex_1++) {
	                        var points = seriesPoints[selectedIndex_1];
	                        // slice to length-1 because we draw lines to the current bubble but we don't need to draw the current frame's bubble
	                        var newPoints = hasBubbleAtCurrentFrame[selectedIndex_1] ? points.slice(0, points.length - 1) : points;
	                        circlePoints = circlePoints.concat(newPoints);
	                    }
	                    var circles = this.element.selectAll(ScatterTraceLineRenderer.TraceBubble.selector)
	                        .data(circlePoints, function (d) { return d.identity.getKey() + d.x + d.y + d.size; });
	                    circles.enter()
	                        .append('circle')
	                        .style('opacity', 0) //fade new bubbles into visibility
	                        .classed(ScatterTraceLineRenderer.TraceBubble.class, true);
	                    circles
	                        .attr('cx', function (d) { return xScale_1(d.x); })
	                        .attr('cy', function (d) { return yScale_1(d.y); })
	                        .attr('r', function (d) { return ScatterChart.getBubbleRadius(d.radius, viewModel.data.currentViewModel.sizeRange, viewModel.viewport); })
	                        .style({
	                        'stroke-opacity': function (d) { return ScatterChart.getBubbleOpacity(d, true); },
	                        'stroke': function (d) { return ScatterChart.getStrokeFill(d, viewModel.data.currentViewModel.colorBorder); },
	                        'fill': function (d) { return d.fill; },
	                        // vary the opacity along the traceline from 0.20 to 0.80, with 0.85 left for the circle already drawn by scatterChart
	                        'fill-opacity': function (d) { return d.size != null ? 0.20 + (d.frameIndex / currentFrameIndex_1) * 0.60 : 0; },
	                    })
	                        .transition()
	                        .ease('linear')
	                        .duration(visuals.PlayChart.FrameAnimationDuration)
	                        .style('opacity', 1);
	                    circles.exit()
	                        .transition()
	                        .ease('linear')
	                        .duration(visuals.PlayChart.FrameAnimationDuration)
	                        .style('opacity', 0) // fade exiting bubbles out
	                        .remove();
	                    if (this.tooltipsEnabled) {
	                        visuals.TooltipManager.addTooltip(circles, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
	                    }
	                    // sort the z-order, smallest size on top
	                    circles.sort(function (d1, d2) { return d2.size - d1.size; });
	                }
	                else {
	                    this.remove();
	                }
	            };
	            ScatterTraceLineRenderer.TraceLine = createClassAndSelector('traceLine');
	            ScatterTraceLineRenderer.TraceBubble = createClassAndSelector('traceBubble');
	            return ScatterTraceLineRenderer;
	        }());
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 271 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
	        var createDataViewScopeIdentity = powerbi.data.createDataViewScopeIdentity;
	        var DataViewConcatenateCategoricalColumns = powerbi.data.DataViewConcatenateCategoricalColumns;
	        var DataViewMatrixUtils = powerbi.data.DataViewMatrixUtils;
	        var SQExprBuilder = powerbi.data.SQExprBuilder;
	        ;
	        ;
	        var PlayAxis = (function () {
	            function PlayAxis(options) {
	                if (options) {
	                    this.interactivityService = options.interactivityService;
	                }
	            }
	            PlayAxis.prototype.init = function (options) {
	                var _this = this;
	                debug.assertValue(options, 'options');
	                this.element = options.element;
	                this.svg = options.svg;
	                this.host = options.host;
	                this.isMobileChart = options.interactivity && options.interactivity.isInteractiveLegend;
	                if (this.interactivityService) {
	                    this.playControl = new PlayControl(this.element, function (frameIndex) { return _this.moveToFrameAndRender(frameIndex); }, this.isMobileChart);
	                    this.playControl.onPlay(function () { return _this.play(); });
	                }
	            };
	            PlayAxis.prototype.setData = function (dataView, visualConverter) {
	                if (dataView) {
	                    if (this.ridiculousFlagForPersistProperties && dataView.metadata) {
	                        // BUG FIX: customer feedback has been strong that we should always default to show the last frame.
	                        // This is essential for dashboard tiles to refresh properly.
	                        //  Only copy frameIndex since it is the only property using persistProperties
	                        //let objectProps = getObjectProperties(dataView.metadata);
	                        //playData.currentFrameIndex = objectProps.currentFrameIndex;
	                        //  Turn off the flag that was set by our persistProperties call
	                        this.ridiculousFlagForPersistProperties = false;
	                        return this.playData;
	                    }
	                    else if (dataView.matrix || dataView.categorical) {
	                        this.playData = PlayChart.converter(dataView, visualConverter);
	                    }
	                    else {
	                        this.playData = PlayChart.getDefaultPlayData();
	                    }
	                }
	                else {
	                    this.playData = PlayChart.getDefaultPlayData();
	                }
	                // Next render should be a full one.
	                this.lastViewport = undefined;
	                return this.playData;
	            };
	            PlayAxis.prototype.render = function (suppressAnimations, viewModel, viewport, margin) {
	                var playData = this.playData;
	                var resized = !this.lastViewport || (this.lastViewport.height !== viewport.height || this.lastViewport.width !== viewport.width);
	                this.lastViewport = viewport;
	                if (resized)
	                    this.stop();
	                if (!playData)
	                    return;
	                var playViewModel = {
	                    data: this.playData,
	                    viewModel: viewModel,
	                    viewport: viewport,
	                };
	                var hasSelection = false;
	                if (this.interactivityService) {
	                    var data_1 = playData.currentViewModel;
	                    this.interactivityService.applySelectionStateToData(data_1.dataPoints);
	                    hasSelection = this.interactivityService.hasSelection();
	                }
	                this.updateCallout(viewport, margin);
	                if (this.playControl && resized) {
	                    this.playControl.rebuild(playData, viewport);
	                }
	                var allDataPoints = playData.allViewModels.map(function (vm) { return vm.dataPoints; });
	                var flatAllDataPoints = _.flatten(allDataPoints);
	                // NOTE: Return data points to keep track of current selected bubble even if it drops out for a few frames
	                return {
	                    allDataPoints: flatAllDataPoints,
	                    viewModel: playViewModel,
	                };
	            };
	            PlayAxis.prototype.updateCallout = function (viewport, margin) {
	                var playData = this.playData;
	                var frameData = playData.frameData;
	                var currentFrameIndex = playData.currentFrameIndex;
	                var height = viewport.height;
	                var plotAreaHeight = height - margin.top - margin.bottom;
	                var width = viewport.width;
	                var plotAreaWidth = width - margin.left - margin.right;
	                var calloutDimension = Math.min(height, width * 1.3); //1.3 to compensate for tall, narrow-width viewport
	                var fontSize = Math.max(12, Math.round(calloutDimension / 7));
	                fontSize = Math.min(fontSize, 70);
	                var textProperties = {
	                    fontSize: jsCommon.PixelConverter.toString(fontSize),
	                    text: frameData[currentFrameIndex].text || "",
	                    fontFamily: visuals.Font.Family.regular.css,
	                };
	                var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties) - powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(textProperties);
	                var calloutData = [];
	                if (currentFrameIndex < frameData.length && currentFrameIndex >= 0 && textHeight < plotAreaHeight) {
	                    var maxTextWidth = plotAreaWidth - (2 * PlayAxis.calloutOffsetMultiplier * textHeight);
	                    var calloutText = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, maxTextWidth);
	                    calloutData = [calloutText];
	                }
	                var callout = this.svg.selectAll(PlayAxis.PlayCallout.selector).data(calloutData);
	                callout.enter()
	                    .append('text')
	                    .classed(PlayAxis.PlayCallout.class, true);
	                callout
	                    .text(function (d) { return d; })
	                    .attr({
	                    x: plotAreaWidth - PlayAxis.calloutOffsetMultiplier * textHeight,
	                    y: function () { return textHeight; },
	                })
	                    .style({
	                    'font-size': fontSize + 'px',
	                    'text-anchor': 'end',
	                });
	                callout.exit().remove();
	            };
	            PlayAxis.prototype.play = function () {
	                var playData = this.playData;
	                if (this.isPlaying) {
	                    this.stop();
	                }
	                else if (this.playControl) {
	                    this.isPlaying = true;
	                    this.playControl.play();
	                    var indexToShow = Math.round(this.playControl.getCurrentIndex());
	                    if (indexToShow >= playData.allViewModels.length - 1) {
	                        playData.currentFrameIndex = -1;
	                    }
	                    else {
	                        playData.currentFrameIndex = indexToShow - 1;
	                    }
	                    this.playNextFrame(playData);
	                }
	            };
	            PlayAxis.prototype.playNextFrame = function (playData, startFrame, endFrame) {
	                var _this = this;
	                if (!this.isPlaying) {
	                    this.stop();
	                    return;
	                }
	                var nextFrame = playData.currentFrameIndex + 1;
	                if (startFrame != null && endFrame != null) {
	                    nextFrame = Math.abs(endFrame - startFrame + 1);
	                    startFrame = nextFrame;
	                }
	                if (nextFrame < playData.allViewModels.length && nextFrame > -1) {
	                    playData.currentFrameIndex = nextFrame;
	                    playData.currentViewModel = playData.allViewModels[nextFrame];
	                    this.renderDelegate(playData.currentViewModel);
	                    this.playControl.setFrame(nextFrame);
	                    if (nextFrame < playData.allViewModels.length) {
	                        window.setTimeout(function () {
	                            _this.playNextFrame(playData, startFrame, endFrame);
	                        }, PlayChart.FrameStepDuration);
	                    }
	                }
	                else {
	                    this.stop();
	                }
	            };
	            PlayAxis.prototype.stop = function () {
	                if (this.playControl)
	                    this.playControl.pause();
	                this.isPlaying = false;
	            };
	            PlayAxis.prototype.remove = function () {
	                if (this.playControl)
	                    this.playControl.remove();
	                d3.selectAll(PlayAxis.PlayCallout.selector).remove();
	                // TODO: remove any tracelines
	            };
	            PlayAxis.prototype.setRenderFunction = function (fn) {
	                this.renderDelegate = fn;
	            };
	            PlayAxis.prototype.getCartesianExtents = function (existingExtents, getExtents) {
	                if (this.playData && this.playData.allViewModels && this.playData.allViewModels.length > 0) {
	                    return PlayChart.getMinMaxForAllFrames(this.playData, getExtents);
	                }
	                return existingExtents;
	            };
	            PlayAxis.prototype.setPlayControlPosition = function (playControlLayout) {
	                if (this.playControl) {
	                    var container = this.playControl.getContainer();
	                    container.css('left', playControlLayout.left ? playControlLayout.left + 'px' : '');
	                    container.css('top', playControlLayout.top ? playControlLayout.top + 'px' : '');
	                }
	            };
	            PlayAxis.prototype.moveToFrameAndRender = function (frameIndex) {
	                var playData = this.playData;
	                this.isPlaying = true;
	                if (playData && frameIndex >= 0 && frameIndex < playData.allViewModels.length && frameIndex !== playData.currentFrameIndex) {
	                    playData.currentFrameIndex = frameIndex;
	                    var data_2 = playData.allViewModels[frameIndex];
	                    playData.currentViewModel = data_2;
	                    this.renderDelegate(data_2);
	                }
	                this.isPlaying = false;
	            };
	            PlayAxis.prototype.isCurrentlyPlaying = function () {
	                return this.isPlaying;
	            };
	            PlayAxis.PlayCallout = createClassAndSelector('play-callout');
	            PlayAxis.calloutOffsetMultiplier = 0.3;
	            return PlayAxis;
	        }());
	        visuals.PlayAxis = PlayAxis;
	        var PlayControl = (function () {
	            function PlayControl(element, renderDelegate, isMobileChart) {
	                this.isMobileChart = isMobileChart;
	                this.createSliderDOM(element);
	                this.renderDelegate = renderDelegate;
	            }
	            PlayControl.prototype.getContainer = function () {
	                return this.playAxisContainer;
	            };
	            PlayControl.prototype.remove = function () {
	                if (this.playAxisContainer)
	                    this.playAxisContainer.remove();
	            };
	            PlayControl.prototype.pause = function () {
	                this.playButton.removeClass('pause').addClass('play');
	            };
	            PlayControl.prototype.play = function () {
	                this.playButton.removeClass('play').addClass('pause');
	            };
	            PlayControl.prototype.getCurrentIndex = function () {
	                // TODO: round() necessary?
	                return Math.round(this.noUiSlider.get());
	            };
	            PlayControl.prototype.onPlay = function (handler) {
	                this.playButtonCircle.off('click');
	                this.playButtonCircle.on('click', handler);
	            };
	            PlayControl.prototype.setFrame = function (frameIndex) {
	                this.noUiSlider.set([frameIndex]);
	            };
	            ;
	            PlayControl.prototype.rebuild = function (playData, viewport) {
	                var _this = this;
	                var slider = this.slider;
	                // re-create the slider
	                if (this.noUiSlider)
	                    this.noUiSlider.destroy();
	                var labelData = playData.labelData;
	                var sliderSize = PlayControl.calucalateSliderSize(labelData, viewport.width);
	                var container = this.getContainer();
	                if (sliderSize.marginLeft > PlayControl.SliderMarginLeft) {
	                    container.css("padding-left", sliderSize.marginLeft - PlayControl.SliderMarginLeft + "px");
	                    container.css("box-sizing", "border-box");
	                }
	                var skipStep = this.updateSliderControl(playData, sliderSize.width);
	                var width = PlayControl.adjustWidthRegardingLastItem(labelData, skipStep, sliderSize.width);
	                this.slider.css('width', width + 'px');
	                this.noUiSlider.on('slide', function () {
	                    var indexToShow = _this.getCurrentIndex();
	                    _this.renderDelegate(indexToShow);
	                });
	                var nextLabelIndex = 0;
	                // update the width and margin-left to center up each label
	                $('.noUi-value', slider).each(function (idx, elem) {
	                    var actualWidth = labelData.labelInfo[nextLabelIndex].labelWidth;
	                    $(elem).width(actualWidth);
	                    $(elem).css('margin-left', -actualWidth / 2 + 'px');
	                    nextLabelIndex += skipStep;
	                });
	            };
	            /**
	             * Updates slider control regarding new data.
	             * @param playData {PlayChartData<T>} Data for the slider.
	             * @param sliderWidth {number} Slider width.
	             * @returns {number} skip mode for the slider.
	             */
	            PlayControl.prototype.updateSliderControl = function (playData, sliderWidth) {
	                var labelData = playData.labelData;
	                var sliderElement = this.slider.get(0);
	                var numFrames = playData.frameData.length;
	                var options = {
	                    start: numFrames === 0 ? 0 : playData.currentFrameIndex,
	                    step: 1,
	                    range: {
	                        min: 0,
	                        max: numFrames === 0 ? 0 : numFrames - 1
	                    }
	                };
	                var pipOptions = null;
	                var skipMode = 0;
	                if (numFrames > 0) {
	                    var filterPipLabels = PlayControl.createPipsFilterFn(playData, sliderWidth, labelData);
	                    skipMode = filterPipLabels.skipStep;
	                    pipOptions = {
	                        mode: 'steps',
	                        density: Math.ceil(100 / numFrames),
	                        format: {
	                            to: function (index) { return playData.frameData[index].escapedText; },
	                            from: function (value) { return playData.frameData.indexOf(value); },
	                        },
	                        filter: filterPipLabels.filter,
	                    };
	                }
	                options.pips = pipOptions;
	                noUiSlider.create(sliderElement, options);
	                this.noUiSlider = sliderElement.noUiSlider;
	                return skipMode;
	            };
	            PlayControl.createPipsFilterFn = function (playData, sliderWidth, labelData) {
	                var maxLabelWidth = _.max(_.map(labelData.labelInfo, function (l) { return l.labelWidth; }));
	                var pipSize = 1; //0=hide, 1=large, 2=small
	                var skipMode = 1;
	                var maxAllowedLabelWidth = playData.frameData.length > 1 ? sliderWidth / (playData.frameData.length - 1) : sliderWidth;
	                var widthRatio = maxLabelWidth / maxAllowedLabelWidth;
	                if (widthRatio > 1.25) {
	                    skipMode = Math.ceil(widthRatio);
	                    pipSize = 2;
	                }
	                else if (widthRatio > 1.0 || labelData.anyWordBreaks) {
	                    // wordbreak line wrapping is automatic, and we don't reserve enough space to show two lines of text with the larger font
	                    pipSize = 2;
	                }
	                var filterPipLabels = function (index, type) {
	                    // noUiSlider will word break / wrap to new lines, so max width is the max word length
	                    if (index % skipMode === 0) {
	                        return pipSize;
	                    }
	                    return 0; //hide
	                };
	                return { filter: filterPipLabels, skipStep: skipMode };
	            };
	            /**
	             * Adjusts width regarding the last visible label size.
	             * @param labelData label data for chart.
	             * @param skipMode skip factor.
	             * @param sliderWidth current width of slider.
	             */
	            PlayControl.adjustWidthRegardingLastItem = function (labelData, skipMode, sliderWidth) {
	                var labelLenth = labelData.labelInfo.length;
	                var lastVisibleItemIndex = Math.floor((labelLenth - 1) / skipMode) * skipMode;
	                var distanceToEnd = sliderWidth + PlayControl.SliderMarginRight - (sliderWidth / labelLenth * (lastVisibleItemIndex + 1));
	                var lastItemWidth = labelData.labelInfo[lastVisibleItemIndex].labelWidth;
	                var requiredWidth = lastItemWidth / 2 - distanceToEnd;
	                if (requiredWidth > 0) {
	                    var maxMargin = PlayControl.SliderMaxMargin - PlayControl.SliderMarginRight;
	                    requiredWidth = requiredWidth > maxMargin ? maxMargin : requiredWidth;
	                    return sliderWidth - requiredWidth;
	                }
	                return sliderWidth;
	            };
	            PlayControl.prototype.createSliderDOM = function (element) {
	                this.playAxisContainer = $('<div class="play-axis-container"></div>')
	                    .appendTo(element)
	                    .css('height', PlayControl.PlayControlHeight + 'px');
	                this.playButtonCircle = $('<div class="button-container"></div>')
	                    .appendTo(this.playAxisContainer);
	                if (this.isMobileChart) {
	                    this.playButtonCircle.addClass('mobile-button-container');
	                }
	                this.playButton = $('<div class="play"></div>')
	                    .appendTo(this.playButtonCircle);
	                this.slider = $('<div class="sliders"></div>')
	                    .appendTo(this.playAxisContainer);
	            };
	            PlayControl.calucalateSliderSize = function (labelData, viewportWidth) {
	                var leftMargin = 0;
	                if (!_.isEmpty(labelData.labelInfo)) {
	                    leftMargin = _.first(labelData.labelInfo).labelWidth / 2;
	                }
	                var sliderLeftMargin = Math.max(leftMargin, PlayControl.SliderMarginLeft);
	                sliderLeftMargin = Math.min(PlayControl.SliderMaxMargin, sliderLeftMargin);
	                var sliderWidth = Math.max((viewportWidth - sliderLeftMargin - PlayControl.SliderMarginRight), 1);
	                return { width: sliderWidth, marginLeft: sliderLeftMargin };
	            };
	            PlayControl.SliderMarginLeft = 24 + 10 * 2; // playButton width + playButton margin * 2
	            PlayControl.SliderMarginRight = 20;
	            PlayControl.SliderMaxMargin = 100;
	            PlayControl.PlayControlHeight = 80; //tuned for two rows of label text to be perfectly clipped before the third row. Dependent on current font sizes in noui-pips.css
	            return PlayControl;
	        }());
	        var PlayChart;
	        (function (PlayChart) {
	            // TODO: add speed control to property pane
	            // NOTE: current noUiSlider speed is a CSS property of the class .noUi-state-tap, and also is hard-coded in noUiSlider.js. We'll need to add a new create param for transition time.
	            // 800ms matches Silverlight frame speed
	            PlayChart.FrameStepDuration = 800;
	            PlayChart.FrameAnimationDuration = 750; //leave 50ms for the traceline animation - to avoid being cancelled. TODO: add a proper wait impl.
	            PlayChart.ClassName = 'playChart';
	            function convertMatrixToCategorical(sourceDataView, frame) {
	                debug.assert(sourceDataView && sourceDataView.metadata && !!sourceDataView.matrix, 'sourceDataView && sourceDataView.metadata && !!sourceDataView.matrix');
	                var matrix = sourceDataView.matrix;
	                var categorical = {
	                    categories: [],
	                    values: powerbi.data.DataViewTransform.createValueColumns()
	                };
	                // If we don't have enough fields, just return early. We need at least:
	                // 2 rows and 1 column:  (play->category, measures)
	                // or:
	                // 1 row and 2 columns:  (play, series->measures)
	                if ((_.isEmpty(matrix.columns.levels)) || (matrix.rows.levels.length < 2 && matrix.columns.levels.length < 2)) {
	                    return { metadata: sourceDataView.metadata, categorical: categorical };
	                }
	                var CategoryRowLevelsStartingIndex = 1;
	                var categories = [];
	                // Ignore the play field (first row level); the Category field(s) starts from the second row group (play->category) or we don't use this variable (categories)
	                // Note related to VSTS 6986788 and 6885783: there are multiple levels for category during drilldown and expand.
	                for (var i_1 = CategoryRowLevelsStartingIndex, ilen = matrix.rows.levels.length; i_1 < ilen; i_1++) {
	                    // Consider: Change the following debug.assert() to retail.assert() when the infrastructure is ready.
	                    debug.assert(matrix.rows.levels[i_1].sources.length > 0, 'The sources is always expected to contain at least one metadata column.');
	                    var sourceColumn = matrix.rows.levels[i_1].sources[0];
	                    categories.push({
	                        source: sourceColumn,
	                        values: [],
	                        identity: [],
	                        objects: undefined,
	                    });
	                }
	                // Matrix shape for Play:
	                //
	                //                   Series1 | Series2 | ...
	                //                  --------- --------  
	                // Play1 | Category1 | values  | values
	                //       | Category2 | values  | values
	                //       | ...
	                // Play2 | Category1 | values  | values
	                //       | Category2 | values  | values
	                // ...
	                // Or, with drilldown / expand on Category (e.g. expand Country -> Region):
	                //                             Series1 | Series2 | ...
	                //                           --------- --------  
	                // Play1 | Country1 | Region1 | values  | values
	                //       |          | Region2 | values  | values
	                //       | Country2 | Region3 | values  | values
	                //       |          | Region4 | values  | values
	                //       | ...
	                // Play2 | Country1 | Region1 | values  | values
	                //       |          | Region2 | values  | values
	                //       | Country2 | Region3 | values  | values
	                //       |          | Region4 | values  | values
	                // we are guaranteed at least one row (it will be the Play field)
	                var hasRowChildren = !_.isEmpty(matrix.rows.root.children);
	                var hasColChildren = !_.isEmpty(matrix.columns.root.children);
	                var hasSeries = matrix.columns.levels.length > 1 && hasColChildren;
	                var hasPlayAndCategory = matrix.rows.levels.length > 1 && hasRowChildren;
	                if (hasSeries && !hasPlayAndCategory) {
	                    // set categories to undefined
	                    categorical.categories = undefined;
	                    var node = matrix.columns.root;
	                    categorical.values.source = matrix.columns.levels[0].sources[0];
	                    var columnLength_1 = matrix.valueSources.length;
	                    for (var i_2 = 0, len_1 = node.children.length; i_2 < len_1; i_2++) {
	                        // add all the value sources for each series
	                        var columnNode = node.children[i_2];
	                        for (var j = 0; j < columnLength_1; j++) {
	                            // DEFECT 6547170: groupName must be null to turn into (Blank), undefined will use the field name
	                            var source = _.create(matrix.valueSources[j], { groupName: columnNode.value === undefined ? null : columnNode.value });
	                            var dataViewColumn = {
	                                identity: columnNode.identity,
	                                values: [],
	                                source: source
	                            };
	                            categorical.values.push(dataViewColumn);
	                        }
	                    }
	                    // Copying the values from matrix intersection to the categorical values columns...
	                    // Given that this is the case without category levels, the matrix intersection values are stored in playFrameNode.values
	                    var playFrameNode = matrix.rows.root.children[frame];
	                    var matrixIntersectionValues = playFrameNode.values;
	                    for (var i = 0, len = node.children.length; i < len; i++) {
	                        for (var j = 0; j < columnLength_1; j++) {
	                            categorical.values[i * columnLength_1 + j].values.push(matrixIntersectionValues[i * columnLength_1 + j].value);
	                        }
	                    }
	                }
	                else if (hasSeries && hasRowChildren) {
	                    // series and categories
	                    var playFrameNode = matrix.rows.root.children[frame];
	                    // create the categories first
	                    DataViewMatrixUtils.forEachLeafNode(playFrameNode.children, function (categoryGroupLeafNode, index, categoryHierarchicalGroupNodes) {
	                        addMatrixHierarchicalGroupToCategories(categoryHierarchicalGroupNodes, categories);
	                    });
	                    categorical.categories = categories;
	                    // now add the series info
	                    categorical.values.source = matrix.columns.levels[0].sources[0];
	                    var nodeQueue = [];
	                    var columnNode = matrix.columns.root;
	                    var seriesIndex_1 = -1;
	                    while (columnNode) {
	                        if (columnNode.children && columnNode.children[0].children) {
	                            for (var j = 0, jlen = columnNode.children.length; j < jlen; j++) {
	                                // each of these is a "series"
	                                nodeQueue.push(columnNode.children[j]);
	                            }
	                        }
	                        else if (columnNode.children && playFrameNode.children) {
	                            // Processing a single series under here, push all the value sources for every series.
	                            var columnLength = columnNode.children.length;
	                            for (var j = 0; j < columnLength; j++) {
	                                var source = _.create(matrix.valueSources[j], { groupName: columnNode.value });
	                                var dataViewColumn = {
	                                    identity: columnNode.identity,
	                                    values: [],
	                                    source: source,
	                                };
	                                categorical.values.push(dataViewColumn);
	                            }
	                            // Copying the values from matrix intersection to the categorical values columns...
	                            DataViewMatrixUtils.forEachLeafNode(playFrameNode.children, function (leafNode) {
	                                for (var j = 0; j < columnLength; j++) {
	                                    categorical.values[seriesIndex_1 * columnLength + j].values.push(leafNode.values[seriesIndex_1 * columnLength + j].value);
	                                }
	                            });
	                        }
	                        if (nodeQueue.length > 0) {
	                            columnNode = nodeQueue[0];
	                            nodeQueue = nodeQueue.splice(1);
	                            seriesIndex_1++;
	                        }
	                        else
	                            columnNode = undefined;
	                    }
	                }
	                else if (hasPlayAndCategory) {
	                    // no series, just play and category
	                    var playFrameNode = matrix.rows.root.children[frame];
	                    var measureLength_1 = matrix.valueSources.length;
	                    for (var j = 0; j < measureLength_1; j++) {
	                        var dataViewColumn = {
	                            identity: undefined,
	                            values: [],
	                            source: matrix.valueSources[j]
	                        };
	                        categorical.values.push(dataViewColumn);
	                    }
	                    DataViewMatrixUtils.forEachLeafNode(playFrameNode.children, function (categoryGroupLeafNode, index, categoryHierarchicalGroupNodes) {
	                        addMatrixHierarchicalGroupToCategories(categoryHierarchicalGroupNodes, categories);
	                        // Copying the values from matrix intersection to the categorical values columns...
	                        for (var j = 0; j < measureLength_1; j++) {
	                            categorical.values[j].values.push(categoryGroupLeafNode.values[j].value);
	                        }
	                    });
	                    categorical.categories = categories;
	                }
	                // the visual code today expects only 1 category column, hence apply DataViewConcatenateCategoricalColumns
	                return DataViewConcatenateCategoricalColumns.applyToPlayChartCategorical(sourceDataView.metadata, visuals.scatterChartCapabilities.objects, 'Category', categorical);
	            }
	            PlayChart.convertMatrixToCategorical = convertMatrixToCategorical;
	            function addMatrixHierarchicalGroupToCategories(sourceCategoryHierarchicalGroupNodes, destinationCategories) {
	                debug.assertNonEmpty(sourceCategoryHierarchicalGroupNodes, 'sourceCategoryHierarchicalGroupNodes');
	                debug.assertNonEmpty(destinationCategories, 'destinationCategories');
	                debug.assert(sourceCategoryHierarchicalGroupNodes.length === destinationCategories.length, 'pre-condition: there should be one category column per matrix row level for Category.');
	                // Note: Before the Categorical concatenation logic got added to this playChart logic, the code did NOT populate
	                // the ***DataViewCategoryColumn.identityFields*** property, and the playChart visual code does not seem to need it.
	                // If we do want to populate that property, we might want to do reuse data.ISQExpr[] across nodes as much as possible 
	                // because all the child nodes under a given parent will have the exact same identityFields value, and a lot of 
	                // DataViewCategory objects can get created for a given playChart.
	                var identity = sourceCategoryHierarchicalGroupNodes[0].identity;
	                if (sourceCategoryHierarchicalGroupNodes.length > 1) {
	                    // if the hierarchical group has more than 1 level, create a composite identity from the nodes
	                    var identityExpr = identity.expr;
	                    for (var i = 1, ilen = sourceCategoryHierarchicalGroupNodes.length; i < ilen; i++) {
	                        var identityExprToAdd = sourceCategoryHierarchicalGroupNodes[i].identity.expr;
	                        identityExpr = SQExprBuilder.and(identityExpr, identityExprToAdd);
	                    }
	                    identity = createDataViewScopeIdentity(identityExpr);
	                }
	                // add the Category value of each matrix node into its respective category column
	                for (var j = 0, jlen = destinationCategories.length; j < jlen; j++) {
	                    destinationCategories[j].identity.push(identity);
	                    var node = sourceCategoryHierarchicalGroupNodes[j];
	                    destinationCategories[j].values.push(node.value);
	                }
	            }
	            function getObjectProperties(dataViewMetadata, dataLabelsSettings) {
	                var objectProperties = {};
	                if (dataViewMetadata && dataViewMetadata.objects) {
	                    var objects = dataViewMetadata.objects;
	                    // TODO: remove?
	                    objectProperties.currentFrameIndex = powerbi.DataViewObjects.getValue(objects, visuals.scatterChartProps.currentFrameIndex.index, null);
	                }
	                return objectProperties;
	            }
	            function converter(dataView, visualConverter) {
	                var dataViewMetadata = dataView.metadata;
	                var dataLabelsSettings = visuals.dataLabelUtils.getDefaultPointLabelSettings();
	                var objectProperties = getObjectProperties(dataViewMetadata, dataLabelsSettings);
	                var allViewModels = [];
	                var frameKeys = [];
	                var convertedData = undefined;
	                var matrixRows = dataView.matrix.rows;
	                var rowChildrenLength = matrixRows.root.children ? matrixRows.root.children.length : 0;
	                var keySourceColumn;
	                if (dataView.matrix && rowChildrenLength > 0 && !_.isEmpty(matrixRows.levels) && !_.isEmpty(matrixRows.levels[0].sources)) {
	                    keySourceColumn = matrixRows.levels[0].sources[0];
	                    // TODO: this should probably defer to the visual which knows how to format the categories.
	                    var formatString = visuals.valueFormatter.getFormatString(keySourceColumn, visuals.scatterChartProps.general.formatString);
	                    var keyFormatter = void 0;
	                    if (keySourceColumn.type.numeric) {
	                        // use value range, not actual values
	                        var valueRange = Math.abs(matrixRows.root.children[rowChildrenLength - 1].value - matrixRows.root.children[0].value);
	                        keyFormatter = visuals.valueFormatter.create({
	                            format: formatString,
	                            value: valueRange,
	                            value2: 0,
	                        });
	                    }
	                    else {
	                        keyFormatter = visuals.valueFormatter.createDefaultFormatter(formatString, true);
	                    }
	                    for (var i = 0, len = rowChildrenLength; i < len; i++) {
	                        var key = matrixRows.root.children[i];
	                        var frameLabelText = keyFormatter.format(key.value);
	                        // escaped html
	                        var frameLabelHtml = $("<div/>").text(frameLabelText).html();
	                        frameKeys.push({ escapedText: frameLabelHtml, text: frameLabelText });
	                        var dataViewCategorical = convertMatrixToCategorical(dataView, i);
	                        var frameInfo = { label: frameLabelHtml, column: keySourceColumn };
	                        convertedData = visualConverter(dataViewCategorical, frameInfo);
	                        allViewModels.push(convertedData);
	                    }
	                }
	                else {
	                    var dataViewCategorical = convertMatrixToCategorical(dataView, 0);
	                    convertedData = visualConverter(dataViewCategorical);
	                    allViewModels.push(convertedData);
	                }
	                // NOTE: currentViewModel is already set to the last frame
	                objectProperties.currentFrameIndex = frameKeys.length - 1;
	                return {
	                    allViewModels: allViewModels,
	                    currentViewModel: convertedData,
	                    frameData: frameKeys,
	                    currentFrameIndex: objectProperties.currentFrameIndex,
	                    labelData: getLabelData(frameKeys, keySourceColumn),
	                };
	            }
	            PlayChart.converter = converter;
	            function getDefaultPlayData() {
	                var defaultData = {
	                    frameData: [],
	                    allViewModels: [],
	                    currentFrameIndex: 0,
	                    currentViewModel: undefined,
	                    labelData: {
	                        anyWordBreaks: false,
	                        labelInfo: [],
	                    },
	                };
	                return defaultData;
	            }
	            PlayChart.getDefaultPlayData = getDefaultPlayData;
	            function getMinMaxForAllFrames(playData, getExtents) {
	                var extents = {
	                    minY: 0,
	                    maxY: 10,
	                    minX: 0,
	                    maxX: 10,
	                };
	                if (playData.allViewModels && playData.allViewModels.length > 0) {
	                    extents.minY = extents.minX = Number.MAX_VALUE;
	                    extents.maxY = extents.maxX = Number.MIN_VALUE;
	                    for (var i = 0, len = playData.allViewModels.length; i < len; i++) {
	                        var data_3 = playData.allViewModels[i];
	                        var e = getExtents(data_3);
	                        // NOTE: D3.min/max handle undefined and NaN nicely, as opposed to Math.min/max
	                        extents = {
	                            minY: d3.min([e.minY, extents.minY]),
	                            maxY: d3.max([e.maxY, extents.maxY]),
	                            minX: d3.min([e.minX, extents.minX]),
	                            maxX: d3.max([e.maxX, extents.maxX]),
	                        };
	                    }
	                }
	                return extents;
	            }
	            PlayChart.getMinMaxForAllFrames = getMinMaxForAllFrames;
	            function getLabelData(keys, keyColumn) {
	                var textProperties = {
	                    fontFamily: visuals.Font.Family.regular.css,
	                    fontSize: jsCommon.PixelConverter.toString(14),
	                };
	                var labelInfo = [];
	                var anyWordBreaks = false;
	                for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
	                    var key = keys_1[_i];
	                    var labelWidth = jsCommon.WordBreaker.getMaxWordWidth(key.escapedText, powerbi.TextMeasurementService.measureSvgTextWidth, textProperties);
	                    // TODO: Why isn't this last part included in hasBreakers()?
	                    anyWordBreaks = anyWordBreaks || jsCommon.WordBreaker.hasBreakers(key.escapedText) || (key.escapedText).indexOf('-') > -1;
	                    labelInfo.push({ label: key.escapedText, labelWidth: labelWidth });
	                }
	                return {
	                    labelInfo: labelInfo,
	                    anyWordBreaks: anyWordBreaks,
	                    labelFieldName: keyColumn && keyColumn.displayName,
	                };
	            }
	            function isDataViewPlayable(dataView, playRole) {
	                if (playRole === void 0) { playRole = 'Play'; }
	                debug.assertValue(dataView, 'dataView');
	                var firstRowSourceRoles = dataView.matrix &&
	                    dataView.matrix.rows &&
	                    dataView.matrix.rows.levels &&
	                    dataView.matrix.rows.levels[0] &&
	                    dataView.matrix.rows.levels[0].sources &&
	                    dataView.matrix.rows.levels[0].sources[0] &&
	                    dataView.matrix.rows.levels[0].sources[0].roles;
	                return firstRowSourceRoles && firstRowSourceRoles[playRole];
	            }
	            PlayChart.isDataViewPlayable = isDataViewPlayable;
	            /** Render trace-lines for selected data points. */
	            function renderTraceLines(allDataPoints, traceLineRenderer, shouldAnimate) {
	                var selectedDataPoints = _.filter(allDataPoints, function (d) { return d.selected; });
	                selectedDataPoints = _.uniq(selectedDataPoints, function (d) { return d.identity.getKey(); });
	                traceLineRenderer.render(selectedDataPoints, shouldAnimate);
	            }
	            PlayChart.renderTraceLines = renderTraceLines;
	        })(PlayChart = visuals.PlayChart || (visuals.PlayChart = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 272 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var PixelConverter = jsCommon.PixelConverter;
	        var VerticalSlicerRenderer = (function () {
	            function VerticalSlicerRenderer(options) {
	                this.textProperties = {
	                    'fontFamily': visuals.Font.Family.regular.css,
	                    'fontSize': '14px',
	                };
	                if (options) {
	                    this.behavior = options.behavior;
	                }
	                this.domHelper = options.domHelper;
	            }
	            // SlicerValueHandler
	            VerticalSlicerRenderer.prototype.getDefaultValue = function () {
	                if (this.data && this.data.defaultValue)
	                    return this.data.defaultValue.value;
	            };
	            VerticalSlicerRenderer.prototype.getIdentityFields = function () {
	                return visuals.SlicerUtil.DefaultValueHandler.getIdentityFields(this.dataView);
	            };
	            VerticalSlicerRenderer.prototype.getUpdatedSelfFilter = function (searchKey) {
	                var metadata = this.dataView && this.dataView.metadata;
	                if (this.data.searchKey === searchKey)
	                    return;
	                return visuals.SlicerUtil.getUpdatedSelfFilter(searchKey, metadata);
	            };
	            VerticalSlicerRenderer.prototype.init = function (slicerInitOptions) {
	                var _this = this;
	                this.element = slicerInitOptions.visualInitOptions.element;
	                this.currentViewport = slicerInitOptions.visualInitOptions.viewport;
	                var hostServices = this.hostServices = slicerInitOptions.visualInitOptions.host;
	                var settings = this.settings = visuals.Slicer.DefaultStyleProperties();
	                var domHelper = this.domHelper;
	                var bodyViewport = domHelper.getSlicerBodyViewport(this.currentViewport, settings, this.textProperties);
	                var interactivityService;
	                if (this.behavior)
	                    interactivityService = visuals.createInteractivityService(hostServices);
	                var containerDiv = document.createElement('div');
	                containerDiv.className = Selectors.Container.class;
	                var container = this.container = d3.select(containerDiv);
	                var header = domHelper.createSlicerHeader(hostServices);
	                containerDiv.appendChild(header);
	                this.header = d3.select(header);
	                this.body = container.append('div').classed(visuals.SlicerUtil.Selectors.Body.class, true)
	                    .style({
	                    'height': PixelConverter.toString(bodyViewport.height),
	                    'width': PixelConverter.toString(bodyViewport.width),
	                });
	                var rowEnter = function (rowSelection) {
	                    _this.onEnterSelection(rowSelection);
	                };
	                var rowUpdate = function (rowSelection) {
	                    _this.onUpdateSelection(rowSelection, interactivityService);
	                };
	                var rowExit = function (rowSelection) {
	                    rowSelection.remove();
	                };
	                var listViewOptions = {
	                    rowHeight: domHelper.getRowHeight(settings, this.textProperties),
	                    enter: rowEnter,
	                    exit: rowExit,
	                    update: rowUpdate,
	                    loadMoreData: function () { return slicerInitOptions.loadMoreData(); },
	                    scrollEnabled: true,
	                    viewport: domHelper.getSlicerBodyViewport(this.currentViewport, settings, this.textProperties),
	                    baseContainer: this.body,
	                    isReadMode: function () {
	                        return (_this.hostServices.getViewMode() !== 1 /* Edit */);
	                    }
	                };
	                this.listView = visuals.ListViewFactory.createListView(listViewOptions);
	                // Append container to DOM
	                this.element.get(0).appendChild(containerDiv);
	                return interactivityService;
	            };
	            VerticalSlicerRenderer.prototype.render = function (options) {
	                var data = this.data = options.data;
	                this.currentViewport = options.viewport;
	                var dataView = options.dataView;
	                if (!dataView || !data) {
	                    this.listView.empty();
	                    return;
	                }
	                this.dataView = dataView;
	                var settings = this.settings = data.slicerSettings;
	                var domHelper = this.domHelper;
	                domHelper.updateSlicerBodyDimensions(this.currentViewport, this.body, settings);
	                this.updateSelectionStyle();
	                this.listView
	                    .viewport(domHelper.getSlicerBodyViewport(this.currentViewport, settings, this.textProperties))
	                    .rowHeight(domHelper.getRowHeight(settings, this.textProperties))
	                    .data(data.slicerDataPoints, function (d) { return $.inArray(d, data.slicerDataPoints); }, options.resetScrollbarPosition);
	            };
	            VerticalSlicerRenderer.prototype.updateSelectionStyle = function () {
	                var settings = this.settings;
	                this.container.classed('isMultiSelectEnabled', settings && settings.selection && !settings.selection.singleSelect);
	            };
	            VerticalSlicerRenderer.prototype.onEnterSelection = function (rowSelection) {
	                var settings = this.settings;
	                var listItemElement = rowSelection.append('ul')
	                    .append('li')
	                    .classed(Selectors.ItemContainer.class, true);
	                var labelElement = listItemElement.append('div')
	                    .classed(Selectors.Input.class, true);
	                labelElement.append('input')
	                    .attr('type', 'checkbox');
	                labelElement.append('span')
	                    .classed(Selectors.Checkbox.class, true);
	                listItemElement.each(function (d, i) {
	                    var item = d3.select(this);
	                    if (d.isImage) {
	                        item.append('img')
	                            .classed(visuals.SlicerUtil.Selectors.LabelImage.class, true);
	                    }
	                    else {
	                        item.append('span')
	                            .classed(visuals.SlicerUtil.Selectors.LabelText.class, true);
	                    }
	                    if (d.count != null) {
	                        item.append('span')
	                            .classed(visuals.SlicerUtil.Selectors.CountText.class, true)
	                            .style('font-size', PixelConverter.fromPoint(settings.slicerText.textSize));
	                    }
	                });
	            };
	            VerticalSlicerRenderer.prototype.onUpdateSelection = function (rowSelection, interactivityService) {
	                var settings = this.settings;
	                var data = this.data;
	                if (data && settings) {
	                    // Style Slicer Header
	                    var domHelper = this.domHelper;
	                    domHelper.styleSlicerHeader(this.header, settings, data.categorySourceName);
	                    var headerText = this.header.select(visuals.SlicerUtil.Selectors.TitleHeader.selector);
	                    headerText.attr('title', data.categorySourceName);
	                    var labelText = rowSelection.selectAll(visuals.SlicerUtil.Selectors.LabelText.selector);
	                    labelText.text(function (d) {
	                        return d.value;
	                    }).attr('title', function (d) {
	                        return d.tooltip;
	                    });
	                    domHelper.setSlicerTextStyle(labelText, settings);
	                    var labelImage = rowSelection.selectAll(visuals.SlicerUtil.Selectors.LabelImage.selector);
	                    if (!labelImage.empty()) {
	                        labelImage.attr('src', function (d) {
	                            return d.value;
	                        });
	                    }
	                    var countText = rowSelection.selectAll(visuals.SlicerUtil.Selectors.CountText.selector);
	                    if (!countText.empty()) {
	                        countText.text(function (d) { return d.count; });
	                        domHelper.setSlicerTextStyle(countText, settings);
	                    }
	                    if (interactivityService && this.body) {
	                        var body = this.body.attr('width', this.currentViewport.width);
	                        var slicerItemContainers = body.selectAll(Selectors.ItemContainer.selector);
	                        var slicerItemLabels = body.selectAll(visuals.SlicerUtil.Selectors.LabelText.selector);
	                        var slicerItemInputs = body.selectAll(Selectors.Input.selector);
	                        var slicerClear = this.header.select(visuals.SlicerUtil.Selectors.Clear.selector);
	                        var searchInput = this.header.select('input');
	                        if (!searchInput.empty()) {
	                            var element = searchInput.node();
	                            var exisingSearchKey = element && element.value;
	                            // When the existingSearchKey is empty, try set it using the searchKey from data.
	                            // This is to ensure the search key is diplayed in the input box when the input box was first rendered.
	                            // If the search key was reset from exploreUI when search is turned off, then the data.searchkey will be ''
	                            // The input box value need to be reset to ''.
	                            if (_.isEmpty(exisingSearchKey) || _.isEmpty(data.searchKey))
	                                searchInput
	                                    .property('value', data.searchKey);
	                        }
	                        var behaviorOptions = {
	                            dataPoints: data.slicerDataPoints,
	                            slicerContainer: this.container,
	                            itemContainers: slicerItemContainers,
	                            itemLabels: slicerItemLabels,
	                            itemInputs: slicerItemInputs,
	                            clear: slicerClear,
	                            interactivityService: interactivityService,
	                            settings: data.slicerSettings,
	                            searchInput: searchInput,
	                            slicerValueHandler: this,
	                        };
	                        var orientationBehaviorOptions = {
	                            behaviorOptions: behaviorOptions,
	                            orientation: 0 /* Vertical */,
	                        };
	                        interactivityService.bind(data.slicerDataPoints, this.behavior, orientationBehaviorOptions, { overrideSelectionFromData: true, hasSelectionOverride: data.hasSelectionOverride, slicerValueHandler: this });
	                        visuals.SlicerWebBehavior.styleSlicerItems(rowSelection.select(Selectors.Input.selector), data.hasSelectionOverride, interactivityService.isSelectionModeInverted());
	                    }
	                    else {
	                        visuals.SlicerWebBehavior.styleSlicerItems(rowSelection.select(Selectors.Input.selector), false, false);
	                    }
	                }
	            };
	            return VerticalSlicerRenderer;
	        }());
	        visuals.VerticalSlicerRenderer = VerticalSlicerRenderer;
	        var Selectors;
	        (function (Selectors) {
	            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
	            Selectors.Container = createClassAndSelector('slicerContainer');
	            Selectors.ItemContainer = createClassAndSelector('slicerItemContainer');
	            Selectors.Input = createClassAndSelector('slicerCheckbox');
	            Selectors.Checkbox = createClassAndSelector('checkbox');
	        })(Selectors || (Selectors = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 273 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var PixelConverter = jsCommon.PixelConverter;
	        var ItemWidthSampleSize = 50;
	        var MinTextWidth = 80;
	        var LoadMoreDataThreshold = 0.8; // The value indicates the percentage of data already shown that triggers a loadMoreData call.
	        var DefaultStyleProperties = {
	            labelText: {
	                marginRight: 2,
	                paddingLeft: 8,
	                paddingRight: 8,
	            },
	        };
	        var HorizontalSlicerRenderer = (function () {
	            function HorizontalSlicerRenderer(options) {
	                this.textProperties = {
	                    fontFamily: visuals.Font.Family.regular.css,
	                    fontSize: '14px'
	                };
	                if (options) {
	                    this.behavior = options.behavior;
	                }
	                this.domHelper = options.domHelper;
	                this.dataStartIndex = 0;
	            }
	            // SlicerValueHandler
	            HorizontalSlicerRenderer.prototype.getDefaultValue = function () {
	                if (this.data && this.data.defaultValue)
	                    return this.data.defaultValue.value;
	            };
	            HorizontalSlicerRenderer.prototype.getIdentityFields = function () {
	                return visuals.SlicerUtil.DefaultValueHandler.getIdentityFields(this.dataView);
	            };
	            HorizontalSlicerRenderer.prototype.getUpdatedSelfFilter = function (searchKey) {
	                var metadata = this.dataView && this.dataView.metadata;
	                if (this.data.searchKey === searchKey)
	                    return;
	                return visuals.SlicerUtil.getUpdatedSelfFilter(searchKey, metadata);
	            };
	            HorizontalSlicerRenderer.prototype.init = function (slicerInitOptions) {
	                this.element = slicerInitOptions.visualInitOptions.element;
	                this.currentViewport = slicerInitOptions.visualInitOptions.viewport;
	                var hostServices = this.hostServices = slicerInitOptions.visualInitOptions.host;
	                if (this.behavior) {
	                    this.interactivityService = visuals.createInteractivityService(hostServices);
	                }
	                this.loadMoreData = function () { return slicerInitOptions.loadMoreData(); };
	                var containerDiv = document.createElement('div');
	                containerDiv.className = Selectors.container.class;
	                var container = this.container = d3.select(containerDiv);
	                var header = this.domHelper.createSlicerHeader(this.hostServices);
	                containerDiv.appendChild(header);
	                this.header = d3.select(header);
	                var body = this.body = container.append('div').classed(visuals.SlicerUtil.Selectors.Body.class + " " + Selectors.FlexDisplay.class, true);
	                this.leftNavigationArrow = body.append("button")
	                    .classed(Selectors.NavigationArrow.class + " " + Selectors.LeftNavigationArrow.class, true);
	                this.itemsContainer = body.append("div")
	                    .classed(Selectors.ItemsContainer.class + " " + Selectors.FlexDisplay.class, true);
	                this.rightNavigationArrow = body.append("button")
	                    .classed(Selectors.NavigationArrow.class + " " + Selectors.RightNavigationArrow.class, true);
	                // Append container to DOM
	                this.element.get(0).appendChild(containerDiv);
	                this.bindNavigationEvents();
	                return this.interactivityService;
	            };
	            HorizontalSlicerRenderer.prototype.render = function (options) {
	                var data = options.data;
	                var dataView = options.dataView;
	                if (!dataView || !data) {
	                    this.itemsContainer.selectAll("*").remove();
	                    return;
	                }
	                this.data = data;
	                this.dataView = dataView;
	                var resized = this.currentViewport && options.viewport
	                    && (this.currentViewport.height !== options.viewport.height || this.currentViewport.width !== options.viewport.width);
	                if (!(this.isMaxWidthCalculated() && resized)) {
	                    // Max width calculation is not required during resize, but required on data changes like changes to formatting properties fontSize, outline, outline weight, etc...
	                    // So calculating only on data updates
	                    this.calculateAndSetMaxItemWidth();
	                    this.calculateAndSetTotalItemWidth();
	                }
	                this.currentViewport = options.viewport;
	                this.updateStyle();
	                var availableWidthForItemsContainer = this.element.find(Selectors.ItemsContainer.selector).width();
	                this.itemsToDisplay = this.getNumberOfItemsToDisplay(availableWidthForItemsContainer);
	                if (this.itemsToDisplay === 0)
	                    return;
	                this.renderCore();
	            };
	            HorizontalSlicerRenderer.prototype.renderCore = function () {
	                var data = this.data;
	                if (!data || !data.slicerDataPoints)
	                    return;
	                this.normalizePosition(data.slicerDataPoints);
	                var itemsToDisplay = this.itemsToDisplay;
	                var dataStartIndex = this.dataStartIndex;
	                // Update Navigation Arrows
	                this.container.classed(Selectors.CanScrollRight.class, dataStartIndex + this.itemsToDisplay <= data.slicerDataPoints.length - 1);
	                this.container.classed(Selectors.CanScrollLeft.class, dataStartIndex > 0);
	                // Manipulate DOM
	                this.renderItems(data.slicerSettings);
	                // Bind Interactivity Service
	                this.bindInteractivityService();
	                // Load More Data
	                if (dataStartIndex + itemsToDisplay >= data.slicerDataPoints.length * LoadMoreDataThreshold) {
	                    this.loadMoreData();
	                }
	            };
	            HorizontalSlicerRenderer.prototype.updateStyle = function () {
	                var viewport = this.currentViewport;
	                var data = this.data;
	                var defaultSettings = data.slicerSettings;
	                var domHelper = this.domHelper;
	                this.container
	                    .classed(Selectors.MultiSelectEnabled.class, !defaultSettings.selection.singleSelect)
	                    .style({
	                    "width": PixelConverter.toString(viewport.width),
	                    "height": PixelConverter.toString(viewport.height),
	                });
	                // Style Slicer Header
	                domHelper.styleSlicerHeader(this.header, defaultSettings, data.categorySourceName);
	                var headerTextProperties = domHelper.getHeaderTextProperties(defaultSettings);
	                this.header.attr('title', data.categorySourceName);
	                // Update body width and height
	                var bodyViewport = this.bodyViewport = domHelper.getSlicerBodyViewport(viewport, defaultSettings, headerTextProperties);
	                this.body.style({
	                    "height": PixelConverter.toString(bodyViewport.height),
	                    "width": PixelConverter.toString(bodyViewport.width),
	                });
	            };
	            HorizontalSlicerRenderer.prototype.renderItems = function (defaultSettings) {
	                var _this = this;
	                var itemsToDisplay = this.itemsToDisplay;
	                debug.assert(itemsToDisplay > 0, 'items to display should be greater than zero');
	                var dataStartIndex = this.dataStartIndex;
	                var materializedDataPoints = this.data.slicerDataPoints.slice(dataStartIndex, dataStartIndex + itemsToDisplay);
	                var items = this.itemsContainer
	                    .selectAll(visuals.SlicerUtil.Selectors.LabelText.selector)
	                    .data(materializedDataPoints, function (d) { return _.indexOf(_this.data.slicerDataPoints, d); });
	                items
	                    .enter()
	                    .append("div")
	                    .classed(visuals.SlicerUtil.Selectors.LabelText.class + " " + Selectors.FlexDisplay.class, true);
	                items.order();
	                items
	                    .style({
	                    "font-family": this.textProperties.fontFamily,
	                    "padding-left": PixelConverter.toString(DefaultStyleProperties.labelText.paddingLeft),
	                    "padding-right": PixelConverter.toString(DefaultStyleProperties.labelText.paddingRight),
	                    "margin-right": function (d, i) { return _this.isLastRowItem(i, itemsToDisplay) ? "0px" : PixelConverter.toString(DefaultStyleProperties.labelText.marginRight); },
	                });
	                // Default style settings from formatting pane settings
	                this.domHelper.setSlicerTextStyle(items, defaultSettings);
	                items.exit().remove();
	                window.setTimeout(function () {
	                    items
	                        .attr("title", function (d) { return d.tooltip; })
	                        .text(function (d) { return d.value; });
	                    // Wrap long text into multiple columns based on height availbale
	                    var labels = _this.element.find(visuals.SlicerUtil.Selectors.LabelText.selector);
	                    var item = labels.first();
	                    var itemWidth = item.width();
	                    var itemHeight = item.height();
	                    labels.each(function (i, element) {
	                        powerbi.TextMeasurementService.wordBreakOverflowingText(element, itemWidth, itemHeight);
	                    });
	                });
	            };
	            HorizontalSlicerRenderer.prototype.bindInteractivityService = function () {
	                if (this.interactivityService && this.body) {
	                    var body = this.body;
	                    var itemsContainer = body.selectAll(Selectors.ItemsContainer.selector);
	                    var itemLabels = body.selectAll(visuals.SlicerUtil.Selectors.LabelText.selector);
	                    var clear = this.header.select(visuals.SlicerUtil.Selectors.Clear.selector);
	                    var data_1 = this.data;
	                    var searchInput = this.header.select('input');
	                    if (!searchInput.empty()) {
	                        var element = searchInput.node();
	                        var existingSearchKey = element.value;
	                        // When the existingSearchKey is empty, try set it using the searchKey from data.
	                        // This is to ensure the search key is diplayed in the input box when the input box was first rendered.
	                        // If the search key was reset from exploreUI when search is turned off, then the data.searchkey will be ''
	                        // The input box value need to be reset to ''.
	                        if (_.isEmpty(existingSearchKey) || _.isEmpty(data_1.searchKey))
	                            searchInput
	                                .property('value', data_1.searchKey);
	                    }
	                    var behaviorOptions = {
	                        dataPoints: data_1.slicerDataPoints,
	                        slicerContainer: this.container,
	                        itemsContainer: itemsContainer,
	                        itemLabels: itemLabels,
	                        clear: clear,
	                        interactivityService: this.interactivityService,
	                        settings: data_1.slicerSettings,
	                        slicerValueHandler: this,
	                        searchInput: searchInput,
	                    };
	                    var orientationBehaviorOptions = {
	                        behaviorOptions: behaviorOptions,
	                        orientation: 1 /* Horizontal */,
	                    };
	                    this.interactivityService.bind(data_1.slicerDataPoints, this.behavior, orientationBehaviorOptions, { overrideSelectionFromData: true, hasSelectionOverride: data_1.hasSelectionOverride });
	                    visuals.SlicerWebBehavior.styleSlicerItems(this.itemsContainer.selectAll(visuals.SlicerUtil.Selectors.LabelText.selector), this.interactivityService.hasSelection(), this.interactivityService.isSelectionModeInverted());
	                }
	                else {
	                    visuals.SlicerWebBehavior.styleSlicerItems(this.itemsContainer.selectAll(visuals.SlicerUtil.Selectors.LabelText.selector), false, false);
	                }
	            };
	            HorizontalSlicerRenderer.prototype.normalizePosition = function (points) {
	                var dataStartIndex = this.dataStartIndex;
	                // if dataStartIndex >= points.length
	                dataStartIndex = Math.min(dataStartIndex, points.length - 1);
	                // if dataStartIndex < 0 
	                this.dataStartIndex = Math.max(dataStartIndex, 0);
	            };
	            HorizontalSlicerRenderer.prototype.bindNavigationEvents = function () {
	                this.registerMouseWheelScrollEvents();
	                this.registerMouseClickEvents();
	            };
	            HorizontalSlicerRenderer.prototype.registerMouseClickEvents = function () {
	                var _this = this;
	                var rightNavigationArrow = this.container.selectAll(Selectors.RightNavigationArrow.selector);
	                var leftNavigationArrow = this.container.selectAll(Selectors.LeftNavigationArrow.selector);
	                rightNavigationArrow
	                    .on("click", function () {
	                    _this.scrollRight();
	                });
	                leftNavigationArrow
	                    .on("click", function () {
	                    _this.scrollLeft();
	                });
	            };
	            // Register for mouse wheel scroll events
	            HorizontalSlicerRenderer.prototype.registerMouseWheelScrollEvents = function () {
	                var _this = this;
	                var scrollableElement = this.body.node();
	                scrollableElement.addEventListener("mousewheel", function (e) {
	                    _this.onMouseWheel(e.wheelDelta);
	                });
	                scrollableElement.addEventListener("DOMMouseScroll", function (e) {
	                    _this.onMouseWheel(e.detail);
	                });
	            };
	            HorizontalSlicerRenderer.prototype.onMouseWheel = function (wheelDelta) {
	                if (wheelDelta < 0) {
	                    this.scrollRight();
	                }
	                else if (wheelDelta > 0) {
	                    this.scrollLeft();
	                }
	            };
	            /* If there is only one item being displayed, we show the next item when navigation arrows are clicked
	            * But when there are more than 1 item, n-1 items are shown say we have 10 items in total , in initial page if we show 1 to 5 items when right button is clicked we will show items from 5 to 10
	            */
	            HorizontalSlicerRenderer.prototype.scrollRight = function () {
	                var itemsToDisplay = this.itemsToDisplay;
	                var startIndex = this.dataStartIndex;
	                var dataPointsLength = this.data.slicerDataPoints.length;
	                var lastItemIndex = dataPointsLength - 1;
	                // If it is the last page stay on the same page and don't navigate
	                if (itemsToDisplay + startIndex > lastItemIndex) {
	                    return;
	                }
	                if (itemsToDisplay === 1) {
	                    startIndex += itemsToDisplay;
	                }
	                else {
	                    startIndex += itemsToDisplay - 1;
	                }
	                // Adjust the startIndex to show last n items if startIndex + itemsToDisplay is greater than total datapoints
	                if (itemsToDisplay + startIndex > lastItemIndex) {
	                    startIndex = lastItemIndex - itemsToDisplay + 1;
	                }
	                this.dataStartIndex = startIndex;
	                this.renderCore();
	            };
	            /* If there is only one item being displayed, we show the next item when navigation arrows are clicked
	            * But when there are more than 1 item, n-1 items are shown
	            */
	            HorizontalSlicerRenderer.prototype.scrollLeft = function () {
	                var itemsToDisplay = this.itemsToDisplay;
	                var startIndex = this.dataStartIndex;
	                var firstItemIndex = 0;
	                // If it is the first page stay on the same page and don't navigate
	                if (startIndex === 0) {
	                    return;
	                }
	                // If there is only item shown when left navigation button is clicked we want to navigate back to show previous item
	                if (itemsToDisplay === 1) {
	                    startIndex -= itemsToDisplay;
	                }
	                if (startIndex - itemsToDisplay < firstItemIndex) {
	                    startIndex = firstItemIndex;
	                }
	                else {
	                    startIndex = startIndex - itemsToDisplay + 1;
	                }
	                this.dataStartIndex = startIndex;
	                this.renderCore();
	            };
	            HorizontalSlicerRenderer.prototype.isLastRowItem = function (fieldIndex, columnsToDisplay) {
	                return fieldIndex === columnsToDisplay - 1;
	            };
	            HorizontalSlicerRenderer.prototype.getScaledTextWidth = function (textSize) {
	                return (textSize / jsCommon.TextSizeDefaults.TextSizeMin) * MinTextWidth;
	            };
	            HorizontalSlicerRenderer.prototype.isMaxWidthCalculated = function () {
	                return this.maxItemWidth !== undefined;
	            };
	            // Sampling a subset of total datapoints to calculate max item width
	            HorizontalSlicerRenderer.prototype.calculateAndSetMaxItemWidth = function () {
	                var dataPointsLength = this.getDataPointsCount();
	                var maxItemWidth = 0;
	                if (dataPointsLength === 0) {
	                    this.maxItemWidth = maxItemWidth;
	                    return;
	                }
	                var data = this.data;
	                var dataPoints = data.slicerDataPoints;
	                var sampleSize = Math.min(dataPointsLength, ItemWidthSampleSize);
	                var properties = jQuery.extend(true, {}, this.textProperties);
	                var textSize = data.slicerSettings.slicerText.textSize;
	                // Update text properties from formatting pane values
	                properties.fontSize = PixelConverter.fromPoint(textSize);
	                var getMaxWordWidth = jsCommon.WordBreaker.getMaxWordWidth;
	                for (var i = 0; i < sampleSize; i++) {
	                    var itemText = dataPoints[i].value;
	                    properties.text = itemText;
	                    maxItemWidth = Math.max(maxItemWidth, getMaxWordWidth(itemText, powerbi.TextMeasurementService.measureSvgTextWidth, properties));
	                }
	                this.maxItemWidth = Math.min(maxItemWidth, this.getScaledTextWidth(textSize));
	            };
	            HorizontalSlicerRenderer.prototype.calculateAndSetTotalItemWidth = function () {
	                var data = this.data;
	                var itemPadding = DefaultStyleProperties.labelText.paddingLeft + DefaultStyleProperties.labelText.paddingRight + DefaultStyleProperties.labelText.marginRight;
	                var borderWidth = this.domHelper.getRowsOutlineWidth(data.slicerSettings.slicerText.outline, data.slicerSettings.general.outlineWeight);
	                this.totalItemWidth = this.maxItemWidth + itemPadding + borderWidth;
	            };
	            HorizontalSlicerRenderer.prototype.getNumberOfItemsToDisplay = function (widthAvailable) {
	                var totalItemWidth = this.totalItemWidth;
	                if (totalItemWidth === 0)
	                    return 0;
	                var dataPointsLength = this.getDataPointsCount();
	                var numberOfItems = Math.min(dataPointsLength, Math.round(widthAvailable / totalItemWidth));
	                // Show atleast 1 item by default 
	                return Math.max(numberOfItems, 1);
	            };
	            HorizontalSlicerRenderer.prototype.getDataPointsCount = function () {
	                return _.size(this.data.slicerDataPoints);
	            };
	            return HorizontalSlicerRenderer;
	        }());
	        visuals.HorizontalSlicerRenderer = HorizontalSlicerRenderer;
	        var Selectors;
	        (function (Selectors) {
	            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
	            Selectors.container = createClassAndSelector('horizontalSlicerContainer');
	            Selectors.ItemsContainer = createClassAndSelector('slicerItemsContainer');
	            Selectors.NavigationArrow = createClassAndSelector('navigationArrow');
	            Selectors.LeftNavigationArrow = createClassAndSelector('left');
	            Selectors.RightNavigationArrow = createClassAndSelector('right');
	            Selectors.MultiSelectEnabled = createClassAndSelector('isMultiSelectEnabled');
	            Selectors.FlexDisplay = createClassAndSelector('flexDisplay');
	            Selectors.CanScrollRight = createClassAndSelector('canScrollRight');
	            Selectors.CanScrollLeft = createClassAndSelector('canScrollLeft');
	        })(Selectors || (Selectors = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 274 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var DisplayNameKeys = visuals.SlicerUtil.DisplayNameKeys;
	        var DOMHelper = visuals.SlicerUtil.DOMHelper;
	        var SettingsHelper = visuals.SlicerUtil.SettingsHelper;
	        var Slicer = (function () {
	            function Slicer(options) {
	                if (options) {
	                    this.behavior = options.behavior;
	                }
	                this.domHelper = new DOMHelper();
	            }
	            Slicer.DefaultStyleProperties = function () {
	                return {
	                    general: {
	                        outlineColor: '#808080',
	                        outlineWeight: 1,
	                        orientation: 0 /* Vertical */,
	                    },
	                    header: {
	                        borderBottomWidth: 1,
	                        show: true,
	                        outline: visuals.outline.bottomOnly,
	                        fontColor: '#000000',
	                        textSize: 10,
	                    },
	                    slicerText: {
	                        color: '#666666',
	                        outline: visuals.outline.none,
	                        textSize: 10,
	                    },
	                    selection: {
	                        selectAllCheckboxEnabled: false,
	                        singleSelect: true,
	                    },
	                    search: {
	                        enabled: false,
	                    },
	                };
	            };
	            Slicer.prototype.init = function (options) {
	                this.initOptions = options;
	                this.element = options.element;
	                this.currentViewport = options.viewport;
	                this.hostServices = options.host;
	                var settings = this.settings = Slicer.DefaultStyleProperties();
	                this.slicerOrientation = settings.general.orientation;
	                this.waitingForData = false;
	                this.initializeSlicerRenderer(this.slicerOrientation);
	            };
	            Slicer.prototype.onDataChanged = function (options) {
	                debug.assertValue(options, 'options');
	                var dataViews = options.dataViews;
	                debug.assertValue(dataViews, 'dataViews');
	                if (_.isEmpty(dataViews)) {
	                    return;
	                }
	                var existingDataView = this.dataView;
	                this.dataView = dataViews[0];
	                // Reset scrollbar by default, unless it's an Append operation or Selecting an item
	                var resetScrollbarPosition = options.operationKind !== powerbi.VisualDataChangeOperationKind.Append
	                    && !powerbi.DataViewAnalysis.hasSameCategoryIdentity(existingDataView, this.dataView);
	                this.render(resetScrollbarPosition, true);
	            };
	            Slicer.prototype.onResizing = function (finalViewport) {
	                this.currentViewport = finalViewport;
	                this.render(false /* resetScrollbarPosition */);
	            };
	            Slicer.prototype.enumerateObjectInstances = function (options) {
	                return ObjectEnumerator.enumerateObjectInstances(options, this.slicerData, this.settings, this.dataView);
	            };
	            // public for testability
	            Slicer.prototype.loadMoreData = function () {
	                var dataView = this.dataView;
	                if (!dataView)
	                    return;
	                var dataViewMetadata = dataView.metadata;
	                // Making sure that hostservices.loadMoreData is not invoked when waiting for server to load the next segment of data
	                if (!this.waitingForData && dataViewMetadata && dataViewMetadata.segment) {
	                    this.hostServices.loadMoreData();
	                    this.waitingForData = true;
	                }
	            };
	            Slicer.prototype.onClearSelection = function () {
	                if (this.interactivityService) {
	                    this.interactivityService.clearSelection();
	                    // calls render so that default behavior can be applied after clear selection.
	                    this.render(false /* resetScrollbarPosition */);
	                }
	            };
	            Slicer.prototype.render = function (resetScrollbarPosition, stopWaitingForData) {
	                var localizedSelectAllText = this.hostServices.getLocalizedString(DisplayNameKeys.SelectAll);
	                this.slicerData = visuals.DataConversion.convert(this.dataView, localizedSelectAllText, this.interactivityService, this.hostServices);
	                if (this.slicerData) {
	                    this.slicerData.slicerSettings.general.outlineWeight = Math.max(this.slicerData.slicerSettings.general.outlineWeight, 0);
	                    this.settings = this.slicerData.slicerSettings;
	                    // TODO: Do we need to check SettingsHelper.areSettingsDefined(), etc. here? Can we just do value validation and coercion in the same place that we create the slicerSettings?
	                    var slicerOrientation_1 = SettingsHelper.areSettingsDefined(this.slicerData) && this.slicerData.slicerSettings.general && this.slicerData.slicerSettings.general.orientation ?
	                        this.slicerData.slicerSettings.general.orientation : Slicer.DefaultStyleProperties().general.orientation;
	                    var orientationHasChanged = this.orientationHasChanged(slicerOrientation_1);
	                    if (orientationHasChanged) {
	                        this.slicerOrientation = slicerOrientation_1;
	                        // Clear the previous slicer type when rendering the new slicer type
	                        this.element.empty();
	                        this.initializeSlicerRenderer(slicerOrientation_1);
	                    }
	                }
	                this.slicerRenderer.render({ dataView: this.dataView, data: this.slicerData, viewport: this.currentViewport, resetScrollbarPosition: resetScrollbarPosition });
	                if (stopWaitingForData)
	                    this.waitingForData = false;
	            };
	            Slicer.prototype.orientationHasChanged = function (slicerOrientation) {
	                return this.slicerOrientation !== slicerOrientation;
	            };
	            Slicer.prototype.initializeSlicerRenderer = function (slicerOrientation) {
	                switch (slicerOrientation) {
	                    case 1 /* Horizontal */:
	                        this.initializeHorizontalSlicer();
	                        break;
	                    case 0 /* Vertical */:
	                        this.initializeVerticalSlicer();
	                        break;
	                }
	            };
	            Slicer.prototype.initializeVerticalSlicer = function () {
	                var verticalSlicerRenderer = this.slicerRenderer = new visuals.VerticalSlicerRenderer({ domHelper: this.domHelper, behavior: this.behavior });
	                var options = this.createInitOptions();
	                this.interactivityService = verticalSlicerRenderer.init(options);
	            };
	            Slicer.prototype.initializeHorizontalSlicer = function () {
	                var horizontalSlicerRenderer = this.slicerRenderer = new visuals.HorizontalSlicerRenderer({ domHelper: this.domHelper, behavior: this.behavior });
	                var options = this.createInitOptions();
	                this.interactivityService = horizontalSlicerRenderer.init(options);
	            };
	            Slicer.prototype.createInitOptions = function () {
	                var _this = this;
	                return {
	                    visualInitOptions: this.initOptions,
	                    loadMoreData: function () { return _this.loadMoreData(); }
	                };
	            };
	            return Slicer;
	        }());
	        visuals.Slicer = Slicer;
	        /** Helper class for calculating the current slicer settings. */
	        var ObjectEnumerator;
	        (function (ObjectEnumerator) {
	            function enumerateObjectInstances(options, data, settings, dataView) {
	                if (!data)
	                    return;
	                switch (options.objectName) {
	                    case 'items':
	                        return enumerateItems(data, settings);
	                    case 'header':
	                        return enumerateHeader(data, settings);
	                    case 'general':
	                        return enumerateGeneral(data, settings);
	                    case 'selection':
	                        if (shouldShowSelectionOption(dataView))
	                            return enumerateSelection(data, settings);
	                }
	            }
	            ObjectEnumerator.enumerateObjectInstances = enumerateObjectInstances;
	            function shouldShowSelectionOption(dataView) {
	                return !(dataView &&
	                    dataView.metadata &&
	                    dataView.metadata.columns &&
	                    _.some(dataView.metadata.columns, function (column) { return column.discourageAggregationAcrossGroups; }));
	            }
	            function enumerateSelection(data, settings) {
	                var slicerSettings = settings;
	                var areSelectionSettingsDefined = SettingsHelper.areSettingsDefined(data) && data.slicerSettings.selection;
	                var selectAllCheckboxEnabled = areSelectionSettingsDefined && data.slicerSettings.selection.selectAllCheckboxEnabled ?
	                    data.slicerSettings.selection.selectAllCheckboxEnabled : slicerSettings.selection.selectAllCheckboxEnabled;
	                var singleSelect = data && data.slicerSettings && data.slicerSettings.selection && data.slicerSettings.selection.singleSelect !== undefined ?
	                    data.slicerSettings.selection.singleSelect : slicerSettings.selection.singleSelect;
	                return [{
	                        selector: null,
	                        objectName: 'selection',
	                        properties: {
	                            selectAllCheckboxEnabled: selectAllCheckboxEnabled,
	                            singleSelect: singleSelect,
	                        }
	                    }];
	            }
	            function enumerateHeader(data, settings) {
	                var slicerSettings = settings;
	                var areHeaderSettingsDefined = SettingsHelper.areSettingsDefined(data) && data.slicerSettings.header;
	                var fontColor = areHeaderSettingsDefined && data.slicerSettings.header.fontColor ?
	                    data.slicerSettings.header.fontColor : slicerSettings.header.fontColor;
	                var background = areHeaderSettingsDefined && data.slicerSettings.header.background ?
	                    data.slicerSettings.header.background : slicerSettings.header.background;
	                return [{
	                        selector: null,
	                        objectName: 'header',
	                        properties: {
	                            show: slicerSettings.header.show,
	                            fontColor: fontColor,
	                            background: background,
	                            outline: slicerSettings.header.outline,
	                            textSize: slicerSettings.header.textSize,
	                        }
	                    }];
	            }
	            function enumerateItems(data, settings) {
	                var slicerSettings = settings;
	                var areTextSettingsDefined = SettingsHelper.areSettingsDefined(data) && data.slicerSettings.slicerText;
	                var fontColor = areTextSettingsDefined && data.slicerSettings.slicerText.color ?
	                    data.slicerSettings.slicerText.color : slicerSettings.slicerText.color;
	                var background = areTextSettingsDefined && data.slicerSettings.slicerText.background ?
	                    data.slicerSettings.slicerText.background : slicerSettings.slicerText.background;
	                return [{
	                        selector: null,
	                        objectName: 'items',
	                        properties: {
	                            fontColor: fontColor,
	                            background: background,
	                            outline: slicerSettings.slicerText.outline,
	                            textSize: slicerSettings.slicerText.textSize,
	                        }
	                    }];
	            }
	            function enumerateGeneral(data, settings) {
	                var slicerSettings = settings;
	                var areGeneralSettingsDefined = SettingsHelper.areSettingsDefined(data) && data.slicerSettings.general != null;
	                var outlineColor = areGeneralSettingsDefined && data.slicerSettings.general.outlineColor ?
	                    data.slicerSettings.general.outlineColor : slicerSettings.general.outlineColor;
	                var outlineWeight = areGeneralSettingsDefined && data.slicerSettings.general.outlineWeight ?
	                    data.slicerSettings.general.outlineWeight : slicerSettings.general.outlineWeight;
	                var orientation = areGeneralSettingsDefined && data.slicerSettings.general.orientation != null ?
	                    data.slicerSettings.general.orientation : slicerSettings.general.orientation;
	                return [{
	                        selector: null,
	                        objectName: 'general',
	                        properties: {
	                            outlineColor: outlineColor,
	                            outlineWeight: outlineWeight,
	                            orientation: orientation,
	                        }
	                    }];
	            }
	        })(ObjectEnumerator || (ObjectEnumerator = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 275 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var TablixUtils = visuals.controls.internal.TablixUtils;
	        var TablixObjects = visuals.controls.internal.TablixObjects;
	        var EdgeSettings = TablixUtils.EdgeSettings;
	        var EdgeType = TablixUtils.EdgeType;
	        var TableHierarchyNavigator = (function () {
	            function TableHierarchyNavigator(tableDataView, isDataComplete, formatter) {
	                debug.assertValue(tableDataView, 'tableDataView');
	                debug.assertValue(formatter, 'formatter');
	                this.tableDataView = tableDataView;
	                this.isDataComplete = isDataComplete;
	                this.formatter = formatter;
	            }
	            /**
	            * Returns the depth of the Columnm hierarchy.
	            */
	            TableHierarchyNavigator.prototype.getColumnHierarchyDepth = function () {
	                return 1;
	            };
	            /**
	            * Returns the depth of the Row hierarchy.
	            */
	            TableHierarchyNavigator.prototype.getRowHierarchyDepth = function () {
	                return 1;
	            };
	            /**
	             * Returns the leaf count of a hierarchy.
	             */
	            TableHierarchyNavigator.prototype.getLeafCount = function (hierarchy) {
	                return hierarchy.length;
	            };
	            /**
	             * Returns the leaf member of a hierarchy at a specified index.
	             */
	            TableHierarchyNavigator.prototype.getLeafAt = function (hierarchy, index) {
	                return hierarchy[index];
	            };
	            /**
	             * Returns the specified hierarchy member parent.
	             */
	            TableHierarchyNavigator.prototype.getParent = function (item) {
	                return null;
	            };
	            /**
	             * Returns the index of the hierarchy member relative to its parent.
	             */
	            TableHierarchyNavigator.prototype.getIndex = function (item) {
	                if (!item)
	                    return -1;
	                if (this.isRow(item))
	                    return item.index;
	                return this.getColumnIndex(item);
	            };
	            TableHierarchyNavigator.prototype.isRow = function (item) {
	                if (!item)
	                    return false;
	                var row = item;
	                return row.index !== undefined && row.values !== undefined;
	            };
	            TableHierarchyNavigator.prototype.getColumnIndex = function (item) {
	                return TableHierarchyNavigator.getIndex(this.tableDataView.columns, item);
	            };
	            /**
	             * Checks whether a hierarchy member is a leaf.
	             */
	            TableHierarchyNavigator.prototype.isLeaf = function (item) {
	                return true;
	            };
	            TableHierarchyNavigator.prototype.isRowHierarchyLeaf = function (cornerItem) {
	                return false;
	            };
	            TableHierarchyNavigator.prototype.isColumnHierarchyLeaf = function (cornerItem) {
	                return true;
	            };
	            TableHierarchyNavigator.prototype.isFirstItem = function (item, items) {
	                // checking for item.index is unreliable because reordering the columns would cause a mismatch between index and items order
	                return item === items[0];
	            };
	            TableHierarchyNavigator.prototype.areAllParentsFirst = function (item, items) {
	                return this.isFirstItem(item, items);
	            };
	            /**
	             * Checks whether a hierarchy member is the last item within its parent.
	             */
	            TableHierarchyNavigator.prototype.isLastItem = function (item, items) {
	                debug.assertValue(item, 'item');
	                // If it's a row, we need to check if data is complete
	                return (items === this.tableDataView.columns || this.isDataComplete)
	                    && (item === _.last(items));
	            };
	            TableHierarchyNavigator.prototype.areAllParentsLast = function (item, items) {
	                return this.isLastItem(item, items);
	            };
	            /**
	             * Gets the children members of a hierarchy member.
	             */
	            TableHierarchyNavigator.prototype.getChildren = function (item) {
	                return null;
	            };
	            TableHierarchyNavigator.prototype.getChildrenLevelDifference = function (item) {
	                return Infinity;
	            };
	            /**
	             * Gets the members count in a specified collection.
	             */
	            TableHierarchyNavigator.prototype.getCount = function (items) {
	                return items.length;
	            };
	            /**
	             * Gets the member at the specified index.
	             */
	            TableHierarchyNavigator.prototype.getAt = function (items, index) {
	                return items[index];
	            };
	            /**
	             * Gets the hierarchy member level.
	             */
	            TableHierarchyNavigator.prototype.getLevel = function (item) {
	                return 0;
	            };
	            /**
	             * Returns the intersection between a row and a column item.
	             */
	            TableHierarchyNavigator.prototype.getIntersection = function (rowItem, columnItem) {
	                var value;
	                var isTotal = false;
	                var position = new TablixUtils.CellPosition();
	                var columnIndex = TableHierarchyNavigator.getIndex(this.tableDataView.columns, columnItem);
	                ;
	                position.column.index = columnIndex;
	                position.column.isFirst = columnIndex === 0 ? true : false;
	                position.column.isLast = columnIndex === this.tableDataView.columns.length - 1;
	                var totalRow = rowItem;
	                if (totalRow.totalCells != null) {
	                    isTotal = true;
	                    value = totalRow.totalCells[columnIndex];
	                }
	                else {
	                    var row = rowItem;
	                    var rowIndex = row.index;
	                    position.row.index = rowIndex;
	                    position.row.isFirst = rowIndex === 0;
	                    position.row.isLast = this.isDataComplete && (rowIndex === this.tableDataView.rows.length - 1);
	                    value = row.values[columnIndex];
	                }
	                var cellItem = new TablixUtils.TablixVisualCell(value, isTotal, columnItem, this.formatter, false);
	                cellItem.position = position;
	                var tableRow = rowItem;
	                if (tableRow && tableRow.values) {
	                    var rowObjects = tableRow.values.objects;
	                    if (rowObjects) {
	                        var cellObject = rowObjects[columnIndex];
	                        if (cellObject) {
	                            cellItem.backColor = TablixObjects.PropValuesBackColor.getValue(cellObject);
	                        }
	                    }
	                }
	                return cellItem;
	            };
	            /**
	             * Returns the corner cell between a row and a column level.
	             */
	            TableHierarchyNavigator.prototype.getCorner = function (rowLevel, columnLevel) {
	                return null;
	            };
	            TableHierarchyNavigator.prototype.headerItemEquals = function (item1, item2) {
	                if (item1 === item2)
	                    return true;
	                // Typechecking does not work with interfaces nor at runtime. We need to explicitly check for
	                // properties of DataViewMetadataColumn to determine if we can use the column equivalency check.
	                // We expect this method to handle either VisualTableRows or DataViewMetadataColumns so checking
	                // for displayName should be sufficient.
	                if (item1.displayName && item2.displayName) {
	                    var column1 = item1;
	                    var column2 = item2;
	                    return powerbi.DataViewAnalysis.areMetadataColumnsEquivalent(column1, column2);
	                }
	                if (this.isRow(item1) && this.isRow(item2))
	                    return item1.index === item2.index;
	                return false;
	            };
	            TableHierarchyNavigator.prototype.bodyCellItemEquals = function (item1, item2) {
	                //return (item1.dataPoint === item2.dataPoint);
	                return (item1.isMatch(item2));
	            };
	            TableHierarchyNavigator.prototype.cornerCellItemEquals = function (item1, item2) {
	                // Should not be called as we don't return any corner items for table
	                return true;
	            };
	            TableHierarchyNavigator.prototype.update = function (table, isDataComplete) {
	                this.tableDataView = table;
	                this.isDataComplete = isDataComplete;
	            };
	            TableHierarchyNavigator.getIndex = function (items, item) {
	                for (var index = 0, len = items.length; index < len; index++) {
	                    // For cases when the item was re-created during the DataTransformation phase,
	                    // we check for the item's index to verify equality.
	                    var arrayItem = items[index];
	                    if (arrayItem.index != null && item.index != null && arrayItem.index === item.index) {
	                        return index;
	                    }
	                    else {
	                        if (item === items[index])
	                            return index;
	                    }
	                }
	                return -1;
	            };
	            return TableHierarchyNavigator;
	        }());
	        visuals.TableHierarchyNavigator = TableHierarchyNavigator;
	        /**
	         * Note: Public for testability.
	         */
	        var TableBinder = (function () {
	            function TableBinder(options, dataView) {
	                this.options = options;
	                // Handling unit tests calling constructor without a dataView
	                if (dataView) {
	                    this.updateDataView(dataView);
	                }
	            }
	            TableBinder.prototype.updateDataView = function (dataView) {
	                this.tableDataView = dataView;
	                this.formattingProperties = dataView.formattingProperties;
	                this.updateTextHeights();
	                if (this.hasImage()) {
	                    this.rowHeight = Math.max(this.textHeightValue, this.formattingProperties.grid.imageHeight);
	                }
	                else {
	                    this.rowHeight = this.textHeightValue;
	                }
	            };
	            TableBinder.prototype.updateTextHeights = function () {
	                this.fontSizeHeader = jsCommon.PixelConverter.fromPointToPixel(this.formattingProperties.general.textSize);
	                this.textPropsHeader = {
	                    fontFamily: TablixUtils.FontFamilyHeader,
	                    fontSize: jsCommon.PixelConverter.toString(this.fontSizeHeader),
	                };
	                this.textHeightHeader = Math.ceil(powerbi.TextMeasurementService.measureSvgTextHeight(this.textPropsHeader, "a"));
	                this.fontSizeValue = jsCommon.PixelConverter.fromPointToPixel(this.formattingProperties.general.textSize);
	                this.textPropsValue = {
	                    fontFamily: TablixUtils.FontFamilyCell,
	                    fontSize: jsCommon.PixelConverter.toString(this.fontSizeValue),
	                };
	                this.textHeightValue = Math.ceil(powerbi.TextMeasurementService.measureSvgTextHeight(this.textPropsValue, "a"));
	                this.fontSizeTotal = jsCommon.PixelConverter.fromPointToPixel(this.formattingProperties.general.textSize);
	                this.textPropsTotal = {
	                    fontFamily: TablixUtils.FontFamilyTotal,
	                    fontSize: jsCommon.PixelConverter.toString(this.fontSizeTotal),
	                };
	                this.textHeightTotal = Math.ceil(powerbi.TextMeasurementService.measureSvgTextHeight(this.textPropsTotal, "a"));
	            };
	            TableBinder.prototype.hasImage = function () {
	                return _.any(this.tableDataView.columns, function (col) { return visuals.converterHelper.isImageUrlColumn(col); });
	            };
	            TableBinder.prototype.onStartRenderingSession = function () {
	            };
	            TableBinder.prototype.onEndRenderingSession = function () {
	            };
	            /**
	             * Row Header.
	             */
	            TableBinder.prototype.bindRowHeader = function (item, cell) {
	                // Check if it's a total row
	                if (item.totalCells) {
	                    cell.contentHeight = this.textHeightTotal;
	                }
	                else {
	                    cell.contentHeight = this.rowHeight;
	                }
	                // To clear the CSS classes that adds paddings
	                TablixUtils.clearCellStyle(cell);
	                if (this.options.onBindRowHeader)
	                    this.options.onBindRowHeader(item);
	            };
	            TableBinder.prototype.unbindRowHeader = function (item, cell) {
	            };
	            /**
	             * Column Header.
	             */
	            TableBinder.prototype.bindColumnHeader = function (item, cell) {
	                var _this = this;
	                cell.extension.disableDragResize();
	                TablixUtils.resetCellCssClass(cell);
	                TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixHeader);
	                TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixColumnHeaderLeaf);
	                var cellStyle = new TablixUtils.CellStyle();
	                // Set default style
	                cellStyle.fontFamily = TablixUtils.FontFamilyHeader;
	                cellStyle.fontColor = TablixUtils.FontColorHeaders;
	                cellStyle.borders.bottom = new EdgeSettings(TablixObjects.PropGridOutlineWeight.defaultValue, TablixObjects.PropGridOutlineColor.defaultValue);
	                cell.contentHeight = this.textHeightHeader;
	                var element = cell.extension.contentHost;
	                if (this.sortIconsEnabled()) {
	                    element = TablixUtils.addSortIconToColumnHeader(item.sort, element);
	                    if (item.sort) {
	                        // Glyph font has all characters width/height same as font size
	                        cell.contentWidth = this.fontSizeHeader + TablixUtils.SortIconPadding;
	                    }
	                }
	                TablixUtils.setCellTextAndTooltip(item.displayName, element, cell.extension.contentHost);
	                cell.contentWidth += powerbi.TextMeasurementService.measureSvgTextWidth(this.textPropsHeader, item.displayName);
	                cell.contentWidth = Math.ceil(cell.contentWidth);
	                if (this.options.onColumnHeaderClick) {
	                    var handler = function (e) {
	                        if (TablixUtils.isValidSortClick(e)) {
	                            var sortDirection = TablixUtils.reverseSort(item.sort);
	                            _this.options.onColumnHeaderClick(item.queryName ? item.queryName : item.displayName, sortDirection);
	                        }
	                    };
	                    cell.extension.registerClickHandler(handler);
	                }
	                this.setColumnHeaderStyle(cell, cellStyle);
	                cell.applyStyle(cellStyle);
	            };
	            TableBinder.prototype.setColumnHeaderStyle = function (cell, style) {
	                var propsGrid = this.formattingProperties.grid;
	                var props = this.formattingProperties.columnHeaders;
	                var propsTotal = this.formattingProperties.total;
	                var propsValues = this.formattingProperties.values;
	                style.borders.top = new EdgeSettings();
	                style.borders.top.applyParams(visuals.outline.showTop(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline);
	                style.borders.bottom = new EdgeSettings();
	                style.borders.bottom.applyParams(visuals.outline.showBottom(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline);
	                style.borders.left = new EdgeSettings();
	                if (cell.position.column.isFirst) {
	                    style.borders.left.applyParams(visuals.outline.showLeft(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline);
	                    // If we dont have left border, but Footer or Body has, we need to apply extra padding
	                    if (!visuals.outline.showLeft(props.outline) && (visuals.outline.showLeft(propsTotal.outline) || visuals.outline.showLeft(propsValues.outline)))
	                        style.paddings.left += propsGrid.outlineWeight;
	                } // else: do nothing
	                style.borders.right = new EdgeSettings();
	                if (cell.position.column.isLast) {
	                    style.borders.right.applyParams(visuals.outline.showRight(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline);
	                    // If we dont have right border, but Footer or Body has, we need to apply extra padding
	                    if (!visuals.outline.showRight(props.outline) && (visuals.outline.showRight(propsTotal.outline) || visuals.outline.showRight(propsValues.outline)))
	                        style.paddings.right += propsGrid.outlineWeight;
	                }
	                else {
	                    style.borders.right.applyParams(propsGrid.gridVertical, propsGrid.gridVerticalWeight, propsGrid.gridVerticalColor, EdgeType.Gridline);
	                }
	                style.fontColor = props.fontColor;
	                style.backColor = props.backColor;
	                style.paddings.top = style.paddings.bottom = propsGrid.rowPadding;
	            };
	            TableBinder.prototype.unbindColumnHeader = function (item, cell) {
	                TablixUtils.clearCellStyle(cell);
	                TablixUtils.clearCellTextAndTooltip(cell);
	                if (this.sortIconsEnabled())
	                    TablixUtils.removeSortIcons(cell);
	                if (this.options.onColumnHeaderClick) {
	                    cell.extension.unregisterClickHandler();
	                }
	            };
	            /**
	             * Body Cell.
	             */
	            TableBinder.prototype.bindBodyCell = function (item, cell) {
	                TablixUtils.resetCellCssClass(cell);
	                this.setBodyContent(item, cell);
	                cell.contentWidth = Math.ceil(cell.contentWidth);
	                var cellStyle = new TablixUtils.CellStyle();
	                if (item.isTotal) {
	                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixValueTotal);
	                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTableFooter);
	                    cellStyle.fontFamily = TablixUtils.FontFamilyTotal;
	                    cellStyle.borders.top = new EdgeSettings(TablixObjects.PropGridOutlineWeight.defaultValue, TablixObjects.PropGridOutlineColor.defaultValue);
	                }
	                else if (item.position.row.isLast) {
	                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTableBodyCellBottom);
	                }
	                else {
	                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTableBodyCell);
	                    cellStyle.borders.bottom = new EdgeSettings(TablixObjects.PropGridHorizontalWeight.defaultValue, TablixObjects.PropGridHorizontalColor.defaultValue);
	                }
	                if (item.isNumeric)
	                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixValueNumeric);
	                if (item.isTotal)
	                    this.setFooterStyle(cell, cellStyle);
	                else
	                    this.setBodyStyle(item, cell, cellStyle);
	                cell.applyStyle(cellStyle);
	            };
	            TableBinder.prototype.setBodyContent = function (item, cell) {
	                var element = cell.extension.contentHost;
	                var imgHeight = this.formattingProperties.grid.imageHeight;
	                var text = item.textContent;
	                // #region Setting Height
	                if (item.isTotal) {
	                    cell.contentHeight = this.textHeightTotal;
	                }
	                else if (item.isImage) {
	                    cell.contentHeight = imgHeight;
	                }
	                else {
	                    cell.contentHeight = this.textHeightValue;
	                }
	                // #endregion
	                if (item.isUrl && item.isValidUrl) {
	                    var showUrlIcon = this.formattingProperties.values.urlIcon;
	                    TablixUtils.appendATagToBodyCell(text, element, showUrlIcon);
	                    if (showUrlIcon)
	                        cell.contentWidth = this.fontSizeValue;
	                    else
	                        cell.contentWidth = powerbi.TextMeasurementService.measureSvgTextWidth(this.textPropsValue, text);
	                    return;
	                }
	                if (item.isImage && item.isValidUrl) {
	                    TablixUtils.appendImgTagToBodyCell(text, element, imgHeight);
	                    cell.contentWidth = imgHeight * TablixUtils.ImageDefaultAspectRatio;
	                    return;
	                }
	                var kpi = item.kpiContent;
	                if (kpi) {
	                    $(element).append(kpi);
	                    // Glyph font has all characters width/height same as font size
	                    cell.contentWidth = this.fontSizeValue;
	                    return;
	                }
	                if (text) {
	                    TablixUtils.setCellTextAndTooltip(text, element);
	                    if (item.isTotal)
	                        cell.contentWidth = powerbi.TextMeasurementService.measureSvgTextWidth(this.textPropsTotal, text);
	                    else
	                        cell.contentWidth = powerbi.TextMeasurementService.measureSvgTextWidth(this.textPropsValue, text);
	                    return;
	                }
	                TablixUtils.setCellTextAndTooltip(" ", element);
	                cell.contentWidth = 0;
	            };
	            TableBinder.prototype.setBodyStyle = function (item, cell, style) {
	                var propsGrid = this.formattingProperties.grid;
	                var props = this.formattingProperties.values;
	                var propsTotal = this.formattingProperties.total;
	                var propsColumns = this.formattingProperties.columnHeaders;
	                style.borders.top = new EdgeSettings();
	                if (cell.position.row.isFirst) {
	                    style.borders.top.applyParams(visuals.outline.showTop(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline);
	                } // else: do nothing
	                style.borders.bottom = new EdgeSettings();
	                if (cell.position.row.isLast) {
	                    style.borders.bottom.applyParams(visuals.outline.showBottom(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline);
	                }
	                else {
	                    style.borders.bottom.applyParams(propsGrid.gridHorizontal, propsGrid.gridHorizontalWeight, propsGrid.gridHorizontalColor, EdgeType.Gridline);
	                }
	                style.borders.left = new EdgeSettings();
	                if (cell.position.column.isFirst) {
	                    style.borders.left.applyParams(visuals.outline.showLeft(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline);
	                    // If we dont have left border, but Footer or Header has, we need to apply extra padding
	                    if (!visuals.outline.showLeft(props.outline) && (visuals.outline.showLeft(propsTotal.outline) || visuals.outline.showLeft(propsColumns.outline)))
	                        style.paddings.left += propsGrid.outlineWeight;
	                } // else: do nothing
	                style.borders.right = new EdgeSettings();
	                if (cell.position.column.isLast) {
	                    style.borders.right.applyParams(visuals.outline.showRight(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline);
	                    // If we dont have right border, but Footer has, we need to apply extra padding
	                    if (!visuals.outline.showRight(props.outline) && (visuals.outline.showRight(propsTotal.outline) || visuals.outline.showRight(propsColumns.outline)))
	                        style.paddings.right += propsGrid.outlineWeight;
	                }
	                else {
	                    style.borders.right.applyParams(propsGrid.gridVertical, propsGrid.gridVerticalWeight, propsGrid.gridVerticalColor, EdgeType.Gridline);
	                }
	                style.fontColor = cell.position.row.index % 2 === 0 ? props.fontColorPrimary : props.fontColorSecondary;
	                // Conditional formatting on the cell overrides primary/secondary background colors.
	                if (item.backColor)
	                    style.backColor = item.backColor;
	                else
	                    style.backColor = cell.position.row.index % 2 === 0 ? props.backColorPrimary : props.backColorSecondary;
	                style.paddings.top = style.paddings.bottom = propsGrid.rowPadding;
	            };
	            TableBinder.prototype.setFooterStyle = function (cell, style) {
	                var props = this.formattingProperties.total;
	                var propsGrid = this.formattingProperties.grid;
	                var propsValues = this.formattingProperties.values;
	                var propsColumns = this.formattingProperties.columnHeaders;
	                style.borders.top = new EdgeSettings();
	                style.borders.top.applyParams(visuals.outline.showTop(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline);
	                style.borders.bottom = new EdgeSettings();
	                style.borders.bottom.applyParams(visuals.outline.showBottom(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline);
	                style.borders.left = new EdgeSettings();
	                if (cell.position.column.isFirst) {
	                    style.borders.left.applyParams(visuals.outline.showLeft(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline);
	                    // If we dont have left border, but values or column headers have, we need to apply padding
	                    if (!visuals.outline.showLeft(props.outline) && (visuals.outline.showLeft(propsValues.outline) || visuals.outline.showLeft(propsColumns.outline)))
	                        style.paddings.left += propsGrid.outlineWeight;
	                } // else: do nothing
	                style.borders.right = new EdgeSettings();
	                if (cell.position.column.isLast) {
	                    style.borders.right.applyParams(visuals.outline.showRight(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline);
	                    // If we dont have left border, but values or column headers have, we need to apply padding
	                    if (!visuals.outline.showRight(props.outline) && (visuals.outline.showRight(propsValues.outline) || visuals.outline.showRight(propsColumns.outline)))
	                        style.paddings.right += propsGrid.outlineWeight;
	                }
	                else {
	                    style.borders.right.applyParams(propsGrid.gridVertical, propsGrid.gridVerticalWeight, propsGrid.gridVerticalColor, EdgeType.Gridline);
	                }
	                style.fontColor = props.fontColor;
	                style.backColor = props.backColor;
	                style.paddings.top = style.paddings.bottom = propsGrid.rowPadding;
	            };
	            TableBinder.prototype.unbindBodyCell = function (item, cell) {
	                TablixUtils.clearCellStyle(cell);
	                TablixUtils.clearCellTextAndTooltip(cell);
	            };
	            /**
	             * Corner Cell.
	             */
	            TableBinder.prototype.bindCornerCell = function (item, cell) {
	                cell.contentWidth = 0;
	            };
	            TableBinder.prototype.unbindCornerCell = function (item, cell) {
	            };
	            TableBinder.prototype.bindEmptySpaceHeaderCell = function (cell) {
	                // Not needed for Table
	            };
	            TableBinder.prototype.unbindEmptySpaceHeaderCell = function (cell) {
	                // Not needed for Table
	            };
	            TableBinder.prototype.bindEmptySpaceFooterCell = function (cell) {
	                // Not needed for Table
	            };
	            TableBinder.prototype.unbindEmptySpaceFooterCell = function (cell) {
	                // Not needed for Table
	            };
	            /**
	             * Measurement Helper.
	             */
	            TableBinder.prototype.getHeaderLabel = function (item) {
	                return item ? item.displayName : "";
	            };
	            TableBinder.prototype.getCellContent = function (item) {
	                return item;
	            };
	            TableBinder.prototype.hasRowGroups = function () {
	                return false;
	            };
	            TableBinder.prototype.sortIconsEnabled = function () {
	                return this.options.layoutKind === 0 /* Canvas */;
	            };
	            return TableBinder;
	        }());
	        visuals.TableBinder = TableBinder;
	        var Table = (function () {
	            function Table(options) {
	                if (options) {
	                    this.isTouchEnabled = options.isTouchEnabled;
	                }
	            }
	            Table.customizeQuery = function (options) {
	                var dataViewMapping = options.dataViewMappings[0];
	                if (!dataViewMapping || !dataViewMapping.table || !dataViewMapping.metadata)
	                    return;
	                var dataViewTableRows = dataViewMapping.table.rows;
	                var objects = dataViewMapping.metadata.objects;
	                dataViewTableRows.for.in.subtotalType = TablixObjects.shouldShowTableTotals(objects) ? 1 /* Before */ : 0 /* None */;
	            };
	            Table.getSortableRoles = function () {
	                return ['Values'];
	            };
	            Table.prototype.init = function (options) {
	                this.element = options.element;
	                this.style = options.style;
	                this.updateViewport(options.viewport);
	                this.formatter = visuals.valueFormatter.formatVariantMeasureValue;
	                this.isInteractive = options.interactivity && options.interactivity.selection != null;
	                this.getLocalizedString = options.host.getLocalizedString;
	                this.hostServices = options.host;
	                this.persistingObjects = false;
	                this.waitingForData = false;
	                this.lastAllowHeaderResize = true;
	                this.waitingForSort = false;
	            };
	            /**
	             * Note: Public for testability.
	             */
	            Table.converter = function (dataView) {
	                var table = dataView.table;
	                debug.assertValue(table, 'table');
	                debug.assertValue(table.rows, 'table.rows');
	                var visualTable = powerbi.Prototype.inherit(table);
	                visualTable.visualRows = [];
	                for (var i = 0; i < table.rows.length; i++) {
	                    var visualRow = {
	                        index: i,
	                        values: table.rows[i]
	                    };
	                    visualTable.visualRows.push(visualRow);
	                }
	                visualTable.formattingProperties = TablixObjects.getTableObjects(dataView);
	                return visualTable;
	            };
	            Table.prototype.onResizing = function (finalViewport) {
	                this.updateViewport(finalViewport);
	            };
	            // Public for testability
	            Table.prototype.getColumnWidthManager = function () {
	                return this.columnWidthManager;
	            };
	            Table.prototype.onDataChanged = function (options) {
	                debug.assertValue(options, 'options');
	                var dataViews = options.dataViews;
	                if (dataViews && dataViews.length > 0) {
	                    var previousDataView = this.dataView;
	                    this.dataView = dataViews[0];
	                    /* To avoid OnDataChanged being called every time we persist Objects. If:
	                    * AutoSizeColumns options was flipped
	                    * A Column was resized manually
	                    * A Column was auto-sized
	                    */
	                    if (this.persistingObjects) {
	                        this.persistingObjects = false;
	                        return;
	                    }
	                    var visualTable = Table.converter(this.dataView);
	                    if (options.operationKind === powerbi.VisualDataChangeOperationKind.Append) {
	                        this.createOrUpdateHierarchyNavigator(visualTable);
	                        this.tablixControl.updateModels(/*resetScrollOffsets*/ false, visualTable.visualRows, visualTable.columns);
	                        this.refreshControl(/*clear*/ false);
	                    }
	                    else {
	                        this.createOrUpdateHierarchyNavigator(visualTable);
	                        this.createColumnWidthManager();
	                        this.createTablixControl(visualTable);
	                        this.updateInternal(previousDataView, visualTable);
	                    }
	                }
	                this.waitingForData = false;
	                this.waitingForSort = false;
	            };
	            Table.prototype.createColumnWidthManager = function () {
	                var _this = this;
	                if (!this.columnWidthManager) {
	                    this.columnWidthManager = new visuals.controls.TablixColumnWidthManager(this.dataView, false /* isMatrix */, function (objectInstances) { return _this.persistColumnWidths(objectInstances); });
	                }
	                else {
	                    this.columnWidthManager.updateDataView(this.dataView);
	                }
	            };
	            Table.prototype.persistColumnWidths = function (objectInstances) {
	                this.persistingObjects = true;
	                this.hostServices.persistProperties(objectInstances);
	            };
	            Table.prototype.updateViewport = function (newViewport) {
	                this.currentViewport = newViewport;
	                if (this.tablixControl) {
	                    this.tablixControl.viewport = this.currentViewport;
	                    this.verifyHeaderResize();
	                    this.refreshControl(false);
	                }
	            };
	            Table.prototype.refreshControl = function (clear) {
	                if (visuals.visibilityHelper.partiallyVisible(this.element) || this.getLayoutKind() === 1 /* DashboardTile */) {
	                    this.tablixControl.refresh(clear);
	                }
	            };
	            Table.prototype.getLayoutKind = function () {
	                return this.isInteractive ? 0 /* Canvas */ : 1 /* DashboardTile */;
	            };
	            Table.prototype.createOrUpdateHierarchyNavigator = function (visualTable) {
	                var isDataComplete = !this.dataView.metadata.segment;
	                if (!this.tablixControl) {
	                    var dataNavigator = new TableHierarchyNavigator(visualTable, isDataComplete, this.formatter);
	                    this.hierarchyNavigator = dataNavigator;
	                }
	                else {
	                    this.hierarchyNavigator.update(visualTable, isDataComplete);
	                }
	            };
	            Table.prototype.createTablixControl = function (visualTable) {
	                if (!this.tablixControl) {
	                    // Create the control
	                    this.tablixControl = this.createControl(this.hierarchyNavigator, visualTable);
	                }
	                else {
	                    var binder = this.tablixControl.getBinder();
	                    binder.updateDataView(visualTable);
	                }
	            };
	            Table.prototype.createControl = function (dataNavigator, visualTable) {
	                var _this = this;
	                var layoutKind = this.getLayoutKind();
	                var textSize = visualTable.formattingProperties.general.textSize;
	                var tableBinderOptions = {
	                    onBindRowHeader: function (item) { return _this.onBindRowHeader(item); },
	                    onColumnHeaderClick: function (queryName, sortDirection) { return _this.onColumnHeaderClick(queryName, sortDirection); },
	                    layoutKind: layoutKind
	                };
	                var tableBinder = new TableBinder(tableBinderOptions, visualTable);
	                var layoutManager = layoutKind === 1 /* DashboardTile */
	                    ? visuals.controls.internal.DashboardTablixLayoutManager.createLayoutManager(tableBinder)
	                    : visuals.controls.internal.CanvasTablixLayoutManager.createLayoutManager(tableBinder, this.columnWidthManager);
	                // Create Host element
	                var tablixContainer = document.createElement('div');
	                this.element.append(tablixContainer);
	                var tablixOptions = {
	                    interactive: this.isInteractive,
	                    enableTouchSupport: this.isTouchEnabled,
	                    layoutKind: layoutKind,
	                    fontSize: TablixObjects.getTextSizeInPx(textSize),
	                };
	                return new visuals.controls.TablixControl(dataNavigator, layoutManager, tableBinder, tablixContainer, tablixOptions);
	            };
	            Table.prototype.updateInternal = function (previousDataView, visualTable) {
	                var _this = this;
	                var textSize = visualTable.formattingProperties.general.textSize;
	                if (this.getLayoutKind() === 1 /* DashboardTile */) {
	                    this.tablixControl.layoutManager.adjustContentSize(visuals.converterHelper.hasImageUrlColumn(this.dataView));
	                }
	                this.tablixControl.fontSize = TablixObjects.getTextSizeInPx(textSize);
	                this.verifyHeaderResize();
	                // Update models before the viewport to make sure column widths are computed correctly
	                this.tablixControl.updateModels(/*resetScrollOffsets*/ true, visualTable.visualRows, visualTable.columns);
	                var totals = this.createTotalsRow(this.dataView);
	                this.tablixControl.rowDimension.setFooter(totals);
	                this.tablixControl.viewport = this.currentViewport;
	                var shouldClearControl = this.shouldClearControl(previousDataView, this.dataView);
	                // Render
	                // We need the layout for the DIV to be done so that the control can measure items correctly.
	                setTimeout(function () {
	                    // Render
	                    _this.refreshControl(shouldClearControl);
	                    var widthChanged = _this.columnWidthManager.onColumnsRendered(_this.tablixControl.layoutManager.columnWidthsToPersist);
	                    // At this point, all columns are rendered with proper width
	                    // Resetting the flag unless any unknown columnn width was persisted
	                    if (_this.persistingObjects && !widthChanged) {
	                        _this.persistingObjects = false;
	                    }
	                }, 0);
	            };
	            Table.prototype.shouldClearControl = function (previousDataView, newDataView) {
	                if (!this.waitingForSort || !previousDataView || !newDataView)
	                    return true;
	                return !powerbi.DataViewAnalysis.isMetadataEquivalent(previousDataView.metadata, newDataView.metadata);
	            };
	            Table.prototype.createTotalsRow = function (dataView) {
	                if (!TablixObjects.shouldShowTableTotals(dataView.metadata.objects))
	                    return null;
	                var totals = dataView.table.totals;
	                if (!totals || totals.length === 0)
	                    return null;
	                var totalRow = [];
	                var columns = dataView.table.columns;
	                // Add totals for measure columns, blank for non-measure columns unless it's the first column
	                for (var i = 0, len = columns.length; i < len; ++i) {
	                    var column = columns[i];
	                    var totalValue = totals[column.index];
	                    if (totalValue != null) {
	                        totalRow.push(totalValue);
	                    }
	                    else {
	                        // If the first column is a non-measure column, we put 'Total' as the text similar to PV.
	                        // Note that if the first column is a measure column we don't render any Total text at
	                        // all, once again similar to PV.
	                        totalRow.push((i === 0) ? this.getLocalizedString('TableTotalLabel') : '');
	                    }
	                }
	                return { totalCells: totalRow };
	            };
	            Table.prototype.onBindRowHeader = function (item) {
	                if (this.needsMoreData(item)) {
	                    this.hostServices.loadMoreData();
	                    this.waitingForData = true;
	                }
	            };
	            Table.prototype.onColumnHeaderClick = function (queryName, sortDirection) {
	                this.waitingForSort = true;
	                this.hostServices.onCustomSort(TablixUtils.getCustomSortEventArgs(queryName, sortDirection));
	            };
	            /**
	             * Note: Public for testability.
	             */
	            Table.prototype.needsMoreData = function (item) {
	                if (this.waitingForData || !this.dataView.metadata || !this.dataView.metadata.segment)
	                    return false;
	                var leafCount = this.tablixControl.rowDimension.getItemsCount();
	                var loadMoreThreshold = leafCount * Table.preferredLoadMoreThreshold;
	                return this.hierarchyNavigator.getIndex(item) >= loadMoreThreshold;
	            };
	            Table.prototype.enumerateObjectInstances = function (options) {
	                var enumeration = new visuals.ObjectEnumerationBuilder();
	                // Visuals are initialized with an empty data view before queries are run, therefore we need to make sure that
	                // we are resilient here when we do not have data view.
	                if (this.dataView) {
	                    TablixObjects.enumerateObjectInstances(options, enumeration, this.dataView, visuals.controls.TablixType.Table);
	                }
	                return enumeration.complete();
	            };
	            Table.prototype.enumerateObjectRepetition = function () {
	                var enumeration = [];
	                // Visuals are initialized with an empty data view before queries are run, therefore we need to make sure that
	                // we are resilient here when we do not have data view.
	                if (this.dataView) {
	                    TablixObjects.enumerateObjectRepetition(enumeration, this.dataView, visuals.controls.TablixType.Table);
	                }
	                return enumeration;
	            };
	            Table.prototype.shouldAllowHeaderResize = function () {
	                return this.hostServices.getViewMode() === 1 /* Edit */;
	            };
	            Table.prototype.onViewModeChanged = function (viewMode) {
	                /* Refreshes the column headers to enable/disable Column resizing */
	                this.updateViewport(this.currentViewport);
	            };
	            Table.prototype.verifyHeaderResize = function () {
	                var currentAllowHeaderResize = this.shouldAllowHeaderResize();
	                if (currentAllowHeaderResize !== this.lastAllowHeaderResize) {
	                    this.lastAllowHeaderResize = currentAllowHeaderResize;
	                    this.tablixControl.layoutManager.setAllowHeaderResize(currentAllowHeaderResize);
	                }
	            };
	            Table.preferredLoadMoreThreshold = 0.8;
	            return Table;
	        }());
	        visuals.Table = Table;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 276 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var TablixUtils = visuals.controls.internal.TablixUtils;
	        var TablixObjects = visuals.controls.internal.TablixObjects;
	        var UrlUtils = jsCommon.UrlUtils;
	        var EdgeSettings = TablixUtils.EdgeSettings;
	        var EdgeType = TablixUtils.EdgeType;
	        var MatrixVisualBodyItem = (function (_super) {
	            __extends(MatrixVisualBodyItem, _super);
	            function MatrixVisualBodyItem() {
	                _super.apply(this, arguments);
	            }
	            Object.defineProperty(MatrixVisualBodyItem.prototype, "isMeasure", {
	                get: function () {
	                    return true;
	                },
	                enumerable: true,
	                configurable: true
	            });
	            ;
	            Object.defineProperty(MatrixVisualBodyItem.prototype, "isValidUrl", {
	                get: function () {
	                    return false;
	                },
	                enumerable: true,
	                configurable: true
	            });
	            ;
	            Object.defineProperty(MatrixVisualBodyItem.prototype, "isValidImage", {
	                get: function () {
	                    return false;
	                },
	                enumerable: true,
	                configurable: true
	            });
	            ;
	            return MatrixVisualBodyItem;
	        }(TablixUtils.TablixVisualCell));
	        visuals.MatrixVisualBodyItem = MatrixVisualBodyItem;
	        /**
	         * Factory method used by unit tests.
	         */
	        function createMatrixHierarchyNavigator(matrix, isDataComplete, formatter, compositeGroupSeparator) {
	            return new MatrixHierarchyNavigator(matrix, isDataComplete, formatter, compositeGroupSeparator);
	        }
	        visuals.createMatrixHierarchyNavigator = createMatrixHierarchyNavigator;
	        var MatrixHierarchyNavigator = (function () {
	            function MatrixHierarchyNavigator(matrix, isDataComplete, formatter, compositeGroupSeparator) {
	                this.matrix = matrix;
	                this.rowHierarchy = MatrixHierarchyNavigator.wrapMatrixHierarchy(matrix.rows);
	                this.columnHierarchy = MatrixHierarchyNavigator.wrapMatrixHierarchy(matrix.columns);
	                this.formatter = formatter;
	                this.compositeGroupSeparator = compositeGroupSeparator;
	                this.isDataComplete = isDataComplete;
	                this.update();
	            }
	            /**
	             * Returns the data view matrix.
	             */
	            MatrixHierarchyNavigator.prototype.getDataViewMatrix = function () {
	                return this.matrix;
	            };
	            /**
	            * Returns the depth of the column hierarchy.
	             */
	            MatrixHierarchyNavigator.prototype.getColumnHierarchyDepth = function () {
	                return Math.max(this.columnHierarchy.levels.length, 1);
	            };
	            /**
	            * Returns the depth of the Row hierarchy.
	            */
	            MatrixHierarchyNavigator.prototype.getRowHierarchyDepth = function () {
	                return Math.max(this.rowHierarchy.levels.length, 1);
	            };
	            /**
	             * Returns the leaf count of a hierarchy.
	             */
	            MatrixHierarchyNavigator.prototype.getLeafCount = function (hierarchy) {
	                var matrixHierarchy = this.getMatrixHierarchy(hierarchy);
	                if (matrixHierarchy)
	                    return matrixHierarchy.leafNodes.length;
	                return 0;
	            };
	            /**
	             * Returns the leaf member of a hierarchy at a specified index.
	             */
	            MatrixHierarchyNavigator.prototype.getLeafAt = function (hierarchy, index) {
	                var matrixHierarchy = this.getMatrixHierarchy(hierarchy);
	                if (matrixHierarchy)
	                    return matrixHierarchy.leafNodes[index];
	                return null;
	            };
	            /**
	             * Returns the leaf index of the visual node.
	             */
	            MatrixHierarchyNavigator.prototype.getLeafIndex = function (item) {
	                debug.assertValue(item, 'item');
	                return item.leafIndex;
	            };
	            /**
	             * Returns the specified hierarchy member parent.
	             */
	            MatrixHierarchyNavigator.prototype.getParent = function (item) {
	                debug.assertValue(item, 'item');
	                // Return null for outermost nodes
	                if (item.level === 0)
	                    return null;
	                return item.parent;
	            };
	            /**
	             * Returns the index of the hierarchy member relative to its parent.
	             */
	            MatrixHierarchyNavigator.prototype.getIndex = function (item) {
	                debug.assertValue(item, 'item');
	                return item ? item.index : -1;
	            };
	            /**
	             * Checks whether a hierarchy member is a leaf.
	             */
	            MatrixHierarchyNavigator.prototype.isLeaf = function (item) {
	                debug.assertValue(item, 'item');
	                return !item.children || item.children.length === 0;
	            };
	            MatrixHierarchyNavigator.prototype.isRowHierarchyLeaf = function (item) {
	                return true;
	            };
	            MatrixHierarchyNavigator.prototype.isColumnHierarchyLeaf = function (item) {
	                return false;
	            };
	            MatrixHierarchyNavigator.prototype.isFirstItem = function (item, items) {
	                return item === _.first(items);
	            };
	            MatrixHierarchyNavigator.prototype.areAllParentsFirst = function (item, items) {
	                if (!item)
	                    return false;
	                var parent = this.getParent(item);
	                if (!parent) {
	                    return this.isFirstItem(item, item.siblings);
	                }
	                else {
	                    return this.isFirstItem(item, item.siblings) && this.areAllParentsFirst(parent, parent.siblings);
	                }
	            };
	            /**
	             * Checks whether a hierarchy member is the last item within its parent.
	             */
	            MatrixHierarchyNavigator.prototype.isLastItem = function (item, items) {
	                debug.assertValue(item, 'item');
	                if (item !== _.last(items))
	                    return false;
	                // if item is a row, we need to check that data is complete
	                return !this.isItemRow(item) || this.isDataComplete;
	            };
	            MatrixHierarchyNavigator.prototype.isItemRow = function (item) {
	                if (!item)
	                    return false;
	                var firstLevelParent = item;
	                while (firstLevelParent.parent)
	                    firstLevelParent = firstLevelParent.parent;
	                return firstLevelParent.siblings === this.rowHierarchy.root.children;
	            };
	            MatrixHierarchyNavigator.prototype.areAllParentsLast = function (item, items) {
	                if (!item)
	                    return false;
	                var parent = this.getParent(item);
	                if (!parent) {
	                    return this.isLastItem(item, item.siblings);
	                }
	                else {
	                    return this.isLastItem(item, item.siblings) && this.areAllParentsLast(parent, parent.siblings);
	                }
	            };
	            /**
	             * Gets the children members of a hierarchy member.
	             */
	            MatrixHierarchyNavigator.prototype.getChildren = function (item) {
	                debug.assertValue(item, 'item');
	                return item.children;
	            };
	            /**
	             * Gets the difference between current level and highest child's level. Can be > 1 if there are multiple values
	             * @param {MatrixVisualNode} item
	             * @returns
	             */
	            MatrixHierarchyNavigator.prototype.getChildrenLevelDifference = function (item) {
	                var diff = Infinity;
	                var children = this.getChildren(item);
	                for (var i = 0, ilen = children.length; i < ilen; i++) {
	                    diff = Math.min(diff, children[i].level - item.level);
	                }
	                return diff;
	            };
	            /**
	             * Gets the members count in a specified collection.
	             */
	            MatrixHierarchyNavigator.prototype.getCount = function (items) {
	                debug.assertValue(items, 'items');
	                return items.length;
	            };
	            /**
	             * Gets the member at the specified index.
	             */
	            MatrixHierarchyNavigator.prototype.getAt = function (items, index) {
	                debug.assertValue(items, 'items');
	                return items[index];
	            };
	            /**
	             * Gets the hierarchy member level.
	             */
	            MatrixHierarchyNavigator.prototype.getLevel = function (item) {
	                debug.assertValue(item, 'item');
	                return item.level;
	            };
	            /**
	             * Returns the intersection between a row and a column item.
	             */
	            MatrixHierarchyNavigator.prototype.getIntersection = function (rowItem, columnItem) {
	                debug.assertValue(rowItem, 'rowItem');
	                debug.assertValue(columnItem, 'columnItem');
	                var isSubtotalItem = rowItem.isSubtotal === true || columnItem.isSubtotal === true;
	                var node;
	                var valueSource;
	                var rowIndex = rowItem.leafIndex;
	                var colIndex = columnItem.leafIndex;
	                var bodyCell;
	                if (!rowItem.values) {
	                    node = undefined;
	                }
	                else {
	                    node = rowItem.values[columnItem.leafIndex];
	                }
	                if (node) {
	                    valueSource = this.matrix.valueSources[node.valueSourceIndex || 0];
	                    bodyCell = new MatrixVisualBodyItem(node.value, isSubtotalItem, valueSource, this.formatter, false);
	                }
	                else {
	                    bodyCell = new MatrixVisualBodyItem(undefined, isSubtotalItem, undefined, this.formatter, false);
	                }
	                bodyCell.position.row.index = rowIndex;
	                bodyCell.position.row.indexInSiblings = rowItem.siblings.indexOf(rowItem);
	                bodyCell.position.row.isFirst = rowIndex === 0;
	                bodyCell.position.row.isLast = this.isDataComplete && (rowIndex === this.rowHierarchy.leafNodes.length - 1);
	                bodyCell.position.column.index = colIndex;
	                bodyCell.position.column.indexInSiblings = columnItem.siblings.indexOf(columnItem);
	                bodyCell.position.column.isFirst = colIndex === 0;
	                bodyCell.position.column.isLast = colIndex === this.columnHierarchy.leafNodes.length - 1;
	                return bodyCell;
	            };
	            /**
	             * Returns the corner cell between a row and a column level.
	             */
	            MatrixHierarchyNavigator.prototype.getCorner = function (rowLevel, columnLevel) {
	                debug.assert(rowLevel >= 0, 'rowLevel');
	                debug.assert(columnLevel >= 0, 'columnLevel');
	                var columnLevels = this.columnHierarchy.levels;
	                var rowLevels = this.rowHierarchy.levels;
	                if (columnLevel === columnLevels.length - 1 || columnLevels.length === 0) {
	                    var levelSource = rowLevels[rowLevel];
	                    if (levelSource)
	                        return {
	                            metadata: levelSource.sources.length === 1 ? levelSource.sources[0] : null,
	                            displayName: _.map(levelSource.sources, function (source) { return source.displayName; }).join(this.compositeGroupSeparator),
	                            isColumnHeaderLeaf: true,
	                            isRowHeaderLeaf: rowLevel === rowLevels.length - 1,
	                        };
	                }
	                if (rowLevel === rowLevels.length - 1) {
	                    var levelSource = columnLevels[columnLevel];
	                    if (levelSource)
	                        return {
	                            metadata: levelSource.sources.length === 1 ? levelSource.sources[0] : null,
	                            displayName: _.map(levelSource.sources, function (source) { return source.displayName; }).join(this.compositeGroupSeparator),
	                            isColumnHeaderLeaf: false,
	                            isRowHeaderLeaf: true,
	                        };
	                }
	                return {
	                    metadata: null,
	                    displayName: '',
	                    isColumnHeaderLeaf: false,
	                    isRowHeaderLeaf: false,
	                };
	            };
	            MatrixHierarchyNavigator.prototype.headerItemEquals = function (item1, item2) {
	                if (item1 && item2)
	                    return (item1 === item2);
	                else
	                    return false;
	            };
	            MatrixHierarchyNavigator.prototype.bodyCellItemEquals = function (item1, item2) {
	                return (item1.position.isMatch(item2.position));
	            };
	            MatrixHierarchyNavigator.prototype.cornerCellItemEquals = function (item1, item2) {
	                var corner1 = item1;
	                var corner2 = item2;
	                if (!corner1 || !corner2)
	                    return false;
	                return corner1.displayName === corner2.displayName &&
	                    corner1.isColumnHeaderLeaf === corner2.isColumnHeaderLeaf &&
	                    corner1.isRowHeaderLeaf === corner2.isRowHeaderLeaf &&
	                    corner1.metadata === corner2.metadata;
	            };
	            MatrixHierarchyNavigator.prototype.getMatrixColumnHierarchy = function () {
	                return this.columnHierarchy;
	            };
	            MatrixHierarchyNavigator.prototype.getMatrixRowHierarchy = function () {
	                return this.rowHierarchy;
	            };
	            /**
	             * Implementation for MatrixDataAdapter interface.
	             */
	            MatrixHierarchyNavigator.prototype.update = function (dataViewMatrix, isDataComplete, updateColumns) {
	                if (updateColumns === void 0) { updateColumns = true; }
	                if (dataViewMatrix) {
	                    this.matrix = dataViewMatrix;
	                    if (isDataComplete != null)
	                        this.isDataComplete = isDataComplete;
	                    this.rowHierarchy = MatrixHierarchyNavigator.wrapMatrixHierarchy(dataViewMatrix.rows);
	                    if (updateColumns)
	                        this.columnHierarchy = MatrixHierarchyNavigator.wrapMatrixHierarchy(dataViewMatrix.columns);
	                }
	                this.updateHierarchy(this.rowHierarchy);
	                if (updateColumns) {
	                    this.updateHierarchy(this.columnHierarchy);
	                    MatrixHierarchyNavigator.updateStaticColumnHeaders(this.columnHierarchy);
	                }
	            };
	            MatrixHierarchyNavigator.wrapMatrixHierarchy = function (hierarchy) {
	                var matrixHierarchy = powerbi.Prototype.inherit(hierarchy);
	                matrixHierarchy.leafNodes = [];
	                return matrixHierarchy;
	            };
	            MatrixHierarchyNavigator.prototype.updateHierarchy = function (hierarchy) {
	                if (hierarchy.leafNodes.length > 0)
	                    hierarchy.leafNodes.length = 0;
	                if (hierarchy.root.children)
	                    this.updateRecursive(hierarchy, hierarchy.root.children, null, hierarchy.leafNodes);
	            };
	            MatrixHierarchyNavigator.prototype.updateRecursive = function (hierarchy, nodes, parent, cache) {
	                var _this = this;
	                var level;
	                var formatStringPropID = TablixObjects.PropColumnFormatString.getPropertyID();
	                for (var i = 0, ilen = nodes.length; i < ilen; i++) {
	                    var node = nodes[i];
	                    node.siblings = nodes;
	                    if (parent)
	                        node.parent = parent;
	                    if (!level)
	                        level = hierarchy.levels[node.level];
	                    if (level) {
	                        /**
	                         * Handling Composite-groups
	                         * Setting the name as the comma separated joining of the formatted strings
	                         * Setting QueryName only for non-composite groups
	                         */
	                        if (node.levelValues) {
	                            var displayNames = _.map(node.levelValues, function (component) {
	                                var source = level.sources[component.levelSourceIndex || 0];
	                                return _this.formatter(component.value, source, formatStringPropID, false);
	                            });
	                            node.valueFormatted = displayNames.join(this.compositeGroupSeparator);
	                            // Explicitly set queryName to undefined for composite groups to suppress sorting and resizing
	                            node.queryName = level.sources.length !== 1 ? undefined : level.sources[0].queryName;
	                        }
	                        else {
	                            var source = level.sources[node.levelSourceIndex || 0];
	                            node.valueFormatted = source.displayName;
	                            node.queryName = source.queryName;
	                        }
	                    }
	                    node.index = i;
	                    if (node.children && node.children.length > 0) {
	                        this.updateRecursive(hierarchy, node.children, node, cache);
	                    }
	                    else {
	                        node.leafIndex = cache.length;
	                        cache.push(node);
	                    }
	                }
	            };
	            MatrixHierarchyNavigator.updateStaticColumnHeaders = function (columnHierarchy) {
	                var columnLeafNodes = columnHierarchy.leafNodes;
	                if (columnLeafNodes && columnLeafNodes.length > 0) {
	                    var columnLeafSources = columnHierarchy.levels[columnLeafNodes[0].level].sources;
	                    for (var i = 0, ilen = columnLeafNodes.length; i < ilen; i++) {
	                        var columnLeafNode = columnLeafNodes[i];
	                        // Static leaf may need to get label from it's definition for the measures level
	                        if (!columnLeafNode.identity && _.isEmpty(columnLeafNode.levelValues)) {
	                            // We make distincion between null and undefined. Null can be considered as legit value, undefined means we need to fall back to metadata
	                            var source = columnLeafSources[columnLeafNode.levelSourceIndex ? columnLeafNode.levelSourceIndex : 0];
	                            if (source)
	                                columnLeafNode.valueFormatted = source.displayName;
	                        }
	                    }
	                }
	            };
	            MatrixHierarchyNavigator.prototype.getMatrixHierarchy = function (rootNodes) {
	                var rowHierarchyRootNodes = this.rowHierarchy.root.children;
	                if (rowHierarchyRootNodes && rootNodes === rowHierarchyRootNodes)
	                    return this.rowHierarchy;
	                var columnHierarchyRootNodes = this.columnHierarchy.root.children;
	                if (columnHierarchyRootNodes && rootNodes === columnHierarchyRootNodes)
	                    return this.columnHierarchy;
	                return null;
	            };
	            return MatrixHierarchyNavigator;
	        }());
	        var MatrixBinder = (function () {
	            function MatrixBinder(hierarchyNavigator, options) {
	                // We pass the hierarchy navigator in here because it is the object that will
	                // survive data changes and gets updated with the latest data view.
	                this.hierarchyNavigator = hierarchyNavigator;
	                this.options = options;
	            }
	            MatrixBinder.prototype.onDataViewChanged = function (formattingProperties) {
	                this.formattingProperties = formattingProperties;
	                this.updateTextHeights();
	            };
	            MatrixBinder.prototype.updateTextHeights = function () {
	                this.fontSizeHeader = jsCommon.PixelConverter.fromPointToPixel(this.formattingProperties.general.textSize);
	                this.textPropsHeader = {
	                    fontFamily: TablixUtils.FontFamilyHeader,
	                    fontSize: jsCommon.PixelConverter.toString(this.fontSizeHeader),
	                };
	                this.textHeightHeader = Math.ceil(powerbi.TextMeasurementService.measureSvgTextHeight(this.textPropsHeader, "a"));
	                this.fontSizeValue = jsCommon.PixelConverter.fromPointToPixel(this.formattingProperties.general.textSize);
	                this.textPropsValue = {
	                    fontFamily: TablixUtils.FontFamilyCell,
	                    fontSize: jsCommon.PixelConverter.toString(this.fontSizeValue),
	                };
	                this.textHeightValue = Math.ceil(powerbi.TextMeasurementService.measureSvgTextHeight(this.textPropsValue, "a"));
	                this.fontSizeTotal = jsCommon.PixelConverter.fromPointToPixel(this.formattingProperties.general.textSize);
	                this.textPropsTotal = {
	                    fontFamily: TablixUtils.FontFamilyTotal,
	                    fontSize: jsCommon.PixelConverter.toString(this.fontSizeTotal),
	                };
	                this.textHeightTotal = Math.ceil(powerbi.TextMeasurementService.measureSvgTextHeight(this.textPropsTotal, "a"));
	            };
	            MatrixBinder.prototype.onStartRenderingSession = function () {
	            };
	            MatrixBinder.prototype.onEndRenderingSession = function () {
	            };
	            /**
	             * Row Header.
	             */
	            MatrixBinder.prototype.bindRowHeader = function (item, cell) {
	                TablixUtils.resetCellCssClass(cell);
	                var cellStyle = new TablixUtils.CellStyle();
	                var isLeaf = this.hierarchyNavigator && this.hierarchyNavigator.isLeaf(item);
	                if (isLeaf) {
	                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassMatrixRowHeaderLeaf);
	                    cellStyle.borders.right = new EdgeSettings(TablixObjects.PropGridOutlineWeight.defaultValue, TablixObjects.PropGridOutlineColor.defaultValue);
	                }
	                if (item.isSubtotal) {
	                    cellStyle.paddings.left = TablixUtils.CellPaddingLeftMatrixTotal;
	                }
	                cell.contentWidth = 0;
	                this.bindHeader(item, cell, cell.extension.contentHost, this.getRowHeaderMetadata(item), cellStyle);
	                cell.contentWidth = Math.ceil(cell.contentWidth);
	                if (this.options.onBindRowHeader)
	                    this.options.onBindRowHeader(item);
	                this.setRowHeaderStyle(cell, cellStyle);
	                cell.applyStyle(cellStyle);
	            };
	            MatrixBinder.prototype.setRowHeaderStyle = function (cell, style) {
	                var propsGrid = this.formattingProperties.grid;
	                var props = this.formattingProperties.rowHeaders;
	                var propsValues = this.formattingProperties.values;
	                var propsCols = this.formattingProperties.columnHeaders;
	                style.borders.top = new EdgeSettings();
	                if (cell.position.row.isFirst) {
	                    style.borders.top.applyParams(visuals.outline.showTop(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline);
	                    // If we dont have top border, but Values have, we need to apply extra padding
	                    if (!visuals.outline.showTop(props.outline) && visuals.outline.showTop(propsValues.outline))
	                        style.paddings.top += propsGrid.outlineWeight;
	                } // else: do nothing
	                style.borders.bottom = new EdgeSettings();
	                if (cell.position.row.isLast) {
	                    style.borders.bottom.applyParams(visuals.outline.showBottom(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline);
	                    // If we dont have bottom border, but Values have, we need to apply extra padding
	                    if (!visuals.outline.showBottom(props.outline) && visuals.outline.showBottom(propsValues.outline))
	                        style.paddings.bottom += propsGrid.outlineWeight;
	                }
	                else {
	                    style.borders.bottom.applyParams(propsGrid.gridHorizontal, propsGrid.gridHorizontalWeight, propsGrid.gridHorizontalColor, EdgeType.Gridline);
	                }
	                style.borders.left = new EdgeSettings();
	                if (cell.position.column.isFirst) {
	                    style.borders.left.applyParams(visuals.outline.showLeft(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline);
	                    // If we dont have left border, but Column Headers have, we need to apply extra padding
	                    if (!visuals.outline.showLeft(props.outline) && visuals.outline.showLeft(propsCols.outline))
	                        style.paddings.left += propsGrid.outlineWeight;
	                } // else: do nothing
	                style.borders.right = new EdgeSettings();
	                if (cell.position.column.isLast) {
	                    style.borders.right.applyParams(visuals.outline.showRight(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline);
	                }
	                else {
	                    style.borders.right.applyParams(propsGrid.gridVertical, propsGrid.gridVerticalWeight, propsGrid.gridVerticalColor, EdgeType.Gridline);
	                }
	                style.fontColor = props.fontColor;
	                style.backColor = props.backColor;
	                style.paddings.top = style.paddings.bottom = propsGrid.rowPadding;
	            };
	            MatrixBinder.prototype.unbindRowHeader = function (item, cell) {
	                TablixUtils.clearCellStyle(cell);
	                TablixUtils.clearCellTextAndTooltip(cell);
	            };
	            /**
	             * Column Header.
	             */
	            MatrixBinder.prototype.bindColumnHeader = function (item, cell) {
	                TablixUtils.resetCellCssClass(cell);
	                // Set default style
	                var cellStyle = new TablixUtils.CellStyle();
	                var overwriteTotalLabel = false;
	                var cellElement = cell.extension.contentHost;
	                cell.contentWidth = 0;
	                var isLeaf = this.hierarchyNavigator && this.hierarchyNavigator.isLeaf(item);
	                if (isLeaf) {
	                    cellStyle.borders.bottom = new EdgeSettings(TablixObjects.PropGridOutlineWeight.defaultValue, TablixObjects.PropGridOutlineColor.defaultValue);
	                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixColumnHeaderLeaf);
	                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixValueNumeric);
	                    if (this.options.showSortIcons) {
	                        var sortableHeaderColumnMetadata = this.getSortableHeaderColumnMetadata(item);
	                        if (sortableHeaderColumnMetadata) {
	                            this.registerColumnHeaderClickHandler(sortableHeaderColumnMetadata, cell);
	                            cellElement = TablixUtils.addSortIconToColumnHeader(sortableHeaderColumnMetadata.sort, cellElement);
	                            if (sortableHeaderColumnMetadata.sort) {
	                                // Glyph font has all characters width/height same as font size
	                                cell.contentWidth = this.fontSizeHeader + TablixUtils.SortIconPadding;
	                            }
	                        }
	                    }
	                    // Overwrite only if the there are subtotal siblings (like in the multimeasure case), which means ALL siblings are subtotals.
	                    if (item.isSubtotal && item.parent && item.parent.children.length > 1 && item.parent.children[0].isSubtotal)
	                        overwriteTotalLabel = true;
	                }
	                cell.extension.disableDragResize();
	                this.bindHeader(item, cell, cellElement, this.getColumnHeaderMetadata(item), cellStyle, overwriteTotalLabel);
	                cell.contentWidth = Math.ceil(cell.contentWidth);
	                this.setColumnHeaderStyle(cell, cellStyle);
	                cell.applyStyle(cellStyle);
	            };
	            MatrixBinder.prototype.setColumnHeaderStyle = function (cell, style) {
	                var propsGrid = this.formattingProperties.grid;
	                var props = this.formattingProperties.columnHeaders;
	                var propsValues = this.formattingProperties.values;
	                style.fontColor = props.fontColor;
	                style.backColor = props.backColor;
	                style.paddings.top = style.paddings.bottom = propsGrid.rowPadding;
	                style.borders.top = new EdgeSettings();
	                if (cell.position.row.isFirst) {
	                    style.borders.top.applyParams(visuals.outline.showTop(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline);
	                } // else: do nothing
	                style.borders.bottom = new EdgeSettings();
	                if (cell.position.row.isLast) {
	                    style.borders.bottom.applyParams(visuals.outline.showBottom(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline);
	                }
	                else {
	                    style.borders.bottom.applyParams(propsGrid.gridHorizontal, propsGrid.gridHorizontalWeight, propsGrid.gridHorizontalColor, EdgeType.Gridline);
	                }
	                style.borders.left = new EdgeSettings();
	                if (cell.position.column.isFirst) {
	                    // If we dont have left border, but Values have, we need to apply extra padding
	                    if (!visuals.outline.showLeft(props.outline) && visuals.outline.showLeft(propsValues.outline))
	                        style.paddings.left += propsGrid.outlineWeight;
	                }
	                style.borders.right = new EdgeSettings();
	                if (cell.position.column.isLast) {
	                    style.borders.right.applyParams(visuals.outline.showRight(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline);
	                    // If we dont have right border, but Values have, we need to apply extra padding
	                    if (!visuals.outline.showRight(props.outline) && visuals.outline.showRight(propsValues.outline))
	                        style.paddings.right += propsGrid.outlineWeight;
	                }
	                else {
	                    style.borders.right.applyParams(propsGrid.gridVertical, propsGrid.gridVerticalWeight, propsGrid.gridVerticalColor, EdgeType.Gridline);
	                }
	            };
	            MatrixBinder.prototype.unbindColumnHeader = function (item, cell) {
	                TablixUtils.clearCellStyle(cell);
	                TablixUtils.clearCellTextAndTooltip(cell);
	                var sortableHeaderColumnMetadata = this.getSortableHeaderColumnMetadata(item);
	                if (sortableHeaderColumnMetadata) {
	                    this.unregisterColumnHeaderClickHandler(cell);
	                }
	                if (this.options.showSortIcons)
	                    TablixUtils.removeSortIcons(cell);
	            };
	            MatrixBinder.prototype.bindHeader = function (item, cell, cellElement, metadata, style, overwriteSubtotalLabel) {
	                TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixHeader);
	                style.fontFamily = TablixUtils.FontFamilyHeader;
	                style.fontColor = TablixUtils.FontColorHeaders;
	                var imgHeight = this.formattingProperties.grid.imageHeight;
	                if (visuals.converterHelper.isImageUrlColumn(metadata))
	                    cell.contentHeight = imgHeight;
	                else if (item.isSubtotal)
	                    cell.contentHeight = this.textHeightTotal;
	                else
	                    cell.contentHeight = this.textHeightValue;
	                if (item.isSubtotal) {
	                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixValueTotal);
	                    style.fontFamily = TablixUtils.FontFamilyTotal;
	                    if (!overwriteSubtotalLabel) {
	                        TablixUtils.setCellTextAndTooltip(this.options.totalLabel, cellElement, cell.extension.contentHost);
	                        cell.contentWidth = powerbi.TextMeasurementService.measureSvgTextWidth(this.textPropsTotal, this.options.totalLabel);
	                        return;
	                    }
	                }
	                var value = this.getHeaderLabel(item);
	                // If item is empty text, set text to a space to maintain height
	                if (!value) {
	                    cellElement.innerHTML = TablixUtils.StringNonBreakingSpace;
	                    // Keep cell.width assigned as 0
	                    return;
	                }
	                // if item is a Valid URL, set an Anchor tag
	                if (visuals.converterHelper.isWebUrlColumn(metadata) && UrlUtils.isValidUrl(value)) {
	                    TablixUtils.appendATagToBodyCell(value, cellElement);
	                    cell.contentWidth += powerbi.TextMeasurementService.measureSvgTextWidth(this.textPropsHeader, value);
	                    return;
	                }
	                // if item is an Image, if it's valid create an Img tag, if not insert text
	                if (visuals.converterHelper.isImageUrlColumn(metadata) && UrlUtils.isValidImageUrl(value)) {
	                    TablixUtils.appendImgTagToBodyCell(item.valueFormatted, cellElement, imgHeight);
	                    cell.contentWidth += imgHeight * TablixUtils.ImageDefaultAspectRatio;
	                    return;
	                }
	                // if item is text, insert it
	                TablixUtils.setCellTextAndTooltip(value, cellElement, cell.extension.contentHost);
	                cell.contentWidth += powerbi.TextMeasurementService.measureSvgTextWidth(item.isSubtotal ? this.textPropsTotal : this.textPropsHeader, value);
	            };
	            MatrixBinder.prototype.registerColumnHeaderClickHandler = function (columnMetadata, cell) {
	                var _this = this;
	                if (this.options.onColumnHeaderClick) {
	                    var handler = function (e) {
	                        if (TablixUtils.isValidSortClick(e)) {
	                            var sortDirection = TablixUtils.reverseSort(columnMetadata.sort);
	                            _this.options.onColumnHeaderClick(columnMetadata.queryName ? columnMetadata.queryName : columnMetadata.displayName, sortDirection);
	                        }
	                    };
	                    cell.extension.registerClickHandler(handler);
	                }
	            };
	            MatrixBinder.prototype.unregisterColumnHeaderClickHandler = function (cell) {
	                if (this.options.onColumnHeaderClick) {
	                    cell.extension.unregisterClickHandler();
	                }
	            };
	            /**
	             * Body Cell.
	             */
	            MatrixBinder.prototype.bindBodyCell = function (item, cell) {
	                TablixUtils.resetCellCssClass(cell);
	                var cellStyle = new TablixUtils.CellStyle();
	                cell.contentHeight = this.textHeightValue;
	                var kpi = item.kpiContent;
	                if (kpi) {
	                    $(cell.extension.contentHost).append(kpi);
	                    // Glyph font has all characters width/height same as font size
	                    cell.contentWidth = this.fontSizeValue;
	                }
	                else {
	                    var textProps = this.textPropsValue;
	                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixValueNumeric);
	                    if (item.isTotal) {
	                        TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixValueTotal);
	                        cellStyle.fontFamily = TablixUtils.FontFamilyTotal;
	                        cell.contentHeight = this.textHeightTotal;
	                        textProps = this.textPropsTotal;
	                    }
	                    var textContent = item.textContent;
	                    if (textContent) {
	                        TablixUtils.setCellTextAndTooltip(textContent, cell.extension.contentHost);
	                        cell.contentWidth = powerbi.TextMeasurementService.measureSvgTextWidth(textProps, textContent);
	                    }
	                }
	                cell.contentWidth = Math.ceil(cell.contentWidth);
	                this.setBodyCellStyle(cell, item, cellStyle);
	                cell.applyStyle(cellStyle);
	            };
	            MatrixBinder.prototype.setBodyCellStyle = function (cell, item, style) {
	                var propsGrid = this.formattingProperties.grid;
	                var props = this.formattingProperties.values;
	                var propsTotal = this.formattingProperties.subtotals;
	                var propsRows = this.formattingProperties.rowHeaders;
	                var propsColumns = this.formattingProperties.columnHeaders;
	                style.paddings.top = style.paddings.bottom = propsGrid.rowPadding;
	                style.borders.top = new EdgeSettings();
	                if (cell.position.row.isFirst) {
	                    style.borders.top.applyParams(visuals.outline.showTop(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline);
	                    // If we dont have top border, but Row Headers have, we need to apply extra padding
	                    if (!visuals.outline.showTop(props.outline) && visuals.outline.showTop(propsRows.outline))
	                        style.paddings.top += propsGrid.outlineWeight;
	                } // else: do nothing
	                style.borders.bottom = new EdgeSettings();
	                if (cell.position.row.isLast) {
	                    style.borders.bottom.applyParams(visuals.outline.showBottom(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline);
	                    // If we dont have bottom border, but Row Headers have, we need to apply extra padding
	                    if (!visuals.outline.showBottom(props.outline) && visuals.outline.showBottom(propsRows.outline))
	                        style.paddings.bottom += propsGrid.outlineWeight;
	                }
	                else {
	                    style.borders.bottom.applyParams(propsGrid.gridHorizontal, propsGrid.gridHorizontalWeight, propsGrid.gridHorizontalColor);
	                }
	                style.borders.left = new EdgeSettings();
	                if (cell.position.column.isFirst) {
	                    style.borders.left.applyParams(visuals.outline.showLeft(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline);
	                } // else: do nothing
	                style.borders.right = new EdgeSettings();
	                if (cell.position.column.isLast) {
	                    style.borders.right.applyParams(visuals.outline.showRight(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline);
	                    // If we dont have right border, but Column Headers have, we need to apply extra padding
	                    if (!visuals.outline.showRight(props.outline) && visuals.outline.showRight(propsColumns.outline))
	                        style.paddings.right += propsGrid.outlineWeight;
	                }
	                else {
	                    style.borders.right.applyParams(propsGrid.gridVertical, propsGrid.gridVerticalWeight, propsGrid.gridVerticalColor, EdgeType.Gridline);
	                }
	                var rowBandingIndex;
	                if (this.formattingProperties.general.rowSubtotals && propsTotal.backColor)
	                    rowBandingIndex = item.position.row.indexInSiblings;
	                else
	                    rowBandingIndex = item.position.row.index;
	                if (item.isTotal && propsTotal.fontColor) {
	                    style.fontColor = propsTotal.fontColor;
	                }
	                else {
	                    style.fontColor = rowBandingIndex % 2 === 0 ? props.fontColorPrimary : props.fontColorSecondary;
	                }
	                if (item.isTotal && propsTotal.backColor) {
	                    style.backColor = propsTotal.backColor;
	                }
	                else {
	                    style.backColor = rowBandingIndex % 2 === 0 ? props.backColorPrimary : props.backColorSecondary;
	                }
	            };
	            MatrixBinder.prototype.unbindBodyCell = function (item, cell) {
	                TablixUtils.clearCellStyle(cell);
	                TablixUtils.clearCellTextAndTooltip(cell);
	            };
	            /**
	             * Corner Cell.
	             */
	            MatrixBinder.prototype.bindCornerCell = function (item, cell) {
	                TablixUtils.resetCellCssClass(cell);
	                var cellStyle = new TablixUtils.CellStyle();
	                cellStyle.fontFamily = TablixUtils.FontFamilyHeader;
	                cellStyle.fontColor = TablixUtils.FontColorHeaders;
	                cell.contentHeight = this.textHeightHeader;
	                cell.contentWidth = 0;
	                var cellElement = cell.extension.contentHost;
	                if (item.isColumnHeaderLeaf) {
	                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixColumnHeaderLeaf);
	                    cellStyle.borders.bottom = new EdgeSettings(TablixObjects.PropGridOutlineWeight.defaultValue, TablixObjects.PropGridOutlineColor.defaultValue);
	                    if (this.options.showSortIcons) {
	                        var cornerHeaderMetadata = this.getSortableCornerColumnMetadata(item);
	                        if (cornerHeaderMetadata) {
	                            this.registerColumnHeaderClickHandler(cornerHeaderMetadata, cell);
	                            cellElement = TablixUtils.addSortIconToColumnHeader((cornerHeaderMetadata ? cornerHeaderMetadata.sort : undefined), cellElement);
	                            if (cornerHeaderMetadata.sort) {
	                                // Glyph font has all characters width/height same as font size
	                                cell.contentWidth = this.fontSizeHeader + TablixUtils.SortIconPadding;
	                            }
	                        }
	                    }
	                }
	                TablixUtils.setCellTextAndTooltip(item.displayName, cellElement, cell.extension.contentHost);
	                cell.contentWidth += powerbi.TextMeasurementService.measureSvgTextWidth(this.textPropsHeader, item.displayName);
	                cell.contentWidth = Math.ceil(cell.contentWidth);
	                if (item.isRowHeaderLeaf) {
	                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassMatrixRowHeaderLeaf);
	                }
	                TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixHeader);
	                this.setCornerCellsStyle(cell, cellStyle);
	                cell.applyStyle(cellStyle);
	                cell.extension.disableDragResize();
	            };
	            MatrixBinder.prototype.setCornerCellsStyle = function (cell, style) {
	                var propsGrid = this.formattingProperties.grid;
	                var propsCol = this.formattingProperties.columnHeaders;
	                var propsRow = this.formattingProperties.rowHeaders;
	                style.fontColor = propsCol.fontColor || propsRow.fontColor;
	                style.backColor = propsCol.backColor || propsRow.backColor;
	                style.paddings.top = style.paddings.bottom = propsGrid.rowPadding;
	                style.borders.top = new EdgeSettings();
	                if (cell.position.row.isFirst) {
	                    style.borders.top.applyParams(visuals.outline.showTop(propsCol.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline);
	                } // else: do nothing
	                style.borders.bottom = new EdgeSettings();
	                if (cell.position.row.isLast) {
	                    style.borders.bottom.applyParams(visuals.outline.showBottom(propsCol.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline);
	                }
	                else {
	                    style.borders.bottom.applyParams(propsGrid.gridHorizontal, propsGrid.gridHorizontalWeight, propsGrid.gridHorizontalColor, EdgeType.Gridline);
	                }
	                style.borders.left = new EdgeSettings();
	                if (cell.position.column.isFirst) {
	                    style.borders.left.applyParams(visuals.outline.showLeft(propsCol.outline), propsGrid.outlineWeight, propsGrid.outlineColor, EdgeType.Outline);
	                    // If we dont have left border, but Row Headers have, we need to apply extra padding
	                    if (!visuals.outline.showLeft(propsCol.outline) && visuals.outline.showLeft(propsRow.outline))
	                        style.paddings.left += propsGrid.outlineWeight;
	                } // else: do nothing
	                style.borders.right = new EdgeSettings();
	                style.borders.right.applyParams(propsGrid.gridVertical, propsGrid.gridVerticalWeight, propsGrid.gridVerticalColor, EdgeType.Gridline);
	            };
	            MatrixBinder.prototype.unbindCornerCell = function (item, cell) {
	                TablixUtils.clearCellStyle(cell);
	                TablixUtils.clearCellTextAndTooltip(cell);
	                if (this.options.showSortIcons)
	                    TablixUtils.removeSortIcons(cell);
	                if (item.isColumnHeaderLeaf) {
	                    this.unregisterColumnHeaderClickHandler(cell);
	                }
	            };
	            MatrixBinder.prototype.bindEmptySpaceHeaderCell = function (cell) {
	            };
	            MatrixBinder.prototype.unbindEmptySpaceHeaderCell = function (cell) {
	            };
	            MatrixBinder.prototype.bindEmptySpaceFooterCell = function (cell) {
	            };
	            MatrixBinder.prototype.unbindEmptySpaceFooterCell = function (cell) {
	            };
	            /**
	             * Measurement Helper.
	             */
	            MatrixBinder.prototype.getHeaderLabel = function (item) {
	                return item.valueFormatted;
	            };
	            MatrixBinder.prototype.getCellContent = function (item) {
	                return item.textContent || '';
	            };
	            MatrixBinder.prototype.hasRowGroups = function () {
	                // Figure out whether we have a static row header, i.e., not row groups
	                var dataView = this.hierarchyNavigator.getDataViewMatrix();
	                if (!dataView || !dataView.rows || !dataView.rows.levels || dataView.rows.levels.length === 0)
	                    return false;
	                return true;
	            };
	            /**
	             * Returns the column metadata of the column that needs to be sorted for the specified matrix corner node.
	             *
	             * @return Column metadata or null if the specified corner node does not represent a sortable header.
	             */
	            MatrixBinder.prototype.getSortableCornerColumnMetadata = function (item) {
	                if (item.isColumnHeaderLeaf)
	                    return item.metadata;
	            };
	            MatrixBinder.prototype.getRowHeaderMetadata = function (item) {
	                if (!this.hierarchyNavigator || !item)
	                    return;
	                var dataView = this.hierarchyNavigator.getDataViewMatrix();
	                if (!dataView || !dataView.rows)
	                    return;
	                return this.getHierarchyMetadata(dataView.rows, item.level);
	            };
	            MatrixBinder.prototype.getColumnHeaderMetadata = function (item) {
	                if (!this.hierarchyNavigator || !item)
	                    return;
	                var dataView = this.hierarchyNavigator.getDataViewMatrix();
	                if (!dataView || !dataView.columns)
	                    return;
	                return this.getHierarchyMetadata(dataView.columns, item.level);
	            };
	            MatrixBinder.prototype.getHierarchyMetadata = function (hierarchy, level) {
	                if (!hierarchy || !hierarchy.levels || hierarchy.levels.length < level)
	                    return;
	                var levelInfo = hierarchy.levels[level];
	                if (!levelInfo || !levelInfo.sources || levelInfo.sources.length === 0)
	                    return;
	                // This assumes the source will always be the first item in the array of sources.
	                return levelInfo.sources[0];
	            };
	            /**
	             * Returns the column metadata of the column that needs to be sorted for the specified header node.
	             *
	             * @return Column metadata or null if the specified header node does not represent a sortable header.
	             */
	            MatrixBinder.prototype.getSortableHeaderColumnMetadata = function (item) {
	                var dataView = this.hierarchyNavigator.getDataViewMatrix();
	                // If there are no row groups, sorting is not supported (as it does not make sense).
	                if (!dataView.rows || !dataView.rows.levels || dataView.rows.levels.length === 0)
	                    return null;
	                var isMultiMeasure = dataView.valueSources && dataView.valueSources.length > 1;
	                var columnGroupCount = dataView.columns ? dataView.columns.levels.length : 0;
	                // If we have multiple values, they establish an extra level, so need to subtract 1
	                if (isMultiMeasure) {
	                    columnGroupCount--;
	                }
	                else if (columnGroupCount === 1 &&
	                    dataView.columns.levels[0] &&
	                    dataView.columns.levels[0].sources && dataView.columns.levels[0].sources[0] &&
	                    dataView.columns.levels[0].sources[0].roles && dataView.columns.levels[0].sources[0].roles["Values"]) {
	                    columnGroupCount = 0;
	                }
	                var valueIndex = -1;
	                if (columnGroupCount === 0) {
	                    // Matrices without column groups, support sorting on all columns (which are then measure columns).
	                    valueIndex = item.levelSourceIndex;
	                }
	                else if (item.isSubtotal) {
	                    // Matrices with column groups support sorting only on the column grand total.
	                    if (isMultiMeasure) {
	                        // In the multi-measure case we need to check if the parent's level is 0 in order
	                        // to determine whether this is the column grand total.  The cells are layed out such
	                        // that the clickable cells are at the innermost level, but the parent for the column
	                        // grand total will have level 0.
	                        if (item.parent && item.parent.level === 0)
	                            valueIndex = item.levelSourceIndex;
	                    }
	                    else {
	                        // In the single-measure case we can directly check the level of the subtotal to
	                        // detect the column grand total (at level 0).
	                        if (item.level === 0)
	                            valueIndex = item.levelSourceIndex;
	                    }
	                }
	                if (valueIndex !== -1) {
	                    // NOTE: if the valueIndex is undefined it implicitly means that it is 0 based on the 
	                    //       visual node contract
	                    valueIndex = valueIndex ? valueIndex : 0;
	                    return dataView.valueSources[valueIndex];
	                }
	                return null;
	            };
	            return MatrixBinder;
	        }());
	        visuals.MatrixBinder = MatrixBinder;
	        var Matrix = (function () {
	            function Matrix(options) {
	                if (options) {
	                    this.isTouchEnabled = options.isTouchEnabled;
	                }
	            }
	            Matrix.customizeQuery = function (options) {
	                var dataViewMapping = options.dataViewMappings[0];
	                if (!dataViewMapping || !dataViewMapping.matrix || !dataViewMapping.metadata)
	                    return;
	                var dataViewMatrix = dataViewMapping.matrix;
	                // If Columns Hierarchy is not empty, set Window DataReduction Count to 100
	                if (!_.isEmpty(dataViewMatrix.columns.for.in.items)) {
	                    dataViewMatrix.rows.dataReductionAlgorithm.window.count = 100;
	                }
	                var objects = dataViewMapping.metadata.objects;
	                dataViewMatrix.rows.for.in.subtotalType = TablixObjects.shouldShowRowSubtotals(objects) ? 2 /* After */ : 0 /* None */;
	                dataViewMatrix.columns.for.in.subtotalType = TablixObjects.shouldShowColumnSubtotals(objects) ? 2 /* After */ : 0 /* None */;
	            };
	            Matrix.getSortableRoles = function () {
	                return ['Rows', 'Values'];
	            };
	            Matrix.prototype.init = function (options) {
	                this.element = options.element;
	                this.style = options.style;
	                this.updateViewport(options.viewport);
	                this.formatter = visuals.valueFormatter.formatVariantMeasureValue;
	                this.isInteractive = options.interactivity && options.interactivity.selection != null;
	                this.hostServices = options.host;
	                this.persistingObjects = false;
	                this.waitingForData = false;
	                this.lastAllowHeaderResize = true;
	                this.waitingForSort = false;
	            };
	            Matrix.converter = function (dataView) {
	                debug.assertValue(dataView, 'dataView');
	                return TablixObjects.getMatrixObjects(dataView);
	            };
	            Matrix.prototype.onResizing = function (finalViewport) {
	                this.updateViewport(finalViewport);
	            };
	            /*
	            Public for testing
	            */
	            Matrix.prototype.getColumnWidthManager = function () {
	                return this.columnWidthManager;
	            };
	            Matrix.prototype.onDataChanged = function (options) {
	                debug.assertValue(options, 'options');
	                var dataViews = options.dataViews;
	                if (dataViews && dataViews.length > 0) {
	                    var previousDataView = this.dataView;
	                    this.dataView = dataViews[0];
	                    // We don't check for persisting flag
	                    // Any change to the Column Widths need to go through to update all column group instances
	                    // ToDo: Consider not resetting scrollbar everytime
	                    var formattingProperties = Matrix.converter(this.dataView);
	                    var textSize = formattingProperties.general.textSize;
	                    if (options.operationKind === powerbi.VisualDataChangeOperationKind.Append) {
	                        // If Root for Rows or Columns has changed by the DataViewTransform (e.g. when having reorders in values)
	                        var rootChanged = previousDataView.matrix.rows.root !== this.dataView.matrix.rows.root;
	                        this.createOrUpdateHierarchyNavigator(rootChanged);
	                        if (rootChanged)
	                            this.tablixControl.updateModels(/*resetScrollOffsets*/ false, this.dataView.matrix.rows.root.children, this.dataView.matrix.columns.root.children);
	                        this.refreshControl(/*clear*/ false);
	                    }
	                    else {
	                        this.createOrUpdateHierarchyNavigator(true);
	                        this.createColumnWidthManager();
	                        this.createTablixControl(textSize);
	                        var binder = this.tablixControl.getBinder();
	                        binder.onDataViewChanged(formattingProperties);
	                        this.updateInternal(textSize, previousDataView);
	                    }
	                }
	                this.waitingForData = false;
	                this.waitingForSort = false;
	            };
	            Matrix.prototype.createColumnWidthManager = function () {
	                var _this = this;
	                var columnHierarchy = this.hierarchyNavigator.getMatrixColumnHierarchy();
	                if (!this.columnWidthManager) {
	                    this.columnWidthManager = new visuals.controls.TablixColumnWidthManager(this.dataView, true /* isMatrix */, function (objectInstances) { return _this.persistColumnWidths(objectInstances); }, columnHierarchy.leafNodes);
	                }
	                else if (!this.persistingObjects) {
	                    this.columnWidthManager.updateDataView(this.dataView, columnHierarchy.leafNodes);
	                }
	            };
	            Matrix.prototype.persistColumnWidths = function (objectInstances) {
	                this.persistingObjects = true;
	                this.hostServices.persistProperties(objectInstances);
	            };
	            Matrix.prototype.updateViewport = function (newViewport) {
	                this.currentViewport = newViewport;
	                if (this.tablixControl) {
	                    this.tablixControl.viewport = this.currentViewport;
	                    this.verifyHeaderResize();
	                    this.refreshControl(/*clear*/ false);
	                }
	            };
	            Matrix.prototype.refreshControl = function (clear) {
	                if (visuals.visibilityHelper.partiallyVisible(this.element) || this.getLayoutKind() === 1 /* DashboardTile */) {
	                    this.tablixControl.refresh(clear);
	                }
	            };
	            Matrix.prototype.getLayoutKind = function () {
	                return this.isInteractive ? 0 /* Canvas */ : 1 /* DashboardTile */;
	            };
	            Matrix.prototype.createOrUpdateHierarchyNavigator = function (rootChanged) {
	                var isDataComplete = !this.dataView.metadata.segment;
	                if (!this.tablixControl) {
	                    var matrixNavigator = createMatrixHierarchyNavigator(this.dataView.matrix, isDataComplete, this.formatter, this.hostServices.getLocalizedString('ListJoin_Separator'));
	                    this.hierarchyNavigator = matrixNavigator;
	                }
	                else {
	                    this.hierarchyNavigator.update(this.dataView.matrix, isDataComplete, rootChanged);
	                }
	            };
	            Matrix.prototype.createTablixControl = function (textSize) {
	                if (!this.tablixControl) {
	                    // Create the control
	                    this.tablixControl = this.createControl(this.hierarchyNavigator, textSize);
	                }
	            };
	            Matrix.prototype.createControl = function (matrixNavigator, textSize) {
	                var _this = this;
	                var layoutKind = this.getLayoutKind();
	                var matrixBinderOptions = {
	                    onBindRowHeader: function (item) { _this.onBindRowHeader(item); },
	                    totalLabel: this.hostServices.getLocalizedString(Matrix.TotalLabel),
	                    onColumnHeaderClick: function (queryName, sortDirection) { return _this.onColumnHeaderClick(queryName, sortDirection); },
	                    showSortIcons: layoutKind === 0 /* Canvas */,
	                };
	                var matrixBinder = new MatrixBinder(this.hierarchyNavigator, matrixBinderOptions);
	                var layoutManager = layoutKind === 1 /* DashboardTile */
	                    ? visuals.controls.internal.DashboardTablixLayoutManager.createLayoutManager(matrixBinder)
	                    : visuals.controls.internal.CanvasTablixLayoutManager.createLayoutManager(matrixBinder, this.columnWidthManager);
	                var tablixContainer = document.createElement('div');
	                this.element.append(tablixContainer);
	                var tablixOptions = {
	                    interactive: this.isInteractive,
	                    enableTouchSupport: this.isTouchEnabled,
	                    layoutKind: layoutKind,
	                    fontSize: TablixObjects.getTextSizeInPx(textSize),
	                };
	                return new visuals.controls.TablixControl(matrixNavigator, layoutManager, matrixBinder, tablixContainer, tablixOptions);
	            };
	            Matrix.prototype.updateInternal = function (textSize, previousDataView) {
	                var _this = this;
	                if (this.getLayoutKind() === 1 /* DashboardTile */) {
	                    this.tablixControl.layoutManager.adjustContentSize(visuals.converterHelper.hasImageUrlColumn(this.dataView));
	                }
	                this.tablixControl.fontSize = TablixObjects.getTextSizeInPx(textSize);
	                this.verifyHeaderResize();
	                /* To avoid resetting scrollbar every time we persist Objects. If:
	                * AutoSizeColumns options was flipped
	                * A Column was resized manually
	                * A Column was auto-sized
	                */
	                // Update models before the viewport to make sure column widths are computed correctly
	                // if a persisting operation is going, don't reset the scrollbar (column resize)
	                this.tablixControl.updateModels(/*resetScrollOffsets*/ !this.persistingObjects, this.dataView.matrix.rows.root.children, this.dataView.matrix.columns.root.children);
	                this.tablixControl.viewport = this.currentViewport;
	                var shouldClearControl = this.shouldClearControl(previousDataView, this.dataView);
	                // We need the layout for the DIV to be done so that the control can measure items correctly.
	                setTimeout(function () {
	                    // Render
	                    _this.refreshControl(shouldClearControl);
	                    var widthChanged = _this.columnWidthManager.onColumnsRendered(_this.tablixControl.layoutManager.columnWidthsToPersist);
	                    // At this point, all columns are rendered with proper width
	                    // Resetting the flag unless any unknown columnn width was persisted
	                    if (_this.persistingObjects && !widthChanged) {
	                        _this.persistingObjects = false;
	                    }
	                }, 0);
	            };
	            Matrix.prototype.shouldClearControl = function (previousDataView, newDataView) {
	                if (!this.waitingForSort || !previousDataView || !newDataView)
	                    return true;
	                // ToDo: Get better criteria
	                return !powerbi.DataViewAnalysis.isMetadataEquivalent(previousDataView.metadata, newDataView.metadata);
	            };
	            Matrix.prototype.onBindRowHeader = function (item) {
	                if (this.needsMoreData(item)) {
	                    this.hostServices.loadMoreData();
	                    this.waitingForData = true;
	                }
	            };
	            Matrix.prototype.onColumnHeaderClick = function (queryName, sortDirection) {
	                this.waitingForSort = true;
	                this.hostServices.onCustomSort(TablixUtils.getCustomSortEventArgs(queryName, sortDirection));
	            };
	            /**
	             * Note: Public for testability.
	             */
	            Matrix.prototype.needsMoreData = function (item) {
	                if (this.waitingForData || !this.hierarchyNavigator.isLeaf(item) || !this.dataView.metadata || !this.dataView.metadata.segment)
	                    return false;
	                var leafCount = this.tablixControl.rowDimension.getItemsCount();
	                var loadMoreThreshold = leafCount * Matrix.preferredLoadMoreThreshold;
	                return this.hierarchyNavigator.getLeafIndex(item) >= loadMoreThreshold;
	            };
	            Matrix.prototype.enumerateObjectInstances = function (options) {
	                var enumeration = new visuals.ObjectEnumerationBuilder();
	                // Visuals are initialized with an empty data view before queries are run, therefore we need to make sure that
	                // we are resilient here when we do not have data view.
	                if (this.dataView) {
	                    TablixObjects.enumerateObjectInstances(options, enumeration, this.dataView, visuals.controls.TablixType.Matrix);
	                }
	                return enumeration.complete();
	            };
	            Matrix.prototype.shouldAllowHeaderResize = function () {
	                return this.hostServices.getViewMode() === 1 /* Edit */;
	            };
	            Matrix.prototype.onViewModeChanged = function (viewMode) {
	                /* Refreshes the column headers to enable/disable Column resizing */
	                this.updateViewport(this.currentViewport);
	            };
	            Matrix.prototype.verifyHeaderResize = function () {
	                var currentAllowHeaderResize = this.shouldAllowHeaderResize();
	                if (currentAllowHeaderResize !== this.lastAllowHeaderResize) {
	                    this.lastAllowHeaderResize = currentAllowHeaderResize;
	                    this.tablixControl.layoutManager.setAllowHeaderResize(currentAllowHeaderResize);
	                }
	            };
	            Matrix.preferredLoadMoreThreshold = 0.8;
	            /**
	             * Note: Public only for testing.
	             */
	            Matrix.TotalLabel = 'TableTotalLabel';
	            return Matrix;
	        }());
	        visuals.Matrix = Matrix;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 277 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var CssConstants = jsCommon.CssConstants;
	        /**
	         * Renders an interactive treemap visual from categorical data.
	         */
	        var Treemap = (function () {
	            function Treemap(options) {
	                this.tooltipsEnabled = options && options.tooltipsEnabled;
	                this.tooltipBucketEnabled = options && options.tooltipBucketEnabled;
	                if (options && options.animator) {
	                    this.animator = options.animator;
	                    this.isScrollable = options.isScrollable ? options.isScrollable : false;
	                    this.behavior = options.behavior;
	                }
	            }
	            Treemap.getLayout = function (labelsSettings, alternativeScale) {
	                var formattersCache = visuals.dataLabelUtils.createColumnFormatterCacheManager();
	                var majorLabelsEnabled = labelsSettings.showCategory;
	                var minorLabelsEnabled = labelsSettings.show || labelsSettings.showCategory;
	                return {
	                    shapeClass: function (d) { return Treemap.getNodeClass(d, false); },
	                    shapeLayout: Treemap.createTreemapShapeLayout(false),
	                    highlightShapeClass: function (d) { return Treemap.getNodeClass(d, true); },
	                    highlightShapeLayout: Treemap.createTreemapShapeLayout(true),
	                    zeroShapeLayout: Treemap.createTreemapZeroShapeLayout(),
	                    majorLabelClass: function (d) { return Treemap.MajorLabelClassName; },
	                    majorLabelLayout: {
	                        x: function (d) { return d.x + Treemap.TextMargin; },
	                        y: function (d) { return d.y + Treemap.TextMargin + Treemap.MajorLabelTextSize; },
	                    },
	                    majorLabelText: function (d) { return Treemap.createMajorLabelText(d, labelsSettings, alternativeScale, formattersCache); },
	                    minorLabelClass: function (d) { return Treemap.MinorLabelClassName; },
	                    minorLabelLayout: {
	                        x: function (d) { return d.x + Treemap.TextMargin; },
	                        y: function (d) { return d.y + d.dy - Treemap.TextMargin; },
	                    },
	                    minorLabelText: function (d) { return Treemap.createMinorLabelText(d, labelsSettings, alternativeScale, formattersCache); },
	                    areMajorLabelsEnabled: function () { return majorLabelsEnabled; },
	                    areMinorLabelsEnabled: function () { return minorLabelsEnabled; },
	                };
	            };
	            Treemap.prototype.init = function (options) {
	                this.options = options;
	                var element = options.element;
	                // Ensure viewport is empty on init
	                element.empty();
	                this.svg = d3.select(element.get(0))
	                    .append('svg')
	                    .style('position', 'absolute')
	                    .classed(Treemap.ClassName, true);
	                this.shapeGraphicsContext = this.svg
	                    .append('g')
	                    .classed(Treemap.ShapesClassName, true);
	                this.labelGraphicsContext = this.svg
	                    .append('g')
	                    .classed(Treemap.LabelsGroupClassName, true);
	                this.element = element;
	                // avoid deep copy
	                this.currentViewport = {
	                    height: options.viewport.height,
	                    width: options.viewport.width,
	                };
	                this.style = options.style;
	                this.treemap = d3.layout.treemap()
	                    .sticky(false)
	                    .sort(function (a, b) { return a.size - b.size; })
	                    .value(function (d) { return d.size; })
	                    .round(false);
	                if (this.behavior) {
	                    this.interactivityService = visuals.createInteractivityService(options.host);
	                }
	                this.legend = visuals.createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, this.interactivityService, this.isScrollable);
	                this.colors = this.style.colorPalette.dataColors;
	                this.hostService = options.host;
	            };
	            /**
	             * Note: Public for testing purposes.
	             */
	            Treemap.converter = function (dataView, colors, labelSettings, interactivityService, viewport, legendObjectProperties, tooltipsEnabled, tooltipBucketEnabled) {
	                if (tooltipsEnabled === void 0) { tooltipsEnabled = true; }
	                var reader = powerbi.data.createIDataViewCategoricalReader(dataView);
	                var hasNegativeValues;
	                var allValuesAreNegative;
	                var rootNode = {
	                    key: "root",
	                    name: "root",
	                    originalValue: undefined,
	                    children: [],
	                    selected: false,
	                    highlightMultiplier: 0,
	                    identity: visuals.SelectionId.createNull(),
	                    color: undefined,
	                };
	                var allNodes = [];
	                var hasHighlights;
	                var legendDataPoints = [];
	                var legendTitle = "";
	                var colorHelper = new visuals.ColorHelper(colors, visuals.treemapProps.dataPoint.fill);
	                var dataWasCulled = undefined;
	                if (dataView && dataView.metadata && dataView.metadata.objects) {
	                    var objects = dataView.metadata.objects;
	                    labelSettings.show = powerbi.DataViewObjects.getValue(objects, visuals.treemapProps.labels.show, labelSettings.show);
	                    labelSettings.labelColor = powerbi.DataViewObjects.getFillColor(objects, visuals.treemapProps.labels.color, labelSettings.labelColor);
	                    labelSettings.displayUnits = powerbi.DataViewObjects.getValue(objects, visuals.treemapProps.labels.labelDisplayUnits, labelSettings.displayUnits);
	                    labelSettings.precision = powerbi.DataViewObjects.getValue(objects, visuals.treemapProps.labels.labelPrecision, labelSettings.precision);
	                    labelSettings.showCategory = powerbi.DataViewObjects.getValue(objects, visuals.treemapProps.categoryLabels.show, labelSettings.showCategory);
	                }
	                // If we values or a gradient, render the tree map
	                if (reader.hasValues(visuals.treemapRoles.values) || reader.hasValues(visuals.treemapRoles.gradient)) {
	                    // If we don't have a values column, but do have a gradient one, use that as values
	                    var valueColumnRoleName = reader.hasValues(visuals.treemapRoles.values) ? visuals.treemapRoles.values : visuals.treemapRoles.gradient;
	                    var categorical = dataView.categorical;
	                    hasHighlights = reader.hasHighlights(valueColumnRoleName);
	                    var formatStringProp = visuals.treemapProps.general.formatString;
	                    var result = Treemap.getValuesFromCategoricalDataView(dataView, hasHighlights, valueColumnRoleName);
	                    var values = result.values;
	                    var highlights = result.highlights;
	                    var totalValue = result.totalValue;
	                    if (result.highlightsOverflow) {
	                        hasHighlights = false;
	                        values = highlights;
	                    }
	                    hasNegativeValues = result.hasNegativeValues;
	                    allValuesAreNegative = result.allValuesAreNegative;
	                    var cullableValue = Treemap.getCullableValue(totalValue, viewport);
	                    var hasDynamicSeries = reader.hasDynamicSeries();
	                    dataWasCulled = false;
	                    var gradientValueColumn = reader.getValueColumn(visuals.treemapRoles.gradient, 0); // Gradient is only used if we have only one series or series are nondynamic (and therefore don't affect gradient)
	                    if ((categorical.categories == null) && !_.isEmpty(values)) {
	                        // No categories, sliced by series and measures
	                        for (var seriesIndex = 0, seriesCount = reader.getSeriesCount(valueColumnRoleName); seriesIndex < seriesCount; seriesIndex++) {
	                            var valueColumn = reader.getValueColumn(valueColumnRoleName, seriesIndex);
	                            var value = values[0][seriesIndex];
	                            var valueShape = Treemap.checkValueForShape(value, cullableValue, allValuesAreNegative, dataWasCulled);
	                            dataWasCulled = valueShape.dataWasCulled;
	                            if (!valueShape.validShape)
	                                continue;
	                            var nodeName = hasDynamicSeries ? visuals.converterHelper.formatFromMetadataColumn(reader.getSeriesValueColumnGroup(seriesIndex).name, reader.getSeriesMetadataColumn(), formatStringProp) : visuals.converterHelper.formatFromMetadataColumn(reader.getValueDisplayName(valueColumnRoleName, seriesIndex), valueColumn.source, formatStringProp);
	                            var identity = new visuals.SelectionIdBuilder()
	                                .withSeries(dataView.categorical.values, hasDynamicSeries ? valueColumn : undefined)
	                                .withMeasure(valueColumn.source.queryName)
	                                .createSelectionId();
	                            var key = identity.getKey();
	                            var color = hasDynamicSeries
	                                ? colorHelper.getColorForSeriesValue(reader.getSeriesObjects(seriesIndex), categorical.values.identityFields, visuals.converterHelper.getSeriesName(valueColumn.source))
	                                : colorHelper.getColorForMeasure(valueColumn.source.objects, valueColumn.source.queryName);
	                            var highlightedValue = hasHighlights ? highlights[0][seriesIndex] : undefined;
	                            var tooltipInfo = void 0;
	                            if (tooltipsEnabled) {
	                                tooltipInfo = [];
	                                if (hasDynamicSeries) {
	                                    var seriesMetadataColumn = reader.getSeriesMetadataColumn();
	                                    var seriesValue = reader.getSeriesValueColumnGroup(seriesIndex).name;
	                                    tooltipInfo.push({
	                                        displayName: seriesMetadataColumn.displayName,
	                                        value: visuals.converterHelper.formatFromMetadataColumn(seriesValue, seriesMetadataColumn, formatStringProp),
	                                    });
	                                }
	                                if (value != null) {
	                                    tooltipInfo.push({
	                                        displayName: valueColumn.source.displayName,
	                                        value: visuals.converterHelper.formatFromMetadataColumn(value, valueColumn.source, formatStringProp),
	                                    });
	                                }
	                                if (highlightedValue != null) {
	                                    tooltipInfo.push({
	                                        displayName: visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName,
	                                        value: visuals.converterHelper.formatFromMetadataColumn(highlightedValue, valueColumn.source, formatStringProp),
	                                    });
	                                }
	                                if (tooltipBucketEnabled) {
	                                    visuals.TooltipBuilder.addTooltipBucketItem(reader, tooltipInfo, 0, hasDynamicSeries ? seriesIndex : undefined);
	                                }
	                            }
	                            var node = {
	                                key: key,
	                                name: nodeName,
	                                size: allValuesAreNegative ? Math.abs(value) : value,
	                                originalValue: value,
	                                color: color,
	                                selected: false,
	                                identity: identity,
	                                tooltipInfo: tooltipInfo,
	                                highlightedTooltipInfo: tooltipInfo,
	                                labelFormatString: visuals.valueFormatter.getFormatString(valueColumn.source, formatStringProp),
	                            };
	                            if (hasHighlights && highlights) {
	                                node.highlightMultiplier = value !== 0 ? highlightedValue / value : 0;
	                                node.highlightValue = (allValuesAreNegative && highlightedValue != null) ? Math.abs(highlightedValue) : highlightedValue;
	                                node.originalHighlightValue = highlightedValue;
	                            }
	                            rootNode.children.push(node);
	                            allNodes.push(node);
	                            legendDataPoints.push({
	                                label: nodeName,
	                                color: color,
	                                icon: visuals.LegendIcon.Box,
	                                identity: identity,
	                                selected: false
	                            });
	                        }
	                    }
	                    else if (categorical.categories && categorical.categories.length > 0) {
	                        // Count the columns that have the value roles
	                        var seriesCount = reader.getSeriesCount(valueColumnRoleName);
	                        // Do not add second level if there's only one series.
	                        var omitSecondLevel = seriesCount === 1;
	                        // Create the first level from categories
	                        var categoryColumn = categorical.categories[0];
	                        legendTitle = categoryColumn.source.displayName;
	                        var categoryFormat = visuals.valueFormatter.getFormatString(categoryColumn.source, formatStringProp);
	                        for (var categoryIndex = 0, categoryLen = values.length; categoryIndex < categoryLen; categoryIndex++) {
	                            var objects = categoryColumn.objects && categoryColumn.objects[categoryIndex];
	                            var color = colorHelper.getColorForSeriesValue(objects, categoryColumn.identityFields, categoryColumn.values[categoryIndex]);
	                            var categoryValue = visuals.valueFormatter.format(categoryColumn.values[categoryIndex], categoryFormat);
	                            var currentValues = values[categoryIndex];
	                            // This section area builds the tooltip for the parent node. It's only displayed if the node doesn't have any children (essentially if omitSecondLevel is true).
	                            // seriesIndex is the index of the 1st series with the role Values.
	                            var seriesIndex = 0;
	                            var value = currentValues[seriesIndex];
	                            var highlightValue = hasHighlights && highlights ? highlights[categoryIndex][seriesIndex] : undefined;
	                            var tooltipInfo = void 0;
	                            var categoryTooltipItem = void 0;
	                            if (tooltipsEnabled) {
	                                tooltipInfo = [];
	                                categoryTooltipItem = {
	                                    displayName: categoryColumn.source.displayName,
	                                    value: categoryValue,
	                                };
	                                tooltipInfo.push(categoryTooltipItem);
	                                var valueColumnMetadata = reader.getValueMetadataColumn(valueColumnRoleName, seriesIndex);
	                                if (value != null) {
	                                    tooltipInfo.push({
	                                        displayName: valueColumnMetadata.displayName,
	                                        value: visuals.converterHelper.formatFromMetadataColumn(value, valueColumnMetadata, formatStringProp),
	                                    });
	                                }
	                                if (highlightValue != null) {
	                                    tooltipInfo.push({
	                                        displayName: visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName,
	                                        value: visuals.converterHelper.formatFromMetadataColumn(highlightValue, valueColumnMetadata, formatStringProp),
	                                    });
	                                }
	                                var gradientValueColumnMetadata = gradientValueColumn ? gradientValueColumn.source : undefined;
	                                if (omitSecondLevel && gradientValueColumnMetadata && gradientValueColumnMetadata !== valueColumnMetadata && gradientValueColumn.values[categoryIndex] != null) {
	                                    tooltipInfo.push({
	                                        displayName: gradientValueColumnMetadata.displayName,
	                                        value: visuals.converterHelper.formatFromMetadataColumn(gradientValueColumn.values[categoryIndex], gradientValueColumnMetadata, formatStringProp),
	                                    });
	                                }
	                                if (tooltipBucketEnabled) {
	                                    visuals.TooltipBuilder.addTooltipBucketItem(reader, tooltipInfo, categoryIndex, seriesIndex);
	                                }
	                            }
	                            var identity = visuals.SelectionIdBuilder.builder()
	                                .withCategory(categoryColumn, categoryIndex)
	                                .withMeasure(omitSecondLevel ? reader.getValueMetadataColumn(valueColumnRoleName, seriesIndex).queryName : undefined)
	                                .createSelectionId();
	                            var key = JSON.stringify({ nodeKey: identity.getKey(), depth: 1 });
	                            var node = {
	                                key: key,
	                                name: categoryValue,
	                                originalValue: undefined,
	                                color: color,
	                                selected: false,
	                                identity: identity,
	                                tooltipInfo: tooltipInfo,
	                                highlightedTooltipInfo: tooltipInfo,
	                                labelFormatString: seriesCount === 1 ? visuals.valueFormatter.getFormatString(reader.getValueMetadataColumn(valueColumnRoleName, seriesIndex), formatStringProp) : categoryFormat,
	                            };
	                            if (hasHighlights) {
	                                node.highlightMultiplier = value !== 0 ? highlightValue / value : 0;
	                                node.highlightValue = (allValuesAreNegative && highlightValue != null) ? Math.abs(highlightValue) : highlightValue;
	                                node.originalHighlightValue = highlightValue;
	                            }
	                            legendDataPoints.push({
	                                label: categoryValue,
	                                color: color,
	                                icon: visuals.LegendIcon.Box,
	                                identity: identity,
	                                selected: false
	                            });
	                            var total = 0;
	                            var highlightTotal = 0; // Used if omitting second level
	                            for (; seriesIndex < seriesCount; seriesIndex++) {
	                                var valueColumn = reader.getValueColumn(valueColumnRoleName, seriesIndex);
	                                var value_1 = currentValues[seriesIndex];
	                                var highlight = void 0;
	                                var valueShape = Treemap.checkValueForShape(value_1, cullableValue, allValuesAreNegative, dataWasCulled);
	                                dataWasCulled = valueShape.dataWasCulled;
	                                if (!valueShape.validShape)
	                                    continue;
	                                total += value_1;
	                                if (hasHighlights) {
	                                    highlight = highlights[categoryIndex][seriesIndex];
	                                    highlightTotal += highlight;
	                                }
	                                if (!omitSecondLevel) {
	                                    var childName = null;
	                                    if (reader.hasDynamicSeries()) {
	                                        // Measure: use name and index
	                                        childName = visuals.converterHelper.formatFromMetadataColumn(reader.getSeriesName(seriesIndex), reader.getSeriesMetadataColumn(), formatStringProp);
	                                    }
	                                    else {
	                                        // Series group instance
	                                        childName = visuals.converterHelper.formatFromMetadataColumn(reader.getValueDisplayName(valueColumnRoleName, seriesIndex), reader.getValueMetadataColumn(valueColumnRoleName, seriesIndex), formatStringProp);
	                                    }
	                                    var categoricalValues = categorical ? categorical.values : null;
	                                    var measureId = valueColumn.source.queryName;
	                                    var childIdentity = visuals.SelectionIdBuilder.builder()
	                                        .withCategory(categoryColumn, categoryIndex)
	                                        .withSeries(categoricalValues, valueColumn)
	                                        .withMeasure(measureId)
	                                        .createSelectionId();
	                                    var childKey = JSON.stringify({ nodeKey: childIdentity.getKey(), depth: 2 });
	                                    var highlightedValue = hasHighlights && highlight !== 0 ? highlight : undefined;
	                                    var tooltipInfo_1 = void 0;
	                                    if (tooltipsEnabled) {
	                                        tooltipInfo_1 = [];
	                                        tooltipInfo_1.push(categoryTooltipItem);
	                                        if (hasDynamicSeries) {
	                                            if (!categoryColumn || categoryColumn.source !== categoricalValues.source) {
	                                                // Category/series on the same column -- don't repeat its value in the tooltip.
	                                                tooltipInfo_1.push({
	                                                    displayName: categoricalValues.source.displayName,
	                                                    value: visuals.converterHelper.formatFromMetadataColumn(reader.getSeriesName(seriesIndex), categoricalValues.source, formatStringProp),
	                                                });
	                                            }
	                                        }
	                                        if (value_1 != null) {
	                                            tooltipInfo_1.push({
	                                                displayName: valueColumn.source.displayName,
	                                                value: visuals.converterHelper.formatFromMetadataColumn(value_1, valueColumn.source, formatStringProp),
	                                            });
	                                        }
	                                        if (highlightValue != null) {
	                                            tooltipInfo_1.push({
	                                                displayName: visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName,
	                                                value: visuals.converterHelper.formatFromMetadataColumn(highlightedValue, valueColumn.source, formatStringProp),
	                                            });
	                                        }
	                                        if (tooltipBucketEnabled) {
	                                            visuals.TooltipBuilder.addTooltipBucketItem(reader, tooltipInfo_1, categoryIndex, hasDynamicSeries ? seriesIndex : undefined);
	                                        }
	                                    }
	                                    var childNode = {
	                                        key: childKey,
	                                        name: childName,
	                                        size: allValuesAreNegative ? Math.abs(value_1) : value_1,
	                                        originalValue: value_1,
	                                        color: color,
	                                        selected: false,
	                                        identity: childIdentity,
	                                        tooltipInfo: tooltipInfo_1,
	                                        highlightedTooltipInfo: tooltipInfo_1,
	                                        labelFormatString: visuals.valueFormatter.getFormatString(valueColumn.source, formatStringProp),
	                                    };
	                                    if (hasHighlights) {
	                                        childNode.highlightMultiplier = value_1 !== 0 ? highlight / value_1 : 0;
	                                        childNode.highlightValue = (allValuesAreNegative && highlight != null) ? Math.abs(highlight) : null;
	                                        childNode.originalHighlightValue = highlight;
	                                    }
	                                    if (node.children == null)
	                                        node.children = [];
	                                    node.children.push(childNode);
	                                    allNodes.push(childNode);
	                                }
	                            }
	                            if (total) {
	                                node.size = allValuesAreNegative ? Math.abs(total) : total;
	                                node.originalValue = total;
	                                rootNode.children.push(node);
	                                allNodes.push(node);
	                            }
	                            if (hasHighlights)
	                                node.highlightMultiplier = total ? highlightTotal / total : 0;
	                        }
	                    }
	                }
	                if (interactivityService) {
	                    interactivityService.applySelectionStateToData(allNodes);
	                    interactivityService.applySelectionStateToData(legendDataPoints);
	                }
	                return {
	                    root: rootNode,
	                    hasHighlights: hasHighlights,
	                    legendData: { title: legendTitle, dataPoints: legendDataPoints, fontSize: visuals.SVGLegend.DefaultFontSizeInPt },
	                    dataLabelsSettings: labelSettings,
	                    legendObjectProperties: legendObjectProperties,
	                    dataWasCulled: dataWasCulled,
	                    hasNegativeValues: hasNegativeValues,
	                    allValuesAreNegative: allValuesAreNegative,
	                };
	            };
	            Treemap.normalizedValue = function (value, allValuesAreNegative) {
	                if (value == null || isNaN(value))
	                    return 0;
	                else if (value === Number.POSITIVE_INFINITY)
	                    return Number.MAX_VALUE;
	                else if (value === Number.NEGATIVE_INFINITY)
	                    return -Number.MAX_VALUE;
	                else if (allValuesAreNegative)
	                    return Math.abs(value);
	                else if (value < 0)
	                    return 0;
	                else
	                    return value;
	            };
	            Treemap.getValuesFromCategoricalDataView = function (dataView, hasHighlights, valueColumnRoleName) {
	                var reader = powerbi.data.createIDataViewCategoricalReader(dataView);
	                var categoryCount = reader.getCategoryCount() || 1;
	                var seriesCount = reader.getSeriesCount(valueColumnRoleName);
	                var values = [];
	                var highlights = [];
	                var totalValue = 0;
	                for (var i = 0; i < categoryCount; i++) {
	                    values.push([]);
	                    if (hasHighlights)
	                        highlights.push([]);
	                }
	                var hasNegativeValues;
	                var allValuesAreNegative = undefined;
	                var highlightsOverflow;
	                for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
	                    for (var categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) {
	                        var value = reader.getValue(valueColumnRoleName, categoryIndex, seriesIndex);
	                        values[categoryIndex].push(value);
	                        var highlight = void 0;
	                        if (hasHighlights) {
	                            highlight = reader.getHighlight(valueColumnRoleName, categoryIndex, seriesIndex);
	                            highlights[categoryIndex].push(highlight);
	                            if (highlight == null)
	                                highlight = 0;
	                        }
	                        if (allValuesAreNegative === undefined) {
	                            allValuesAreNegative = ((hasHighlights ? highlight <= 0 : true) && value <= 0) ? true : false;
	                        }
	                        else {
	                            allValuesAreNegative = allValuesAreNegative && (hasHighlights ? highlight <= 0 : true) && value <= 0;
	                        }
	                        if (!hasNegativeValues)
	                            hasNegativeValues = value < 0 || (hasHighlights ? highlight < 0 : false);
	                    }
	                }
	                allValuesAreNegative = !!allValuesAreNegative;
	                for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
	                    for (var categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) {
	                        var value = values[categoryIndex][seriesIndex];
	                        value = Treemap.normalizedValue(value, allValuesAreNegative);
	                        totalValue += value;
	                        if (hasHighlights) {
	                            var highlight = highlights[categoryIndex][seriesIndex];
	                            highlight = Treemap.normalizedValue(highlight, allValuesAreNegative);
	                            if (!highlightsOverflow && highlight > value) {
	                                highlightsOverflow = true;
	                            }
	                        }
	                    }
	                }
	                return {
	                    values: values,
	                    highlights: hasHighlights ? highlights : undefined,
	                    highlightsOverflow: hasHighlights ? highlightsOverflow : undefined,
	                    totalValue: allValuesAreNegative ? Math.abs(totalValue) : totalValue,
	                    hasNegativeValues: hasNegativeValues,
	                    allValuesAreNegative: allValuesAreNegative,
	                };
	            };
	            Treemap.getCullableValue = function (totalValue, viewport) {
	                var totalArea = viewport.width * viewport.height;
	                var culledPercent = Treemap.CullableArea / totalArea;
	                return culledPercent * totalValue;
	            };
	            Treemap.prototype.update = function (options) {
	                debug.assertValue(options, 'options');
	                var dataViews = this.dataViews = options.dataViews;
	                this.currentViewport = options.viewport;
	                var dataViewCategorical = dataViews && dataViews.length > 0 && dataViews[0].categorical ? dataViews[0].categorical : undefined;
	                var labelSettings = visuals.dataLabelUtils.getDefaultTreemapLabelSettings();
	                var legendObjectProperties = null;
	                if (dataViewCategorical) {
	                    var dataView = dataViews[0];
	                    var dataViewMetadata = dataView.metadata;
	                    var objects = void 0;
	                    if (dataViewMetadata)
	                        objects = dataViewMetadata.objects;
	                    if (objects) {
	                        legendObjectProperties = objects['legend'];
	                    }
	                    this.data = Treemap.converter(dataView, this.colors, labelSettings, this.interactivityService, this.currentViewport, legendObjectProperties, this.tooltipsEnabled, this.tooltipBucketEnabled);
	                }
	                else {
	                    var rootNode = {
	                        key: "root",
	                        name: "root",
	                        originalValue: undefined,
	                        children: [],
	                        selected: false,
	                        highlightMultiplier: 0,
	                        identity: visuals.SelectionId.createNull(),
	                        color: undefined,
	                    };
	                    var legendData = { title: "", dataPoints: [] };
	                    var treeMapData = {
	                        root: rootNode,
	                        hasHighlights: false,
	                        legendData: legendData,
	                        dataLabelsSettings: labelSettings,
	                        dataWasCulled: false,
	                        hasNegativeValues: false,
	                        allValuesAreNegative: false,
	                    };
	                    this.data = treeMapData;
	                }
	                this.updateInternal(options.suppressAnimations);
	                if (dataViews) {
	                    var warnings = visuals.getInvalidValueWarnings(dataViews, false /*supportsNaN*/, false /*supportsNegativeInfinity*/, false /*supportsPositiveInfinity*/);
	                    if (this.data.allValuesAreNegative) {
	                        warnings.push(new visuals.AllNegativeValuesWarning());
	                    }
	                    else if (this.data.hasNegativeValues) {
	                        warnings.push(new visuals.NegativeValuesNotSupportedWarning());
	                    }
	                    this.hostService.setWarnings(warnings);
	                }
	            };
	            // TODO: Remove this once all visuals have implemented update.
	            Treemap.prototype.onDataChanged = function (options) {
	                this.update({
	                    suppressAnimations: options.suppressAnimations,
	                    dataViews: options.dataViews,
	                    viewport: this.currentViewport
	                });
	            };
	            // TODO: Remove this once all visuals have implemented update.
	            Treemap.prototype.onResizing = function (viewport) {
	                this.update({
	                    suppressAnimations: true,
	                    dataViews: this.dataViews,
	                    viewport: viewport
	                });
	            };
	            Treemap.prototype.onClearSelection = function () {
	                if (this.interactivityService)
	                    this.interactivityService.clearSelection();
	            };
	            Treemap.prototype.enumerateObjectInstances = function (options) {
	                var data = this.data;
	                if (!data)
	                    return;
	                var objectName = options.objectName, enumeration = new visuals.ObjectEnumerationBuilder();
	                var dataLabelsSettings = this.data.dataLabelsSettings
	                    ? this.data.dataLabelsSettings
	                    : visuals.dataLabelUtils.getDefaultTreemapLabelSettings();
	                switch (objectName) {
	                    case 'dataPoint':
	                        var dataViewCat = this.dataViews && this.dataViews.length > 0 && this.dataViews[0] && this.dataViews[0].categorical;
	                        var hasGradientRole = visuals.GradientUtils.hasGradientRole(dataViewCat);
	                        if (!hasGradientRole)
	                            this.enumerateDataPoints(enumeration, data);
	                        break;
	                    case 'legend':
	                        return this.enumerateLegend(data);
	                    case 'labels':
	                        var labelSettingOptions = {
	                            enumeration: enumeration,
	                            dataLabelsSettings: dataLabelsSettings,
	                            show: true,
	                            displayUnits: true,
	                            precision: true,
	                        };
	                        visuals.dataLabelUtils.enumerateDataLabels(labelSettingOptions);
	                        break;
	                    case 'categoryLabels':
	                        visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, dataLabelsSettings, false /* withFill */, true /* isShowCategory */);
	                        break;
	                }
	                return enumeration.complete();
	            };
	            Treemap.prototype.enumerateDataPoints = function (enumeration, data) {
	                var rootChildren = data.root.children;
	                if (_.isEmpty(rootChildren))
	                    return;
	                for (var y = 0; y < rootChildren.length; y++) {
	                    var treemapNode = rootChildren[y];
	                    enumeration.pushInstance({
	                        displayName: treemapNode.name,
	                        selector: visuals.ColorHelper.normalizeSelector(treemapNode.identity.getSelector()),
	                        properties: {
	                            fill: { solid: { color: treemapNode.color } }
	                        },
	                        objectName: 'dataPoint'
	                    });
	                }
	            };
	            Treemap.prototype.enumerateLegend = function (data) {
	                var legendObjectProperties = { legend: data.legendObjectProperties };
	                var show = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.treemapProps.legend.show, this.legend.isVisible());
	                var showTitle = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.treemapProps.legend.showTitle, true);
	                var titleText = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.treemapProps.legend.titleText, this.data.legendData.title);
	                var labelColor = powerbi.DataViewObject.getValue(legendObjectProperties, visuals.legendProps.labelColor, this.data.legendData ? this.data.legendData.labelColor : visuals.LegendData.DefaultLegendLabelFillColor);
	                var labelFontSize = powerbi.DataViewObject.getValue(legendObjectProperties, visuals.legendProps.fontSize, this.data.legendData && this.data.legendData.fontSize ? this.data.legendData.fontSize : visuals.SVGLegend.DefaultFontSizeInPt);
	                var position = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.treemapProps.legend.position, visuals.legendPosition.top);
	                return [{
	                        selector: null,
	                        objectName: 'legend',
	                        properties: {
	                            show: show,
	                            position: position,
	                            showTitle: showTitle,
	                            titleText: titleText,
	                            labelColor: labelColor,
	                            fontSize: labelFontSize,
	                        }
	                    }];
	            };
	            Treemap.checkValueForShape = function (value, cullableValue, allValuesAreNegative, dataWasCulled) {
	                var shouldCullValue = undefined;
	                if (!value) {
	                    return {
	                        validShape: false,
	                        dataWasCulled: dataWasCulled,
	                    };
	                }
	                else {
	                    if (!allValuesAreNegative)
	                        shouldCullValue = value < cullableValue;
	                    else
	                        shouldCullValue = Math.abs(value) < cullableValue;
	                    if (shouldCullValue) {
	                        dataWasCulled = dataWasCulled || shouldCullValue;
	                        return {
	                            validShape: false,
	                            dataWasCulled: dataWasCulled,
	                        };
	                    }
	                    return {
	                        validShape: true,
	                        dataWasCulled: dataWasCulled,
	                    };
	                }
	            };
	            Treemap.prototype.calculateTreemapSize = function () {
	                var legendMargins = this.legend.getMargins();
	                return {
	                    height: this.currentViewport.height - legendMargins.height,
	                    width: this.currentViewport.width - legendMargins.width
	                };
	            };
	            Treemap.prototype.initViewportDependantProperties = function (duration) {
	                if (duration === void 0) { duration = 0; }
	                var viewport = this.calculateTreemapSize();
	                this.svg.attr({
	                    width: viewport.width,
	                    height: viewport.height
	                });
	                visuals.Legend.positionChartArea(this.svg, this.legend);
	                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
	            };
	            Treemap.hasChildrenWithIdentity = function (node) {
	                var children = node.children;
	                if (!children)
	                    return false;
	                var count = children.length;
	                if (count === 0)
	                    return false;
	                for (var i = count - 1; i >= 0; i--) {
	                    if (children[i].identity.hasIdentity())
	                        return true;
	                }
	                return false;
	            };
	            Treemap.canDisplayMajorLabel = function (node) {
	                // Only display major labels for level 1
	                if (node.depth !== 1)
	                    return false;
	                if (_.isEmpty(node.name))
	                    return false;
	                // Check if the room is enough for text with or without ellipse
	                var availableWidth = node.dx - Treemap.TextMargin * 2;
	                if (availableWidth < Treemap.MinTextWidthForMajorLabel)
	                    return false;
	                // Check if the shape is high enough for label
	                var textHeightWithMargin = Treemap.MajorLabelTextSize + Treemap.TextMargin * 2;
	                if (node.dy < textHeightWithMargin)
	                    return false;
	                return true;
	            };
	            Treemap.canDisplayMinorLabel = function (node, labelSettings) {
	                // Only display minor labels for level 1 and 2
	                if (node.depth < 1 || node.depth > 2)
	                    return false;
	                // If a depth 1 node has children or is not showing data labels, do not show minor labels
	                if (node.depth === 1 && (node.children || !labelSettings.show)) {
	                    return false;
	                }
	                if (_.isEmpty(node.name))
	                    return false;
	                // Check if the room is enough for text with or without ellipse
	                var availableWidth = node.dx - Treemap.TextMargin * 2;
	                if (availableWidth < Treemap.MinTextWidthForMinorLabel)
	                    return false;
	                // Check if the shape is high enough for label
	                var textHeightWithMargin = Treemap.MinorLabelTextSize + Treemap.TextMargin * 2;
	                if (node.dy < textHeightWithMargin)
	                    return false;
	                if (node.depth === 1) {
	                    var roomTop = node.y + Treemap.MajorLabelTextSize + Treemap.TextMargin * 2;
	                    if (node.y + node.dy - roomTop < textHeightWithMargin)
	                        return false;
	                }
	                else if (node.depth === 2) {
	                    var parent_1 = node.parent;
	                    var roomTop = Math.max(parent_1.y + Treemap.MajorLabelTextSize + Treemap.TextMargin * 2, node.y);
	                    // Parent's label needs the room
	                    if (node.y + node.dy - roomTop < textHeightWithMargin)
	                        return false;
	                }
	                return true;
	            };
	            Treemap.createMajorLabelText = function (node, labelsSettings, alternativeScale, formattersCache) {
	                var spaceAvaliableForLabels = node.dx - Treemap.TextMargin * 2;
	                var baseTextProperties = Treemap.MajorLabelTextProperties;
	                var textProperties = {
	                    text: node.name,
	                    fontFamily: baseTextProperties.fontFamily,
	                    fontSize: baseTextProperties.fontSize
	                };
	                return powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, spaceAvaliableForLabels);
	            };
	            Treemap.createMinorLabelText = function (node, labelsSettings, alternativeScale, formattersCache) {
	                var spaceAvaliableForLabels = node.dx - Treemap.TextMargin * 2;
	                var label = node.name;
	                if (labelsSettings.show) {
	                    var measureFormatter = formattersCache.getOrCreate(node.labelFormatString, labelsSettings, alternativeScale);
	                    // Create measure label
	                    label = visuals.dataLabelUtils.getLabelFormattedText({
	                        label: node.originalHighlightValue != null ? node.originalHighlightValue : node.originalValue, maxWidth: spaceAvaliableForLabels, formatter: measureFormatter
	                    });
	                    // Add category if needed (we're showing category and the node depth is 2)
	                    if (labelsSettings.showCategory && node.depth === 2)
	                        label = visuals.dataLabelUtils.getLabelFormattedText({
	                            label: node.name,
	                            maxWidth: spaceAvaliableForLabels
	                        }) + " " + label;
	                }
	                return visuals.dataLabelUtils.getLabelFormattedText({
	                    label: label,
	                    maxWidth: spaceAvaliableForLabels,
	                    fontSize: labelsSettings.fontSize
	                });
	            };
	            Treemap.getFill = function (d, isHighlightRect) {
	                // NOTE: only painted shapes will catch click event. We either paint children or their parent but not both.
	                // If it's a leaf with no category, parent will be painted instead (and support interactivity)
	                if (d.depth > 1 && !d.identity.hasIdentity() && !isHighlightRect)
	                    return CssConstants.noneValue;
	                // If it's not a leaf and it has children with a category, children will be painted
	                if (Treemap.hasChildrenWithIdentity(d))
	                    return CssConstants.noneValue;
	                return d.color;
	            };
	            Treemap.getFillOpacity = function (d, hasSelection, hasHighlights, isHighlightRect) {
	                if (hasHighlights) {
	                    if (isHighlightRect)
	                        return null;
	                    return Treemap.DimmedShapeOpacity.toString();
	                }
	                if (!hasSelection || d.selected)
	                    return null;
	                // Parent node is selected (as an optimization, we only check below level 1 because root node cannot be selected anyway)
	                if (d.depth > 1 && d.parent.selected)
	                    return null;
	                // It's a parent node with interactive children, fall back to default opacity
	                if (Treemap.hasChildrenWithIdentity(d))
	                    return null;
	                return Treemap.DimmedShapeOpacity.toString();
	            };
	            Treemap.prototype.updateInternal = function (suppressAnimations) {
	                var data = this.data;
	                var hasHighlights = data && data.hasHighlights;
	                var labelSettings = data ? data.dataLabelsSettings : null;
	                var duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
	                if (!(this.options.interactivity && this.options.interactivity.isInteractiveLegend) && this.data) {
	                    this.renderLegend();
	                }
	                this.initViewportDependantProperties(duration);
	                var viewport = this.calculateTreemapSize();
	                this.treemap.size([viewport.width, viewport.height]);
	                // Shapes are drawn for all nodes
	                var nodes = (data && data.root) ? this.treemap.nodes(data.root) : [];
	                // Highlight shapes are drawn only for nodes with non-null/undefed highlightMultipliers that have no children
	                var highlightNodes = nodes.filter(function (value) { return value.highlightMultiplier != null && (!value.children || value.children.length === 0); });
	                var majorLabeledNodes = [];
	                var minorLabeledNodes = [];
	                var alternativeScale = null;
	                // Only populate major labels if category labels are turned on
	                if (labelSettings.showCategory) {
	                    majorLabeledNodes = nodes.filter(function (d) { return Treemap.canDisplayMajorLabel(d); });
	                }
	                // Only populate minor labels if category or data labels are turned on
	                if (labelSettings.show || labelSettings.showCategory) {
	                    minorLabeledNodes = nodes.filter(function (d) { return Treemap.canDisplayMinorLabel(d, labelSettings); });
	                    // If the display unit is 0 we calculate the format scale using the maximum value available
	                    if (labelSettings.displayUnits === 0)
	                        alternativeScale = d3.max(minorLabeledNodes, function (d) { return Math.abs(d.value); });
	                }
	                var treemapLayout = Treemap.getLayout(labelSettings, alternativeScale);
	                var shapes;
	                var highlightShapes;
	                var majorLabels;
	                var minorLabels;
	                var result;
	                if (this.animator && !suppressAnimations) {
	                    var options = {
	                        viewModel: data,
	                        nodes: nodes,
	                        highlightNodes: highlightNodes,
	                        majorLabeledNodes: majorLabeledNodes,
	                        minorLabeledNodes: minorLabeledNodes,
	                        shapeGraphicsContext: this.shapeGraphicsContext,
	                        labelGraphicsContext: this.labelGraphicsContext,
	                        interactivityService: this.interactivityService,
	                        layout: treemapLayout,
	                        labelSettings: labelSettings,
	                    };
	                    result = this.animator.animate(options);
	                    shapes = result.shapes;
	                    highlightShapes = result.highlightShapes;
	                    majorLabels = result.majorLabels;
	                    minorLabels = result.minorLabels;
	                }
	                if (!this.animator || suppressAnimations || result.failed) {
	                    var hasSelection = this.interactivityService && this.interactivityService.hasSelection();
	                    var shapeGraphicsContext = this.shapeGraphicsContext;
	                    shapes = Treemap.drawDefaultShapes(shapeGraphicsContext, nodes, hasSelection, hasHighlights, treemapLayout);
	                    highlightShapes = Treemap.drawDefaultHighlightShapes(shapeGraphicsContext, highlightNodes, hasSelection, hasHighlights, treemapLayout);
	                    var labelGraphicsContext = this.labelGraphicsContext;
	                    majorLabels = Treemap.drawDefaultMajorLabels(labelGraphicsContext, majorLabeledNodes, labelSettings, treemapLayout);
	                    minorLabels = Treemap.drawDefaultMinorLabels(labelGraphicsContext, minorLabeledNodes, labelSettings, treemapLayout);
	                }
	                if (this.interactivityService) {
	                    var behaviorOptions = {
	                        shapes: shapes,
	                        highlightShapes: highlightShapes,
	                        majorLabels: majorLabels,
	                        minorLabels: minorLabels,
	                        nodes: nodes,
	                        hasHighlights: data.hasHighlights,
	                    };
	                    this.interactivityService.bind(nodes, this.behavior, behaviorOptions);
	                }
	                if (this.tooltipsEnabled) {
	                    visuals.TooltipManager.addTooltip(shapes, function (tooltipEvent) { return tooltipEvent.data.highlightedTooltipInfo ? tooltipEvent.data.highlightedTooltipInfo : tooltipEvent.data.tooltipInfo; });
	                    visuals.TooltipManager.addTooltip(highlightShapes, function (tooltipEvent) { return tooltipEvent.data.highlightedTooltipInfo; });
	                }
	                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
	            };
	            Treemap.prototype.renderLegend = function () {
	                var legendObjectProperties = this.data.legendObjectProperties;
	                if (legendObjectProperties) {
	                    var legendData = this.data.legendData;
	                    visuals.LegendData.update(legendData, legendObjectProperties);
	                    var position = legendObjectProperties[visuals.legendProps.position];
	                    if (position)
	                        this.legend.changeOrientation(visuals.LegendPosition[position]);
	                    this.legend.drawLegend(legendData, this.currentViewport);
	                }
	                else {
	                    // TODO: Draw should be the only API. Visuals should only call that with orientation, props, etc 
	                    // instead of managing state. Will follow up with another change.
	                    this.legend.changeOrientation(visuals.LegendPosition.Top);
	                    this.legend.drawLegend({ dataPoints: [] }, this.currentViewport);
	                }
	            };
	            Treemap.getNodeClass = function (d, highlight) {
	                var nodeClass;
	                switch (d.depth) {
	                    case 1:
	                        nodeClass = Treemap.ParentGroupClassName;
	                        break;
	                    case 2:
	                        nodeClass = Treemap.NodeGroupClassName;
	                        break;
	                    case 0:
	                        nodeClass = Treemap.RootNodeClassName;
	                        break;
	                    default:
	                        debug.assertFail('Treemap only supports 2 levels maxiumum');
	                }
	                nodeClass += " " + (highlight ? Treemap.HighlightNodeClassName : Treemap.TreemapNodeClassName);
	                return nodeClass;
	            };
	            Treemap.createTreemapShapeLayout = function (isHighlightRect) {
	                if (isHighlightRect === void 0) { isHighlightRect = false; }
	                return {
	                    x: function (d) { return d.x; },
	                    y: function (d) { return d.y + (isHighlightRect ? d.dy * (1 - d.highlightMultiplier) : 0); },
	                    width: function (d) { return Math.max(0, d.dx); },
	                    height: function (d) { return Math.max(0, d.dy * (isHighlightRect ? d.highlightMultiplier : 1)); },
	                };
	            };
	            Treemap.createTreemapZeroShapeLayout = function () {
	                return {
	                    x: function (d) { return d.x; },
	                    y: function (d) { return d.y + d.dy; },
	                    width: function (d) { return Math.max(0, d.dx); },
	                    height: function (d) { return 0; },
	                };
	            };
	            Treemap.drawDefaultShapes = function (context, nodes, hasSelection, hasHighlights, layout) {
	                var isHighlightShape = false;
	                var shapes = context.selectAll('.' + Treemap.TreemapNodeClassName)
	                    .data(nodes, function (d) { return d.key; });
	                shapes.enter().append('rect')
	                    .attr('class', layout.shapeClass);
	                shapes
	                    .style("fill", function (d) { return Treemap.getFill(d, isHighlightShape); })
	                    .style("fill-opacity", function (d) { return Treemap.getFillOpacity(d, hasSelection, hasHighlights, isHighlightShape); })
	                    .attr(layout.shapeLayout);
	                shapes.exit().remove();
	                return shapes;
	            };
	            Treemap.drawDefaultHighlightShapes = function (context, nodes, hasSelection, hasHighlights, layout) {
	                var isHighlightShape = true;
	                var highlightShapes = context.selectAll('.' + Treemap.HighlightNodeClassName)
	                    .data(nodes, function (d) { return d.key + "highlight"; });
	                highlightShapes.enter().append('rect')
	                    .attr('class', layout.highlightShapeClass);
	                highlightShapes
	                    .style("fill", function (d) { return Treemap.getFill(d, isHighlightShape); })
	                    .style("fill-opacity", function (d) { return Treemap.getFillOpacity(d, hasSelection, hasHighlights, isHighlightShape); })
	                    .attr(layout.highlightShapeLayout);
	                highlightShapes.exit().remove();
	                return highlightShapes;
	            };
	            Treemap.drawDefaultMajorLabels = function (context, nodes, labelSettings, layout) {
	                var labels = context
	                    .selectAll('.' + Treemap.MajorLabelClassName)
	                    .data(nodes, function (d) { return d.key; });
	                labels.enter().append('text')
	                    .attr('class', layout.majorLabelClass);
	                labels
	                    .attr(layout.majorLabelLayout)
	                    .text(layout.majorLabelText)
	                    .style('fill', function () { return labelSettings.labelColor; });
	                labels.exit().remove();
	                return labels;
	            };
	            Treemap.drawDefaultMinorLabels = function (context, nodes, labelSettings, layout) {
	                var labels = context
	                    .selectAll('.' + Treemap.MinorLabelClassName)
	                    .data(nodes, function (d) { return d.key; });
	                labels.enter().append('text')
	                    .attr('class', layout.minorLabelClass);
	                labels
	                    .attr(layout.minorLabelLayout)
	                    .text(layout.minorLabelText)
	                    .style('fill', function () { return labelSettings.labelColor; });
	                labels.exit().remove();
	                return labels;
	            };
	            Treemap.cleanMinorLabels = function (context) {
	                var empty = [];
	                var labels = context
	                    .selectAll('.' + Treemap.LabelsGroupClassName)
	                    .selectAll('.' + Treemap.MinorLabelClassName)
	                    .data(empty);
	                labels.exit().remove();
	            };
	            Treemap.DimmedShapeOpacity = 0.4;
	            Treemap.ClassName = 'treemap';
	            Treemap.LabelsGroupClassName = "labels";
	            Treemap.MajorLabelClassName = 'majorLabel';
	            Treemap.MinorLabelClassName = 'minorLabel';
	            Treemap.ShapesClassName = "shapes";
	            Treemap.TreemapNodeClassName = "treemapNode";
	            Treemap.RootNodeClassName = 'rootNode';
	            Treemap.ParentGroupClassName = 'parentGroup';
	            Treemap.NodeGroupClassName = 'nodeGroup';
	            Treemap.HighlightNodeClassName = 'treemapNodeHighlight';
	            Treemap.TextMargin = 5;
	            Treemap.MinorLabelTextSize = 10;
	            Treemap.MinTextWidthForMinorLabel = 18;
	            Treemap.MajorLabelTextSize = 12;
	            Treemap.MinTextWidthForMajorLabel = 22;
	            Treemap.MajorLabelTextProperties = {
	                fontFamily: visuals.Font.Family.regular.css,
	                fontSize: Treemap.MajorLabelTextSize + 'px'
	            };
	            /**
	             * A rect with an area of 9 is a treemap rectangle of only
	             * a single pixel in the middle with a 1 pixel stroke on each edge.
	             */
	            Treemap.CullableArea = 9;
	            return Treemap;
	        }());
	        visuals.Treemap = Treemap;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 278 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var getKpiImageMetadata = powerbi.visuals.KpiUtil.getKpiImageMetadata;
	        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
	        var Card = (function (_super) {
	            __extends(Card, _super);
	            function Card(options) {
	                _super.call(this, Card.cardClassName);
	                this.isScrollable = false;
	                this.displayUnitSystemType = powerbi.DisplayUnitSystemType.WholeUnits;
	                if (options) {
	                    this.isScrollable = !!options.isScrollable;
	                    if (options.animator)
	                        this.animator = options.animator;
	                    if (options.displayUnitSystemType != null)
	                        this.displayUnitSystemType = options.displayUnitSystemType;
	                    if (options.cardSmallViewportProperties) {
	                        this.cardSmallViewportProperties = options.cardSmallViewportProperties;
	                    }
	                }
	            }
	            Card.prototype.init = function (options) {
	                debug.assertValue(options, 'options');
	                this.animationOptions = options.animation;
	                var element = options.element;
	                this.kpiImage = d3.select(element.get(0)).append('div')
	                    .classed(Card.KPIImage.class, true);
	                var svg = this.svg = d3.select(element.get(0)).append('svg');
	                this.graphicsContext = svg.append('g');
	                this.currentViewport = options.viewport;
	                this.hostServices = options.host;
	                this.style = options.style;
	                this.updateViewportProperties();
	                if (this.isScrollable) {
	                    svg.attr('class', Card.cardClassName);
	                    this.labelContext = svg.append('g');
	                }
	            };
	            Card.prototype.onDataChanged = function (options) {
	                debug.assertValue(options, 'options');
	                var dataView = options.dataViews[0];
	                var value;
	                if (dataView) {
	                    this.getMetaDataColumn(dataView);
	                    if (dataView.single) {
	                        value = dataView.single.value;
	                    }
	                    // Update settings based on new metadata column
	                    this.cardFormatSetting = this.getDefaultFormatSettings();
	                    var dataViewMetadata = dataView.metadata;
	                    if (dataViewMetadata) {
	                        var objects = dataViewMetadata.objects;
	                        if (objects) {
	                            var labelSettings = this.cardFormatSetting.labelSettings;
	                            labelSettings.labelColor = powerbi.DataViewObjects.getFillColor(objects, visuals.cardProps.labels.color, labelSettings.labelColor);
	                            labelSettings.precision = powerbi.DataViewObjects.getValue(objects, visuals.cardProps.labels.labelPrecision, labelSettings.precision);
	                            labelSettings.fontSize = powerbi.DataViewObjects.getValue(objects, visuals.cardProps.labels.fontSize, labelSettings.fontSize);
	                            // The precision can't go below 0
	                            if (labelSettings.precision !== visuals.dataLabelUtils.defaultLabelPrecision && labelSettings.precision < 0) {
	                                labelSettings.precision = 0;
	                            }
	                            labelSettings.displayUnits = powerbi.DataViewObjects.getValue(objects, visuals.cardProps.labels.labelDisplayUnits, labelSettings.displayUnits);
	                            //category labels
	                            labelSettings.showCategory = powerbi.DataViewObjects.getValue(objects, visuals.cardProps.categoryLabels.show, labelSettings.showCategory);
	                            labelSettings.categoryLabelColor = powerbi.DataViewObjects.getFillColor(objects, visuals.cardProps.categoryLabels.color, labelSettings.categoryLabelColor);
	                            this.cardFormatSetting.wordWrap = powerbi.DataViewObjects.getValue(objects, visuals.cardProps.wordWrap.show, this.cardFormatSetting.wordWrap);
	                            this.cardFormatSetting.textSize = powerbi.DataViewObjects.getValue(objects, visuals.cardProps.categoryLabels.fontSize, this.cardFormatSetting.textSize);
	                        }
	                    }
	                }
	                this.updateInternal(value, true /* suppressAnimations */, true /* forceUpdate */);
	            };
	            Card.prototype.onResizing = function (viewport) {
	                this.currentViewport = viewport;
	                this.updateViewportProperties();
	                this.updateInternal(this.value, true /* suppressAnimations */, true /* forceUpdate */);
	            };
	            Card.prototype.updateViewportProperties = function () {
	                var viewport = this.currentViewport;
	                this.svg.attr('width', viewport.width)
	                    .attr('height', viewport.height);
	            };
	            Card.prototype.setTextProperties = function (text, fontSize) {
	                Card.cardTextProperties.fontSize = jsCommon.PixelConverter.fromPoint(fontSize);
	                Card.cardTextProperties.text = text;
	            };
	            Card.prototype.getCardFormatTextSize = function () {
	                return this.cardFormatSetting.textSize;
	            };
	            Card.prototype.isSmallViewport = function () {
	                if (this.cardSmallViewportProperties) {
	                    if (this.currentViewport.width < this.cardSmallViewportProperties.cardSmallViewportWidth) {
	                        return true;
	                    }
	                }
	                return false;
	            };
	            Card.prototype.getCardPrecision = function (isSmallViewport) {
	                if (isSmallViewport === void 0) { isSmallViewport = false; }
	                return isSmallViewport ? visuals.dataLabelUtils.defaultLabelPrecision : this.cardFormatSetting.labelSettings.precision;
	            };
	            Card.prototype.getCardDisplayUnits = function (isSmallViewport) {
	                if (isSmallViewport === void 0) { isSmallViewport = false; }
	                return isSmallViewport ? 0 : this.cardFormatSetting.labelSettings.displayUnits;
	            };
	            Card.prototype.getAdjustedFontHeight = function (availableWidth, textToMeasure, seedFontHeight) {
	                var adjustedFontHeight = _super.prototype.getAdjustedFontHeight.call(this, availableWidth, textToMeasure, seedFontHeight);
	                return Math.min(adjustedFontHeight, Card.DefaultStyle.card.maxFontSize);
	            };
	            Card.prototype.clear = function (valueOnly) {
	                if (valueOnly === void 0) { valueOnly = false; }
	                this.svg.select(Card.Value.selector).text('');
	                if (!valueOnly)
	                    this.svg.select(Card.Label.selector).text('');
	                _super.prototype.clear.call(this);
	            };
	            Card.prototype.updateInternal = function (target, suppressAnimations, forceUpdate) {
	                if (forceUpdate === void 0) { forceUpdate = false; }
	                var start = this.value;
	                var duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
	                if (target === undefined) {
	                    if (start !== undefined)
	                        this.clear();
	                    return;
	                }
	                var metaDataColumn = this.metaDataColumn;
	                var labelSettings = this.cardFormatSetting.labelSettings;
	                var isSmallViewport = this.isSmallViewport();
	                var precision = this.getCardPrecision(isSmallViewport);
	                var displayUnits = this.getCardDisplayUnits(isSmallViewport);
	                var isDefaultDisplayUnit = displayUnits === 0;
	                var format = this.getFormatString(metaDataColumn);
	                var formatter = visuals.valueFormatter.create({
	                    format: format,
	                    value: isDefaultDisplayUnit ? target : displayUnits,
	                    precision: visuals.dataLabelUtils.getLabelPrecision(precision, format),
	                    displayUnitSystemType: isDefaultDisplayUnit && precision === visuals.dataLabelUtils.defaultLabelPrecision ? this.displayUnitSystemType : powerbi.DisplayUnitSystemType.WholeUnits,
	                    formatSingleValues: isDefaultDisplayUnit ? true : false,
	                    allowFormatBeautification: true,
	                    columnType: metaDataColumn ? metaDataColumn.type : undefined
	                });
	                var formatSettings = this.cardFormatSetting;
	                var valueTextHeightInPx = jsCommon.PixelConverter.fromPointToPixel(labelSettings.fontSize);
	                var valueStyles = Card.DefaultStyle.value;
	                this.setTextProperties(target, this.getCardFormatTextSize());
	                var labelTextHeightInPx = labelSettings.showCategory ? powerbi.TextMeasurementService.estimateSvgTextHeight(Card.cardTextProperties) : 0;
	                var labelHeightWithPadding = labelTextHeightInPx + Card.DefaultStyle.label.paddingTop;
	                var width = this.currentViewport.width;
	                var height = this.currentViewport.height;
	                var translateX = this.getTranslateX(width);
	                var translateY = (height - labelHeightWithPadding - valueTextHeightInPx) / 2;
	                var statusGraphicInfo = getKpiImageMetadata(metaDataColumn, target, 1 /* Big */);
	                if (this.isScrollable) {
	                    if (!forceUpdate && start === target)
	                        return;
	                    // We want to format for null/blank/empty string and anything that is not a string
	                    if (start !== target && (_.isEmpty(target) || typeof (target) !== "string"))
	                        target = formatter.format(target);
	                    if (statusGraphicInfo) {
	                        // Display card KPI icon
	                        this.graphicsContext.selectAll('text').remove();
	                        this.displayStatusGraphic(statusGraphicInfo, translateX, translateY, valueTextHeightInPx);
	                    }
	                    else {
	                        // Display card text value
	                        this.kpiImage.selectAll('div').remove();
	                        var translatedValueY = this.getTranslateY(valueTextHeightInPx + translateY);
	                        var valueElement = this.graphicsContext
	                            .attr('transform', visuals.SVGUtil.translate(translateX, translatedValueY))
	                            .selectAll('text')
	                            .data([target]);
	                        valueElement
	                            .enter()
	                            .append('text')
	                            .attr('class', Card.Value.class);
	                        valueElement
	                            .text(function (d) { return d; })
	                            .style({
	                            'font-size': jsCommon.PixelConverter.fromPoint(labelSettings.fontSize),
	                            'fill': labelSettings.labelColor,
	                            'font-family': valueStyles.fontFamily,
	                            'text-anchor': this.getTextAnchor(),
	                        });
	                        if (formatSettings.wordWrap) {
	                            var valueElementNode = valueElement.node();
	                            powerbi.TextMeasurementService.wordBreak(valueElementNode, width, height - labelHeightWithPadding);
	                            var numLines = valueElementNode.childElementCount;
	                            if (numLines > 1) {
	                                var valueTextLineHeight = valueTextHeightInPx;
	                                valueTextHeightInPx *= numLines;
	                                // Use the full height of all the text to figure out the top of the vertically centered container (translateY)
	                                translateY = (height - labelHeightWithPadding - valueTextHeightInPx) / 2;
	                                // But only use height of one line when figuring out the anchor point for the text since its vertical anchor is on
	                                // the baseline of the 1st row.
	                                translatedValueY = this.getTranslateY(valueTextLineHeight + translateY);
	                                this.graphicsContext.attr('transform', visuals.SVGUtil.translate(translateX, translatedValueY));
	                            }
	                        }
	                        else {
	                            valueElement.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width, powerbi.TextMeasurementService.svgEllipsis);
	                        }
	                        valueElement
	                            .append('title')
	                            .text(function (d) { return d; });
	                        valueElement.exit().remove();
	                    }
	                    // Show the label if it's enabled and we have a value to display
	                    if (labelSettings.showCategory && metaDataColumn && metaDataColumn.displayName) {
	                        var labelData = [metaDataColumn.displayName];
	                        var translatedLabelY = this.getTranslateY(valueTextHeightInPx + labelHeightWithPadding + translateY);
	                        var labelElement = this.labelContext
	                            .attr('transform', visuals.SVGUtil.translate(translateX, translatedLabelY))
	                            .selectAll('text')
	                            .data(labelData);
	                        labelElement
	                            .enter()
	                            .append('text')
	                            .attr('class', Card.Label.class);
	                        labelElement
	                            .text(function (d) { return d; })
	                            .style({
	                            'font-size': jsCommon.PixelConverter.fromPoint(this.getCardFormatTextSize()),
	                            'fill': labelSettings.categoryLabelColor,
	                            'text-anchor': this.getTextAnchor()
	                        });
	                        var labelElementNode = labelElement.node();
	                        if (labelElementNode) {
	                            if (formatSettings.wordWrap)
	                                powerbi.TextMeasurementService.wordBreak(labelElementNode, width / 2, height - translatedLabelY);
	                            else
	                                labelElement.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width, powerbi.TextMeasurementService.svgEllipsis);
	                        }
	                        labelElement
	                            .append('title')
	                            .text(function (d) { return d; });
	                        labelElement.exit().remove();
	                    }
	                    else {
	                        // Otherwise, remove any existing labels we may have been displaying
	                        this.labelContext.selectAll('text').remove();
	                    }
	                }
	                else {
	                    if (statusGraphicInfo) {
	                        // Display card KPI icon
	                        this.graphicsContext.selectAll('text').remove();
	                        this.displayStatusGraphic(statusGraphicInfo, translateX, translateY, valueTextHeightInPx);
	                    }
	                    else {
	                        this.kpiImage.selectAll('div').remove();
	                        this.doValueTransition(start, target, this.displayUnitSystemType, this.animationOptions, duration, forceUpdate, formatter);
	                        //in order to remove duplicated title values we first remove all and than add a new one
	                        this.graphicsContext.call(visuals.tooltipUtils.tooltipUpdate, [target]);
	                    }
	                }
	                this.value = target;
	            };
	            Card.prototype.displayStatusGraphic = function (statusGraphicInfo, translateX, translateY, labelTextSizeInPx) {
	                // Remove existing text
	                this.graphicsContext.selectAll('text').remove();
	                // Create status graphic, if necessary
	                var kpiImageDiv = this.kpiImage.select('div');
	                if (!kpiImageDiv || kpiImageDiv.empty())
	                    kpiImageDiv = this.kpiImage.append('div');
	                // Style status graphic
	                kpiImageDiv
	                    .attr('class', statusGraphicInfo.class)
	                    .style('position', 'absolute')
	                    .style('font-size', labelTextSizeInPx + 'px');
	                // Layout thrash to get image dimensions (could set as a const in future when icon font is fixed)
	                var imageWidth = kpiImageDiv.node().offsetWidth;
	                var imageHeight = kpiImageDiv.node().offsetHeight;
	                // Position based on image height
	                kpiImageDiv.style('transform', visuals.SVGUtil.translateWithPixels((translateX - (imageWidth / 2)), this.getTranslateY(labelTextSizeInPx + translateY) - imageHeight));
	            };
	            Card.prototype.getDefaultFormatSettings = function () {
	                return {
	                    labelSettings: visuals.dataLabelUtils.getDefaultCardLabelSettings(Card.DefaultStyle.value.color, Card.DefaultStyle.label.color, Card.DefaultStyle.value.textSize),
	                    wordWrap: false,
	                    textSize: Card.DefaultStyle.label.textSize,
	                };
	            };
	            Card.prototype.enumerateObjectInstances = function (options) {
	                if (!this.cardFormatSetting)
	                    this.cardFormatSetting = this.getDefaultFormatSettings();
	                var formatSettings = this.cardFormatSetting;
	                var enumeration = new visuals.ObjectEnumerationBuilder();
	                switch (options.objectName) {
	                    case 'categoryLabels':
	                        visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, formatSettings.labelSettings, true /* withFill */, true /* isShowCategory */, formatSettings.textSize);
	                        break;
	                    case 'labels':
	                        var labelSettingOptions = {
	                            enumeration: enumeration,
	                            dataLabelsSettings: formatSettings.labelSettings,
	                            show: true,
	                            displayUnits: true,
	                            precision: true,
	                            fontSize: true,
	                        };
	                        visuals.dataLabelUtils.enumerateDataLabels(labelSettingOptions);
	                        break;
	                    case 'wordWrap':
	                        enumeration.pushInstance({
	                            objectName: 'wordWrap',
	                            selector: null,
	                            properties: {
	                                show: formatSettings.wordWrap,
	                            },
	                        });
	                        break;
	                }
	                return enumeration.complete();
	            };
	            Card.cardClassName = 'card';
	            Card.Label = createClassAndSelector('label');
	            Card.Value = createClassAndSelector('value');
	            Card.KPIImage = createClassAndSelector('caption');
	            Card.cardTextProperties = {
	                fontSize: null,
	                text: null,
	                fontFamily: visuals.dataLabelUtils.LabelTextProperties.fontFamily,
	            };
	            Card.DefaultStyle = {
	                card: {
	                    maxFontSize: 200
	                },
	                label: {
	                    textSize: 12,
	                    color: '#a6a6a6',
	                    paddingTop: 8
	                },
	                value: {
	                    textSize: 27,
	                    color: '#333333',
	                    fontFamily: visuals.Font.Family.regularSecondary.css
	                }
	            };
	            return Card;
	        }(visuals.AnimatedText));
	        visuals.Card = Card;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 279 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var OwlHappiness;
	        (function (OwlHappiness) {
	            OwlHappiness[OwlHappiness["Sad"] = 0] = "Sad";
	            OwlHappiness[OwlHappiness["Meh"] = 1] = "Meh";
	            OwlHappiness[OwlHappiness["Happy"] = 2] = "Happy";
	        })(OwlHappiness || (OwlHappiness = {}));
	        var OwlGauge = (function () {
	            function OwlGauge() {
	            }
	            OwlGauge.converter = function (dataView) {
	                return {};
	            };
	            OwlGauge.getGaugeData = function (dataView) {
	                var settings = {
	                    max: 100,
	                    min: 0,
	                    target: undefined,
	                    value: 0,
	                    tooltipItems: []
	                };
	                if (dataView && dataView.categorical && dataView.categorical.values && dataView.metadata && dataView.metadata.columns) {
	                    var values = dataView.categorical.values;
	                    var metadataColumns = dataView.metadata.columns;
	                    debug.assert(metadataColumns.length >= values.length, 'length');
	                    for (var i = 0; i < values.length; i++) {
	                        var col = metadataColumns[i], value = values[i].values[0] || 0;
	                        if (col && col.roles) {
	                            if (col.roles[visuals.gaugeRoleNames.y]) {
	                                settings.value = value;
	                                if (value)
	                                    settings.tooltipItems.push({ displayName: values[i].source.displayName, value: visuals.converterHelper.formatFromMetadataColumn(value, values[i].source, visuals.Gauge.formatStringProp) });
	                            }
	                            else if (col.roles[visuals.gaugeRoleNames.minValue]) {
	                                settings.min = value;
	                            }
	                            else if (col.roles[visuals.gaugeRoleNames.maxValue]) {
	                                settings.max = value;
	                            }
	                            else if (col.roles[visuals.gaugeRoleNames.targetValue]) {
	                                settings.target = value;
	                                if (value)
	                                    settings.tooltipItems.push({ displayName: values[i].source.displayName, value: visuals.converterHelper.formatFromMetadataColumn(value, values[i].source, visuals.Gauge.formatStringProp) });
	                            }
	                        }
	                    }
	                }
	                return settings;
	            };
	            OwlGauge.prototype.init = function (options) {
	                var _this = this;
	                this.rootElem = options.element;
	                this.rootElem.addClass('owlGaugeVisual');
	                this.svgTailElem = $(OwlGauge.owlTailSvg);
	                this.svgBgElem = $(OwlGauge.visualBgSvg);
	                this.svgBodyElem = $(OwlGauge.owlBodySvg);
	                this.rootElem.append(this.svgBgElem).append(this.svgTailElem).append(this.svgBodyElem);
	                if (OwlGauge.OwlDemoMode) {
	                    window.setInterval(function () {
	                        var randomPercentage = Math.random() * 100 + 1;
	                        _this.updateGauge(randomPercentage);
	                    }, 2000);
	                }
	                this.updateViewportSize(options.viewport.width, options.viewport.height);
	            };
	            OwlGauge.prototype.update = function (options) {
	                this.updateViewportSize(options.viewport.width, options.viewport.height);
	                var dataView = options.dataViews.length > 0 ? options.dataViews[0] : null;
	                if (dataView) {
	                    var gaugeData = OwlGauge.getGaugeData(options.dataViews[0]);
	                    var percentage = (gaugeData.value - gaugeData.min) / (gaugeData.max - gaugeData.min);
	                    this.updateGauge(percentage * 100 | 0);
	                }
	                else
	                    this.updateGauge(0);
	            };
	            OwlGauge.prototype.updateGauge = function (percentage) {
	                if (percentage >= 0 && percentage <= 100) {
	                    var rotationDeg = -180 + (180 * percentage / 100);
	                    this.svgBgElem.css({ transform: 'rotate(' + rotationDeg + 'deg)' });
	                    if (percentage >= 66) {
	                        this.happinessLevel = OwlHappiness.Happy;
	                    }
	                    else if (percentage >= 33) {
	                        this.happinessLevel = OwlHappiness.Meh;
	                    }
	                    else {
	                        this.happinessLevel = OwlHappiness.Sad;
	                    }
	                }
	            };
	            Object.defineProperty(OwlGauge.prototype, "happinessLevel", {
	                set: function (level) {
	                    this.rootElem.removeClass('sad').removeClass('meh').removeClass('happy');
	                    switch (level) {
	                        case OwlHappiness.Sad:
	                            this.rootElem.addClass('sad');
	                            break;
	                        case OwlHappiness.Meh:
	                            this.rootElem.addClass('meh');
	                            break;
	                        case OwlHappiness.Happy:
	                            this.rootElem.addClass('happy');
	                            break;
	                        default:
	                            console.log('Well, this is interesting...');
	                    }
	                },
	                enumerable: true,
	                configurable: true
	            });
	            OwlGauge.prototype.updateViewportSize = function (width, height) {
	                var _this = this;
	                var smoothingFn = window.setImmediate || window.requestAnimationFrame;
	                smoothingFn(function () {
	                    _this.rootElem.css({
	                        height: height,
	                        width: width
	                    });
	                    _this.svgBodyElem.height(_this.svgBodyElem.width() * OwlGauge.owlBodyHeightMultiplier);
	                    _this.svgBgElem.height(_this.svgBgElem.width() * OwlGauge.visualBgHeightMultiplier);
	                    _this.svgTailElem.height(_this.svgTailElem.width() * OwlGauge.owlTailHeightMultiplier);
	                });
	            };
	            OwlGauge.owlBodySvg = '<svg version="1.1" class="owlGaugeBody" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 267.7 291.2" style="enable-background:new 0 0 267.7 291.2;" xml:space="preserve"> <style type="text/css"> .owlGaugeBody .st0{fill:#A87D50;} .owlGaugeBody .st1{fill:#C2B59B;} .owlGaugeBody .st2{fill:#EB2227;} .owlGaugeBody .st3{fill:#FFFFFF;} .owlGaugeBody .st4{fill:#F9D018;} .owlGaugeBody .st5{fill:none;} .owlGaugeBody .st6{fill:#83381B;} .owlGaugeBody .st7{fill:#231F20;} </style> <g id="XMLID_31_"> <g id="XMLID_34_"> <ellipse id="XMLID_21_" transform="matrix(0.9998 1.947640e-02 -1.947640e-02 0.9998 2.8614 -2.5802)" class="st0" cx="133.9" cy="145.6" rx="133.9" ry="145.6"/> <polygon id="XMLID_20_" class="st0" points="199.2,32.8 184,11.3 209,9.7 "/> <polygon id="XMLID_19_" class="st0" points="73.9,31.2 62.1,7.7 87.1,9.8 "/> <circle id="XMLID_18_" class="st1" cx="134.8" cy="189.2" r="89.8"/> <path id="XMLID_17_" class="st2" d="M140.1,88c-2.7,3.8-7.9,4.7-11.7,2c-2.7-1.9-3.9-5.1-3.4-8.1c0,0,9.6-41.8,9.6-41.8l6.9,40.8 C142,83.2,141.6,85.8,140.1,88z"/> <path id="XMLID_16_" class="st3" d="M164.6,16.2c-14.2,0-26.3,9.2-30.6,21.9c-4.1-13.1-16.3-22.6-30.8-22.6 C85.4,15.6,71,30,71,47.8s14.4,32.3,32.3,32.3c14.2,0,26.3-9.2,30.6-21.9c4.1,13.1,16.3,22.6,30.8,22.6 c17.8,0,32.3-14.4,32.3-32.3S182.4,16.2,164.6,16.2z"/> <path id="XMLID_15_" class="st4" d="M122,58.7l23.3-0.1c0,0-9,14.8-10.2,16.6c-1.2,1.9-2.2,0.1-2.2,0.1L122,58.7z"/> <rect id="XMLID_14_" x="-11.4" y="-68.8" class="st5" width="288.3" height="259.7"/> <g id="XMLID_37_"> <path id="XMLID_13_" class="st6" d="M121.6,125.5c0,3.7-3.5,6.6-7.7,6.6c-4.2,0-7.7-3-7.7-6.6"/> <path id="XMLID_12_" class="st6" d="M160.1,126.5c0,3.7-3.5,6.6-7.7,6.6s-7.7-3-7.7-6.6"/> <path id="XMLID_11_" class="st6" d="M142.4,148.1c0,3.7-3.5,6.6-7.7,6.6c-4.2,0-7.7-3-7.7-6.6"/> <path id="XMLID_10_" class="st6" d="M183.1,148.8c0,3.7-3.5,6.6-7.7,6.6c-4.2,0-7.7-3-7.7-6.6"/> <path id="XMLID_9_" class="st6" d="M160.9,177.4c0,3.7-3.5,6.6-7.7,6.6s-7.7-3-7.7-6.6"/> <path id="XMLID_8_" class="st6" d="M201.6,178c0,3.7-3.5,6.6-7.7,6.6s-7.7-3-7.7-6.6"/> <path id="XMLID_7_" class="st6" d="M76.4,177.4c0,3.7-3.5,6.6-7.7,6.6c-4.2,0-7.7-3-7.7-6.6"/> <path id="XMLID_6_" class="st6" d="M117,178c0,3.7-3.5,6.6-7.7,6.6s-7.7-3-7.7-6.6"/> <path id="XMLID_5_" class="st6" d="M98.6,148.1c0,3.7-3.5,6.6-7.7,6.6c-4.2,0-7.7-3-7.7-6.6"/> </g> <circle id="XMLID_4_" class="st7" cx="164.1" cy="49" r="6.4"/> <circle id="XMLID_3_" class="st7" cx="102.7" cy="47.7" r="6.4"/> </g> <path id="XMLID_2_" class="st0" d="M160.1,140.9c11.1-8.4,55.6-36,55.6-36l4.7,0.8l10.2,38.8c0,0-3,3-9.2,3.1 c-5.1,0.1-45.9-2.6-60.2-3.5C158.1,143.9,157.7,142.7,160.1,140.9z"/> <path id="XMLID_1_" class="st0" d="M110.6,140.8c-11.1-8.4-55.6-36-55.6-36l-4.7,0.8L40,144.4c0,0,3,3,9.2,3.1 c5.1,0.1,45.9-2.6,60.2-3.5C112.5,143.8,113,142.6,110.6,140.8z"/> </g> </svg>';
	            OwlGauge.owlTailSvg = '<svg version="1.1" class="owlGaugeTail" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 587.8 295.5" style="enable-background:new 0 0 587.8 295.5;" xml:space="preserve"> <style type="text/css"> .owlGaugeTail .st0{fill:#3B2416;} .owlGaugeTail .st1{fill:#5B4B43;} .owlGaugeTail .st2{fill:#603A17;} .owlGaugeTail .st3{fill:#726659;} </style> <g id="XMLID_55_"> <path id="XMLID_29_" class="st0" d="M85.2,106.2c-27.1,0-49.2,22-49.2,49.2c0,19.1,10.9,35.7,26.9,43.8c0,0,231.2,95.9,231.2,95.9 l-171-171C114.1,113.2,100.5,106.2,85.2,106.2z"/> <g id="XMLID_56_"> <path id="XMLID_28_" class="st1" d="M482.5,86.4c0-27.1-22-49.2-49.2-49.2c-19.1,0-35.7,10.9-43.8,26.9c0,0-95.9,231.2-95.9,231.2 l171-171C475.5,115.3,482.5,101.7,482.5,86.4z"/> <path id="XMLID_27_" class="st2" d="M573.5,281.3c19.2-19.2,19.2-50.3,0-69.5c-13.5-13.5-33-17.5-50-12c0,0-231.3,95.7-231.3,95.7 l241.8,0C548,296.9,562.6,292.1,573.5,281.3z"/> <path id="XMLID_26_" class="st3" d="M279.9,14.4c-19.2-19.2-50.3-19.2-69.5,0c-13.5,13.5-17.5,33-12,50c0,0,95.7,231.3,95.7,231.3 L294,54C295.4,39.8,290.7,25.2,279.9,14.4z"/> <path id="XMLID_25_" class="st2" d="M105.3,86.4c0-27.1,22-49.2,49.2-49.2c19.1,0,35.7,10.9,43.8,26.9c0,0,95.9,231.2,95.9,231.2 l-171-171C112.3,115.3,105.3,101.7,105.3,86.4z"/> <path id="XMLID_24_" class="st2" d="M14.4,281.4c-19.2-19.2-19.2-50.3,0-69.5c13.5-13.5,33-17.5,50-12c0,0,231.3,95.7,231.3,95.7 l-241.8,0C39.8,297,25.2,292.3,14.4,281.4z"/> <path id="XMLID_23_" class="st2" d="M308.2,14c19.2-19.2,50.3-19.2,69.5,0c13.5,13.5,17.5,33,12,50c0,0-95.7,231.3-95.7,231.3 l0-241.8C292.6,39.4,297.4,24.8,308.2,14z"/> <path id="XMLID_22_" class="st0" d="M503.2,106c27.1,0,49.2,22,49.2,49.2c0,19.1-10.9,35.7-26.9,43.8c0,0-231.2,95.9-231.2,95.9 l171-171C474.2,113,487.8,106,503.2,106z"/> </g> </g> </svg>';
	            OwlGauge.visualBgSvg = '<svg version="1.1" class="owlGaugeBg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="123.8 94.9 349.1 175.3" style="enable-background:new 123.8 94.9 349.1 175.3;" xml:space="preserve"> <style type="text/css"> .owlGaugeBg .st0{fill:#EF4137;} .owlGaugeBg .st1{fill:#FAAF42;} .owlGaugeBg .st2{fill:#F15B2A;} .owlGaugeBg .st3{fill:#F69321;} </style> <g id="XMLID_10_"> <path id="XMLID_8_" class="st0" d="M174.3,158c-16.1,0-29.2,13.1-29.2,29.2c0,11.4,6.5,21.2,16,26.1l137.3,57L196.9,168.7 C191.5,162.2,183.4,158,174.3,158z"/> <g id="XMLID_11_"> <path id="XMLID_7_" class="st1" d="M410.2,146.3c0-16.1-13.1-29.2-29.2-29.2c-11.4,0-21.2,6.5-26,16l-57,137.5L399.5,169 C406.1,163.5,410.2,155.4,410.2,146.3z"/> <path id="XMLID_6_" class="st0" d="M464.3,262.2c11.4-11.4,11.4-29.9,0-41.3c-8-8-19.6-10.4-29.7-7.1l-137.4,56.9h143.6 C449.2,271.4,457.9,268.6,464.3,262.2z"/> <path id="XMLID_5_" class="st2" d="M290,103.5c-11.4-11.4-29.9-11.4-41.3,0c-8,8-10.4,19.6-7.1,29.7l56.8,137.5V127 C299.2,118.6,296.4,109.9,290,103.5z"/> <path id="XMLID_4_" class="st3" d="M186.3,146.3c0-16.1,13.1-29.2,29.2-29.2c11.4,0,21.2,6.5,26,16l57,137.5L197,168.8 C190.5,163.5,186.3,155.4,186.3,146.3z"/> <path id="XMLID_3_" class="st2" d="M132.3,262.2c-11.4-11.4-11.4-29.9,0-41.3c8-8,19.6-10.4,29.7-7.1l137.4,56.9H155.8 C147.4,271.5,138.7,268.7,132.3,262.2z"/> <path id="XMLID_2_" class="st3" d="M306.8,103.2c11.4-11.4,29.9-11.4,41.3,0c8,8,10.4,19.6,7.1,29.7l-56.8,137.5V126.7 C297.5,118.3,300.3,109.7,306.8,103.2z"/> <path id="XMLID_1_" class="st2" d="M422.5,157.9c16.1,0,29.2,13.1,29.2,29.2c0,11.4-6.5,21.2-16,26.1l-137.3,57L400,168.6 C405.3,162.1,413.4,157.9,422.5,157.9z"/> </g> </g> </svg>';
	            OwlGauge.owlBodyHeightMultiplier = 291.2 / 267.7;
	            OwlGauge.owlTailHeightMultiplier = 295.5 / 587.8;
	            OwlGauge.visualBgHeightMultiplier = 295.5 / 587.8;
	            OwlGauge.OwlDemoMode = false;
	            OwlGauge.capabilities = {
	                dataRoles: [
	                    {
	                        displayName: 'Category',
	                        name: 'Category',
	                        kind: powerbi.VisualDataRoleKind.Grouping,
	                    },
	                    {
	                        displayName: 'Y Axis',
	                        name: 'Y',
	                        kind: powerbi.VisualDataRoleKind.Measure,
	                    },
	                ],
	                dataViewMappings: [{
	                        categorical: {
	                            categories: {
	                                for: { in: 'Category' },
	                                dataReductionAlgorithm: { top: {} }
	                            },
	                            values: {
	                                select: [{ bind: { to: 'Y' } }]
	                            },
	                        }
	                    }]
	            };
	            return OwlGauge;
	        }());
	        visuals.OwlGauge = OwlGauge;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 280 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var NoMapLocationWarning = (function () {
	            function NoMapLocationWarning() {
	            }
	            Object.defineProperty(NoMapLocationWarning.prototype, "code", {
	                get: function () {
	                    return 'NoMapLocation';
	                },
	                enumerable: true,
	                configurable: true
	            });
	            NoMapLocationWarning.prototype.getMessages = function (resourceProvider) {
	                var messageKey = 'NoMapLocationMessage';
	                var titleKey = 'NoMapLocationKey';
	                var detailKey = 'NoMapLocationValue';
	                var visualMessage = {
	                    message: resourceProvider.get(messageKey),
	                    title: resourceProvider.get(titleKey),
	                    detail: resourceProvider.get(detailKey),
	                };
	                return visualMessage;
	            };
	            return NoMapLocationWarning;
	        }());
	        visuals.NoMapLocationWarning = NoMapLocationWarning;
	        var FilledMapWithoutValidGeotagCategoryWarning = (function () {
	            function FilledMapWithoutValidGeotagCategoryWarning() {
	            }
	            Object.defineProperty(FilledMapWithoutValidGeotagCategoryWarning.prototype, "code", {
	                get: function () {
	                    return 'NoValidGeotaggedCategory';
	                },
	                enumerable: true,
	                configurable: true
	            });
	            FilledMapWithoutValidGeotagCategoryWarning.prototype.getMessages = function (resourceProvider) {
	                var messageKey = 'NoValidGeotaggedCategoryMessage';
	                var titleKey = 'NoValidGeotaggedCategoryKey';
	                var detailKey = 'NoValidGeotaggedCategoryValue';
	                var visualMessage = {
	                    message: resourceProvider.get(messageKey),
	                    title: resourceProvider.get(titleKey),
	                    detail: resourceProvider.get(detailKey),
	                };
	                return visualMessage;
	            };
	            return FilledMapWithoutValidGeotagCategoryWarning;
	        }());
	        visuals.FilledMapWithoutValidGeotagCategoryWarning = FilledMapWithoutValidGeotagCategoryWarning;
	        var GeometryCulledWarning = (function () {
	            function GeometryCulledWarning() {
	            }
	            Object.defineProperty(GeometryCulledWarning.prototype, "code", {
	                get: function () {
	                    return 'GeometryCulledWarning';
	                },
	                enumerable: true,
	                configurable: true
	            });
	            GeometryCulledWarning.prototype.getMessages = function (resourceProvider) {
	                var messageKey = 'GeometryCulledWarningMessage';
	                var titleKey = 'GeometryCulledWarningKey';
	                var detailKey = 'GeometryCulledWarningVal';
	                var visualMessage = {
	                    message: resourceProvider.get(messageKey),
	                    title: resourceProvider.get(titleKey),
	                    detail: resourceProvider.get(detailKey),
	                };
	                return visualMessage;
	            };
	            return GeometryCulledWarning;
	        }());
	        visuals.GeometryCulledWarning = GeometryCulledWarning;
	        var NegativeValuesNotSupportedWarning = (function () {
	            function NegativeValuesNotSupportedWarning() {
	            }
	            Object.defineProperty(NegativeValuesNotSupportedWarning.prototype, "code", {
	                get: function () {
	                    return 'NegativeValuesNotSupported';
	                },
	                enumerable: true,
	                configurable: true
	            });
	            NegativeValuesNotSupportedWarning.prototype.getMessages = function (resourceProvider) {
	                var messageKey = 'VisualWarning_NegativeValues';
	                var visualMessage = {
	                    message: resourceProvider.get(messageKey),
	                    title: '',
	                    detail: '',
	                };
	                return visualMessage;
	            };
	            return NegativeValuesNotSupportedWarning;
	        }());
	        visuals.NegativeValuesNotSupportedWarning = NegativeValuesNotSupportedWarning;
	        var AllNegativeValuesWarning = (function () {
	            function AllNegativeValuesWarning() {
	            }
	            Object.defineProperty(AllNegativeValuesWarning.prototype, "code", {
	                get: function () {
	                    return 'AllNegativeValuesNotSupported';
	                },
	                enumerable: true,
	                configurable: true
	            });
	            AllNegativeValuesWarning.prototype.getMessages = function (resourceProvider) {
	                var messageKey = 'VisualWarning_AllNegativeValues';
	                var visualMessage = {
	                    message: resourceProvider.get(messageKey),
	                    title: '',
	                    detail: '',
	                };
	                return visualMessage;
	            };
	            return AllNegativeValuesWarning;
	        }());
	        visuals.AllNegativeValuesWarning = AllNegativeValuesWarning;
	        var NaNNotSupportedWarning = (function () {
	            function NaNNotSupportedWarning() {
	            }
	            Object.defineProperty(NaNNotSupportedWarning.prototype, "code", {
	                get: function () {
	                    return 'NaNNotSupported';
	                },
	                enumerable: true,
	                configurable: true
	            });
	            NaNNotSupportedWarning.prototype.getMessages = function (resourceProvider) {
	                var messageKey = 'VisualWarning_NanValues';
	                var visualMessage = {
	                    message: resourceProvider.get(messageKey),
	                    title: '',
	                    detail: '',
	                };
	                return visualMessage;
	            };
	            return NaNNotSupportedWarning;
	        }());
	        visuals.NaNNotSupportedWarning = NaNNotSupportedWarning;
	        var InfinityValuesNotSupportedWarning = (function () {
	            function InfinityValuesNotSupportedWarning() {
	            }
	            Object.defineProperty(InfinityValuesNotSupportedWarning.prototype, "code", {
	                get: function () {
	                    return 'InfinityValuesNotSupported';
	                },
	                enumerable: true,
	                configurable: true
	            });
	            InfinityValuesNotSupportedWarning.prototype.getMessages = function (resourceProvider) {
	                var messageKey = 'VisualWarning_InfinityValues';
	                var visualMessage = {
	                    message: resourceProvider.get(messageKey),
	                    title: '',
	                    detail: '',
	                };
	                return visualMessage;
	            };
	            return InfinityValuesNotSupportedWarning;
	        }());
	        visuals.InfinityValuesNotSupportedWarning = InfinityValuesNotSupportedWarning;
	        var ValuesOutOfRangeWarning = (function () {
	            function ValuesOutOfRangeWarning() {
	            }
	            Object.defineProperty(ValuesOutOfRangeWarning.prototype, "code", {
	                get: function () {
	                    return 'ValuesOutOfRange';
	                },
	                enumerable: true,
	                configurable: true
	            });
	            ValuesOutOfRangeWarning.prototype.getMessages = function (resourceProvider) {
	                var messageKey = 'VisualWarning_VisualizationOutOfRange';
	                var visualMessage = {
	                    message: resourceProvider.get(messageKey),
	                    title: '',
	                    detail: '',
	                };
	                return visualMessage;
	            };
	            return ValuesOutOfRangeWarning;
	        }());
	        visuals.ValuesOutOfRangeWarning = ValuesOutOfRangeWarning;
	        var ZeroValueWarning = (function () {
	            function ZeroValueWarning() {
	            }
	            Object.defineProperty(ZeroValueWarning.prototype, "code", {
	                get: function () {
	                    return "ZeroValuesNotSupported";
	                },
	                enumerable: true,
	                configurable: true
	            });
	            ZeroValueWarning.prototype.getMessages = function (resourceProvider) {
	                var messageKey = 'VisualWarning_ZeroValues';
	                var visualMessage = {
	                    message: resourceProvider.get(messageKey),
	                    title: '',
	                    detail: '',
	                };
	                return visualMessage;
	            };
	            return ZeroValueWarning;
	        }());
	        visuals.ZeroValueWarning = ZeroValueWarning;
	        var VisualKPIDataMissingWarning = (function () {
	            function VisualKPIDataMissingWarning() {
	            }
	            Object.defineProperty(VisualKPIDataMissingWarning.prototype, "code", {
	                get: function () {
	                    return "VisualKPIDataMissing";
	                },
	                enumerable: true,
	                configurable: true
	            });
	            VisualKPIDataMissingWarning.prototype.getMessages = function (resourceProvider) {
	                var messageKey = 'Visual_KPI_DataMissing';
	                var visualMessage = {
	                    message: resourceProvider.get(messageKey),
	                    title: '',
	                    detail: '',
	                };
	                return visualMessage;
	            };
	            return VisualKPIDataMissingWarning;
	        }());
	        visuals.VisualKPIDataMissingWarning = VisualKPIDataMissingWarning;
	        var ScriptVisualRefreshWarning = (function () {
	            function ScriptVisualRefreshWarning() {
	            }
	            Object.defineProperty(ScriptVisualRefreshWarning.prototype, "code", {
	                get: function () {
	                    return "ScriptVisualNotRefreshed";
	                },
	                enumerable: true,
	                configurable: true
	            });
	            ScriptVisualRefreshWarning.prototype.getMessages = function (resourceProvider) {
	                var messageKey = 'ScriptVisualRefreshWarningMessage';
	                var detailKey = 'ScriptVisualRefreshWarningValue';
	                var visualMessage = {
	                    message: resourceProvider.get(messageKey),
	                    title: resourceProvider.get(messageKey),
	                    detail: resourceProvider.get(detailKey),
	                };
	                return visualMessage;
	            };
	            return ScriptVisualRefreshWarning;
	        }());
	        visuals.ScriptVisualRefreshWarning = ScriptVisualRefreshWarning;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 281 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var PixelConverter = jsCommon.PixelConverter;
	        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
	        var WaterfallChart = (function () {
	            function WaterfallChart(options) {
	                this.isScrollable = options.isScrollable;
	                this.tooltipsEnabled = options.tooltipsEnabled;
	                this.tooltipBucketEnabled = options.tooltipBucketEnabled;
	                this.interactivityService = options.interactivityService;
	            }
	            WaterfallChart.prototype.init = function (options) {
	                debug.assertValue(options, 'options');
	                this.svg = options.svg;
	                this.svg.classed(WaterfallChart.WaterfallClassName, true);
	                this.style = options.style;
	                this.currentViewport = options.viewport;
	                this.hostServices = options.host;
	                this.interactivity = options.interactivity;
	                this.cartesianVisualHost = options.cartesianHost;
	                this.options = options;
	                this.element = options.element;
	                this.colors = this.style.colorPalette.dataColors;
	                this.mainGraphicsSVG = this.svg.append('svg');
	                this.mainGraphicsContext = this.mainGraphicsSVG.append('g')
	                    .classed(WaterfallChart.MainGraphicsContextClassName, true);
	                this.labelGraphicsContext = this.mainGraphicsSVG.append('g')
	                    .classed(visuals.NewDataLabelUtils.labelGraphicsContextClass.class, true);
	            };
	            WaterfallChart.converter = function (dataView, palette, hostServices, dataLabelSettings, sentimentColors, interactivityService, tooltipsEnabled, tooltipBucketEnabled) {
	                if (tooltipsEnabled === void 0) { tooltipsEnabled = true; }
	                debug.assertValue(palette, 'palette');
	                var reader = powerbi.data.createIDataViewCategoricalReader(dataView);
	                var formatStringProp = WaterfallChart.formatStringProp;
	                var categories = dataView.categorical.categories || [];
	                var increaseColor = sentimentColors.increaseFill.solid.color;
	                var decreaseColor = sentimentColors.decreaseFill.solid.color;
	                var totalColor = sentimentColors.totalFill.solid.color;
	                var totalLabel = hostServices.getLocalizedString(WaterfallChart.TotalLabel);
	                var increaseLabel = hostServices.getLocalizedString(WaterfallChart.IncreaseLabel);
	                var decreaseLabel = hostServices.getLocalizedString(WaterfallChart.DecreaseLabel);
	                var legend = [
	                    {
	                        label: increaseLabel,
	                        color: increaseColor,
	                        icon: visuals.LegendIcon.Box,
	                        identity: visuals.SelectionIdBuilder.builder().withMeasure('increase').createSelectionId(),
	                        selected: false,
	                    }, {
	                        label: decreaseLabel,
	                        color: decreaseColor,
	                        icon: visuals.LegendIcon.Box,
	                        identity: visuals.SelectionIdBuilder.builder().withMeasure('decrease').createSelectionId(),
	                        selected: false,
	                    }, {
	                        label: totalLabel,
	                        color: totalColor,
	                        icon: visuals.LegendIcon.Box,
	                        identity: visuals.SelectionIdBuilder.builder().withMeasure('total').createSelectionId(),
	                        selected: false,
	                    }];
	                /**
	                 * The position represents the starting point for each bar,
	                 * for any value it is the sum of all previous values.
	                 * Values > 0 are considered gains, values < 0 are losses.
	                 */
	                var pos = 0, posMin = 0, posMax = 0;
	                var dataPoints = [];
	                var categoryValues = [];
	                var categoryMetadata;
	                var valuesMetadata = undefined;
	                var totalTooltips;
	                var tooltipsCount;
	                var tooltipMetadataColumns;
	                if (reader.hasValues("Tooltips")) {
	                    tooltipMetadataColumns = reader.getAllValueMetadataColumnsForRole("Tooltips", undefined);
	                }
	                if (reader.hasValues("Y")) {
	                    valuesMetadata = reader.getValueMetadataColumn("Y");
	                    var labelFormatString = valuesMetadata.format;
	                    if (_.isEmpty(categories)) {
	                        // We have values but no category, just show the total bar.
	                        pos = posMax = reader.getValue("Y", 0);
	                        posMin = 0;
	                    }
	                    else {
	                        var categoryColumn = categories[0];
	                        categoryMetadata = categoryColumn.source;
	                        categoryValues = categoryColumn.values.slice();
	                        categoryValues.push(totalLabel);
	                        if (reader.hasValues("Tooltips")) {
	                            tooltipsCount = reader.getSeriesCount("Tooltips");
	                            totalTooltips = _.map(new Array(tooltipsCount), function () { return 0; });
	                        }
	                        for (var categoryIndex = 0, catLen = reader.getCategoryCount(); categoryIndex < catLen; categoryIndex++) {
	                            var category = categoryValues[categoryIndex];
	                            var value = reader.getValue("Y", categoryIndex) || 0;
	                            var identity = visuals.SelectionIdBuilder.builder()
	                                .withCategory(categoryColumn, categoryIndex)
	                                .withMeasure(valuesMetadata.queryName)
	                                .createSelectionId();
	                            var tooltipInfo_1 = void 0;
	                            if (tooltipsEnabled) {
	                                tooltipInfo_1 = [];
	                                tooltipInfo_1.push({
	                                    displayName: categoryMetadata.displayName,
	                                    value: visuals.converterHelper.formatFromMetadataColumn(category, categoryMetadata, formatStringProp),
	                                });
	                                if (value != null) {
	                                    tooltipInfo_1.push({
	                                        displayName: valuesMetadata.displayName,
	                                        value: visuals.converterHelper.formatFromMetadataColumn(value, valuesMetadata, formatStringProp),
	                                    });
	                                }
	                                if (tooltipBucketEnabled) {
	                                    var tooltipValues = reader.getAllValuesForRole("Tooltips", categoryIndex);
	                                    if (tooltipValues && tooltipMetadataColumns) {
	                                        for (var i = 0; i < tooltipValues.length; i++) {
	                                            totalTooltips[i] += tooltipValues[i];
	                                        }
	                                        for (var j = 0; j < tooltipValues.length; j++) {
	                                            if (tooltipValues[j] != null && tooltipMetadataColumns[j]) {
	                                                tooltipInfo_1.push({
	                                                    displayName: tooltipMetadataColumns[j].displayName,
	                                                    value: visuals.converterHelper.formatFromMetadataColumn(tooltipValues[j], tooltipMetadataColumns[j], formatStringProp),
	                                                });
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                            var color = value > 0 ? increaseColor : decreaseColor;
	                            dataPoints.push({
	                                value: value,
	                                position: pos,
	                                color: color,
	                                categoryValue: category,
	                                categoryIndex: categoryIndex,
	                                seriesIndex: 0,
	                                selected: false,
	                                identity: identity,
	                                highlight: false,
	                                key: identity.getKey(),
	                                tooltipInfo: tooltipInfo_1,
	                                labelFill: dataLabelSettings.labelColor,
	                                labelFormatString: labelFormatString,
	                            });
	                            pos += value;
	                            if (pos > posMax)
	                                posMax = pos;
	                            if (pos < posMin)
	                                posMin = pos;
	                        }
	                    }
	                    var tooltipInfo = void 0;
	                    if (tooltipsEnabled) {
	                        tooltipInfo = [];
	                        if (categoryMetadata) {
	                            tooltipInfo.push({
	                                displayName: categoryMetadata.displayName,
	                                value: totalLabel,
	                            });
	                        }
	                        if (pos != null) {
	                            tooltipInfo.push({
	                                displayName: valuesMetadata.displayName,
	                                value: visuals.converterHelper.formatFromMetadataColumn(pos, valuesMetadata, formatStringProp),
	                            });
	                        }
	                        if (tooltipBucketEnabled) {
	                            var tooltipValues = reader.getAllValuesForRole("Tooltips", 0, undefined);
	                            totalTooltips = totalTooltips ? totalTooltips : tooltipValues;
	                            if (tooltipValues && tooltipMetadataColumns) {
	                                for (var j = 0; j < totalTooltips.length; j++) {
	                                    if (totalTooltips[j] != null) {
	                                        tooltipInfo.push({
	                                            displayName: tooltipMetadataColumns[j].displayName,
	                                            value: visuals.converterHelper.formatFromMetadataColumn(totalTooltips[j], tooltipMetadataColumns[j], formatStringProp),
	                                        });
	                                    }
	                                }
	                            }
	                        }
	                    }
	                    var totalIdentity = visuals.SelectionId.createNull();
	                    dataPoints.push({
	                        value: pos,
	                        position: 0,
	                        color: totalColor,
	                        categoryValue: totalLabel,
	                        categoryIndex: categoryIndex,
	                        identity: totalIdentity,
	                        seriesIndex: 0,
	                        selected: false,
	                        highlight: false,
	                        key: totalIdentity.getKey(),
	                        tooltipInfo: tooltipInfo,
	                        labelFill: dataLabelSettings.labelColor,
	                        labelFormatString: labelFormatString,
	                        isTotal: true,
	                    });
	                }
	                if (interactivityService) {
	                    interactivityService.applySelectionStateToData(dataPoints);
	                }
	                var xAxisProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataView.metadata);
	                var yAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataView.metadata);
	                var axesLabels = visuals.converterHelper.createAxesLabels(xAxisProperties, yAxisProperties, categoryMetadata, [valuesMetadata]);
	                return {
	                    series: [{ data: dataPoints }],
	                    categories: categoryValues,
	                    categoryMetadata: categoryMetadata,
	                    valuesMetadata: valuesMetadata,
	                    legend: { dataPoints: legend },
	                    hasHighlights: false,
	                    positionMin: posMin,
	                    positionMax: posMax,
	                    dataLabelsSettings: dataLabelSettings,
	                    sentimentColors: sentimentColors,
	                    axesLabels: { x: axesLabels.xAxisLabel, y: axesLabels.yAxisLabel },
	                };
	            };
	            WaterfallChart.prototype.setData = function (dataViews) {
	                debug.assertValue(dataViews, "dataViews");
	                var sentimentColors = this.getSentimentColorsFromObjects(null);
	                var dataView = dataViews.length > 0 ? dataViews[0] : undefined;
	                this.data = {
	                    series: [{ data: [] }],
	                    categories: [],
	                    valuesMetadata: null,
	                    legend: { dataPoints: [], },
	                    hasHighlights: false,
	                    categoryMetadata: null,
	                    scalarCategoryAxis: false,
	                    positionMax: 0,
	                    positionMin: 0,
	                    dataLabelsSettings: visuals.dataLabelUtils.getDefaultLabelSettings(/* show */ false, /* labelColor */ undefined),
	                    sentimentColors: sentimentColors,
	                    axesLabels: { x: null, y: null },
	                };
	                if (dataView) {
	                    if (dataView.metadata && dataView.metadata.objects) {
	                        var objects = dataView.metadata.objects;
	                        var labelsObj = objects['labels'];
	                        if (labelsObj) {
	                            visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, this.data.dataLabelsSettings);
	                        }
	                        sentimentColors = this.getSentimentColorsFromObjects(objects);
	                    }
	                    if (dataView.categorical) {
	                        this.data = WaterfallChart.converter(dataView, this.colors, this.hostServices, this.data.dataLabelsSettings, sentimentColors, this.interactivityService, this.tooltipsEnabled, this.tooltipBucketEnabled);
	                    }
	                }
	            };
	            WaterfallChart.prototype.enumerateObjectInstances = function (enumeration, options) {
	                switch (options.objectName) {
	                    case 'sentimentColors':
	                        this.enumerateSentimentColors(enumeration);
	                        break;
	                    case 'labels':
	                        var labelSettingOptions = {
	                            enumeration: enumeration,
	                            dataLabelsSettings: this.data.dataLabelsSettings,
	                            show: true,
	                            displayUnits: true,
	                            precision: true,
	                            fontSize: true,
	                        };
	                        visuals.dataLabelUtils.enumerateDataLabels(labelSettingOptions);
	                        break;
	                }
	            };
	            WaterfallChart.prototype.enumerateSentimentColors = function (enumeration) {
	                var sentimentColors = this.data.sentimentColors;
	                enumeration.pushInstance({
	                    selector: null,
	                    properties: {
	                        increaseFill: sentimentColors.increaseFill,
	                        decreaseFill: sentimentColors.decreaseFill,
	                        totalFill: sentimentColors.totalFill
	                    },
	                    objectName: 'sentimentColors'
	                });
	            };
	            WaterfallChart.prototype.calculateLegend = function () {
	                // TODO: support interactive legend
	                return this.data.legend;
	            };
	            WaterfallChart.prototype.hasLegend = function () {
	                // Waterfall legend is more like a color-key, so just return true
	                return true;
	            };
	            WaterfallChart.createClippedDataIfOverflowed = function (data, renderableDataCount) {
	                var clipped = data;
	                var dataPoints = data.series[0].data;
	                if (data && renderableDataCount < dataPoints.length) {
	                    clipped = powerbi.Prototype.inherit(data);
	                    clipped.series = [{ data: dataPoints.slice(0, renderableDataCount) }];
	                    clipped.categories = data.categories.slice(0, renderableDataCount);
	                }
	                return clipped;
	            };
	            WaterfallChart.prototype.calculateAxesProperties = function (options) {
	                var _this = this;
	                debug.assertValue(options, 'options');
	                this.currentViewport = options.viewport;
	                this.margin = options.margin;
	                var data = this.clippedData = this.data;
	                var categoryCount = data.categories.length;
	                var preferredPlotArea = this.getPreferredPlotArea(false, categoryCount, visuals.CartesianChart.MinOrdinalRectThickness);
	                var cartesianLayout = visuals.CartesianChart.getLayout(null, {
	                    availableWidth: preferredPlotArea.width,
	                    categoryCount: categoryCount,
	                    domain: null,
	                    isScalar: false,
	                    isScrollable: this.isScrollable,
	                    trimOrdinalDataOnOverflow: options.trimOrdinalDataOnOverflow
	                });
	                // In the case that we have overflowed horizontally we want to clip the data and use that to calculate the axes on the dashboard.           
	                if (!this.isScrollable) {
	                    data = this.clippedData = WaterfallChart.createClippedDataIfOverflowed(data, cartesianLayout.categoryCount);
	                }
	                var xAxisCreationOptions = WaterfallChart.getXAxisCreationOptions(data, preferredPlotArea.width, cartesianLayout, options);
	                var yAxisCreationOptions = WaterfallChart.getYAxisCreationOptions(data, preferredPlotArea.height, options);
	                var xAxisProperties = this.xAxisProperties = visuals.AxisHelper.createAxis(xAxisCreationOptions);
	                var yAxisProperties = this.yAxisProperties = visuals.AxisHelper.createAxis(yAxisCreationOptions);
	                var categoryWidth = this.xAxisProperties.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
	                var formattersCache = visuals.dataLabelUtils.createColumnFormatterCacheManager();
	                var labelSettings = data.dataLabelsSettings;
	                var value2 = WaterfallChart.getDisplayUnitValueFromAxisFormatter(yAxisProperties, labelSettings);
	                this.layout = {
	                    categoryCount: cartesianLayout.categoryCount,
	                    categoryThickness: cartesianLayout.categoryThickness,
	                    isScalar: cartesianLayout.isScalar,
	                    outerPaddingRatio: cartesianLayout.outerPaddingRatio,
	                    categoryWidth: categoryWidth,
	                    labelText: function (d) {
	                        //total value has no identity
	                        var formatter = formattersCache.getOrCreate(d.labelFormatString, labelSettings, value2);
	                        return visuals.dataLabelUtils.getLabelFormattedText({ label: formatter.format(d.value) });
	                    },
	                    labelLayout: visuals.dataLabelUtils.getLabelLayoutXYForWaterfall(xAxisProperties, categoryWidth, yAxisProperties, yAxisCreationOptions.dataDomain),
	                    filter: function (d) {
	                        return visuals.dataLabelUtils.doesDataLabelFitInShape(d, yAxisProperties, _this.layout);
	                    },
	                    style: {
	                        'fill': function (d) {
	                            if (d.isLabelInside)
	                                return visuals.dataLabelUtils.defaultInsideLabelColor;
	                            return d.labelFill;
	                        },
	                    },
	                };
	                this.xAxisProperties.axisLabel = options.showCategoryAxisLabel ? data.axesLabels.x : null;
	                this.yAxisProperties.axisLabel = options.showValueAxisLabel ? data.axesLabels.y : null;
	                return [xAxisProperties, yAxisProperties];
	            };
	            WaterfallChart.getDisplayUnitValueFromAxisFormatter = function (yAxisProperties, labelSettings) {
	                return (yAxisProperties.formatter && yAxisProperties.formatter.displayUnit && labelSettings.displayUnits === 0) ? yAxisProperties.formatter.displayUnit.value : null;
	            };
	            WaterfallChart.lookupXValue = function (data, index, type) {
	                var dataPoints = data.series[0].data;
	                if (index === dataPoints.length - 1)
	                    // Total
	                    return dataPoints[index].categoryValue;
	                else
	                    return visuals.CartesianHelper.lookupXValue(data, index, type, false);
	            };
	            WaterfallChart.getXAxisCreationOptions = function (data, width, layout, options) {
	                debug.assertValue(data, 'data');
	                debug.assertValue(options, 'options');
	                var categoryDataType = visuals.AxisHelper.getCategoryValueType(data.categoryMetadata);
	                var domain = visuals.AxisHelper.createDomain(data.series, categoryDataType, /* isScalar */ false, options.forcedXDomain, options.ensureXDomain);
	                var categoryThickness = layout.categoryThickness;
	                var outerPadding = categoryThickness * layout.outerPaddingRatio;
	                return {
	                    pixelSpan: width,
	                    dataDomain: domain,
	                    metaDataColumn: data.categoryMetadata,
	                    formatString: visuals.valueFormatter.getFormatString(data.categoryMetadata, WaterfallChart.formatStringProp),
	                    isScalar: false,
	                    outerPadding: outerPadding,
	                    categoryThickness: categoryThickness,
	                    getValueFn: function (index, type) { return WaterfallChart.lookupXValue(data, index, type); },
	                    forcedTickCount: options.forcedTickCount,
	                    isCategoryAxis: true,
	                    axisDisplayUnits: options.categoryAxisDisplayUnits,
	                    axisPrecision: options.categoryAxisPrecision
	                };
	            };
	            WaterfallChart.getYAxisCreationOptions = function (data, height, options) {
	                debug.assertValue(data, 'data');
	                debug.assertValue(options, 'options');
	                var combinedDomain = visuals.AxisHelper.combineDomain(options.forcedYDomain, [data.positionMin, data.positionMax], options.ensureYDomain);
	                return {
	                    pixelSpan: height,
	                    dataDomain: combinedDomain,
	                    isScalar: true,
	                    isVertical: true,
	                    metaDataColumn: data.valuesMetadata,
	                    formatString: visuals.valueFormatter.getFormatString(data.valuesMetadata, WaterfallChart.formatStringProp),
	                    outerPadding: 0,
	                    forcedTickCount: options.forcedTickCount,
	                    useTickIntervalForDisplayUnits: true,
	                    isCategoryAxis: false,
	                    axisDisplayUnits: options.valueAxisDisplayUnits,
	                    axisPrecision: options.valueAxisPrecision
	                };
	            };
	            WaterfallChart.prototype.getPreferredPlotArea = function (isScalar, categoryCount, categoryThickness) {
	                return visuals.CartesianChart.getPreferredPlotArea(categoryCount, categoryThickness, this.currentViewport, this.isScrollable, isScalar, this.margin);
	            };
	            WaterfallChart.prototype.getVisualCategoryAxisIsScalar = function () {
	                return false;
	            };
	            WaterfallChart.prototype.overrideXScale = function (xProperties) {
	                this.xAxisProperties = xProperties;
	            };
	            WaterfallChart.prototype.setFilteredData = function (startIndex, endIndex) {
	                var data = this.clippedData = powerbi.Prototype.inherit(this.data);
	                data.series = [{ data: data.series[0].data.slice(startIndex, endIndex) }];
	                data.categories = data.categories.slice(startIndex, endIndex);
	                return data;
	            };
	            WaterfallChart.prototype.createRects = function (data) {
	                var mainGraphicsContext = this.mainGraphicsContext;
	                var colsSelection = mainGraphicsContext.selectAll(WaterfallChart.CategoryValueClasses.selector);
	                var cols = colsSelection.data(data, function (d) { return d.key; });
	                cols
	                    .enter()
	                    .append('rect')
	                    .attr('class', function (d) { return WaterfallChart.CategoryValueClasses.class.concat(d.highlight ? 'highlight' : ''); });
	                cols.exit().remove();
	                return cols;
	            };
	            WaterfallChart.prototype.createConnectors = function (data) {
	                var mainGraphicsContext = this.mainGraphicsContext;
	                var connectorSelection = mainGraphicsContext.selectAll(WaterfallChart.WaterfallConnectorClasses.selector);
	                var connectors = connectorSelection.data(data.slice(0, data.length - 1), function (d) { return d.key; });
	                connectors
	                    .enter()
	                    .append('line')
	                    .classed(WaterfallChart.WaterfallConnectorClasses.class, true);
	                connectors.exit().remove();
	                return connectors;
	            };
	            WaterfallChart.prototype.render = function (suppressAnimations) {
	                var _this = this;
	                var dataPoints = this.clippedData.series[0].data;
	                var bars = this.createRects(dataPoints);
	                var connectors = this.createConnectors(dataPoints);
	                if (this.tooltipsEnabled)
	                    visuals.TooltipManager.addTooltip(bars, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
	                var hasSelection = this.interactivityService && this.interactivityService.hasSelection();
	                var xScale = this.xAxisProperties.scale;
	                var yScale = this.yAxisProperties.scale;
	                var y0 = yScale(0);
	                this.mainGraphicsSVG.attr('height', this.getAvailableHeight())
	                    .attr('width', this.getAvailableWidth());
	                /**
	                 * The y-value is always at the top of the rect. If the data value is negative then we can
	                 * use the scaled position directly since we are drawing down. If the data value is positive
	                 * we have to calculate the top of the rect and use that as the y-value. Since the y-value
	                 * is always the top of the rect, height should always be positive.
	                 */
	                bars
	                    .style('fill', function (d) { return d.color; })
	                    .style('fill-opacity', function (d) { return d.isTotal ? visuals.ColumnUtil.DefaultOpacity : visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, _this.data.hasHighlights); })
	                    .attr('width', this.layout.categoryWidth)
	                    .attr('x', function (d) { return xScale(d.categoryIndex); })
	                    .attr('y', function (d) { return WaterfallChart.getRectTop(yScale, d.position, d.value); })
	                    .attr('height', function (d) { return y0 - yScale(Math.abs(d.value)); });
	                connectors
	                    .attr({
	                    'x1': function (d) { return xScale(d.categoryIndex); },
	                    'y1': function (d) { return yScale(d.position + d.value); },
	                    'x2': function (d) { return xScale(d.categoryIndex + 1) + _this.layout.categoryWidth; },
	                    'y2': function (d) { return yScale(d.position + d.value); },
	                });
	                var labelSettings = this.data.dataLabelsSettings;
	                var labelDataPoints = [];
	                if (labelSettings && labelSettings.show || labelSettings.showCategory) {
	                    labelDataPoints = this.createLabelDataPoints();
	                }
	                var behaviorOptions = undefined;
	                if (this.interactivityService) {
	                    behaviorOptions = {
	                        bars: bars
	                    };
	                }
	                // This should always be the last line in the render code.
	                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
	                return { dataPoints: dataPoints, behaviorOptions: behaviorOptions, labelDataPoints: labelDataPoints, labelsAreNumeric: true };
	            };
	            WaterfallChart.prototype.onClearSelection = function () {
	                if (this.interactivityService)
	                    this.interactivityService.clearSelection();
	            };
	            WaterfallChart.prototype.getSupportedCategoryAxisType = function () {
	                return visuals.axisType.categorical;
	            };
	            WaterfallChart.getRectTop = function (scale, pos, value) {
	                if (value < 0)
	                    return scale(pos);
	                else
	                    return scale(pos) - (scale(0) - scale(value));
	            };
	            WaterfallChart.prototype.getAvailableWidth = function () {
	                return this.currentViewport.width - (this.margin.left + this.margin.right);
	            };
	            WaterfallChart.prototype.getAvailableHeight = function () {
	                return this.currentViewport.height - (this.margin.top + this.margin.bottom);
	            };
	            WaterfallChart.prototype.getSentimentColorsFromObjects = function (objects) {
	                var defaultSentimentColors = this.colors.getSentimentColors();
	                var increaseColor = powerbi.DataViewObjects.getFillColor(objects, visuals.waterfallChartProps.sentimentColors.increaseFill, defaultSentimentColors[2].value);
	                var decreaseColor = powerbi.DataViewObjects.getFillColor(objects, visuals.waterfallChartProps.sentimentColors.decreaseFill, defaultSentimentColors[0].value);
	                var totalColor = powerbi.DataViewObjects.getFillColor(objects, visuals.waterfallChartProps.sentimentColors.totalFill, WaterfallChart.defaultTotalColor);
	                return {
	                    increaseFill: { solid: { color: increaseColor } },
	                    decreaseFill: { solid: { color: decreaseColor } },
	                    totalFill: { solid: { color: totalColor } }
	                };
	            };
	            // Public for testing
	            WaterfallChart.prototype.createLabelDataPoints = function () {
	                var labelDataPoints = [];
	                var data = this.data;
	                var xScale = this.xAxisProperties.scale;
	                var yScale = this.yAxisProperties.scale;
	                var y0 = yScale(0);
	                var series = data.series;
	                var formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager();
	                var axisFormatter = visuals.NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yAxisProperties.formatter, data.dataLabelsSettings);
	                var labelSettings = this.data.dataLabelsSettings;
	                for (var _i = 0, series_1 = series; _i < series_1.length; _i++) {
	                    var currentSeries = series_1[_i];
	                    for (var _a = 0, _b = currentSeries.data; _a < _b.length; _a++) {
	                        var dataPoint = _b[_a];
	                        // Calculate parent rectangle
	                        var parentRect = {
	                            left: xScale(dataPoint.categoryIndex),
	                            top: WaterfallChart.getRectTop(yScale, dataPoint.position, dataPoint.value),
	                            width: this.layout.categoryWidth,
	                            height: y0 - yScale(Math.abs(dataPoint.value)),
	                        };
	                        // Calculate label text
	                        var formatString = dataPoint.labelFormatString;
	                        var formatter = formattersCache.getOrCreate(formatString, this.data.dataLabelsSettings, axisFormatter);
	                        var text = visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(dataPoint.value));
	                        // Calculate text size
	                        var properties = {
	                            text: text,
	                            fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
	                            fontSize: PixelConverter.fromPoint(labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt),
	                            fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight,
	                        };
	                        var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
	                        var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, true /* tightFitForNumeric */);
	                        labelDataPoints.push({
	                            isPreferred: true,
	                            text: text,
	                            textSize: {
	                                width: textWidth,
	                                height: textHeight,
	                            },
	                            outsideFill: labelSettings.labelColor ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultLabelColor,
	                            insideFill: visuals.NewDataLabelUtils.defaultInsideLabelColor,
	                            parentType: 1 /* Rectangle */,
	                            parentShape: {
	                                rect: parentRect,
	                                orientation: dataPoint.value >= 0 ? 1 /* VerticalBottomBased */ : 2 /* VerticalTopBased */,
	                                validPositions: dataPoint.value === 0 ? WaterfallChart.validZeroLabelPosition : WaterfallChart.validLabelPositions,
	                            },
	                            fontSize: labelSettings.fontSize,
	                            identity: undefined,
	                        });
	                    }
	                }
	                return labelDataPoints;
	            };
	            WaterfallChart.formatStringProp = { objectName: 'general', propertyName: 'formatString' };
	            WaterfallChart.WaterfallClassName = 'waterfallChart';
	            WaterfallChart.MainGraphicsContextClassName = 'mainGraphicsContext';
	            WaterfallChart.IncreaseLabel = "Waterfall_IncreaseLabel";
	            WaterfallChart.DecreaseLabel = "Waterfall_DecreaseLabel";
	            WaterfallChart.TotalLabel = "Waterfall_TotalLabel";
	            WaterfallChart.CategoryValueClasses = createClassAndSelector('column');
	            WaterfallChart.WaterfallConnectorClasses = createClassAndSelector('waterfall-connector');
	            WaterfallChart.defaultTotalColor = "#00b8aa";
	            WaterfallChart.validLabelPositions = [16 /* OutsideEnd */, 4 /* InsideEnd */];
	            WaterfallChart.validZeroLabelPosition = [16 /* OutsideEnd */, 8 /* OutsideBase */];
	            return WaterfallChart;
	        }());
	        visuals.WaterfallChart = WaterfallChart;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 282 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="./_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var TouchUtils = powerbi.visuals.controls.TouchUtils;
	        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
	        ;
	        var ContainerClassName = createClassAndSelector("tooltip-container");
	        var ContentContainerClassName = createClassAndSelector("tooltip-content-container");
	        var ArrowClassName = createClassAndSelector("arrow");
	        var TooltipHeaderClassName = createClassAndSelector("tooltip-header");
	        var TooltipRowClassName = createClassAndSelector("tooltip-row");
	        var TooltipColorCellClassName = createClassAndSelector("tooltip-color-cell");
	        var TooltipTitleCellClassName = createClassAndSelector("tooltip-title-cell");
	        var TooltipValueCellClassName = createClassAndSelector("tooltip-value-cell");
	        var ToolTipComponent = (function () {
	            function ToolTipComponent(tooltipOptions) {
	                this.tooltipOptions = tooltipOptions;
	                this.isTooltipVisible = false;
	                if (!tooltipOptions) {
	                    this.tooltipOptions = ToolTipComponent.DefaultTooltipOptions;
	                }
	            }
	            ToolTipComponent.prototype.isTooltipComponentVisible = function () {
	                return this.isTooltipVisible;
	            };
	            /** Note: For tests only */
	            ToolTipComponent.prototype.setTestScreenSize = function (width, height) {
	                this.customScreenWidth = width;
	                this.customScreenHeight = height;
	            };
	            ToolTipComponent.prototype.show = function (tooltipData, clickedArea) {
	                this.isTooltipVisible = true;
	                if (!this.tooltipContainer) {
	                    this.tooltipContainer = this.createTooltipContainer();
	                }
	                this.setTooltipContent(tooltipData);
	                this.tooltipContainer
	                    .style("visibility", "visible")
	                    .transition()
	                    .duration(0) // Cancel previous transitions
	                    .style("opacity", this.tooltipOptions.opacity);
	                this.setPosition(clickedArea);
	            };
	            ToolTipComponent.prototype.move = function (tooltipData, clickedArea) {
	                if (this.isTooltipVisible) {
	                    if (tooltipData) {
	                        this.setTooltipContent(tooltipData);
	                    }
	                    this.setPosition(clickedArea);
	                }
	            };
	            ToolTipComponent.prototype.hide = function () {
	                if (this.isTooltipVisible) {
	                    this.isTooltipVisible = false;
	                    this.tooltipContainer
	                        .transition()
	                        .duration(this.tooltipOptions.animationDuration)
	                        .style("opacity", 0)
	                        .each('end', function () { this.style.visibility = "hidden"; });
	                }
	            };
	            ToolTipComponent.prototype.createTooltipContainer = function () {
	                var container = d3.select(ToolTipComponent.parentContainerSelector)
	                    .append("div")
	                    .attr("class", ContainerClassName.class);
	                container.append("div").attr("class", ArrowClassName.class);
	                container.append("div").attr("class", ContentContainerClassName.class);
	                return container;
	            };
	            ToolTipComponent.prototype.setTooltipContent = function (tooltipData) {
	                if (_.isEqual(tooltipData, this.currentTooltipData))
	                    return;
	                this.currentTooltipData = tooltipData;
	                var rowsSelector = TooltipRowClassName.selector;
	                var contentContainer = this.tooltipContainer.select(ContentContainerClassName.selector);
	                // Clear existing content
	                contentContainer.selectAll(TooltipHeaderClassName.selector).remove();
	                contentContainer.selectAll(TooltipRowClassName.selector).remove();
	                if (tooltipData.length === 0)
	                    return;
	                if (tooltipData[0].header) {
	                    contentContainer.append("div").attr("class", TooltipHeaderClassName.class).text(tooltipData[0].header);
	                }
	                var tooltipRow = contentContainer.selectAll(rowsSelector).data(tooltipData);
	                var newRow = tooltipRow.enter().append("div").attr("class", TooltipRowClassName.class);
	                if (_.any(tooltipData, function (tooltipItem) { return tooltipItem.color; })) {
	                    var newColorCell = newRow.filter(function (d) { return d.color; }).append("div").attr("class", TooltipColorCellClassName.class);
	                    newColorCell
	                        .append('svg')
	                        .attr({
	                        'width': '100%',
	                        'height': '15px'
	                    })
	                        .append('circle')
	                        .attr({
	                        'cx': '5',
	                        'cy': '8',
	                        'r': '5'
	                    })
	                        .style({
	                        'fill': function (d) { return d.color; },
	                        'fill-opacity': function (d) { return d.opacity != null ? d.opacity : 1; },
	                    });
	                }
	                var newTitleCell = newRow.append("div").attr("class", TooltipTitleCellClassName.class);
	                var newValueCell = newRow.append("div").attr("class", TooltipValueCellClassName.class);
	                newTitleCell.text(function (d) { return d.displayName; });
	                newValueCell.text(function (d) { return d.value; });
	            };
	            ToolTipComponent.prototype.getTooltipPosition = function (clickedArea, clickedScreenArea) {
	                var tooltipContainerBounds = this.tooltipContainer.node().getBoundingClientRect();
	                var centerPointOffset = Math.floor(clickedArea.width / 2);
	                var offsetX = 0;
	                var offsetY = 0;
	                var centerPoint = new TouchUtils.Point(clickedArea.x + centerPointOffset, clickedArea.y + centerPointOffset);
	                var arrowOffset = 7;
	                if (clickedScreenArea === 0 /* TopLeft */) {
	                    offsetX += 3 * arrowOffset + centerPointOffset;
	                    offsetY -= 2 * arrowOffset + centerPointOffset;
	                }
	                else if (clickedScreenArea === 1 /* TopRight */) {
	                    offsetX -= (2 * arrowOffset + tooltipContainerBounds.width + centerPointOffset);
	                    offsetY -= 2 * arrowOffset + centerPointOffset;
	                }
	                else if (clickedScreenArea === 3 /* BottomLeft */) {
	                    offsetX += 3 * arrowOffset + centerPointOffset;
	                    offsetY -= (tooltipContainerBounds.height - 2 * arrowOffset + centerPointOffset);
	                }
	                else if (clickedScreenArea === 2 /* BottomRight */) {
	                    offsetX -= (2 * arrowOffset + tooltipContainerBounds.width + centerPointOffset);
	                    offsetY -= (tooltipContainerBounds.height - 2 * arrowOffset + centerPointOffset);
	                }
	                centerPoint.offset(offsetX, offsetY);
	                return centerPoint;
	            };
	            ToolTipComponent.prototype.setPosition = function (clickedArea) {
	                var clickedScreenArea = this.getClickedScreenArea(clickedArea);
	                var tooltipPosition = this.getTooltipPosition(clickedArea, clickedScreenArea);
	                this.setTooltipContainerClass(clickedScreenArea);
	                this.tooltipContainer.style({ "left": tooltipPosition.x + "px", "top": tooltipPosition.y + "px" });
	                this.setArrowPosition(clickedScreenArea);
	            };
	            ToolTipComponent.prototype.setTooltipContainerClass = function (clickedScreenArea) {
	                var tooltipContainerClassName;
	                switch (clickedScreenArea) {
	                    case 0 /* TopLeft */:
	                    case 3 /* BottomLeft */:
	                        tooltipContainerClassName = 'left';
	                        break;
	                    case 1 /* TopRight */:
	                    case 2 /* BottomRight */:
	                        tooltipContainerClassName = 'right';
	                        break;
	                }
	                this.tooltipContainer
	                    .attr('class', ContainerClassName.class) // Reset all classes
	                    .classed(tooltipContainerClassName, true);
	            };
	            ToolTipComponent.prototype.setArrowPosition = function (clickedScreenArea) {
	                var arrow = this.getArrowElement();
	                var arrowClassName;
	                if (clickedScreenArea === 0 /* TopLeft */) {
	                    arrowClassName = "top left";
	                }
	                else if (clickedScreenArea === 1 /* TopRight */) {
	                    arrowClassName = "top right";
	                }
	                else if (clickedScreenArea === 3 /* BottomLeft */) {
	                    arrowClassName = "bottom left";
	                }
	                else {
	                    arrowClassName = "bottom right";
	                }
	                arrow
	                    .attr('class', 'arrow') // Reset all classes
	                    .classed(arrowClassName, true);
	            };
	            ToolTipComponent.prototype.getArrowElement = function () {
	                return this.tooltipContainer.select(ArrowClassName.selector);
	            };
	            ToolTipComponent.prototype.getClickedScreenArea = function (clickedArea) {
	                var screenWidth = this.customScreenWidth || window.innerWidth;
	                var screenHeight = this.customScreenHeight || window.innerHeight;
	                var centerPointOffset = clickedArea.width / 2;
	                var centerPoint = new TouchUtils.Point(clickedArea.x + centerPointOffset, clickedArea.y + centerPointOffset);
	                var halfWidth = screenWidth / 2;
	                var halfHeight = screenHeight / 2;
	                if (centerPoint.x < halfWidth && centerPoint.y < halfHeight) {
	                    return 0 /* TopLeft */;
	                }
	                else if (centerPoint.x >= halfWidth && centerPoint.y < halfHeight) {
	                    return 1 /* TopRight */;
	                }
	                else if (centerPoint.x < halfWidth && centerPoint.y >= halfHeight) {
	                    return 3 /* BottomLeft */;
	                }
	                else if (centerPoint.x >= halfWidth && centerPoint.y >= halfHeight) {
	                    return 2 /* BottomRight */;
	                }
	            };
	            ToolTipComponent.DefaultTooltipOptions = {
	                opacity: 1,
	                animationDuration: 250,
	                offsetX: 10,
	                offsetY: 10
	            };
	            ToolTipComponent.parentContainerSelector = "body";
	            ToolTipComponent.highlightedValueDisplayNameResorceKey = "Tooltip_HighlightedValueDisplayName";
	            return ToolTipComponent;
	        }());
	        visuals.ToolTipComponent = ToolTipComponent;
	        var TooltipManager;
	        (function (TooltipManager) {
	            TooltipManager.ShowTooltips = true;
	            TooltipManager.ToolTipInstance = new ToolTipComponent();
	            var GlobalTooltipEventsAttached = false;
	            var tooltipMouseOverDelay = 350;
	            var tooltipMouseOutDelay = 500;
	            var tooltipTouchDelay = 350;
	            var tooltipTimeoutId;
	            var handleTouchDelay = 1000;
	            var handleTouchTimeoutId = 0;
	            var mouseCoordinates;
	            var tooltipData;
	            function addTooltip(selection, getTooltipInfoDelegate, reloadTooltipDataOnMouseMove, onMouseOutDelegate) {
	                if (!TooltipManager.ShowTooltips) {
	                    return;
	                }
	                debug.assertValue(selection, "selection");
	                var rootNode = d3.select(ToolTipComponent.parentContainerSelector).node();
	                // Mouse events
	                selection.on("mouseover", function () {
	                    var target = d3.event.target;
	                    var data = d3.select(target).datum();
	                    // Ignore mouseover while handling touch events
	                    if (handleTouchTimeoutId || !canDisplayTooltip(d3.event))
	                        return;
	                    mouseCoordinates = getCoordinates(rootNode, true);
	                    var elementCoordinates = getCoordinates(target, true);
	                    var tooltipEvent = {
	                        data: data,
	                        coordinates: mouseCoordinates,
	                        elementCoordinates: elementCoordinates,
	                        context: target,
	                        isTouchEvent: false
	                    };
	                    clearTooltipTimeout();
	                    // if it is already visible, change contents immediately (use 16ms minimum perceivable frame rate to prevent thrashing)
	                    var delay = TooltipManager.ToolTipInstance.isTooltipComponentVisible() ? 16 : tooltipMouseOverDelay;
	                    tooltipTimeoutId = showDelayedTooltip(tooltipEvent, getTooltipInfoDelegate, delay);
	                });
	                selection.on("mouseout", function () {
	                    if (!handleTouchTimeoutId) {
	                        clearTooltipTimeout();
	                        tooltipTimeoutId = hideDelayedTooltip();
	                    }
	                    if (onMouseOutDelegate) {
	                        onMouseOutDelegate();
	                    }
	                });
	                selection.on("mousemove", function () {
	                    var target = d3.event.target;
	                    var data = d3.select(target).datum();
	                    // Ignore mousemove while handling touch events
	                    if (handleTouchTimeoutId || !canDisplayTooltip(d3.event))
	                        return;
	                    mouseCoordinates = getCoordinates(rootNode, true);
	                    var elementCoordinates = getCoordinates(target, true);
	                    var tooltipEvent = {
	                        data: data,
	                        coordinates: mouseCoordinates,
	                        elementCoordinates: elementCoordinates,
	                        context: target,
	                        isTouchEvent: false
	                    };
	                    moveTooltipEventHandler(tooltipEvent, getTooltipInfoDelegate, reloadTooltipDataOnMouseMove);
	                });
	                // --- Touch events ---
	                // TODO: static?
	                var touchStartEventName = getTouchStartEventName();
	                var touchEndEventName = getTouchEndEventName();
	                var isPointerEvent = touchStartEventName === "pointerdown" || touchStartEventName === "MSPointerDown";
	                if (!GlobalTooltipEventsAttached) {
	                    // Add root container hide tooltip event
	                    attachGlobalEvents(touchStartEventName);
	                    GlobalTooltipEventsAttached = true;
	                }
	                selection.on(touchStartEventName, function () {
	                    var target = d3.event.target;
	                    var data = d3.select(target).datum();
	                    hideTooltipEventHandler();
	                    var coordinates = getCoordinates(rootNode, isPointerEvent);
	                    var elementCoordinates = getCoordinates(target, isPointerEvent);
	                    var tooltipEvent = {
	                        data: data,
	                        coordinates: coordinates,
	                        elementCoordinates: elementCoordinates,
	                        context: target,
	                        isTouchEvent: true
	                    };
	                    clearTooltipTimeout();
	                    tooltipTimeoutId = showDelayedTooltip(tooltipEvent, getTooltipInfoDelegate, tooltipTouchDelay);
	                });
	                selection.on(touchEndEventName, function () {
	                    clearTooltipTimeout();
	                    if (handleTouchTimeoutId)
	                        clearTimeout(handleTouchTimeoutId);
	                    // At the end of touch action, set a timeout that will let us ignore the incoming mouse events for a small amount of time
	                    handleTouchTimeoutId = setTimeout(function () {
	                        handleTouchTimeoutId = 0;
	                    }, handleTouchDelay);
	                });
	            }
	            TooltipManager.addTooltip = addTooltip;
	            function showDelayedTooltip(tooltipEvent, getTooltipInfoDelegate, delayInMs) {
	                return setTimeout(function () { return showTooltipEventHandler(tooltipEvent, getTooltipInfoDelegate); }, delayInMs);
	            }
	            TooltipManager.showDelayedTooltip = showDelayedTooltip;
	            function hideDelayedTooltip() {
	                return setTimeout(function () { return hideTooltipEventHandler(); }, tooltipMouseOutDelay);
	            }
	            TooltipManager.hideDelayedTooltip = hideDelayedTooltip;
	            function setLocalizedStrings(localizationOptions) {
	                ToolTipComponent.localizationOptions = localizationOptions;
	            }
	            TooltipManager.setLocalizedStrings = setLocalizedStrings;
	            function showTooltipEventHandler(tooltipEvent, getTooltipInfoDelegate) {
	                var tooltipInfo = tooltipData || getTooltipInfoDelegate(tooltipEvent);
	                if (!_.isEmpty(tooltipInfo)) {
	                    var coordinates = mouseCoordinates || tooltipEvent.coordinates;
	                    var clickedArea = getClickedArea(coordinates[0], coordinates[1], tooltipEvent.isTouchEvent);
	                    TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
	                }
	            }
	            function moveTooltipEventHandler(tooltipEvent, getTooltipInfoDelegate, reloadTooltipDataOnMouseMove) {
	                tooltipData = undefined;
	                if (reloadTooltipDataOnMouseMove) {
	                    tooltipData = getTooltipInfoDelegate(tooltipEvent);
	                }
	                var clickedArea = getClickedArea(tooltipEvent.coordinates[0], tooltipEvent.coordinates[1], tooltipEvent.isTouchEvent);
	                TooltipManager.ToolTipInstance.move(tooltipData, clickedArea);
	            }
	            ;
	            function hideTooltipEventHandler() {
	                TooltipManager.ToolTipInstance.hide();
	            }
	            ;
	            function clearTooltipTimeout() {
	                if (tooltipTimeoutId) {
	                    clearTimeout(tooltipTimeoutId);
	                }
	            }
	            function canDisplayTooltip(d3Event) {
	                var cadDisplay = true;
	                var mouseEvent = d3Event;
	                if (mouseEvent.buttons !== undefined) {
	                    // Check mouse buttons state
	                    var hasMouseButtonPressed = mouseEvent.buttons !== 0;
	                    cadDisplay = !hasMouseButtonPressed;
	                }
	                return cadDisplay;
	            }
	            function getTouchStartEventName() {
	                var eventName = "touchstart";
	                if (window["PointerEvent"]) {
	                    // IE11
	                    eventName = "pointerdown";
	                }
	                else if (window["MSPointerEvent"]) {
	                    // IE10
	                    eventName = "MSPointerDown";
	                }
	                return eventName;
	            }
	            function getTouchEndEventName() {
	                var eventName = "touchend";
	                if (window["PointerEvent"]) {
	                    // IE11
	                    eventName = "pointerup";
	                }
	                else if (window["MSPointerEvent"]) {
	                    // IE10
	                    eventName = "MSPointerUp";
	                }
	                return eventName;
	            }
	            function getCoordinates(rootNode, isPointerEvent) {
	                var coordinates;
	                if (isPointerEvent) {
	                    // DO NOT USE - WebKit bug in getScreenCTM with nested SVG results in slight negative coordinate shift
	                    // Also, IE will incorporate transform scale but WebKit does not, forcing us to detect browser and adjust appropriately.
	                    // Just use non-scaled coordinates for all browsers, and adjust for the transform scale later (see lineChart.findIndex)
	                    //coordinates = d3.mouse(rootNode);
	                    // copied from d3_eventSource (which is not exposed)
	                    var e = d3.event, s = void 0;
	                    while (s = e.sourceEvent)
	                        e = s;
	                    var rect = rootNode.getBoundingClientRect();
	                    coordinates = [e.clientX - rect.left - rootNode.clientLeft, e.clientY - rect.top - rootNode.clientTop];
	                }
	                else {
	                    var touchCoordinates = d3.touches(rootNode);
	                    if (touchCoordinates && touchCoordinates.length > 0) {
	                        coordinates = touchCoordinates[0];
	                    }
	                }
	                return coordinates;
	            }
	            function attachGlobalEvents(touchStartEventName) {
	                d3.select(ToolTipComponent.parentContainerSelector).on(touchStartEventName, function (d, i) {
	                    TooltipManager.ToolTipInstance.hide();
	                });
	            }
	            function getClickedArea(x, y, isTouchEvent) {
	                var width = 0;
	                var pointX = x;
	                var pointY = y;
	                if (isTouchEvent) {
	                    width = 12;
	                    var offset = width / 2;
	                    pointX = Math.max(x - offset, 0);
	                    pointY = Math.max(y - offset, 0);
	                }
	                return new TouchUtils.Rectangle(pointX, pointY, width, width);
	            }
	        })(TooltipManager = visuals.TooltipManager || (visuals.TooltipManager = {}));
	        var TooltipBuilder;
	        (function (TooltipBuilder) {
	            // TODO: implement options bag as input parameter
	            function createTooltipInfo(formatStringProp, dataViewCat, categoryValue, value, categories, seriesData, seriesIndex, categoryIndex, highlightedValue, gradientValueColumn) {
	                var categorySource;
	                var seriesSource = [];
	                var valuesSource = undefined;
	                seriesIndex = seriesIndex | 0;
	                var categoriesData = dataViewCat ? dataViewCat.categories : categories;
	                if (categoriesData && categoriesData.length > 0) {
	                    if (categoriesData.length > 1) {
	                        var compositeCategoriesData = [];
	                        for (var i = 0, ilen = categoriesData.length; i < ilen; i++) {
	                            compositeCategoriesData.push(categoriesData[i].source);
	                        }
	                        categorySource = { value: categoryValue, metadata: compositeCategoriesData };
	                    }
	                    else {
	                        categorySource = { value: categoryValue, metadata: [categoriesData[0].source] };
	                    }
	                }
	                if (dataViewCat && dataViewCat.values) {
	                    if (categorySource && categorySource.metadata[0] === dataViewCat.values.source) {
	                    }
	                    else {
	                        valuesSource = dataViewCat.values.source;
	                    }
	                    if (dataViewCat.values.length > 0) {
	                        var valueColumn = dataViewCat.values[seriesIndex];
	                        var isAutoGeneratedColumn = !!(valueColumn && valueColumn.source && valueColumn.source.isAutoGeneratedColumn);
	                        if (!isAutoGeneratedColumn) {
	                            seriesSource.push({ value: value, highlightedValue: highlightedValue, metadata: valueColumn });
	                        }
	                    }
	                    //Create Gradient tooltip value
	                    var gradientToolTipData = createGradientToolTipData(gradientValueColumn, categoryIndex);
	                    if (gradientToolTipData != null)
	                        seriesSource.push(gradientToolTipData);
	                }
	                if (seriesData) {
	                    for (var i = 0, len = seriesData.length; i < len; i++) {
	                        var singleSeriesData = seriesData[i];
	                        if (categorySource && categorySource.metadata[0] === singleSeriesData.metadata.source)
	                            continue;
	                        seriesSource.push({ value: singleSeriesData.value, metadata: singleSeriesData.metadata });
	                    }
	                }
	                var tooltipInfo = createTooltipData(formatStringProp, categorySource, valuesSource, seriesSource);
	                return tooltipInfo;
	            }
	            TooltipBuilder.createTooltipInfo = createTooltipInfo;
	            function createGradientToolTipData(gradientValueColumn, categoryIndex) {
	                if (gradientValueColumn) {
	                    // Saturation color
	                    return { value: gradientValueColumn.values[categoryIndex], metadata: { source: gradientValueColumn.source, values: [] } };
	                }
	                return null;
	            }
	            TooltipBuilder.createGradientToolTipData = createGradientToolTipData;
	            function createTooltipData(formatStringProp, categoryValue, valuesSource, seriesValues) {
	                debug.assertValue(seriesValues, "seriesSource");
	                debug.assertValue(ToolTipComponent.localizationOptions, "ToolTipComponent.localizationOptions");
	                debug.assertAnyValue(formatStringProp, 'formatStringProp');
	                var items = [];
	                if (categoryValue) {
	                    if (categoryValue.metadata.length > 1) {
	                        var displayName = '';
	                        // This is being done simply for lat/long for now, as that's the only composite category we use.  If we ever have tooltips
	                        //   involving other composite categories, we need to do a more thorough design and be more careful here.
	                        for (var i = 0, ilen = categoryValue.metadata.length; i < ilen; i++) {
	                            if (i !== 0)
	                                displayName += '/';
	                            displayName += categoryValue.metadata[i].displayName;
	                        }
	                        var categoryFormattedValue = getFormattedValue(categoryValue.metadata[0], formatStringProp, categoryValue.value);
	                        items.push({ displayName: displayName, value: categoryFormattedValue });
	                    }
	                    else {
	                        var categoryFormattedValue = getFormattedValue(categoryValue.metadata[0], formatStringProp, categoryValue.value);
	                        items.push({ displayName: categoryValue.metadata[0].displayName, value: categoryFormattedValue });
	                    }
	                }
	                if (valuesSource) {
	                    // Dynamic series value
	                    var dynamicValue = void 0;
	                    if (seriesValues.length > 0) {
	                        var dynamicValueMetadata = seriesValues[0].metadata.source;
	                        dynamicValue = getFormattedValue(valuesSource, formatStringProp, dynamicValueMetadata.groupName);
	                    }
	                    items.push({ displayName: valuesSource.displayName, value: dynamicValue });
	                }
	                for (var i = 0; i < seriesValues.length; i++) {
	                    var seriesData = seriesValues[i];
	                    if (seriesData && seriesData.metadata) {
	                        var seriesMetadataColumn = seriesData.metadata.source;
	                        var value = seriesData.value;
	                        var highlightedValue = seriesData.highlightedValue;
	                        if (value || value === 0) {
	                            var formattedValue = getFormattedValue(seriesMetadataColumn, formatStringProp, value);
	                            items.push({ displayName: seriesMetadataColumn.displayName, value: formattedValue });
	                        }
	                        if (highlightedValue || highlightedValue === 0) {
	                            var formattedHighlightedValue = getFormattedValue(seriesMetadataColumn, formatStringProp, highlightedValue);
	                            var displayName = ToolTipComponent.localizationOptions.highlightedValueDisplayName;
	                            items.push({ displayName: displayName, value: formattedHighlightedValue });
	                        }
	                    }
	                }
	                return items;
	            }
	            function addTooltipBucketItem(reader, tooltipInfo, categoryIndex, seriesIndex) {
	                var tooltipValues = reader.getAllValuesForRole("Tooltips", categoryIndex, seriesIndex);
	                var tooltipMetadataColumns = reader.getAllValueMetadataColumnsForRole("Tooltips", seriesIndex);
	                if (tooltipValues && tooltipMetadataColumns) {
	                    for (var j = 0; j < tooltipValues.length; j++) {
	                        if (tooltipValues[j] != null && tooltipMetadataColumns[j]) {
	                            tooltipInfo.push({
	                                displayName: tooltipMetadataColumns[j].displayName,
	                                value: visuals.converterHelper.formatFromMetadataColumn(tooltipValues[j], tooltipMetadataColumns[j], visuals.Gauge.formatStringProp),
	                            });
	                        }
	                    }
	                }
	            }
	            TooltipBuilder.addTooltipBucketItem = addTooltipBucketItem;
	            function getFormattedValue(column, formatStringProp, value) {
	                var formatString = getFormatStringFromColumn(column, formatStringProp);
	                return visuals.valueFormatter.format(value, formatString);
	            }
	            function getFormatStringFromColumn(column, formatStringProp) {
	                if (column) {
	                    var formatString = visuals.valueFormatter.getFormatString(column, formatStringProp, true);
	                    return formatString || column.format;
	                }
	                return null;
	            }
	        })(TooltipBuilder = visuals.TooltipBuilder || (visuals.TooltipBuilder = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 283 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var visualStyles;
	        (function (visualStyles) {
	            function create(dataColors) {
	                if (dataColors === undefined)
	                    dataColors = new visuals.DataColorPalette();
	                return {
	                    titleText: {
	                        color: { value: '#333' }
	                    },
	                    subTitleText: {
	                        color: { value: '#919191' }
	                    },
	                    colorPalette: {
	                        foreground: { value: '#333' },
	                        background: { value: '#fff' },
	                        tableAccent: { value: dataColors.getColorByIndex(0).value },
	                        dataColors: dataColors,
	                    },
	                    labelText: {
	                        color: {
	                            value: '#333',
	                        },
	                        fontSize: '11px'
	                    },
	                    isHighContrast: false,
	                };
	            }
	            visualStyles.create = create;
	        })(visualStyles = visuals.visualStyles || (visuals.visualStyles = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 284 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
	        /**
	         * Renders a donut chart.
	         */
	        var DonutChart = (function () {
	            function DonutChart(options) {
	                if (options) {
	                    this.sliceWidthRatio = options.sliceWidthRatio;
	                    this.animator = options.animator;
	                    this.isScrollable = options.isScrollable ? options.isScrollable : false;
	                    this.disableGeometricCulling = options.disableGeometricCulling ? options.disableGeometricCulling : false;
	                    this.behavior = options.behavior;
	                    this.tooltipsEnabled = options.tooltipsEnabled;
	                    this.tooltipBucketEnabled = options.tooltipBucketEnabled;
	                    if (options.smallViewPortProperties) {
	                        this.maxHeightToScaleDonutLegend = options.smallViewPortProperties.maxHeightToScaleDonutLegend;
	                    }
	                }
	                if (this.sliceWidthRatio == null) {
	                    this.sliceWidthRatio = DonutChart.defaultSliceWidthRatio;
	                }
	            }
	            DonutChart.converter = function (dataView, colors, defaultDataPointColor, viewport, disableGeometricCulling, interactivityService, tooltipsEnabled, tooltipBucketEnabled) {
	                if (tooltipsEnabled === void 0) { tooltipsEnabled = true; }
	                var converter = new DonutChartConversion.DonutChartConverter(dataView, colors, defaultDataPointColor, tooltipsEnabled, tooltipBucketEnabled);
	                converter.convert();
	                var d3PieLayout = d3.layout.pie()
	                    .sort(null)
	                    .value(function (d) {
	                    return d.percentage;
	                });
	                if (interactivityService) {
	                    interactivityService.applySelectionStateToData(converter.dataPoints);
	                    interactivityService.applySelectionStateToData(converter.legendData.dataPoints);
	                }
	                var culledDataPoints = (!disableGeometricCulling && viewport) ? DonutChart.cullDataByViewport(converter.dataPoints, converter.maxValue, viewport) : converter.dataPoints;
	                return {
	                    dataPointsToDeprecate: culledDataPoints,
	                    dataPoints: d3PieLayout(culledDataPoints),
	                    unCulledDataPoints: converter.dataPoints,
	                    dataPointsToEnumerate: converter.legendData.dataPoints,
	                    legendData: converter.legendData,
	                    hasHighlights: converter.hasHighlights,
	                    highlightsOverflow: converter.highlightsOverflow,
	                    dataLabelsSettings: converter.dataLabelsSettings,
	                    legendObjectProperties: converter.legendObjectProperties,
	                    maxValue: converter.maxValue,
	                    visibleGeometryCulled: converter.dataPoints.length !== culledDataPoints.length,
	                    hasNegativeValues: converter.hasNegativeValues,
	                    allValuesAreNegative: converter.allValuesAreNegative,
	                };
	            };
	            DonutChart.prototype.init = function (options) {
	                this.options = options;
	                var element = options.element;
	                // Ensure viewport is empty on init
	                element.empty();
	                this.parentViewport = options.viewport;
	                // avoid deep copy
	                this.currentViewport = {
	                    height: options.viewport.height,
	                    width: options.viewport.width,
	                };
	                this.formatter = visuals.valueFormatter.format;
	                this.data = {
	                    dataPointsToDeprecate: [],
	                    dataPointsToEnumerate: [],
	                    dataPoints: [],
	                    unCulledDataPoints: [],
	                    legendData: { title: "", dataPoints: [], fontSize: visuals.SVGLegend.DefaultFontSizeInPt },
	                    hasHighlights: false,
	                    highlightsOverflow: false,
	                    dataLabelsSettings: visuals.dataLabelUtils.getDefaultDonutLabelSettings(),
	                    hasNegativeValues: false,
	                    allValuesAreNegative: false,
	                };
	                this.drilled = false;
	                // Leaving this false for now, will depend on the datacategory in the future
	                this.allowDrilldown = false;
	                this.style = options.style;
	                this.colors = this.style.colorPalette.dataColors;
	                this.radius = 0;
	                this.isInteractive = options.interactivity && options.interactivity.isInteractiveLegend;
	                var donutChartSettings = this.settings;
	                if (this.behavior) {
	                    this.interactivityService = visuals.createInteractivityService(options.host);
	                }
	                this.legend = visuals.createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, this.interactivityService, this.isScrollable);
	                this.hostService = options.host;
	                if (this.isInteractive) {
	                    this.chartRotationAnimationDuration = (donutChartSettings && donutChartSettings.chartRotationAnimationDuration) ? donutChartSettings.chartRotationAnimationDuration : 0;
	                    // Create interactive legend
	                    var legendContainer = this.legendContainer = d3.select(element.get(0))
	                        .append('div')
	                        .classed(DonutChart.InteractiveLegendClassName, true);
	                    this.interactivityState = {
	                        interactiveLegend: new DonutChartInteractiveLegend(this, legendContainer, this.colors, options, this.settings),
	                        valueToAngleFactor: 0,
	                        sliceAngles: [],
	                        currentRotate: 0,
	                        interactiveChosenSliceFinishedSetting: false,
	                        lastChosenInteractiveSliceIndex: 0,
	                        totalDragAngleDifference: 0,
	                        currentIndexDrag: 0,
	                        previousIndexDrag: 0,
	                        previousDragAngle: 0,
	                        donutCenter: { x: 0, y: 0 },
	                    };
	                }
	                this.svg = d3.select(element.get(0))
	                    .append('svg')
	                    .style('position', 'absolute')
	                    .classed(DonutChart.ClassName, true);
	                if (this.behavior)
	                    this.clearCatcher = visuals.appendClearCatcher(this.svg);
	                this.mainGraphicsContext = this.svg.append('g');
	                this.mainGraphicsContext.append("g")
	                    .classed('slices', true);
	                this.labelGraphicsContext = this.svg
	                    .append("g")
	                    .classed(visuals.NewDataLabelUtils.labelGraphicsContextClass.class, true);
	                this.pie = d3.layout.pie()
	                    .sort(null)
	                    .value(function (d) {
	                    return d.percentage;
	                });
	            };
	            DonutChart.prototype.update = function (options) {
	                debug.assertValue(options, 'options');
	                // Viewport resizing
	                var viewport = options.viewport;
	                this.parentViewport = viewport;
	                var dataViews = this.dataViews = options.dataViews;
	                if (dataViews && dataViews.length > 0 && dataViews[0].categorical) {
	                    var dataViewMetadata = dataViews[0].metadata;
	                    var defaultDataPointColor = undefined;
	                    if (dataViewMetadata) {
	                        var objects = dataViewMetadata.objects;
	                        if (objects) {
	                            defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.donutChartProps.dataPoint.defaultColor);
	                        }
	                    }
	                    this.data = DonutChart.converter(dataViews[0], this.colors, defaultDataPointColor, this.currentViewport, this.disableGeometricCulling, this.interactivityService, this.tooltipsEnabled, this.tooltipBucketEnabled);
	                    this.data.defaultDataPointColor = defaultDataPointColor;
	                    if (!(this.options.interactivity && this.options.interactivity.isInteractiveLegend))
	                        this.renderLegend();
	                }
	                else {
	                    this.data = {
	                        dataPointsToDeprecate: [],
	                        dataPointsToEnumerate: [],
	                        dataPoints: [],
	                        unCulledDataPoints: [],
	                        legendData: { title: "", dataPoints: [] },
	                        hasHighlights: false,
	                        highlightsOverflow: false,
	                        dataLabelsSettings: visuals.dataLabelUtils.getDefaultDonutLabelSettings(),
	                        hasNegativeValues: false,
	                        allValuesAreNegative: false,
	                    };
	                }
	                this.initViewportDependantProperties();
	                this.initDonutProperties();
	                this.updateInternal(this.data, options.suppressAnimations);
	                this.hasSetData = true;
	                if (dataViews) {
	                    var warnings = visuals.getInvalidValueWarnings(dataViews, false /*supportsNaN*/, false /*supportsNegativeInfinity*/, false /*supportsPositiveInfinity*/);
	                    if (this.data.allValuesAreNegative) {
	                        warnings.push(new visuals.AllNegativeValuesWarning());
	                    }
	                    else if (this.data.hasNegativeValues) {
	                        warnings.push(new visuals.NegativeValuesNotSupportedWarning());
	                    }
	                    this.hostService.setWarnings(warnings);
	                }
	            };
	            DonutChart.prototype.onDataChanged = function (options) {
	                debug.assertValue(options, 'options');
	                this.update({
	                    dataViews: options.dataViews,
	                    suppressAnimations: options.suppressAnimations,
	                    viewport: this.currentViewport,
	                });
	            };
	            DonutChart.prototype.onResizing = function (viewport) {
	                this.update({
	                    dataViews: this.dataViews,
	                    suppressAnimations: true,
	                    viewport: viewport,
	                });
	            };
	            DonutChart.prototype.enumerateObjectInstances = function (options) {
	                var enumeration = new visuals.ObjectEnumerationBuilder();
	                var dataLabelsSettings = this.data && this.data.dataLabelsSettings
	                    ? this.data.dataLabelsSettings
	                    : visuals.dataLabelUtils.getDefaultDonutLabelSettings();
	                switch (options.objectName) {
	                    case 'legend':
	                        this.enumerateLegend(enumeration);
	                        break;
	                    case 'dataPoint':
	                        this.enumerateDataPoints(enumeration);
	                        break;
	                    case 'labels':
	                        var labelSettingOptions = {
	                            enumeration: enumeration,
	                            dataLabelsSettings: dataLabelsSettings,
	                            show: true,
	                            displayUnits: true,
	                            precision: true,
	                            fontSize: true,
	                            labelStyle: true,
	                        };
	                        visuals.dataLabelUtils.enumerateDataLabels(labelSettingOptions);
	                        break;
	                }
	                return enumeration.complete();
	            };
	            DonutChart.prototype.enumerateDataPoints = function (enumeration) {
	                var data = this.data;
	                if (!data)
	                    return;
	                var dataPoints = data.dataPointsToEnumerate;
	                var dataPointsLength = dataPoints.length;
	                for (var i = 0; i < dataPointsLength; i++) {
	                    var dataPoint = dataPoints[i];
	                    enumeration.pushInstance({
	                        objectName: 'dataPoint',
	                        displayName: dataPoint.label,
	                        selector: visuals.ColorHelper.normalizeSelector(dataPoint.identity.getSelector()),
	                        properties: {
	                            fill: { solid: { color: dataPoint.color } }
	                        },
	                    });
	                }
	            };
	            DonutChart.prototype.enumerateLegend = function (enumeration) {
	                var data = this.data;
	                if (!data)
	                    return;
	                var legendObjectProperties = { legend: data.legendObjectProperties };
	                var show = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.donutChartProps.legend.show, this.legend.isVisible());
	                var showTitle = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.donutChartProps.legend.showTitle, true);
	                var titleText = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.donutChartProps.legend.titleText, this.data.legendData.title);
	                var labelColor = powerbi.DataViewObject.getValue(legendObjectProperties, visuals.legendProps.labelColor, this.data.legendData.labelColor);
	                var labelFontSize = powerbi.DataViewObject.getValue(legendObjectProperties, visuals.legendProps.fontSize, this.data.legendData.fontSize);
	                var position = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.donutChartProps.legend.position, visuals.legendPosition.top);
	                enumeration.pushInstance({
	                    selector: null,
	                    objectName: 'legend',
	                    properties: {
	                        show: show,
	                        position: position,
	                        showTitle: showTitle,
	                        titleText: titleText,
	                        labelColor: labelColor,
	                        fontSize: labelFontSize
	                    }
	                });
	            };
	            DonutChart.prototype.setInteractiveChosenSlice = function (sliceIndex) {
	                var _this = this;
	                if (this.interactivityState.sliceAngles.length === 0)
	                    return;
	                this.interactivityState.lastChosenInteractiveSliceIndex = sliceIndex;
	                this.interactivityState.interactiveChosenSliceFinishedSetting = false;
	                var viewport = this.currentViewport;
	                var moduledIndex = sliceIndex % this.data.dataPoints.length;
	                var angle = this.interactivityState.sliceAngles[moduledIndex];
	                this.svg.select('g')
	                    .transition()
	                    .duration(this.chartRotationAnimationDuration)
	                    .ease('elastic')
	                    .attr('transform', visuals.SVGUtil.translateAndRotate(viewport.width / 2, viewport.height / 2, 0, 0, angle))
	                    .each('end', function () { _this.interactivityState.interactiveChosenSliceFinishedSetting = true; });
	                this.interactivityState.currentRotate = angle;
	                this.interactivityState.interactiveLegend.updateLegend(moduledIndex);
	                // Set the opacity of chosen slice to full and the others to semi-transparent
	                this.svg.selectAll('.slice').attr('opacity', function (d, index) {
	                    return index === moduledIndex ? 1 : 0.6;
	                });
	                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
	            };
	            DonutChart.prototype.calculateRadius = function () {
	                var viewport = this.currentViewport;
	                if (!this.isInteractive && this.data && this.data.dataLabelsSettings.show) {
	                    // if we have category or data labels, use a sigmoid to blend the desired denominator from 2 to 3.
	                    // if we are taller than we are wide, we need to use a larger denominator to leave horizontal room for the labels.
	                    var hw = viewport.height / viewport.width;
	                    var denom = 2 + (1 / (1 + Math.exp(-5 * (hw - 1))));
	                    return Math.min(viewport.height, viewport.width) / denom;
	                }
	                // no labels (isInteractive does not have labels since the interactive legend shows extra info)
	                return Math.min(viewport.height, viewport.width) / 2;
	            };
	            DonutChart.prototype.getScaleForLegendArrow = function () {
	                var ratio = 1.0;
	                if (this.maxHeightToScaleDonutLegend && this.currentViewport.height < this.maxHeightToScaleDonutLegend) {
	                    ratio = this.currentViewport.height / this.maxHeightToScaleDonutLegend;
	                }
	                return ratio;
	            };
	            DonutChart.prototype.initViewportDependantProperties = function (duration) {
	                if (duration === void 0) { duration = 0; }
	                this.currentViewport.height = this.parentViewport.height;
	                this.currentViewport.width = this.parentViewport.width;
	                var viewport = this.currentViewport;
	                if (this.isInteractive) {
	                    viewport.height -= DonutChart.InteractiveLegendContainerHeight; // leave space for the legend
	                }
	                else {
	                    var legendMargins = this.legend.getMargins();
	                    viewport.height -= legendMargins.height;
	                    viewport.width -= legendMargins.width;
	                }
	                this.svg.attr({
	                    'width': viewport.width,
	                    'height': viewport.height
	                });
	                if (this.isInteractive) {
	                    this.legendContainer
	                        .style({
	                        'width': '100%',
	                        'height': DonutChart.InteractiveLegendContainerHeight + 'px',
	                        'overflow': 'hidden',
	                        'top': 0
	                    });
	                    this.svg
	                        .style('top', DonutChart.InteractiveLegendContainerHeight);
	                }
	                else {
	                    visuals.Legend.positionChartArea(this.svg, this.legend);
	                }
	                this.previousRadius = this.radius;
	                var radius = this.radius = this.calculateRadius();
	                var halfViewportWidth = viewport.width / 2;
	                var halfViewportHeight = viewport.height / 2;
	                this.arc = d3.svg.arc();
	                this.outerArc = d3.svg.arc()
	                    .innerRadius(radius * DonutChart.OuterArcRadiusRatio)
	                    .outerRadius(radius * DonutChart.OuterArcRadiusRatio);
	                if (this.isInteractive) {
	                    this.mainGraphicsContext.attr('transform', visuals.SVGUtil.translate(halfViewportWidth, halfViewportHeight));
	                    this.labelGraphicsContext.attr('transform', visuals.SVGUtil.translate(halfViewportWidth, halfViewportHeight));
	                }
	                else {
	                    this.mainGraphicsContext.transition().duration(duration).attr('transform', visuals.SVGUtil.translate(halfViewportWidth, halfViewportHeight));
	                    this.labelGraphicsContext.transition().duration(duration).attr('transform', visuals.SVGUtil.translate(halfViewportWidth, halfViewportHeight));
	                }
	                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
	            };
	            DonutChart.prototype.initDonutProperties = function () {
	                this.donutProperties = {
	                    viewport: this.currentViewport,
	                    radius: this.radius,
	                    arc: this.arc.innerRadius(0).outerRadius(this.radius * DonutChart.InnerArcRadiusRatio),
	                    outerArc: this.outerArc,
	                    innerArcRadiusRatio: DonutChart.InnerArcRadiusRatio,
	                    outerArcRadiusRatio: DonutChart.OuterArcRadiusRatio,
	                    dataLabelsSettings: this.data.dataLabelsSettings,
	                };
	            };
	            DonutChart.prototype.mergeDatasets = function (first, second) {
	                var secondSet = d3.set();
	                second.forEach(function (d) {
	                    secondSet.add(d.identity ? d.identity.getKey() : d.data.identity.getKey());
	                });
	                var onlyFirst = first.filter(function (d) {
	                    return !secondSet.has(d.identity ? d.identity.getKey() : d.data.identity.getKey());
	                }).map(function (d) {
	                    var derived = powerbi.Prototype.inherit(d);
	                    derived.percentage === undefined ? derived.data.percentage = 0 : derived.percentage = 0;
	                    return derived;
	                });
	                return d3.merge([second, onlyFirst]);
	            };
	            DonutChart.prototype.updateInternal = function (data, suppressAnimations, duration) {
	                if (duration === void 0) { duration = 0; }
	                var viewport = this.currentViewport;
	                duration = duration || visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
	                if (this.animator) {
	                    var layout = DonutChart.getLayout(this.radius, this.sliceWidthRatio, viewport);
	                    var result = void 0;
	                    var shapes_1;
	                    var highlightShapes = void 0;
	                    var labelSettings = data.dataLabelsSettings;
	                    var labels = [];
	                    if (labelSettings && labelSettings.show) {
	                        labels = this.createLabels();
	                    }
	                    if (!suppressAnimations) {
	                        var animationOptions = {
	                            viewModel: data,
	                            colors: this.colors,
	                            graphicsContext: this.mainGraphicsContext,
	                            labelGraphicsContext: this.labelGraphicsContext,
	                            interactivityService: this.interactivityService,
	                            layout: layout,
	                            radius: this.radius,
	                            sliceWidthRatio: this.sliceWidthRatio,
	                            viewport: viewport,
	                            labels: labels,
	                            innerArcRadiusRatio: DonutChart.InnerArcRadiusRatio,
	                        };
	                        result = this.animator.animate(animationOptions);
	                        shapes_1 = result.shapes;
	                        highlightShapes = result.highlightShapes;
	                    }
	                    if (suppressAnimations || result.failed) {
	                        shapes_1 = DonutChart.drawDefaultShapes(this.svg, data, layout, this.colors, this.radius, this.interactivityService && this.interactivityService.hasSelection(), this.sliceWidthRatio, this.data.defaultDataPointColor);
	                        highlightShapes = DonutChart.drawDefaultHighlightShapes(this.svg, data, layout, this.colors, this.radius, this.sliceWidthRatio);
	                        visuals.NewDataLabelUtils.drawDefaultLabels(this.labelGraphicsContext, labels, false, true, true /*has tooltip */);
	                        visuals.NewDataLabelUtils.drawLabelLeaderLines(this.labelGraphicsContext, labels);
	                    }
	                    this.assignInteractions(shapes_1, highlightShapes, data);
	                    if (this.tooltipsEnabled) {
	                        visuals.TooltipManager.addTooltip(shapes_1, function (tooltipEvent) { return tooltipEvent.data.data.tooltipInfo; });
	                        visuals.TooltipManager.addTooltip(highlightShapes, function (tooltipEvent) { return tooltipEvent.data.data.tooltipInfo; });
	                    }
	                }
	                else {
	                    this.updateInternalToMove(data, duration);
	                }
	                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
	            };
	            DonutChart.prototype.createLabels = function () {
	                var labelLayout = new powerbi.DonutLabelLayout({
	                    maximumOffset: visuals.NewDataLabelUtils.maxLabelOffset,
	                    startingOffset: visuals.NewDataLabelUtils.startingLabelOffset
	                }, this.donutProperties);
	                var labelDataPoints = this.createLabelDataPoints();
	                return labelLayout.layout(labelDataPoints);
	            };
	            DonutChart.prototype.createLabelDataPoints = function () {
	                var data = this.data;
	                var labelDataPoints = [];
	                var measureFormatterCache = visuals.dataLabelUtils.createColumnFormatterCacheManager();
	                var alternativeScale = null;
	                if (data.dataLabelsSettings.displayUnits === 0)
	                    alternativeScale = d3.max(data.dataPoints, function (d) { return Math.abs(d.data.measure); });
	                for (var i = 0; i < this.data.dataPoints.length; i++) {
	                    var label = this.createLabelDataPoint(data.dataPoints[i], alternativeScale, measureFormatterCache);
	                    labelDataPoints.push(label);
	                }
	                return labelDataPoints;
	            };
	            DonutChart.prototype.createLabelDataPoint = function (d, alternativeScale, measureFormatterCache) {
	                var labelPoint = this.outerArc.centroid(d);
	                var labelX = visuals.DonutLabelUtils.getXPositionForDonutLabel(labelPoint[0]);
	                var labelY = labelPoint[1];
	                var labelSettings = this.data.dataLabelsSettings;
	                var measureFormatter = measureFormatterCache.getOrCreate(d.data.labelFormatString, labelSettings, alternativeScale);
	                var position = labelX < 0 ? 4 /* Left */ : 8 /* Right */;
	                var pointPosition = {
	                    point: {
	                        x: labelX,
	                        y: labelY,
	                    },
	                    validPositions: [position],
	                    radius: 0,
	                };
	                var outsideFill = labelSettings.labelColor ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultLabelColor;
	                var dataLabel;
	                var dataLabelSize;
	                var categoryLabel;
	                var categoryLabelSize;
	                var textSize;
	                var labelSettingsStyle = labelSettings.labelStyle;
	                var fontSize = labelSettings.fontSize;
	                var tooltip = "";
	                if (labelSettingsStyle === visuals.labelStyle.both || labelSettingsStyle === visuals.labelStyle.data) {
	                    dataLabel = measureFormatter.format(d.data.originalHighlightValue != null ? d.data.originalHighlightValue : d.data.originalMeasure);
	                    dataLabelSize = visuals.NewDataLabelUtils.getTextSize(dataLabel, fontSize);
	                }
	                if (labelSettingsStyle === visuals.labelStyle.both || labelSettingsStyle === visuals.labelStyle.category) {
	                    categoryLabel = d.data.label;
	                    categoryLabelSize = visuals.NewDataLabelUtils.getTextSize(categoryLabel, fontSize);
	                }
	                switch (labelSettingsStyle) {
	                    case visuals.labelStyle.both:
	                        var text = categoryLabel + " (" + dataLabel + ")";
	                        tooltip = text;
	                        textSize = visuals.NewDataLabelUtils.getTextSize(text, fontSize);
	                        break;
	                    case visuals.labelStyle.category:
	                        textSize = _.clone(categoryLabelSize);
	                        tooltip = categoryLabel;
	                        break;
	                    case visuals.labelStyle.data:
	                        textSize = _.clone(dataLabelSize);
	                        tooltip = dataLabel;
	                        break;
	                }
	                var leaderLinePoints = visuals.DonutLabelUtils.getLabelLeaderLineForDonutChart(d, this.donutProperties, pointPosition.point);
	                var leaderLinesSize = visuals.DonutLabelUtils.getLabelLeaderLinesSizeForDonutChart(leaderLinePoints);
	                return {
	                    isPreferred: true,
	                    text: "",
	                    tooltip: tooltip,
	                    textSize: textSize,
	                    outsideFill: outsideFill,
	                    fontSize: fontSize,
	                    identity: d.data.identity,
	                    parentShape: pointPosition,
	                    insideFill: visuals.NewDataLabelUtils.defaultInsideLabelColor,
	                    parentType: 0 /* Point */,
	                    alternativeScale: alternativeScale,
	                    donutArcDescriptor: d,
	                    angle: (d.startAngle + d.endAngle) / 2 - (Math.PI / 2),
	                    dataLabel: dataLabel,
	                    dataLabelSize: dataLabelSize,
	                    categoryLabel: categoryLabel,
	                    categoryLabelSize: categoryLabelSize,
	                    leaderLinePoints: leaderLinePoints,
	                    linesSize: leaderLinesSize,
	                };
	            };
	            DonutChart.prototype.renderLegend = function () {
	                if (!this.isInteractive) {
	                    var legendObjectProperties = this.data.legendObjectProperties;
	                    if (legendObjectProperties) {
	                        var legendData = this.data.legendData;
	                        visuals.LegendData.update(legendData, legendObjectProperties);
	                        var position = legendObjectProperties[visuals.legendProps.position];
	                        if (position)
	                            this.legend.changeOrientation(visuals.LegendPosition[position]);
	                        this.legend.drawLegend(legendData, this.parentViewport);
	                    }
	                    else {
	                        this.legend.changeOrientation(visuals.LegendPosition.Top);
	                        this.legend.drawLegend({ dataPoints: [] }, this.parentViewport);
	                    }
	                }
	            };
	            DonutChart.prototype.addInteractiveLegendArrow = function () {
	                if (!this.data || !this.data.dataPoints || this.data.dataPoints.length === 0)
	                    return;
	                var arrowHeightOffset = 11;
	                var arrowWidthOffset = 33 / 2;
	                if (!this.interactiveLegendArrow) {
	                    var interactiveLegendArrow = this.svg.append('g');
	                    interactiveLegendArrow.append('path')
	                        .classed(DonutChart.InteractiveLegendArrowClassName, true)
	                        .attr('d', 'M1.5,2.6C0.65,1.15,1.85,0,3,0l27,0c1.65,0,2.35,1.15,1.5,2.6L18,26.45c-0.8,1.45-2.15,1.45-2.95,0L1.95,2.6z');
	                    this.interactiveLegendArrow = interactiveLegendArrow;
	                }
	                var viewport = this.currentViewport;
	                // Calculate the offsets from the legend container to the arrow.
	                var scaleRatio = this.getScaleForLegendArrow();
	                var distanceBetweenLegendAndArrow = (viewport.height - 2 * this.radius) / 2 + (arrowHeightOffset * scaleRatio);
	                var middleOfChart = viewport.width / 2 - (arrowWidthOffset * scaleRatio);
	                this.interactiveLegendArrow.attr('transform', visuals.SVGUtil.translateAndScale(middleOfChart, distanceBetweenLegendAndArrow, scaleRatio));
	            };
	            DonutChart.prototype.calculateSliceAngles = function () {
	                var angles = [];
	                var data = this.data.dataPoints;
	                if (data.length === 0) {
	                    this.interactivityState.valueToAngleFactor = 0;
	                    this.interactivityState.sliceAngles = [];
	                    return;
	                }
	                var sum = 0;
	                for (var i = 0, ilen = data.length; i < ilen; i++) {
	                    sum += data[i].data.percentage; // value is an absolute number
	                }
	                debug.assert(sum !== 0, 'sum of slices values cannot be zero');
	                this.interactivityState.valueToAngleFactor = 360 / sum; // Calculate the ratio between 360 and the sum to know the angles to rotate by
	                var currentAngle = 0;
	                for (var i = 0, ilen = data.length; i < ilen; i++) {
	                    var relativeAngle = data[i].data.percentage * this.interactivityState.valueToAngleFactor;
	                    currentAngle += relativeAngle;
	                    angles.push((relativeAngle / 2) - currentAngle);
	                }
	                this.interactivityState.sliceAngles = angles;
	            };
	            DonutChart.prototype.assignInteractions = function (slices, highlightSlices, data) {
	                // assign interactions according to chart interactivity type
	                if (this.isInteractive) {
	                    this.assignInteractiveChartInteractions(slices);
	                }
	                else if (this.interactivityService) {
	                    var dataPoints = data.dataPoints.map(function (value) { return value.data; });
	                    var behaviorOptions = {
	                        clearCatcher: this.clearCatcher,
	                        slices: slices,
	                        highlightSlices: highlightSlices,
	                        allowDrilldown: this.allowDrilldown,
	                        visual: this,
	                        hasHighlights: data.hasHighlights,
	                    };
	                    this.interactivityService.bind(dataPoints, this.behavior, behaviorOptions);
	                }
	            };
	            DonutChart.prototype.assignInteractiveChartInteractions = function (slice) {
	                var _this = this;
	                var svg = this.svg;
	                this.interactivityState.interactiveChosenSliceFinishedSetting = true;
	                var svgRect = svg.node().getBoundingClientRect();
	                this.interactivityState.donutCenter = { x: svgRect.left + svgRect.width / 2, y: svgRect.top + svgRect.height / 2 }; // Center of the donut chart
	                this.interactivityState.totalDragAngleDifference = 0;
	                this.interactivityState.currentRotate = 0;
	                this.calculateSliceAngles();
	                // Set the on click method for the slices so thsete pie chart will turn according to each slice's corresponding angle [the angle its on top]
	                slice.on('click', function (d, clickedIndex) {
	                    if (d3.event.defaultPrevented)
	                        return; // click was suppressed, for example from drag event
	                    _this.setInteractiveChosenSlice(clickedIndex);
	                });
	                // Set the drag events
	                var drag = d3.behavior.drag()
	                    .origin(Object)
	                    .on('dragstart', function () { return _this.interactiveDragStart(); })
	                    .on('drag', function () { return _this.interactiveDragMove(); })
	                    .on('dragend', function () { return _this.interactiveDragEnd(); });
	                svg
	                    .style('touch-action', 'none')
	                    .call(drag);
	            };
	            /**
	             * Get the angle (in degrees) of the drag event coordinates.
	             * The angle is calculated against the plane of the center of the donut
	             * (meaning, when the center of the donut is at (0,0) coordinates).
	             */
	            DonutChart.prototype.getAngleFromDragEvent = function () {
	                var interactivityState = this.interactivityState;
	                // get pageX and pageY (coordinates of the drag event) according to event type
	                var pageX, pageY;
	                var sourceEvent = d3.event.sourceEvent;
	                // check if that's a touch event or not
	                if (sourceEvent.type.toLowerCase().indexOf('touch') !== -1) {
	                    if (sourceEvent.touches.length !== 1)
	                        return null; // in case there isn't a single touch - return null and do nothing.
	                    // take the first, single, touch surface.
	                    var touch = sourceEvent.touches[0];
	                    pageX = touch.pageX;
	                    pageY = touch.pageY;
	                }
	                else {
	                    pageX = sourceEvent.pageX;
	                    pageY = sourceEvent.pageY;
	                }
	                // Adjust the coordinates, putting the donut center as the (0,0) coordinates
	                var adjustedCoordinates = { x: pageX - interactivityState.donutCenter.x, y: -pageY + interactivityState.donutCenter.y };
	                // Move to polar axis - take only the angle (theta), and convert to degrees
	                var angleToThePlane = Math.atan2(adjustedCoordinates.y, adjustedCoordinates.x) * 180 / Math.PI;
	                return angleToThePlane;
	            };
	            DonutChart.prototype.interactiveDragStart = function () {
	                this.interactivityState.totalDragAngleDifference = 0;
	                this.interactivityState.previousDragAngle = this.getAngleFromDragEvent();
	            };
	            DonutChart.prototype.interactiveDragMove = function () {
	                var data = this.data.dataPoints;
	                var viewport = this.currentViewport;
	                var interactivityState = this.interactivityState;
	                if (interactivityState.interactiveChosenSliceFinishedSetting === true) {
	                    // get current angle from the drag event
	                    var currentDragAngle = this.getAngleFromDragEvent();
	                    if (!currentDragAngle)
	                        return; // if no angle was returned, do nothing
	                    // compare it to the previous drag event angle
	                    var angleDragDiff = interactivityState.previousDragAngle - currentDragAngle;
	                    interactivityState.totalDragAngleDifference += angleDragDiff;
	                    interactivityState.previousDragAngle = currentDragAngle;
	                    // Rotate the chart by the difference in angles
	                    interactivityState.currentRotate += angleDragDiff;
	                    // Rotate the chart to the current rotate angle
	                    this.svg.select('g')
	                        .attr('transform', visuals.SVGUtil.translateAndRotate(viewport.width / 2, viewport.height / 2, 0, 0, this.interactivityState.currentRotate));
	                    var currentHigherLimit = data[0].data.percentage * interactivityState.valueToAngleFactor;
	                    var currentAngle = interactivityState.currentRotate <= 0 ? (interactivityState.currentRotate * -1) % 360 : (360 - (interactivityState.currentRotate % 360));
	                    interactivityState.currentIndexDrag = 0;
	                    //consider making this  ++interactivityState.currentIndexDrag ? then you don't need the if statement, the interactivityState.currentIndexDrag +1 and interactivityState.currentIndexDrag++
	                    // Check the current index according to the angle 
	                    var dataLength = data.length;
	                    while ((interactivityState.currentIndexDrag < dataLength) && (currentAngle > currentHigherLimit)) {
	                        if (interactivityState.currentIndexDrag < (dataLength - 1)) {
	                            currentHigherLimit += (data[interactivityState.currentIndexDrag + 1].data.percentage * interactivityState.valueToAngleFactor);
	                        }
	                        interactivityState.currentIndexDrag++;
	                    }
	                    // If the index changed update the legend and opacity
	                    if (interactivityState.currentIndexDrag !== interactivityState.previousIndexDrag) {
	                        interactivityState.interactiveLegend.updateLegend(interactivityState.currentIndexDrag);
	                        // set the opacticity of the top slice to full and the others to semi-transparent
	                        this.svg.selectAll('.slice').attr('opacity', function (d, index) {
	                            return index === interactivityState.currentIndexDrag ? DonutChart.OpaqueOpacity : DonutChart.SemiTransparentOpacity;
	                        });
	                        interactivityState.previousIndexDrag = interactivityState.currentIndexDrag;
	                    }
	                }
	            };
	            DonutChart.prototype.interactiveDragEnd = function () {
	                // If totalDragDifference was changed, means we have a drag event (compared to a click event)
	                if (this.interactivityState.totalDragAngleDifference !== 0) {
	                    this.setInteractiveChosenSlice(this.interactivityState.currentIndexDrag);
	                    // drag happened - disable click event
	                    d3.event.sourceEvent.stopPropagation();
	                }
	            };
	            DonutChart.prototype.updateInternalToMove = function (data, duration) {
	                if (duration === void 0) { duration = 0; }
	                // Cache for performance
	                var svg = this.svg;
	                var pie = this.pie;
	                var key = this.key;
	                var arc = this.arc;
	                var radius = this.radius;
	                var previousRadius = this.previousRadius;
	                var sliceWidthRatio = this.sliceWidthRatio;
	                var existingData = this.svg.select('.slices')
	                    .selectAll('path' + DonutChart.sliceClass.selector)
	                    .data().map(function (d) { return d.data; });
	                if (existingData.length === 0) {
	                    existingData = data.dataPointsToDeprecate;
	                }
	                var is = this.mergeDatasets(existingData, data.dataPointsToDeprecate);
	                var slice = svg.select('.slices')
	                    .selectAll('path' + DonutChart.sliceClass.selector)
	                    .data(pie(data.dataPointsToDeprecate), key);
	                slice.enter()
	                    .insert('path')
	                    .classed(DonutChart.sliceClass.class, true)
	                    .each(function (d) { this._current = d; });
	                slice = svg.select('.slices')
	                    .selectAll('path' + DonutChart.sliceClass.selector)
	                    .data(pie(is), key);
	                var innerRadius = radius * sliceWidthRatio;
	                DonutChart.isSingleColor(data.dataPoints);
	                slice
	                    .style('fill', function (d) { return d.data.color; })
	                    .style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, false, data.hasHighlights); })
	                    .style('stroke', 'white')
	                    .style('stroke-dasharray', function (d) { return DonutChart.drawStrokeForDonutChart(radius, DonutChart.InnerArcRadiusRatio, d, sliceWidthRatio); })
	                    .style('stroke-width', function (d) { return d.data.strokeWidth; })
	                    .transition().duration(duration)
	                    .attrTween('d', function (d) {
	                    var i = d3.interpolate(this._current, d), k = d3.interpolate(previousRadius * DonutChart.InnerArcRadiusRatio, radius * DonutChart.InnerArcRadiusRatio);
	                    this._current = i(0);
	                    return function (t) {
	                        return arc.innerRadius(innerRadius).outerRadius(k(t))(i(t));
	                    };
	                });
	                slice = svg.select('.slices')
	                    .selectAll('path' + DonutChart.sliceClass.selector)
	                    .data(pie(data.dataPointsToDeprecate), key);
	                slice.exit()
	                    .transition()
	                    .delay(duration)
	                    .duration(0)
	                    .remove();
	                // For interactive chart, there shouldn't be slice labels (as you have the legend).
	                if (!this.isInteractive) {
	                    var labelSettings = data.dataLabelsSettings;
	                    var labels = [];
	                    if (labelSettings && labelSettings.show) {
	                        labels = this.createLabels();
	                    }
	                    visuals.NewDataLabelUtils.drawDefaultLabels(this.labelGraphicsContext, labels, false, true);
	                    visuals.NewDataLabelUtils.drawLabelLeaderLines(this.labelGraphicsContext, labels);
	                }
	                var highlightSlices = undefined;
	                if (data.hasHighlights) {
	                    // Draw partial highlight slices.
	                    highlightSlices = svg
	                        .select('.slices')
	                        .selectAll('path' + DonutChart.sliceHighlightClass.selector)
	                        .data(pie(data.dataPointsToDeprecate), key);
	                    highlightSlices
	                        .enter()
	                        .insert('path')
	                        .classed(DonutChart.sliceHighlightClass.class, true)
	                        .each(function (d) { this._current = d; });
	                    DonutChart.isSingleColor(data.dataPoints);
	                    highlightSlices
	                        .style('fill', function (d) { return d.data.color; })
	                        .style('fill-opacity', 1.0)
	                        .style('stroke', 'white')
	                        .style('stroke-dasharray', function (d) { return DonutChart.drawStrokeForDonutChart(radius, DonutChart.InnerArcRadiusRatio, d, sliceWidthRatio, d.data.highlightRatio); })
	                        .style('stroke-width', function (d) { return d.data.highlightRatio === 0 ? 0 : d.data.strokeWidth; })
	                        .transition().duration(duration)
	                        .attrTween('d', function (d) {
	                        var i = d3.interpolate(this._current, d), k = d3.interpolate(previousRadius * DonutChart.InnerArcRadiusRatio, DonutChart.getHighlightRadius(radius, sliceWidthRatio, d.data.highlightRatio));
	                        this._current = i(0);
	                        return function (t) {
	                            return arc.innerRadius(innerRadius).outerRadius(k(t))(i(t));
	                        };
	                    });
	                    highlightSlices
	                        .exit()
	                        .transition()
	                        .delay(duration)
	                        .duration(0)
	                        .remove();
	                }
	                else {
	                    svg
	                        .selectAll('path' + DonutChart.sliceHighlightClass.selector)
	                        .transition()
	                        .delay(duration)
	                        .duration(0)
	                        .remove();
	                }
	                this.assignInteractions(slice, highlightSlices, data);
	                if (this.tooltipsEnabled) {
	                    visuals.TooltipManager.addTooltip(slice, function (tooltipEvent) { return tooltipEvent.data.data.tooltipInfo; });
	                    if (data.hasHighlights) {
	                        visuals.TooltipManager.addTooltip(highlightSlices, function (tooltipEvent) { return tooltipEvent.data.data.tooltipInfo; });
	                    }
	                }
	                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
	                if (this.isInteractive) {
	                    this.addInteractiveLegendArrow();
	                    this.interactivityState.interactiveLegend.drawLegend(this.data.dataPointsToDeprecate);
	                    this.setInteractiveChosenSlice(this.interactivityState.lastChosenInteractiveSliceIndex ? this.interactivityState.lastChosenInteractiveSliceIndex : 0);
	                }
	            };
	            DonutChart.drawDefaultShapes = function (graphicsContext, donutData, layout, colors, radius, hasSelection, sliceWidthRatio, defaultColor) {
	                var shapes = graphicsContext.select('.slices')
	                    .selectAll('path' + DonutChart.sliceClass.selector)
	                    .data(donutData.dataPoints, function (d) { return d.data.identity.getKey(); });
	                shapes.enter()
	                    .insert('path')
	                    .classed(DonutChart.sliceClass.class, true);
	                DonutChart.isSingleColor(donutData.dataPoints);
	                shapes
	                    .style('fill', function (d) { return d.data.color; })
	                    .style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, hasSelection, donutData.hasHighlights); })
	                    .style('stroke-dasharray', function (d) { return DonutChart.drawStrokeForDonutChart(radius, DonutChart.InnerArcRadiusRatio, d, sliceWidthRatio); })
	                    .style('stroke-width', function (d) { return d.data.strokeWidth; })
	                    .attr(layout.shapeLayout);
	                shapes.exit()
	                    .remove();
	                return shapes;
	            };
	            DonutChart.drawDefaultHighlightShapes = function (graphicsContext, donutData, layout, colors, radius, sliceWidthRatio) {
	                var shapes = graphicsContext.select('.slices')
	                    .selectAll('path' + DonutChart.sliceHighlightClass.selector)
	                    .data(donutData.dataPoints.filter(function (value) { return value.data.highlightRatio != null; }), function (d) { return d.data.identity.getKey(); });
	                shapes.enter()
	                    .insert('path')
	                    .classed(DonutChart.sliceHighlightClass.class, true)
	                    .each(function (d) { this._current = d; });
	                DonutChart.isSingleColor(donutData.dataPoints);
	                shapes
	                    .style('fill', function (d) { return d.data.color; })
	                    .style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, true, false, donutData.hasHighlights); })
	                    .style('stroke', 'white')
	                    .style('stroke-dasharray', function (d) { return DonutChart.drawStrokeForDonutChart(radius, DonutChart.InnerArcRadiusRatio, d, sliceWidthRatio, d.data.highlightRatio); })
	                    .style('stroke-width', function (d) { return d.data.highlightRatio === 0 ? 0 : d.data.strokeWidth; })
	                    .attr(layout.highlightShapeLayout);
	                shapes.exit()
	                    .remove();
	                return shapes;
	            };
	            /**
	                Set true to the last data point when all slices have the same color
	            */
	            DonutChart.isSingleColor = function (dataPoints) {
	                if (dataPoints.length > 1) {
	                    var lastPoint = dataPoints.length - 1;
	                    dataPoints[lastPoint].data.isLastInDonut = dataPoints[lastPoint].data.color === dataPoints[0].data.color;
	                }
	            };
	            DonutChart.drawStrokeForDonutChart = function (radius, innerArcRadiusRatio, d, sliceWidthRatio, highlightRatio) {
	                if (highlightRatio === void 0) { highlightRatio = 1; }
	                var sliceRadius = radius * innerArcRadiusRatio * highlightRatio;
	                var sliceArc = (d.endAngle - d.startAngle) * sliceRadius;
	                var sectionWithoutStroke;
	                var sectionWithStroke;
	                /*Donut chart*/
	                if (sliceWidthRatio) {
	                    var innerRadius = radius * sliceWidthRatio;
	                    var outerRadius = highlightRatio * radius * (DonutChart.InnerArcRadiusRatio - sliceWidthRatio);
	                    var innerSliceArc = (d.endAngle - d.startAngle) * innerRadius;
	                    if (d.data.highlightRatio)
	                        sliceArc = (d.endAngle - d.startAngle) * (outerRadius + innerRadius);
	                    if (d.data.isLastInDonut) {
	                        //if all slices have the same color, the stroke of the last slice needs to be drawn on both radiuses
	                        return 0 + " " + sliceArc + " " + outerRadius + " " + innerSliceArc + " " + outerRadius;
	                    }
	                    sectionWithoutStroke = sliceArc + outerRadius + innerSliceArc;
	                    sectionWithStroke = outerRadius;
	                }
	                else {
	                    if (d.data.isLastInDonut) {
	                        //if all slices have the same color, the stroke of the last slice needs to be drawn on both radiuses
	                        sectionWithoutStroke = sliceArc;
	                        sectionWithStroke = sliceRadius * 2;
	                    }
	                    else {
	                        sectionWithoutStroke = sliceArc + sliceRadius;
	                        sectionWithStroke = sliceRadius;
	                    }
	                }
	                return 0 + " " + sectionWithoutStroke + " " + sectionWithStroke;
	            };
	            DonutChart.prototype.onClearSelection = function () {
	                if (this.interactivityService)
	                    this.interactivityService.clearSelection();
	            };
	            DonutChart.getLayout = function (radius, sliceWidthRatio, viewport) {
	                var innerRadius = radius * sliceWidthRatio;
	                var arc = d3.svg.arc().innerRadius(innerRadius);
	                var arcWithRadius = arc.outerRadius(radius * DonutChart.InnerArcRadiusRatio);
	                return {
	                    shapeLayout: {
	                        d: function (d) {
	                            return arcWithRadius(d);
	                        }
	                    },
	                    highlightShapeLayout: {
	                        d: function (d) {
	                            var highlightArc = arc.outerRadius(DonutChart.getHighlightRadius(radius, sliceWidthRatio, d.data.highlightRatio));
	                            return highlightArc(d);
	                        }
	                    },
	                    zeroShapeLayout: {
	                        d: function (d) {
	                            var zeroWithZeroRadius = arc.outerRadius(innerRadius || DonutChart.EffectiveZeroValue);
	                            return zeroWithZeroRadius(d);
	                        }
	                    },
	                };
	            };
	            DonutChart.getHighlightRadius = function (radius, sliceWidthRatio, highlightRatio) {
	                var innerRadius = radius * sliceWidthRatio;
	                return innerRadius + highlightRatio * radius * (DonutChart.InnerArcRadiusRatio - sliceWidthRatio);
	            };
	            DonutChart.cullDataByViewport = function (dataPoints, maxValue, viewport) {
	                var estimatedRadius = Math.min(viewport.width, viewport.height) / 2;
	                // Ratio of slice too small to show (invisible) = invisbleArcLength / circumference
	                var cullRatio = this.invisibleArcLengthInPixels / (estimatedRadius * DonutChart.twoPi);
	                var cullableValue = cullRatio * maxValue;
	                var culledDataPoints = [];
	                var prevPointColor;
	                for (var _i = 0, dataPoints_1 = dataPoints; _i < dataPoints_1.length; _i++) {
	                    var datapoint = dataPoints_1[_i];
	                    if (datapoint.measure >= cullableValue) {
	                        //updates the stroke width
	                        datapoint.strokeWidth = prevPointColor === datapoint.color ? 1 : 0;
	                        prevPointColor = datapoint.color;
	                        culledDataPoints.push(datapoint);
	                    }
	                }
	                return culledDataPoints;
	            };
	            DonutChart.ClassName = 'donutChart';
	            DonutChart.InteractiveLegendClassName = 'donutLegend';
	            DonutChart.InteractiveLegendArrowClassName = 'donutLegendArrow';
	            DonutChart.OuterArcRadiusRatio = 0.9;
	            DonutChart.InnerArcRadiusRatio = 0.8;
	            DonutChart.OpaqueOpacity = 1.0;
	            DonutChart.SemiTransparentOpacity = 0.6;
	            DonutChart.defaultSliceWidthRatio = 0.48;
	            DonutChart.invisibleArcLengthInPixels = 3;
	            DonutChart.sliceClass = createClassAndSelector('slice');
	            DonutChart.sliceHighlightClass = createClassAndSelector('slice-highlight');
	            DonutChart.twoPi = 2 * Math.PI;
	            DonutChart.InteractiveLegendContainerHeight = 70;
	            DonutChart.EffectiveZeroValue = 0.000000001; // Very small multiplier so that we have a properly shaped zero arc to animate to/from.
	            DonutChart.PolylineOpacity = 0.5;
	            return DonutChart;
	        }());
	        visuals.DonutChart = DonutChart;
	        /**
	        * This class is an interactive legend for the Donut Chart.
	         *
	         * Features: It is scrollable indefinitely, using drag gesture
	         * when you interact with it, it updates the donut chart itself.
	        */
	        var DonutChartInteractiveLegend = (function () {
	            function DonutChartInteractiveLegend(donutChart, legendContainer, colors, visualInitOptions, settings) {
	                this.legendContainerParent = legendContainer;
	                this.colors = colors;
	                this.donutChart = donutChart;
	                this.visualInitOptions = visualInitOptions;
	                this.legendItemsPositions = [];
	                this.legendTransitionAnimationDuration = settings && settings.legendTransitionAnimationDuration ? settings.legendTransitionAnimationDuration : 0;
	            }
	            DonutChartInteractiveLegend.prototype.drawLegend = function (data) {
	                var _this = this;
	                this.data = data;
	                this.currentNumberOfLegendItems = data.length;
	                this.currentIndex = 0;
	                this.leftMostIndex = 0;
	                this.rightMostIndex = data.length - 1;
	                if (this.legendContainerParent.select(DonutChartInteractiveLegend.LegendContainerSelector).empty()) {
	                    this.legendContainer = this.legendContainerParent.append('div').classed(DonutChartInteractiveLegend.LegendContainerClassName, true);
	                }
	                var legendItems = this.legendContainer.selectAll(DonutChartInteractiveLegend.LegendItemSelector).data(data);
	                var legendContainerWidth = this.legendContainerWidth = this.legendContainer.node().getBoundingClientRect().width;
	                var initialXOffset = legendContainerWidth / 2 - (legendContainerWidth * 0.4 / 2) + DonutChartInteractiveLegend.ItemMargin;
	                var currX = initialXOffset;
	                this.currentXOffset = initialXOffset;
	                // Given the legend item div, create the item values (category, percentage and measure) on top of it.
	                var createLegendItem = function (itemDiv, datum) {
	                    // position the legend item
	                    itemDiv
	                        .attr('data-legend-index', datum.index) // assign index for later use
	                        .css({
	                        'position': 'absolute',
	                        'left': currX,
	                    });
	                    // Add the category, percentage and value
	                    var itemCategory = visuals.valueFormatter.format(datum.label);
	                    var itemValue = visuals.valueFormatter.format(datum.originalMeasure, datum.measureFormat);
	                    var itemPercentage = visuals.valueFormatter.format(datum.percentage, '0.00 %;-0.00 %;0.00 %');
	                    var itemColor = datum.color;
	                    // Create basic spans for width calculations
	                    var itemValueSpan = DonutChartInteractiveLegend.createBasicLegendItemSpan(DonutChartInteractiveLegend.LegendItemValueClassName, itemValue, 11);
	                    var itemCategorySpan = DonutChartInteractiveLegend.createBasicLegendItemSpan(DonutChartInteractiveLegend.LegendItemCategoryClassName, itemCategory, 11);
	                    var itemPercentageSpan = DonutChartInteractiveLegend.createBasicLegendItemSpan(DonutChartInteractiveLegend.LegendItemPercentageClassName, itemPercentage, 20);
	                    // Calculate Legend Box size according to widths and set the width accordingly
	                    var valueSpanWidth = DonutChartInteractiveLegend.spanWidth(itemValueSpan);
	                    var categorySpanWidth = DonutChartInteractiveLegend.spanWidth(itemCategorySpan);
	                    var precentageSpanWidth = DonutChartInteractiveLegend.spanWidth(itemPercentageSpan);
	                    var currentLegendBoxWidth = DonutChartInteractiveLegend.legendBoxSize(valueSpanWidth, categorySpanWidth, precentageSpanWidth);
	                    itemDiv.css('width', currentLegendBoxWidth);
	                    // Calculate margins so that all the spans will be placed in the middle
	                    var getLeftValue = function (spanWidth) {
	                        return currentLegendBoxWidth - spanWidth > 0 ? (currentLegendBoxWidth - spanWidth) / 2 : 0;
	                    };
	                    var marginLeftValue = getLeftValue(valueSpanWidth);
	                    var marginLeftCategory = getLeftValue(categorySpanWidth);
	                    var marginLeftPrecentage = getLeftValue(precentageSpanWidth);
	                    // Create the actual spans with the right styling and margins so it will be center aligned and add them
	                    DonutChartInteractiveLegend.createLegendItemSpan(itemCategorySpan, marginLeftCategory);
	                    DonutChartInteractiveLegend.createLegendItemSpan(itemValueSpan, marginLeftValue);
	                    DonutChartInteractiveLegend.createLegendItemSpan(itemPercentageSpan, marginLeftPrecentage).css('color', itemColor);
	                    itemDiv.append(itemCategorySpan);
	                    itemDiv.append(itemPercentageSpan);
	                    itemDiv.append(itemValueSpan);
	                    _this.legendItemsPositions.push({
	                        startX: currX,
	                        boxWidth: currentLegendBoxWidth,
	                    });
	                    currX += currentLegendBoxWidth + DonutChartInteractiveLegend.ItemMargin;
	                };
	                // Create the Legend Items
	                legendItems.enter()
	                    .insert('div')
	                    .classed(DonutChartInteractiveLegend.LegendItemClassName, true)
	                    .each(function (d) {
	                    createLegendItem($(this), d);
	                });
	                legendItems.exit().remove();
	                // Assign interactions on the legend
	                this.assignInteractions();
	            };
	            DonutChartInteractiveLegend.prototype.updateLegend = function (sliceIndex) {
	                var _this = this;
	                var legendContainerWidth = this.legendContainerWidth;
	                this.currentIndex = sliceIndex;
	                // "rearrange" legend items if needed, so we would have contnious endless scrolling
	                this.updateLabelBlocks(sliceIndex);
	                var legendTransitionAnimationDuration = this.legendTransitionAnimationDuration;
	                // Transform the legend so that the selected slice would be in the middle
	                var nextXOffset = (this.legendItemsPositions[sliceIndex].startX + (this.legendItemsPositions[sliceIndex].boxWidth / 2) - (legendContainerWidth / 2)) * (-1);
	                this.legendContainer
	                    .transition()
	                    .styleTween('-webkit-transform', function (d, i, a) {
	                    return d3.interpolate(visuals.SVGUtil.translateWithPixels(_this.currentXOffset, 0), visuals.SVGUtil.translateWithPixels(nextXOffset, 0));
	                })
	                    .styleTween('transform', function (d, i, a) {
	                    return d3.interpolate(visuals.SVGUtil.translateWithPixels(_this.currentXOffset, 0), visuals.SVGUtil.translateWithPixels(nextXOffset, 0));
	                })
	                    .duration(legendTransitionAnimationDuration)
	                    .ease('bounce')
	                    .each('end', function () {
	                    _this.currentXOffset = nextXOffset;
	                });
	                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.visualInitOptions);
	            };
	            DonutChartInteractiveLegend.prototype.assignInteractions = function () {
	                var _this = this;
	                var currentDX = 0; // keep how much drag had happened
	                var hasChanged = false; // flag to indicate if we changed the "center" value in the legend. We only change it once per swipe.
	                var dragStart = function () {
	                    currentDX = 0; // start of drag gesture
	                    hasChanged = false;
	                };
	                var dragMove = function () {
	                    currentDX += d3.event.dx;
	                    // Detect if swipe occured and if the index already changed in this drag
	                    if (hasChanged || Math.abs(currentDX) < DonutChartInteractiveLegend.MinimumSwipeDX)
	                        return;
	                    var dragDirectionLeft = (currentDX < 0);
	                    _this.dragLegend(dragDirectionLeft);
	                    hasChanged = true;
	                };
	                var drag = d3.behavior.drag()
	                    .origin(Object)
	                    .on('drag', dragMove)
	                    .on('dragstart', dragStart);
	                this.legendContainer
	                    .style({
	                    'touch-action': 'none',
	                    'cursor': 'pointer'
	                })
	                    .call(drag);
	            };
	            DonutChartInteractiveLegend.prototype.dragLegend = function (dragDirectionLeft) {
	                if (this.currentNumberOfLegendItems > (DonutChartInteractiveLegend.MinimumItemsInLegendForCycled - 1)) {
	                    this.currentIndex = this.getCyclingCurrentIndex(dragDirectionLeft);
	                }
	                else {
	                    if (this.shouldChangeIndexInNonCycling(dragDirectionLeft)) {
	                        if (dragDirectionLeft) {
	                            this.currentIndex++;
	                        }
	                        else {
	                            this.currentIndex--;
	                        }
	                    }
	                }
	                this.donutChart.setInteractiveChosenSlice(this.currentIndex);
	            };
	            DonutChartInteractiveLegend.prototype.shouldChangeIndexInNonCycling = function (dragDirectionLeft) {
	                if ((this.currentIndex === 0 && !dragDirectionLeft) || (this.currentIndex === (this.currentNumberOfLegendItems - 1) && dragDirectionLeft)) {
	                    return false;
	                }
	                return true;
	            };
	            DonutChartInteractiveLegend.prototype.getCyclingCurrentIndex = function (dragDirectionLeft) {
	                var dataLen = this.data.length;
	                var delta = dragDirectionLeft ? 1 : -1;
	                var newIndex = (this.currentIndex + delta) % (dataLen || 1); // modolu of negative number stays negative on javascript
	                return (newIndex < 0) ? newIndex + dataLen : newIndex;
	            };
	            DonutChartInteractiveLegend.prototype.updateLegendItemsBlocks = function (rightSidedShift, numberOfLegendItemsBlocksToShift) {
	                var legendContainer$ = $(this.legendContainer[0]);
	                if (rightSidedShift) {
	                    var smallestItem = legendContainer$.find('[data-legend-index=' + this.leftMostIndex + ']');
	                    smallestItem.remove().insertAfter(legendContainer$.find('[data-legend-index=' + this.rightMostIndex + ']'));
	                    var newX = this.legendItemsPositions[this.rightMostIndex].startX + this.legendItemsPositions[this.rightMostIndex].boxWidth + DonutChartInteractiveLegend.ItemMargin;
	                    this.legendItemsPositions[this.leftMostIndex].startX = newX;
	                    smallestItem.css('left', newX);
	                    this.rightMostIndex = this.leftMostIndex;
	                    this.leftMostIndex = (this.leftMostIndex + 1) % this.data.length;
	                }
	                else {
	                    var highestItem = legendContainer$.find('[data-legend-index=' + this.rightMostIndex + ']');
	                    highestItem.remove().insertBefore(legendContainer$.find('[data-legend-index=' + this.leftMostIndex + ']'));
	                    var newX = this.legendItemsPositions[this.leftMostIndex].startX - this.legendItemsPositions[this.rightMostIndex].boxWidth - DonutChartInteractiveLegend.ItemMargin;
	                    this.legendItemsPositions[this.rightMostIndex].startX = newX;
	                    highestItem.css('left', newX);
	                    this.leftMostIndex = this.rightMostIndex;
	                    this.rightMostIndex = (this.rightMostIndex - 1) === -1 ? (this.legendItemsPositions.length - 1) : (this.rightMostIndex - 1);
	                }
	                if ((numberOfLegendItemsBlocksToShift - 1) !== 0) {
	                    this.updateLegendItemsBlocks(rightSidedShift, (numberOfLegendItemsBlocksToShift - 1));
	                }
	            };
	            /** Update the legend items, allowing for endless rotation */
	            DonutChartInteractiveLegend.prototype.updateLabelBlocks = function (index) {
	                if (this.currentNumberOfLegendItems > DonutChartInteractiveLegend.MinimumItemsInLegendForCycled) {
	                    // The idea of the four if's is to keep two labels before and after the current one so it will fill the screen.
	                    // If the index of the slice is the highest currently availble add 2 labels "ahead" of it
	                    if (this.rightMostIndex === index)
	                        this.updateLegendItemsBlocks(true, 2);
	                    // If the index of the slice is the lowest currently availble add 2 labels "before" it
	                    if (this.leftMostIndex === index)
	                        this.updateLegendItemsBlocks(false, 2);
	                    // If the index of the slice is the second highest currently availble add a labels "ahead" of it
	                    if (this.rightMostIndex === (index + 1) || ((this.rightMostIndex === 0) && (index === (this.currentNumberOfLegendItems - 1))))
	                        this.updateLegendItemsBlocks(true, 1);
	                    // If the index of the slice is the second lowest currently availble add a labels "before" it
	                    if (this.leftMostIndex === (index - 1) || ((this.leftMostIndex === (this.currentNumberOfLegendItems - 1) && (index === 0))))
	                        this.updateLegendItemsBlocks(false, 1);
	                }
	                else {
	                    if (this.currentNumberOfLegendItems === DonutChartInteractiveLegend.MinimumItemsInLegendForCycled) {
	                        // If the index of the slice is the highest currently availble add a label "ahead" of it
	                        if (this.rightMostIndex === index)
	                            this.updateLegendItemsBlocks(true, 1);
	                        // If the index of the slice is the lowest currently availble add a label "before" it
	                        if (this.leftMostIndex === index)
	                            this.updateLegendItemsBlocks(false, 1);
	                    }
	                }
	            };
	            DonutChartInteractiveLegend.createBasicLegendItemSpan = function (spanClass, text, fontSize) {
	                return $('<span/>')
	                    .addClass(spanClass)
	                    .css({
	                    'white-space': 'nowrap',
	                    'font-size': fontSize + 'px',
	                })
	                    .text(text);
	            };
	            /** This method alters the given span and sets it to the final legen item span style. */
	            DonutChartInteractiveLegend.createLegendItemSpan = function (existingSpan, marginLeft) {
	                existingSpan
	                    .css({
	                    'overflow': 'hidden',
	                    'text-overflow': 'ellipsis',
	                    'display': 'inline-block',
	                    'width': '100%',
	                    'margin-left': marginLeft
	                });
	                return existingSpan;
	            };
	            /** Caclulte entire legend box size according to its building spans */
	            DonutChartInteractiveLegend.legendBoxSize = function (valueSpanWidth, categorySpanWidth, precentageSpanWidth) {
	                var boxSize = valueSpanWidth > categorySpanWidth ? valueSpanWidth : categorySpanWidth;
	                boxSize = boxSize > precentageSpanWidth ? boxSize : precentageSpanWidth;
	                boxSize = boxSize > DonutChartInteractiveLegend.MaxLegendItemBoxSize ? DonutChartInteractiveLegend.MaxLegendItemBoxSize : (boxSize + 2);
	                return boxSize;
	            };
	            DonutChartInteractiveLegend.spanWidth = function (span) {
	                if (!this.FakeElementSpan) {
	                    this.FakeElementSpan = $('<span>').hide().appendTo(document.body);
	                }
	                this.FakeElementSpan.empty();
	                this.FakeElementSpan.append(span);
	                return this.FakeElementSpan.width();
	            };
	            DonutChartInteractiveLegend.LegendContainerClassName = 'legend-container';
	            DonutChartInteractiveLegend.LegendContainerSelector = '.legend-container';
	            DonutChartInteractiveLegend.LegendItemClassName = 'legend-item';
	            DonutChartInteractiveLegend.LegendItemSelector = '.legend-item';
	            DonutChartInteractiveLegend.LegendItemCategoryClassName = 'category';
	            DonutChartInteractiveLegend.LegendItemPercentageClassName = 'percentage';
	            DonutChartInteractiveLegend.LegendItemValueClassName = 'value';
	            DonutChartInteractiveLegend.MaxLegendItemBoxSize = 160;
	            DonutChartInteractiveLegend.ItemMargin = 30; // Margin between items
	            DonutChartInteractiveLegend.MinimumSwipeDX = 15; // Minimup swipe gesture to create a change in the legend
	            DonutChartInteractiveLegend.MinimumItemsInLegendForCycled = 3; // Minimum items in the legend before we cycle it
	            return DonutChartInteractiveLegend;
	        }());
	        var DonutChartConversion;
	        (function (DonutChartConversion) {
	            ;
	            var DonutChartConverter = (function () {
	                function DonutChartConverter(dataView, colors, defaultDataPointColor, tooltipsEnabled, tooltipBucketEnabled) {
	                    if (tooltipsEnabled === void 0) { tooltipsEnabled = true; }
	                    var reader = this.reader = powerbi.data.createIDataViewCategoricalReader(dataView);
	                    var dataViewCategorical = dataView.categorical;
	                    this.dataViewCategorical = dataViewCategorical;
	                    this.dataViewMetadata = dataView.metadata;
	                    this.tooltipsEnabled = tooltipsEnabled;
	                    this.tooltipBucketEnabled = tooltipBucketEnabled;
	                    this.colorHelper = new visuals.ColorHelper(colors, visuals.donutChartProps.dataPoint.fill, defaultDataPointColor);
	                    this.maxValue = 0;
	                    this.hasNegativeValues = false;
	                    this.allValuesAreNegative = false;
	                    if (dataViewCategorical.categories && dataViewCategorical.categories.length > 0) {
	                        var category = dataViewCategorical.categories[0];
	                        this.categoryIdentities = category.identity;
	                        this.categoryValues = category.values;
	                        this.allCategoryObjects = category.objects;
	                        this.categoryColumnRef = category.identityFields;
	                        this.categoryFormatString = visuals.valueFormatter.getFormatString(category.source, visuals.donutChartProps.general.formatString);
	                    }
	                    this.isDynamicSeries = reader.hasDynamicSeries();
	                    this.highlightsOverflow = false;
	                    this.total = 0;
	                    this.highlightTotal = 0;
	                    this.dataPoints = [];
	                    this.legendDataPoints = [];
	                    this.dataLabelsSettings = null;
	                    // TODO: this should be shared with TreeMap
	                    if (reader.hasValues("Y")) {
	                        var seriesCount = this.seriesCount = reader.getSeriesCount("Y");
	                        this.hasHighlights = reader.hasHighlights("Y");
	                        var categoryCount = reader.getCategoryCount() || 1;
	                        this.allValuesAreNegative = undefined;
	                        for (var categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) {
	                            for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
	                                var value = reader.getValue("Y", categoryIndex, seriesIndex);
	                                var highlight = void 0;
	                                if (this.hasHighlights) {
	                                    highlight = reader.getHighlight("Y", categoryIndex, seriesIndex);
	                                    if (highlight == null)
	                                        highlight = 0;
	                                }
	                                if (this.allValuesAreNegative === undefined) {
	                                    this.allValuesAreNegative = ((this.hasHighlights ? highlight <= 0 : true) && value <= 0) ? true : false;
	                                }
	                                else {
	                                    this.allValuesAreNegative = this.allValuesAreNegative && (this.hasHighlights ? highlight <= 0 : true) && value <= 0;
	                                }
	                                if (!this.hasNegativeValues)
	                                    this.hasNegativeValues = value < 0 || (this.hasHighlights ? highlight < 0 : false);
	                            }
	                        }
	                        this.allValuesAreNegative = !!this.allValuesAreNegative;
	                        // We iterate over all categories, or if we have no categories, we just iterate over the series (category index = 0 is fine in that case)
	                        for (var categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) {
	                            for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
	                                var value = reader.getValue("Y", categoryIndex, seriesIndex);
	                                value = DonutChartConverter.normalizedValue(value, this.allValuesAreNegative);
	                                this.total += value;
	                                if (this.hasHighlights) {
	                                    var highlight = reader.getHighlight("Y", categoryIndex, seriesIndex);
	                                    highlight = DonutChartConverter.normalizedValue(highlight, this.allValuesAreNegative);
	                                    this.highlightTotal += highlight;
	                                    if (!this.highlightsOverflow && highlight > value) {
	                                        this.highlightsOverflow = true;
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	                // For public test
	                DonutChartConverter.normalizedValue = function (value, allValuesAreNegative) {
	                    if (value == null || isNaN(value))
	                        return 0;
	                    else if (value === Number.POSITIVE_INFINITY)
	                        return Number.MAX_VALUE;
	                    else if (value === Number.NEGATIVE_INFINITY)
	                        return -Number.MAX_VALUE;
	                    else if (allValuesAreNegative)
	                        return Math.abs(value);
	                    else if (value < 0)
	                        return 0;
	                    else
	                        return value;
	                };
	                DonutChartConverter.prototype.convert = function () {
	                    var reader = this.reader;
	                    var convertedData;
	                    if (this.total !== 0) {
	                        // We render based on categories, series, or measures in that order of preference
	                        if (this.categoryValues) {
	                            convertedData = this.convertCategoricalWithSlicing();
	                        }
	                        else if (this.isDynamicSeries) {
	                            // Series but no category.
	                            convertedData = this.convertSeries();
	                        }
	                        else {
	                            // No category or series; only measures.
	                            convertedData = this.convertMeasures();
	                        }
	                    }
	                    else {
	                        convertedData = [];
	                    }
	                    // Create data labels settings
	                    this.dataLabelsSettings = this.convertDataLabelSettings();
	                    var dataViewMetadata = this.dataViewMetadata;
	                    if (dataViewMetadata) {
	                        var objects = dataViewMetadata.objects;
	                        if (objects) {
	                            this.legendObjectProperties = objects['legend'];
	                        }
	                    }
	                    var category = !_.isEmpty(this.dataViewCategorical.categories) ? this.dataViewCategorical.categories[0] : null;
	                    this.dataPoints = [];
	                    var formatStringProp = visuals.donutChartProps.general.formatString;
	                    var prevPointColor;
	                    var pctFormatString = visuals.valueFormatter.getLocalizedString('Percentage');
	                    for (var i = 0, dataPointCount = convertedData.length; i < dataPointCount; i++) {
	                        var point = convertedData[i];
	                        var originalMeasure = point.measure;
	                        var normalizedMeasure = DonutChartConverter.normalizedValue(point.measure, this.allValuesAreNegative);
	                        var originalHighlight = point.highlightMeasure;
	                        var normalizedHighlight = DonutChartConverter.normalizedValue(point.highlightMeasure, this.allValuesAreNegative);
	                        var percentage = (this.total > 0) ? normalizedMeasure / this.total : 0.0;
	                        var highlightRatio = void 0;
	                        var highlightPercentage = void 0;
	                        if (normalizedMeasure > this.maxValue)
	                            this.maxValue = normalizedMeasure;
	                        if (normalizedHighlight > this.maxValue)
	                            this.maxValue = normalizedHighlight;
	                        if (this.hasHighlights) {
	                            // When any highlight value is greater than the corresponding non-highlight value
	                            // we just render all of the highlight values and discard the non-highlight values.
	                            if (this.highlightsOverflow) {
	                                originalMeasure = originalHighlight;
	                                normalizedMeasure = normalizedHighlight;
	                                percentage = (this.highlightTotal > 0) ? normalizedHighlight / this.highlightTotal : 0.0;
	                                highlightRatio = 1;
	                            }
	                            else {
	                                highlightRatio = normalizedMeasure !== 0 ? normalizedHighlight / normalizedMeasure : 0;
	                            }
	                            if (!highlightRatio) {
	                                highlightRatio = DonutChart.EffectiveZeroValue;
	                            }
	                            highlightPercentage = percentage * highlightRatio;
	                        }
	                        var categoryValue = point.categoryLabel;
	                        var categorical = this.dataViewCategorical;
	                        var valueIndex = void 0;
	                        if (point.seriesIndex != null) {
	                            valueIndex = point.seriesIndex;
	                        }
	                        else {
	                            // Static series with no categories
	                            valueIndex = i;
	                        }
	                        var valuesMetadata = reader.getValueMetadataColumn("Y", valueIndex);
	                        var value = this.hasHighlights && this.highlightsOverflow ? originalHighlight : originalMeasure;
	                        var highlightValue = this.hasHighlights && !this.highlightsOverflow ? originalHighlight : undefined;
	                        var formatString = visuals.valueFormatter.getFormatString(valuesMetadata, formatStringProp);
	                        var pct = visuals.valueFormatter.format(percentage, pctFormatString);
	                        var valueAndPct = void 0;
	                        if (value != null && pct != null) {
	                            valueAndPct = visuals.valueFormatter.format(value, formatString) + ' (' + pct + ')';
	                        }
	                        var highlightValueAndPct = void 0;
	                        if (highlightValue != null && highlightPercentage != null) {
	                            var highlightedPct = visuals.valueFormatter.format(highlightPercentage, pctFormatString);
	                            highlightValueAndPct = visuals.valueFormatter.format(highlightValue, formatString) + ' (' + highlightedPct + ')';
	                        }
	                        var tooltipInfo = void 0;
	                        if (this.tooltipsEnabled) {
	                            tooltipInfo = [];
	                            if (category) {
	                                tooltipInfo.push({
	                                    displayName: category.source.displayName,
	                                    value: categoryValue,
	                                });
	                            }
	                            if (this.isDynamicSeries) {
	                                if (!category || category.source !== categorical.values.source) {
	                                    // Category/series on the same column -- don't repeat its value in the tooltip.
	                                    tooltipInfo.push({
	                                        displayName: categorical.values.source.displayName,
	                                        value: point.label,
	                                    });
	                                }
	                            }
	                            if (valueAndPct != null) {
	                                tooltipInfo.push({
	                                    displayName: valuesMetadata.displayName,
	                                    value: valueAndPct,
	                                });
	                            }
	                            if (highlightValueAndPct != null) {
	                                tooltipInfo.push({
	                                    displayName: visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName,
	                                    value: highlightValueAndPct,
	                                });
	                            }
	                            if (this.tooltipBucketEnabled) {
	                                // SeriesIndex is not needed for static series.
	                                visuals.TooltipBuilder.addTooltipBucketItem(reader, tooltipInfo, this.categoryValues ? point.categoryIndex : 0, this.isDynamicSeries ? point.seriesIndex : undefined);
	                            }
	                        }
	                        var strokeWidth = (prevPointColor === point.color && percentage && percentage > 0) ? 1 : 0;
	                        prevPointColor = (percentage && percentage > 0) ? point.color : prevPointColor;
	                        this.dataPoints.push({
	                            identity: point.identity,
	                            measure: normalizedMeasure,
	                            originalMeasure: originalMeasure,
	                            measureFormat: point.measureFormat,
	                            percentage: percentage,
	                            index: point.index,
	                            label: point.label,
	                            highlightRatio: highlightRatio,
	                            highlightValue: (this.hasHighlights && !this.highlightsOverflow) ? normalizedHighlight : undefined,
	                            originalHighlightValue: (this.hasHighlights && !this.highlightsOverflow) ? originalHighlight : undefined,
	                            selected: false,
	                            tooltipInfo: tooltipInfo,
	                            color: point.color,
	                            strokeWidth: strokeWidth,
	                            labelFormatString: valuesMetadata.format,
	                        });
	                    }
	                    this.legendData = this.convertLegendData();
	                };
	                DonutChartConverter.prototype.getLegendTitle = function () {
	                    if (this.total !== 0) {
	                        // If category exists, we render title using category source. If not, we render title
	                        // using measure.
	                        var dvValuesSourceName = this.dataViewCategorical.values && this.dataViewCategorical.values.source
	                            ? this.dataViewCategorical.values.source.displayName : "";
	                        var dvCategorySourceName = this.dataViewCategorical.categories && this.dataViewCategorical.categories.length > 0 && this.dataViewCategorical.categories[0].source
	                            ? this.dataViewCategorical.categories[0].source.displayName : "";
	                        if (this.categoryValues) {
	                            return dvCategorySourceName;
	                        }
	                        else {
	                            return dvValuesSourceName;
	                        }
	                    }
	                    else {
	                        return "";
	                    }
	                };
	                DonutChartConverter.prototype.convertCategoricalWithSlicing = function () {
	                    var reader = this.reader;
	                    var dataViewCategorical = this.dataViewCategorical;
	                    var formatStringProp = visuals.donutChartProps.general.formatString;
	                    var dataPoints = [];
	                    for (var categoryIndex = 0, categoryCount = this.categoryValues.length; categoryIndex < categoryCount; categoryIndex++) {
	                        var categoryValue = this.categoryValues[categoryIndex];
	                        var thisCategoryObjects = this.allCategoryObjects ? this.allCategoryObjects[categoryIndex] : undefined;
	                        var legendIdentity = visuals.SelectionId.createWithId(this.categoryIdentities[categoryIndex]);
	                        var color = this.colorHelper.getColorForSeriesValue(thisCategoryObjects, this.categoryColumnRef, categoryValue);
	                        var categoryLabel = visuals.valueFormatter.format(categoryValue, this.categoryFormatString);
	                        // Series are either measures in the multi-measure case, or the single series otherwise
	                        for (var seriesIndex = 0; seriesIndex < this.seriesCount; seriesIndex++) {
	                            var value = reader.getValue("Y", categoryIndex, seriesIndex);
	                            var highlightValue = this.hasHighlights ? reader.getHighlight("Y", categoryIndex, seriesIndex) : undefined;
	                            var valueColumn = reader.getValueColumn("Y", seriesIndex);
	                            var label = categoryLabel;
	                            if (this.isDynamicSeries || reader.getSeriesCount("Y") > 1) {
	                                label = visuals.converterHelper.getFormattedLegendLabel(valueColumn.source, dataViewCategorical.values, formatStringProp);
	                            }
	                            var measure = valueColumn.source.queryName;
	                            var identity = visuals.SelectionIdBuilder.builder()
	                                .withCategory(dataViewCategorical.categories[0], categoryIndex)
	                                .withSeries(dataViewCategorical.values, this.isDynamicSeries ? valueColumn : undefined)
	                                .withMeasure(measure)
	                                .createSelectionId();
	                            var dataPoint = {
	                                identity: identity,
	                                measureFormat: visuals.valueFormatter.getFormatString(valueColumn.source, formatStringProp, true),
	                                measure: value,
	                                highlightMeasure: highlightValue,
	                                index: categoryIndex * this.seriesCount + seriesIndex,
	                                label: label,
	                                categoryLabel: categoryLabel,
	                                color: color,
	                                categoryIndex: categoryIndex,
	                                seriesIndex: seriesIndex
	                            };
	                            dataPoints.push(dataPoint);
	                        }
	                        this.legendDataPoints.push({
	                            label: categoryLabel,
	                            color: color,
	                            icon: visuals.LegendIcon.Box,
	                            identity: legendIdentity,
	                            selected: false
	                        });
	                    }
	                    return dataPoints;
	                };
	                DonutChartConverter.prototype.convertMeasures = function () {
	                    var reader = this.reader;
	                    var dataPoints = [];
	                    var formatStringProp = visuals.donutChartProps.general.formatString;
	                    for (var measureIndex = 0; measureIndex < this.seriesCount; measureIndex++) {
	                        var value = reader.getValue("Y", 0, measureIndex);
	                        var highlightValue = this.hasHighlights ? reader.getHighlight("Y", 0, measureIndex) : undefined;
	                        var valueColumn = reader.getValueColumn("Y", measureIndex);
	                        var measureFormat = visuals.valueFormatter.getFormatString(valueColumn.source, formatStringProp, true);
	                        var measureLabel = valueColumn.source.displayName;
	                        var identity = visuals.SelectionId.createWithMeasure(valueColumn.source.queryName);
	                        var color = this.colorHelper.getColorForMeasure(valueColumn.source.objects, valueColumn.source.queryName);
	                        var dataPoint = {
	                            identity: identity,
	                            measureFormat: measureFormat,
	                            measure: value,
	                            highlightMeasure: highlightValue,
	                            index: measureIndex,
	                            label: measureLabel,
	                            categoryLabel: measureLabel,
	                            color: color
	                        };
	                        dataPoints.push(dataPoint);
	                        this.legendDataPoints.push({
	                            label: dataPoint.label,
	                            color: dataPoint.color,
	                            icon: visuals.LegendIcon.Box,
	                            identity: dataPoint.identity,
	                            selected: false
	                        });
	                    }
	                    return dataPoints;
	                };
	                DonutChartConverter.prototype.convertSeries = function () {
	                    var reader = this.reader;
	                    var dataViewCategorical = this.dataViewCategorical;
	                    var dataPoints = [];
	                    var formatStringProp = visuals.donutChartProps.general.formatString;
	                    for (var seriesIndex = 0; seriesIndex < this.seriesCount; seriesIndex++) {
	                        var value = reader.getValue("Y", 0, seriesIndex);
	                        var highlightValue = this.hasHighlights ? reader.getHighlight("Y", 0, seriesIndex) : undefined;
	                        var valueColumn = reader.getValueColumn("Y", seriesIndex);
	                        var seriesFormat = visuals.valueFormatter.getFormatString(valueColumn.source, formatStringProp, true);
	                        var label = visuals.converterHelper.getFormattedLegendLabel(valueColumn.source, dataViewCategorical.values, formatStringProp);
	                        var identity = new visuals.SelectionIdBuilder()
	                            .withSeries(dataViewCategorical.values, valueColumn)
	                            .withMeasure(valueColumn.source.queryName)
	                            .createSelectionId();
	                        var seriesName = visuals.converterHelper.getSeriesName(valueColumn.source);
	                        var objects = reader.getSeriesObjects(seriesIndex);
	                        var color = this.colorHelper.getColorForSeriesValue(objects, dataViewCategorical.values.identityFields, seriesName);
	                        var dataPoint = {
	                            identity: identity,
	                            measureFormat: seriesFormat,
	                            measure: value,
	                            highlightMeasure: highlightValue,
	                            index: seriesIndex,
	                            label: label,
	                            categoryLabel: label,
	                            color: color,
	                            seriesIndex: seriesIndex
	                        };
	                        dataPoints.push(dataPoint);
	                        this.legendDataPoints.push({
	                            label: dataPoint.label,
	                            color: dataPoint.color,
	                            icon: visuals.LegendIcon.Box,
	                            identity: dataPoint.identity,
	                            selected: false
	                        });
	                    }
	                    return dataPoints;
	                };
	                DonutChartConverter.prototype.convertDataLabelSettings = function () {
	                    var dataViewMetadata = this.dataViewMetadata;
	                    var dataLabelsSettings = visuals.dataLabelUtils.getDefaultDonutLabelSettings();
	                    if (dataViewMetadata) {
	                        var objects = dataViewMetadata.objects;
	                        if (objects) {
	                            // Handle lables settings
	                            var labelsObj = objects['labels'];
	                            if (labelsObj) {
	                                visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, dataLabelsSettings);
	                            }
	                        }
	                    }
	                    return dataLabelsSettings;
	                };
	                DonutChartConverter.prototype.convertLegendData = function () {
	                    return {
	                        dataPoints: this.legendDataPoints,
	                        labelColor: visuals.LegendData.DefaultLegendLabelFillColor,
	                        title: this.getLegendTitle(),
	                        fontSize: visuals.SVGLegend.DefaultFontSizeInPt,
	                    };
	                };
	                return DonutChartConverter;
	            }());
	            DonutChartConversion.DonutChartConverter = DonutChartConverter;
	        })(DonutChartConversion || (DonutChartConversion = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 285 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var ScriptVisual = (function () {
	            function ScriptVisual(options) {
	                this.canRefresh = options.canRefresh;
	            }
	            ScriptVisual.prototype.init = function (options) {
	                this.element = options.element;
	                this.hostServices = options.host;
	                if (!this.canRefresh) {
	                    this.hostServices.setWarnings([new visuals.ScriptVisualRefreshWarning()]);
	                }
	            };
	            ScriptVisual.prototype.update = function (options) {
	                debug.assertValue(options, 'options');
	                var dataViews = options.dataViews;
	                if (!dataViews || dataViews.length === 0)
	                    return;
	                var dataView = dataViews[0];
	                if (!dataView || !dataView.metadata)
	                    return;
	                var imageUrl = null;
	                if (dataView.scriptResult && dataView.scriptResult.imageBase64) {
	                    imageUrl = "data:image/png;base64," + dataView.scriptResult.imageBase64;
	                }
	                this.ensureHtmlElement();
	                var img = this.ensureImageElement();
	                if (imageUrl) {
	                    img.attr("src", imageUrl);
	                }
	                else {
	                    img.removeAttr("src");
	                }
	                this.onResizing(options.viewport, options.resizeMode || 2 /* Resized */);
	            };
	            ScriptVisual.prototype.onResizing = function (finalViewport, resizeMode) {
	                var div = this.ensureHtmlElement();
	                div.css({ height: finalViewport.height, width: finalViewport.width });
	            };
	            ScriptVisual.prototype.ensureHtmlElement = function () {
	                var div = this.imageBackgroundElement;
	                if (!div) {
	                    div = $("<div class='autoScaleImageContainer'/>");
	                    this.imageBackgroundElement = div;
	                    this.imageBackgroundElement.appendTo(this.element);
	                }
	                return div;
	            };
	            ScriptVisual.prototype.ensureImageElement = function () {
	                var img = this.imageElement;
	                if (!img) {
	                    img = $("<img class='autoScaleImage'/>");
	                    this.imageElement = img;
	                    this.imageElement.appendTo(this.imageBackgroundElement);
	                }
	                return img;
	            };
	            return ScriptVisual;
	        }());
	        visuals.ScriptVisual = ScriptVisual;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 286 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var system;
	        (function (system) {
	            var DebugVisual = (function () {
	                function DebugVisual() {
	                }
	                DebugVisual.prototype.reloadAdapter = function (auto) {
	                    var _this = this;
	                    if (auto === void 0) { auto = false; }
	                    if (this.dataViewShowing) {
	                        if (auto) {
	                            return;
	                        }
	                        this.toggleDataview(false);
	                    }
	                    var developerMode = powerbi.localStorageService.getData('DEVELOPER_MODE_ENABLED');
	                    if (!developerMode) {
	                        this.toggleAutoReload(false);
	                        var errorMessage = this.buildErrorMessage({
	                            message: this.host.getLocalizedString('DebugVisual_Enabled_Error_Message'),
	                            moreMessage: this.host.getLocalizedString('DebugVisual_Enabled_Error_Learn_More'),
	                            moreLinkHref: "https://aka.ms/powerbideveloperenablederror",
	                            moreLinkText: this.host.getLocalizedString('DebugVisual_Enabled_Error_Learn_More_Link'),
	                            type: 'blockedsite'
	                        });
	                        this.container.html(errorMessage);
	                        this.setCapabilities();
	                        return;
	                    }
	                    var baseUrl = powerbi.localStorageService.getData('DEVELOPMENT_SERVER_URL') || 'https://localhost:8080/assets/';
	                    if (this.statusLoading) {
	                        return;
	                    }
	                    this.statusLoading = true;
	                    $.get(baseUrl + 'status').done(function (status) {
	                        if (!status) {
	                            return;
	                        }
	                        if (auto && _this.lastUpdateStatus === status) {
	                            return;
	                        }
	                        _this.lastUpdateStatus = status;
	                        if (status === 'error') {
	                            var errorMessage = _this.buildErrorMessage({
	                                message: _this.host.getLocalizedString('DebugVisual_Compile_Error_Message'),
	                                moreMessage: _this.host.getLocalizedString('DebugVisual_Compile_Error_Learn_More'),
	                                moreLinkHref: "https://aka.ms/powerbideveloperpbivizcompileerror",
	                                moreLinkText: _this.host.getLocalizedString('DebugVisual_Compile_Error_Learn_More_Link'),
	                                type: 'repair'
	                            });
	                            _this.container.html(errorMessage);
	                            _this.setCapabilities();
	                            return;
	                        }
	                        $.getJSON(baseUrl + 'pbiviz.json').done(function (pbivizJson) {
	                            debug.assertValue(pbivizJson.capabilities, "DebugVisual - pbiviz capabilities missing");
	                            debug.assertValue(pbivizJson.visual && pbivizJson.visual.guid, "DebugVisual - pbiviz visual guid missing");
	                            if (!pbivizJson.capabilities || !pbivizJson.visual || !pbivizJson.visual.guid) {
	                                return;
	                            }
	                            //update guid if needed
	                            if (_this.visualGuid !== pbivizJson.visual.guid) {
	                                _this.visualGuid = pbivizJson.visual.guid;
	                            }
	                            //loaded separately for sourcemap support
	                            $.getScript(baseUrl + 'visual.js').done(function () {
	                                debug.assertValue(visuals.plugins[_this.visualGuid], "DebugVisual - Plugin not found");
	                                if (!visuals.plugins[_this.visualGuid]) {
	                                    return;
	                                }
	                                //attach json capabilities to plugin
	                                visuals.plugins[_this.visualGuid].capabilities = pbivizJson.capabilities;
	                                //translate plugin
	                                powerbi.extensibility.translateVisualPlugin(visuals.plugins[_this.visualGuid]);
	                                //loaded separately for sourcemap support
	                                $.get(baseUrl + 'visual.css').done(function (data) {
	                                    $('#css-DEBUG').remove();
	                                    $("<style/>", {
	                                        id: 'css-DEBUG',
	                                        html: data,
	                                    }).appendTo($('head'));
	                                    _this.loadVisual(_this.visualGuid);
	                                    //override debugVisual capabilities with user's
	                                    _this.setCapabilities(visuals.plugins[_this.visualGuid].capabilities);
	                                });
	                            });
	                        });
	                    }).fail(function () {
	                        _this.toggleAutoReload(false);
	                        var errorMessage = _this.buildErrorMessage({
	                            message: _this.host.getLocalizedString('DebugVisual_Server_Error_Message'),
	                            moreMessage: _this.host.getLocalizedString('DebugVisual_Server_Error_Learn_More'),
	                            moreLinkHref: "https://aka.ms/powerbideveloperpbivizservererror",
	                            moreLinkText: _this.host.getLocalizedString('DebugVisual_Server_Error_Learn_More_Link'),
	                            type: 'error'
	                        });
	                        _this.container.html(errorMessage);
	                        _this.setCapabilities();
	                    }).always(function () {
	                        _this.statusLoading = false;
	                    });
	                };
	                DebugVisual.prototype.loadVisual = function (guid) {
	                    this.visualContainer.attr('class', 'visual-' + guid);
	                    this.visualContainer.empty();
	                    this.container.empty().append(this.visualContainer);
	                    var adapter = this.adapter = powerbi.extensibility.createVisualAdapter(visuals.plugins[guid]);
	                    if (adapter.init) {
	                        adapter.init(this.optionsForVisual);
	                    }
	                    if (adapter.update && this.lastUpdateOptions) {
	                        var lastUpdateOptions = powerbi.Prototype.inherit(this.lastUpdateOptions);
	                        lastUpdateOptions.type = powerbi.VisualUpdateType.All;
	                        adapter.update(lastUpdateOptions);
	                    }
	                };
	                /**
	                 * Toggles auto reload
	                 * if value is set it sets it to true = on / false = off
	                 */
	                DebugVisual.prototype.toggleAutoReload = function (value) {
	                    var _this = this;
	                    if (this.autoReloadInterval && value !== true) {
	                        this.autoRefreshBtn.addClass('pbi-glyph-play');
	                        this.autoRefreshBtn.removeClass('pbi-glyph-stop');
	                        this.refreshBtn.show();
	                        clearInterval(this.autoReloadInterval);
	                        this.autoReloadInterval = undefined;
	                    }
	                    else if (!this.autoReloadInterval && value !== false) {
	                        this.autoRefreshBtn.removeClass('pbi-glyph-play');
	                        this.autoRefreshBtn.addClass('pbi-glyph-stop');
	                        this.refreshBtn.hide();
	                        this.autoReloadInterval = setInterval(function () { return _this.reloadAdapter(true); }, DebugVisual.autoReloadPollTime);
	                    }
	                };
	                /**
	                 * Toggles dataViewer
	                 * if value is set it sets it to true = on / false = off
	                 */
	                DebugVisual.prototype.toggleDataview = function (value) {
	                    if (this.dataViewShowing && value !== true) {
	                        this.dataViewShowing = false;
	                        this.dataBtn.toggleClass('active', false);
	                        this.reloadAdapter();
	                    }
	                    else if (!this.dataViewShowing && value !== false) {
	                        this.dataViewShowing = true;
	                        this.dataBtn.toggleClass('active', true);
	                        this.loadVisual('dataViewer');
	                    }
	                };
	                DebugVisual.prototype.createRefreshBtn = function () {
	                    var _this = this;
	                    var label = this.host.getLocalizedString('DebugVisual_Reload_Visual_Button_Title');
	                    var refreshBtn = this.refreshBtn = $("<i title=\"" + label + "\" class=\"controlBtn glyphicon pbi-glyph-refresh\"></i>");
	                    refreshBtn.on('click', function () { return _this.reloadAdapter(); });
	                    return refreshBtn;
	                };
	                DebugVisual.prototype.createAutoRefreshBtn = function () {
	                    var _this = this;
	                    var label = this.host.getLocalizedString('DebugVisual_Toggle_Auto_Reload_Button_Title');
	                    var autoRefreshBtn = this.autoRefreshBtn = $("<i title=\"" + label + "\" class=\"controlBtn glyphicon pbi-glyph-play\"></i>");
	                    autoRefreshBtn.on('click', function () { return _this.toggleAutoReload(); });
	                    return autoRefreshBtn;
	                };
	                DebugVisual.prototype.createDataBtn = function () {
	                    var _this = this;
	                    var label = this.host.getLocalizedString('DebugVisual_Show_Dataview_Button_Title');
	                    var dataBtn = this.dataBtn = $("<i title=\"" + label + "\" class=\"controlBtn glyphicon pbi-glyph-seedata\"></i>");
	                    dataBtn.on('click', function () { return _this.toggleDataview(); });
	                    return dataBtn;
	                };
	                DebugVisual.prototype.createHelpBtn = function () {
	                    var label = this.host.getLocalizedString('DebugVisual_Help_Button_Title');
	                    var helpBtn = $("<a href=\"https://aka.ms/powerbideveloperhelp\" target=\"_blank\"><i title=\"" + label + "\" class=\"controlBtn glyphicon pbi-glyph-question\"></i></a>");
	                    return helpBtn;
	                };
	                DebugVisual.prototype.createSmilyBtn = function () {
	                    var label = this.host.getLocalizedString('DebugVisual_Feedback_Button_Title');
	                    var smilyBtn = $("<a href=\"https://aka.ms/powerbideveloperfeedback\" target=\"_blank\"><i title=\"" + label + "\" class=\"controlBtn glyphicon pbi-glyph-smiley\"></i></a>");
	                    return smilyBtn;
	                };
	                DebugVisual.prototype.buildControls = function () {
	                    var controlsContainer = $('<div class="debugVisual-controlsContainer"></div>');
	                    controlsContainer
	                        .append(this.createRefreshBtn(), this.createAutoRefreshBtn(), this.createDataBtn(), this.createHelpBtn(), this.createSmilyBtn());
	                    return controlsContainer;
	                };
	                DebugVisual.prototype.buildErrorMessage = function (options) {
	                    return _.template(DebugVisual.errorMessageTemplate)(options);
	                };
	                DebugVisual.prototype.setCapabilities = function (capabilities) {
	                    if (capabilities === void 0) { capabilities = DebugVisual.defaultCapabilities; }
	                    if (_.isEqual(capabilities, visuals.plugins.debugVisual.capabilities))
	                        return;
	                    visuals.plugins.debugVisual.capabilities = capabilities;
	                    this.host.visualCapabilitiesChanged();
	                };
	                DebugVisual.prototype.init = function (options) {
	                    this.host = options.host;
	                    var container = this.container = $('<div class="debugVisualContainer"></div>');
	                    var visualContainer = this.visualContainer = $('<div class="visual"></div>');
	                    this.dataViewShowing = false;
	                    container.append(visualContainer);
	                    options.element.append(container);
	                    var optionsForVisual = this.optionsForVisual = powerbi.Prototype.inherit(options);
	                    optionsForVisual.element = visualContainer;
	                    this.host.setToolbar(this.buildControls());
	                    this.reloadAdapter();
	                };
	                DebugVisual.prototype.update = function (options) {
	                    var visualOptions = this.lastUpdateOptions = powerbi.Prototype.inherit(options);
	                    var height = options.viewport.height;
	                    var width = options.viewport.width;
	                    this.visualContainer
	                        .height(height)
	                        .width(width);
	                    if (this.adapter && this.adapter.update) {
	                        this.adapter.update(visualOptions);
	                    }
	                };
	                DebugVisual.prototype.enumerateObjectInstances = function (options) {
	                    if (this.adapter && this.adapter.enumerateObjectInstances) {
	                        return this.adapter.enumerateObjectInstances(options);
	                    }
	                    return [];
	                };
	                DebugVisual.prototype.destroy = function () {
	                    if (this.adapter && this.adapter.destroy) {
	                        this.adapter.destroy();
	                    }
	                    ;
	                    this.toggleAutoReload(false);
	                    this.container = null;
	                    this.visualContainer = null;
	                    this.host.setToolbar(null);
	                };
	                DebugVisual.defaultCapabilities = {
	                    dataRoles: [
	                        {
	                            displayName: 'Values',
	                            name: 'Values',
	                            kind: powerbi.VisualDataRoleKind.Measure
	                        },
	                    ],
	                    dataViewMappings: [
	                        {
	                            table: {
	                                rows: {
	                                    for: { in: 'Values' }
	                                }
	                            },
	                        }
	                    ],
	                };
	                DebugVisual.capabilities = DebugVisual.defaultCapabilities;
	                DebugVisual.autoReloadPollTime = 300;
	                DebugVisual.errorMessageTemplate = "\n            <div class=\"errorContainer\">\n                <div class=\"errorMessage\">\n                    <div ng-switch=\"$ctrl.errorInfo.overlayType\">\n                        <div class=\"glyphicon pbi-glyph-<%= type %> glyph-med\"></div>\n                    </div>\n                    <div>\n                        <div class=\"errorSpan\"><%= message %></div>\n                        <span class=\"errorSeeMore\"><%= moreMessage %></span>\n                        <a class=\"errorSeeMore\" href=\"<%= moreLinkHref %>\" target=\"_blank\"><%= moreLinkText %></a>\n                    </div>\n                </div>\n            </div>\n        ";
	                return DebugVisual;
	            }());
	            system.DebugVisual = DebugVisual;
	        })(system = visuals.system || (visuals.system = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 287 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="./_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var plugins;
	        (function (plugins) {
	            // This file registers the built-in visualizations
	            plugins.animatedNumber = {
	                name: 'animatedNumber',
	                capabilities: visuals.capabilities.animatedNumber,
	                create: function () { return new visuals.AnimatedNumber(); }
	            };
	            plugins.areaChart = {
	                name: 'areaChart',
	                watermarkKey: 'area',
	                capabilities: visuals.capabilities.lineChart,
	                create: function () { return new visuals.CartesianChart({ chartType: 1 /* Area */ }); },
	                customizeQuery: visuals.LineChart.customizeQuery,
	                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
	                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
	            };
	            plugins.barChart = {
	                name: 'barChart',
	                watermarkKey: 'bar',
	                capabilities: visuals.capabilities.barChart,
	                create: function () { return new visuals.CartesianChart({ chartType: 6 /* StackedBar */ }); },
	                customizeQuery: visuals.ColumnChart.customizeQuery,
	                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
	                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
	            };
	            plugins.basicShape = {
	                name: 'basicShape',
	                capabilities: visuals.basicShapeCapabilities,
	                create: function () { return new visuals.BasicShapeVisual(); }
	            };
	            plugins.card = {
	                name: 'card',
	                watermarkKey: 'card',
	                capabilities: visuals.capabilities.card,
	                create: function () { return new visuals.Card(); }
	            };
	            plugins.multiRowCard = {
	                name: 'multiRowCard',
	                watermarkKey: 'multiRowCard',
	                capabilities: visuals.capabilities.multiRowCard,
	                create: function () { return new visuals.MultiRowCard(); },
	                getSortableRoles: function (visualSortableOptions) { return visuals.MultiRowCard.getSortableRoles(visualSortableOptions); },
	            };
	            plugins.clusteredBarChart = {
	                name: 'clusteredBarChart',
	                watermarkKey: 'clusteredBar',
	                capabilities: visuals.capabilities.clusteredBarChart,
	                create: function () { return new visuals.CartesianChart({ chartType: 5 /* ClusteredBar */ }); },
	                customizeQuery: visuals.ColumnChart.customizeQuery,
	                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
	                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
	            };
	            plugins.clusteredColumnChart = {
	                name: 'clusteredColumnChart',
	                watermarkKey: 'clusteredColumn',
	                capabilities: visuals.capabilities.clusteredColumnChart,
	                create: function () { return new visuals.CartesianChart({ chartType: 3 /* ClusteredColumn */ }); },
	                customizeQuery: visuals.ColumnChart.customizeQuery,
	                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
	                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
	            };
	            plugins.columnChart = {
	                name: 'columnChart',
	                watermarkKey: 'column',
	                capabilities: visuals.capabilities.columnChart,
	                create: function () { return new visuals.CartesianChart({ chartType: 4 /* StackedColumn */ }); },
	                customizeQuery: visuals.ColumnChart.customizeQuery,
	                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
	                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
	            };
	            plugins.comboChart = {
	                name: 'comboChart',
	                watermarkKey: 'combo',
	                capabilities: visuals.capabilities.comboChart,
	                customizeQuery: visuals.ComboChart.customizeQuery,
	                create: function () { return new visuals.CartesianChart({ chartType: 10 /* ComboChart */ }); },
	                getSortableRoles: function (visualSortableOptions) { return visuals.ComboChart.getSortableRoles(visualSortableOptions); },
	                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
	            };
	            plugins.dataDotChart = {
	                name: 'dataDotChart',
	                capabilities: visuals.capabilities.dataDotChart,
	                create: function () { return new visuals.CartesianChart({ chartType: 11 /* DataDot */ }); },
	                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
	            };
	            plugins.dataDotClusteredColumnComboChart = {
	                name: 'dataDotClusteredColumnComboChart',
	                watermarkKey: 'combo',
	                capabilities: visuals.capabilities.dataDotClusteredColumnComboChart,
	                customizeQuery: visuals.ComboChart.customizeQuery,
	                create: function () { return new visuals.CartesianChart({ chartType: 15 /* DataDotClusteredColumnCombo */ }); },
	                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
	            };
	            plugins.dataDotStackedColumnComboChart = {
	                name: 'dataDotStackedColumnComboChart',
	                watermarkKey: 'combo',
	                capabilities: visuals.capabilities.dataDotStackedColumnComboChart,
	                customizeQuery: visuals.ComboChart.customizeQuery,
	                create: function () { return new visuals.CartesianChart({ chartType: 16 /* DataDotStackedColumnCombo */ }); },
	                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
	            };
	            plugins.donutChart = {
	                name: 'donutChart',
	                watermarkKey: 'donut',
	                capabilities: visuals.capabilities.donutChart,
	                create: function () { return new visuals.DonutChart(); }
	            };
	            plugins.funnel = {
	                name: 'funnel',
	                watermarkKey: 'funnel',
	                capabilities: visuals.capabilities.funnel,
	                create: function () { return new visuals.FunnelChart(); }
	            };
	            plugins.gauge = {
	                name: 'gauge',
	                watermarkKey: 'gauge',
	                capabilities: visuals.capabilities.gauge,
	                create: function () { return new visuals.Gauge(); }
	            };
	            plugins.hundredPercentStackedBarChart = {
	                name: 'hundredPercentStackedBarChart',
	                watermarkKey: '100stackedbar',
	                capabilities: visuals.capabilities.hundredPercentStackedBarChart,
	                create: function () { return new visuals.CartesianChart({ chartType: 7 /* HundredPercentStackedBar */ }); },
	                customizeQuery: visuals.ColumnChart.customizeQuery,
	                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
	                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
	            };
	            plugins.hundredPercentStackedColumnChart = {
	                name: 'hundredPercentStackedColumnChart',
	                watermarkKey: '100stackedcolumn',
	                capabilities: visuals.capabilities.hundredPercentStackedColumnChart,
	                create: function () { return new visuals.CartesianChart({ chartType: 8 /* HundredPercentStackedColumn */ }); },
	                customizeQuery: visuals.ColumnChart.customizeQuery,
	                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
	                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
	            };
	            plugins.image = {
	                name: 'image',
	                capabilities: visuals.capabilities.image,
	                create: function () { return new visuals.ImageVisual(); }
	            };
	            plugins.lineChart = {
	                name: 'lineChart',
	                watermarkKey: 'line',
	                capabilities: visuals.capabilities.lineChart,
	                create: function () { return new visuals.CartesianChart({ chartType: 0 /* Line */ }); },
	                customizeQuery: visuals.LineChart.customizeQuery,
	                getSortableRoles: function (visualSortableOptions) { return visuals.LineChart.getSortableRoles(visualSortableOptions); },
	                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
	            };
	            plugins.lineStackedColumnComboChart = {
	                name: 'lineStackedColumnComboChart',
	                watermarkKey: 'combo',
	                capabilities: visuals.capabilities.lineStackedColumnComboChart,
	                customizeQuery: visuals.ComboChart.customizeQuery,
	                create: function () { return new visuals.CartesianChart({ chartType: 14 /* LineStackedColumnCombo */ }); },
	                getSortableRoles: function (visualSortableOptions) { return visuals.ComboChart.getSortableRoles(visualSortableOptions); },
	                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
	            };
	            plugins.lineClusteredColumnComboChart = {
	                name: 'lineClusteredColumnComboChart',
	                watermarkKey: 'combo',
	                capabilities: visuals.capabilities.lineClusteredColumnComboChart,
	                customizeQuery: visuals.ComboChart.customizeQuery,
	                create: function () { return new visuals.CartesianChart({ chartType: 13 /* LineClusteredColumnCombo */ }); },
	                getSortableRoles: function (visualSortableOptions) { return visuals.ComboChart.getSortableRoles(visualSortableOptions); },
	                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
	            };
	            plugins.map = {
	                name: 'map',
	                watermarkKey: 'map',
	                capabilities: visuals.capabilities.map,
	                create: function () { return new visuals.Map({ filledMap: false }); }
	            };
	            plugins.filledMap = {
	                name: 'filledMap',
	                watermarkKey: 'filledMap',
	                capabilities: visuals.capabilities.filledMap,
	                create: function () { return new visuals.Map({ filledMap: true }); }
	            };
	            plugins.treemap = {
	                name: 'treemap',
	                watermarkKey: 'tree',
	                capabilities: visuals.capabilities.treemap,
	                create: function () { return new visuals.Treemap(); }
	            };
	            plugins.pieChart = {
	                name: 'pieChart',
	                watermarkKey: 'pie',
	                capabilities: visuals.capabilities.donutChart,
	                create: function () { return new visuals.DonutChart({ sliceWidthRatio: 0 }); }
	            };
	            plugins.scatterChart = {
	                name: 'scatterChart',
	                watermarkKey: 'scatterplot',
	                capabilities: visuals.capabilities.scatterChart,
	                create: function () { return new visuals.CartesianChart({ chartType: 9 /* Scatter */ }); },
	                getAdditionalTelemetry: function (dataView) { return visuals.ScatterChart.getAdditionalTelemetry(dataView); },
	            };
	            plugins.stackedAreaChart = {
	                name: 'stackedAreaChart',
	                watermarkKey: 'stackedarea',
	                capabilities: visuals.capabilities.lineChart,
	                create: function () { return new visuals.CartesianChart({ chartType: 2 /* StackedArea */ }); },
	                customizeQuery: visuals.LineChart.customizeQuery,
	                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
	                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
	            };
	            plugins.table = {
	                name: 'table',
	                watermarkKey: 'table',
	                capabilities: visuals.capabilities.table,
	                create: function () { return new visuals.Table(); },
	                customizeQuery: visuals.Table.customizeQuery,
	                getSortableRoles: function (visualSortableOptions) { return visuals.Table.getSortableRoles(); },
	            };
	            plugins.matrix = {
	                name: 'matrix',
	                watermarkKey: 'matrix',
	                capabilities: visuals.capabilities.matrix,
	                create: function () { return new visuals.Matrix(); },
	                customizeQuery: visuals.Matrix.customizeQuery,
	                getSortableRoles: function (visualSortableOptions) { return visuals.Matrix.getSortableRoles(); },
	            };
	            plugins.slicer = {
	                name: 'slicer',
	                watermarkKey: 'slicer',
	                capabilities: visuals.capabilities.slicer,
	                create: function () { return new visuals.Slicer(); }
	            };
	            plugins.textbox = {
	                name: 'textbox',
	                capabilities: visuals.capabilities.textbox,
	                create: function () { return new visuals.Textbox(); }
	            };
	            plugins.waterfallChart = {
	                name: 'waterfallChart',
	                watermarkKey: 'waterfall',
	                capabilities: visuals.capabilities.waterfallChart,
	                create: function () { return new visuals.CartesianChart({ chartType: 12 /* Waterfall */ }); },
	                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
	            };
	            plugins.cheerMeter = {
	                name: 'cheerMeter',
	                capabilities: visuals.CheerMeter.capabilities,
	                create: function () { return new visuals.CheerMeter(); }
	            };
	            plugins.consoleWriter = {
	                name: 'consoleWriter',
	                capabilities: visuals.samples.consoleWriterCapabilities,
	                create: function () { return new visuals.samples.ConsoleWriter(); }
	            };
	            plugins.helloIVisual = {
	                name: 'helloIVisual',
	                capabilities: visuals.samples.HelloIVisual.capabilities,
	                create: function () { return new visuals.samples.HelloIVisual(); }
	            };
	            plugins.owlGauge = {
	                name: 'owlGauge',
	                watermarkKey: 'gauge',
	                capabilities: visuals.OwlGauge.capabilities,
	                create: function () { return new visuals.OwlGauge(); }
	            };
	            plugins.scriptVisual = {
	                name: 'scriptVisual',
	                watermarkKey: 'scriptvisual',
	                capabilities: visuals.capabilities.scriptVisual,
	                create: function () { return new visuals.ScriptVisual({ canRefresh: false }); }
	            };
	            plugins.kpi = {
	                name: 'kpi',
	                watermarkKey: 'kpi',
	                capabilities: visuals.capabilities.kpi,
	                create: function () { return new visuals.KPIStatusWithHistory(); }
	            };
	            plugins.debugVisual = {
	                name: 'debugVisual',
	                // TODO: Create new watermark (waiting on design)
	                watermarkKey: 'kpi',
	                capabilities: visuals.system.DebugVisual.capabilities,
	                create: function () { return new visuals.system.DebugVisual(); }
	            };
	        })(plugins = visuals.plugins || (visuals.plugins = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 288 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var CanvasBackgroundHelper;
	        (function (CanvasBackgroundHelper) {
	            function getDefaultColor() {
	                return '#FFFFFF';
	            }
	            CanvasBackgroundHelper.getDefaultColor = getDefaultColor;
	            function getDefaultValues() {
	                return {
	                    color: getDefaultColor(),
	                };
	            }
	            CanvasBackgroundHelper.getDefaultValues = getDefaultValues;
	        })(CanvasBackgroundHelper = visuals.CanvasBackgroundHelper || (visuals.CanvasBackgroundHelper = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 289 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var defaultMaxValue = 100;
	        /**
	         * Implements IRange interface for the Date type.
	         */
	        var DateRange = (function () {
	            function DateRange(min, max, start, end) {
	                debug.assert(max > min, "Requires max date to be bigger than min date.");
	                debug.assert((!start || start >= min) && (!end || end <= max), "Specified date is out of boundaries");
	                var interval = d3.time.day;
	                this.scale = d3.time.scale()
	                    .domain([min, max])
	                    .range([0, defaultMaxValue])
	                    .nice(interval);
	                this.value = {
	                    min: start || min,
	                    max: end || max
	                };
	                this.setValue(this.value);
	            }
	            DateRange.prototype.getScaledValue = function () {
	                return this.scaledValue;
	            };
	            DateRange.prototype.setValue = function (original) {
	                debug.assert(original != null, "Value can't be null");
	                debug.assert(original.min != null, "Min can't be null");
	                debug.assert(original.max != null, "Max can't be null");
	                this.value = original;
	                this.scaledValue = {
	                    min: this.scale(original.min),
	                    max: this.scale(original.max)
	                };
	            };
	            DateRange.prototype.getValue = function () {
	                return this.value;
	            };
	            /**
	             * Updates scaled value.
	             * Value should in range [0 .. 100].
	             */
	            DateRange.prototype.setScaledValue = function (value) {
	                debug.assert(value.min <= 100 && value.min >= 0 &&
	                    value.max >= 0 && value.max <= 100 && value.max >= value.min, "Value is out of range");
	                this.scaledValue = value;
	                this.value = {
	                    min: this.scale.invert(value.min),
	                    max: this.scale.invert(value.max)
	                };
	            };
	            return DateRange;
	        }());
	        visuals.DateRange = DateRange;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 290 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var TablixObjects = visuals.controls.internal.TablixObjects;
	        var Color = jsCommon.Color;
	        var SQExprBuilder = powerbi.data.SQExprBuilder;
	        var valueOrDefault = jsCommon.Utility.valueOrDefault;
	        var createSolidFillDefinition = powerbi.FillDefinitionHelpers.createSolidFillDefinition;
	        // Default for values common to most presets to avoid repeating declaring them
	        var defaultOutlineWeight = TablixObjects.PropGridOutlineWeight.defaultValue;
	        var defaultGridlineHorizontalWeight = TablixObjects.PropGridHorizontalWeight.defaultValue;
	        var defaultGridlineVerticalWeight = TablixObjects.PropGridVerticalWeight.defaultValue;
	        var defaultColumnsOutline = TablixObjects.PropColumnsOutline.defaultValue;
	        var defaultValuesOutline = TablixObjects.PropValuesOutline.defaultValue;
	        var defaultTotalOutline = TablixObjects.PropTotalOutline.defaultValue;
	        var rowPaddingCondensed = 0;
	        var rowPaddingNormal = 3;
	        var rowPaddingSparse = 6;
	        function wrapFormattingElements(elements) {
	            return {
	                grid: [{
	                        properties: {
	                            outlineColor: createSolidFillDefinition(elements.grid.outlineColor),
	                            outlineWeight: SQExprBuilder.integer(valueOrDefault(elements.grid.outlineWeight, defaultOutlineWeight)),
	                            gridVertical: SQExprBuilder.boolean(elements.grid.gridVertical),
	                            gridVerticalColor: createSolidFillDefinition(elements.grid.gridVerticalColor),
	                            gridVerticalWeight: SQExprBuilder.integer(valueOrDefault(elements.grid.gridVerticalWeight, defaultGridlineVerticalWeight)),
	                            gridHorizontal: SQExprBuilder.boolean(elements.grid.gridHorizontal),
	                            gridHorizontalColor: createSolidFillDefinition(elements.grid.gridHorizontalColor),
	                            gridHorizontalWeight: SQExprBuilder.integer(valueOrDefault(elements.grid.gridHorizontalWeight, defaultGridlineHorizontalWeight)),
	                            rowPadding: SQExprBuilder.integer(elements.grid.rowPadding),
	                        },
	                    }],
	                columnHeaders: [{
	                        properties: {
	                            outline: SQExprBuilder.text(elements.columnHeaders.outline),
	                            fontColor: createSolidFillDefinition(elements.columnHeaders.fontColor),
	                            backColor: createSolidFillDefinition(elements.columnHeaders.backColor),
	                        }
	                    }],
	                values: [{
	                        properties: {
	                            outline: SQExprBuilder.text(elements.values.outline),
	                            fontColorPrimary: createSolidFillDefinition(elements.values.fontColorPrimary),
	                            backColorPrimary: createSolidFillDefinition(elements.values.backColorPrimary),
	                            fontColorSecondary: createSolidFillDefinition(elements.values.fontColorSecondary),
	                            backColorSecondary: createSolidFillDefinition(elements.values.backColorSecondary),
	                        }
	                    }],
	                total: [{
	                        properties: {
	                            outline: SQExprBuilder.text(elements.total.outline),
	                            fontColor: createSolidFillDefinition(elements.total.fontColor),
	                            backColor: createSolidFillDefinition(elements.total.backColor),
	                        }
	                    }],
	            };
	        }
	        function tableStylePresets() {
	            return {
	                sectionTitle: powerbi.data.createDisplayNameGetter('Visual_Table_StylePreset_SectionTitle'),
	                sliceTitle: powerbi.data.createDisplayNameGetter('Visual_Table_StylePreset_SliceTitle'),
	                defaultPresetName: "None",
	                presets: {
	                    None: {
	                        name: "None",
	                        displayName: powerbi.data.createDisplayNameGetter('Visual_Table_StylePreset_None'),
	                        evaluate: function (theme) {
	                            return wrapFormattingElements({
	                                grid: {
	                                    outlineColor: TablixObjects.PropGridOutlineColor.defaultValue,
	                                    gridVertical: TablixObjects.PropGridVertical.defaultValue,
	                                    gridVerticalColor: TablixObjects.PropGridVerticalColor.defaultValue,
	                                    gridHorizontal: TablixObjects.PropGridHorizontalTable.defaultValue,
	                                    gridHorizontalColor: TablixObjects.PropGridHorizontalColor.defaultValue,
	                                    rowPadding: TablixObjects.PropGridRowPadding.defaultValue,
	                                },
	                                columnHeaders: {
	                                    outline: defaultColumnsOutline,
	                                    fontColor: TablixObjects.PropColumnsFontColor.defaultValue,
	                                    backColor: TablixObjects.PropColumnsBackColor.defaultValue,
	                                },
	                                values: {
	                                    outline: defaultValuesOutline,
	                                    fontColorPrimary: TablixObjects.PropValuesFontColorPrimary.defaultValue,
	                                    backColorPrimary: TablixObjects.PropValuesBackColorPrimary.defaultValue,
	                                    fontColorSecondary: TablixObjects.PropValuesFontColorSecondary.defaultValue,
	                                    backColorSecondary: TablixObjects.PropValuesBackColorSecondary.defaultValue,
	                                },
	                                total: {
	                                    outline: defaultTotalOutline,
	                                    fontColor: TablixObjects.PropTotalFontColor.defaultValue,
	                                    backColor: TablixObjects.PropTotalBackColor.defaultValue,
	                                },
	                            });
	                        }
	                    },
	                    Minimal: {
	                        name: "Minimal",
	                        displayName: powerbi.data.createDisplayNameGetter('Visual_Table_StylePreset_Minimal'),
	                        evaluate: function (theme) {
	                            var backColor = theme.colorPalette.background.value;
	                            var foreColor = theme.colorPalette.foreground.value;
	                            var outlineColor = theme.colorPalette.tableAccent.value;
	                            var gridColor = Color.hexBlend(foreColor, 0.12, backColor);
	                            return wrapFormattingElements({
	                                grid: {
	                                    outlineColor: outlineColor,
	                                    gridVertical: false,
	                                    gridVerticalColor: gridColor,
	                                    gridVerticalWeight: defaultGridlineVerticalWeight,
	                                    gridHorizontal: true,
	                                    gridHorizontalColor: gridColor,
	                                    gridHorizontalWeight: defaultGridlineHorizontalWeight,
	                                    rowPadding: rowPaddingNormal,
	                                },
	                                columnHeaders: {
	                                    outline: defaultColumnsOutline,
	                                    fontColor: foreColor,
	                                    backColor: backColor,
	                                },
	                                values: {
	                                    outline: defaultValuesOutline,
	                                    fontColorPrimary: foreColor,
	                                    backColorPrimary: backColor,
	                                    fontColorSecondary: foreColor,
	                                    backColorSecondary: backColor,
	                                },
	                                total: {
	                                    outline: defaultTotalOutline,
	                                    fontColor: foreColor,
	                                    backColor: backColor,
	                                },
	                            });
	                        },
	                    },
	                    BoldHeader: {
	                        name: "BoldHeader",
	                        displayName: powerbi.data.createDisplayNameGetter('Visual_Table_StylePreset_BoldHeader'),
	                        evaluate: function (theme) {
	                            var backColor = theme.colorPalette.background.value;
	                            var foreColor = theme.colorPalette.foreground.value;
	                            var accent = theme.colorPalette.tableAccent.value;
	                            var gridColor = Color.hexBlend(foreColor, 0.12, backColor);
	                            return wrapFormattingElements({
	                                grid: {
	                                    outlineColor: accent,
	                                    gridVertical: false,
	                                    gridVerticalColor: gridColor,
	                                    gridVerticalWeight: defaultGridlineVerticalWeight,
	                                    gridHorizontal: true,
	                                    gridHorizontalColor: gridColor,
	                                    gridHorizontalWeight: defaultGridlineHorizontalWeight,
	                                    rowPadding: rowPaddingNormal,
	                                },
	                                columnHeaders: {
	                                    outline: defaultColumnsOutline,
	                                    fontColor: backColor,
	                                    backColor: foreColor,
	                                },
	                                values: {
	                                    outline: defaultValuesOutline,
	                                    fontColorPrimary: foreColor,
	                                    backColorPrimary: backColor,
	                                    fontColorSecondary: foreColor,
	                                    backColorSecondary: backColor,
	                                },
	                                total: {
	                                    outline: defaultTotalOutline,
	                                    fontColor: foreColor,
	                                    backColor: backColor,
	                                },
	                            });
	                        },
	                    },
	                    AlternatingRows: {
	                        name: "AlternatingRows",
	                        displayName: powerbi.data.createDisplayNameGetter('Visual_Table_StylePreset_AlternatingRows'),
	                        evaluate: function (theme) {
	                            var backColor = theme.colorPalette.background.value;
	                            var foreColor = theme.colorPalette.foreground.value;
	                            var accent = theme.colorPalette.tableAccent.value;
	                            var gridColor = Color.hexBlend(foreColor, 0.12, backColor);
	                            return wrapFormattingElements({
	                                grid: {
	                                    outlineColor: accent,
	                                    gridVertical: false,
	                                    gridVerticalColor: gridColor,
	                                    gridVerticalWeight: defaultGridlineVerticalWeight,
	                                    gridHorizontal: true,
	                                    gridHorizontalColor: gridColor,
	                                    gridHorizontalWeight: defaultGridlineHorizontalWeight,
	                                    rowPadding: rowPaddingNormal,
	                                },
	                                columnHeaders: {
	                                    outline: defaultColumnsOutline,
	                                    fontColor: backColor,
	                                    backColor: foreColor,
	                                },
	                                values: {
	                                    outline: defaultValuesOutline,
	                                    fontColorPrimary: foreColor,
	                                    backColorPrimary: backColor,
	                                    fontColorSecondary: foreColor,
	                                    backColorSecondary: Color.hexBlend(foreColor, 0.08, backColor),
	                                },
	                                total: {
	                                    outline: defaultTotalOutline,
	                                    fontColor: backColor,
	                                    backColor: foreColor,
	                                },
	                            });
	                        },
	                    },
	                    ContrastAlternatingRows: {
	                        name: "ContrastAlternatingRows",
	                        displayName: powerbi.data.createDisplayNameGetter('Visual_Table_StylePreset_ContrastAlternatingRows'),
	                        evaluate: function (theme) {
	                            var backColor = theme.colorPalette.background.value;
	                            var foreColor = theme.colorPalette.foreground.value;
	                            var accent = theme.colorPalette.tableAccent.value;
	                            var gridColor = Color.hexBlend(foreColor, 0.12, backColor);
	                            return wrapFormattingElements({
	                                grid: {
	                                    outlineColor: accent,
	                                    gridVertical: false,
	                                    gridVerticalColor: gridColor,
	                                    gridVerticalWeight: defaultGridlineVerticalWeight,
	                                    gridHorizontal: true,
	                                    gridHorizontalColor: gridColor,
	                                    gridHorizontalWeight: defaultGridlineHorizontalWeight,
	                                    rowPadding: rowPaddingNormal,
	                                },
	                                columnHeaders: {
	                                    outline: defaultColumnsOutline,
	                                    fontColor: backColor,
	                                    backColor: foreColor,
	                                },
	                                values: {
	                                    outline: defaultValuesOutline,
	                                    fontColorPrimary: backColor,
	                                    backColorPrimary: Color.hexBlend(foreColor, 0.75, backColor),
	                                    fontColorSecondary: foreColor,
	                                    backColorSecondary: Color.hexBlend(foreColor, 0.25, backColor),
	                                },
	                                total: {
	                                    outline: defaultTotalOutline,
	                                    fontColor: backColor,
	                                    backColor: foreColor,
	                                },
	                            });
	                        },
	                    },
	                    FlashyRows: {
	                        name: "FlashyRows",
	                        displayName: powerbi.data.createDisplayNameGetter('Visual_Table_StylePreset_FlashyRows'),
	                        evaluate: function (theme) {
	                            var backColor = theme.colorPalette.background.value;
	                            var foreColor = theme.colorPalette.foreground.value;
	                            var accent = theme.colorPalette.tableAccent.value;
	                            return wrapFormattingElements({
	                                grid: {
	                                    outlineColor: foreColor,
	                                    gridVertical: false,
	                                    gridVerticalColor: backColor,
	                                    gridVerticalWeight: defaultGridlineVerticalWeight,
	                                    gridHorizontal: false,
	                                    gridHorizontalColor: backColor,
	                                    gridHorizontalWeight: defaultGridlineHorizontalWeight,
	                                    rowPadding: rowPaddingNormal,
	                                },
	                                columnHeaders: {
	                                    outline: defaultColumnsOutline,
	                                    fontColor: foreColor,
	                                    backColor: backColor,
	                                },
	                                values: {
	                                    outline: defaultValuesOutline,
	                                    fontColorPrimary: foreColor,
	                                    backColorPrimary: Color.hexBlend(accent, 0.40, backColor),
	                                    fontColorSecondary: foreColor,
	                                    backColorSecondary: Color.hexBlend(accent, 0.80, backColor),
	                                },
	                                total: {
	                                    outline: defaultTotalOutline,
	                                    fontColor: foreColor,
	                                    backColor: backColor,
	                                },
	                            });
	                        },
	                    },
	                    BoldHeaderFlashyRows: {
	                        name: "BoldHeaderFlashyRows",
	                        displayName: powerbi.data.createDisplayNameGetter('Visual_Table_StylePreset_BoldHeaderFlashyRows'),
	                        evaluate: function (theme) {
	                            var backColor = theme.colorPalette.background.value;
	                            var foreColor = theme.colorPalette.foreground.value;
	                            var accent = theme.colorPalette.tableAccent.value;
	                            return wrapFormattingElements({
	                                grid: {
	                                    outlineColor: backColor,
	                                    gridVertical: false,
	                                    gridVerticalColor: foreColor,
	                                    gridVerticalWeight: defaultGridlineVerticalWeight,
	                                    gridHorizontal: false,
	                                    gridHorizontalColor: foreColor,
	                                    gridHorizontalWeight: defaultGridlineHorizontalWeight,
	                                    rowPadding: rowPaddingNormal,
	                                },
	                                columnHeaders: {
	                                    outline: defaultColumnsOutline,
	                                    fontColor: backColor,
	                                    backColor: foreColor,
	                                },
	                                values: {
	                                    outline: defaultValuesOutline,
	                                    fontColorPrimary: foreColor,
	                                    backColorPrimary: Color.hexBlend(accent, 0.40, backColor),
	                                    fontColorSecondary: foreColor,
	                                    backColorSecondary: Color.hexBlend(accent, 0.80, backColor),
	                                },
	                                total: {
	                                    outline: defaultTotalOutline,
	                                    fontColor: backColor,
	                                    backColor: foreColor,
	                                },
	                            });
	                        },
	                    },
	                    Sparse: {
	                        name: "Sparse",
	                        displayName: powerbi.data.createDisplayNameGetter('Visual_Table_StylePreset_Sparse'),
	                        evaluate: function (theme) {
	                            var backColor = theme.colorPalette.background.value;
	                            var foreColor = theme.colorPalette.foreground.value;
	                            var accent = theme.colorPalette.tableAccent.value;
	                            var gridColor = Color.hexBlend(foreColor, 0.20, backColor);
	                            return wrapFormattingElements({
	                                grid: {
	                                    outlineColor: accent,
	                                    gridVertical: false,
	                                    gridVerticalColor: gridColor,
	                                    gridVerticalWeight: defaultGridlineVerticalWeight,
	                                    gridHorizontal: false,
	                                    gridHorizontalColor: gridColor,
	                                    gridHorizontalWeight: defaultGridlineHorizontalWeight,
	                                    rowPadding: rowPaddingSparse,
	                                },
	                                columnHeaders: {
	                                    outline: defaultColumnsOutline,
	                                    fontColor: backColor,
	                                    backColor: foreColor,
	                                },
	                                values: {
	                                    outline: defaultValuesOutline,
	                                    fontColorPrimary: foreColor,
	                                    backColorPrimary: backColor,
	                                    fontColorSecondary: foreColor,
	                                    backColorSecondary: backColor,
	                                },
	                                total: {
	                                    outline: defaultTotalOutline,
	                                    fontColor: backColor,
	                                    backColor: foreColor,
	                                },
	                            });
	                        },
	                    },
	                    Condensed: {
	                        name: "Condensed",
	                        displayName: powerbi.data.createDisplayNameGetter('Visual_Table_StylePreset_Condensed'),
	                        evaluate: function (theme) {
	                            var backColor = theme.colorPalette.background.value;
	                            var foreColor = theme.colorPalette.foreground.value;
	                            var accent = theme.colorPalette.tableAccent.value;
	                            var gridColor = Color.hexBlend(foreColor, 0.20, backColor);
	                            return wrapFormattingElements({
	                                grid: {
	                                    outlineColor: accent,
	                                    gridVertical: true,
	                                    gridVerticalColor: gridColor,
	                                    gridVerticalWeight: defaultGridlineVerticalWeight,
	                                    gridHorizontal: true,
	                                    gridHorizontalColor: gridColor,
	                                    gridHorizontalWeight: defaultGridlineHorizontalWeight,
	                                    rowPadding: rowPaddingCondensed,
	                                },
	                                columnHeaders: {
	                                    outline: defaultColumnsOutline,
	                                    fontColor: backColor,
	                                    backColor: foreColor,
	                                },
	                                values: {
	                                    outline: defaultValuesOutline,
	                                    fontColorPrimary: foreColor,
	                                    backColorPrimary: backColor,
	                                    fontColorSecondary: foreColor,
	                                    backColorSecondary: backColor,
	                                },
	                                total: {
	                                    outline: defaultTotalOutline,
	                                    fontColor: backColor,
	                                    backColor: foreColor,
	                                },
	                            });
	                        },
	                    },
	                },
	            };
	        }
	        visuals.tableStylePresets = tableStylePresets;
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ }
/******/ ]);
//# sourceMappingURL=Visuals.js.map