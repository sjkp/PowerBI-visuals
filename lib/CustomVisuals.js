/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(13);


/***/ },
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/// <reference path="./_references.ts"/>
	window.jsCommon = window.jsCommon || {};
	window.powerbi = window.powerbi || {};
	window.debug = window.debug || {};
	window.InJs = window.InJs || {};
	requireAll(__webpack_require__(14));
	// Require all files from the `_references.ts`
	__webpack_require__(37);
	function requireAll(requireContext) {
	    return requireContext.keys().map(requireContext);
	}

	

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./styles/styles.less": 15,
		"./visuals/asterPlot/visual/styles/asterPlot.less": 17,
		"./visuals/bulletChart/visual/styles/bulletChart.less": 18,
		"./visuals/chicletSlicer/visual/styles/chicletSlicer.less": 19,
		"./visuals/chordChart/visual/styles/chordChart.less": 20,
		"./visuals/dotPlot/visual/styles/dotPlot.less": 21,
		"./visuals/enhancedScatterChart/visual/styles/enhancedScatterChart.less": 22,
		"./visuals/forceGraph/visual/styles/forceGraph.less": 23,
		"./visuals/gantt/visual/styles/gantt.less": 24,
		"./visuals/globeMap/visual/styles/globeMap.less": 25,
		"./visuals/histogram/visual/styles/histogram.less": 26,
		"./visuals/lineDotChart/visual/styles/lineDotChart.less": 27,
		"./visuals/mekkoChart/visual/styles/mekkoChart.less": 28,
		"./visuals/pulseChart/visual/styles/pulseChart.less": 29,
		"./visuals/radarChart/visual/styles/radarChart.less": 30,
		"./visuals/sankeyDiagram/visual/styles/sankeyDiagram.less": 31,
		"./visuals/streamGraph/visual/styles/streamGraph.less": 32,
		"./visuals/sunburst/visual/styles/sunburst.less": 33,
		"./visuals/timeline/visual/styles/timeline.less": 34,
		"./visuals/tornadoChart/visual/styles/tornadoChart.less": 35,
		"./visuals/wordCloud/visual/styles/wordCloud.less": 36
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 14;


/***/ },
/* 15 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 16 */,
/* 17 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 18 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 19 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 20 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 21 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 22 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 23 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 24 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 25 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 26 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 27 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 28 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 29 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 30 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 31 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 32 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 33 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 34 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 35 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 36 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/// <reference path="../Visuals/_references.ts"/>
	/// <reference path="../VisualsCommon/_references.ts"/>
	/// <reference path="../VisualsContracts/_references.ts"/>
	/// <reference path="../VisualsData/_references.ts"/>
	/// <reference path="../../../src/Clients/Typedefs/webpack/webpack-env.d.ts"/>
	/// <reference path="../../../src/Clients/Typedefs/common/window.d.ts"/>
	__webpack_require__(38);
	__webpack_require__(39);
	__webpack_require__(40);
	__webpack_require__(41);
	__webpack_require__(42);
	__webpack_require__(43);
	__webpack_require__(44);
	__webpack_require__(45);
	__webpack_require__(46);
	__webpack_require__(47);
	__webpack_require__(48);
	__webpack_require__(49);
	__webpack_require__(50);
	__webpack_require__(51);
	__webpack_require__(52);
	__webpack_require__(53);
	__webpack_require__(54);
	__webpack_require__(55);
	__webpack_require__(56);
	__webpack_require__(57);
	__webpack_require__(58); 



/***/ },
/* 38 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../../../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var samples;
	        (function (samples) {
	            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
	            var PixelConverter = jsCommon.PixelConverter;
	            var ValueFormatter = powerbi.visuals.valueFormatter;
	            var LegendData = powerbi.visuals.LegendData;
	            var createEnumType = powerbi.createEnumType;
	            var DataViewObjects = powerbi.DataViewObjects;
	            var ObjectEnumerationBuilder = powerbi.visuals.ObjectEnumerationBuilder;
	            var LegendPosition = powerbi.visuals.LegendPosition;
	            var dataLabelUtils = powerbi.visuals.dataLabelUtils;
	            var converterHelper = powerbi.visuals.converterHelper;
	            var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
	            var legendPosition = powerbi.visuals.legendPosition;
	            var ColorHelper = powerbi.visuals.ColorHelper;
	            var valueFormatter = powerbi.visuals.valueFormatter;
	            var TooltipBuilder = powerbi.visuals.TooltipBuilder;
	            var SelectionId = powerbi.visuals.SelectionId;
	            var LegendIcon = powerbi.visuals.LegendIcon;
	            var appendClearCatcher = powerbi.visuals.appendClearCatcher;
	            var createInteractivityService = powerbi.visuals.createInteractivityService;
	            var createLegend = powerbi.visuals.createLegend;
	            var MinervaAnimationDuration = powerbi.visuals.AnimatorCommon.MinervaAnimationDuration;
	            var SVGUtil = powerbi.visuals.SVGUtil;
	            var TooltipManager = powerbi.visuals.TooltipManager;
	            var TextMeasurementService = powerbi.TextMeasurementService;
	            var DataLabelManager = powerbi.DataLabelManager;
	            var Legend = powerbi.visuals.Legend;
	            var VisualDataRoleKind = powerbi.VisualDataRoleKind;
	            var AsterPlotVisualClassName = "asterPlot";
	            var AsterRadiusRatio = 0.9;
	            var AsterConflictRatio = 0.9;
	            var AsterPlotWebBehavior = (function () {
	                function AsterPlotWebBehavior() {
	                }
	                AsterPlotWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
	                    this.selection = options.selection;
	                    this.clearCatcher = options.clearCatcher;
	                    this.interactivityService = options.interactivityService;
	                    this.hasHighlights = options.hasHighlights;
	                    this.selection.on("click", function (d, i) {
	                        selectionHandler.handleSelection(d.data, d3.event.ctrlKey);
	                    });
	                    this.clearCatcher.on("click", function () {
	                        selectionHandler.handleClearSelection();
	                    });
	                    this.renderSelection(this.interactivityService.hasSelection());
	                };
	                AsterPlotWebBehavior.prototype.renderSelection = function (hasSelection) {
	                    var _this = this;
	                    this.selection.style("fill-opacity", function (d) {
	                        return asterPlotUtils.getFillOpacity(d.data.selected, d.data.highlight, hasSelection, _this.hasHighlights);
	                    });
	                };
	                return AsterPlotWebBehavior;
	            }());
	            var AsterPlotWarning = (function () {
	                function AsterPlotWarning(message) {
	                    this.message = message;
	                }
	                Object.defineProperty(AsterPlotWarning.prototype, "code", {
	                    get: function () {
	                        return "AsterPlotWarning";
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                AsterPlotWarning.prototype.getMessages = function (resourceProvider) {
	                    return {
	                        message: this.message,
	                        title: resourceProvider.get(""),
	                        detail: resourceProvider.get("")
	                    };
	                };
	                return AsterPlotWarning;
	            }());
	            samples.AsterPlotWarning = AsterPlotWarning;
	            var VisualLayout = (function () {
	                function VisualLayout(defaultViewport, defaultMargin) {
	                    this.defaultViewport = defaultViewport || { width: 0, height: 0 };
	                    this.defaultMargin = defaultMargin || { top: 0, bottom: 0, right: 0, left: 0 };
	                }
	                Object.defineProperty(VisualLayout.prototype, "viewport", {
	                    get: function () {
	                        return this.viewportValue || (this.viewportValue = this.defaultViewport);
	                    },
	                    set: function (value) {
	                        var _this = this;
	                        this.previousOriginalViewportValue = _.clone(this.originalViewportValue);
	                        this.originalViewportValue = _.clone(value);
	                        this.setUpdateObject(value, function (v) { return _this.viewportValue = v; }, function (o) { return VisualLayout.restrictToMinMax(o, _this.minViewport); });
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(VisualLayout.prototype, "viewportCopy", {
	                    get: function () {
	                        return _.clone(this.viewport);
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(VisualLayout.prototype, "viewportIn", {
	                    //Returns viewport minus margin
	                    get: function () {
	                        return this.viewportInValue || this.viewport;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(VisualLayout.prototype, "minViewport", {
	                    get: function () {
	                        return this.minViewportValue || { width: 0, height: 0 };
	                    },
	                    set: function (value) {
	                        var _this = this;
	                        this.setUpdateObject(value, function (v) { return _this.minViewportValue = v; }, VisualLayout.restrictToMinMax);
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(VisualLayout.prototype, "margin", {
	                    get: function () {
	                        return this.marginValue || (this.marginValue = this.defaultMargin);
	                    },
	                    set: function (value) {
	                        var _this = this;
	                        this.setUpdateObject(value, function (v) { return _this.marginValue = v; }, VisualLayout.restrictToMinMax);
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(VisualLayout.prototype, "viewportChanged", {
	                    //Returns true if viewport has updated after last change.
	                    get: function () {
	                        return !!this.originalViewportValue && (!this.previousOriginalViewportValue
	                            || this.previousOriginalViewportValue.height !== this.originalViewportValue.height
	                            || this.previousOriginalViewportValue.width !== this.originalViewportValue.width);
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(VisualLayout.prototype, "viewportInIsZero", {
	                    get: function () {
	                        return this.viewportIn.width === 0 || this.viewportIn.height === 0;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                VisualLayout.prototype.resetMargin = function () {
	                    this.margin = this.defaultMargin;
	                };
	                VisualLayout.prototype.update = function () {
	                    this.viewportInValue = VisualLayout.restrictToMinMax({
	                        width: this.viewport.width - (this.margin.left + this.margin.right),
	                        height: this.viewport.height - (this.margin.top + this.margin.bottom)
	                    }, this.minViewportValue);
	                };
	                VisualLayout.prototype.setUpdateObject = function (object, setObjectFn, beforeUpdateFn) {
	                    var _this = this;
	                    object = _.clone(object);
	                    setObjectFn(VisualLayout.createNotifyChangedObject(object, function (o) {
	                        if (beforeUpdateFn)
	                            beforeUpdateFn(object);
	                        _this.update();
	                    }));
	                    if (beforeUpdateFn)
	                        beforeUpdateFn(object);
	                    this.update();
	                };
	                VisualLayout.createNotifyChangedObject = function (object, objectChanged) {
	                    var result = {};
	                    _.keys(object).forEach(function (key) { return Object.defineProperty(result, key, {
	                        get: function () { return object[key]; },
	                        set: function (value) { object[key] = value; objectChanged(object, key); },
	                        enumerable: true,
	                        configurable: true
	                    }); });
	                    return result;
	                };
	                VisualLayout.restrictToMinMax = function (value, minValue) {
	                    _.keys(value).forEach(function (x) { return value[x] = Math.max(minValue && minValue[x] || 0, value[x]); });
	                    return value;
	                };
	                return VisualLayout;
	            }());
	            var Helpers = (function () {
	                function Helpers() {
	                }
	                Helpers.setAttrThroughTransitionIfNotResized = function (element, setTransision, attrName, attrValue, attrTransitionValue, viewportChanged) {
	                    if (viewportChanged) {
	                        element.attr(attrName, attrValue);
	                    }
	                    else {
	                        setTransision(element.transition()).attrTween(attrName, attrTransitionValue);
	                    }
	                };
	                Helpers.interpolateArc = function (arc) {
	                    return function (data) {
	                        if (!this.oldData) {
	                            this.oldData = data;
	                            return function () { return arc(data); };
	                        }
	                        var interpolation = d3.interpolate(this.oldData, data);
	                        this.oldData = interpolation(0);
	                        return function (x) { return arc(interpolation(x)); };
	                    };
	                };
	                Helpers.addContext = function (context, fn) {
	                    return function () {
	                        return fn.apply(context, [this].concat(_.toArray(arguments)));
	                    };
	                };
	                return Helpers;
	            }());
	            var AsterPlotSettings = (function () {
	                function AsterPlotSettings() {
	                    //Default Settings
	                    this.legend = {
	                        show: false,
	                        position: LegendPosition[LegendPosition.Top],
	                        showTitle: true,
	                        titleText: "",
	                        labelColor: LegendData.DefaultLegendLabelFillColor,
	                        fontSize: 8,
	                    };
	                    this.labels = {
	                        show: false,
	                        color: dataLabelUtils.defaultLabelColor,
	                        displayUnits: 0,
	                        precision: dataLabelUtils.defaultLabelPrecision,
	                        fontSize: dataLabelUtils.DefaultFontSizeInPt,
	                    };
	                    this.outerLine = {
	                        show: false,
	                        thickness: 1,
	                    };
	                }
	                Object.defineProperty(AsterPlotSettings, "Default", {
	                    get: function () {
	                        return new this();
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                AsterPlotSettings.parse = function (dataView, capabilities) {
	                    var settings = new this();
	                    if (!dataView || !dataView.metadata || !dataView.metadata.objects) {
	                        return settings;
	                    }
	                    var properties = this.getProperties(capabilities);
	                    for (var objectKey in capabilities.objects) {
	                        for (var propKey in capabilities.objects[objectKey].properties) {
	                            if (!settings[objectKey] || !_.has(settings[objectKey], propKey)) {
	                                continue;
	                            }
	                            var type = capabilities.objects[objectKey].properties[propKey].type;
	                            var getValueFn = this.getValueFnByType(type);
	                            settings[objectKey][propKey] = getValueFn(dataView.metadata.objects, properties[objectKey][propKey], settings[objectKey][propKey]);
	                        }
	                    }
	                    return settings;
	                };
	                AsterPlotSettings.getProperties = function (capabilities) {
	                    var objects = _.merge({
	                        general: { properties: { formatString: {} } }
	                    }, capabilities.objects);
	                    var properties = {};
	                    for (var objectKey in objects) {
	                        properties[objectKey] = {};
	                        for (var propKey in objects[objectKey].properties) {
	                            properties[objectKey][propKey] = {
	                                objectName: objectKey,
	                                propertyName: propKey
	                            };
	                        }
	                    }
	                    return properties;
	                };
	                AsterPlotSettings.createEnumTypeFromEnum = function (type) {
	                    var even = false;
	                    return createEnumType(Object.keys(type)
	                        .filter(function (key, i) { return ((!!(i % 2)) === even && type[key] === key
	                        && !void (even = !even)) || (!!(i % 2)) !== even; })
	                        .map(function (x) { return { value: x, displayName: x }; }));
	                };
	                AsterPlotSettings.getValueFnByType = function (type) {
	                    switch (_.keys(type)[0]) {
	                        case "fill":
	                            return DataViewObjects.getFillColor;
	                        default:
	                            return DataViewObjects.getValue;
	                    }
	                };
	                AsterPlotSettings.enumerateObjectInstances = function (settings, options, capabilities) {
	                    if (settings === void 0) { settings = new this(); }
	                    var enumeration = new ObjectEnumerationBuilder();
	                    var object = settings && settings[options.objectName];
	                    if (!object) {
	                        return enumeration;
	                    }
	                    var instance = {
	                        objectName: options.objectName,
	                        selector: null,
	                        properties: {}
	                    };
	                    for (var key in object) {
	                        if (_.has(object, key)) {
	                            instance.properties[key] = object[key];
	                        }
	                    }
	                    enumeration.pushInstance(instance);
	                    return enumeration;
	                };
	                AsterPlotSettings.prototype.createOriginalSettings = function () {
	                    this.originalSettings = _.cloneDeep(this);
	                };
	                return AsterPlotSettings;
	            }());
	            samples.AsterPlotSettings = AsterPlotSettings;
	            var AsterPlotColumns = (function () {
	                function AsterPlotColumns() {
	                    //Data Roles
	                    this.Category = null;
	                    this.Y = null;
	                }
	                AsterPlotColumns.getColumnSources = function (dataView) {
	                    return this.getColumnSourcesT(dataView);
	                };
	                AsterPlotColumns.getTableValues = function (dataView) {
	                    var table = dataView && dataView.table;
	                    var columns = this.getColumnSourcesT(dataView);
	                    return columns && table && _.mapValues(columns, function (n, i) { return n && table.rows.map(function (row) { return row[n.index]; }); });
	                };
	                AsterPlotColumns.getTableRows = function (dataView) {
	                    var table = dataView && dataView.table;
	                    var columns = this.getColumnSourcesT(dataView);
	                    return columns && table && table.rows.map(function (row) {
	                        return _.mapValues(columns, function (n, i) { return n && row[n.index]; });
	                    });
	                };
	                AsterPlotColumns.getCategoricalValues = function (dataView) {
	                    var categorical = dataView && dataView.categorical;
	                    var categories = categorical && categorical.categories || [];
	                    var values = categorical && categorical.values || [];
	                    var series = categorical && values.source && this.getSeriesValues(dataView);
	                    return categorical && _.mapValues(new this(), function (n, i) {
	                        return _.toArray(categories).concat(_.toArray(values))
	                            .filter(function (x) { return x.source.roles && x.source.roles[i]; }).map(function (x) { return x.values; })[0]
	                            || values.source && values.source.roles && values.source.roles[i] && series;
	                    });
	                };
	                AsterPlotColumns.getSeriesValues = function (dataView) {
	                    return dataView && dataView.categorical && dataView.categorical.values
	                        && dataView.categorical.values.map(function (x) { return converterHelper.getSeriesName(x.source); });
	                };
	                AsterPlotColumns.getCategoricalColumns = function (dataView) {
	                    var categorical = dataView && dataView.categorical;
	                    var categories = categorical && categorical.categories || [];
	                    var values = categorical && categorical.values || [];
	                    return categorical && _.mapValues(new this(), function (n, i) { return categories.filter(function (x) { return x.source.roles && x.source.roles[i]; })[0]
	                        || values.source && values.source.roles && values.source.roles[i]
	                        || values.filter(function (x) { return x.source.roles && x.source.roles[i]; }); });
	                };
	                AsterPlotColumns.getColumnSourcesT = function (dataView) {
	                    var columns = dataView && dataView.metadata && dataView.metadata.columns;
	                    return columns && _.mapValues(new this(), function (n, i) { return columns.filter(function (x) { return x.roles && x.roles[i]; })[0]; });
	                };
	                AsterPlotColumns.Roles = Object.freeze(_.mapValues(new AsterPlotColumns(), function (x, i) { return i; }));
	                return AsterPlotColumns;
	            }());
	            samples.AsterPlotColumns = AsterPlotColumns;
	            var AsterPlot = (function () {
	                function AsterPlot() {
	                }
	                AsterPlot.converter = function (dataView, colors) {
	                    var categorical = AsterPlotColumns.getCategoricalColumns(dataView);
	                    var catValues = AsterPlotColumns.getCategoricalValues(dataView);
	                    if (!categorical
	                        || !categorical.Category
	                        || _.isEmpty(categorical.Category.values)
	                        || _.isEmpty(categorical.Y)
	                        || _.isEmpty(categorical.Y[0].values)) {
	                        return;
	                    }
	                    var settings = AsterPlot.parseSettings(dataView, categorical.Category.source);
	                    var properties = AsterPlotSettings.getProperties(AsterPlot.capabilities);
	                    var dataPoints = [];
	                    var highlightedDataPoints = [];
	                    var legendData = {
	                        dataPoints: [],
	                        title: null,
	                        fontSize: AsterPlotSettings.Default.legend.fontSize,
	                        labelColor: LegendData.DefaultLegendLabelFillColor
	                    };
	                    var colorHelper = new ColorHelper(colors /*, properties.dataPoint.fill*/);
	                    var hasHighlights = !!(categorical.Y[0].highlights);
	                    var maxValue = Math.max(d3.min(categorical.Y[0].values));
	                    var minValue = Math.min(0, d3.min(categorical.Y[0].values));
	                    var labelFormatter = ValueFormatter.create({
	                        format: ValueFormatter.getFormatString(categorical.Y[0].source, properties.general.formatString),
	                        precision: settings.labels.precision,
	                        value: (settings.labels.displayUnits === 0) && (maxValue != null) ? maxValue : settings.labels.displayUnits,
	                    });
	                    var categorySourceFormatString = valueFormatter.getFormatString(categorical.Category.source, properties.general.formatString);
	                    var fontSizeInPx = PixelConverter.fromPoint(settings.labels.fontSize);
	                    for (var i = 0; i < catValues.Category.length; i++) {
	                        var formattedCategoryValue = valueFormatter.format(catValues.Category[i], categorySourceFormatString);
	                        var currentValue = categorical.Y[0].values[i];
	                        var tooltipInfo = TooltipBuilder.createTooltipInfo(properties.general.formatString, dataView.categorical, formattedCategoryValue, currentValue, null, null, 0);
	                        if (categorical.Y.length > 1) {
	                            var toolTip = TooltipBuilder.createTooltipInfo(properties.general.formatString, dataView.categorical, formattedCategoryValue, categorical.Y[1].values[i], null, null, 1)[1];
	                            if (toolTip)
	                                tooltipInfo.push(toolTip);
	                            currentValue += categorical.Y[1].values[i];
	                        }
	                        var identity = categorical.Category.identity[i];
	                        var color = colorHelper.getColorForMeasure(categorical.Category.objects && categorical.Category.objects[i], identity.key);
	                        var selector = SelectionId.createWithId(identity);
	                        var sliceWidth = Math.max(0, categorical.Y.length > 1 ? categorical.Y[1].values[i] : 1);
	                        if (sliceWidth > 0) {
	                            dataPoints.push({
	                                sliceHeight: categorical.Y[0].values[i] - minValue,
	                                sliceWidth: sliceWidth,
	                                label: labelFormatter.format(currentValue),
	                                color: color,
	                                identity: selector,
	                                selected: false,
	                                tooltipInfo: tooltipInfo,
	                                labelFontSize: fontSizeInPx,
	                                highlight: false,
	                            });
	                        }
	                        // Handle legend data
	                        if (settings.legend.show) {
	                            legendData.dataPoints.push({
	                                label: formattedCategoryValue,
	                                color: color,
	                                icon: LegendIcon.Box,
	                                selected: false,
	                                identity: selector
	                            });
	                        }
	                        // Handle highlights
	                        if (hasHighlights) {
	                            var highlightIdentity = SelectionId.createWithHighlight(selector);
	                            var notNull = categorical.Y[0].highlights[i] != null;
	                            currentValue = notNull ? categorical.Y[0].highlights[i] : 0;
	                            tooltipInfo = TooltipBuilder.createTooltipInfo(properties.general.formatString, dataView.categorical, formattedCategoryValue, currentValue, null, null, 0);
	                            if (categorical.Y.length > 1) {
	                                var toolTip = TooltipBuilder.createTooltipInfo(properties.general.formatString, dataView.categorical, formattedCategoryValue, categorical.Y[1].highlights[i], null, null, 1)[1];
	                                if (toolTip)
	                                    tooltipInfo.push(toolTip);
	                                currentValue += categorical.Y[1].highlights[i] !== null ? categorical.Y[1].highlights[i] : 0;
	                            }
	                            highlightedDataPoints.push({
	                                sliceHeight: notNull ? categorical.Y[0].highlights[i] - minValue : null,
	                                sliceWidth: Math.max(0, (categorical.Y.length > 1 && categorical.Y[1].highlights[i] !== null) ? categorical.Y[1].highlights[i] : sliceWidth),
	                                label: labelFormatter.format(currentValue),
	                                color: color,
	                                identity: highlightIdentity,
	                                selected: false,
	                                tooltipInfo: tooltipInfo,
	                                labelFontSize: fontSizeInPx,
	                                highlight: true,
	                            });
	                        }
	                    }
	                    return dataPoints.length && {
	                        dataPoints: dataPoints,
	                        settings: settings,
	                        hasHighlights: hasHighlights,
	                        legendData: legendData,
	                        highlightedDataPoints: highlightedDataPoints,
	                        labelFormatter: labelFormatter,
	                        centerText: categorical.Category.source.displayName
	                    };
	                };
	                AsterPlot.parseSettings = function (dataView, categorySource) {
	                    var settings = AsterPlotSettings.parse(dataView, AsterPlot.capabilities);
	                    settings.labels.precision = Math.min(17, Math.max(0, settings.labels.precision));
	                    settings.outerLine.thickness = Math.min(300, Math.max(1, settings.outerLine.thickness));
	                    settings.createOriginalSettings();
	                    if (_.isEmpty(settings.legend.titleText)) {
	                        settings.legend.titleText = categorySource.displayName;
	                    }
	                    return settings;
	                };
	                Object.defineProperty(AsterPlot.prototype, "settings", {
	                    get: function () {
	                        return this.data && this.data.settings;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                AsterPlot.prototype.init = function (options) {
	                    this.hostServices = options.host;
	                    this.hostServices.canSelect = function (args) {
	                        var selectors = _.map(args.visualObjects, function (visualObject) { return powerbi.data.Selector.convertSelectorsByColumnToSelector(visualObject.selectorsByColumn); });
	                        // We can't have multiple selections if any include more than one identity
	                        if (selectors.length > 1) {
	                            if (selectors.some(function (value) { return value && value.data && value.data.length > 1; }))
	                                return false;
	                        }
	                        return true;
	                    };
	                    this.layout = new VisualLayout(options.viewport, { top: 10, right: 10, bottom: 15, left: 10 });
	                    var element = options.element;
	                    var svg = this.svg = d3.select(element.get(0))
	                        .append("svg")
	                        .classed(AsterPlotVisualClassName, true)
	                        .style("position", "absolute");
	                    this.colors = options.style.colorPalette.dataColors;
	                    this.mainGroupElement = svg.append("g");
	                    this.mainLabelsElement = svg.append("g");
	                    this.behavior = new AsterPlotWebBehavior();
	                    this.clearCatcher = appendClearCatcher(this.mainGroupElement);
	                    this.slicesElement = this.mainGroupElement.append("g").classed(AsterPlot.AsterSlices.class, true);
	                    var interactivity = options.interactivity;
	                    this.interactivityService = createInteractivityService(this.hostServices);
	                    this.legend = createLegend(element, interactivity && interactivity.isInteractiveLegend, this.interactivityService, true);
	                };
	                AsterPlot.prototype.update = function (options) {
	                    if (!options || !options.dataViews || !options.dataViews[0]) {
	                        return; // or clear the view, display an error, etc.
	                    }
	                    this.layout.viewport = options.viewport;
	                    var duration = options.suppressAnimations ? 0 : MinervaAnimationDuration;
	                    var data = AsterPlot.converter(options.dataViews[0], this.colors);
	                    if (!data) {
	                        this.clear();
	                        return;
	                    }
	                    this.data = data;
	                    if (this.interactivityService) {
	                        this.interactivityService.applySelectionStateToData(this.data.dataPoints);
	                        this.interactivityService.applySelectionStateToData(this.data.highlightedDataPoints);
	                    }
	                    this.renderLegend();
	                    this.updateViewPortAccordingToLegend();
	                    this.svg.attr(this.layout.viewport);
	                    var transformX = (this.layout.viewportIn.width + this.layout.margin.right) / 2;
	                    var transformY = (this.layout.viewportIn.height + this.layout.margin.bottom) / 2;
	                    this.mainGroupElement.attr("transform", SVGUtil.translate(transformX, transformY));
	                    this.mainLabelsElement.attr("transform", SVGUtil.translate(transformX, transformY));
	                    // Move back the clearCatcher
	                    this.clearCatcher.attr("transform", SVGUtil.translate(-transformX, -transformY));
	                    dataLabelUtils.cleanDataLabels(this.mainLabelsElement, true);
	                    this.renderArcsAndLabels(duration);
	                    if (this.data.hasHighlights) {
	                        this.renderArcsAndLabels(duration, true);
	                    }
	                    else {
	                        this.slicesElement.selectAll(AsterPlot.AsterHighlightedSlice.selector).remove();
	                    }
	                    if (this.interactivityService) {
	                        var behaviorOptions = {
	                            selection: this.slicesElement.selectAll(AsterPlot.AsterSlice.selector + ", " + AsterPlot.AsterHighlightedSlice.selector),
	                            clearCatcher: this.clearCatcher,
	                            interactivityService: this.interactivityService,
	                            hasHighlights: this.data.hasHighlights
	                        };
	                        this.interactivityService.bind(this.data.dataPoints.concat(this.data.highlightedDataPoints), this.behavior, behaviorOptions);
	                    }
	                };
	                AsterPlot.prototype.renderArcsAndLabels = function (duration, isHighlight) {
	                    var _this = this;
	                    if (isHighlight === void 0) { isHighlight = false; }
	                    var viewportRadius = Math.min(this.layout.viewportIn.width, this.layout.viewportIn.height) / 2, innerRadius = 0.3 * (this.settings.labels.show ? viewportRadius * AsterRadiusRatio : viewportRadius), maxScore = d3.max(this.data.dataPoints, function (d) { return d.sliceHeight; }), totalWeight = d3.sum(this.data.dataPoints, function (d) { return d.sliceWidth; });
	                    var pie = d3.layout.pie()
	                        .sort(null)
	                        .value(function (dataPoint) {
	                        if (!totalWeight || !dataPoint || isNaN(dataPoint.sliceWidth)) {
	                            return 0;
	                        }
	                        return dataPoint.sliceWidth / totalWeight;
	                    });
	                    var arc = d3.svg.arc()
	                        .innerRadius(innerRadius)
	                        .outerRadius(function (arcDescriptor) {
	                        var height = 0;
	                        if (maxScore) {
	                            var radius = viewportRadius - innerRadius, sliceHeight = 1;
	                            sliceHeight = arcDescriptor
	                                && arcDescriptor.data
	                                && !isNaN(arcDescriptor.data.sliceHeight)
	                                ? arcDescriptor.data.sliceHeight
	                                : sliceHeight;
	                            height = radius * sliceHeight / maxScore;
	                        }
	                        //The chart should shrink if data labels are on
	                        var heightIsLabelsOn = innerRadius + (_this.settings.labels.show ? height * AsterRadiusRatio : height);
	                        // Prevent from data to be inside the inner radius
	                        return Math.max(heightIsLabelsOn, innerRadius);
	                    });
	                    var arcDescriptorDataPoints = pie(isHighlight ? this.data.highlightedDataPoints : this.data.dataPoints);
	                    var classSelector = isHighlight
	                        ? AsterPlot.AsterHighlightedSlice
	                        : AsterPlot.AsterSlice;
	                    var selection = this.slicesElement
	                        .selectAll(classSelector.selector)
	                        .data(arcDescriptorDataPoints, function (d, i) {
	                        return d.data
	                            ? d.data.identity.getKey()
	                            : i;
	                    });
	                    selection
	                        .enter()
	                        .append("path")
	                        .classed(classSelector.class, true)
	                        .attr("stroke", "#333");
	                    selection
	                        .attr("fill", function (d) { return d.data.color; })
	                        .call(function (selection) {
	                        return Helpers.setAttrThroughTransitionIfNotResized(selection, function (s) { return s.duration(duration); }, "d", arc, Helpers.interpolateArc(arc), _this.layout.viewportChanged);
	                    });
	                    selection
	                        .exit()
	                        .remove();
	                    TooltipManager.addTooltip(selection, function (tooltipEvent) { return tooltipEvent.data.data.tooltipInfo; });
	                    // Draw data labels only if they are on and there are no highlights or there are highlights and this is the highlighted data labels
	                    if (this.settings.labels.show && (!this.data.hasHighlights || (this.data.hasHighlights && isHighlight))) {
	                        var labelRadCalc = function (d) {
	                            var height = viewportRadius * (d && !isNaN(d.sliceHeight) ? d.sliceHeight : 1) / maxScore + innerRadius;
	                            return Math.max(height, innerRadius);
	                        };
	                        var labelArc = d3.svg.arc()
	                            .innerRadius(function (d) { return labelRadCalc(d.data); })
	                            .outerRadius(function (d) { return labelRadCalc(d.data); });
	                        var lineRadCalc = function (d) {
	                            var height = (viewportRadius - innerRadius) * (d && !isNaN(d.sliceHeight) ? d.sliceHeight : 1) / maxScore;
	                            height = innerRadius + height * AsterRadiusRatio;
	                            return Math.max(height, innerRadius);
	                        };
	                        var outlineArc = d3.svg.arc()
	                            .innerRadius(function (d) { return lineRadCalc(d.data); })
	                            .outerRadius(function (d) { return lineRadCalc(d.data); });
	                        var labelLayout = this.getLabelLayout(labelArc, this.layout.viewport);
	                        this.drawLabels(arcDescriptorDataPoints.filter(function (x) { return !isHighlight || x.data.sliceHeight !== null; }), this.mainLabelsElement, labelLayout, this.layout.viewport, outlineArc, labelArc);
	                    }
	                    else {
	                        dataLabelUtils.cleanDataLabels(this.mainLabelsElement, true);
	                    }
	                    // Draw center text and outline once for original data points
	                    if (!isHighlight) {
	                        this.drawCenterText(innerRadius);
	                        this.drawOuterLine(innerRadius, _.max(arcDescriptorDataPoints.map(function (d) { return arc.outerRadius()(d); })), arcDescriptorDataPoints);
	                    }
	                    return selection;
	                };
	                AsterPlot.prototype.getLabelLayout = function (arc, viewport) {
	                    var midAngle = function (d) { return d.startAngle + (d.endAngle - d.startAngle) / 2; };
	                    var textProperties = {
	                        fontFamily: dataLabelUtils.StandardFontFamily,
	                        fontSize: PixelConverter.fromPoint(this.settings.labels.fontSize),
	                        text: "",
	                    };
	                    var isLabelsHasConflict = function (d) {
	                        var pos = arc.centroid(d);
	                        textProperties.text = d.data.label;
	                        var textWidth = TextMeasurementService.measureSvgTextWidth(textProperties);
	                        var horizontalSpaceAvaliableForLabels = viewport.width / 2 - Math.abs(pos[0]);
	                        var textHeight = TextMeasurementService.estimateSvgTextHeight(textProperties);
	                        var verticalSpaceAvaliableForLabels = viewport.height / 2 - Math.abs(pos[1]);
	                        d.isLabelHasConflict = textWidth > horizontalSpaceAvaliableForLabels || textHeight > verticalSpaceAvaliableForLabels;
	                        return d.isLabelHasConflict;
	                    };
	                    return {
	                        labelText: function (d) {
	                            textProperties.text = d.data.label;
	                            var pos = arc.centroid(d);
	                            var xPos = isLabelsHasConflict(d) ? pos[0] * AsterConflictRatio : pos[0];
	                            var spaceAvaliableForLabels = viewport.width / 2 - Math.abs(xPos);
	                            return TextMeasurementService.getTailoredTextOrDefault(textProperties, spaceAvaliableForLabels);
	                        },
	                        labelLayout: {
	                            x: function (d) {
	                                var pos = arc.centroid(d);
	                                textProperties.text = d.data.label;
	                                var xPos = d.isLabelHasConflict ? pos[0] * AsterConflictRatio : pos[0];
	                                return xPos;
	                            },
	                            y: function (d) {
	                                var pos = arc.centroid(d);
	                                var yPos = d.isLabelHasConflict ? pos[1] * AsterConflictRatio : pos[1];
	                                return yPos;
	                            },
	                        },
	                        filter: function (d) { return (d != null && !_.isEmpty(d.data.label)); },
	                        style: {
	                            "fill": this.settings.labels.color,
	                            "font-size": textProperties.fontSize,
	                            "text-anchor": function (d) { return midAngle(d) < Math.PI ? "start" : "end"; },
	                        },
	                    };
	                };
	                AsterPlot.prototype.drawLabels = function (data, context, layout, viewport, outlineArc, labelArc) {
	                    var _this = this;
	                    // Hide and reposition labels that overlap
	                    var dataLabelManager = new DataLabelManager();
	                    var filteredData = dataLabelManager.hideCollidedLabels(viewport, data, layout, true /* addTransform */);
	                    if (filteredData.length === 0) {
	                        dataLabelUtils.cleanDataLabels(context, true);
	                        return;
	                    }
	                    // Draw labels
	                    if (context.select(AsterPlot.labelGraphicsContextClass.selector).empty())
	                        context.append("g").classed(AsterPlot.labelGraphicsContextClass.class, true);
	                    var labels = context
	                        .select(AsterPlot.labelGraphicsContextClass.selector)
	                        .selectAll(".data-labels").data(filteredData, function (d) { return d.data.identity.getKey(); });
	                    labels.enter().append("text").classed("data-labels", true);
	                    if (!labels)
	                        return;
	                    labels
	                        .attr({ x: function (d) { return d.labelX; }, y: function (d) { return d.labelY; }, dy: ".35em" })
	                        .text(function (d) { return d.labeltext; })
	                        .style(layout.style);
	                    labels
	                        .exit()
	                        .remove();
	                    // Draw lines
	                    if (context.select(AsterPlot.linesGraphicsContextClass.selector).empty())
	                        context.append("g").classed(AsterPlot.linesGraphicsContextClass.class, true);
	                    // Remove lines for null and zero values
	                    filteredData = _.filter(filteredData, function (d) { return d.data.sliceHeight !== null && d.data.sliceHeight !== 0; });
	                    var lines = context.select(AsterPlot.linesGraphicsContextClass.selector).selectAll("polyline")
	                        .data(filteredData, function (d) { return d.data.identity.getKey(); });
	                    var labelLinePadding = 4;
	                    var chartLinePadding = 1.02;
	                    var midAngle = function (d) { return d.startAngle + (d.endAngle - d.startAngle) / 2; };
	                    lines.enter()
	                        .append("polyline")
	                        .classed("line-label", true);
	                    lines
	                        .attr("points", function (d) {
	                        var textPoint = [d.labelX, d.labelY];
	                        textPoint[0] = textPoint[0] + ((midAngle(d) < Math.PI ? -1 : 1) * labelLinePadding);
	                        var chartPoint = outlineArc.centroid(d);
	                        chartPoint[0] *= chartLinePadding;
	                        chartPoint[1] *= chartLinePadding;
	                        return [chartPoint, textPoint];
	                    }).
	                        style({
	                        "opacity": 0.5,
	                        "fill-opacity": 0,
	                        "stroke": function (d) { return _this.settings.labels.color; },
	                    });
	                    lines
	                        .exit()
	                        .remove();
	                };
	                AsterPlot.prototype.renderLegend = function () {
	                    if (this.settings.legend.show) {
	                        // Force update for title text
	                        var legendObject = _.clone(this.settings.legend);
	                        legendObject.labelColor = { solid: { color: legendObject.labelColor } };
	                        LegendData.update(this.data.legendData, legendObject);
	                        this.legend.changeOrientation(LegendPosition[this.settings.legend.position]);
	                    }
	                    this.legend.drawLegend(this.data.legendData, this.layout.viewportCopy);
	                    Legend.positionChartArea(this.svg, this.legend);
	                };
	                AsterPlot.prototype.updateViewPortAccordingToLegend = function () {
	                    if (!this.settings.legend.show)
	                        return;
	                    var legendMargins = this.legend.getMargins();
	                    var legendPosition = LegendPosition[this.settings.legend.position];
	                    switch (legendPosition) {
	                        case LegendPosition.Top:
	                        case LegendPosition.TopCenter:
	                        case LegendPosition.Bottom:
	                        case LegendPosition.BottomCenter: {
	                            this.layout.viewport.height -= legendMargins.height;
	                            break;
	                        }
	                        case LegendPosition.Left:
	                        case LegendPosition.LeftCenter:
	                        case LegendPosition.Right:
	                        case LegendPosition.RightCenter: {
	                            this.layout.viewport.width -= legendMargins.width;
	                            break;
	                        }
	                        default:
	                            break;
	                    }
	                };
	                AsterPlot.prototype.drawOuterLine = function (innerRadius, radius, data) {
	                    var mainGroup = this.mainGroupElement;
	                    var outlineArc = d3.svg.arc()
	                        .innerRadius(innerRadius)
	                        .outerRadius(radius);
	                    if (this.settings.outerLine.show) {
	                        var OuterThickness = this.settings.outerLine.thickness + "px";
	                        var outerLine = mainGroup.selectAll(AsterPlot.OuterLine.selector).data(data);
	                        outerLine.enter().append("path");
	                        outerLine.attr("fill", "none")
	                            .attr({
	                            "stroke": "#333",
	                            "stroke-width": OuterThickness,
	                            "d": outlineArc
	                        })
	                            .style("opacity", 1)
	                            .classed(AsterPlot.OuterLine.class, true);
	                        outerLine.exit().remove();
	                    }
	                    else
	                        mainGroup.selectAll(AsterPlot.OuterLine.selector).remove();
	                };
	                AsterPlot.prototype.drawCenterText = function (innerRadius) {
	                    if (_.isEmpty(this.data.centerText)) {
	                        this.mainGroupElement.select(AsterPlot.CenterLabelClass.selector).remove();
	                        return;
	                    }
	                    var centerTextProperties = {
	                        fontFamily: dataLabelUtils.StandardFontFamily,
	                        fontWeight: "bold",
	                        fontSize: PixelConverter.toString(innerRadius * AsterPlot.CenterTextFontHeightCoefficient),
	                        text: this.data.centerText
	                    };
	                    if (this.mainGroupElement.select(AsterPlot.CenterLabelClass.selector).empty())
	                        this.centerText = this.mainGroupElement.append("text").classed(AsterPlot.CenterLabelClass.class, true);
	                    this.centerText
	                        .style({
	                        "line-height": 1,
	                        "font-weight": centerTextProperties.fontWeight,
	                        "font-size": centerTextProperties.fontSize,
	                        "fill": this.settings.labels.color
	                    })
	                        .attr({
	                        "dy": "0.35em",
	                        "text-anchor": "middle"
	                    })
	                        .text(TextMeasurementService.getTailoredTextOrDefault(centerTextProperties, innerRadius * AsterPlot.CenterTextFontWidthCoefficient));
	                };
	                AsterPlot.prototype.clear = function () {
	                    this.mainGroupElement.selectAll("path").remove();
	                    this.mainGroupElement.select(AsterPlot.CenterLabelClass.selector).remove();
	                    dataLabelUtils.cleanDataLabels(this.mainLabelsElement, true);
	                    this.legend.drawLegend({ dataPoints: [] }, this.layout.viewportCopy);
	                };
	                AsterPlot.prototype.onClearSelection = function () {
	                    if (this.interactivityService)
	                        this.interactivityService.clearSelection();
	                };
	                // This function retruns the values to be displayed in the property pane for each object.
	                // Usually it is a bind pass of what the property pane gave you, but sometimes you may want to do
	                // validation and return other values/defaults
	                AsterPlot.prototype.enumerateObjectInstances = function (options) {
	                    var instances = AsterPlotSettings.enumerateObjectInstances(this.settings && this.settings.originalSettings, options, AsterPlot.capabilities);
	                    return instances.complete();
	                };
	                AsterPlot.capabilities = {
	                    dataRoles: [
	                        {
	                            displayName: "Category",
	                            name: AsterPlotColumns.Roles.Category,
	                            kind: VisualDataRoleKind.Grouping,
	                        },
	                        {
	                            displayName: "Y Axis",
	                            name: AsterPlotColumns.Roles.Y,
	                            kind: VisualDataRoleKind.Measure,
	                        },
	                    ],
	                    dataViewMappings: [{
	                            conditions: [
	                                { "Category": { max: 1 }, "Y": { max: 2 } }
	                            ],
	                            categorical: {
	                                categories: {
	                                    for: { in: "Category" },
	                                    dataReductionAlgorithm: { top: {} }
	                                },
	                                values: {
	                                    select: [{ bind: { to: "Y" } }]
	                                },
	                            }
	                        }],
	                    objects: {
	                        general: {
	                            displayName: createDisplayNameGetter("Visual_General"),
	                            properties: {
	                                formatString: {
	                                    type: { formatting: { formatString: true } },
	                                },
	                            },
	                        },
	                        legend: {
	                            displayName: "Legend",
	                            description: "Display legend options",
	                            properties: {
	                                show: {
	                                    displayName: "Show",
	                                    type: { bool: true }
	                                },
	                                position: {
	                                    displayName: "Position",
	                                    description: "Select the location for the legend",
	                                    type: { enumeration: legendPosition.type }
	                                },
	                                showTitle: {
	                                    displayName: "Title",
	                                    description: "Display a title for legend symbols",
	                                    type: { bool: true }
	                                },
	                                titleText: {
	                                    displayName: "Legend Name",
	                                    description: "Title text",
	                                    type: { text: true },
	                                    suppressFormatPainterCopy: true
	                                },
	                                labelColor: {
	                                    displayName: "Color",
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                fontSize: {
	                                    displayName: "Text Size",
	                                    type: { formatting: { fontSize: true } }
	                                }
	                            }
	                        },
	                        label: {
	                            displayName: "Center Label",
	                            properties: {
	                                fill: {
	                                    displayName: "Fill",
	                                    type: { fill: { solid: { color: true } } }
	                                }
	                            }
	                        },
	                        labels: {
	                            displayName: "Detail Labels",
	                            properties: {
	                                show: {
	                                    type: { bool: true }
	                                },
	                                color: {
	                                    displayName: "Color",
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                displayUnits: {
	                                    displayName: "Display Units",
	                                    type: { formatting: { displayUnits: true } },
	                                },
	                                precision: {
	                                    displayName: "Decimal Places",
	                                    placeHolderText: "Auto",
	                                    type: { numeric: true },
	                                },
	                                fontSize: {
	                                    displayName: "Text Size",
	                                    type: { formatting: { fontSize: true } },
	                                },
	                            },
	                        },
	                        outerLine: {
	                            displayName: "Outer line",
	                            properties: {
	                                show: {
	                                    displayName: "Show",
	                                    type: { bool: true }
	                                },
	                                thickness: {
	                                    displayName: "Thickness",
	                                    type: { numeric: true }
	                                }
	                            }
	                        }
	                    },
	                    supportsHighlight: true,
	                };
	                AsterPlot.AsterSlices = createClassAndSelector("asterSlices");
	                AsterPlot.AsterSlice = createClassAndSelector("asterSlice");
	                AsterPlot.AsterHighlightedSlice = createClassAndSelector("asterHighlightedSlice");
	                AsterPlot.OuterLine = createClassAndSelector("outerLine");
	                AsterPlot.labelGraphicsContextClass = createClassAndSelector("labels");
	                AsterPlot.linesGraphicsContextClass = createClassAndSelector("lines");
	                AsterPlot.CenterLabelClass = createClassAndSelector("centerLabel");
	                AsterPlot.CenterTextFontHeightCoefficient = 0.4;
	                AsterPlot.CenterTextFontWidthCoefficient = 1.9;
	                return AsterPlot;
	            }());
	            samples.AsterPlot = AsterPlot;
	            var asterPlotUtils;
	            (function (asterPlotUtils) {
	                asterPlotUtils.DimmedOpacity = 0.4;
	                asterPlotUtils.DefaultOpacity = 1.0;
	                function getFillOpacity(selected, highlight, hasSelection, hasPartialHighlights) {
	                    if ((hasPartialHighlights && !highlight) || (hasSelection && !selected)) {
	                        return asterPlotUtils.DimmedOpacity;
	                    }
	                    return asterPlotUtils.DefaultOpacity;
	                }
	                asterPlotUtils.getFillOpacity = getFillOpacity;
	            })(asterPlotUtils = samples.asterPlotUtils || (samples.asterPlotUtils = {}));
	        })(samples = visuals.samples || (visuals.samples = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 39 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../../../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var samples;
	        (function (samples) {
	            var PixelConverter = jsCommon.PixelConverter;
	            var SelectionId = powerbi.visuals.SelectionId;
	            var LegendData = powerbi.visuals.LegendData;
	            var DataViewObject = powerbi.DataViewObject;
	            var SVGUtil = powerbi.visuals.SVGUtil;
	            var VisualDataRoleKind = powerbi.VisualDataRoleKind;
	            var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
	            var legendPosition = powerbi.visuals.legendPosition;
	            var dataLabelUtils = powerbi.visuals.dataLabelUtils;
	            var TextMeasurementService = powerbi.TextMeasurementService;
	            var valueFormatter = powerbi.visuals.valueFormatter;
	            var SelectionIdBuilder = powerbi.visuals.SelectionIdBuilder;
	            var TooltipBuilder = powerbi.visuals.TooltipBuilder;
	            var DataViewObjects = powerbi.DataViewObjects;
	            var ColorHelper = powerbi.visuals.ColorHelper;
	            var createInteractivityService = powerbi.visuals.createInteractivityService;
	            var appendClearCatcher = powerbi.visuals.appendClearCatcher;
	            var createLegend = powerbi.visuals.createLegend;
	            var GetAnimationDuration = powerbi.visuals.AnimatorCommon.GetAnimationDuration;
	            var LegendIcon = powerbi.visuals.LegendIcon;
	            var LegendPosition = powerbi.visuals.LegendPosition;
	            var legendProps = powerbi.visuals.legendProps;
	            var TooltipManager = powerbi.visuals.TooltipManager;
	            var Legend = powerbi.visuals.Legend;
	            var ObjectEnumerationBuilder = powerbi.visuals.ObjectEnumerationBuilder;
	            var TornadoWebBehavior = (function () {
	                function TornadoWebBehavior() {
	                }
	                TornadoWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
	                    this.columns = options.columns;
	                    this.clearCatcher = options.clearCatcher;
	                    this.interactivityService = options.interactivityService;
	                    this.columns.on('click', function (d, i) {
	                        selectionHandler.handleSelection(d, d3.event.ctrlKey);
	                    });
	                    this.clearCatcher.on('click', function () {
	                        selectionHandler.handleClearSelection();
	                    });
	                };
	                TornadoWebBehavior.prototype.renderSelection = function (hasSelection) {
	                    var hasHighlights = this.interactivityService.hasSelection();
	                    this.columns.style("fill-opacity", function (d) { return tornadoChartUtils.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights); });
	                };
	                return TornadoWebBehavior;
	            }());
	            var TornadoChartScrolling = (function () {
	                function TornadoChartScrolling(getRoot, getViewport, getMargin, getPrefferedHeight, isScrollable) {
	                    this.scrollYBrush = d3.svg.brush();
	                    this.getRoot = getRoot;
	                    this.getViewport = getViewport;
	                    this.isScrollable = isScrollable;
	                    this.getPrefferedHeight = getPrefferedHeight;
	                }
	                Object.defineProperty(TornadoChartScrolling.prototype, "scrollViewport", {
	                    get: function () {
	                        return {
	                            height: this.viewport.height,
	                            width: this.viewport.width
	                                - ((this.isYScrollBarVisible && this.isScrollable) ? TornadoChart.ScrollBarWidth : 0)
	                        };
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(TornadoChartScrolling.prototype, "root", {
	                    get: function () {
	                        return this.getRoot();
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(TornadoChartScrolling.prototype, "viewport", {
	                    get: function () {
	                        return this.getViewport();
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                TornadoChartScrolling.prototype.renderY = function (data, onScroll) {
	                    var _this = this;
	                    this.isYScrollBarVisible = this.isScrollable &&
	                        this.getPrefferedHeight() > this.viewport.height
	                        && this.viewport.height > 0
	                        && this.viewport.width > 0;
	                    this.brushGraphicsContextY = this.createOrRemoveScrollbar(this.isYScrollBarVisible, this.brushGraphicsContextY, 'y brush');
	                    if (!this.isYScrollBarVisible) {
	                        onScroll.call(this, jQuery.extend(true, {}, data), 0, 1);
	                        return;
	                    }
	                    var scrollSpaceLength = this.viewport.height;
	                    var extentData = this.getExtentData(this.getPrefferedHeight(), scrollSpaceLength);
	                    var onRender = function (wheelDelta) {
	                        if (wheelDelta === void 0) { wheelDelta = 0; }
	                        var position = _this.scrollYBrush.extent();
	                        if (wheelDelta !== 0) {
	                            // Handle mouse wheel manually by moving the scrollbar half of its size
	                            var halfScrollsize = (position[1] - position[0]) / 2;
	                            position[0] += (wheelDelta > 0) ? halfScrollsize : -halfScrollsize;
	                            position[1] += (wheelDelta > 0) ? halfScrollsize : -halfScrollsize;
	                            if (position[0] < 0) {
	                                var offset = 0 - position[0];
	                                position[0] += offset;
	                                position[1] += offset;
	                            }
	                            if (position[1] > scrollSpaceLength) {
	                                var offset = position[1] - scrollSpaceLength;
	                                position[0] -= offset;
	                                position[1] -= offset;
	                            }
	                            // Update the scroll bar accordingly and redraw
	                            _this.scrollYBrush.extent(position);
	                            _this.brushGraphicsContextY.select('.extent').attr('y', position[0]);
	                        }
	                        var scrollPosition = extentData.toScrollPosition(position, scrollSpaceLength);
	                        onScroll.call(_this, jQuery.extend(true, {}, data), scrollPosition[0], scrollPosition[1]);
	                        _this.setScrollBarSize(_this.brushGraphicsContextY, extentData.value[1], true);
	                    };
	                    var scrollYScale = d3.scale.ordinal().rangeBands([0, scrollSpaceLength]);
	                    this.scrollYBrush.y(scrollYScale).extent(extentData.value);
	                    this.renderScrollbar(this.scrollYBrush, this.brushGraphicsContextY, this.viewport.width, onRender);
	                    onRender();
	                };
	                TornadoChartScrolling.prototype.createOrRemoveScrollbar = function (isVisible, brushGraphicsContext, brushClass) {
	                    if (isVisible && this.isScrollable) {
	                        return brushGraphicsContext || this.root.append("g").classed(brushClass, true);
	                    }
	                    return brushGraphicsContext ? void brushGraphicsContext.remove() : undefined;
	                };
	                TornadoChartScrolling.prototype.renderScrollbar = function (brush, brushGraphicsContext, brushX, onRender) {
	                    var _this = this;
	                    brush.on("brush", function () { return window.requestAnimationFrame(function () { return onRender(0); }); });
	                    this.root.on('wheel', function () {
	                        if (!_this.isYScrollBarVisible)
	                            return;
	                        var wheelEvent = d3.event; // Casting to any to avoid compilation errors
	                        onRender(wheelEvent.deltaY);
	                    });
	                    brushGraphicsContext.attr({
	                        "transform": SVGUtil.translate(brushX, 0),
	                        "drag-resize-disabled": "true" /*disables resizing of the visual when dragging the scrollbar in edit mode*/
	                    });
	                    brushGraphicsContext.call(brush); /*call the brush function, causing it to create the rectangles   */
	                    /* Disabling the zooming feature */
	                    brushGraphicsContext.selectAll(".resize").remove();
	                    brushGraphicsContext.select(".background").remove();
	                    brushGraphicsContext.selectAll(".extent").style({
	                        "fill-opacity": 0.125,
	                        "cursor": "default",
	                    });
	                };
	                TornadoChartScrolling.prototype.setScrollBarSize = function (brushGraphicsContext, minExtent, isVertical) {
	                    brushGraphicsContext.selectAll("rect").attr(isVertical ? "width" : "height", TornadoChart.ScrollBarWidth);
	                    brushGraphicsContext.selectAll("rect").attr(isVertical ? "height" : "width", minExtent);
	                };
	                TornadoChartScrolling.prototype.getExtentData = function (svgLength, scrollSpaceLength) {
	                    var value = scrollSpaceLength * scrollSpaceLength / svgLength;
	                    var scaleMultipler = TornadoChartScrolling.ScrollBarMinLength <= value
	                        ? 1
	                        : value / TornadoChartScrolling.ScrollBarMinLength;
	                    value = Math.max(value, TornadoChartScrolling.ScrollBarMinLength);
	                    var toScrollPosition = function (extent, scrollSpaceLength) {
	                        var scrollSize = extent[1] - extent[0];
	                        var scrollPosition = extent[0] / (scrollSpaceLength - scrollSize);
	                        scrollSize *= scaleMultipler;
	                        var start = (scrollPosition * (scrollSpaceLength - scrollSize));
	                        var end = (start + scrollSize);
	                        return [start / scrollSpaceLength, end / scrollSpaceLength];
	                    };
	                    return { value: [0, value], toScrollPosition: toScrollPosition };
	                };
	                TornadoChartScrolling.prototype.clearData = function () {
	                    if (this.brushGraphicsContextY)
	                        this.brushGraphicsContextY.selectAll("*").remove();
	                };
	                TornadoChartScrolling.ScrollBarMinLength = 15;
	                return TornadoChartScrolling;
	            }());
	            var TornadoChartWarning = (function () {
	                function TornadoChartWarning() {
	                }
	                Object.defineProperty(TornadoChartWarning.prototype, "code", {
	                    get: function () {
	                        return "TornadoChartWarning";
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                TornadoChartWarning.prototype.getMessages = function (resourceProvider) {
	                    var message = "This visual requires two distinct values to be returned for the Legend field.", titleKey = "", detailKey = "", visualMessage;
	                    visualMessage = {
	                        message: message,
	                        title: resourceProvider.get(titleKey),
	                        detail: resourceProvider.get(detailKey)
	                    };
	                    return visualMessage;
	                };
	                return TornadoChartWarning;
	            }());
	            samples.TornadoChartWarning = TornadoChartWarning;
	            function getTornadoChartWarning() {
	                return new TornadoChartWarning();
	            }
	            samples.getTornadoChartWarning = getTornadoChartWarning;
	            var TornadoChart = (function () {
	                function TornadoChart(tornadoChartConstructorOptions) {
	                    this.textOptions = {};
	                    this.columnPadding = 5;
	                    this.leftLabelMargin = 4;
	                    this.InnerTextHeightDelta = 2;
	                    this.margin = {
	                        top: 10,
	                        right: 5,
	                        bottom: 10,
	                        left: 10
	                    };
	                    this.heightColumn = 0;
	                    if (tornadoChartConstructorOptions) {
	                        this.svg = tornadoChartConstructorOptions.svg || this.svg;
	                        this.margin = tornadoChartConstructorOptions.margin || this.margin;
	                        this.columnPadding = tornadoChartConstructorOptions.columnPadding || this.columnPadding;
	                        this.animator = tornadoChartConstructorOptions.animator;
	                    }
	                }
	                TornadoChart.getProperties = function (capabilities) {
	                    var result = {};
	                    for (var objectKey in capabilities.objects) {
	                        result[objectKey] = {};
	                        for (var propKey in capabilities.objects[objectKey].properties) {
	                            result[objectKey][propKey] = {
	                                objectName: objectKey,
	                                propertyName: propKey
	                            };
	                        }
	                    }
	                    return result;
	                };
	                TornadoChart.converter = function (dataView, textOptions, colors) {
	                    if (!dataView ||
	                        !dataView.categorical ||
	                        !dataView.categorical.categories ||
	                        !dataView.categorical.categories[0] ||
	                        !dataView.categorical.categories[0].source ||
	                        !dataView.categorical.values ||
	                        !dataView.categorical.values[0]) {
	                        return null;
	                    }
	                    var categorical = dataView.categorical;
	                    var categories = categorical.categories || [];
	                    var values = categorical.values;
	                    var category = categories[0];
	                    var formatStringProp = TornadoChart.Properties.general.formatString;
	                    var maxValue = d3.max(values[0].values);
	                    var settings = TornadoChart.parseSettings(dataView.metadata.objects, maxValue, colors);
	                    var hasDynamicSeries = !!values.source;
	                    var hasHighlights = !!(values.length > 0 && values[0].highlights);
	                    var labelHeight = TextMeasurementService.estimateSvgTextHeight({
	                        fontFamily: dataLabelUtils.StandardFontFamily,
	                        fontSize: PixelConverter.fromPoint(settings.labelSettings.fontSize),
	                    });
	                    var series = [];
	                    var dataPoints = [];
	                    var highlightedDataPoints = [];
	                    var categorySourceFormatString = valueFormatter.getFormatString(category.source, formatStringProp);
	                    var categoriesLabels = category.values.map(function (value) {
	                        var formattedCategoryValue = valueFormatter.format(value, categorySourceFormatString);
	                        return TornadoChart.getTextData(formattedCategoryValue, textOptions, true);
	                    });
	                    var groupedValues = values.grouped ? values.grouped() : null;
	                    var minValue = Math.min(d3.min(values[0].values), 0);
	                    if (values.length === TornadoChart.MaxSeries) {
	                        minValue = d3.min([minValue, d3.min(values[1].values)]);
	                        maxValue = d3.max([maxValue, d3.max(values[1].values)]);
	                    }
	                    for (var seriesIndex = 0; seriesIndex < values.length; seriesIndex++) {
	                        var columnGroup = groupedValues && groupedValues.length > seriesIndex
	                            && groupedValues[seriesIndex].values ? groupedValues[seriesIndex] : null;
	                        var parsedSeries = TornadoChart.parseSeries(values, seriesIndex, hasDynamicSeries, columnGroup, colors);
	                        series.push(parsedSeries);
	                        var currentSeries = values[seriesIndex];
	                        var measureName = currentSeries.source.queryName;
	                        for (var i = 0; i < category.values.length; i++) {
	                            var value = currentSeries.values[i] == null || isNaN(currentSeries.values[i]) ? 0 : currentSeries.values[i];
	                            var identity = SelectionIdBuilder.builder()
	                                .withCategory(category, i)
	                                .withSeries(values, columnGroup)
	                                .withMeasure(measureName)
	                                .createSelectionId();
	                            var formattedCategoryValue = categoriesLabels[i].text;
	                            var tooltipInfo;
	                            tooltipInfo = TooltipBuilder.createTooltipInfo(formatStringProp, categorical, formattedCategoryValue, value, null, null, seriesIndex, i, null);
	                            // Limit maximum value with what the user choose
	                            var currentMaxValue = parsedSeries.categoryAxisEnd ? Math.min(parsedSeries.categoryAxisEnd, maxValue) : maxValue;
	                            var formatString = dataView.categorical.values[seriesIndex].source.format;
	                            dataPoints.push({
	                                value: value,
	                                minValue: minValue,
	                                maxValue: currentMaxValue,
	                                formatString: formatString,
	                                color: parsedSeries.fill,
	                                selected: false,
	                                identity: identity,
	                                tooltipData: tooltipInfo,
	                                categoryIndex: i,
	                            });
	                            if (hasHighlights) {
	                                var highlightIdentity = SelectionId.createWithHighlight(identity);
	                                var highlight = currentSeries.highlights[i];
	                                var highlightedValue = highlight != null ? highlight : 0;
	                                tooltipInfo = TooltipBuilder.createTooltipInfo(formatStringProp, categorical, formattedCategoryValue, value, null, null, seriesIndex, i, highlightedValue);
	                                highlightedDataPoints.push({
	                                    value: highlightedValue,
	                                    minValue: minValue,
	                                    maxValue: currentMaxValue,
	                                    formatString: formatString,
	                                    color: parsedSeries.fill,
	                                    selected: false,
	                                    identity: highlightIdentity,
	                                    tooltipData: tooltipInfo,
	                                    categoryIndex: i,
	                                    highlight: true,
	                                });
	                            }
	                        }
	                    }
	                    return {
	                        categories: categoriesLabels,
	                        series: series,
	                        settings: settings,
	                        legend: TornadoChart.getLegendData(series, hasDynamicSeries),
	                        dataPoints: dataPoints,
	                        highlightedDataPoints: highlightedDataPoints,
	                        maxLabelsWidth: _.max(categoriesLabels.map(function (x) { return x.width; })),
	                        hasDynamicSeries: hasDynamicSeries,
	                        hasHighlights: hasHighlights,
	                        labelHeight: labelHeight,
	                        legendObjectProperties: DataViewObjects.getObject(dataView.metadata.objects, "legend", {}),
	                    };
	                };
	                TornadoChart.parseSeries = function (dataViewValueColumns, index, isGrouped, columnGroup, colors) {
	                    var dataViewValueColumn = dataViewValueColumns ? dataViewValueColumns[index] : null, source = dataViewValueColumn ? dataViewValueColumn.source : null, identity = columnGroup ? columnGroup.identity : null, queryName = source ? source.queryName : null;
	                    var selectionId = identity
	                        ? SelectionId.createWithId(identity)
	                        : SelectionIdBuilder.builder()
	                            .withSeries(dataViewValueColumns, columnGroup)
	                            .withMeasure(queryName)
	                            .createSelectionId();
	                    var objects, categoryAxisObject, displayName = source ? source.groupName
	                        ? source.groupName : source.displayName
	                        : null;
	                    if (isGrouped && columnGroup) {
	                        categoryAxisObject = columnGroup.objects ? columnGroup.objects['categoryAxis'] : null;
	                        objects = columnGroup.objects;
	                    }
	                    else if (source) {
	                        objects = source.objects;
	                        categoryAxisObject = objects ? objects['categoryAxis'] : null;
	                    }
	                    var color = TornadoChart.getColor(TornadoChart.Properties.dataPoint.fill, ["purple", "teal"][index], objects, colors);
	                    var categoryAxisEnd = categoryAxisObject ? categoryAxisObject['end'] : null;
	                    return {
	                        fill: color,
	                        name: displayName,
	                        selectionId: selectionId,
	                        categoryAxisEnd: categoryAxisEnd,
	                    };
	                };
	                TornadoChart.getColor = function (properties, defaultColor, objects, colors) {
	                    var colorHelper = new ColorHelper(colors, properties, defaultColor);
	                    return colorHelper.getColorForMeasure(objects, "");
	                };
	                TornadoChart.getTextData = function (text, textOptions, measureWidth, measureHeight, overrideFontSize) {
	                    if (measureWidth === void 0) { measureWidth = false; }
	                    if (measureHeight === void 0) { measureHeight = false; }
	                    var width = 0, height = 0, fontSize, textProperties;
	                    text = text || "";
	                    fontSize = overrideFontSize
	                        ? PixelConverter.fromPoint(overrideFontSize)
	                        : "" + textOptions.fontSize + textOptions.sizeUnit;
	                    textProperties = {
	                        text: text,
	                        fontFamily: textOptions.fontFamily,
	                        fontSize: fontSize
	                    };
	                    if (measureWidth) {
	                        width = TextMeasurementService.measureSvgTextWidth(textProperties);
	                    }
	                    if (measureHeight) {
	                        height = TextMeasurementService.estimateSvgTextHeight(textProperties);
	                    }
	                    return {
	                        text: text,
	                        width: width,
	                        height: height,
	                        textProperties: textProperties
	                    };
	                };
	                Object.defineProperty(TornadoChart.prototype, "allLabelsWidth", {
	                    get: function () {
	                        return (this.dataView.settings.showCategories
	                            ? Math.min(this.dataView.maxLabelsWidth, this.scrolling.scrollViewport.width / 2)
	                            : 3) + TornadoChart.CategoryLabelMargin;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(TornadoChart.prototype, "allColumnsWidth", {
	                    get: function () {
	                        return this.scrolling.scrollViewport.width - this.allLabelsWidth;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(TornadoChart.prototype, "columnWidth", {
	                    get: function () {
	                        return this.dataView.series.length === TornadoChart.MaxSeries
	                            ? this.allColumnsWidth / 2
	                            : this.allColumnsWidth;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                TornadoChart.prototype.init = function (visualInitOptions) {
	                    var _this = this;
	                    var style = visualInitOptions.style, fontSize;
	                    this.hostService = visualInitOptions.host;
	                    var element = visualInitOptions.element;
	                    this.colors = style.colorPalette.dataColors;
	                    var interactivity = visualInitOptions.interactivity;
	                    this.interactivityService = createInteractivityService(this.hostService);
	                    var root;
	                    if (this.svg)
	                        this.root = root = this.svg;
	                    else
	                        this.root = root = d3.select(element.get(0))
	                            .append("svg");
	                    root
	                        .classed(TornadoChart.ClassName, true)
	                        .style('position', 'absolute');
	                    fontSize = root.style("font-size");
	                    this.textOptions.sizeUnit = fontSize.slice(fontSize.length - 2);
	                    this.textOptions.fontSize = Number(fontSize.slice(0, fontSize.length - 2));
	                    this.textOptions.fontFamily = root.style("font-family");
	                    this.viewport = visualInitOptions.viewport;
	                    this.scrolling = new TornadoChartScrolling(function () { return root; }, function () { return _this.viewport; }, function () { return _this.margin; }, function () { return _this.dataView.categories.length * TornadoChart.CategoryMinHeight; }, true);
	                    var main = this.main = root.append("g");
	                    this.clearCatcher = appendClearCatcher(main);
	                    this.columns = main
	                        .append("g")
	                        .classed(TornadoChart.Columns.class, true);
	                    this.axes = main
	                        .append("g")
	                        .classed(TornadoChart.Axes.class, true);
	                    this.labels = main
	                        .append("g")
	                        .classed(TornadoChart.Labels.class, true);
	                    this.categories = main
	                        .append("g")
	                        .classed(TornadoChart.Categories.class, true);
	                    this.behavior = new TornadoWebBehavior();
	                    this.legend = createLegend(element, interactivity && interactivity.isInteractiveLegend, this.interactivityService, true);
	                };
	                TornadoChart.prototype.update = function (visualUpdateOptions) {
	                    if (!visualUpdateOptions ||
	                        !visualUpdateOptions.dataViews ||
	                        !visualUpdateOptions.dataViews[0]) {
	                        return;
	                    }
	                    this.viewport = {
	                        height: Math.max(0, visualUpdateOptions.viewport.height - this.margin.top - this.margin.bottom),
	                        width: Math.max(0, visualUpdateOptions.viewport.width - this.margin.left - this.margin.right)
	                    };
	                    if (this.animator)
	                        this.durationAnimations = GetAnimationDuration(this.animator, visualUpdateOptions.suppressAnimations);
	                    else
	                        this.durationAnimations = visualUpdateOptions.suppressAnimations ? 0 : 250;
	                    this.dataView = TornadoChart.converter(this.validateDataView(visualUpdateOptions.dataViews[0]), this.textOptions, this.colors);
	                    if (!this.dataView || this.scrolling.scrollViewport.height < TornadoChart.CategoryMinHeight) {
	                        this.clearData();
	                        return;
	                    }
	                    if (this.dataView && this.interactivityService) {
	                        this.interactivityService.applySelectionStateToData(this.dataView.dataPoints);
	                        this.interactivityService.applySelectionStateToData(this.dataView.highlightedDataPoints);
	                    }
	                    this.render();
	                };
	                TornadoChart.prototype.validateDataView = function (dataView) {
	                    if (!dataView || !dataView.categorical || !dataView.categorical.values) {
	                        return null;
	                    }
	                    if (dataView.categorical.values.length > TornadoChart.MaxSeries) {
	                        this.hostService.setWarnings([getTornadoChartWarning()]);
	                        return null;
	                    }
	                    return dataView;
	                };
	                TornadoChart.prototype.updateElements = function () {
	                    var elementsTranslate = SVGUtil.translate(this.allLabelsWidth, 0);
	                    this.root.attr({
	                        "height": this.viewport.height + this.margin.top + this.margin.bottom,
	                        "width": this.viewport.width + this.margin.left + this.margin.right
	                    });
	                    this.columns
	                        .attr("transform", elementsTranslate);
	                    this.labels
	                        .attr("transform", elementsTranslate);
	                    this.axes
	                        .attr("transform", elementsTranslate);
	                };
	                TornadoChart.parseSettings = function (objects, value, colors) {
	                    var precision = TornadoChart.getPrecision(objects);
	                    var displayUnits = DataViewObjects.getValue(objects, TornadoChart.Properties.labels.labelDisplayUnits, TornadoChart.DefaultTornadoChartSettings.labelSettings.displayUnits);
	                    var labelSettings = TornadoChart.DefaultTornadoChartSettings.labelSettings;
	                    var getLabelValueFormatter = function (formatString) { return valueFormatter.create({
	                        format: formatString,
	                        precision: precision,
	                        value: (displayUnits === 0) && (value != null) ? value : displayUnits,
	                    }); };
	                    return {
	                        labelOutsideFillColor: TornadoChart.getColor(TornadoChart.Properties.labels.outsideFill, TornadoChart.DefaultTornadoChartSettings.labelOutsideFillColor, objects, colors),
	                        labelSettings: {
	                            show: DataViewObjects.getValue(objects, TornadoChart.Properties.labels.show, labelSettings.show),
	                            precision: precision,
	                            fontSize: DataViewObjects.getValue(objects, TornadoChart.Properties.labels.fontSize, labelSettings.fontSize),
	                            displayUnits: displayUnits,
	                            labelColor: TornadoChart.getColor(TornadoChart.Properties.labels.insideFill, labelSettings.labelColor, objects, colors),
	                        },
	                        showCategories: DataViewObjects.getValue(objects, TornadoChart.Properties.categories.show, TornadoChart.DefaultTornadoChartSettings.showCategories),
	                        showLegend: DataViewObjects.getValue(objects, TornadoChart.Properties.legend.show, TornadoChart.DefaultTornadoChartSettings.showLegend),
	                        legendFontSize: DataViewObjects.getValue(objects, TornadoChart.Properties.legend.fontSize, TornadoChart.DefaultTornadoChartSettings.legendFontSize),
	                        legendColor: TornadoChart.getColor(TornadoChart.Properties.legend.labelColor, TornadoChart.DefaultTornadoChartSettings.legendColor, objects, colors),
	                        categoriesFillColor: TornadoChart.getColor(TornadoChart.Properties.categories.fill, TornadoChart.DefaultTornadoChartSettings.categoriesFillColor, objects, colors),
	                        getLabelValueFormatter: getLabelValueFormatter
	                    };
	                };
	                TornadoChart.getPrecision = function (objects) {
	                    var precision = DataViewObjects.getValue(objects, TornadoChart.Properties.labels.labelPrecision, TornadoChart.DefaultTornadoChartSettings.labelSettings.precision);
	                    return Math.min(Math.max(0, precision), TornadoChart.MaxPrecision);
	                };
	                TornadoChart.getLegendData = function (series, hasDynamicSeries) {
	                    var legendDataPoints = [];
	                    if (hasDynamicSeries)
	                        legendDataPoints = series.map(function (series) {
	                            return {
	                                label: series.name,
	                                color: series.fill,
	                                icon: LegendIcon.Box,
	                                selected: false,
	                                identity: series.selectionId
	                            };
	                        });
	                    return {
	                        dataPoints: legendDataPoints
	                    };
	                };
	                TornadoChart.prototype.render = function () {
	                    this.updateElements();
	                    this.renderLegend();
	                    this.scrolling.renderY(this.dataView, this.renderWithScrolling.bind(this));
	                };
	                TornadoChart.prototype.clearData = function () {
	                    this.columns.selectAll("*").remove();
	                    this.axes.selectAll("*").remove();
	                    this.labels.selectAll("*").remove();
	                    this.categories.selectAll("*").remove();
	                    this.legend.drawLegend({ dataPoints: [] }, this.viewport);
	                    this.scrolling.clearData();
	                };
	                TornadoChart.prototype.onClearSelection = function () {
	                    if (this.interactivityService)
	                        this.interactivityService.clearSelection();
	                };
	                TornadoChart.prototype.renderWithScrolling = function (tornadoChartDataView, scrollStart, scrollEnd) {
	                    if (!this.dataView || !this.dataView.settings)
	                        return;
	                    var categoriesLength = tornadoChartDataView.categories.length;
	                    var startIndex = scrollStart * categoriesLength;
	                    var endIndex = scrollEnd * categoriesLength;
	                    var startIndexRound = Math.floor(startIndex);
	                    var endIndexRound = Math.floor(endIndex);
	                    var maxValues = Math.floor(this.scrolling.scrollViewport.height / TornadoChart.CategoryMinHeight);
	                    if (scrollEnd - scrollStart < 1 && maxValues < endIndexRound - startIndexRound) {
	                        if (startIndex - startIndexRound > endIndex - endIndexRound) {
	                            startIndexRound++;
	                        }
	                        else {
	                            endIndex--;
	                        }
	                    }
	                    if (this.interactivityService) {
	                        this.interactivityService.applySelectionStateToData(tornadoChartDataView.dataPoints);
	                        this.interactivityService.applySelectionStateToData(tornadoChartDataView.highlightedDataPoints);
	                    }
	                    // Filter data according to the visible visual area
	                    tornadoChartDataView.categories = tornadoChartDataView.categories.slice(startIndexRound, endIndexRound);
	                    tornadoChartDataView.dataPoints = _.filter(tornadoChartDataView.dataPoints, function (d) { return d.categoryIndex >= startIndexRound && d.categoryIndex < endIndexRound; });
	                    tornadoChartDataView.highlightedDataPoints = _.filter(tornadoChartDataView.highlightedDataPoints, function (d) { return d.categoryIndex >= startIndexRound && d.categoryIndex < endIndexRound; });
	                    this.dataView = tornadoChartDataView;
	                    this.computeHeightColumn();
	                    this.renderMiddleSection();
	                    this.renderAxes();
	                    this.renderCategories();
	                };
	                TornadoChart.prototype.updateViewport = function () {
	                    var legendMargins = this.legend.getMargins(), legendPosition;
	                    legendPosition = LegendPosition[this.dataView.legendObjectProperties[legendProps.position]];
	                    switch (legendPosition) {
	                        case LegendPosition.Top:
	                        case LegendPosition.TopCenter:
	                        case LegendPosition.Bottom:
	                        case LegendPosition.BottomCenter: {
	                            this.viewport.height -= legendMargins.height;
	                            break;
	                        }
	                        case LegendPosition.Left:
	                        case LegendPosition.LeftCenter:
	                        case LegendPosition.Right:
	                        case LegendPosition.RightCenter: {
	                            this.viewport.width -= legendMargins.width;
	                            break;
	                        }
	                    }
	                };
	                TornadoChart.prototype.computeHeightColumn = function () {
	                    var length = this.dataView.categories.length;
	                    this.heightColumn = (this.scrolling.scrollViewport.height - ((length - 1) * this.columnPadding)) / length;
	                };
	                TornadoChart.prototype.renderMiddleSection = function () {
	                    var tornadoChartDataView = this.dataView;
	                    this.calculateDataPoints(tornadoChartDataView.dataPoints);
	                    this.calculateDataPoints(tornadoChartDataView.highlightedDataPoints);
	                    var dataPointsWithHighlights = tornadoChartDataView.dataPoints.concat(tornadoChartDataView.highlightedDataPoints);
	                    this.renderColumns(dataPointsWithHighlights, tornadoChartDataView.series.length === 2);
	                    this.renderLabels(this.dataView.hasHighlights ? tornadoChartDataView.highlightedDataPoints : tornadoChartDataView.dataPoints, tornadoChartDataView.settings.labelSettings);
	                };
	                /**
	                 * Calculate the width, dx value and label info for every data point
	                 */
	                TornadoChart.prototype.calculateDataPoints = function (dataPoints) {
	                    var categoriesLength = this.dataView.categories.length;
	                    var settings = this.dataView.settings;
	                    var heightColumn = Math.max(this.heightColumn, 0);
	                    var py = heightColumn / 2;
	                    var pyHighlighted = heightColumn * TornadoChart.HighlightedShapeFactor / 2;
	                    var maxSeries = this.dataView.series.length === TornadoChart.MaxSeries;
	                    for (var i = 0; i < dataPoints.length; i++) {
	                        var dataPoint = dataPoints[i];
	                        var shiftToMiddle = i < categoriesLength && maxSeries;
	                        var shiftToRight = i > categoriesLength - 1;
	                        var widthOfColumn = this.getColumnWidth(dataPoint.value, dataPoint.minValue, dataPoint.maxValue, this.columnWidth);
	                        var dx = (this.columnWidth - widthOfColumn) * Number(shiftToMiddle) + this.columnWidth * Number(shiftToRight);
	                        dx = Math.max(dx, 0);
	                        var highlighted = this.dataView.hasHighlights && dataPoint.highlight;
	                        var highlightOffset = highlighted ? heightColumn * (1 - TornadoChart.HighlightedShapeFactor) / 2 : 0;
	                        var dy = (heightColumn + this.columnPadding) * (i % categoriesLength) + highlightOffset;
	                        var label = this.getLabelData(dataPoint.value, dx, widthOfColumn, shiftToMiddle, dataPoint.formatString, settings);
	                        dataPoint.dx = dx;
	                        dataPoint.dy = dy;
	                        dataPoint.px = widthOfColumn / 2;
	                        dataPoint.py = highlighted ? pyHighlighted : py;
	                        dataPoint.angle = shiftToMiddle ? 180 : 0;
	                        dataPoint.width = widthOfColumn;
	                        dataPoint.height = highlighted ? heightColumn * TornadoChart.HighlightedShapeFactor : heightColumn;
	                        dataPoint.label = label;
	                    }
	                };
	                TornadoChart.prototype.renderColumns = function (columnsData, selectSecondSeries) {
	                    var _this = this;
	                    if (selectSecondSeries === void 0) { selectSecondSeries = false; }
	                    var hasSelection = this.interactivityService && this.interactivityService.hasSelection();
	                    var columnsSelection = this.columns
	                        .selectAll(TornadoChart.Column.selector)
	                        .data(columnsData);
	                    columnsSelection
	                        .enter()
	                        .append("svg:rect")
	                        .classed(TornadoChart.Column.class, true);
	                    columnsSelection
	                        .style("fill", function (p) { return p.color; })
	                        .style("fill-opacity", function (p) { return tornadoChartUtils.getFillOpacity(p.selected, p.highlight, hasSelection, _this.dataView.hasHighlights); })
	                        .attr("transform", function (p) { return SVGUtil.translateAndRotate(p.dx, p.dy, p.px, p.py, p.angle); })
	                        .attr("height", function (p) { return p.height; })
	                        .attr("width", function (p) { return p.width; });
	                    columnsSelection
	                        .exit()
	                        .remove();
	                    var interactivityService = this.interactivityService;
	                    if (interactivityService) {
	                        interactivityService.applySelectionStateToData(columnsData);
	                        var behaviorOptions = {
	                            columns: columnsSelection,
	                            clearCatcher: this.clearCatcher,
	                            interactivityService: this.interactivityService,
	                        };
	                        interactivityService.bind(columnsData, this.behavior, behaviorOptions);
	                    }
	                    this.renderTooltip(columnsSelection);
	                };
	                TornadoChart.prototype.renderTooltip = function (selection) {
	                    TooltipManager.addTooltip(selection, function (tooltipEvent) {
	                        return tooltipEvent.data.tooltipData;
	                    });
	                };
	                TornadoChart.prototype.getColumnWidth = function (value, minValue, maxValue, width) {
	                    if (minValue === maxValue) {
	                        return width;
	                    }
	                    var columnWidth = width * (value - minValue) / (maxValue - minValue);
	                    // In case the user specifies a custom category axis end we limit the
	                    // column width to the maximum available width
	                    return Math.max(0, Math.min(width, columnWidth));
	                };
	                TornadoChart.prototype.getLabelData = function (value, dxColumn, columnWidth, isColumnPositionLeft, formatStringProp, settings) {
	                    var dx, tornadoChartSettings = settings ? settings : this.dataView.settings, labelSettings = tornadoChartSettings.labelSettings, fontSize = labelSettings.fontSize, color = labelSettings.labelColor;
	                    var maxOutsideLabelWidth = isColumnPositionLeft
	                        ? dxColumn - this.leftLabelMargin
	                        : this.allColumnsWidth - (dxColumn + columnWidth + this.leftLabelMargin);
	                    var maxLabelWidth = Math.max(maxOutsideLabelWidth, columnWidth - this.leftLabelMargin);
	                    var textProperties = {
	                        fontFamily: dataLabelUtils.StandardFontFamily,
	                        fontSize: PixelConverter.fromPoint(fontSize),
	                        text: tornadoChartSettings.getLabelValueFormatter(formatStringProp).format(value)
	                    };
	                    var valueAfterValueFormatter = TextMeasurementService.getTailoredTextOrDefault(textProperties, maxLabelWidth);
	                    var textDataAfterValueFormatter = TornadoChart.getTextData(valueAfterValueFormatter, this.textOptions, true, false, fontSize);
	                    if (columnWidth > textDataAfterValueFormatter.width + TornadoChart.LabelPadding) {
	                        dx = dxColumn + columnWidth / 2 - textDataAfterValueFormatter.width / 2;
	                    }
	                    else {
	                        if (isColumnPositionLeft) {
	                            dx = dxColumn - this.leftLabelMargin - textDataAfterValueFormatter.width;
	                        }
	                        else {
	                            dx = dxColumn + columnWidth + this.leftLabelMargin;
	                        }
	                        color = tornadoChartSettings.labelOutsideFillColor;
	                    }
	                    return {
	                        dx: dx,
	                        source: value,
	                        value: valueAfterValueFormatter,
	                        color: color
	                    };
	                };
	                TornadoChart.prototype.renderAxes = function () {
	                    var linesData, axesSelection, axesElements = this.main
	                        .select(TornadoChart.Axes.selector)
	                        .selectAll(TornadoChart.Axis.selector);
	                    if (this.dataView.series.length !== TornadoChart.MaxSeries) {
	                        axesElements.remove();
	                        return;
	                    }
	                    linesData = this.generateAxesData();
	                    axesSelection = axesElements.data(linesData);
	                    axesSelection
	                        .enter()
	                        .append("svg:line")
	                        .classed(TornadoChart.Axis.class, true);
	                    axesSelection
	                        .attr("x1", function (data) { return data.x1; })
	                        .attr("y1", function (data) { return data.y1; })
	                        .attr("x2", function (data) { return data.x2; })
	                        .attr("y2", function (data) { return data.y2; });
	                    axesSelection
	                        .exit()
	                        .remove();
	                };
	                TornadoChart.prototype.generateAxesData = function () {
	                    var x, y1, y2;
	                    x = this.allColumnsWidth / 2;
	                    y1 = 0;
	                    y2 = this.scrolling.scrollViewport.height;
	                    return [{
	                            x1: x,
	                            y1: y1,
	                            x2: x,
	                            y2: y2
	                        }];
	                };
	                TornadoChart.prototype.renderLabels = function (dataPoints, labelsSettings) {
	                    var _this = this;
	                    var labelEnterSelection, labelSelection = this.main
	                        .select(TornadoChart.Labels.selector)
	                        .selectAll(TornadoChart.Label.selector)
	                        .data(_.filter(dataPoints, function (p) { return p.label.dx >= 0; }));
	                    // Check if labels can be displayed
	                    if (!labelsSettings.show || this.dataView.labelHeight >= this.heightColumn) {
	                        this.labels.selectAll("*").remove();
	                        return;
	                    }
	                    var fontSizeInPx = PixelConverter.fromPoint(labelsSettings.fontSize);
	                    var labelYOffset = this.heightColumn / 2 + this.dataView.labelHeight / 2 - this.InnerTextHeightDelta;
	                    var categoriesLength = this.dataView.categories.length;
	                    labelEnterSelection = labelSelection
	                        .enter()
	                        .append("g");
	                    labelEnterSelection
	                        .append("svg:title")
	                        .classed(TornadoChart.LabelTitle.class, true);
	                    labelEnterSelection
	                        .append("svg:text")
	                        .attr("dy", dataLabelUtils.DefaultDy)
	                        .classed(TornadoChart.LabelText.class, true);
	                    labelSelection
	                        .attr("pointer-events", "none")
	                        .classed(TornadoChart.Label.class, true);
	                    labelSelection
	                        .select(TornadoChart.LabelTitle.selector)
	                        .text(function (p) { return p.label.source; });
	                    labelSelection
	                        .attr("transform", function (p, index) {
	                        var dy = (_this.heightColumn + _this.columnPadding) * (index % categoriesLength);
	                        return SVGUtil.translate(p.label.dx, dy + labelYOffset);
	                    });
	                    labelSelection
	                        .select(TornadoChart.LabelText.selector)
	                        .attr("fill", function (p) { return p.label.color; })
	                        .attr("font-size", function (p) { return fontSizeInPx; })
	                        .text(function (p) { return p.label.value; });
	                    labelSelection
	                        .exit()
	                        .remove();
	                };
	                TornadoChart.prototype.renderCategories = function () {
	                    var _this = this;
	                    var settings = this.dataView.settings, color = settings.categoriesFillColor, categoriesEnterSelection, categoriesSelection, categoryElements = this.main
	                        .select(TornadoChart.Categories.selector)
	                        .selectAll(TornadoChart.Category.selector);
	                    if (!settings.showCategories) {
	                        categoryElements.remove();
	                        return;
	                    }
	                    categoriesSelection = categoryElements.data(this.dataView.categories);
	                    categoriesEnterSelection = categoriesSelection
	                        .enter()
	                        .append("g");
	                    categoriesEnterSelection
	                        .append("svg:title")
	                        .classed(TornadoChart.CategoryTitle.class, true);
	                    categoriesEnterSelection
	                        .append("svg:text")
	                        .classed(TornadoChart.CategoryText.class, true);
	                    categoriesSelection
	                        .attr("transform", function (text, index) {
	                        var shift = (_this.heightColumn + _this.columnPadding) * index + _this.heightColumn / 2, textData = TornadoChart.getTextData(text, _this.textOptions, false, true);
	                        shift = shift + textData.height / 2 - _this.InnerTextHeightDelta;
	                        return SVGUtil.translate(0, shift);
	                    })
	                        .classed(TornadoChart.Category.class, true);
	                    categoriesSelection
	                        .select(TornadoChart.CategoryTitle.selector)
	                        .text(function (text) { return text.text; });
	                    categoriesSelection
	                        .select(TornadoChart.CategoryText.selector)
	                        .attr("fill", color)
	                        .text(function (data) { return _this.dataView.settings.showCategories
	                        ? TextMeasurementService.getTailoredTextOrDefault(TornadoChart.getTextData(data.text, _this.textOptions).textProperties, _this.allLabelsWidth)
	                        : ""; });
	                    categoriesSelection
	                        .exit()
	                        .remove();
	                };
	                TornadoChart.prototype.renderLegend = function () {
	                    var legend = this.dataView.legend;
	                    if (!legend) {
	                        return;
	                    }
	                    var settings = this.dataView.settings;
	                    var legendData = {
	                        title: legend.title,
	                        dataPoints: legend.dataPoints,
	                        fontSize: settings.legendFontSize,
	                        labelColor: settings.legendColor,
	                    };
	                    if (this.dataView.legendObjectProperties) {
	                        var position;
	                        LegendData.update(legendData, this.dataView.legendObjectProperties);
	                        position = this.dataView.legendObjectProperties[legendProps.position];
	                        if (position) {
	                            this.legend.changeOrientation(LegendPosition[position]);
	                        }
	                    }
	                    // Draw the legend on a viewport with the original height and width
	                    var viewport = {
	                        height: this.viewport.height + this.margin.top + this.margin.bottom,
	                        width: this.viewport.width + this.margin.left + this.margin.right,
	                    };
	                    this.legend.drawLegend(legendData, viewport);
	                    Legend.positionChartArea(this.root, this.legend);
	                    if (legendData.dataPoints.length > 0 && settings.showLegend)
	                        this.updateViewport();
	                };
	                TornadoChart.prototype.enumerateObjectInstances = function (options) {
	                    var enumeration = new ObjectEnumerationBuilder(), settings;
	                    if (!this.dataView ||
	                        !this.dataView.settings) {
	                        return [];
	                    }
	                    settings = this.dataView.settings;
	                    switch (options.objectName) {
	                        case "dataPoint": {
	                            this.enumerateDataPoint(enumeration);
	                            break;
	                        }
	                        case "categoryAxis": {
	                            this.enumerateCategoryAxis(enumeration);
	                            break;
	                        }
	                        case "labels": {
	                            var labelSettings = settings.labelSettings;
	                            var labels = {
	                                objectName: "labels",
	                                displayName: "Labels",
	                                selector: null,
	                                properties: {
	                                    show: labelSettings.show,
	                                    fontSize: labelSettings.fontSize,
	                                    labelPrecision: labelSettings.precision,
	                                    labelDisplayUnits: labelSettings.displayUnits,
	                                    insideFill: labelSettings.labelColor,
	                                    outsideFill: settings.labelOutsideFillColor
	                                }
	                            };
	                            enumeration.pushInstance(labels);
	                            break;
	                        }
	                        case "legend": {
	                            if (!this.dataView.hasDynamicSeries)
	                                return;
	                            var showTitle = true, titleText = "", legend;
	                            showTitle = DataViewObject.getValue(this.dataView.legendObjectProperties, legendProps.showTitle, showTitle);
	                            titleText = DataViewObject.getValue(this.dataView.legendObjectProperties, legendProps.titleText, titleText);
	                            legend = {
	                                objectName: "legend",
	                                displayName: "Legend",
	                                selector: null,
	                                properties: {
	                                    show: settings.showLegend,
	                                    position: LegendPosition[this.legend.getOrientation()],
	                                    showTitle: showTitle,
	                                    titleText: titleText,
	                                    fontSize: settings.legendFontSize,
	                                    labelColor: settings.legendColor,
	                                }
	                            };
	                            enumeration.pushInstance(legend);
	                            break;
	                        }
	                        case "categories": {
	                            var categories = {
	                                objectName: "categories",
	                                displayName: "Categories",
	                                selector: null,
	                                properties: {
	                                    show: settings.showCategories,
	                                    fill: settings.categoriesFillColor
	                                }
	                            };
	                            enumeration.pushInstance(categories);
	                            break;
	                        }
	                    }
	                    return enumeration.complete();
	                };
	                TornadoChart.prototype.enumerateDataPoint = function (enumeration) {
	                    if (!this.dataView ||
	                        !this.dataView.series) {
	                        return;
	                    }
	                    var series = this.dataView.series;
	                    for (var i = 0, length = series.length; i < length; i++) {
	                        enumeration.pushInstance({
	                            objectName: "dataPoint",
	                            displayName: series[i].name,
	                            selector: ColorHelper.normalizeSelector(series[i].selectionId.getSelector(), false),
	                            properties: {
	                                fill: { solid: { color: series[i].fill } }
	                            }
	                        });
	                    }
	                };
	                TornadoChart.prototype.enumerateCategoryAxis = function (enumeration) {
	                    if (!this.dataView || !this.dataView.series)
	                        return;
	                    var series = this.dataView.series;
	                    for (var i = 0, length = series.length; i < length; i++) {
	                        enumeration.pushInstance({
	                            objectName: "categoryAxis",
	                            displayName: series[i].name,
	                            selector: series[i].selectionId ? series[i].selectionId.getSelector() : null,
	                            properties: {
	                                end: series[i].categoryAxisEnd,
	                            }
	                        });
	                    }
	                };
	                TornadoChart.prototype.destroy = function () {
	                    this.root = null;
	                };
	                TornadoChart.ClassName = "tornado-chart";
	                TornadoChart.capabilities = {
	                    dataRoles: [{
	                            name: "Category",
	                            kind: VisualDataRoleKind.Grouping,
	                            displayName: createDisplayNameGetter("Role_DisplayName_Group")
	                        }, {
	                            name: "Series",
	                            kind: VisualDataRoleKind.Grouping,
	                            displayName: createDisplayNameGetter('Role_DisplayName_Legend')
	                        }, {
	                            name: "Values",
	                            kind: VisualDataRoleKind.Measure,
	                            displayName: createDisplayNameGetter("Role_DisplayName_Values")
	                        }],
	                    dataViewMappings: [{
	                            conditions: [
	                                { "Category": { max: 1 }, "Values": { min: 0, max: 1 }, "Series": { min: 0, max: 1 } },
	                                { "Category": { max: 1 }, "Values": { min: 2, max: 2 }, "Series": { max: 0 } }
	                            ],
	                            categorical: {
	                                categories: {
	                                    for: {
	                                        in: "Category"
	                                    }
	                                },
	                                values: {
	                                    group: {
	                                        by: "Series",
	                                        select: [{ for: { in: "Values" } }],
	                                        dataReductionAlgorithm: { top: {} }
	                                    }
	                                }
	                            }
	                        }],
	                    objects: {
	                        general: {
	                            displayName: 'General',
	                            properties: {
	                                formatString: {
	                                    type: {
	                                        formatting: {
	                                            formatString: true
	                                        }
	                                    },
	                                }
	                            }
	                        },
	                        dataPoint: {
	                            displayName: 'Data Colors',
	                            properties: {
	                                fill: {
	                                    displayName: createDisplayNameGetter('Visual_Fill'),
	                                    type: { fill: { solid: { color: true } } }
	                                }
	                            }
	                        },
	                        categoryAxis: {
	                            displayName: 'X-Axis',
	                            properties: {
	                                end: {
	                                    displayName: 'End',
	                                    type: { numeric: true },
	                                    suppressFormatPainterCopy: true,
	                                },
	                            }
	                        },
	                        labels: {
	                            displayName: 'Data Labels',
	                            properties: {
	                                show: {
	                                    displayName: 'Show',
	                                    type: { bool: true }
	                                },
	                                labelPrecision: {
	                                    displayName: 'Decimal Places',
	                                    placeHolderText: 'Auto',
	                                    type: { numeric: true }
	                                },
	                                fontSize: {
	                                    displayName: createDisplayNameGetter('Visual_TextSize'),
	                                    type: { formatting: { fontSize: true } }
	                                },
	                                labelDisplayUnits: {
	                                    displayName: 'Display Units',
	                                    type: { formatting: { labelDisplayUnits: true } },
	                                },
	                                insideFill: {
	                                    displayName: 'Inside fill',
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                outsideFill: {
	                                    displayName: 'Outside fill',
	                                    type: { fill: { solid: { color: true } } }
	                                }
	                            }
	                        },
	                        legend: {
	                            displayName: 'Legend',
	                            properties: {
	                                show: {
	                                    displayName: 'Show',
	                                    type: { bool: true }
	                                },
	                                position: {
	                                    displayName: 'Position',
	                                    description: createDisplayNameGetter('Visual_LegendPositionDescription'),
	                                    type: { enumeration: legendPosition.type }
	                                },
	                                showTitle: {
	                                    displayName: 'Title',
	                                    description: createDisplayNameGetter('Visual_LegendShowTitleDescription'),
	                                    type: { bool: true }
	                                },
	                                titleText: {
	                                    displayName: 'Legend Name',
	                                    description: createDisplayNameGetter('Visual_LegendNameDescription'),
	                                    type: { text: true }
	                                },
	                                labelColor: {
	                                    displayName: 'Color',
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                fontSize: {
	                                    displayName: 'TextSize',
	                                    type: { formatting: { fontSize: true } }
	                                },
	                            }
	                        },
	                        categories: {
	                            displayName: 'Group',
	                            properties: {
	                                show: {
	                                    displayName: 'Show',
	                                    type: { bool: true }
	                                },
	                                fill: {
	                                    displayName: 'Color',
	                                    type: { fill: { solid: { color: true } } }
	                                }
	                            }
	                        }
	                    },
	                    supportsHighlight: true,
	                };
	                TornadoChart.Properties = TornadoChart.getProperties(TornadoChart.capabilities);
	                TornadoChart.Columns = {
	                    "class": "columns",
	                    selector: ".columns"
	                };
	                TornadoChart.Column = {
	                    "class": "column",
	                    selector: ".column"
	                };
	                TornadoChart.Axes = {
	                    "class": "axes",
	                    selector: ".axes"
	                };
	                TornadoChart.Axis = {
	                    "class": "axis",
	                    selector: ".axis"
	                };
	                TornadoChart.Labels = {
	                    "class": "labels",
	                    selector: ".labels"
	                };
	                TornadoChart.Label = {
	                    "class": "label",
	                    selector: ".label"
	                };
	                TornadoChart.LabelTitle = {
	                    "class": "label-title",
	                    selector: ".label-title"
	                };
	                TornadoChart.LabelText = {
	                    "class": "label-text",
	                    selector: ".label-text"
	                };
	                TornadoChart.Categories = {
	                    "class": "categories",
	                    selector: ".categories"
	                };
	                TornadoChart.Category = {
	                    "class": "category",
	                    selector: ".category"
	                };
	                TornadoChart.CategoryTitle = {
	                    "class": "category-title",
	                    selector: ".category-title"
	                };
	                TornadoChart.CategoryText = {
	                    "class": "category-text",
	                    selector: ".category-text"
	                };
	                TornadoChart.MaxSeries = 2;
	                TornadoChart.MaxPrecision = 17; // max number of decimals in float
	                TornadoChart.LabelPadding = 2.5;
	                TornadoChart.CategoryMinHeight = 25;
	                TornadoChart.DefaultFontSize = 9;
	                TornadoChart.DefaultLegendFontSize = 8;
	                TornadoChart.HighlightedShapeFactor = 0.5;
	                TornadoChart.CategoryLabelMargin = 10;
	                TornadoChart.ScrollBarWidth = 22;
	                TornadoChart.DefaultTornadoChartSettings = {
	                    labelOutsideFillColor: dataLabelUtils.defaultLabelColor,
	                    labelSettings: {
	                        show: true,
	                        precision: null,
	                        fontSize: TornadoChart.DefaultFontSize,
	                        displayUnits: 0,
	                        labelColor: dataLabelUtils.defaultInsideLabelColor,
	                    },
	                    showCategories: true,
	                    showLegend: true,
	                    legendFontSize: TornadoChart.DefaultLegendFontSize,
	                    legendColor: LegendData.DefaultLegendLabelFillColor,
	                    categoriesFillColor: "#777"
	                };
	                return TornadoChart;
	            }());
	            samples.TornadoChart = TornadoChart;
	            var tornadoChartUtils;
	            (function (tornadoChartUtils) {
	                tornadoChartUtils.DimmedOpacity = 0.4;
	                tornadoChartUtils.DefaultOpacity = 1.0;
	                function getFillOpacity(selected, highlight, hasSelection, hasPartialHighlights) {
	                    if ((hasPartialHighlights && !highlight) || (hasSelection && !selected))
	                        return tornadoChartUtils.DimmedOpacity;
	                    return tornadoChartUtils.DefaultOpacity;
	                }
	                tornadoChartUtils.getFillOpacity = getFillOpacity;
	            })(tornadoChartUtils = samples.tornadoChartUtils || (samples.tornadoChartUtils = {}));
	        })(samples = visuals.samples || (visuals.samples = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 40 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../../../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var samples;
	        (function (samples) {
	            var EnumExtensions = jsCommon.EnumExtensions;
	            var PixelConverter = jsCommon.PixelConverter;
	            var ArrayExtensions = jsCommon.ArrayExtensions;
	            var WordBreaker = jsCommon.WordBreaker;
	            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
	            var NewDataLabelUtils = powerbi.visuals.NewDataLabelUtils;
	            var AxisHelper = powerbi.visuals.AxisHelper;
	            var valueFormatter = powerbi.visuals.valueFormatter;
	            var Double = powerbi.Double;
	            var TextMeasurementService = powerbi.TextMeasurementService;
	            var VisualDataRoleKind = powerbi.VisualDataRoleKind;
	            var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
	            var LegendData = powerbi.visuals.LegendData;
	            var DataViewObject = powerbi.DataViewObject;
	            var InteractivityUtils = powerbi.visuals.InteractivityUtils;
	            var yAxisPosition = powerbi.visuals.yAxisPosition;
	            var appendClearCatcher = powerbi.visuals.appendClearCatcher;
	            var createInteractivityService = powerbi.visuals.createInteractivityService;
	            var createLegend = powerbi.visuals.createLegend;
	            var SVGUtil = powerbi.visuals.SVGUtil;
	            var DataViewObjects = powerbi.DataViewObjects;
	            var axisType = powerbi.visuals.axisType;
	            var getInvalidValueWarnings = powerbi.visuals.getInvalidValueWarnings;
	            var dataLabelUtils = powerbi.visuals.dataLabelUtils;
	            var ObjectEnumerationBuilder = powerbi.visuals.ObjectEnumerationBuilder;
	            var legendProps = powerbi.visuals.legendProps;
	            var LegendPosition = powerbi.visuals.LegendPosition;
	            var axisScale = powerbi.visuals.axisScale;
	            var axisStyle = powerbi.visuals.axisStyle;
	            var Prototype = powerbi.Prototype;
	            var GetAnimationDuration = powerbi.visuals.AnimatorCommon.GetAnimationDuration;
	            var LabelLayout = powerbi.LabelLayout;
	            var converterHelper = powerbi.visuals.converterHelper;
	            var SelectionIdBuilder = powerbi.visuals.SelectionIdBuilder;
	            var TooltipBuilder = powerbi.visuals.TooltipBuilder;
	            var SelectionId = powerbi.visuals.SelectionId;
	            var GradientUtils = powerbi.visuals.GradientUtils;
	            var ColorHelper = powerbi.visuals.ColorHelper;
	            var LegendIcon = powerbi.visuals.LegendIcon;
	            var TooltipManager = powerbi.visuals.TooltipManager;
	            var flagBar = 1 << 1;
	            var flagColumn = 1 << 2;
	            var flagClustered = 1 << 3;
	            var flagStacked = 1 << 4;
	            var flagStacked100 = flagStacked | (1 << 5);
	            (function (MekkoVisualChartType) {
	                MekkoVisualChartType[MekkoVisualChartType["clusteredBar"] = flagBar | flagClustered] = "clusteredBar";
	                MekkoVisualChartType[MekkoVisualChartType["clusteredColumn"] = flagColumn | flagClustered] = "clusteredColumn";
	                MekkoVisualChartType[MekkoVisualChartType["hundredPercentStackedBar"] = flagBar | flagStacked100] = "hundredPercentStackedBar";
	                MekkoVisualChartType[MekkoVisualChartType["hundredPercentStackedColumn"] = flagColumn | flagStacked100] = "hundredPercentStackedColumn";
	                MekkoVisualChartType[MekkoVisualChartType["stackedBar"] = flagBar | flagStacked] = "stackedBar";
	                MekkoVisualChartType[MekkoVisualChartType["stackedColumn"] = flagColumn | flagStacked] = "stackedColumn";
	            })(samples.MekkoVisualChartType || (samples.MekkoVisualChartType = {}));
	            var MekkoVisualChartType = samples.MekkoVisualChartType;
	            (function (MekkoChartType) {
	                MekkoChartType[MekkoChartType["HundredPercentStackedColumn"] = 0] = "HundredPercentStackedColumn";
	            })(samples.MekkoChartType || (samples.MekkoChartType = {}));
	            var MekkoChartType = samples.MekkoChartType;
	            var MekkoDataWrapper = (function () {
	                function MekkoDataWrapper(columnChartData, isScalar) {
	                    this.data = columnChartData;
	                    this.isScalar = isScalar;
	                }
	                MekkoDataWrapper.prototype.lookupXValue = function (index, type) {
	                    debug.assertValue(this.data, 'this.data');
	                    var isDateTime = AxisHelper.isDateTime(type);
	                    if (isDateTime && this.isScalar) {
	                        return new Date(index);
	                    }
	                    var data = this.data;
	                    if (type.text) {
	                        debug.assert(index < data.categories.length, 'category index out of range');
	                        return data.categories[index];
	                    }
	                    else {
	                        var firstSeries = data.series[0];
	                        if (firstSeries) {
	                            var seriesValues = firstSeries.data;
	                            if (seriesValues) {
	                                if (this.data.hasHighlights) {
	                                    index = index * 2;
	                                }
	                                var dataPoint = seriesValues[index];
	                                if (dataPoint) {
	                                    if (isDateTime) {
	                                        return new Date(dataPoint.categoryValue);
	                                    }
	                                    return dataPoint.categoryValue;
	                                }
	                            }
	                        }
	                    }
	                    return index;
	                };
	                return MekkoDataWrapper;
	            }());
	            samples.MekkoDataWrapper = MekkoDataWrapper;
	            var MekkoChartStrategy = (function () {
	                function MekkoChartStrategy() {
	                }
	                MekkoChartStrategy.prototype.setupVisualProps = function (columnChartProps) {
	                    this.graphicsContext = columnChartProps;
	                    this.margin = columnChartProps.margin;
	                    this.width = this.graphicsContext.width;
	                    this.height = this.graphicsContext.height;
	                    this.categoryLayout = columnChartProps.layout;
	                    this.animator = columnChartProps.animator;
	                    this.interactivityService = columnChartProps.interactivityService;
	                    this.viewportHeight = columnChartProps.viewportHeight;
	                    this.viewportWidth = columnChartProps.viewportWidth;
	                };
	                MekkoChartStrategy.prototype.setData = function (data) {
	                    this.data = data;
	                };
	                MekkoChartStrategy.createFormatter = function (scaleDomain, dataDomain, dataType, isScalar, formatString, bestTickCount, tickValues, getValueFn, useTickIntervalForDisplayUnits) {
	                    if (useTickIntervalForDisplayUnits === void 0) { useTickIntervalForDisplayUnits = false; }
	                    var formatter;
	                    if (dataType.dateTime) {
	                        if (isScalar) {
	                            var value = new Date(scaleDomain[0]);
	                            var value2 = new Date(scaleDomain[1]);
	                            // datetime with only one value needs to pass the same value
	                            // (from the original dataDomain value, not the adjusted scaleDomain)
	                            // so formatting works correctly.
	                            if (bestTickCount === 1)
	                                value = value2 = new Date(dataDomain[0]);
	                            formatter = valueFormatter.create({ format: formatString, value: value, value2: value2, tickCount: bestTickCount });
	                        }
	                        else {
	                            if (getValueFn == null) {
	                                debug.assertFail('getValueFn must be supplied for ordinal datetime tickValues');
	                            }
	                            var minDate = getValueFn(0, dataType);
	                            var maxDate = getValueFn(scaleDomain.length - 1, dataType);
	                            formatter = valueFormatter.create({ format: formatString, value: minDate, value2: maxDate, tickCount: bestTickCount });
	                        }
	                    }
	                    else {
	                        if (getValueFn == null && !isScalar) {
	                            debug.assertFail('getValueFn must be supplied for ordinal tickValues');
	                        }
	                        if (useTickIntervalForDisplayUnits && isScalar && tickValues.length > 1) {
	                            var domainMin = tickValues[1] - tickValues[0];
	                            var domainMax = 0; //force tickInterval to be used with display units
	                            formatter = valueFormatter.create({ format: formatString, value: domainMin, value2: domainMax, allowFormatBeautification: true });
	                        }
	                        else {
	                            // do not use display units, just the basic value formatter
	                            // datetime is handled above, so we are ordinal and either boolean, numeric, or text.
	                            formatter = valueFormatter.createDefaultFormatter(formatString, true);
	                        }
	                    }
	                    return formatter;
	                };
	                /**
	                 * Format the linear tick labels or the category labels.
	                 */
	                MekkoChartStrategy.formatAxisTickValues = function (axis, tickValues, formatter, dataType, isScalar, getValueFn) {
	                    var formattedTickValues = [];
	                    if (formatter) {
	                        // getValueFn takes an ordinal axis index or builds DateTime from milliseconds, do not pass a numeric scalar value.
	                        if (getValueFn && !(dataType.numeric && isScalar)) {
	                            axis.tickFormat(function (d) { return formatter.format(getValueFn(d, dataType)); });
	                            formattedTickValues = tickValues.map(function (d) { return formatter.format(getValueFn(d, dataType)); });
	                        }
	                        else {
	                            axis.tickFormat(function (d) { return formatter.format(d); });
	                            formattedTickValues = tickValues.map(function (d) { return formatter.format(d); });
	                        }
	                    }
	                    else {
	                        formattedTickValues = tickValues.map(function (d) { return getValueFn(d, dataType); });
	                    }
	                    return formattedTickValues;
	                };
	                /**
	                 * Create a D3 axis including scale. Can be vertical or horizontal, and either datetime, numeric, or text.
	                 * @param options The properties used to create the axis.
	                 */
	                MekkoChartStrategy.prototype.createAxis = function (options) {
	                    var pixelSpan = options.pixelSpan, dataDomain = options.dataDomain, metaDataColumn = options.metaDataColumn, formatStringProp = options.formatStringProp, outerPadding = options.outerPadding || 0, isCategoryAxis = !!options.isCategoryAxis, isScalar = !!options.isScalar, isVertical = !!options.isVertical, useTickIntervalForDisplayUnits = !!options.useTickIntervalForDisplayUnits, // DEPRECATE: same meaning as isScalar?
	                    getValueFn = options.getValueFn, categoryThickness = options.categoryThickness;
	                    var formatString = valueFormatter.getFormatString(metaDataColumn, formatStringProp);
	                    var dataType = AxisHelper.getCategoryValueType(metaDataColumn, isScalar);
	                    var isLogScaleAllowed = AxisHelper.isLogScalePossible(dataDomain, dataType);
	                    var scale = d3.scale.linear();
	                    var scaleDomain = [0, 1];
	                    var bestTickCount = dataDomain.length || 1;
	                    var borderWidth = MekkoColumnChart.getBorderWidth(options.borderSettings);
	                    var chartWidth = pixelSpan - borderWidth * (bestTickCount - 1);
	                    if (chartWidth < MekkoChart.MinOrdinalRectThickness) {
	                        chartWidth = MekkoChart.MinOrdinalRectThickness;
	                    }
	                    scale.domain(scaleDomain)
	                        .range([0, chartWidth]);
	                    var tickValues = dataDomain;
	                    var formatter = MekkoChartStrategy.createFormatter(scaleDomain, dataDomain, dataType, isScalar, formatString, bestTickCount, tickValues, getValueFn, useTickIntervalForDisplayUnits);
	                    // sets default orientation only, cartesianChart will fix y2 for comboChart
	                    // tickSize(pixelSpan) is used to create gridLines
	                    var axis = d3.svg.axis()
	                        .scale(scale)
	                        .tickSize(6, 0)
	                        .orient(isVertical ? 'left' : 'bottom')
	                        .ticks(bestTickCount)
	                        .tickValues(dataDomain);
	                    var formattedTickValues = [];
	                    if (metaDataColumn) {
	                        formattedTickValues = MekkoChartStrategy.formatAxisTickValues(axis, tickValues, formatter, dataType, isScalar, getValueFn);
	                    }
	                    var xLabelMaxWidth;
	                    // Use category layout of labels if specified, otherwise use scalar layout of labels
	                    if (!isScalar && categoryThickness) {
	                        xLabelMaxWidth = Math.max(1, categoryThickness - MekkoChart.TickLabelPadding * 2);
	                    }
	                    else {
	                        // When there are 0 or 1 ticks, then xLabelMaxWidth = pixelSpan
	                        // When there is > 1 ticks then we need to +1 so that their widths don't overlap
	                        // Example: 2 ticks are drawn at 33.33% and 66.66%, their width needs to be 33.33% so they don't overlap.
	                        var labelAreaCount = tickValues.length > 1 ? tickValues.length + 1 : tickValues.length;
	                        xLabelMaxWidth = labelAreaCount > 1 ? pixelSpan / labelAreaCount : pixelSpan;
	                        xLabelMaxWidth = Math.max(1, xLabelMaxWidth - MekkoChart.TickLabelPadding * 2);
	                    }
	                    return {
	                        scale: scale,
	                        axis: axis,
	                        formatter: formatter,
	                        values: formattedTickValues,
	                        axisType: dataType,
	                        axisLabel: null,
	                        isCategoryAxis: isCategoryAxis,
	                        xLabelMaxWidth: xLabelMaxWidth,
	                        categoryThickness: categoryThickness,
	                        outerPadding: outerPadding,
	                        usingDefaultDomain: false,
	                        isLogScaleAllowed: isLogScaleAllowed
	                    };
	                };
	                MekkoChartStrategy.prototype.getCategoryAxis = function (data, size, layout, isVertical, forcedXMin, forcedXMax, axisScaleType) {
	                    var categoryThickness = layout.categoryThickness;
	                    var isScalar = layout.isScalar;
	                    var outerPaddingRatio = layout.outerPaddingRatio;
	                    var dw = new MekkoDataWrapper(data, isScalar);
	                    var domain = [];
	                    if (data.series &&
	                        (data.series.length > 0) &&
	                        data.series[0].data &&
	                        (data.series[0].data.length > 0)) {
	                        var domainDoubles = data.series[0].data.map(function (item) {
	                            return item.originalPosition + (item.value / 2);
	                        });
	                        domain = domainDoubles.filter(function (item, pos) {
	                            return domainDoubles.indexOf(item) === pos;
	                        });
	                    }
	                    var axisProperties = this.createAxis({
	                        pixelSpan: size,
	                        dataDomain: domain,
	                        metaDataColumn: data.categoryMetadata,
	                        formatStringProp: MekkoChart.Properties["general"]["formatString"],
	                        outerPadding: categoryThickness * outerPaddingRatio,
	                        isCategoryAxis: true,
	                        isScalar: isScalar,
	                        isVertical: isVertical,
	                        categoryThickness: categoryThickness,
	                        useTickIntervalForDisplayUnits: true,
	                        getValueFn: function (index, type) {
	                            var domainIndex = domain.indexOf(index);
	                            var value = dw.lookupXValue(domainIndex, type);
	                            return value;
	                        },
	                        scaleType: axisScaleType,
	                        borderSettings: data.borderSettings
	                    });
	                    // intentionally updating the input layout by ref
	                    layout.categoryThickness = axisProperties.categoryThickness;
	                    return axisProperties;
	                };
	                MekkoChartStrategy.prototype.setXScale = function (is100Pct, forcedTickCount, forcedXDomain, axisScaleType) {
	                    var width = this.width;
	                    var forcedXMin, forcedXMax;
	                    if (forcedXDomain && forcedXDomain.length === 2) {
	                        forcedXMin = forcedXDomain[0];
	                        forcedXMax = forcedXDomain[1];
	                    }
	                    var props = this.xProps = this.getCategoryAxis(this.data, width, this.categoryLayout, false, forcedXMin, forcedXMax, axisScaleType);
	                    return props;
	                };
	                MekkoChartStrategy.prototype.setYScale = function (is100Pct, forcedTickCount, forcedYDomain, axisScaleType) {
	                    var height = this.viewportHeight;
	                    var valueDomain = MekkoChartUtils.calcValueDomain(this.data.series, is100Pct);
	                    var valueDomainArr = [valueDomain.min, valueDomain.max];
	                    var combinedDomain = AxisHelper.combineDomain(forcedYDomain, valueDomainArr);
	                    var shouldClamp = AxisHelper.scaleShouldClamp(combinedDomain, valueDomainArr);
	                    var metadataColumn = this.data.valuesMetadata[0];
	                    var formatString = is100Pct ?
	                        this.graphicsContext.hostService.getLocalizedString('Percentage')
	                        : valueFormatter.getFormatString(metadataColumn, MekkoChart.Properties["general"]["formatString"]);
	                    var mekkoMekkoCreateAxisOptions = {
	                        pixelSpan: height,
	                        dataDomain: combinedDomain,
	                        metaDataColumn: metadataColumn,
	                        formatString: formatString,
	                        outerPadding: 0,
	                        isScalar: true,
	                        isVertical: true,
	                        forcedTickCount: forcedTickCount,
	                        useTickIntervalForDisplayUnits: true,
	                        isCategoryAxis: false,
	                        scaleType: axisScaleType,
	                        axisDisplayUnits: 0,
	                        axisPrecision: 0,
	                        is100Pct: is100Pct,
	                        shouldClamp: shouldClamp,
	                        formatStringProp: undefined,
	                    };
	                    this.yProps = AxisHelper.createAxis(mekkoMekkoCreateAxisOptions);
	                    return this.yProps;
	                };
	                MekkoChartStrategy.prototype.drawColumns = function (useAnimation) {
	                    var data = this.data;
	                    debug.assertValue(data, 'data should not be null or undefined');
	                    this.columnsCenters = null; // invalidate the columnsCenters so that will be calculated again
	                    var axisOptions = {
	                        columnWidth: 0,
	                        xScale: this.xProps.scale,
	                        yScale: this.yProps.scale,
	                        isScalar: this.categoryLayout.isScalar,
	                        margin: this.margin,
	                    };
	                    var stackedColumnLayout = this.layout = MekkoChartStrategy.getLayout(data, axisOptions);
	                    //var dataLabelSettings = data.labelSettings;
	                    var labelDataPoints = this.createMekkoLabelDataPoints();
	                    var result;
	                    var shapes;
	                    var series = MekkoChartUtils.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);
	                    if (this.animator && useAnimation) {
	                        result = this.animator.animate({
	                            viewModel: data,
	                            series: series,
	                            layout: stackedColumnLayout,
	                            itemCS: MekkoChartStrategy.Classes["item"],
	                            interactivityService: this.interactivityService,
	                            mainGraphicsContext: this.graphicsContext.mainGraphicsContext,
	                            viewPort: { height: this.height, width: this.width },
	                        });
	                        shapes = result.shapes;
	                    }
	                    if (!this.animator || !useAnimation || result.failed) {
	                        shapes = MekkoChartStrategy.drawDefaultShapes(data, series, stackedColumnLayout, MekkoChartStrategy.Classes["item"], !this.animator, this.interactivityService && this.interactivityService.hasSelection());
	                    }
	                    MekkoChartUtils.applyInteractivity(shapes, this.graphicsContext.onDragStart);
	                    return {
	                        shapesSelection: shapes,
	                        viewport: { height: this.height, width: this.width },
	                        axisOptions: axisOptions,
	                        labelDataPoints: labelDataPoints,
	                    };
	                };
	                MekkoChartStrategy.drawDefaultShapes = function (data, series, layout, itemCS, filterZeros, hasSelection) {
	                    // We filter out invisible (0, null, etc.) values from the dataset
	                    // based on whether animations are enabled or not, Dashboard and
	                    // Exploration mode, respectively.
	                    var rectName = 'rect';
	                    filterZeros = false;
	                    var dataSelector;
	                    if (filterZeros) {
	                        dataSelector = function (d) {
	                            var filteredData = _.filter(d.data, function (datapoint) { return !!datapoint.value; });
	                            return filteredData;
	                        };
	                    }
	                    else {
	                        dataSelector = function (d) { return d.data; };
	                    }
	                    var shapeSelection = series.selectAll(itemCS.selector);
	                    var shapes = shapeSelection.data(dataSelector, function (d) { return d.key; });
	                    shapes.enter()
	                        .append(rectName)
	                        .attr("class", function (d) { return itemCS.class.concat(d.highlight ? " highlight" : ""); });
	                    shapes
	                        .style("fill", function (d) { return d.color; })
	                        .style("fill-opacity", function (d) { return MekkoChartUtils.getFillOpacity(d.selected, d.highlight, hasSelection, data.hasHighlights); })
	                        .attr(layout.shapeLayout);
	                    shapes
	                        .exit()
	                        .remove();
	                    var borderSelection = series.selectAll(MekkoColumnChart.BorderClass.selector);
	                    var borders = borderSelection.data(dataSelector, function (d) { return d.key; });
	                    var borderColor = MekkoColumnChart.getBorderColor(data.borderSettings);
	                    borders.enter()
	                        .append(rectName)
	                        .classed(MekkoColumnChart.BorderClass.class, true);
	                    borders
	                        .style("fill", function (d) { return borderColor; })
	                        .style("fill-opacity", function (d) {
	                        return data.hasHighlights
	                            ? MekkoChartUtils.DimmedOpacity
	                            : MekkoChartUtils.DefaultOpacity;
	                    })
	                        .attr(layout.shapeBorder);
	                    borders
	                        .exit()
	                        .remove();
	                    return shapes;
	                };
	                MekkoChartStrategy.prototype.selectColumn = function (selectedColumnIndex, lastSelectedColumnIndex) {
	                    MekkoChartUtils.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, MekkoChartStrategy.Classes["item"].selector, selectedColumnIndex, lastSelectedColumnIndex);
	                    this.moveHandle(selectedColumnIndex);
	                };
	                MekkoChartStrategy.prototype.getClosestColumnIndex = function (x, y) {
	                    return MekkoChartUtils.getClosestColumnIndex(x, this.getColumnsCenters());
	                };
	                /**
	                 * Get the chart's columns centers (x value).
	                 */
	                MekkoChartStrategy.prototype.getColumnsCenters = function () {
	                    var _this = this;
	                    if (!this.columnsCenters) {
	                        var categoryWidth = this.categoryLayout.categoryThickness * (1 - MekkoChart.InnerPaddingRatio);
	                        // use the axis scale and first series data to get category centers
	                        if (this.data.series.length > 0) {
	                            var xScaleOffset = 0;
	                            if (!this.categoryLayout.isScalar) {
	                                xScaleOffset = categoryWidth / 2;
	                            }
	                            var firstSeries = this.data.series[0];
	                            if (firstSeries &&
	                                firstSeries.data) {
	                                this.columnsCenters = firstSeries.data.map(function (d) { return _this.xProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + xScaleOffset; });
	                            }
	                        }
	                    }
	                    return this.columnsCenters;
	                };
	                MekkoChartStrategy.prototype.moveHandle = function (selectedColumnIndex) {
	                    var columnCenters = this.getColumnsCenters();
	                    var x = columnCenters[selectedColumnIndex];
	                    if (!this.columnSelectionLineHandle) {
	                        var handle = this.columnSelectionLineHandle = this.graphicsContext.mainGraphicsContext.append('g');
	                        handle.append('line')
	                            .classed('interactive-hover-line', true)
	                            .attr({
	                            x1: x,
	                            x2: x,
	                            y1: 0,
	                            y2: this.height,
	                        });
	                        handle.append('circle')
	                            .attr({
	                            cx: x,
	                            cy: this.height,
	                            r: '6px',
	                        })
	                            .classed('drag-handle', true);
	                    }
	                    else {
	                        var handle = this.columnSelectionLineHandle;
	                        handle.select('line').attr({ x1: x, x2: x });
	                        handle.select('circle').attr({ cx: x });
	                    }
	                };
	                MekkoChartStrategy.getLayout = function (data, axisOptions) {
	                    var xScale = axisOptions.xScale;
	                    var yScale = axisOptions.yScale;
	                    var scaledY0 = yScale(0);
	                    var scaledX0 = xScale(0);
	                    var borderWidth = MekkoColumnChart.getBorderWidth(data.borderSettings);
	                    var columnWidthScale = function (d) {
	                        var value = AxisHelper.diffScaled(xScale, d.value, 0);
	                        return value;
	                    };
	                    var columnStart = function (d) {
	                        var value = scaledX0 +
	                            AxisHelper.diffScaled(xScale, d.originalPosition, 0) +
	                            borderWidth * d.categoryIndex;
	                        return value;
	                    };
	                    var borderStart = function (d) {
	                        var value = scaledX0 +
	                            AxisHelper.diffScaled(xScale, d.originalPosition, 0) +
	                            AxisHelper.diffScaled(xScale, d.value, 0) +
	                            borderWidth * d.categoryIndex;
	                        return value;
	                    };
	                    return {
	                        shapeLayout: {
	                            width: columnWidthScale,
	                            x: columnStart,
	                            y: function (d) { return scaledY0 + AxisHelper.diffScaled(yScale, d.position, 0); },
	                            height: function (d) { return MekkoChartUtils.getSize(yScale, d.valueAbsolute); }
	                        },
	                        shapeBorder: {
	                            width: function (d) { return borderWidth; },
	                            x: borderStart,
	                            y: function (d) { return scaledY0 + AxisHelper.diffScaled(yScale, d.position, 0); },
	                            height: function (d) { return MekkoChartUtils.getSize(yScale, d.valueAbsolute); }
	                        },
	                        shapeLayoutWithoutHighlights: {
	                            width: columnWidthScale,
	                            x: columnStart,
	                            y: function (d) { return scaledY0 + AxisHelper.diffScaled(yScale, d.position, 0); },
	                            height: function (d) { return MekkoChartUtils.getSize(yScale, d.originalValueAbsolute); }
	                        },
	                        zeroShapeLayout: {
	                            width: columnWidthScale,
	                            x: columnStart,
	                            y: function (d) { return scaledY0 + AxisHelper.diffScaled(yScale, d.position, 0) + MekkoChartUtils.getSize(yScale, d.valueAbsolute); },
	                            height: function (d) { return 0; }
	                        },
	                        shapeXAxis: {
	                            width: columnWidthScale,
	                            x: columnStart,
	                            y: function (d) { return scaledY0 + AxisHelper.diffScaled(yScale, d.position, 0); },
	                            height: function (d) { return MekkoChartUtils.getSize(yScale, d.valueAbsolute); }
	                        },
	                    };
	                };
	                MekkoChartStrategy.prototype.createMekkoLabelDataPoints = function () {
	                    var labelDataPoints = [];
	                    var data = this.data;
	                    var series = data.series;
	                    var formattersCache = NewDataLabelUtils.createColumnFormatterCacheManager();
	                    var shapeLayout = this.layout.shapeLayout;
	                    for (var i = 0, ilen = series.length; i < ilen; i++) {
	                        var currentSeries = series[i];
	                        var labelSettings = currentSeries.labelSettings ? currentSeries.labelSettings : data.labelSettings;
	                        if (!labelSettings.show) {
	                            continue;
	                        }
	                        if (!currentSeries.data) {
	                            continue;
	                        }
	                        var axisFormatter = NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yProps.formatter, labelSettings);
	                        for (var j = 0; j < currentSeries.data.length; j++) {
	                            var dataPoint = currentSeries.data[j];
	                            if ((data.hasHighlights && !dataPoint.highlight) || dataPoint.value == null) {
	                                continue;
	                            }
	                            // Calculate parent rectangle
	                            var parentRect = {
	                                left: shapeLayout.x(dataPoint),
	                                top: shapeLayout.y(dataPoint),
	                                width: shapeLayout.width(dataPoint),
	                                height: shapeLayout.height(dataPoint),
	                            };
	                            // Calculate label text
	                            var formatString = null;
	                            var value = dataPoint.valueOriginal;
	                            if (!labelSettings.displayUnits) {
	                                formatString = NewDataLabelUtils.hundredPercentFormat;
	                                value = dataPoint.valueAbsolute;
	                            }
	                            var formatter = formattersCache.getOrCreate(formatString, labelSettings, axisFormatter);
	                            var text = NewDataLabelUtils.getLabelFormattedText(formatter.format(value));
	                            // Calculate text size
	                            var properties = {
	                                text: text,
	                                fontFamily: NewDataLabelUtils.LabelTextProperties.fontFamily,
	                                fontSize: NewDataLabelUtils.LabelTextProperties.fontSize,
	                                fontWeight: NewDataLabelUtils.LabelTextProperties.fontWeight,
	                            };
	                            var textWidth = TextMeasurementService.measureSvgTextWidth(properties);
	                            var textHeight = TextMeasurementService.estimateSvgTextHeight(properties);
	                            labelDataPoints.push({
	                                isPreferred: true,
	                                text: text,
	                                textSize: {
	                                    width: textWidth,
	                                    height: textHeight,
	                                },
	                                outsideFill: labelSettings.labelColor ? labelSettings.labelColor : NewDataLabelUtils.defaultLabelColor,
	                                insideFill: labelSettings.labelColor ? labelSettings.labelColor : NewDataLabelUtils.defaultInsideLabelColor,
	                                isParentRect: true,
	                                parentShape: {
	                                    rect: parentRect,
	                                    orientation: 1,
	                                    validPositions: MekkoChartStrategy.validLabelPositions,
	                                },
	                                identity: dataPoint.identity,
	                                parentType: 1,
	                            });
	                        }
	                    }
	                    return labelDataPoints;
	                };
	                MekkoChartStrategy.Classes = {
	                    item: createClassAndSelector('column'),
	                    highlightItem: createClassAndSelector('highlightColumn')
	                };
	                MekkoChartStrategy.validLabelPositions = [1];
	                return MekkoChartStrategy;
	            }());
	            samples.MekkoChartStrategy = MekkoChartStrategy;
	            /**
	             * Renders a data series as a cartestian visual.
	             */
	            var MekkoChart = (function () {
	                function MekkoChart(options) {
	                    this.isScrollable = false;
	                    if (options) {
	                        this.type = options.chartType;
	                        if (options.isScrollable)
	                            this.isScrollable = options.isScrollable;
	                        this.animator = options.animator;
	                        if (options.cartesianSmallViewPortProperties) {
	                            this.cartesianSmallViewPortProperties = options.cartesianSmallViewPortProperties;
	                        }
	                        if (options.behavior) {
	                            this.behavior = options.behavior;
	                        }
	                    }
	                    else {
	                        this.behavior = new CustomVisualBehavior([new MekkoChartWebBehavior()]);
	                    }
	                }
	                MekkoChart.getTextProperties = function (fontSize) {
	                    if (fontSize === void 0) { fontSize = MekkoChart.FontSize; }
	                    return {
	                        fontFamily: 'wf_segoe-ui_normal',
	                        fontSize: PixelConverter.toString(fontSize),
	                    };
	                };
	                MekkoChart.prototype.init = function (options) {
	                    this.visualInitOptions = options;
	                    this.layers = [];
	                    var element = this.element = options.element;
	                    var viewport = this.currentViewport = options.viewport;
	                    this.hostServices = options.host;
	                    this.brush = d3.svg.brush();
	                    element.addClass(MekkoChart.ClassName);
	                    this.margin = {
	                        top: 1,
	                        right: 1,
	                        bottom: 1,
	                        left: 1
	                    };
	                    this.yAxisOrientation = yAxisPosition.left;
	                    this.adjustMargins(viewport);
	                    this.sharedColorPalette = new MekkoChartSharedColorPalette(options.style.colorPalette.dataColors);
	                    var showLinesOnX = true;
	                    var showLinesOnY = true;
	                    var svg = this.svg = d3.select(element.get(0)).append('svg');
	                    svg.style('position', 'absolute');
	                    var axisGraphicsContext = this.axisGraphicsContext = svg.append('g')
	                        .classed(MekkoChart.AxisGraphicsContextClassName, true);
	                    this.svgScrollable = svg.append('svg')
	                        .classed('svgScrollable', true)
	                        .style('overflow', 'hidden');
	                    var axisGraphicsContextScrollable = this.axisGraphicsContextScrollable = this.svgScrollable.append('g')
	                        .classed(MekkoChart.AxisGraphicsContextClassName, true);
	                    this.labelGraphicsContextScrollable = this.svgScrollable.append('g')
	                        .classed(NewDataLabelUtils.labelGraphicsContextClass.class, true);
	                    if (this.behavior) {
	                        this.clearCatcher = appendClearCatcher(this.axisGraphicsContextScrollable);
	                    }
	                    var axisGroup = showLinesOnX ? axisGraphicsContextScrollable : axisGraphicsContext;
	                    this.xAxisGraphicsContext = showLinesOnX ? axisGraphicsContext.append('g').attr('class', 'x axis') : axisGraphicsContextScrollable.append('g').attr('class', 'x axis');
	                    this.y1AxisGraphicsContext = axisGroup.append('g').attr('class', 'y axis');
	                    this.y2AxisGraphicsContext = axisGroup.append('g').attr('class', 'y axis');
	                    this.xAxisGraphicsContext.classed('showLinesOnAxis', showLinesOnX);
	                    this.y1AxisGraphicsContext.classed('showLinesOnAxis', showLinesOnY);
	                    this.y2AxisGraphicsContext.classed('showLinesOnAxis', showLinesOnY);
	                    this.xAxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnX);
	                    this.y1AxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnY);
	                    this.y2AxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnY);
	                    if (this.behavior) {
	                        this.interactivityService = createInteractivityService(this.hostServices);
	                    }
	                    this.legend = createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, this.interactivityService, true);
	                };
	                MekkoChart.prototype.renderAxesLabels = function (options) {
	                    debug.assertValue(options, 'options');
	                    debug.assertValue(options.viewport, 'options.viewport');
	                    debug.assertValue(options.axisLabels, 'options.axisLabels');
	                    this.axisGraphicsContext.selectAll('.xAxisLabel').remove();
	                    this.axisGraphicsContext.selectAll('.yAxisLabel').remove();
	                    var margin = this.margin;
	                    var width = options.viewport.width - (margin.left + margin.right);
	                    var height = options.viewport.height;
	                    var fontSize = MekkoChart.FontSize;
	                    var heightOffset = fontSize;
	                    var showOnRight = this.yAxisOrientation === yAxisPosition.right;
	                    if (!options.hideXAxisTitle) {
	                        var xAxisLabel = this.axisGraphicsContext.append("text")
	                            .style("text-anchor", "middle")
	                            .text(options.axisLabels.x)
	                            .call(function (text) {
	                            text.each(function () {
	                                var text = d3.select(this);
	                                text.attr({
	                                    "class": "xAxisLabel",
	                                    "transform": SVGUtil.translate(width / 2, height - heightOffset)
	                                });
	                            });
	                        });
	                        xAxisLabel.style("fill", options.xLabelColor ? options.xLabelColor.solid.color : null);
	                        xAxisLabel.call(AxisHelper.LabelLayoutStrategy.clip, width, TextMeasurementService.svgEllipsis);
	                    }
	                    if (!options.hideYAxisTitle) {
	                        var yAxisLabel = this.axisGraphicsContext.append("text")
	                            .style("text-anchor", "middle")
	                            .text(options.axisLabels.y)
	                            .call(function (text) {
	                            text.each(function () {
	                                var text = d3.select(this);
	                                text.attr({
	                                    "class": "yAxisLabel",
	                                    "transform": "rotate(-90)",
	                                    "y": showOnRight ? width + margin.right - fontSize : -margin.left,
	                                    "x": -((height - margin.top - options.legendMargin) / 2),
	                                    "dy": "1em"
	                                });
	                            });
	                        });
	                        yAxisLabel.style("fill", options.yLabelColor ? options.yLabelColor.solid.color : null);
	                        yAxisLabel.call(AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), TextMeasurementService.svgEllipsis);
	                    }
	                    if (!options.hideY2AxisTitle && options.axisLabels.y2) {
	                        var y2AxisLabel = this.axisGraphicsContext.append("text")
	                            .style("text-anchor", "middle")
	                            .text(options.axisLabels.y2)
	                            .call(function (text) {
	                            text.each(function () {
	                                var text = d3.select(this);
	                                text.attr({
	                                    "class": "yAxisLabel",
	                                    "transform": "rotate(-90)",
	                                    "y": showOnRight ? -margin.left : width + margin.right - fontSize,
	                                    "x": -((height - margin.top - options.legendMargin) / 2),
	                                    "dy": "1em"
	                                });
	                            });
	                        });
	                        y2AxisLabel.style("fill", options.y2LabelColor ? options.y2LabelColor.solid.color : null);
	                        y2AxisLabel.call(AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), TextMeasurementService.svgEllipsis);
	                    }
	                };
	                MekkoChart.prototype.adjustMargins = function (viewport) {
	                    var margin = this.margin;
	                    var width = viewport.width - (margin.left + margin.right);
	                    var height = viewport.height - (margin.top + margin.bottom);
	                    // Adjust margins if ticks are not going to be shown on either axis
	                    var xAxis = this.element.find('.x.axis');
	                    if (AxisHelper.getRecommendedNumberOfTicksForXAxis(width) === 0
	                        && AxisHelper.getRecommendedNumberOfTicksForYAxis(height) === 0) {
	                        this.margin = {
	                            top: 0,
	                            right: 0,
	                            bottom: 0,
	                            left: 0
	                        };
	                        xAxis.hide();
	                    }
	                    else {
	                        xAxis.show();
	                    }
	                };
	                MekkoChart.prototype.translateAxes = function (viewport) {
	                    this.adjustMargins(viewport);
	                    var margin = this.margin;
	                    var width = viewport.width - (margin.left + margin.right);
	                    var height = viewport.height - (margin.top + margin.bottom);
	                    var showY1OnRight = this.yAxisOrientation === yAxisPosition.right;
	                    this.xAxisGraphicsContext
	                        .attr('transform', SVGUtil.translate(0, height));
	                    this.y1AxisGraphicsContext
	                        .attr('transform', SVGUtil.translate(showY1OnRight ? width : 0, 0));
	                    this.y2AxisGraphicsContext
	                        .attr('transform', SVGUtil.translate(showY1OnRight ? 0 : width, 0));
	                    this.svg.attr({
	                        'width': viewport.width,
	                        'height': viewport.height
	                    });
	                    this.svg.style('top', this.legend.isVisible() ? this.legend.getMargins().height + 'px' : 0);
	                    this.svgScrollable.attr({
	                        'width': viewport.width,
	                        'height': viewport.height
	                    });
	                    this.svgScrollable.attr({
	                        'x': 0
	                    });
	                    this.axisGraphicsContext.attr('transform', SVGUtil.translate(margin.left, margin.top));
	                    this.axisGraphicsContextScrollable.attr('transform', SVGUtil.translate(margin.left, margin.top));
	                    this.labelGraphicsContextScrollable.attr('transform', SVGUtil.translate(margin.left, margin.top));
	                    if (this.isXScrollBarVisible) {
	                        this.svgScrollable.attr({
	                            'x': this.margin.left
	                        });
	                        this.axisGraphicsContextScrollable.attr('transform', SVGUtil.translate(0, margin.top));
	                        this.labelGraphicsContextScrollable.attr('transform', SVGUtil.translate(0, margin.top));
	                        this.svgScrollable.attr('width', width);
	                        this.svg.attr('width', viewport.width)
	                            .attr('height', viewport.height + MekkoChart.ScrollBarWidth);
	                    }
	                    else if (this.isYScrollBarVisible) {
	                        this.svgScrollable.attr('height', height + margin.top);
	                        this.svg.attr('width', viewport.width + MekkoChart.ScrollBarWidth)
	                            .attr('height', viewport.height);
	                    }
	                };
	                /**
	                 * Returns preferred Category span if the visual is scrollable.
	                 */
	                MekkoChart.getPreferredCategorySpan = function (categoryCount, categoryThickness, noOuterPadding) {
	                    var span = (categoryThickness * categoryCount);
	                    if (noOuterPadding)
	                        return span;
	                    return span + (categoryThickness * MekkoChart.OuterPaddingRatio * 2);
	                };
	                MekkoChart.getIsScalar = function (objects, propertyId, type) {
	                    var axisTypeValue = DataViewObjects.getValue(objects, propertyId);
	                    if (!objects || axisTypeValue === undefined) {
	                        // If we don't have anything set (Auto), show charts as Scalar if the category type is numeric or time.
	                        // If we have the property, it will override the type.
	                        return !AxisHelper.isOrdinal(type);
	                    }
	                    // also checking type here to be in sync with AxisHelper, which ignores scalar if the type is non-numeric.
	                    return (axisTypeValue === axisType.scalar) && !AxisHelper.isOrdinal(type);
	                };
	                MekkoChart.prototype.populateObjectProperties = function (dataViews) {
	                    if (dataViews && dataViews.length > 0) {
	                        var dataViewMetadata = dataViews[0].metadata;
	                        if (dataViewMetadata) {
	                            this.legendObjectProperties = DataViewObjects.getObject(dataViewMetadata.objects, 'legend', {});
	                            this.borderObjectProperties = DataViewObjects.getObject(dataViewMetadata.objects, 'columnBorder', {});
	                        }
	                        else {
	                            this.legendObjectProperties = {};
	                            this.borderObjectProperties = {};
	                        }
	                        this.categoryAxisProperties = MekkochartHelper.getCategoryAxisProperties(dataViewMetadata);
	                        this.valueAxisProperties = MekkochartHelper.getValueAxisProperties(dataViewMetadata);
	                        if (dataViewMetadata &&
	                            dataViewMetadata.objects) {
	                            var categoryAxis = dataViewMetadata.objects['categoryAxis'];
	                            var valueAxis = dataViewMetadata.objects['valueAxis'];
	                            if (categoryAxis) {
	                                this.categoryAxisProperties['showBorder'] = categoryAxis['showBorder'];
	                                this.categoryAxisProperties['fontSize'] = categoryAxis['fontSize'];
	                            }
	                            if (valueAxis) {
	                                this.valueAxisProperties['fontSize'] = valueAxis['fontSize'];
	                            }
	                        }
	                        var axisPosition = this.valueAxisProperties['position'];
	                        this.yAxisOrientation = axisPosition ? axisPosition.toString() : yAxisPosition.left;
	                    }
	                };
	                MekkoChart.prototype.update = function (options) {
	                    debug.assertValue(options, 'options');
	                    var dataViews = this.dataViews = options.dataViews;
	                    this.currentViewport = options.viewport;
	                    if (!dataViews) {
	                        this.clearViewport();
	                        return;
	                    }
	                    if ((this.currentViewport.width < MekkoChart.MinWidth) ||
	                        (this.currentViewport.height < MekkoChart.MinHeight)) {
	                        this.clearViewport();
	                        return;
	                    }
	                    if (this.layers.length === 0) {
	                        // Lazily instantiate the chart layers on the first data load.
	                        this.layers = this.createAndInitLayers(dataViews);
	                        debug.assert(this.layers.length > 0, 'createAndInitLayers should update the layers.');
	                    }
	                    var layers = this.layers;
	                    if (dataViews && dataViews.length > 0) {
	                        var warnings = getInvalidValueWarnings(dataViews, false /*supportsNaN*/, false /*supportsNegativeInfinity*/, false /*supportsPositiveInfinity*/);
	                        if (warnings && warnings.length > 0) {
	                            this.hostServices.setWarnings(warnings);
	                        }
	                        this.populateObjectProperties(dataViews);
	                    }
	                    this.sharedColorPalette.clearPreferredScale();
	                    for (var i = 0, len = layers.length; i < len; i++) {
	                        layers[i].setData(getLayerData(dataViews, i, len));
	                        if (len > 1) {
	                            this.sharedColorPalette.rotateScale();
	                        }
	                    }
	                    // Note: interactive legend shouldn't be rendered explicitly here
	                    // The interactive legend is being rendered in the render method of ICartesianVisual
	                    if (!(this.visualInitOptions.interactivity && this.visualInitOptions.interactivity.isInteractiveLegend)) {
	                        this.renderLegend();
	                    }
	                    this.render(!this.hasSetData || options.suppressAnimations);
	                    this.hasSetData = this.hasSetData || (dataViews && dataViews.length > 0);
	                };
	                /**
	                 * Clear the viewport area
	                 */
	                MekkoChart.prototype.clearViewport = function () {
	                    this.legend.reset();
	                    this.setVisibility(false);
	                };
	                MekkoChart.prototype.setVisibility = function (status) {
	                    if (status === void 0) { status = true; }
	                    this.svg.style('display', status ? 'block' : 'none');
	                    this.element.find('.legend').toggle(status);
	                };
	                MekkoChart.getLayout = function (data, options) {
	                    var categoryCount = options.categoryCount, availableWidth = options.availableWidth, domain = options.domain, trimOrdinalDataOnOverflow = options.trimOrdinalDataOnOverflow, isScalar = !!options.isScalar, isScrollable = !!options.isScrollable;
	                    var categoryThickness = MekkoChart.getCategoryThickness(data ? data.series : null, categoryCount, availableWidth, domain, isScalar, trimOrdinalDataOnOverflow);
	                    // Total width of the outer padding, the padding that exist on the far right and far left of the chart.
	                    var totalOuterPadding = categoryThickness * MekkoChart.OuterPaddingRatio * 2;
	                    // visibleCategoryCount will be used to discard data that overflows on ordinal-axis charts.
	                    // Needed for dashboard visuals            
	                    var calculatedBarCount = Double.floorWithPrecision((availableWidth - totalOuterPadding) / categoryThickness);
	                    var visibleCategoryCount = Math.min(calculatedBarCount, categoryCount);
	                    var willScroll = visibleCategoryCount < categoryCount && isScrollable;
	                    var outerPaddingRatio = MekkoChart.OuterPaddingRatio;
	                    if (!isScalar && !willScroll) {
	                        // use dynamic outer padding to improve spacing when we have few categories
	                        var oneOuterPadding = (availableWidth - (categoryThickness * visibleCategoryCount)) / 2;
	                        outerPaddingRatio = oneOuterPadding / categoryThickness;
	                    }
	                    // If scrollable, visibleCategoryCount will be total categories
	                    if (!isScalar && isScrollable)
	                        visibleCategoryCount = categoryCount;
	                    return {
	                        categoryCount: visibleCategoryCount,
	                        categoryThickness: categoryThickness,
	                        outerPaddingRatio: outerPaddingRatio,
	                        isScalar: isScalar
	                    };
	                };
	                /**
	                 * Returns the thickness for each category.
	                 * For clustered charts, you still need to divide by
	                 * the number of series to get column width after calling this method.
	                 * For linear or time scales, category thickness accomodates for
	                 * the minimum interval between consequtive points.
	                 * For all types, return value has accounted for outer padding,
	                 * but not inner padding.
	                 */
	                MekkoChart.getCategoryThickness = function (seriesList, numCategories, plotLength, domain, isScalar, trimOrdinalDataOnOverflow) {
	                    var thickness;
	                    if (numCategories < 2)
	                        thickness = plotLength * (1 - MekkoChart.OuterPaddingRatio);
	                    else if (isScalar && domain && domain.length > 1) {
	                        // the smallest interval defines the column width.
	                        var minInterval = MekkoChart.getMinInterval(seriesList);
	                        var domainSpan = domain[domain.length - 1] - domain[0];
	                        // account for outside padding
	                        var ratio = minInterval / (domainSpan + (minInterval * MekkoChart.OuterPaddingRatio * 2));
	                        thickness = plotLength * ratio;
	                        thickness = Math.max(thickness, MekkoChart.MinScalarRectThickness);
	                    }
	                    else {
	                        // Divide the available width up including outer padding (in terms of category thickness) on
	                        // both sides of the chart, and categoryCount categories. Reverse math:
	                        // availableWidth = (categoryThickness * categoryCount) + (categoryThickness * (outerPadding * 2)),
	                        // availableWidth = categoryThickness * (categoryCount + (outerPadding * 2)),
	                        // categoryThickness = availableWidth / (categoryCount + (outerpadding * 2))
	                        thickness = plotLength / (numCategories + (MekkoChart.OuterPaddingRatio * 2));
	                        if (trimOrdinalDataOnOverflow) {
	                            thickness = Math.max(thickness, MekkoChart.MinOrdinalRectThickness);
	                        }
	                    }
	                    // spec calls for using the whole plot area, but the max rectangle thickness is "as if there were three categories"
	                    // (outerPaddingRatio has the same units as '# of categories' so they can be added)
	                    var maxRectThickness = plotLength / (3 + (MekkoChart.OuterPaddingRatio * 2));
	                    thickness = Math.min(thickness, maxRectThickness);
	                    if (!isScalar && numCategories >= 3 && trimOrdinalDataOnOverflow) {
	                        return Math.max(thickness, MekkoChart.MinOrdinalRectThickness);
	                    }
	                    return thickness;
	                };
	                MekkoChart.getMinInterval = function (seriesList) {
	                    var minInterval = Number.MAX_VALUE;
	                    if (seriesList.length > 0) {
	                        var series0data = seriesList[0].data.filter(function (d) { return !d.highlight; });
	                        for (var i = 0, ilen = series0data.length - 1; i < ilen; i++) {
	                            minInterval = Math.min(minInterval, Math.abs(series0data[i + 1].categoryValue - series0data[i].categoryValue));
	                        }
	                    }
	                    return minInterval;
	                };
	                MekkoChart.parseLabelSettings = function (objects) {
	                    var labelSettings = dataLabelUtils.getDefaultColumnLabelSettings(true);
	                    var labelsObj = objects['labels'];
	                    var minPrecision = MekkoChart.DefaultSettings.labelSettings.minPrecision, maxPrecision = MekkoChart.DefaultSettings.labelSettings.maxPrecision;
	                    dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, labelSettings);
	                    if (labelSettings.precision < minPrecision) {
	                        labelSettings.precision = minPrecision;
	                    }
	                    if (labelSettings.precision > maxPrecision) {
	                        labelSettings.precision = maxPrecision;
	                    }
	                    return labelSettings;
	                };
	                MekkoChart.parseBorderSettings = function (objects) {
	                    var show = DataViewObjects.getValue(objects, MekkoChart.Properties["columnBorder"]["show"], MekkoChart.DefaultSettings.columnBorder.show);
	                    var color = DataViewObjects.getFillColor(objects, MekkoChart.Properties["columnBorder"]["color"], MekkoChart.DefaultSettings.columnBorder.color);
	                    var width = DataViewObjects.getValue(objects, MekkoChart.Properties["columnBorder"]["width"], MekkoChart.DefaultSettings.columnBorder.width);
	                    var maxWidth = MekkoChart.DefaultSettings.columnBorder.maxWidth;
	                    if (width > maxWidth) {
	                        width = maxWidth;
	                    }
	                    else if (width < 0) {
	                        width = 0;
	                    }
	                    if (!show) {
	                        width = 0;
	                    }
	                    return {
	                        show: show,
	                        color: color,
	                        width: width,
	                    };
	                };
	                MekkoChart.prototype.enumerateBorder = function (enumeration) {
	                    var objects = {
	                        columnBorder: this.borderObjectProperties
	                    };
	                    var show = DataViewObjects.getValue(objects, MekkoChart.Properties["columnBorder"]["show"], MekkoChart.DefaultSettings.columnBorder.show);
	                    var color = DataViewObjects.getFillColor(objects, MekkoChart.Properties["columnBorder"]["color"], MekkoChart.DefaultSettings.columnBorder.color);
	                    var width = DataViewObjects.getValue(objects, MekkoChart.Properties["columnBorder"]["width"], MekkoChart.DefaultSettings.columnBorder.width);
	                    var maxWidth = MekkoChart.DefaultSettings.columnBorder.maxWidth;
	                    if (width > maxWidth) {
	                        width = maxWidth;
	                    }
	                    else if (width < 0) {
	                        width = 0;
	                    }
	                    var instance = {
	                        objectName: 'columnBorder',
	                        selector: null,
	                        properties: {
	                            show: show,
	                            color: color,
	                            width: width,
	                        },
	                    };
	                    enumeration
	                        .pushInstance(instance);
	                };
	                MekkoChart.prototype.enumerateObjectInstances = function (options) {
	                    var enumeration = new ObjectEnumerationBuilder();
	                    var layersLength = this.layers
	                        ? this.layers.length
	                        : 0;
	                    if (options.objectName === 'columnBorder') {
	                        this.enumerateBorder(enumeration);
	                    }
	                    else if (options.objectName === 'legend') {
	                        if (!this.shouldShowLegendCard()) {
	                            return;
	                        }
	                        this.enumerateLegend(options, enumeration);
	                    }
	                    else if (options.objectName === 'categoryAxis' && this.hasCategoryAxis) {
	                        this.getCategoryAxisValues(enumeration);
	                    }
	                    else if (options.objectName === 'valueAxis') {
	                        this.getValueAxisValues(enumeration);
	                    }
	                    for (var i = 0, len = layersLength; i < len; i++) {
	                        var layer = this.layers[i];
	                        if (layer.enumerateObjectInstances) {
	                            layer.enumerateObjectInstances(enumeration, options);
	                        }
	                    }
	                    return enumeration.complete();
	                };
	                MekkoChart.prototype.enumerateLegend = function (options, enumeration) {
	                    var show, showTitle, titleText, fontSize, position;
	                    show = DataViewObject.getValue(this.legendObjectProperties, legendProps.show, this.legend.isVisible());
	                    showTitle = DataViewObject.getValue(this.legendObjectProperties, legendProps.showTitle, true);
	                    titleText = DataViewObject.getValue(this.legendObjectProperties, legendProps.titleText, this.layerLegendData && this.layerLegendData.title
	                        ? this.layerLegendData.title
	                        : '');
	                    fontSize = DataViewObject.getValue(this.legendObjectProperties, legendProps.fontSize, this.layerLegendData && this.layerLegendData.fontSize
	                        ? this.layerLegendData.fontSize
	                        : NewDataLabelUtils.DefaultLabelFontSizeInPt);
	                    position = DataViewObject.getValue(this.legendObjectProperties, legendProps.position, visuals.legendPosition.top);
	                    enumeration.pushInstance({
	                        selector: null,
	                        properties: {
	                            show: show,
	                            position: position,
	                            showTitle: showTitle,
	                            titleText: titleText,
	                            fontSize: fontSize
	                        },
	                        objectName: options.objectName
	                    });
	                };
	                MekkoChart.prototype.shouldShowLegendCard = function () {
	                    var layers = this.layers;
	                    var dataViews = this.dataViews;
	                    if (layers && dataViews) {
	                        var layersLength = layers.length;
	                        var layersWithValuesCtr = 0;
	                        for (var i = 0; i < layersLength; i++) {
	                            if (layers[i].hasLegend()) {
	                                return true;
	                            }
	                            // if there are at least two layers with values legend card should be shown (even if each of the individual layers don't have legend)
	                            var dataView = dataViews[i];
	                            if (dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.values.length > 0) {
	                                layersWithValuesCtr++;
	                                if (layersWithValuesCtr > 1) {
	                                    return true;
	                                }
	                            }
	                        }
	                    }
	                    return false;
	                };
	                MekkoChart.prototype.getCategoryAxisValues = function (enumeration) {
	                    var supportedType = axisType.both;
	                    var isScalar = false;
	                    var logPossible = !!this.axes.x.isLogScaleAllowed;
	                    var scaleOptions = [axisScale.log, axisScale.linear]; //until options can be update in propPane, show all options
	                    if (this.layers && this.layers[0].getSupportedCategoryAxisType) {
	                        supportedType = this.layers[0].getSupportedCategoryAxisType();
	                        if (supportedType === axisType.scalar) {
	                            isScalar = true;
	                        }
	                        else {
	                            isScalar = MekkochartHelper.isScalar(supportedType === axisType.both, this.categoryAxisProperties);
	                        }
	                    }
	                    if (!isScalar) {
	                        if (this.categoryAxisProperties) {
	                            this.categoryAxisProperties['start'] = null;
	                            this.categoryAxisProperties['end'] = null;
	                        }
	                    }
	                    var instance = {
	                        selector: null,
	                        properties: {},
	                        objectName: 'categoryAxis',
	                        validValues: {
	                            axisScale: scaleOptions
	                        }
	                    };
	                    instance.properties['show'] = this.categoryAxisProperties && this.categoryAxisProperties['show'] != null ? this.categoryAxisProperties['show'] : true;
	                    if (this.yAxisIsCategorical)
	                        instance.properties['position'] = this.valueAxisProperties && this.valueAxisProperties['position'] != null ? this.valueAxisProperties['position'] : yAxisPosition.left;
	                    if (supportedType === axisType.both) {
	                        instance.properties['axisType'] = isScalar ? axisType.scalar : axisType.categorical;
	                    }
	                    if (isScalar) {
	                        instance.properties['axisScale'] = (this.categoryAxisProperties && this.categoryAxisProperties['axisScale'] != null && logPossible) ? this.categoryAxisProperties['axisScale'] : axisScale.linear;
	                        instance.properties['start'] = this.categoryAxisProperties ? this.categoryAxisProperties['start'] : null;
	                        instance.properties['end'] = this.categoryAxisProperties ? this.categoryAxisProperties['end'] : null;
	                    }
	                    instance.properties['showAxisTitle'] = this.categoryAxisProperties && this.categoryAxisProperties['showAxisTitle'] != null ? this.categoryAxisProperties['showAxisTitle'] : false;
	                    instance.properties['showBorder'] = this.categoryAxisProperties && this.categoryAxisProperties['showBorder'] != null ? this.categoryAxisProperties['showAxisTitle'] : false;
	                    instance.properties['fontSize'] = this.categoryAxisProperties && this.categoryAxisProperties['fontSize'] != null ? this.categoryAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt;
	                    enumeration
	                        .pushInstance(instance)
	                        .pushInstance({
	                        selector: null,
	                        properties: {
	                            axisStyle: this.categoryAxisProperties && this.categoryAxisProperties['axisStyle'] ? this.categoryAxisProperties['axisStyle'] : axisStyle.showTitleOnly,
	                            labelColor: this.categoryAxisProperties ? this.categoryAxisProperties['labelColor'] : null,
	                            fontSize: this.categoryAxisProperties && this.categoryAxisProperties['fontSize'] != null ? this.categoryAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt
	                        },
	                        objectName: 'categoryAxis',
	                        validValues: {
	                            axisStyle: this.categoryAxisHasUnitType ? [axisStyle.showTitleOnly, axisStyle.showUnitOnly, axisStyle.showBoth] : [axisStyle.showTitleOnly],
	                        }
	                    });
	                };
	                //todo: wrap all these object getters and other related stuff into an interface
	                MekkoChart.prototype.getValueAxisValues = function (enumeration) {
	                    var scaleOptions = [axisScale.log, axisScale.linear]; //until options can be update in propPane, show all options
	                    var logPossible = !!this.axes.y1.isLogScaleAllowed;
	                    //var secLogPossible = this.axes.y2 != null && this.axes.y2.isLogScaleAllowed;
	                    var instance = {
	                        selector: null,
	                        properties: {},
	                        objectName: 'valueAxis',
	                        validValues: {
	                            axisScale: scaleOptions,
	                            secAxisScale: scaleOptions
	                        }
	                    };
	                    instance.properties['show'] = this.valueAxisProperties && this.valueAxisProperties['show'] != null ? this.valueAxisProperties['show'] : true;
	                    if (!this.yAxisIsCategorical) {
	                        instance.properties['position'] = this.valueAxisProperties && this.valueAxisProperties['position'] != null ? this.valueAxisProperties['position'] : yAxisPosition.left;
	                    }
	                    instance.properties['axisScale'] = (this.valueAxisProperties && this.valueAxisProperties['axisScale'] != null && logPossible) ? this.valueAxisProperties['axisScale'] : axisScale.linear;
	                    instance.properties['start'] = this.valueAxisProperties ? this.valueAxisProperties['start'] : null;
	                    instance.properties['end'] = this.valueAxisProperties ? this.valueAxisProperties['end'] : null;
	                    instance.properties['showAxisTitle'] = this.valueAxisProperties && this.valueAxisProperties['showAxisTitle'] != null ? this.valueAxisProperties['showAxisTitle'] : false;
	                    instance.properties['fontSize'] = this.valueAxisProperties && this.valueAxisProperties['fontSize'] != null ? this.valueAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt;
	                    enumeration
	                        .pushInstance(instance)
	                        .pushInstance({
	                        selector: null,
	                        properties: {
	                            axisStyle: this.valueAxisProperties && this.valueAxisProperties['axisStyle'] != null ? this.valueAxisProperties['axisStyle'] : axisStyle.showTitleOnly,
	                            labelColor: this.valueAxisProperties ? this.valueAxisProperties['labelColor'] : null,
	                            fontSize: this.valueAxisProperties && this.valueAxisProperties['fontSize'] != null ? this.valueAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt
	                        },
	                        objectName: 'valueAxis',
	                        validValues: {
	                            axisStyle: this.valueAxisHasUnitType ? [axisStyle.showTitleOnly, axisStyle.showUnitOnly, axisStyle.showBoth] : [axisStyle.showTitleOnly]
	                        },
	                    });
	                    if (this.layers.length === 2) {
	                        instance.properties['secShow'] = this.valueAxisProperties && this.valueAxisProperties['secShow'] != null ? this.valueAxisProperties['secShow'] : this.y2AxisExists;
	                        if (instance.properties['secShow']) {
	                            instance.properties['axisLabel'] = ''; //this.layers[0].getVisualType();//I will keep or remove this, depending on the decision made
	                        }
	                    }
	                };
	                MekkoChart.prototype.onClearSelection = function () {
	                    if (this.hasSetData) {
	                        for (var i = 0, len = this.layers.length; i < len; i++) {
	                            var layer = this.layers[i];
	                            layer.onClearSelection();
	                            layer.render(true /* suppressAnimations */);
	                        }
	                    }
	                };
	                MekkoChart.prototype.createAndInitLayers = function (dataViews) {
	                    var _this = this;
	                    var objects;
	                    if (dataViews && dataViews.length > 0) {
	                        var dataViewMetadata = dataViews[0].metadata;
	                        if (dataViewMetadata)
	                            objects = dataViewMetadata.objects;
	                    }
	                    // Create the layers
	                    var layers = createLayers(this.type, objects, this.interactivityService, this.animator, this.isScrollable);
	                    // Initialize the layers
	                    var cartesianOptions = Prototype.inherit(this.visualInitOptions);
	                    cartesianOptions.svg = this.axisGraphicsContextScrollable;
	                    cartesianOptions.cartesianHost = {
	                        updateLegend: function (data) { return _this.legend.drawLegend(data, _this.currentViewport); },
	                        getSharedColors: function () { return _this.sharedColorPalette; },
	                        triggerRender: undefined,
	                    };
	                    for (var i = 0, len = layers.length; i < len; i++) {
	                        layers[i].init(cartesianOptions);
	                    }
	                    return layers;
	                };
	                MekkoChart.prototype.renderLegend = function () {
	                    var layers = this.layers;
	                    var legendData = { title: "", dataPoints: [] };
	                    for (var i = 0, len = layers.length; i < len; i++) {
	                        this.layerLegendData = layers[i].calculateLegend();
	                        if (this.layerLegendData) {
	                            legendData.title = i === 0 ? this.layerLegendData.title || ""
	                                : legendData.title;
	                            legendData.dataPoints = legendData.dataPoints.concat(this.layerLegendData.dataPoints || []);
	                            if (this.layerLegendData.grouped) {
	                                legendData.grouped = true;
	                            }
	                        }
	                    }
	                    var legendProperties = this.legendObjectProperties;
	                    if (legendProperties) {
	                        if (!legendProperties['fontSize']) {
	                            legendProperties['fontSize'] = NewDataLabelUtils.DefaultLabelFontSizeInPt;
	                        }
	                        LegendData.update(legendData, legendProperties);
	                        var position = legendProperties[legendProps.position];
	                        if (position) {
	                            this.legend.changeOrientation(LegendPosition[position]);
	                        }
	                    }
	                    else {
	                        this.legend.changeOrientation(LegendPosition.Top);
	                    }
	                    if ((legendData.dataPoints.length === 1 && !legendData.grouped) || this.hideLegends()) {
	                        legendData.dataPoints = [];
	                    }
	                    this.legend.drawLegend(legendData, this.currentViewport);
	                };
	                MekkoChart.prototype.hideLegends = function () {
	                    if (this.cartesianSmallViewPortProperties) {
	                        if (this.cartesianSmallViewPortProperties.hideLegendOnSmallViewPort && (this.currentViewport.height < this.cartesianSmallViewPortProperties.MinHeightLegendVisible)) {
	                            return true;
	                        }
	                    }
	                    return false;
	                };
	                MekkoChart.prototype.addUnitTypeToAxisLabel = function (axes) {
	                    var unitType = MekkoChart.getUnitType(axes, function (axis) { return axis.x; });
	                    if (axes.x.isCategoryAxis) {
	                        this.categoryAxisHasUnitType = unitType !== null;
	                    }
	                    else {
	                        this.valueAxisHasUnitType = unitType !== null;
	                    }
	                    if (axes.x.axisLabel && unitType) {
	                        if (axes.x.isCategoryAxis) {
	                            axes.x.axisLabel = AxisHelper.createAxisLabel(this.categoryAxisProperties, axes.x.axisLabel, unitType);
	                        }
	                        else {
	                            axes.x.axisLabel = AxisHelper.createAxisLabel(this.valueAxisProperties, axes.x.axisLabel, unitType);
	                        }
	                    }
	                    unitType = MekkoChart.getUnitType(axes, function (axis) { return axis.y1; });
	                    if (!axes.y1.isCategoryAxis) {
	                        this.valueAxisHasUnitType = unitType !== null;
	                    }
	                    else {
	                        this.categoryAxisHasUnitType = unitType !== null;
	                    }
	                    if (axes.y1.axisLabel && unitType) {
	                        if (!axes.y1.isCategoryAxis) {
	                            axes.y1.axisLabel = AxisHelper.createAxisLabel(this.valueAxisProperties, axes.y1.axisLabel, unitType);
	                        }
	                        else {
	                            axes.y1.axisLabel = AxisHelper.createAxisLabel(this.categoryAxisProperties, axes.y1.axisLabel, unitType);
	                        }
	                    }
	                    if (axes.y2) {
	                        var unitType = MekkoChart.getUnitType(axes, function (axis) { return axis.y2; });
	                        this.secValueAxisHasUnitType = unitType !== null;
	                        if (axes.y2.axisLabel && unitType) {
	                            if (this.valueAxisProperties && this.valueAxisProperties['secAxisStyle']) {
	                                if (this.valueAxisProperties['secAxisStyle'] === axisStyle.showBoth) {
	                                    axes.y2.axisLabel = axes.y2.axisLabel + ' (' + unitType + ')';
	                                }
	                                else if (this.valueAxisProperties['secAxisStyle'] === axisStyle.showUnitOnly) {
	                                    axes.y2.axisLabel = unitType;
	                                }
	                            }
	                        }
	                    }
	                };
	                MekkoChart.prototype.shouldRenderSecondaryAxis = function (axisProperties) {
	                    if (!axisProperties) {
	                        return false;
	                    }
	                    if (!this.valueAxisProperties || this.valueAxisProperties["secShow"] == null || this.valueAxisProperties["secShow"]) {
	                        return axisProperties.values && axisProperties.values.length > 0;
	                    }
	                    return false;
	                };
	                MekkoChart.prototype.shouldRenderAxis = function (axisProperties, propertyName) {
	                    if (propertyName === void 0) { propertyName = "show"; }
	                    if (!axisProperties) {
	                        return false;
	                    }
	                    else if (axisProperties.isCategoryAxis && (!this.categoryAxisProperties || this.categoryAxisProperties[propertyName] == null || this.categoryAxisProperties[propertyName])) {
	                        return axisProperties.values && axisProperties.values.length > 0;
	                    }
	                    else if (!axisProperties.isCategoryAxis && (!this.valueAxisProperties || this.valueAxisProperties[propertyName] == null || this.valueAxisProperties[propertyName])) {
	                        return axisProperties.values && axisProperties.values.length > 0;
	                    }
	                    return false;
	                };
	                MekkoChart.prototype.render = function (suppressAnimations) {
	                    this.setVisibility(true);
	                    var legendMargins = this.legendMargins = this.legend.getMargins();
	                    var viewport = {
	                        height: this.currentViewport.height - legendMargins.height,
	                        width: this.currentViewport.width - legendMargins.width
	                    };
	                    var maxMarginFactor = this.getMaxMarginFactor();
	                    var leftRightMarginLimit = this.leftRightMarginLimit = viewport.width * maxMarginFactor;
	                    this.bottomMarginLimit = Math.max(MekkoChart.MinBottomMargin, Math.ceil(viewport.height * maxMarginFactor));
	                    var xAxisTextProperties = MekkoChart.getTextProperties(this.categoryAxisProperties && parseFloat(this.categoryAxisProperties['fontSize']) || undefined);
	                    var y1AxisTextProperties = MekkoChart.getTextProperties(this.valueAxisProperties && parseFloat(this.valueAxisProperties['fontSize']) || undefined);
	                    var margin = this.margin;
	                    // reset defaults
	                    margin.top = parseFloat(y1AxisTextProperties.fontSize) / 2;
	                    margin.bottom = MekkoChart.MinBottomMargin;
	                    margin.right = 0;
	                    var axes = this.axes = calculateAxes(this.layers, viewport, margin, this.categoryAxisProperties, this.valueAxisProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, null);
	                    this.yAxisIsCategorical = axes.y1.isCategoryAxis;
	                    this.hasCategoryAxis = this.yAxisIsCategorical ? axes.y1 && axes.y1.values.length > 0 : axes.x && axes.x.values.length > 0;
	                    var renderXAxis = this.shouldRenderAxis(axes.x);
	                    var renderY1Axis = this.shouldRenderAxis(axes.y1);
	                    var renderY2Axis = this.shouldRenderSecondaryAxis(axes.y2);
	                    var width = viewport.width - (margin.left + margin.right);
	                    var isScalar = false;
	                    var mainAxisScale;
	                    var preferredViewport;
	                    this.isXScrollBarVisible = false;
	                    this.isYScrollBarVisible = false;
	                    var yAxisOrientation = this.yAxisOrientation;
	                    var showY1OnRight = yAxisOrientation === yAxisPosition.right;
	                    if (this.layers) {
	                        if (this.layers[0].getVisualCategoryAxisIsScalar) {
	                            isScalar = this.layers[0].getVisualCategoryAxisIsScalar();
	                        }
	                        if (!isScalar && this.isScrollable && this.layers[0].getPreferredPlotArea) {
	                            var categoryThickness = this.scrollX ? axes.x.categoryThickness : axes.y1.categoryThickness;
	                            var categoryCount = this.scrollX ? axes.x.values.length : axes.y1.values.length;
	                            preferredViewport = this.layers[0].getPreferredPlotArea(isScalar, categoryCount, categoryThickness);
	                            if (this.scrollX && preferredViewport && preferredViewport.width > viewport.width) {
	                                this.isXScrollBarVisible = true;
	                                viewport.height -= MekkoChart.ScrollBarWidth;
	                            }
	                            if (this.scrollY && preferredViewport && preferredViewport.height > viewport.height) {
	                                this.isYScrollBarVisible = true;
	                                viewport.width -= MekkoChart.ScrollBarWidth;
	                                width = viewport.width - (margin.left + margin.right);
	                            }
	                        }
	                    }
	                    // Only create the g tag where there is a scrollbar
	                    if (this.isXScrollBarVisible || this.isYScrollBarVisible) {
	                        if (!this.brushGraphicsContext) {
	                            this.brushGraphicsContext = this.svg.append("g")
	                                .classed('x brush', true);
	                        }
	                    }
	                    else {
	                        // clear any existing brush if no scrollbar is shown
	                        this.svg.selectAll('.brush').remove();
	                        this.brushGraphicsContext = undefined;
	                    }
	                    // Recalculate axes now that scrollbar visible variables have been set
	                    axes = calculateAxes(this.layers, viewport, margin, this.categoryAxisProperties, this.valueAxisProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, null);
	                    // we need to make two passes because the margin changes affect the chosen tick values, which then affect the margins again.
	                    // after the second pass the margins are correct.
	                    var doneWithMargins = false, maxIterations = 2, numIterations = 0;
	                    var tickLabelMargins = undefined;
	                    var chartHasAxisLabels = undefined;
	                    var axisLabels = undefined;
	                    while (!doneWithMargins && numIterations < maxIterations) {
	                        numIterations++;
	                        tickLabelMargins = getTickLabelMargins({ width: width, height: viewport.height }, leftRightMarginLimit, TextMeasurementService.measureSvgTextWidth, TextMeasurementService.estimateSvgTextHeight, axes, this.bottomMarginLimit, xAxisTextProperties, y1AxisTextProperties, null, false, this.isXScrollBarVisible || this.isYScrollBarVisible, showY1OnRight, renderXAxis, renderY1Axis, renderY2Axis);
	                        // We look at the y axes as main and second sides, if the y axis orientation is right so the main side represents the right side
	                        var maxMainYaxisSide = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft, maxSecondYaxisSide = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight, xMax = renderXAxis ? (tickLabelMargins.xMax / 1.8) : 0;
	                        maxMainYaxisSide += MekkoChart.LeftPadding;
	                        maxSecondYaxisSide += MekkoChart.RightPadding;
	                        xMax += MekkoChart.BottomPadding;
	                        if (this.hideAxisLabels(legendMargins)) {
	                            axes.x.axisLabel = null;
	                            axes.y1.axisLabel = null;
	                            if (axes.y2) {
	                                axes.y2.axisLabel = null;
	                            }
	                        }
	                        this.addUnitTypeToAxisLabel(axes);
	                        axisLabels = { x: axes.x.axisLabel, y: axes.y1.axisLabel, y2: axes.y2 ? axes.y2.axisLabel : null };
	                        chartHasAxisLabels = (axisLabels.x != null) || (axisLabels.y != null || axisLabels.y2 != null);
	                        if (axisLabels.x != null) {
	                            xMax += MekkoChart.XAxisLabelPadding;
	                        }
	                        if (axisLabels.y != null) {
	                            maxMainYaxisSide += MekkoChart.YAxisLabelPadding;
	                        }
	                        if (axisLabels.y2 != null) {
	                            maxSecondYaxisSide += MekkoChart.YAxisLabelPadding;
	                        }
	                        margin.left = showY1OnRight ? maxSecondYaxisSide : maxMainYaxisSide;
	                        margin.right = showY1OnRight ? maxMainYaxisSide : maxSecondYaxisSide;
	                        margin.bottom = xMax;
	                        this.margin = margin;
	                        width = viewport.width - (margin.left + margin.right);
	                        // re-calculate the axes with the new margins
	                        var previousTickCountY1 = axes.y1.values.length;
	                        var previousTickCountY2 = axes.y2 && axes.y2.values.length;
	                        axes = calculateAxes(this.layers, viewport, margin, this.categoryAxisProperties, this.valueAxisProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, axes);
	                        // the minor padding adjustments could have affected the chosen tick values, which would then need to calculate margins again
	                        // e.g. [0,2,4,6,8] vs. [0,5,10] the 10 is wider and needs more margin.
	                        if (axes.y1.values.length === previousTickCountY1 && (!axes.y2 || axes.y2.values.length === previousTickCountY2))
	                            doneWithMargins = true;
	                    }
	                    this.renderChart(mainAxisScale, axes, width, tickLabelMargins, chartHasAxisLabels, axisLabels, viewport, suppressAnimations);
	                };
	                MekkoChart.prototype.hideAxisLabels = function (legendMargins) {
	                    if (this.cartesianSmallViewPortProperties) {
	                        if (this.cartesianSmallViewPortProperties.hideAxesOnSmallViewPort && ((this.currentViewport.height + legendMargins.height) < this.cartesianSmallViewPortProperties.MinHeightAxesVisible) && !this.visualInitOptions.interactivity.isInteractiveLegend) {
	                            return true;
	                        }
	                    }
	                    return false;
	                };
	                MekkoChart.getUnitType = function (axis, axisPropertiesLookup) {
	                    if (axisPropertiesLookup(axis).formatter &&
	                        axisPropertiesLookup(axis).formatter.displayUnit &&
	                        axisPropertiesLookup(axis).formatter.displayUnit.value > 1) {
	                        return axisPropertiesLookup(axis).formatter.displayUnit.title;
	                    }
	                    return null;
	                };
	                MekkoChart.prototype.getMaxMarginFactor = function () {
	                    return this.visualInitOptions.style.maxMarginFactor || MekkoChart.MaxMarginFactor;
	                };
	                MekkoChart.getChartViewport = function (viewport, margin) {
	                    return {
	                        width: viewport.width - margin.left - margin.right,
	                        height: viewport.height - margin.top - margin.bottom,
	                    };
	                };
	                MekkoChart.wordBreak = function (text, axisProperties, columnsWidth, maxHeight, borderWidth) {
	                    //var allowedLength = axisProperties.xLabelMaxWidth;
	                    text.each(function (data, index) {
	                        var width, allowedLength;
	                        var node = d3.select(this);
	                        if (columnsWidth.length >= index) {
	                            width = columnsWidth[index];
	                            allowedLength = axisProperties.scale(width);
	                        }
	                        else {
	                            allowedLength = axisProperties.xLabelMaxWidth;
	                        }
	                        // Reset style of text node
	                        node
	                            .style('text-anchor', 'middle')
	                            .attr({
	                            'dx': '0em',
	                            'dy': '1em',
	                            'transform': 'rotate(0)'
	                        });
	                        TextMeasurementService.wordBreak(this, allowedLength, axisProperties.willLabelsWordBreak ? maxHeight : 0);
	                    });
	                };
	                MekkoChart.prototype.renderChart = function (mainAxisScale, axes, width, tickLabelMargins, chartHasAxisLabels, axisLabels, viewport, suppressAnimations, scrollScale, extent) {
	                    var bottomMarginLimit = this.bottomMarginLimit;
	                    var leftRightMarginLimit = this.leftRightMarginLimit;
	                    var layers = this.layers;
	                    var duration = GetAnimationDuration(this.animator, suppressAnimations);
	                    var chartViewport = MekkoChart.getChartViewport(viewport, this.margin);
	                    debug.assertValue(layers, 'layers');
	                    var xLabelColor;
	                    var yLabelColor;
	                    var y2LabelColor;
	                    var xFontSize;
	                    var yFontSize;
	                    //hide show x-axis here
	                    if (this.shouldRenderAxis(axes.x)) {
	                        if (axes.x.isCategoryAxis) {
	                            xLabelColor = this.categoryAxisProperties && this.categoryAxisProperties['labelColor'] ? this.categoryAxisProperties['labelColor'] : null;
	                            xFontSize = this.categoryAxisProperties && this.categoryAxisProperties['fontSize'] != null ? this.categoryAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt;
	                        }
	                        else {
	                            xLabelColor = this.valueAxisProperties && this.valueAxisProperties['labelColor'] ? this.valueAxisProperties['labelColor'] : null;
	                            xFontSize = this.valueAxisProperties && this.valueAxisProperties['fontSize'] ? this.valueAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt;
	                        }
	                        axes.x.axis.orient("bottom");
	                        if (!axes.x.willLabelsFit) {
	                            axes.x.axis.tickPadding(MekkoChart.TickPaddingRotatedX);
	                        }
	                        var xAxisGraphicsElement = this.xAxisGraphicsContext;
	                        if (duration) {
	                            xAxisGraphicsElement
	                                .transition()
	                                .duration(duration)
	                                .call(axes.x.axis);
	                        }
	                        else {
	                            xAxisGraphicsElement
	                                .call(axes.x.axis);
	                        }
	                        xAxisGraphicsElement
	                            .call(MekkoChart.darkenZeroLine)
	                            .call(MekkoChart.setAxisLabelColor, xLabelColor)
	                            .call(MekkoChart.setAxisLabelFontSize, xFontSize);
	                        var xAxisTextNodes = xAxisGraphicsElement.selectAll('text');
	                        var columnWidth = [];
	                        var borderWidth = 0;
	                        if (this.layers && this.layers.length) {
	                            columnWidth = this.layers[0].getColumnsWidth();
	                            borderWidth = this.layers[0].getBorderWidth();
	                        }
	                        xAxisGraphicsElement
	                            .call(MekkoChart.moveBorder, axes.x.scale, borderWidth, xFontSize / 2 - 8);
	                        xAxisTextNodes
	                            .call(MekkoChart.wordBreak, axes.x, columnWidth, bottomMarginLimit, borderWidth);
	                    }
	                    else {
	                        this.xAxisGraphicsContext.selectAll('*').remove();
	                    }
	                    if (this.shouldRenderAxis(axes.y1)) {
	                        if (axes.y1.isCategoryAxis) {
	                            yLabelColor = this.categoryAxisProperties && this.categoryAxisProperties['labelColor'] ? this.categoryAxisProperties['labelColor'] : null;
	                            yFontSize = this.categoryAxisProperties && this.categoryAxisProperties['fontSize'] != null ? this.categoryAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt;
	                        }
	                        else {
	                            yLabelColor = this.valueAxisProperties && this.valueAxisProperties['labelColor'] ? this.valueAxisProperties['labelColor'] : null;
	                            yFontSize = this.valueAxisProperties && this.valueAxisProperties['fontSize'] != null ? this.valueAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt;
	                        }
	                        var yAxisOrientation = this.yAxisOrientation;
	                        var showY1OnRight = yAxisOrientation === yAxisPosition.right;
	                        axes.y1.axis
	                            .tickSize(-width)
	                            .tickPadding(MekkoChart.TickPaddingY)
	                            .orient(yAxisOrientation.toLowerCase());
	                        var y1AxisGraphicsElement = this.y1AxisGraphicsContext;
	                        if (duration) {
	                            y1AxisGraphicsElement
	                                .transition()
	                                .duration(duration)
	                                .call(axes.y1.axis);
	                        }
	                        else {
	                            y1AxisGraphicsElement
	                                .call(axes.y1.axis);
	                        }
	                        y1AxisGraphicsElement
	                            .call(MekkoChart.darkenZeroLine)
	                            .call(MekkoChart.setAxisLabelColor, yLabelColor)
	                            .call(MekkoChart.setAxisLabelFontSize, yFontSize);
	                        if (tickLabelMargins.yLeft >= leftRightMarginLimit) {
	                            y1AxisGraphicsElement.selectAll('text')
	                                .call(AxisHelper.LabelLayoutStrategy.clip, 
	                            // Can't use padding space to render text, so subtract that from available space for ellipses calculations
	                            leftRightMarginLimit - MekkoChart.LeftPadding, TextMeasurementService.svgEllipsis);
	                        }
	                        if (axes.y2 && (!this.valueAxisProperties || this.valueAxisProperties['secShow'] == null || this.valueAxisProperties['secShow'])) {
	                            y2LabelColor = this.valueAxisProperties && this.valueAxisProperties['secLabelColor'] ? this.valueAxisProperties['secLabelColor'] : null;
	                            axes.y2.axis
	                                .tickPadding(MekkoChart.TickPaddingY)
	                                .orient(showY1OnRight ? yAxisPosition.left.toLowerCase() : yAxisPosition.right.toLowerCase());
	                            if (duration) {
	                                this.y2AxisGraphicsContext
	                                    .transition()
	                                    .duration(duration)
	                                    .call(axes.y2.axis);
	                            }
	                            else {
	                                this.y2AxisGraphicsContext
	                                    .call(axes.y2.axis);
	                            }
	                            this.y2AxisGraphicsContext
	                                .call(MekkoChart.darkenZeroLine)
	                                .call(MekkoChart.setAxisLabelColor, y2LabelColor);
	                            if (tickLabelMargins.yRight >= leftRightMarginLimit) {
	                                this.y2AxisGraphicsContext.selectAll('text')
	                                    .call(AxisHelper.LabelLayoutStrategy.clip, 
	                                // Can't use padding space to render text, so subtract that from available space for ellipses calculations
	                                leftRightMarginLimit - MekkoChart.RightPadding, TextMeasurementService.svgEllipsis);
	                            }
	                        }
	                        else {
	                            this.y2AxisGraphicsContext.selectAll('*').remove();
	                        }
	                    }
	                    else {
	                        this.y1AxisGraphicsContext.selectAll('*').remove();
	                        this.y2AxisGraphicsContext.selectAll('*').remove();
	                    }
	                    // Axis labels
	                    if (chartHasAxisLabels) {
	                        var hideXAxisTitle = !this.shouldRenderAxis(axes.x, "showAxisTitle");
	                        var hideYAxisTitle = !this.shouldRenderAxis(axes.y1, "showAxisTitle");
	                        var hideY2AxisTitle = this.valueAxisProperties && this.valueAxisProperties["secShowAxisTitle"] != null && this.valueAxisProperties["secShowAxisTitle"] === false;
	                        var renderAxisOptions = {
	                            axisLabels: axisLabels,
	                            legendMargin: this.legendMargins.height,
	                            viewport: viewport,
	                            hideXAxisTitle: hideXAxisTitle,
	                            hideYAxisTitle: hideYAxisTitle,
	                            hideY2AxisTitle: hideY2AxisTitle,
	                            xLabelColor: xLabelColor,
	                            yLabelColor: yLabelColor,
	                            y2LabelColor: y2LabelColor,
	                            margin: undefined,
	                        };
	                        this.renderAxesLabels(renderAxisOptions);
	                    }
	                    else {
	                        this.axisGraphicsContext.selectAll('.xAxisLabel').remove();
	                        this.axisGraphicsContext.selectAll('.yAxisLabel').remove();
	                    }
	                    this.translateAxes(viewport);
	                    var dataPoints = [];
	                    var layerBehaviorOptions = [];
	                    var labelDataPointsGroup = [];
	                    //Render chart columns
	                    if (this.behavior) {
	                        for (var i = 0, len = layers.length; i < len; i++) {
	                            var result = layers[i].render(suppressAnimations);
	                            if (result) {
	                                dataPoints = dataPoints.concat(result.dataPoints);
	                                layerBehaviorOptions.push(result.behaviorOptions);
	                                if (result.labelDataPointGroups) {
	                                    var resultLabelDataPointsGroups = result.labelDataPointGroups;
	                                    for (var j = 0, jlen = resultLabelDataPointsGroups.length; j < jlen; j++) {
	                                        var resultLabelDataPointsGroup = resultLabelDataPointsGroups[j];
	                                        labelDataPointsGroup.push({
	                                            labelDataPoints: resultLabelDataPointsGroup.labelDataPoints,
	                                            maxNumberOfLabels: resultLabelDataPointsGroup.maxNumberOfLabels,
	                                        });
	                                    }
	                                }
	                                else {
	                                    var resultsLabelDataPoints = result.labelDataPoints;
	                                    var reducedDataPoints = resultsLabelDataPoints;
	                                    labelDataPointsGroup.push({
	                                        labelDataPoints: reducedDataPoints,
	                                        maxNumberOfLabels: reducedDataPoints.length,
	                                    });
	                                }
	                            }
	                        }
	                        var labelLayoutOptions = {
	                            maximumOffset: NewDataLabelUtils.maxLabelOffset,
	                            startingOffset: NewDataLabelUtils.startingLabelOffset
	                        };
	                        var labelLayout = new LabelLayout(labelLayoutOptions);
	                        var dataLabels = labelLayout.layout(labelDataPointsGroup, chartViewport);
	                        if (layers.length > 1) {
	                            NewDataLabelUtils.drawLabelBackground(this.labelGraphicsContextScrollable, dataLabels, "#FFFFFF", 0.7);
	                        }
	                        if (this.animator && !suppressAnimations) {
	                            NewDataLabelUtils.animateDefaultLabels(this.labelGraphicsContextScrollable, dataLabels, this.animator.getDuration());
	                        }
	                        else {
	                            NewDataLabelUtils.drawDefaultLabels(this.labelGraphicsContextScrollable, dataLabels);
	                        }
	                        this.labelGraphicsContextScrollable.selectAll("text.label").style("pointer-events", "none");
	                        if (this.interactivityService) {
	                            var behaviorOptions = {
	                                layerOptions: layerBehaviorOptions,
	                                clearCatcher: this.clearCatcher,
	                            };
	                            this.interactivityService.bind(dataPoints, this.behavior, behaviorOptions);
	                        }
	                    }
	                };
	                /**
	                 * Within the context of the given selection (g), find the offset of
	                 * the zero tick using the d3 attached datum of g.tick elements.
	                 * 'Classed' is undefined for transition selections
	                 */
	                MekkoChart.darkenZeroLine = function (g) {
	                    var zeroTick = g.selectAll('g.tick').filter(function (data) { return data === 0; }).node();
	                    if (zeroTick) {
	                        d3.select(zeroTick).select('line').classed('zero-line', true);
	                    }
	                };
	                MekkoChart.setAxisLabelColor = function (g, fill) {
	                    g.selectAll('g.tick text').style('fill', fill ? fill.solid.color : null);
	                };
	                MekkoChart.setAxisLabelFontSize = function (g, fontSize) {
	                    var value = PixelConverter.toString(fontSize);
	                    g.selectAll('g.tick text').attr('font-size', value);
	                };
	                MekkoChart.moveBorder = function (g, scale, borderWidth, yOffset) {
	                    if (yOffset === void 0) { yOffset = 0; }
	                    g.selectAll('g.tick')
	                        .attr("transform", function (value, index) {
	                        return SVGUtil.translate(scale(value) + (borderWidth * index), yOffset);
	                    });
	                };
	                MekkoChart.Classes = {
	                    series: createClassAndSelector('series')
	                };
	                MekkoChart.capabilities = {
	                    dataRoles: [
	                        {
	                            name: 'Category',
	                            kind: VisualDataRoleKind.Grouping,
	                            displayName: 'Category',
	                        }, {
	                            name: 'Series',
	                            kind: VisualDataRoleKind.Grouping,
	                            displayName: 'Series',
	                        }, {
	                            name: 'Y',
	                            kind: VisualDataRoleKind.Measure,
	                            displayName: 'Y Axis',
	                        }, {
	                            name: 'Width',
	                            kind: VisualDataRoleKind.Measure,
	                            displayName: 'Axis width',
	                        }
	                    ],
	                    objects: {
	                        columnBorder: {
	                            displayName: 'Column Border',
	                            properties: {
	                                show: {
	                                    displayName: createDisplayNameGetter('Visual_Show'),
	                                    type: { bool: true }
	                                },
	                                color: {
	                                    displayName: createDisplayNameGetter('Visual_LabelsFill'),
	                                    description: createDisplayNameGetter('Visual_LabelsFillDescription'),
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                width: {
	                                    displayName: 'Width',
	                                    type: { numeric: true }
	                                },
	                            },
	                        },
	                        labels: {
	                            displayName: createDisplayNameGetter('Visual_DataPointsLabels'),
	                            description: createDisplayNameGetter('Visual_DataPointsLabelsDescription'),
	                            properties: {
	                                show: {
	                                    displayName: createDisplayNameGetter('Visual_Show'),
	                                    type: { bool: true }
	                                },
	                                showSeries: {
	                                    displayName: createDisplayNameGetter('Visual_Show'),
	                                    type: { bool: true }
	                                },
	                                color: {
	                                    displayName: createDisplayNameGetter('Visual_LabelsFill'),
	                                    description: createDisplayNameGetter('Visual_LabelsFillDescription'),
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                labelDisplayUnits: {
	                                    displayName: createDisplayNameGetter('Visual_DisplayUnits'),
	                                    description: createDisplayNameGetter('Visual_DisplayUnitsDescription'),
	                                    type: { formatting: { labelDisplayUnits: true } },
	                                    suppressFormatPainterCopy: true
	                                },
	                                labelPrecision: {
	                                    displayName: createDisplayNameGetter('Visual_Precision'),
	                                    description: createDisplayNameGetter('Visual_PrecisionDescription'),
	                                    placeHolderText: createDisplayNameGetter('Visual_Precision_Auto'),
	                                    type: { numeric: true },
	                                    suppressFormatPainterCopy: true
	                                },
	                                showAll: {
	                                    displayName: createDisplayNameGetter('Visual_ShowAll'),
	                                    type: { bool: true }
	                                },
	                                fontSize: {
	                                    displayName: createDisplayNameGetter('Visual_TextSize'),
	                                    type: { formatting: { fontSize: true } }
	                                },
	                            },
	                        },
	                        legend: {
	                            displayName: createDisplayNameGetter('Visual_Legend'),
	                            properties: {
	                                show: {
	                                    displayName: createDisplayNameGetter('Visual_Show'),
	                                    type: { bool: true }
	                                },
	                                position: {
	                                    displayName: createDisplayNameGetter('Visual_LegendPosition'),
	                                    type: { formatting: { legendPosition: true } }
	                                },
	                                showTitle: {
	                                    displayName: createDisplayNameGetter('Visual_LegendShowTitle'),
	                                    type: { bool: true }
	                                },
	                                titleText: {
	                                    displayName: 'Title text',
	                                    type: { text: true }
	                                },
	                                fontSize: {
	                                    displayName: 'Text size',
	                                    type: { formatting: { fontSize: true } }
	                                },
	                            }
	                        },
	                        categoryAxis: {
	                            displayName: createDisplayNameGetter('Visual_XAxis'),
	                            properties: {
	                                show: {
	                                    displayName: createDisplayNameGetter('Visual_Show'),
	                                    type: { bool: true }
	                                },
	                                position: {
	                                    displayName: createDisplayNameGetter('Visual_YAxis_Position'),
	                                    type: { formatting: { yAxisPosition: true } }
	                                },
	                                axisScale: {
	                                    displayName: createDisplayNameGetter('Visual_Axis_Scale'),
	                                    type: { formatting: { axisScale: true } }
	                                },
	                                axisType: {
	                                    displayName: createDisplayNameGetter('Visual_Axis_Type'),
	                                    type: { formatting: { axisType: true } }
	                                },
	                                showAxisTitle: {
	                                    displayName: createDisplayNameGetter('Visual_Axis_Title'),
	                                    type: { bool: true }
	                                },
	                                axisStyle: {
	                                    displayName: createDisplayNameGetter('Visual_Axis_Style'),
	                                    type: { formatting: { axisStyle: true } }
	                                },
	                                labelColor: {
	                                    displayName: createDisplayNameGetter('Visual_Axis_LabelColor'),
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                fontSize: {
	                                    displayName: createDisplayNameGetter('Visual_TextSize'),
	                                    type: { formatting: { fontSize: true } }
	                                },
	                            }
	                        },
	                        valueAxis: {
	                            displayName: createDisplayNameGetter('Visual_YAxis'),
	                            properties: {
	                                show: {
	                                    displayName: createDisplayNameGetter('Visual_Show'),
	                                    type: { bool: true }
	                                },
	                                position: {
	                                    displayName: createDisplayNameGetter('Visual_YAxis_Position'),
	                                    type: { formatting: { yAxisPosition: true } }
	                                },
	                                axisScale: {
	                                    displayName: createDisplayNameGetter('Visual_Axis_Scale'),
	                                    type: { formatting: { axisScale: true } }
	                                },
	                                intersection: {
	                                    displayName: createDisplayNameGetter('Visual_Axis_Intersection'),
	                                    type: { numeric: true }
	                                },
	                                showAxisTitle: {
	                                    displayName: createDisplayNameGetter('Visual_Axis_Title'),
	                                    type: { bool: true }
	                                },
	                                axisStyle: {
	                                    displayName: createDisplayNameGetter('Visual_Axis_Style'),
	                                    type: { formatting: { axisStyle: true } }
	                                },
	                                labelColor: {
	                                    displayName: createDisplayNameGetter('Visual_Axis_LabelColor'),
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                fontSize: {
	                                    displayName: createDisplayNameGetter('Visual_TextSize'),
	                                    type: { formatting: { fontSize: true } }
	                                }
	                            }
	                        },
	                        dataPoint: {
	                            displayName: createDisplayNameGetter('Visual_DataPoint'),
	                            properties: {
	                                defaultColor: {
	                                    displayName: createDisplayNameGetter('Visual_DefaultColor'),
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                showAllDataPoints: {
	                                    displayName: createDisplayNameGetter('Visual_DataPoint_Show_All'),
	                                    type: { bool: true }
	                                },
	                                fill: {
	                                    displayName: createDisplayNameGetter('Visual_Fill'),
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                fillRule: {
	                                    displayName: createDisplayNameGetter('Visual_Gradient'),
	                                    type: { fillRule: {} },
	                                    rule: {
	                                        inputRole: 'Gradient',
	                                        output: {
	                                            property: 'fill',
	                                            selector: ['Category'],
	                                        },
	                                    },
	                                }
	                            }
	                        },
	                    },
	                    dataViewMappings: [{
	                            conditions: [
	                                { 'Category': { min: 0, max: 1 }, 'Series': { min: 0, max: 1 }, 'Y': { min: 0, max: 1 }, 'Width': { min: 0, max: 1 } },
	                            ],
	                            categorical: {
	                                categories: {
	                                    for: { in: 'Category' },
	                                    dataReductionAlgorithm: { top: {} }
	                                },
	                                values: {
	                                    group: {
	                                        by: 'Series',
	                                        select: [{ for: { in: 'Y' } }, { for: { in: 'Width' } }],
	                                        dataReductionAlgorithm: { top: {} }
	                                    }
	                                },
	                                rowCount: { preferred: { min: 1, max: 1 }, supported: { min: 0 } }
	                            },
	                        }],
	                    supportsHighlight: true,
	                    sorting: {
	                        default: {},
	                    },
	                    drilldown: {
	                        roles: ['Category']
	                    },
	                };
	                MekkoChart.Properties = {
	                    dataPoint: {
	                        defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
	                        fill: { objectName: 'dataPoint', propertyName: 'fill' },
	                        showAllDataPoints: { objectName: 'dataPoint', propertyName: 'showAllDataPoints' },
	                    },
	                    general: {
	                        formatString: { objectName: 'general', propertyName: 'formatString' }
	                    },
	                    columnBorder: {
	                        show: { objectName: 'columnBorder', propertyName: 'show', },
	                        color: { objectName: 'columnBorder', propertyName: 'color' },
	                        width: { objectName: 'columnBorder', propertyName: 'width' }
	                    }
	                };
	                MekkoChart.DefaultSettings = {
	                    columnBorder: {
	                        show: true,
	                        color: '#fff',
	                        width: 2,
	                        maxWidth: 5,
	                    },
	                    labelSettings: {
	                        maxPrecision: 4,
	                        minPrecision: 0,
	                    }
	                };
	                MekkoChart.MinOrdinalRectThickness = 20;
	                MekkoChart.MinScalarRectThickness = 2;
	                MekkoChart.OuterPaddingRatio = 0.4;
	                MekkoChart.InnerPaddingRatio = 0.2;
	                MekkoChart.TickLabelPadding = 2;
	                MekkoChart.ClassName = 'cartesianChart';
	                MekkoChart.AxisGraphicsContextClassName = 'axisGraphicsContext';
	                MekkoChart.MaxMarginFactor = 0.25;
	                MekkoChart.MinBottomMargin = 50;
	                MekkoChart.LeftPadding = 10;
	                MekkoChart.RightPadding = 10;
	                MekkoChart.BottomPadding = 16;
	                MekkoChart.YAxisLabelPadding = 20;
	                MekkoChart.XAxisLabelPadding = 20;
	                MekkoChart.TickPaddingY = 10;
	                MekkoChart.TickPaddingRotatedX = 5;
	                MekkoChart.FontSize = 11;
	                MekkoChart.MaxNumberOfLabels = 100;
	                MekkoChart.MinWidth = 100;
	                MekkoChart.MinHeight = 100;
	                MekkoChart.ScrollBarWidth = 10;
	                return MekkoChart;
	            }());
	            samples.MekkoChart = MekkoChart;
	            function getTickLabelMargins(viewport, yMarginLimit, textWidthMeasurer, textHeightMeasurer, axes, bottomMarginLimit, xAxisTextProperties, y1AxisTextProperties, y2AxisTextProperties, enableOverflowCheck, scrollbarVisible, showOnRight, renderXAxis, renderY1Axis, renderY2Axis) {
	                var XLabelMaxAllowedOverflow = 35;
	                debug.assertValue(axes, 'axes');
	                var xAxisProperties = axes.x;
	                var y1AxisProperties = axes.y1;
	                var y2AxisProperties = axes.y2;
	                debug.assertValue(viewport, 'viewport');
	                debug.assertValue(textWidthMeasurer, 'textWidthMeasurer');
	                debug.assertValue(textHeightMeasurer, 'textHeightMeasurer');
	                debug.assertValue(xAxisProperties, 'xAxis');
	                debug.assertValue(y1AxisProperties, 'yAxis');
	                var xLabels = xAxisProperties.values;
	                var y1Labels = y1AxisProperties.values;
	                var leftOverflow = 0;
	                var rightOverflow = 0;
	                var maxWidthY1 = 0;
	                var maxWidthY2 = 0;
	                var xMax = 0; // bottom margin
	                var ordinalLabelOffset = xAxisProperties.categoryThickness ? xAxisProperties.categoryThickness / 2 : 0;
	                var scaleIsOrdinal = AxisHelper.isOrdinalScale(xAxisProperties.scale);
	                var xLabelOuterPadding = 0;
	                if (xAxisProperties.outerPadding !== undefined) {
	                    xLabelOuterPadding = xAxisProperties.outerPadding;
	                }
	                else if (xAxisProperties.xLabelMaxWidth !== undefined) {
	                    xLabelOuterPadding = Math.max(0, (viewport.width - xAxisProperties.xLabelMaxWidth * xLabels.length) / 2);
	                }
	                if (AxisHelper.getRecommendedNumberOfTicksForXAxis(viewport.width) !== 0
	                    || AxisHelper.getRecommendedNumberOfTicksForYAxis(viewport.height) !== 0) {
	                    var rotation;
	                    if (scrollbarVisible)
	                        rotation = AxisHelper.LabelLayoutStrategy.DefaultRotationWithScrollbar;
	                    else
	                        rotation = AxisHelper.LabelLayoutStrategy.DefaultRotation;
	                    if (renderY1Axis) {
	                        for (var i = 0, len = y1Labels.length; i < len; i++) {
	                            y1AxisTextProperties.text = y1Labels[i];
	                            maxWidthY1 = Math.max(maxWidthY1, textWidthMeasurer(y1AxisTextProperties));
	                        }
	                    }
	                    if (y2AxisProperties && renderY2Axis) {
	                        var y2Labels = y2AxisProperties.values;
	                        for (var i = 0, len = y2Labels.length; i < len; i++) {
	                            y2AxisTextProperties.text = y2Labels[i];
	                            maxWidthY2 = Math.max(maxWidthY2, textWidthMeasurer(y2AxisTextProperties));
	                        }
	                    }
	                    var textHeight = textHeightMeasurer(xAxisTextProperties);
	                    var maxNumLines = Math.floor(bottomMarginLimit / textHeight);
	                    var xScale = xAxisProperties.scale;
	                    var xDomain = xScale.domain();
	                    if (renderXAxis && xLabels.length > 0) {
	                        for (var i = 0, len = xLabels.length; i < len; i++) {
	                            // find the max height of the x-labels, perhaps rotated or wrapped
	                            var height;
	                            xAxisTextProperties.text = xLabels[i];
	                            var width = textWidthMeasurer(xAxisTextProperties);
	                            if (xAxisProperties.willLabelsWordBreak) {
	                                // Split label and count rows
	                                var wordBreaks = WordBreaker.splitByWidth(xAxisTextProperties.text, xAxisTextProperties, textWidthMeasurer, xAxisProperties.xLabelMaxWidth, maxNumLines);
	                                height = wordBreaks.length * textHeight;
	                                // word wrapping will truncate at xLabelMaxWidth
	                                width = xAxisProperties.xLabelMaxWidth;
	                            }
	                            else if (!xAxisProperties.willLabelsFit && scaleIsOrdinal) {
	                                height = width * rotation.sine;
	                                width = width * rotation.cosine;
	                            }
	                            else {
	                                height = textHeight;
	                            }
	                            // calculate left and right overflow due to wide X labels
	                            // (Note: no right overflow when rotated)
	                            if (i === 0) {
	                                if (scaleIsOrdinal) {
	                                    if (!xAxisProperties.willLabelsFit /*rotated text*/)
	                                        leftOverflow = width - ordinalLabelOffset - xLabelOuterPadding;
	                                    else
	                                        leftOverflow = (width / 2) - ordinalLabelOffset - xLabelOuterPadding;
	                                    leftOverflow = Math.max(leftOverflow, 0);
	                                }
	                                else if (xDomain.length > 1) {
	                                    // Scalar - do some math
	                                    var xPos = xScale(xDomain[0]);
	                                    // xPos already incorporates xLabelOuterPadding, don't subtract it twice
	                                    leftOverflow = (width / 2) - xPos;
	                                    leftOverflow = Math.max(leftOverflow, 0);
	                                }
	                            }
	                            else if (i === len - 1) {
	                                if (scaleIsOrdinal) {
	                                    // if we are rotating text (!willLabelsFit) there won't be any right overflow
	                                    if (xAxisProperties.willLabelsFit || xAxisProperties.willLabelsWordBreak) {
	                                        // assume this label is placed near the edge
	                                        rightOverflow = (width / 2) - ordinalLabelOffset - xLabelOuterPadding;
	                                        rightOverflow = Math.max(rightOverflow, 0);
	                                    }
	                                }
	                                else if (xDomain.length > 1) {
	                                    // Scalar - do some math
	                                    var xPos = xScale(xDomain[1]);
	                                    // xPos already incorporates xLabelOuterPadding, don't subtract it twice
	                                    rightOverflow = (width / 2) - (viewport.width - xPos);
	                                    rightOverflow = Math.max(rightOverflow, 0);
	                                }
	                            }
	                            xMax = Math.max(xMax, height);
	                        }
	                        // trim any actual overflow to the limit
	                        leftOverflow = enableOverflowCheck ? Math.min(leftOverflow, XLabelMaxAllowedOverflow) : 0;
	                        rightOverflow = enableOverflowCheck ? Math.min(rightOverflow, XLabelMaxAllowedOverflow) : 0;
	                    }
	                }
	                var rightMargin = 0, leftMargin = 0, bottomMargin = Math.min(Math.ceil(xMax), bottomMarginLimit);
	                if (showOnRight) {
	                    leftMargin = Math.min(Math.max(leftOverflow, maxWidthY2), yMarginLimit);
	                    rightMargin = Math.min(Math.max(rightOverflow, maxWidthY1), yMarginLimit);
	                }
	                else {
	                    leftMargin = Math.min(Math.max(leftOverflow, maxWidthY1), yMarginLimit);
	                    rightMargin = Math.min(Math.max(rightOverflow, maxWidthY2), yMarginLimit);
	                }
	                return {
	                    xMax: Math.ceil(bottomMargin),
	                    yLeft: Math.ceil(leftMargin),
	                    yRight: Math.ceil(rightMargin),
	                };
	            }
	            function getLayerData(dataViews, currentIdx, totalLayers) {
	                if (totalLayers > 1) {
	                    if (dataViews && dataViews.length > currentIdx)
	                        return [dataViews[currentIdx]];
	                    return [];
	                }
	                return dataViews;
	            }
	            /**
	             * Returns a boolean, that indicates if y axis title should be displayed.
	             * @return True if y axis title should be displayed,
	             * otherwise false.
	             */
	            function shouldShowYAxisLabel(layerNumber, valueAxisProperties, yAxisWillMerge) {
	                return ((layerNumber === 0 && !!valueAxisProperties && !!valueAxisProperties['showAxisTitle']) ||
	                    (layerNumber === 1 && !yAxisWillMerge && !!valueAxisProperties && !!valueAxisProperties['secShowAxisTitle']));
	            }
	            /**
	             * Computes the Cartesian Chart axes from the set of layers.
	             */
	            function calculateAxes(layers, viewport, margin, categoryAxisProperties, valueAxisProperties, scrollbarVisible, existingAxisProperties) {
	                debug.assertValue(layers, 'layers');
	                var visualOptions = {
	                    viewport: viewport,
	                    margin: margin,
	                    forcedXDomain: [categoryAxisProperties ? categoryAxisProperties['start'] : null, categoryAxisProperties ? categoryAxisProperties['end'] : null],
	                    forceMerge: valueAxisProperties && valueAxisProperties['secShow'] === false,
	                    showCategoryAxisLabel: false,
	                    showValueAxisLabel: false,
	                    categoryAxisScaleType: categoryAxisProperties && categoryAxisProperties['axisScale'] != null ? categoryAxisProperties['axisScale'] : axisScale.linear,
	                    valueAxisScaleType: valueAxisProperties && valueAxisProperties['axisScale'] != null ? valueAxisProperties['axisScale'] : axisScale.linear,
	                    trimOrdinalDataOnOverflow: false
	                };
	                var yAxisWillMerge = false;
	                if (valueAxisProperties) {
	                    visualOptions.forcedYDomain = AxisHelper.applyCustomizedDomain([valueAxisProperties['start'], valueAxisProperties['end']], visualOptions.forcedYDomain);
	                }
	                var result;
	                for (var layerNumber = 0, len = layers.length; layerNumber < len; layerNumber++) {
	                    var currentlayer = layers[layerNumber];
	                    visualOptions.showCategoryAxisLabel = (!!categoryAxisProperties && !!categoryAxisProperties['showAxisTitle']); //here
	                    //visualOptions.showBorder = (!!categoryAxisProperties && !!categoryAxisProperties['showBorder']);//here
	                    visualOptions.showValueAxisLabel = shouldShowYAxisLabel(layerNumber, valueAxisProperties, yAxisWillMerge);
	                    var axes = currentlayer.calculateAxesProperties(visualOptions);
	                    if (layerNumber === 0) {
	                        result = {
	                            x: axes[0],
	                            y1: axes[1]
	                        };
	                    }
	                    result.x.willLabelsFit = false;
	                    result.x.willLabelsWordBreak = false;
	                }
	                return result;
	            }
	            function createLayers(type, objects, interactivityService, animator, isScrollable) {
	                if (isScrollable === void 0) { isScrollable = true; }
	                var layers = [];
	                var cartesianOptions = {
	                    isScrollable: isScrollable,
	                    animator: animator,
	                    interactivityService: interactivityService
	                };
	                layers.push(createMekkoChartLayer(MekkoVisualChartType.hundredPercentStackedColumn, cartesianOptions));
	                return layers;
	            }
	            samples.createLayers = createLayers;
	            function createMekkoChartLayer(type, defaultOptions) {
	                var options = {
	                    animator: defaultOptions.animator,
	                    interactivityService: defaultOptions.interactivityService,
	                    isScrollable: defaultOptions.isScrollable,
	                    chartType: type
	                };
	                return new MekkoColumnChart(options);
	            }
	            var RoleNames = {
	                category: 'Category',
	                series: 'Series',
	                y: 'Y',
	                width: 'Width'
	            };
	            // export interface IMekkoColumnChartStrategy /*extends IColumnChartStrategy*/ {
	            //     drawColumns(useAnimation: boolean): MekkoColumnChartDrawInfo;
	            //     setData(data: MekkoChartBaseData): void;
	            //     setupVisualProps(columnChartProps: MekkoChartContext): void;
	            //     setXScale(is100Pct: boolean, forcedTickCount?: number, forcedXDomain?: any[], axisScaleType?: string, axisDisplayUnits?: number, axisPrecision?: number): IAxisProperties;
	            //     setYScale(is100Pct: boolean, forcedTickCount?: number, forcedYDomain?: any[], axisScaleType?: string, axisDisplayUnits?: number, axisPrecision?: number): IAxisProperties;
	            //     selectColumn(selectedColumnIndex: number, lastSelectedColumnIndex: number): void;
	            //     getClosestColumnIndex(x: number, y: number): number;
	            // }
	            var MekkoColumnChart = (function () {
	                function MekkoColumnChart(options) {
	                    debug.assertValue(options, 'options');
	                    var chartType = options.chartType;
	                    debug.assertValue(chartType, 'chartType');
	                    this.chartType = chartType;
	                    this.categoryAxisType = null;
	                    this.animator = options.animator;
	                    this.isScrollable = options.isScrollable;
	                    this.interactivityService = options.interactivityService;
	                }
	                MekkoColumnChart.prototype.init = function (options) {
	                    this.svg = options.svg;
	                    this.unclippedGraphicsContext = this.svg.append('g').classed('columnChartUnclippedGraphicsContext', true);
	                    this.mainGraphicsContext = this.unclippedGraphicsContext.append('svg').classed('columnChartMainGraphicsContext', true);
	                    this.labelGraphicsContext = this.svg.append('g').classed(NewDataLabelUtils.labelGraphicsContextClass.class, true);
	                    this.style = options.style;
	                    this.currentViewport = options.viewport;
	                    this.hostService = options.host;
	                    this.interactivity = options.interactivity;
	                    this.colors = this.style.colorPalette.dataColors;
	                    this.cartesianVisualHost = options.cartesianHost;
	                    this.options = options;
	                    this.supportsOverflow = !EnumExtensions.hasFlag(this.chartType, flagStacked);
	                    var element = this.element = options.element;
	                    element.addClass(MekkoColumnChart.ColumnChartClassName);
	                    this.columnChart = new MekkoChartStrategy();
	                };
	                MekkoColumnChart.prototype.getCategoryLayout = function (numCategoryValues, options) {
	                    var availableWidth = this.currentViewport.width - (this.margin.left + this.margin.right);
	                    var metaDataColumn = this.data ? this.data.categoryMetadata : undefined;
	                    var categoryDataType = AxisHelper.getCategoryValueType(metaDataColumn);
	                    var isScalar = this.data ? this.data.scalarCategoryAxis : false;
	                    var domain = AxisHelper.createDomain(this.data.series, categoryDataType, isScalar, options.forcedXDomain);
	                    return MekkoChart.getLayout(this.data, {
	                        availableWidth: availableWidth,
	                        categoryCount: numCategoryValues,
	                        domain: domain,
	                        isScalar: isScalar,
	                        isScrollable: this.isScrollable,
	                        trimOrdinalDataOnOverflow: false
	                    });
	                };
	                MekkoColumnChart.getBorderWidth = function (border) {
	                    if (!border ||
	                        !border.show ||
	                        !border.width) {
	                        return 0;
	                    }
	                    var width = border.width;
	                    if (width < 0) {
	                        return 0;
	                    }
	                    if (width > border.maxWidth) {
	                        return border.maxWidth;
	                    }
	                    return width;
	                };
	                MekkoColumnChart.getBorderColor = function (border) {
	                    if (!border) {
	                        return MekkoChart.DefaultSettings.columnBorder.color;
	                    }
	                    return border.color;
	                };
	                MekkoColumnChart.converter = function (dataView, colors, is100PercentStacked, isScalar, supportsOverflow, dataViewMetadata, chartType) {
	                    if (is100PercentStacked === void 0) { is100PercentStacked = false; }
	                    if (isScalar === void 0) { isScalar = false; }
	                    if (supportsOverflow === void 0) { supportsOverflow = false; }
	                    if (dataViewMetadata === void 0) { dataViewMetadata = null; }
	                    debug.assertValue(dataView, 'dataView');
	                    debug.assertValue(colors, 'colors');
	                    var xAxisCardProperties = MekkochartHelper.getCategoryAxisProperties(dataViewMetadata);
	                    var valueAxisProperties = MekkochartHelper.getValueAxisProperties(dataViewMetadata);
	                    isScalar = MekkochartHelper.isScalar(isScalar, xAxisCardProperties);
	                    dataView = MekkoChartUtils.applyUserMinMax(isScalar, dataView, xAxisCardProperties);
	                    var converterStrategy = new MekkoChartConverterHelper(dataView);
	                    var categoryInfo = converterHelper.getPivotedCategories(dataView, MekkoChart.Properties["general"]["formatString"]);
	                    var categories = categoryInfo.categories, categoryFormatter = categoryInfo.categoryFormatter, categoryIdentities = categoryInfo.categoryIdentities, categoryMetadata = dataView.categories && dataView.categories.length > 0 ? dataView.categories[0].source : undefined;
	                    //labelFormatString: string = dataView.values && dataView.values[0] ? valueFormatter.getFormatString(dataView.values[0].source, columnChartProps.general.formatString) : undefined;
	                    var borderSettings = MekkoChart.DefaultSettings.columnBorder;
	                    var labelSettings = dataLabelUtils.getDefaultColumnLabelSettings(true);
	                    var defaultDataPointColor = undefined;
	                    var showAllDataPoints = undefined;
	                    if (dataViewMetadata && dataViewMetadata.objects) {
	                        var objects = dataViewMetadata.objects;
	                        defaultDataPointColor = DataViewObjects.getFillColor(objects, MekkoChart.Properties["dataPoint"]["defaultColor"]);
	                        showAllDataPoints = DataViewObjects.getValue(objects, MekkoChart.Properties["dataPoint"]["showAllDataPoints"]);
	                        labelSettings = MekkoChart.parseLabelSettings(objects);
	                        borderSettings = MekkoChart.parseBorderSettings(objects);
	                    }
	                    // Allocate colors
	                    var legendAndSeriesInfo = converterStrategy.getLegend(colors, defaultDataPointColor);
	                    var legend = legendAndSeriesInfo.legend.dataPoints;
	                    var seriesSources = legendAndSeriesInfo.seriesSources;
	                    // Determine data points
	                    var result = MekkoColumnChart.createDataPoints(dataView, categories, categoryIdentities, legend, legendAndSeriesInfo.seriesObjects, converterStrategy, labelSettings, is100PercentStacked, isScalar, supportsOverflow, converterHelper.categoryIsAlsoSeriesRole(dataView, RoleNames.series, RoleNames.category), categoryInfo.categoryObjects, defaultDataPointColor, chartType, categoryMetadata);
	                    var columnSeries = result.series;
	                    var valuesMetadata = [];
	                    for (var j = 0, jlen = legend.length; j < jlen; j++) {
	                        valuesMetadata.push(seriesSources[j]);
	                    }
	                    var labels = converterHelper.createAxesLabels(xAxisCardProperties, valueAxisProperties, categoryMetadata, valuesMetadata);
	                    return {
	                        categories: categories,
	                        categoriesWidth: result.categoriesWidth,
	                        categoryFormatter: categoryFormatter,
	                        series: columnSeries,
	                        valuesMetadata: valuesMetadata,
	                        legendData: legendAndSeriesInfo.legend,
	                        hasHighlights: result.hasHighlights,
	                        categoryMetadata: categoryMetadata,
	                        scalarCategoryAxis: isScalar,
	                        borderSettings: borderSettings,
	                        labelSettings: labelSettings,
	                        axesLabels: { x: labels.xAxisLabel, y: labels.yAxisLabel },
	                        hasDynamicSeries: result.hasDynamicSeries,
	                        defaultDataPointColor: defaultDataPointColor,
	                        showAllDataPoints: showAllDataPoints,
	                        isMultiMeasure: false,
	                    };
	                };
	                MekkoColumnChart.getStackedMultiplier = function (rawValues, rowIdx, seriesCount, categoryCount) {
	                    var pos = 0, neg = 0;
	                    for (var i = 0; i < seriesCount; i++) {
	                        var value = rawValues[i][rowIdx];
	                        value = AxisHelper.normalizeNonFiniteNumber(value);
	                        if (value > 0) {
	                            pos += value;
	                        }
	                        else if (value < 0) {
	                            neg -= value;
	                        }
	                    }
	                    var absTotal = pos + neg;
	                    return {
	                        pos: pos ? (pos / absTotal) / pos : 1,
	                        neg: neg ? (neg / absTotal) / neg : 1,
	                    };
	                };
	                MekkoColumnChart.createDataPoints = function (dataViewCat, categories, categoryIdentities, legend, seriesObjectsList, converterStrategy, defaultLabelSettings, is100PercentStacked, isScalar, supportsOverflow, isCategoryAlsoSeries, categoryObjectsList, defaultDataPointColor, chartType, categoryMetadata) {
	                    if (is100PercentStacked === void 0) { is100PercentStacked = false; }
	                    if (isScalar === void 0) { isScalar = false; }
	                    if (supportsOverflow === void 0) { supportsOverflow = false; }
	                    var grouped = dataViewCat && dataViewCat.values ? dataViewCat.values.grouped() : undefined;
	                    var categoryCount = categories.length;
	                    var seriesCount = legend.length;
	                    var columnSeries = [];
	                    if (seriesCount < 1 || categoryCount < 1 || categories[0] === null) {
	                        return {
	                            series: columnSeries,
	                            hasHighlights: false,
	                            hasDynamicSeries: false,
	                            categoriesWidth: [],
	                        };
	                    }
	                    var dvCategories = dataViewCat.categories;
	                    categoryMetadata = (dvCategories && dvCategories.length > 0)
	                        ? dvCategories[0].source
	                        : null;
	                    var categoryType = AxisHelper.getCategoryValueType(categoryMetadata);
	                    var isDateTime = AxisHelper.isDateTime(categoryType);
	                    var baseValuesPos = [], baseValuesNeg = [];
	                    var rawValues = [];
	                    var rawHighlightValues = [];
	                    var hasDynamicSeries = !!(dataViewCat.values && dataViewCat.values.source);
	                    var widthColumns = [];
	                    var widthIndex = -1;
	                    var seriesIndex = 0;
	                    var highlightsOverflow = false; // Overflow means the highlight larger than value or the signs being different
	                    var hasHighlights = converterStrategy.hasHighlightValues(0);
	                    for (seriesIndex = 0; seriesIndex < dataViewCat.values.length; seriesIndex++) {
	                        if (dataViewCat.values[seriesIndex].source.roles &&
	                            dataViewCat.values[seriesIndex].source.roles[RoleNames.width] &&
	                            !dataViewCat.values[seriesIndex].source.roles[RoleNames.y]) {
	                            widthIndex = seriesIndex;
	                            var widthValues = dataViewCat.values[seriesIndex].values;
	                            for (var i = 0, valuesLen = widthValues.length; i < valuesLen; i++) {
	                                widthColumns[i] = d3.sum([0, widthColumns[i], widthValues[i]]);
	                            }
	                            continue;
	                        }
	                        var seriesValues = [];
	                        var seriesHighlightValues = [];
	                        for (var categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) {
	                            var value = converterStrategy.getValueBySeriesAndCategory(seriesIndex, categoryIndex);
	                            seriesValues[categoryIndex] = value;
	                            if (hasHighlights) {
	                                var highlightValue = converterStrategy.getHighlightBySeriesAndCategory(seriesIndex, categoryIndex);
	                                seriesHighlightValues[categoryIndex] = highlightValue;
	                                // There are two cases where we don't use overflow logic; if all are false, use overflow logic appropriate for the chart.
	                                if (!((value >= 0 && highlightValue >= 0 && value >= highlightValue) ||
	                                    (value <= 0 && highlightValue <= 0 && value <= highlightValue))) {
	                                    highlightsOverflow = true;
	                                }
	                            }
	                        }
	                        rawValues.push(seriesValues);
	                        if (hasHighlights) {
	                            rawHighlightValues.push(seriesHighlightValues);
	                        }
	                    }
	                    //console.log(dataViewCat);
	                    if (highlightsOverflow && !supportsOverflow) {
	                        highlightsOverflow = false;
	                        hasHighlights = false;
	                        rawValues = rawHighlightValues;
	                    }
	                    if (widthColumns.length < 1) {
	                        for (seriesIndex = 0; seriesIndex < dataViewCat.values.length; seriesIndex++) {
	                            if (dataViewCat.values[seriesIndex].source.roles &&
	                                dataViewCat.values[seriesIndex].source.roles[RoleNames.width]) {
	                                widthIndex = seriesIndex;
	                                var widthValues = dataViewCat.values[seriesIndex].values;
	                                for (var i = 0, valuesLen = widthValues.length; i < valuesLen; i++) {
	                                    widthColumns[i] = d3.sum([0, widthColumns[i], widthValues[i]]);
	                                }
	                                continue;
	                            }
	                        }
	                    }
	                    if (widthColumns.length < 1) {
	                        for (seriesIndex = 0; seriesIndex < categoryCount; seriesIndex++) {
	                            widthColumns.push(1);
	                        }
	                    }
	                    var totalSum = d3.sum(widthColumns);
	                    var linearScale = d3.scale.linear()
	                        .domain([0, totalSum])
	                        .range([0, 1]);
	                    var columnStartX = [0];
	                    var columnWidth = [];
	                    for (seriesIndex = 0; seriesIndex < (categoryCount - 1); seriesIndex++) {
	                        var stepWidth = columnStartX[columnStartX.length - 1] + (widthColumns[seriesIndex] || 0);
	                        columnStartX.push(stepWidth);
	                    }
	                    for (seriesIndex = 0; seriesIndex < categoryCount; seriesIndex++) {
	                        columnStartX[seriesIndex] = linearScale(columnStartX[seriesIndex]);
	                        columnWidth[seriesIndex] = linearScale(widthColumns[seriesIndex]);
	                    }
	                    var dataPointObjects = categoryObjectsList, formatStringProp = MekkoChart.Properties["general"]["formatString"];
	                    for (seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
	                        var seriesDataPoints = [], legendItem = legend[seriesIndex], seriesLabelSettings;
	                        if (!hasDynamicSeries) {
	                            var labelsSeriesGroup = grouped && grouped.length > 0 && grouped[0].values ? grouped[0].values[seriesIndex] : null;
	                            var labelObjects = (labelsSeriesGroup && labelsSeriesGroup.source && labelsSeriesGroup.source.objects) ? labelsSeriesGroup.source.objects['labels'] : null;
	                            if (labelObjects) {
	                                seriesLabelSettings = Prototype.inherit(defaultLabelSettings);
	                                dataLabelUtils.updateLabelSettingsFromLabelsObject(labelObjects, seriesLabelSettings);
	                            }
	                        }
	                        var series = {
	                            displayName: legendItem.label,
	                            key: 'series' + seriesIndex,
	                            index: seriesIndex,
	                            data: seriesDataPoints,
	                            identity: legendItem.identity,
	                            color: legendItem.color,
	                            labelSettings: seriesLabelSettings,
	                        };
	                        if (seriesCount > 1) {
	                            dataPointObjects = seriesObjectsList[seriesIndex];
	                        }
	                        var metadata = dataViewCat.values[seriesIndex].source;
	                        for (var categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) {
	                            if (seriesIndex === 0) {
	                                baseValuesPos.push(0);
	                                baseValuesNeg.push(0);
	                            }
	                            var value = AxisHelper.normalizeNonFiniteNumber(rawValues[seriesIndex][categoryIndex]);
	                            if (value == null) {
	                                // Optimization: Ignore null dataPoints from the fabricated category/series combination in the self cross-join.
	                                // However, we must retain the first series because it is used to compute things like axis scales, and value lookups.
	                                if (seriesIndex > 0) {
	                                    continue;
	                                }
	                            }
	                            var originalValue = value;
	                            var categoryValue = categories[categoryIndex];
	                            if (isDateTime && categoryValue) {
	                                categoryValue = categoryValue.getTime();
	                            }
	                            if (isScalar && (categoryValue == null || isNaN(categoryValue))) {
	                                continue;
	                            }
	                            var multipliers;
	                            if (is100PercentStacked) {
	                                multipliers = MekkoColumnChart.getStackedMultiplier(rawValues, categoryIndex, seriesCount, categoryCount);
	                            }
	                            var unadjustedValue = value, isNegative = value < 0;
	                            if (multipliers) {
	                                if (isNegative) {
	                                    value *= multipliers.neg;
	                                }
	                                else {
	                                    value *= multipliers.pos;
	                                }
	                            }
	                            var valueAbsolute = Math.abs(value);
	                            var position;
	                            if (isNegative) {
	                                position = baseValuesNeg[categoryIndex];
	                                if (!isNaN(valueAbsolute)) {
	                                    baseValuesNeg[categoryIndex] -= valueAbsolute;
	                                }
	                            }
	                            else {
	                                if (!isNaN(valueAbsolute)) {
	                                    baseValuesPos[categoryIndex] += valueAbsolute;
	                                }
	                                position = baseValuesPos[categoryIndex];
	                            }
	                            var columnGroup = grouped && grouped.length > seriesIndex && grouped[seriesIndex].values ? grouped[seriesIndex] : null;
	                            var category = dataViewCat.categories && dataViewCat.categories.length > 0 ? dataViewCat.categories[0] : null;
	                            var identity = SelectionIdBuilder.builder()
	                                .withCategory(category, categoryIndex)
	                                .withSeries(dataViewCat.values, columnGroup)
	                                .withMeasure(converterStrategy.getMeasureNameByIndex(seriesIndex))
	                                .createSelectionId();
	                            var rawCategoryValue = categories[categoryIndex];
	                            var color = MekkoColumnChart.getDataPointColor(legendItem, categoryIndex, dataPointObjects);
	                            var seriesData = [];
	                            if (columnGroup) {
	                                var seriesValueColumn = {
	                                    values: [],
	                                    source: dataViewCat.values.source,
	                                };
	                                seriesData.push({
	                                    value: columnGroup.name,
	                                    metadata: seriesValueColumn,
	                                });
	                                for (var columnIndex = 0; columnIndex < columnGroup.values.length; columnIndex++) {
	                                    var columnValues = columnGroup.values[columnIndex];
	                                    seriesData.push({
	                                        value: columnValues.values[categoryIndex],
	                                        metadata: columnValues,
	                                    });
	                                }
	                            }
	                            var tooltipInfo = TooltipBuilder.createTooltipInfo(formatStringProp, null /*dataViewCat*/, rawCategoryValue, originalValue, [category], seriesData, null /*seriesIndex*/, categoryIndex);
	                            var dataPointLabelSettings = (series && series.labelSettings) ? series.labelSettings : defaultLabelSettings;
	                            var labelColor = dataPointLabelSettings.labelColor;
	                            var lastValue = undefined;
	                            //Stacked column/bar label color is white by default (except last series)
	                            if ((EnumExtensions.hasFlag(chartType, flagStacked))) {
	                                lastValue = this.getStackedLabelColor(isNegative, seriesIndex, seriesCount, categoryIndex, rawValues);
	                                labelColor = (lastValue || (seriesIndex === seriesCount - 1 && !isNegative)) ? labelColor : dataLabelUtils.defaultInsideLabelColor;
	                            }
	                            value = columnWidth[categoryIndex];
	                            var originalPosition = columnStartX[categoryIndex];
	                            var dataPoint = {
	                                categoryValue: categoryValue,
	                                value: value,
	                                position: position,
	                                valueAbsolute: valueAbsolute,
	                                valueOriginal: unadjustedValue,
	                                seriesIndex: seriesIndex,
	                                labelSettings: dataPointLabelSettings,
	                                categoryIndex: categoryIndex,
	                                color: color,
	                                selected: false,
	                                originalValue: value,
	                                originalPosition: originalPosition,
	                                originalValueAbsolute: valueAbsolute,
	                                identity: identity,
	                                key: identity.getKey(),
	                                tooltipInfo: tooltipInfo,
	                                labelFill: labelColor,
	                                labelFormatString: metadata.format,
	                                lastSeries: lastValue,
	                                chartType: chartType,
	                            };
	                            seriesDataPoints.push(dataPoint);
	                            if (hasHighlights) {
	                                var valueHighlight = rawHighlightValues[seriesIndex][categoryIndex];
	                                var unadjustedValueHighlight = valueHighlight;
	                                var highlightedTooltip = true;
	                                if (valueHighlight === null) {
	                                    valueHighlight = 0;
	                                    highlightedTooltip = false;
	                                }
	                                if (is100PercentStacked) {
	                                    valueHighlight *= multipliers.pos;
	                                }
	                                var absoluteValueHighlight = Math.abs(valueHighlight);
	                                var highlightPosition = position;
	                                if (valueHighlight > 0) {
	                                    highlightPosition -= valueAbsolute - absoluteValueHighlight;
	                                }
	                                else if (valueHighlight === 0 && value > 0) {
	                                    highlightPosition -= valueAbsolute;
	                                }
	                                var highlightIdentity = SelectionId.createWithHighlight(identity);
	                                var rawCategoryValue = categories[categoryIndex];
	                                //var highlightedValue: number = highlightedTooltip ? valueHighlight : undefined;
	                                //var tooltipInfo: TooltipDataItem[] = TooltipBuilder.createTooltipInfo(formatStringProp, dataViewCat, rawCategoryValue, originalValue, null, null, seriesIndex, categoryIndex, highlightedValue);
	                                if (highlightedTooltip) {
	                                    // Override non highlighted data point
	                                    dataPoint.tooltipInfo = tooltipInfo;
	                                }
	                                var highlightDataPoint = {
	                                    categoryValue: categoryValue,
	                                    value: value,
	                                    position: highlightPosition,
	                                    valueAbsolute: absoluteValueHighlight,
	                                    valueOriginal: unadjustedValueHighlight,
	                                    seriesIndex: seriesIndex,
	                                    labelSettings: dataPointLabelSettings,
	                                    categoryIndex: categoryIndex,
	                                    color: color,
	                                    selected: false,
	                                    highlight: true,
	                                    originalValue: value,
	                                    originalPosition: originalPosition,
	                                    originalValueAbsolute: valueAbsolute,
	                                    drawThinner: highlightsOverflow,
	                                    identity: highlightIdentity,
	                                    key: highlightIdentity.getKey(),
	                                    tooltipInfo: tooltipInfo,
	                                    labelFormatString: metadata.format,
	                                    labelFill: labelColor,
	                                    lastSeries: lastValue,
	                                    chartType: chartType,
	                                };
	                                seriesDataPoints.push(highlightDataPoint);
	                            }
	                        }
	                        columnSeries.push(series);
	                    }
	                    return {
	                        series: columnSeries,
	                        categoriesWidth: columnWidth,
	                        hasHighlights: hasHighlights,
	                        hasDynamicSeries: hasDynamicSeries,
	                    };
	                };
	                MekkoColumnChart.getDataPointColor = function (legendItem, categoryIndex, dataPointObjects) {
	                    debug.assertValue(legendItem, 'legendItem');
	                    debug.assertValue(categoryIndex, 'categoryIndex');
	                    debug.assertAnyValue(dataPointObjects, 'dataPointObjects');
	                    if (dataPointObjects) {
	                        var colorOverride = DataViewObjects.getFillColor(dataPointObjects[categoryIndex], MekkoChart.Properties["dataPoint"]["fill"]);
	                        if (colorOverride) {
	                            return colorOverride;
	                        }
	                    }
	                    return legendItem.color;
	                };
	                MekkoColumnChart.getStackedLabelColor = function (isNegative, seriesIndex, seriesCount, categoryIndex, rawValues) {
	                    var lastValue = !(isNegative && seriesIndex === seriesCount - 1 && seriesCount !== 1);
	                    //run for the next series and check if current series is last
	                    for (var i = seriesIndex + 1; i < seriesCount; i++) {
	                        var nextValues = AxisHelper.normalizeNonFiniteNumber(rawValues[i][categoryIndex]);
	                        if ((nextValues !== null) && (((!isNegative || (isNegative && seriesIndex === 0)) && nextValues > 0) || (isNegative && seriesIndex !== 0))) {
	                            lastValue = false;
	                            break;
	                        }
	                    }
	                    return lastValue;
	                };
	                MekkoColumnChart.sliceSeries = function (series, endIndex, startIndex) {
	                    if (startIndex === void 0) { startIndex = 0; }
	                    var newSeries = [];
	                    if (series && series.length > 0) {
	                        for (var i = 0, len = series.length; i < len; i++) {
	                            var iNewSeries = newSeries[i] = Prototype.inherit(series[i]);
	                            iNewSeries.data = series[i].data.filter(function (d) { return d.categoryIndex >= startIndex && d.categoryIndex < endIndex; });
	                        }
	                    }
	                    return newSeries;
	                };
	                MekkoColumnChart.getInteractiveColumnChartDomElement = function (element) {
	                    return element.children("svg").get(0);
	                };
	                MekkoColumnChart.prototype.getColumnsWidth = function () {
	                    var data = this.data;
	                    if (!data ||
	                        !data.series ||
	                        !data.series[0] ||
	                        !data.series[0].data) {
	                        return [];
	                    }
	                    return data.categoriesWidth;
	                };
	                MekkoColumnChart.prototype.getBorderWidth = function () {
	                    return MekkoColumnChart.getBorderWidth(this.data.borderSettings);
	                };
	                MekkoColumnChart.prototype.setData = function (dataViews) {
	                    debug.assertValue(dataViews, "dataViews");
	                    var is100PctStacked = true;
	                    this.data = {
	                        categories: [],
	                        categoriesWidth: [],
	                        categoryFormatter: null,
	                        series: [],
	                        valuesMetadata: [],
	                        legendData: null,
	                        hasHighlights: false,
	                        categoryMetadata: null,
	                        scalarCategoryAxis: false,
	                        borderSettings: null,
	                        labelSettings: dataLabelUtils.getDefaultColumnLabelSettings(is100PctStacked),
	                        axesLabels: { x: null, y: null },
	                        hasDynamicSeries: false,
	                        defaultDataPointColor: null,
	                        isMultiMeasure: false,
	                    };
	                    if (dataViews.length > 0) {
	                        var dataView = dataViews[0];
	                        if (dataView && dataView.categorical) {
	                            var dataViewCat = this.dataViewCat = dataView.categorical;
	                            this.data = MekkoColumnChart.converter(dataViewCat, this.cartesianVisualHost.getSharedColors(), true, //s100PctStacked,
	                            false, this.supportsOverflow, dataView.metadata, this.chartType);
	                            var series = this.data.series;
	                            for (var i = 0, ilen = series.length; i < ilen; i++) {
	                                var currentSeries = series[i];
	                                if (this.interactivityService) {
	                                    this.interactivityService.applySelectionStateToData(currentSeries.data);
	                                }
	                            }
	                        }
	                    }
	                };
	                MekkoColumnChart.prototype.calculateLegend = function () {
	                    // if we're in interactive mode, return the interactive legend
	                    if (this.interactivity && this.interactivity.isInteractiveLegend) {
	                        return this.createInteractiveMekkoLegendDataPoints(0);
	                    }
	                    var legendData = this.data ? this.data.legendData : null;
	                    var MekkoLegendDataPoints = legendData ? legendData.dataPoints : [];
	                    if (ArrayExtensions.isUndefinedOrEmpty(MekkoLegendDataPoints))
	                        return null;
	                    return legendData;
	                };
	                MekkoColumnChart.prototype.hasLegend = function () {
	                    return this.data && (this.data.hasDynamicSeries || (this.data.series && this.data.series.length > 1));
	                };
	                MekkoColumnChart.prototype.enumerateObjectInstances = function (enumeration, options) {
	                    switch (options.objectName) {
	                        case 'dataPoint':
	                            if (!GradientUtils.hasGradientRole(this.dataViewCat))
	                                this.enumerateDataPoints(enumeration);
	                            break;
	                        case 'labels':
	                            this.enumerateDataLabels(enumeration);
	                            break;
	                    }
	                };
	                MekkoColumnChart.prototype.enumerateDataLabels = function (enumeration) {
	                    var data = this.data, labelSettings = this.data.labelSettings, seriesCount = data.series.length;
	                    //Draw default settings
	                    dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings, false));
	                    if (seriesCount === 0) {
	                        return;
	                    }
	                    //Draw series settings
	                    if (!data.hasDynamicSeries && (seriesCount > 1 || !data.categoryMetadata)) {
	                        for (var i = 0; i < seriesCount; i++) {
	                            var series = data.series[i], labelSettings = (series.labelSettings) ? series.labelSettings : this.data.labelSettings;
	                            //enumeration.pushContainer({ displayName: series.displayName });
	                            dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings, true, series));
	                        }
	                    }
	                };
	                MekkoColumnChart.prototype.getLabelSettingsOptions = function (enumeration, labelSettings, isSeries, series) {
	                    var is100PctStacked = true;
	                    return {
	                        enumeration: enumeration,
	                        dataLabelsSettings: labelSettings,
	                        show: !isSeries,
	                        displayUnits: is100PctStacked,
	                        precision: true,
	                        selector: series && series.identity ? series.identity.getSelector() : null
	                    };
	                };
	                MekkoColumnChart.prototype.enumerateDataPoints = function (enumeration) {
	                    var data = this.data;
	                    if (!data || !data.series) {
	                        return;
	                    }
	                    var seriesCount = data.series.length;
	                    if (seriesCount === 0) {
	                        return;
	                    }
	                    if (data.hasDynamicSeries || seriesCount > 1 || !data.categoryMetadata) {
	                        for (var i = 0; i < seriesCount; i++) {
	                            var series = data.series[i];
	                            enumeration.pushInstance({
	                                objectName: 'dataPoint',
	                                displayName: series.displayName,
	                                selector: ColorHelper.normalizeSelector(series.identity.getSelector()),
	                                properties: {
	                                    fill: { solid: { color: series.color } }
	                                },
	                            });
	                        }
	                    }
	                    else {
	                        // For single-category, single-measure column charts, the user can color the individual bars.
	                        var singleSeriesData = data.series[0].data;
	                        var categoryFormatter = data.categoryFormatter;
	                        // Add default color and show all slices
	                        enumeration.pushInstance({
	                            objectName: 'dataPoint',
	                            selector: null,
	                            properties: {
	                                defaultColor: { solid: { color: data.defaultDataPointColor || this.colors.getColorByIndex(0).value } }
	                            }
	                        }).pushInstance({
	                            objectName: 'dataPoint',
	                            selector: null,
	                            properties: {
	                                showAllDataPoints: !!data.showAllDataPoints
	                            }
	                        });
	                        for (var i = 0; i < singleSeriesData.length; i++) {
	                            var singleSeriesDataPoints = singleSeriesData[i], categoryValue = data.categories[i];
	                            enumeration.pushInstance({
	                                objectName: 'dataPoint',
	                                displayName: categoryFormatter ? categoryFormatter.format(categoryValue) : categoryValue,
	                                selector: ColorHelper.normalizeSelector(singleSeriesDataPoints.identity.getSelector(), /*isSingleSeries*/ true),
	                                properties: {
	                                    fill: { solid: { color: singleSeriesDataPoints.color } }
	                                },
	                            });
	                        }
	                    }
	                };
	                MekkoColumnChart.prototype.calculateAxesProperties = function (options) {
	                    var data = this.data;
	                    this.currentViewport = options.viewport;
	                    var margin = this.margin = options.margin;
	                    var origCatgSize = (data && data.categories) ? data.categories.length : 0;
	                    var chartLayout = data ? this.getCategoryLayout(origCatgSize, options) : {
	                        categoryCount: 0,
	                        categoryThickness: MekkoChart.MinOrdinalRectThickness,
	                        outerPaddingRatio: MekkoChart.OuterPaddingRatio,
	                        isScalar: false
	                    };
	                    this.categoryAxisType = chartLayout.isScalar ? axisType.scalar : null;
	                    this.columnChart.setData(data);
	                    var preferredPlotArea = this.getPreferredPlotArea(chartLayout.isScalar, chartLayout.categoryCount, chartLayout.categoryThickness);
	                    /* preferredPlotArea would be same as currentViewport width when there is no scrollbar.
	                     In that case we want to calculate the available plot area for the shapes by subtracting the margin from available viewport */
	                    if (preferredPlotArea.width === this.currentViewport.width) {
	                        preferredPlotArea.width -= (margin.left + margin.right);
	                    }
	                    preferredPlotArea.height -= (margin.top + margin.bottom);
	                    var is100Pct = true;
	                    // When the category axis is scrollable the height of the category axis and value axis will be different
	                    // The height of the value axis would be same as viewportHeight
	                    var chartContext = {
	                        height: preferredPlotArea.height,
	                        width: preferredPlotArea.width,
	                        duration: 0,
	                        hostService: this.hostService,
	                        unclippedGraphicsContext: this.unclippedGraphicsContext,
	                        mainGraphicsContext: this.mainGraphicsContext,
	                        labelGraphicsContext: this.labelGraphicsContext,
	                        margin: this.margin,
	                        layout: chartLayout,
	                        animator: this.animator,
	                        interactivityService: this.interactivityService,
	                        viewportHeight: this.currentViewport.height - (margin.top + margin.bottom),
	                        viewportWidth: this.currentViewport.width - (margin.left + margin.right),
	                        is100Pct: is100Pct,
	                        isComboChart: true,
	                    };
	                    this.ApplyInteractivity(chartContext);
	                    this.columnChart.setupVisualProps(chartContext);
	                    var isBarChart = EnumExtensions.hasFlag(this.chartType, flagBar);
	                    if (isBarChart) {
	                        var temp = options.forcedXDomain;
	                        options.forcedXDomain = options.forcedYDomain;
	                        options.forcedYDomain = temp;
	                    }
	                    this.xAxisProperties = this.columnChart.setXScale(is100Pct, options.forcedTickCount, options.forcedXDomain, isBarChart ? options.valueAxisScaleType : options.categoryAxisScaleType);
	                    this.yAxisProperties = this.columnChart.setYScale(is100Pct, options.forcedTickCount, options.forcedYDomain, isBarChart ? options.categoryAxisScaleType : options.valueAxisScaleType);
	                    if (options.showCategoryAxisLabel && this.xAxisProperties.isCategoryAxis || options.showValueAxisLabel && !this.xAxisProperties.isCategoryAxis) {
	                        this.xAxisProperties.axisLabel = data.axesLabels.x;
	                    }
	                    else {
	                        this.xAxisProperties.axisLabel = null;
	                    }
	                    if (options.showValueAxisLabel && !this.yAxisProperties.isCategoryAxis || options.showCategoryAxisLabel && this.yAxisProperties.isCategoryAxis) {
	                        this.yAxisProperties.axisLabel = data.axesLabels.y;
	                    }
	                    else {
	                        this.yAxisProperties.axisLabel = null;
	                    }
	                    return [this.xAxisProperties, this.yAxisProperties];
	                };
	                MekkoColumnChart.prototype.getPreferredPlotArea = function (isScalar, categoryCount, categoryThickness) {
	                    var viewport = {
	                        height: this.currentViewport.height,
	                        width: this.currentViewport.width
	                    };
	                    if (this.isScrollable && !isScalar) {
	                        var preferredWidth = MekkoChart.getPreferredCategorySpan(categoryCount, categoryThickness);
	                        if (EnumExtensions.hasFlag(this.chartType, flagBar)) {
	                            viewport.height = Math.max(preferredWidth, viewport.height);
	                        }
	                        else
	                            viewport.width = Math.max(preferredWidth, viewport.width);
	                    }
	                    return viewport;
	                };
	                MekkoColumnChart.prototype.ApplyInteractivity = function (chartContext) {
	                    var _this = this;
	                    var interactivity = this.interactivity;
	                    if (interactivity) {
	                        if (interactivity.dragDataPoint) {
	                            chartContext.onDragStart = function (datum) {
	                                if (!datum.identity)
	                                    return;
	                                _this.hostService.onDragStart({
	                                    event: d3.event,
	                                    data: {
	                                        data: datum.identity.getSelector()
	                                    }
	                                });
	                            };
	                        }
	                        if (interactivity.isInteractiveLegend) {
	                            var dragMove = function () {
	                                var mousePoint = d3.mouse(_this.mainGraphicsContext[0][0]); // get the x and y for the column area itself
	                                var x = mousePoint[0];
	                                var y = mousePoint[1];
	                                var index = _this.columnChart.getClosestColumnIndex(x, y);
	                                _this.selectColumn(index);
	                            };
	                            var ColumnChartSvg = MekkoColumnChart.getInteractiveColumnChartDomElement(this.element);
	                            //set click interaction on the visual
	                            this.svg.on('click', dragMove);
	                            //set click interaction on the background
	                            d3.select(ColumnChartSvg).on('click', dragMove);
	                            var drag = d3.behavior.drag()
	                                .origin(Object)
	                                .on("drag", dragMove);
	                            //set drag interaction on the visual
	                            this.svg.call(drag);
	                            //set drag interaction on the background
	                            d3.select(ColumnChartSvg).call(drag);
	                        }
	                    }
	                };
	                MekkoColumnChart.prototype.selectColumn = function (indexOfColumnSelected, force) {
	                    if (force === void 0) { force = false; }
	                    if (!force && this.lastInteractiveSelectedColumnIndex === indexOfColumnSelected)
	                        return; // same column, nothing to do here
	                    var legendData = this.createInteractiveMekkoLegendDataPoints(indexOfColumnSelected);
	                    var MekkoLegendDataPoints = legendData.dataPoints;
	                    this.cartesianVisualHost.updateLegend(legendData);
	                    if (MekkoLegendDataPoints.length > 0) {
	                        this.columnChart.selectColumn(indexOfColumnSelected, this.lastInteractiveSelectedColumnIndex);
	                    }
	                    this.lastInteractiveSelectedColumnIndex = indexOfColumnSelected;
	                };
	                MekkoColumnChart.prototype.createInteractiveMekkoLegendDataPoints = function (columnIndex) {
	                    var data = this.data;
	                    if (!data || ArrayExtensions.isUndefinedOrEmpty(data.series)) {
	                        return { dataPoints: [] };
	                    }
	                    var formatStringProp = MekkoChart.Properties["general"]["formatString"];
	                    var MekkoLegendDataPoints = [];
	                    var category = data.categories && data.categories[columnIndex];
	                    var allSeries = data.series;
	                    var dataPoints = data.legendData && data.legendData.dataPoints;
	                    var converterStrategy = new MekkoChartConverterHelper(this.dataViewCat);
	                    for (var i = 0, len = allSeries.length; i < len; i++) {
	                        var measure = converterStrategy.getValueBySeriesAndCategory(i, columnIndex);
	                        var valueMetadata = data.valuesMetadata[i];
	                        var formattedLabel = converterHelper.getFormattedLegendLabel(valueMetadata, this.dataViewCat.values, formatStringProp);
	                        var dataPointColor;
	                        if (allSeries.length === 1) {
	                            var series = allSeries[0];
	                            dataPointColor = series.data.length > columnIndex && series.data[columnIndex].color;
	                        }
	                        else {
	                            dataPointColor = dataPoints.length > i && dataPoints[i].color;
	                        }
	                        MekkoLegendDataPoints.push({
	                            color: dataPointColor,
	                            icon: LegendIcon.Box,
	                            label: formattedLabel,
	                            category: data.categoryFormatter ? data.categoryFormatter.format(category) : category,
	                            measure: valueFormatter.format(measure, valueFormatter.getFormatString(valueMetadata, formatStringProp)),
	                            identity: SelectionId.createNull(),
	                            selected: false,
	                        });
	                    }
	                    return { dataPoints: MekkoLegendDataPoints };
	                };
	                MekkoColumnChart.prototype.overrideXScale = function (xProperties) {
	                    this.xAxisProperties = xProperties;
	                };
	                MekkoColumnChart.prototype.render = function (suppressAnimations) {
	                    var MekkoColumnChartDrawInfo = this.columnChart.drawColumns(!suppressAnimations /* useAnimations */);
	                    var data = this.data;
	                    var margin = this.margin;
	                    var viewport = this.currentViewport;
	                    var height = viewport.height - (margin.top + margin.bottom);
	                    var width = viewport.width - (margin.left + margin.right);
	                    this.mainGraphicsContext
	                        .attr('height', height)
	                        .attr('width', width);
	                    TooltipManager.addTooltip(MekkoColumnChartDrawInfo.shapesSelection, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
	                    var allDataPoints = [];
	                    var behaviorOptions = undefined;
	                    if (this.interactivityService) {
	                        for (var i = 0, ilen = data.series.length; i < ilen; i++) {
	                            allDataPoints = allDataPoints.concat(data.series[i].data);
	                        }
	                        behaviorOptions = {
	                            datapoints: allDataPoints,
	                            bars: MekkoColumnChartDrawInfo.shapesSelection,
	                            hasHighlights: data.hasHighlights,
	                            eventGroup: this.mainGraphicsContext,
	                            mainGraphicsContext: this.mainGraphicsContext,
	                            viewport: MekkoColumnChartDrawInfo.viewport,
	                            axisOptions: MekkoColumnChartDrawInfo.axisOptions,
	                            showLabel: data.labelSettings.show
	                        };
	                    }
	                    if (this.interactivity && this.interactivity.isInteractiveLegend) {
	                        if (this.data.series.length > 0) {
	                            this.selectColumn(0, true); // start with the first column
	                        }
	                    }
	                    SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
	                    return {
	                        dataPoints: allDataPoints,
	                        behaviorOptions: behaviorOptions,
	                        labelDataPoints: MekkoColumnChartDrawInfo.labelDataPoints,
	                        labelsAreNumeric: true
	                    };
	                };
	                MekkoColumnChart.prototype.onClearSelection = function () {
	                    if (this.interactivityService) {
	                        this.interactivityService.clearSelection();
	                    }
	                };
	                MekkoColumnChart.prototype.getVisualCategoryAxisIsScalar = function () {
	                    return this.data ? this.data.scalarCategoryAxis : false;
	                };
	                MekkoColumnChart.prototype.getSupportedCategoryAxisType = function () {
	                    var metaDataColumn = this.data ? this.data.categoryMetadata : undefined;
	                    var valueType = AxisHelper.getCategoryValueType(metaDataColumn);
	                    var isOrdinal = AxisHelper.isOrdinal(valueType);
	                    return isOrdinal ? axisType.categorical : axisType.both;
	                };
	                MekkoColumnChart.prototype.setFilteredData = function (startIndex, endIndex) {
	                    var data = Prototype.inherit(this.data);
	                    data.series = MekkoColumnChart.sliceSeries(data.series, endIndex, startIndex);
	                    data.categories = data.categories.slice(startIndex, endIndex);
	                    this.columnChart.setData(data);
	                    return data;
	                };
	                MekkoColumnChart.ColumnChartClassName = 'columnChart';
	                MekkoColumnChart.SeriesClasses = createClassAndSelector("series");
	                MekkoColumnChart.BorderClass = createClassAndSelector("mekkoborder");
	                return MekkoColumnChart;
	            }());
	            samples.MekkoColumnChart = MekkoColumnChart;
	            var MekkoChartConverterHelper = (function () {
	                function MekkoChartConverterHelper(dataView) {
	                    this.dataView = dataView;
	                }
	                MekkoChartConverterHelper.hasRole = function (column, name) {
	                    var roles = column.roles;
	                    return roles && roles[name];
	                };
	                MekkoChartConverterHelper.prototype.getLegend = function (colors, defaultColor) {
	                    var legend = [];
	                    var seriesSources = [];
	                    var seriesObjects = [];
	                    var grouped = false;
	                    var colorHelper = new ColorHelper(colors, MekkoChart.Properties["dataPoint"]["fill"], defaultColor);
	                    var legendTitle = undefined;
	                    if (this.dataView && this.dataView.values) {
	                        var allValues = this.dataView.values;
	                        var valueGroups = allValues.grouped();
	                        var hasDynamicSeries = !!(allValues && allValues.source);
	                        var formatStringProp = MekkoChart.Properties["general"]["formatString"];
	                        for (var valueGroupsIndex = 0, valueGroupsLen = valueGroups.length; valueGroupsIndex < valueGroupsLen; valueGroupsIndex++) {
	                            var valueGroup = valueGroups[valueGroupsIndex], valueGroupObjects = valueGroup.objects, values = valueGroup.values;
	                            for (var valueIndex = 0, valuesLen = values.length; valueIndex < valuesLen; valueIndex++) {
	                                var series = values[valueIndex];
	                                var source = series.source;
	                                // Gradient measures do not create series.
	                                if (MekkoChartConverterHelper.hasRole(source, 'Width') && !MekkoChartConverterHelper.hasRole(source, 'Y')) {
	                                    continue;
	                                }
	                                seriesSources.push(source);
	                                seriesObjects.push(series.objects);
	                                var selectionId = series.identity ?
	                                    SelectionId.createWithIdAndMeasure(series.identity, source.queryName) :
	                                    SelectionId.createWithMeasure(this.getMeasureNameByIndex(valueIndex));
	                                var label = converterHelper.getFormattedLegendLabel(source, allValues, formatStringProp);
	                                var color = hasDynamicSeries
	                                    ? colorHelper.getColorForSeriesValue(valueGroupObjects || source.objects, allValues.identityFields, source.groupName)
	                                    : colorHelper.getColorForMeasure(valueGroupObjects || source.objects, source.queryName);
	                                legend.push({
	                                    icon: LegendIcon.Box,
	                                    color: color,
	                                    label: label,
	                                    identity: selectionId,
	                                    selected: false,
	                                });
	                                if (series.identity && source.groupName !== undefined) {
	                                    grouped = true;
	                                }
	                            }
	                        }
	                        var dvValues = this.dataView.values;
	                        legendTitle = dvValues && dvValues.source ? dvValues.source.displayName : "";
	                    }
	                    var legendData = {
	                        title: legendTitle,
	                        dataPoints: legend,
	                        grouped: grouped,
	                    };
	                    return {
	                        legend: legendData,
	                        seriesSources: seriesSources,
	                        seriesObjects: seriesObjects,
	                    };
	                };
	                MekkoChartConverterHelper.prototype.getValueBySeriesAndCategory = function (series, category) {
	                    return this.dataView.values[series].values[category];
	                };
	                MekkoChartConverterHelper.prototype.getMeasureNameByIndex = function (index) {
	                    return this.dataView.values[index].source.queryName;
	                };
	                MekkoChartConverterHelper.prototype.hasHighlightValues = function (series) {
	                    var column = this.dataView && this.dataView.values ? this.dataView.values[series] : undefined;
	                    return column && !!column.highlights;
	                };
	                MekkoChartConverterHelper.prototype.getHighlightBySeriesAndCategory = function (series, category) {
	                    return this.dataView.values[series].highlights[category];
	                };
	                return MekkoChartConverterHelper;
	            }());
	            var CustomVisualBehavior = (function () {
	                function CustomVisualBehavior(behaviors) {
	                    this.behaviors = behaviors || [];
	                }
	                CustomVisualBehavior.prototype.bindEvents = function (options, selectionHandler) {
	                    var behaviors = this.behaviors;
	                    for (var i = 0, ilen = behaviors.length; i < ilen; i++) {
	                        behaviors[i].bindEvents(options.layerOptions[i], selectionHandler);
	                    }
	                    options.clearCatcher.on("click", function () {
	                        selectionHandler.handleClearSelection();
	                    });
	                };
	                CustomVisualBehavior.prototype.renderSelection = function (hasSelection) {
	                    for (var behaviorName in this.behaviors) {
	                        this.behaviors[behaviorName].renderSelection(hasSelection);
	                    }
	                };
	                return CustomVisualBehavior;
	            }());
	            var MekkoChartWebBehavior = (function () {
	                function MekkoChartWebBehavior() {
	                }
	                MekkoChartWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
	                    this.options = options;
	                    var eventGroup = options.eventGroup;
	                    eventGroup.on('click', function () {
	                        var d = MekkoChartWebBehavior.getDatumForLastInputEvent();
	                        selectionHandler.handleSelection(d, d3.event.ctrlKey);
	                    });
	                    eventGroup.on('contextmenu', function () {
	                        if (d3.event.ctrlKey)
	                            return;
	                        d3.event.preventDefault();
	                        var d = MekkoChartWebBehavior.getDatumForLastInputEvent();
	                        var position = InteractivityUtils.getPositionOfLastInputEvent();
	                        selectionHandler.handleContextMenu(d, position);
	                    });
	                };
	                MekkoChartWebBehavior.prototype.renderSelection = function (hasSelection) {
	                    var options = this.options;
	                    options.bars.style("fill-opacity", function (d) {
	                        return MekkoChartUtils.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && options.hasHighlights);
	                    });
	                };
	                MekkoChartWebBehavior.getDatumForLastInputEvent = function () {
	                    var target = d3.event.target;
	                    return d3.select(target).datum();
	                };
	                return MekkoChartWebBehavior;
	            }());
	            samples.MekkoChartWebBehavior = MekkoChartWebBehavior;
	            var MekkoChartUtils;
	            (function (MekkoChartUtils) {
	                var PctRoundingError = 0.0001;
	                var rectName = 'rect';
	                MekkoChartUtils.DimmedOpacity = 0.4;
	                MekkoChartUtils.DefaultOpacity = 1.0;
	                function getSize(scale, size, zeroVal) {
	                    if (zeroVal === void 0) { zeroVal = 0; }
	                    return AxisHelper.diffScaled(scale, zeroVal, size);
	                }
	                MekkoChartUtils.getSize = getSize;
	                function calcValueDomain(data, is100pct) {
	                    var defaultNumberRange = {
	                        min: 0,
	                        max: 10
	                    };
	                    if (data.length === 0)
	                        return defaultNumberRange;
	                    // Can't use AxisHelper because Stacked layout has a slightly different calc, (position - valueAbs)
	                    var min = d3.min(data, function (d) {
	                        return d3.min(d.data, function (e) { return e.position - e.valueAbsolute; });
	                    });
	                    var max = d3.max(data, function (d) {
	                        return d3.max(d.data, function (e) { return e.position; });
	                    });
	                    if (is100pct) {
	                        min = Double.roundToPrecision(min, PctRoundingError);
	                        max = Double.roundToPrecision(max, PctRoundingError);
	                    }
	                    return {
	                        min: min,
	                        max: max,
	                    };
	                }
	                MekkoChartUtils.calcValueDomain = calcValueDomain;
	                function drawSeries(data, graphicsContext, axisOptions) {
	                    var colGroupSelection = graphicsContext.selectAll(MekkoChart.Classes["series"].selector);
	                    var series = colGroupSelection.data(data.series, function (d) { return d.key; });
	                    series
	                        .enter()
	                        .append('g')
	                        .classed(MekkoChart.Classes["series"].class, true);
	                    series
	                        .style({
	                        fill: function (d) { return d.color; },
	                    });
	                    series
	                        .exit()
	                        .remove();
	                    return series;
	                }
	                MekkoChartUtils.drawSeries = drawSeries;
	                function applyInteractivity(columns, onDragStart) {
	                    debug.assertValue(columns, 'columns');
	                    if (onDragStart) {
	                        columns
	                            .attr('draggable', 'true')
	                            .on('dragstart', onDragStart);
	                    }
	                }
	                MekkoChartUtils.applyInteractivity = applyInteractivity;
	                function getFillOpacity(selected, highlight, hasSelection, hasPartialHighlights) {
	                    if ((hasPartialHighlights && !highlight) || (hasSelection && !selected))
	                        return MekkoChartUtils.DimmedOpacity;
	                    return MekkoChartUtils.DefaultOpacity;
	                }
	                MekkoChartUtils.getFillOpacity = getFillOpacity;
	                function setChosenColumnOpacity(mainGraphicsContext, columnGroupSelector, selectedColumnIndex, lastColumnIndex) {
	                    var series = mainGraphicsContext.selectAll(MekkoChart.Classes["series"].selector);
	                    var lastColumnUndefined = typeof lastColumnIndex === 'undefined';
	                    // find all columns that do not belong to the selected column and set a dimmed opacity with a smooth animation to those columns
	                    series.selectAll(rectName + columnGroupSelector).filter(function (d) {
	                        return (d.categoryIndex !== selectedColumnIndex) && (lastColumnUndefined || d.categoryIndex === lastColumnIndex);
	                    }).transition().style('fill-opacity', MekkoChartUtils.DimmedOpacity);
	                    // set the default opacity for the selected column
	                    series.selectAll(rectName + columnGroupSelector).filter(function (d) {
	                        return d.categoryIndex === selectedColumnIndex;
	                    }).style('fill-opacity', MekkoChartUtils.DefaultOpacity);
	                }
	                MekkoChartUtils.setChosenColumnOpacity = setChosenColumnOpacity;
	                function getClosestColumnIndex(coordinate, columnsCenters) {
	                    var currentIndex = 0;
	                    var distance = Number.MAX_VALUE;
	                    for (var i = 0, ilen = columnsCenters.length; i < ilen; i++) {
	                        var currentDistance = Math.abs(coordinate - columnsCenters[i]);
	                        if (currentDistance < distance) {
	                            distance = currentDistance;
	                            currentIndex = i;
	                        }
	                    }
	                    return currentIndex;
	                }
	                MekkoChartUtils.getClosestColumnIndex = getClosestColumnIndex;
	                function applyUserMinMax(isScalar, dataView, xAxisCardProperties) {
	                    if (isScalar) {
	                        var min = xAxisCardProperties['start'];
	                        var max = xAxisCardProperties['end'];
	                        return MekkoChartUtils.transformDomain(dataView, min, max);
	                    }
	                    return dataView;
	                }
	                MekkoChartUtils.applyUserMinMax = applyUserMinMax;
	                function transformDomain(dataView, min, max) {
	                    if (!dataView.categories || !dataView.values || dataView.categories.length === 0 || dataView.values.length === 0)
	                        return dataView; // no need to do something when there are no categories
	                    if (typeof min !== "number" && typeof max !== "number")
	                        return dataView; //user did not set min max, nothing to do here
	                    var category = dataView.categories[0]; //at the moment we only support one category
	                    var categoryType = category ? category.source.type : null;
	                    // Min/Max comparison won't work if category source is Ordinal
	                    if (AxisHelper.isOrdinal(categoryType))
	                        return;
	                    var categoryValues = category.values;
	                    var categoryObjects = category.objects;
	                    if (!categoryValues || !categoryObjects)
	                        return dataView;
	                    var newcategoryValues = [];
	                    var newValues = [];
	                    var newObjects = [];
	                    //get new min max
	                    if (typeof min !== "number") {
	                        min = categoryValues[0];
	                    }
	                    if (typeof max !== "number") {
	                        max = categoryValues[categoryValues.length - 1];
	                    }
	                    //don't allow this
	                    if (min > max)
	                        return dataView;
	                    //build measure array
	                    for (var j = 0, len = dataView.values.length; j < len; j++) {
	                        newValues.push([]);
	                    }
	                    for (var t = 0, len = categoryValues.length; t < len; t++) {
	                        if (categoryValues[t] >= min && categoryValues[t] <= max) {
	                            newcategoryValues.push(categoryValues[t]);
	                            if (categoryObjects) {
	                                newObjects.push(categoryObjects[t]);
	                            }
	                            //on each measure set the new range
	                            if (dataView.values) {
	                                for (var k = 0; k < dataView.values.length; k++) {
	                                    newValues[k].push(dataView.values[k].values[t]);
	                                }
	                            }
	                        }
	                    }
	                    //don't write directly to dataview
	                    var resultDataView = Prototype.inherit(dataView);
	                    var resultDataViewValues = resultDataView.values = Prototype.inherit(resultDataView.values);
	                    var resultDataViewCategories = resultDataView.categories = Prototype.inherit(dataView.categories);
	                    var resultDataViewCategories0 = resultDataView.categories[0] = Prototype.inherit(resultDataViewCategories[0]);
	                    resultDataViewCategories0.values = newcategoryValues;
	                    //only if we had objects, then you set the new objects
	                    if (resultDataViewCategories0.objects) {
	                        resultDataViewCategories0.objects = newObjects;
	                    }
	                    //update measure array
	                    for (var t = 0, len = dataView.values.length; t < len; t++) {
	                        var measureArray = resultDataViewValues[t] = Prototype.inherit(resultDataViewValues[t]);
	                        measureArray.values = newValues[t];
	                    }
	                    return resultDataView;
	                }
	                MekkoChartUtils.transformDomain = transformDomain;
	            })(MekkoChartUtils = samples.MekkoChartUtils || (samples.MekkoChartUtils = {}));
	            var MekkoChartSharedColorPalette = (function () {
	                function MekkoChartSharedColorPalette(palette) {
	                    this.palette = palette;
	                    this.clearPreferredScale();
	                }
	                MekkoChartSharedColorPalette.prototype.getColorScaleByKey = function (scaleKey) {
	                    this.setPreferredScale(scaleKey);
	                    return this.preferredScale;
	                };
	                MekkoChartSharedColorPalette.prototype.getNewColorScale = function () {
	                    return this.preferredScale;
	                };
	                MekkoChartSharedColorPalette.prototype.getColorByIndex = function (index) {
	                    return this.palette.getColorByIndex(index);
	                };
	                MekkoChartSharedColorPalette.prototype.getSentimentColors = function () {
	                    return this.palette.getSentimentColors();
	                };
	                MekkoChartSharedColorPalette.prototype.getBasePickerColors = function () {
	                    return this.palette.getBasePickerColors();
	                };
	                MekkoChartSharedColorPalette.prototype.clearPreferredScale = function () {
	                    this.preferredScale = this.palette.getNewColorScale();
	                    this.rotated = false;
	                };
	                MekkoChartSharedColorPalette.prototype.rotateScale = function () {
	                    // We create a new rotated the scale such that the first color of the new scale is the first
	                    // free color of the previous scale. Note that the new scale does not have any colors allocated
	                    // to particular keys.
	                    this.preferredScale = this.preferredScale.clone();
	                    this.preferredScale.clearAndRotateScale();
	                    this.rotated = true;
	                };
	                MekkoChartSharedColorPalette.prototype.setPreferredScale = function (scaleKey) {
	                    if (!this.rotated) {
	                        // The first layer to express a preference sets the preferred scale.
	                        this.preferredScale = this.palette.getColorScaleByKey(scaleKey);
	                    }
	                };
	                return MekkoChartSharedColorPalette;
	            }());
	            samples.MekkoChartSharedColorPalette = MekkoChartSharedColorPalette;
	            var MekkochartHelper;
	            (function (MekkochartHelper) {
	                function getCategoryAxisProperties(dataViewMetadata, axisTitleOnByDefault) {
	                    var toReturn = {};
	                    if (!dataViewMetadata)
	                        return toReturn;
	                    var objects = dataViewMetadata.objects;
	                    if (objects) {
	                        var categoryAxisObject = objects['categoryAxis'];
	                        if (categoryAxisObject) {
	                            toReturn = {
	                                show: categoryAxisObject['show'],
	                                axisType: categoryAxisObject['axisType'],
	                                axisScale: categoryAxisObject['axisScale'],
	                                start: categoryAxisObject['start'],
	                                end: categoryAxisObject['end'],
	                                showAxisTitle: categoryAxisObject['showAxisTitle'] == null ? axisTitleOnByDefault : categoryAxisObject['showAxisTitle'],
	                                axisStyle: categoryAxisObject['axisStyle'],
	                                labelColor: categoryAxisObject['labelColor'],
	                                labelDisplayUnits: categoryAxisObject['labelDisplayUnits'],
	                                labelPrecision: categoryAxisObject['labelPrecision'],
	                                duration: categoryAxisObject['duration'],
	                            };
	                        }
	                    }
	                    return toReturn;
	                }
	                MekkochartHelper.getCategoryAxisProperties = getCategoryAxisProperties;
	                function getValueAxisProperties(dataViewMetadata, axisTitleOnByDefault) {
	                    var toReturn = {};
	                    if (!dataViewMetadata)
	                        return toReturn;
	                    var objects = dataViewMetadata.objects;
	                    if (objects) {
	                        var valueAxisObject = objects['valueAxis'];
	                        if (valueAxisObject) {
	                            toReturn = {
	                                show: valueAxisObject['show'],
	                                position: valueAxisObject['position'],
	                                axisScale: valueAxisObject['axisScale'],
	                                start: valueAxisObject['start'],
	                                end: valueAxisObject['end'],
	                                showAxisTitle: valueAxisObject['showAxisTitle'] == null ? axisTitleOnByDefault : valueAxisObject['showAxisTitle'],
	                                axisStyle: valueAxisObject['axisStyle'],
	                                labelColor: valueAxisObject['labelColor'],
	                                labelDisplayUnits: valueAxisObject['labelDisplayUnits'],
	                                labelPrecision: valueAxisObject['labelPrecision'],
	                                secShow: valueAxisObject['secShow'],
	                                secPosition: valueAxisObject['secPosition'],
	                                secAxisScale: valueAxisObject['secAxisScale'],
	                                secStart: valueAxisObject['secStart'],
	                                secEnd: valueAxisObject['secEnd'],
	                                secShowAxisTitle: valueAxisObject['secShowAxisTitle'],
	                                secAxisStyle: valueAxisObject['secAxisStyle'],
	                                secLabelColor: valueAxisObject['secLabelColor'],
	                                secLabelDisplayUnits: valueAxisObject['secLabelDisplayUnits'],
	                                secLabelPrecision: valueAxisObject['secLabelPrecision'],
	                            };
	                        }
	                    }
	                    return toReturn;
	                }
	                MekkochartHelper.getValueAxisProperties = getValueAxisProperties;
	                function isScalar(isScalar, xAxisCardProperties) {
	                    if (isScalar) {
	                        //now check what the user wants
	                        isScalar = xAxisCardProperties && xAxisCardProperties['axisType'] ? xAxisCardProperties['axisType'] === axisType.scalar : true;
	                    }
	                    return isScalar;
	                }
	                MekkochartHelper.isScalar = isScalar;
	            })(MekkochartHelper = samples.MekkochartHelper || (samples.MekkochartHelper = {}));
	        })(samples = visuals.samples || (visuals.samples = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 41 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../../../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var samples;
	        (function (samples) {
	            var SelectionManager = visuals.utility.SelectionManager;
	            var ValueFormatter = powerbi.visuals.valueFormatter;
	            var pixelConverterFromPoint = jsCommon.PixelConverter.fromPoint;
	            var SankeyDiagram = (function () {
	                function SankeyDiagram(constructorOptions) {
	                    this.margin = {
	                        top: 10,
	                        right: 10,
	                        bottom: 10,
	                        left: 10
	                    };
	                    this.nodeWidth = 21.5;
	                    this.curvatureOfLinks = 0.5;
	                    if (constructorOptions) {
	                        this.svg = constructorOptions.svg;
	                        this.margin = constructorOptions.margin || this.margin;
	                        this.curvatureOfLinks = constructorOptions.curvatureOfLinks || this.curvatureOfLinks;
	                    }
	                }
	                SankeyDiagram.getProperties = function (capabilities) {
	                    var result = {};
	                    for (var objectKey in capabilities.objects) {
	                        result[objectKey] = {};
	                        for (var propKey in capabilities.objects[objectKey].properties) {
	                            result[objectKey][propKey] = {
	                                objectName: objectKey,
	                                propertyName: propKey
	                            };
	                        }
	                    }
	                    return result;
	                };
	                Object.defineProperty(SankeyDiagram.prototype, "textProperties", {
	                    get: function () {
	                        return {
	                            fontFamily: this.root.style("font-family"),
	                            fontSize: pixelConverterFromPoint(this.dataView
	                                ? this.dataView.settings.fontSize
	                                : SankeyDiagram.DefaultSettings.fontSize)
	                        };
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                SankeyDiagram.prototype.init = function (visualsInitOptions) {
	                    if (this.svg) {
	                        this.root = this.svg;
	                    }
	                    else {
	                        this.root = d3.select(visualsInitOptions.element.get(0))
	                            .append("svg");
	                    }
	                    this.selectionManager = new SelectionManager({ hostServices: visualsInitOptions.host });
	                    var style = visualsInitOptions.style;
	                    this.colours = style && style.colorPalette
	                        ? style.colorPalette.dataColors
	                        : new visuals.DataColorPalette();
	                    this.root.classed(SankeyDiagram.ClassName, true);
	                    this.main = this.root.append("g");
	                    this.links = this.main
	                        .append("g")
	                        .classed(SankeyDiagram.Links["class"], true);
	                    this.nodes = this.main
	                        .append("g")
	                        .classed(SankeyDiagram.Nodes["class"], true);
	                };
	                SankeyDiagram.prototype.update = function (visualUpdateOptions) {
	                    if (!visualUpdateOptions ||
	                        !visualUpdateOptions.dataViews) {
	                        return;
	                    }
	                    var dataView = visualUpdateOptions.dataViews[0], sankeyDiagramDataView;
	                    this.updateViewport(visualUpdateOptions.viewport);
	                    sankeyDiagramDataView = this.converter(dataView);
	                    this.computePositions(sankeyDiagramDataView);
	                    this.dataView = sankeyDiagramDataView;
	                    this.render(sankeyDiagramDataView);
	                };
	                SankeyDiagram.prototype.updateViewport = function (viewport) {
	                    var height, width;
	                    height = this.getPositiveNumber(viewport.height);
	                    width = this.getPositiveNumber(viewport.width);
	                    this.viewport = {
	                        height: this.getPositiveNumber(height - this.margin.top - this.margin.bottom),
	                        width: this.getPositiveNumber(width - this.margin.left - this.margin.right)
	                    };
	                    this.updateElements(height, width);
	                };
	                /**
	                 * Public for testability.
	                 */
	                SankeyDiagram.prototype.getPositiveNumber = function (value) {
	                    return value < 0 || isNaN(value) || value === null || value === Infinity || value === -Infinity
	                        ? 0
	                        : value;
	                };
	                SankeyDiagram.prototype.updateElements = function (height, width) {
	                    this.root.attr({
	                        "height": height,
	                        "width": width
	                    });
	                    this.main.attr("transform", visuals.SVGUtil.translate(this.margin.left, this.margin.top));
	                };
	                SankeyDiagram.prototype.converter = function (dataView) {
	                    var _this = this;
	                    if (!dataView ||
	                        !dataView.categorical ||
	                        !dataView.categorical.categories ||
	                        !dataView.categorical.categories[0] ||
	                        !dataView.categorical.categories[1] ||
	                        !dataView.categorical.categories[0].values ||
	                        !dataView.categorical.categories[1].values) {
	                        return {
	                            nodes: [],
	                            links: [],
	                            columns: [],
	                            settings: {
	                                scale: { x: 1, y: 1 },
	                                colourOfLabels: SankeyDiagram.DefaultSettings.colourOfLabels,
	                                fontSize: SankeyDiagram.DefaultSettings.fontSize
	                            }
	                        };
	                    }
	                    var nodes = [], links = [], dataPoints = [], categories = dataView.categorical.categories[0].values, secondCategories = dataView.categorical.categories[1].values, valuesColumn = dataView.categorical.values && dataView.categorical.values[0], weightValues = [], allCategories, valueFormatterForCategories, formatOfWeigth = "g", valuesFormatterForWeigth, objects, linksObjects = dataView.categorical.categories[0].objects || [], labelColour, settings, shiftOfColour, identities = [];
	                    if (valuesColumn && valuesColumn.values && valuesColumn.values.map) {
	                        weightValues = valuesColumn.values.map(function (x) {
	                            return x ? x : 0;
	                        });
	                    }
	                    if (dataView.categorical.categories[0].identity) {
	                        identities = identities.concat(dataView.categorical.categories[0].identity);
	                    }
	                    if (dataView.categorical.categories[1].identity) {
	                        identities = identities.concat(dataView.categorical.categories[1].identity);
	                    }
	                    objects = this.getObjectsFromDataView(dataView);
	                    labelColour = this.getColour(SankeyDiagram.Properties["labels"]["fill"], SankeyDiagram.DefaultSettings.colourOfLabels, objects);
	                    if (valuesColumn && valuesColumn.source) {
	                        formatOfWeigth = ValueFormatter.getFormatString(valuesColumn.source, SankeyDiagram.Properties["general"]["formatString"]);
	                    }
	                    dataPoints = categories.map(function (item, index) {
	                        return {
	                            source: item,
	                            destination: secondCategories[index],
	                            weigth: valuesColumn ? Math.max(weightValues[index] || 0, 0) : 1
	                        };
	                    });
	                    allCategories = categories.concat(secondCategories);
	                    valueFormatterForCategories = ValueFormatter.create({
	                        format: ValueFormatter.getFormatString(dataView.categorical.categories[0].source, SankeyDiagram.Properties["general"]["formatString"]),
	                        value: allCategories[0],
	                        value2: allCategories[allCategories.length - 1]
	                    });
	                    valuesFormatterForWeigth = ValueFormatter.create({
	                        format: formatOfWeigth,
	                        value: Math.max(d3.max(weightValues) || 1, 1),
	                    });
	                    allCategories.forEach(function (item, index) {
	                        if (!nodes.some(function (node) {
	                            if (item === node.label.name) {
	                                node.selectionIds.push(visuals.SelectionId.createWithId(identities[index]));
	                                return true;
	                            }
	                            return false;
	                        })) {
	                            var formattedValue = valueFormatterForCategories.format(item), label, selectionId, textProperties = {
	                                text: formattedValue,
	                                fontFamily: _this.textProperties.fontFamily,
	                                fontSize: _this.textProperties.fontSize
	                            };
	                            label = {
	                                name: item,
	                                formattedName: valueFormatterForCategories.format(item),
	                                width: powerbi.TextMeasurementService.measureSvgTextWidth(textProperties),
	                                height: powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties),
	                                colour: labelColour
	                            };
	                            selectionId = visuals.SelectionId.createWithId(identities[index]);
	                            nodes.push({
	                                label: label,
	                                links: [],
	                                inputWeight: 0,
	                                outputWeight: 0,
	                                width: _this.nodeWidth,
	                                height: 0,
	                                colour: SankeyDiagram.DefaultColourOfNode,
	                                tooltipData: [],
	                                selectionIds: [selectionId]
	                            });
	                        }
	                    });
	                    shiftOfColour = this.colours.getAllColors().length / nodes.length;
	                    nodes.forEach(function (node, index) {
	                        node.colour = _this.colours.getColorByIndex(Math.floor(index * shiftOfColour)).value;
	                    });
	                    dataPoints.forEach(function (dataPoint, index) {
	                        var sourceNode, destinationNode, link, linkColour;
	                        if (dataPoint.source === dataPoint.destination) {
	                            return;
	                        }
	                        nodes.forEach(function (node) {
	                            if (node.label.name === dataPoint.source) {
	                                sourceNode = node;
	                            }
	                            if (node.label.name === dataPoint.destination) {
	                                destinationNode = node;
	                            }
	                        });
	                        linkColour = _this.getColour(SankeyDiagram.Properties["links"]["fill"], SankeyDiagram.DefaultColourOfLink, linksObjects[index]);
	                        link = {
	                            source: sourceNode,
	                            destination: destinationNode,
	                            weigth: dataPoint.weigth,
	                            height: dataPoint.weigth,
	                            colour: linkColour,
	                            tooltipData: _this.getTooltipDataForLink(valuesFormatterForWeigth, sourceNode.label.formattedName, destinationNode.label.formattedName, dataPoint.weigth),
	                            selectionId: visuals.SelectionId.createWithId(identities[index])
	                        };
	                        links.push(link);
	                        sourceNode.links.push(link);
	                        destinationNode.links.push(link);
	                        _this.updateValueOfNode(sourceNode);
	                        _this.updateValueOfNode(destinationNode);
	                        sourceNode.tooltipData = _this.getTooltipForNode(valuesFormatterForWeigth, sourceNode.label.formattedName, sourceNode.inputWeight ? sourceNode.inputWeight : sourceNode.outputWeight);
	                        destinationNode.tooltipData = _this.getTooltipForNode(valuesFormatterForWeigth, destinationNode.label.formattedName, destinationNode.inputWeight ? destinationNode.inputWeight : destinationNode.outputWeight);
	                    });
	                    settings = this.parseSettings(objects);
	                    settings.colourOfLabels = labelColour;
	                    return {
	                        nodes: nodes,
	                        links: links,
	                        settings: settings,
	                        columns: []
	                    };
	                };
	                SankeyDiagram.prototype.getObjectsFromDataView = function (dataView) {
	                    if (!dataView ||
	                        !dataView.metadata ||
	                        !dataView.metadata.columns ||
	                        !dataView.metadata.objects) {
	                        return null;
	                    }
	                    return dataView.metadata.objects;
	                };
	                SankeyDiagram.prototype.getColour = function (properties, defaultColor, objects) {
	                    var colorHelper;
	                    colorHelper = new visuals.ColorHelper(this.colours, properties, defaultColor);
	                    return colorHelper.getColorForMeasure(objects, "");
	                };
	                SankeyDiagram.prototype.getTooltipDataForLink = function (valueFormatter, sourceNodeName, destinationNodeName, linkWeight) {
	                    var formattedLinkWeight;
	                    if (valueFormatter && valueFormatter.format) {
	                        formattedLinkWeight = valueFormatter.format(linkWeight);
	                    }
	                    else {
	                        formattedLinkWeight = linkWeight.toString();
	                    }
	                    return [{
	                            displayName: SankeyDiagram.RoleNames.rows,
	                            value: sourceNodeName
	                        }, {
	                            displayName: SankeyDiagram.RoleNames.columns,
	                            value: destinationNodeName
	                        }, {
	                            displayName: SankeyDiagram.RoleNames.values,
	                            value: formattedLinkWeight
	                        }];
	                };
	                SankeyDiagram.prototype.updateValueOfNode = function (node) {
	                    node.inputWeight = node.links.reduce(function (previousValue, currentValue) {
	                        return previousValue + (currentValue.destination === node ? currentValue.weigth : 0);
	                    }, 0);
	                    node.outputWeight = node.links.reduce(function (previousValue, currentValue) {
	                        return previousValue + (currentValue.source === node ? currentValue.weigth : 0);
	                    }, 0);
	                };
	                SankeyDiagram.prototype.getTooltipForNode = function (valueFormatter, nodeName, nodeWeight) {
	                    var formattedNodeWeigth;
	                    if (valueFormatter && valueFormatter.format) {
	                        formattedNodeWeigth = valueFormatter.format(nodeWeight);
	                    }
	                    else {
	                        formattedNodeWeigth = nodeWeight.toString();
	                    }
	                    return [{
	                            displayName: "Name",
	                            value: nodeName
	                        }, {
	                            displayName: SankeyDiagram.RoleNames.values,
	                            value: formattedNodeWeigth
	                        }];
	                };
	                SankeyDiagram.prototype.parseSettings = function (objects) {
	                    var isVisibleLabels = false;
	                    isVisibleLabels = powerbi.DataViewObjects.getValue(objects, SankeyDiagram.Properties["labels"]["show"], SankeyDiagram.DefaultSettings.isVisibleLabels);
	                    return {
	                        isVisibleLabels: isVisibleLabels,
	                        scale: {
	                            x: SankeyDiagram.DefaultSettings.scale.x,
	                            y: SankeyDiagram.DefaultSettings.scale.y
	                        },
	                        colourOfLabels: SankeyDiagram.DefaultSettings.colourOfLabels,
	                        fontSize: powerbi.DataViewObjects.getValue(objects, SankeyDiagram.Properties["labels"]["fontSize"], SankeyDiagram.DefaultSettings.fontSize)
	                    };
	                };
	                SankeyDiagram.prototype.computePositions = function (sankeyDiagramDataView) {
	                    var maxXPosition, maxColumn, columns;
	                    maxXPosition = this.computeXPositions(sankeyDiagramDataView);
	                    this.sortNodesByX(sankeyDiagramDataView.nodes);
	                    columns = this.getColumns(sankeyDiagramDataView.nodes);
	                    maxColumn = this.getMaxColumn(columns);
	                    sankeyDiagramDataView.settings.scale.x = this.getScaleByAxisX(maxXPosition);
	                    sankeyDiagramDataView.settings.scale.y = this.getScaleByAxisY(maxColumn.sumValueOfNodes);
	                    this.scalePositionsByAxes(sankeyDiagramDataView.nodes, columns, sankeyDiagramDataView.settings.scale, this.viewport.height);
	                    this.computeYPosition(sankeyDiagramDataView.nodes, sankeyDiagramDataView.settings.scale.y);
	                };
	                SankeyDiagram.prototype.computeXPositions = function (sankeyDiagramDataView) {
	                    var nodes = sankeyDiagramDataView.nodes, nextNodes = [], previousNodes = [], x = 0, isRecursiveDependencies = false;
	                    while (nodes.length > 0) {
	                        nextNodes = [];
	                        nodes.forEach(function (node) {
	                            node.x = x;
	                            node.links.forEach(function (link) {
	                                if (node === link.source && node !== link.destination) {
	                                    if (nextNodes.every(function (item) {
	                                        return item !== link.destination;
	                                    })) {
	                                        nextNodes.push(link.destination);
	                                    }
	                                }
	                            });
	                        });
	                        isRecursiveDependencies = nextNodes.length === previousNodes.length &&
	                            previousNodes.every(function (previousNode) {
	                                return nextNodes.some(function (nextNode) {
	                                    return nextNode === previousNode;
	                                });
	                            });
	                        if (isRecursiveDependencies) {
	                            previousNodes.forEach(function (element) {
	                                element.x = x;
	                                x++;
	                            });
	                            nodes = [];
	                        }
	                        else {
	                            nodes = nextNodes;
	                            previousNodes = nodes;
	                            x++;
	                        }
	                    }
	                    return x - 1;
	                };
	                SankeyDiagram.prototype.getScaleByAxisX = function (numberOfColumns) {
	                    if (numberOfColumns === void 0) { numberOfColumns = 1; }
	                    return this.getPositiveNumber((this.viewport.width - this.nodeWidth) / numberOfColumns);
	                };
	                /**
	                 * Public for testability.
	                 */
	                SankeyDiagram.prototype.sortNodesByX = function (nodes) {
	                    return nodes.sort(function (firstNode, secondNode) {
	                        return firstNode.x - secondNode.x;
	                    });
	                };
	                /**
	                 * Public for testability.
	                 */
	                SankeyDiagram.prototype.getColumns = function (nodes) {
	                    var columns = [], currentX = -Number.MAX_VALUE;
	                    nodes.forEach(function (node, index) {
	                        if (currentX !== node.x) {
	                            columns.push({
	                                countOfNodes: 0,
	                                sumValueOfNodes: 0
	                            });
	                            currentX = node.x;
	                        }
	                        if (columns[node.x]) {
	                            columns[node.x].sumValueOfNodes += Math.max(node.inputWeight, node.outputWeight);
	                            columns[node.x].countOfNodes++;
	                        }
	                    });
	                    return columns;
	                };
	                /**
	                 * Public for testability.
	                 */
	                SankeyDiagram.prototype.getMaxColumn = function (columns) {
	                    if (columns === void 0) { columns = []; }
	                    var currentMaxColumn = { sumValueOfNodes: 0, countOfNodes: 0 };
	                    columns.forEach(function (column) {
	                        if (column && column.sumValueOfNodes > currentMaxColumn.sumValueOfNodes) {
	                            currentMaxColumn = column;
	                        }
	                    });
	                    return currentMaxColumn;
	                };
	                SankeyDiagram.prototype.getScaleByAxisY = function (sumValueOfNodes) {
	                    return this.getPositiveNumber((this.viewport.height - this.getAvailableSumNodeMarginByY()) / sumValueOfNodes);
	                };
	                SankeyDiagram.prototype.getAvailableSumNodeMarginByY = function () {
	                    return this.viewport
	                        ? this.viewport.height * SankeyDiagram.NodeBottomMargin / 100
	                        : 0;
	                };
	                SankeyDiagram.prototype.scalePositionsByAxes = function (nodes, columns, scale, viewportHeight) {
	                    var shiftByAxisY = 0, currentX = 0, index = 0;
	                    nodes.forEach(function (node) {
	                        var offsetByY = 0, availableHeight = 0;
	                        if (currentX !== node.x) {
	                            currentX = node.x;
	                            shiftByAxisY = 0;
	                            index = 0;
	                        }
	                        if (columns[currentX]) {
	                            availableHeight = viewportHeight - columns[currentX].sumValueOfNodes * scale.y;
	                            offsetByY = availableHeight / columns[currentX].countOfNodes;
	                        }
	                        node.x *= scale.x;
	                        node.height = Math.max(node.inputWeight, node.outputWeight) * scale.y;
	                        node.y = shiftByAxisY + offsetByY * index;
	                        shiftByAxisY += node.height;
	                        index++;
	                    });
	                };
	                // TODO: Update this method to improve a distribution by height.
	                SankeyDiagram.prototype.computeYPosition = function (nodes, scale) {
	                    nodes.forEach(function (node) {
	                        node.links = node.links.sort(function (firstLink, secondLink) {
	                            var firstY, secondY;
	                            firstY = firstLink.source === node
	                                ? firstLink.destination.y
	                                : firstLink.source.y;
	                            secondY = secondLink.source === node
	                                ? secondLink.destination.y
	                                : secondLink.source.y;
	                            return firstY - secondY;
	                        });
	                        var shiftByAxisYOfLeftLink = 0, shiftByAxisYOfRightLink = 0;
	                        node.links.forEach(function (link) {
	                            var shiftByAxisY = 0;
	                            link.height = link.weigth * scale;
	                            if (link.source.x < node.x || link.destination.x < node.x) {
	                                shiftByAxisY = shiftByAxisYOfLeftLink;
	                                shiftByAxisYOfLeftLink += link.height;
	                            }
	                            else if (link.source.x > node.x || link.destination.x > node.x) {
	                                shiftByAxisY = shiftByAxisYOfRightLink;
	                                shiftByAxisYOfRightLink += link.height;
	                            }
	                            if (link.source === node) {
	                                link.dySource = shiftByAxisY;
	                            }
	                            else if (link.destination === node) {
	                                link.dyDestination = shiftByAxisY;
	                            }
	                        });
	                    });
	                };
	                SankeyDiagram.prototype.render = function (sankeyDiagramDataView) {
	                    var nodesSelection, linksSelection;
	                    linksSelection = this.renderLinks(sankeyDiagramDataView);
	                    this.renderTooltip(linksSelection);
	                    nodesSelection = this.renderNodes(sankeyDiagramDataView);
	                    this.renderTooltip(nodesSelection);
	                    this.bindSelectionHandler(sankeyDiagramDataView, nodesSelection, linksSelection);
	                };
	                SankeyDiagram.prototype.renderNodes = function (sankeyDiagramDataView) {
	                    var _this = this;
	                    var nodesEnterSelection, nodesSelection, nodeElements;
	                    nodeElements = this.main
	                        .select(SankeyDiagram.Nodes.selector)
	                        .selectAll(SankeyDiagram.Node.selector);
	                    nodesSelection = nodeElements.data(sankeyDiagramDataView.nodes.filter(function (x) { return x.height > 0; }));
	                    nodesEnterSelection = nodesSelection
	                        .enter()
	                        .append("g");
	                    nodesSelection
	                        .attr("transform", function (node) {
	                        return visuals.SVGUtil.translate(node.x, node.y);
	                    })
	                        .classed(SankeyDiagram.Node["class"], true);
	                    nodesEnterSelection
	                        .append("rect")
	                        .classed(SankeyDiagram.NodeRect["class"], true);
	                    nodesEnterSelection
	                        .append("text")
	                        .classed(SankeyDiagram.NodeLabel["class"], true);
	                    nodesSelection
	                        .select(SankeyDiagram.NodeRect.selector)
	                        .style({
	                        "fill": function (node) { return node.colour; },
	                        "stroke": function (node) { return d3.rgb(node.colour).darker(1.5); }
	                    })
	                        .attr({
	                        x: 0,
	                        y: 0,
	                        height: function (node) { return node.height; },
	                        width: function (node) { return node.width; }
	                    });
	                    nodesSelection
	                        .select(SankeyDiagram.NodeLabel.selector)
	                        .attr({
	                        x: function (node) { return _this.getLabelPositionByAxisX(node); },
	                        y: function (node) { return node.height / 2; },
	                        dy: "0.35em"
	                    })
	                        .style("fill", function (node) { return node.label.colour; })
	                        .style("font-size", this.textProperties.fontSize)
	                        .style("display", function (node) {
	                        var isNotVisibleLabel = false, labelPositionByAxisX = _this.getCurrentPositionOfLabelByAxisX(node);
	                        isNotVisibleLabel =
	                            labelPositionByAxisX >= _this.viewport.width ||
	                                labelPositionByAxisX <= 0 ||
	                                (node.height + SankeyDiagram.NodeMargin) < node.label.height;
	                        if (isNotVisibleLabel || !sankeyDiagramDataView.settings.isVisibleLabels
	                            || sankeyDiagramDataView.settings.scale.x / 2 < SankeyDiagram.MinWidthOfLabel) {
	                            return "none";
	                        }
	                        return null;
	                    })
	                        .style("text-anchor", function (node) {
	                        if (_this.isLabelLargerThanWidth(node)) {
	                            return "end";
	                        }
	                        return null;
	                    })
	                        .text(function (node) {
	                        var maxWidth = sankeyDiagramDataView.settings.scale.x / 2 - node.width - SankeyDiagram.NodeMargin;
	                        if (_this.getCurrentPositionOfLabelByAxisX(node) > maxWidth) {
	                            return powerbi.TextMeasurementService.getTailoredTextOrDefault({
	                                text: node.label.formattedName,
	                                fontFamily: _this.textProperties.fontFamily,
	                                fontSize: _this.textProperties.fontSize
	                            }, maxWidth);
	                        }
	                        return node.label.formattedName;
	                    });
	                    nodesSelection
	                        .exit()
	                        .remove();
	                    return nodesSelection;
	                };
	                SankeyDiagram.prototype.getLabelPositionByAxisX = function (node) {
	                    if (this.isLabelLargerThanWidth(node)) {
	                        return -(SankeyDiagram.LabelMargin);
	                    }
	                    return node.width + SankeyDiagram.LabelMargin;
	                };
	                SankeyDiagram.prototype.isLabelLargerThanWidth = function (node) {
	                    var shiftByAxisX = node.x + node.width + SankeyDiagram.LabelMargin;
	                    return shiftByAxisX + node.label.width > this.viewport.width;
	                };
	                SankeyDiagram.prototype.getCurrentPositionOfLabelByAxisX = function (node) {
	                    var labelPositionByAxisX = this.getLabelPositionByAxisX(node);
	                    labelPositionByAxisX = labelPositionByAxisX > 0
	                        ? labelPositionByAxisX + node.x + node.label.width + node.width
	                        : node.x + labelPositionByAxisX - node.label.width - node.width;
	                    return labelPositionByAxisX;
	                };
	                SankeyDiagram.prototype.renderLinks = function (sankeyDiagramDataView) {
	                    var _this = this;
	                    var linksSelection, linksElements;
	                    linksElements = this.main
	                        .select(SankeyDiagram.Links.selector)
	                        .selectAll(SankeyDiagram.Link.selector);
	                    linksSelection = linksElements.data(sankeyDiagramDataView.links.filter(function (x) { return x.height > 0; }));
	                    linksSelection
	                        .enter()
	                        .append("path")
	                        .classed(SankeyDiagram.Link["class"], true);
	                    linksSelection
	                        .attr("d", function (link) {
	                        return _this.getSvgPath(link);
	                    })
	                        .style({
	                        "stroke-width": function (link) { return link.height; },
	                        "stroke": function (link) { return link.colour; }
	                    });
	                    linksSelection
	                        .exit()
	                        .remove();
	                    return linksSelection;
	                };
	                SankeyDiagram.prototype.getSvgPath = function (link) {
	                    var x0, x1, xi, x2, x3, y0, y1;
	                    if (link.destination.x < link.source.x) {
	                        x0 = link.source.x;
	                        x1 = link.destination.x + link.destination.width;
	                    }
	                    else {
	                        x0 = link.source.x + link.source.width;
	                        x1 = link.destination.x;
	                    }
	                    xi = d3.interpolateNumber(x0, x1);
	                    x2 = xi(this.curvatureOfLinks);
	                    x3 = xi(1 - this.curvatureOfLinks);
	                    y0 = link.source.y + link.dySource + link.height / 2;
	                    y1 = link.destination.y + link.dyDestination + link.height / 2;
	                    return "M " + x0 + " " + y0 + " C " + x2 + " " + y0 + ", " + x3 + " " + y1 + ", " + x1 + " " + y1;
	                };
	                SankeyDiagram.prototype.renderTooltip = function (selection) {
	                    visuals.TooltipManager.addTooltip(selection, function (tooltipEvent) {
	                        return tooltipEvent.data.tooltipData;
	                    });
	                };
	                SankeyDiagram.prototype.bindSelectionHandler = function (sankeyDiagramDataView, nodesSelection, linksSelection) {
	                    var _this = this;
	                    nodesSelection.on("click", function (node) {
	                        var selectionIds = _.isEqual(node.selectionIds.map(function (x) { return x.getKey(); }), _this.selectionManager.getSelectionIds().map(function (x) { return x.getKey(); }))
	                            ? []
	                            : node.selectionIds;
	                        _this.selectMany(selectionIds, true).then(function () { return _this.setSelection(nodesSelection, linksSelection); });
	                        d3.event.stopPropagation();
	                    });
	                    linksSelection.on("click", function (link) {
	                        _this.selectionManager.select(link.selectionId, d3.event.ctrlKey).then(function () {
	                            return _this.setSelection(nodesSelection, linksSelection);
	                        });
	                        d3.event.stopPropagation();
	                    });
	                    this.root.on("click", function () {
	                        _this.selectionManager.clear().then(function () { return _this.setSelection(nodesSelection, linksSelection); });
	                    });
	                    this.setSelection(nodesSelection, linksSelection);
	                };
	                SankeyDiagram.prototype.selectMany = function (selectionIds, clear) {
	                    var _this = this;
	                    if (clear === void 0) { clear = false; }
	                    if (clear) {
	                        return this.selectionManager.clear().then(function () { return _this.selectMany(selectionIds, false); });
	                    }
	                    var selectionDeffered = selectionIds.map(function (id) { return _this.selectionManager.select(id, true); });
	                    return $.when.apply(null, selectionDeffered);
	                };
	                SankeyDiagram.prototype.setSelection = function (nodes, links) {
	                    var selectionIds = this.selectionManager.getSelectionIds();
	                    nodes.classed("selected", selectionIds.length > 0);
	                    links.classed("selected", false);
	                    if (selectionIds.length === 0) {
	                        return;
	                    }
	                    var selectedNodesSelection = nodes.filter(function (node) { return selectionIds
	                        .some(function (selectedId) { return node.selectionIds
	                        .some(function (x) { return x.getKey() === selectedId.getKey(); }); }); });
	                    var selectedLinksSelection = links.filter(function (link) {
	                        return selectionIds.some(function (selectionId) { return selectionId.getKey() === link.selectionId.getKey(); });
	                    });
	                    selectedNodesSelection.classed("selected", false);
	                    selectedLinksSelection.classed("selected", true);
	                };
	                SankeyDiagram.prototype.enumerateObjectInstances = function (options) {
	                    var enumeration = new visuals.ObjectEnumerationBuilder();
	                    if (!this.dataView) {
	                        return [];
	                    }
	                    switch (options.objectName) {
	                        case "labels": {
	                            this.enumerateLabels(enumeration);
	                            break;
	                        }
	                        case "links": {
	                            this.enumerateLinks(enumeration);
	                            break;
	                        }
	                    }
	                    return enumeration.complete();
	                };
	                SankeyDiagram.prototype.enumerateLabels = function (enumeration) {
	                    var settings = this.dataView.settings, labels;
	                    if (!settings) {
	                        return;
	                    }
	                    labels = {
	                        objectName: "labels",
	                        displayName: "labels",
	                        selector: null,
	                        properties: {
	                            show: settings.isVisibleLabels,
	                            fill: settings.colourOfLabels,
	                            fontSize: settings.fontSize
	                        }
	                    };
	                    enumeration.pushInstance(labels);
	                };
	                SankeyDiagram.prototype.enumerateLinks = function (enumeration) {
	                    var links = this.dataView.links;
	                    if (!links || !(links.length > 0)) {
	                        return;
	                    }
	                    links.forEach(function (link) {
	                        enumeration.pushInstance({
	                            objectName: "links",
	                            displayName: link.source.label.formattedName + " - " + link.destination.label.formattedName,
	                            selector: visuals.ColorHelper.normalizeSelector(link.selectionId.getSelector(), false),
	                            properties: {
	                                fill: { solid: { color: link.colour } }
	                            }
	                        });
	                    });
	                };
	                SankeyDiagram.ClassName = "sankeyDiagram";
	                SankeyDiagram.Nodes = {
	                    "class": "nodes",
	                    selector: ".nodes"
	                };
	                SankeyDiagram.Node = {
	                    "class": "node",
	                    selector: ".node"
	                };
	                SankeyDiagram.NodeRect = {
	                    "class": "nodeRect",
	                    selector: ".nodeRect"
	                };
	                SankeyDiagram.NodeLabel = {
	                    "class": "nodeLabel",
	                    selector: ".nodeLabel"
	                };
	                SankeyDiagram.Links = {
	                    "class": "links",
	                    selector: ".links"
	                };
	                SankeyDiagram.Link = {
	                    "class": "link",
	                    selector: ".link"
	                };
	                SankeyDiagram.DefaultColourOfNode = "rgb(62, 187, 162)";
	                SankeyDiagram.DefaultColourOfLink = "black";
	                SankeyDiagram.DefaultSettings = {
	                    isVisibleLabels: true,
	                    scale: { x: 1, y: 1 },
	                    colourOfLabels: "black",
	                    fontSize: 12
	                };
	                SankeyDiagram.MinWidthOfLabel = 35;
	                SankeyDiagram.NodeBottomMargin = 5; // 5%
	                SankeyDiagram.NodeMargin = 5;
	                SankeyDiagram.LabelMargin = 4;
	                SankeyDiagram.RoleNames = {
	                    rows: "Source",
	                    columns: "Destination",
	                    values: "Weight"
	                };
	                SankeyDiagram.capabilities = {
	                    dataRoles: [{
	                            name: SankeyDiagram.RoleNames.rows,
	                            kind: powerbi.VisualDataRoleKind.Grouping,
	                            displayName: SankeyDiagram.RoleNames.rows
	                        }, {
	                            name: SankeyDiagram.RoleNames.columns,
	                            kind: powerbi.VisualDataRoleKind.Grouping,
	                            displayName: SankeyDiagram.RoleNames.columns
	                        }, {
	                            name: SankeyDiagram.RoleNames.values,
	                            kind: powerbi.VisualDataRoleKind.Measure,
	                            displayName: SankeyDiagram.RoleNames.values
	                        }],
	                    dataViewMappings: [{
	                            conditions: [
	                                { "Source": { min: 0, max: 1 }, "Destination": { min: 0, max: 1 }, "Weight": { min: 0, max: 0 } },
	                                { "Source": { min: 0, max: 1 }, "Destination": { min: 0, max: 1 }, "Weight": { min: 1, max: 1 } }
	                            ],
	                            categorical: {
	                                categories: {
	                                    for: { in: SankeyDiagram.RoleNames.rows },
	                                    dataReductionAlgorithm: { top: {} }
	                                },
	                                values: {
	                                    select: [
	                                        { bind: { to: SankeyDiagram.RoleNames.columns } },
	                                        { bind: { to: SankeyDiagram.RoleNames.values } }
	                                    ]
	                                }
	                            }
	                        }],
	                    objects: {
	                        general: {
	                            displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
	                            properties: {
	                                formatString: { type: { formatting: { formatString: true } } }
	                            }
	                        },
	                        labels: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
	                            properties: {
	                                show: {
	                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
	                                    type: { bool: true }
	                                },
	                                fill: {
	                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                fontSize: {
	                                    displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
	                                    type: { formatting: { fontSize: true } }
	                                }
	                            }
	                        },
	                        links: {
	                            displayName: "Links",
	                            properties: {
	                                fill: {
	                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
	                                    type: { fill: { solid: { color: true } } }
	                                }
	                            }
	                        }
	                    }
	                };
	                SankeyDiagram.Properties = SankeyDiagram.getProperties(SankeyDiagram.capabilities);
	                return SankeyDiagram;
	            }());
	            samples.SankeyDiagram = SankeyDiagram;
	        })(samples = visuals.samples || (visuals.samples = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 42 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../../../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var samples;
	        (function (samples) {
	            var PixelConverter = jsCommon.PixelConverter;
	            var createEnumType = powerbi.createEnumType;
	            var VisualDataRoleKind = powerbi.VisualDataRoleKind;
	            var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
	            var DataViewObjects = powerbi.DataViewObjects;
	            var TextMeasurementService = powerbi.TextMeasurementService;
	            var valueFormatter = powerbi.visuals.valueFormatter;
	            var SelectionId = powerbi.visuals.SelectionId;
	            var TooltipBuilder = powerbi.visuals.TooltipBuilder;
	            var appendClearCatcher = powerbi.visuals.appendClearCatcher;
	            var createInteractivityService = powerbi.visuals.createInteractivityService;
	            var TooltipManager = powerbi.visuals.TooltipManager;
	            samples.bulletChartRoleNames = {
	                value: 'Value',
	                targetValue: 'TargetValue',
	                minValue: 'Minimum',
	                needsImprovementValue: 'NeedsImprovement',
	                satisfactoryValue: 'Satisfactory',
	                goodValue: 'Good',
	                veryGoodValue: 'VeryGood',
	                maxValue: 'Maximum',
	                targetValue2: 'TargetValue2',
	            };
	            var Orientation;
	            (function (Orientation) {
	                Orientation.HORIZONTALLEFT = 'Horizontal Left';
	                Orientation.HORIZONTALRIGHT = 'Horizontal Right';
	                Orientation.VERTICALTOP = 'Vertical Top';
	                Orientation.VERTICALBOTTOM = 'Vertical Bottom';
	                Orientation.type = createEnumType([
	                    { value: Orientation.HORIZONTALLEFT, displayName: Orientation.HORIZONTALLEFT },
	                    { value: Orientation.HORIZONTALRIGHT, displayName: Orientation.HORIZONTALRIGHT },
	                    { value: Orientation.VERTICALTOP, displayName: Orientation.VERTICALTOP },
	                    { value: Orientation.VERTICALBOTTOM, displayName: Orientation.VERTICALBOTTOM }
	                ]);
	            })(Orientation || (Orientation = {}));
	            samples.bulletChartProps = {
	                values: {
	                    targetValue: { objectName: 'values', propertyName: 'targetValue' },
	                    minimumPercent: { objectName: 'values', propertyName: 'minimumPercent' },
	                    needsImprovementPercent: { objectName: 'values', propertyName: 'needsImprovementPercent' },
	                    satisfactoryPercent: { objectName: 'values', propertyName: 'satisfactoryPercent' },
	                    goodPercent: { objectName: 'values', propertyName: 'goodPercent' },
	                    veryGoodPercent: { objectName: 'values', propertyName: 'veryGoodPercent' },
	                    maximumPercent: { objectName: 'values', propertyName: 'maximumPercent' },
	                    targetValue2: { objectName: 'values', propertyName: 'targetValue2' },
	                    secondTargetVisibility: { objectName: 'values', propertyName: 'secondTargetVisibility' },
	                },
	                orientation: {
	                    orientation: { objectName: 'orientation', propertyName: 'orientation' },
	                },
	                colors: {
	                    badColor: { objectName: 'colors', propertyName: 'badColor' },
	                    needsImprovementColor: { objectName: 'colors', propertyName: 'needsImprovementColor' },
	                    satisfactoryColor: { objectName: 'colors', propertyName: 'satisfactoryColor' },
	                    goodColor: { objectName: 'colors', propertyName: 'goodColor' },
	                    veryGoodColor: { objectName: 'colors', propertyName: 'veryGoodColor' },
	                    bulletColor: { objectName: 'colors', propertyName: 'bulletColor' },
	                },
	                axis: {
	                    axis: { objectName: 'axis', propertyName: 'axis' },
	                    axisColor: { objectName: 'axis', propertyName: 'axisColor' },
	                    measureUnits: { objectName: 'axis', propertyName: 'measureUnits' },
	                    unitsColor: { objectName: 'axis', propertyName: 'unitsColor' },
	                },
	                general: {
	                    formatString: { objectName: 'general', propertyName: 'formatString' },
	                },
	                labels: {
	                    fontSize: { objectName: 'labels', propertyName: 'fontSize' },
	                    show: { objectName: 'labels', propertyName: 'show' },
	                    labelColor: { objectName: 'labels', propertyName: 'labelColor' }
	                }
	            };
	            var BulletChart = (function () {
	                function BulletChart() {
	                    this.baselineDelta = 0;
	                }
	                Object.defineProperty(BulletChart.prototype, "reverse", {
	                    get: function () {
	                        return this.model.bulletChartSettings.orientation.reverse;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(BulletChart.prototype, "vertical", {
	                    get: function () {
	                        return this.model.bulletChartSettings.orientation.vertical;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                BulletChart.DefaultStyleProperties = function () {
	                    return {
	                        values: {
	                            targetValue: 0,
	                            targetValue2: 0,
	                            minimumPercent: 0,
	                            needsImprovementPercent: 25,
	                            satisfactoryPercent: 50,
	                            goodPercent: 100,
	                            veryGoodPercent: 125,
	                            maximumPercent: 200,
	                            secondTargetVisibility: false,
	                        },
	                        orientation: {
	                            orientation: Orientation.HORIZONTALLEFT,
	                            reverse: false,
	                            vertical: false
	                        },
	                        colors: {
	                            badColor: 'Darkred',
	                            needsImprovementColor: 'Red',
	                            satisfactoryColor: 'Yellow',
	                            goodColor: 'Green',
	                            veryGoodColor: 'Darkgreen',
	                            bulletColor: 'Black'
	                        },
	                        axis: {
	                            axis: true,
	                            axisColor: 'Grey',
	                            measureUnits: '',
	                            unitsColor: 'Grey',
	                        },
	                        labelSettings: {
	                            fontSize: 11,
	                            show: true,
	                            labelColor: 'Black',
	                        },
	                    };
	                };
	                Object.defineProperty(BulletChart.prototype, "viewportIn", {
	                    get: function () {
	                        return {
	                            width: this.viewport.width,
	                            height: this.viewport.height
	                        };
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(BulletChart.prototype, "viewportScroll", {
	                    get: function () {
	                        var viewportIn = this.viewportIn;
	                        return {
	                            width: viewportIn.width - BulletChart.ScrollBarSize,
	                            height: viewportIn.height - BulletChart.ScrollBarSize
	                        };
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                BulletChart.getTextProperties = function (text, fontSize) {
	                    return {
	                        fontFamily: BulletChart.FontFamily,
	                        fontSize: PixelConverter.fromPoint(fontSize),
	                        text: text,
	                    };
	                };
	                // Convert a DataView into a view model
	                BulletChart.converter = function (dataView, options) {
	                    var defaultSettings = BulletChart.DefaultStyleProperties();
	                    var bulletModel = {
	                        bulletValueFormatString: null,
	                        bulletChartSettings: defaultSettings,
	                        bars: [],
	                        barRects: [],
	                        valueRects: [],
	                        targetValues: [],
	                        viewportLength: 0
	                    };
	                    if (!dataView || !dataView.categorical || !dataView.categorical.values || dataView.categorical.values.length === 0
	                        || !dataView.metadata || !dataView.metadata.columns || dataView.metadata.columns.length === 0) {
	                        return bulletModel;
	                    }
	                    var objects = dataView.metadata.objects;
	                    var settings = bulletModel.bulletChartSettings;
	                    if (objects) {
	                        settings.values.targetValue = DataViewObjects.getValue(objects, samples.bulletChartProps["values"]["targetValue"], defaultSettings.values.targetValue);
	                        settings.values.targetValue2 = DataViewObjects.getValue(objects, samples.bulletChartProps["values"]["targetValue2"], defaultSettings.values.targetValue2);
	                        settings.values.secondTargetVisibility = DataViewObjects.getValue(objects, samples.bulletChartProps["values"]["secondTargetVisibility"], defaultSettings.values.secondTargetVisibility);
	                        settings.values.minimumPercent = DataViewObjects.getValue(objects, samples.bulletChartProps["values"]["minimumPercent"], defaultSettings.values.minimumPercent);
	                        settings.values.needsImprovementPercent = DataViewObjects.getValue(objects, samples.bulletChartProps["values"]["needsImprovementPercent"], defaultSettings.values.needsImprovementPercent);
	                        settings.values.satisfactoryPercent = DataViewObjects.getValue(objects, samples.bulletChartProps["values"]["satisfactoryPercent"], defaultSettings.values.satisfactoryPercent);
	                        settings.values.goodPercent = DataViewObjects.getValue(objects, samples.bulletChartProps["values"]["goodPercent"], defaultSettings.values.goodPercent);
	                        settings.values.veryGoodPercent = DataViewObjects.getValue(objects, samples.bulletChartProps["values"]["veryGoodPercent"], defaultSettings.values.veryGoodPercent);
	                        settings.values.maximumPercent = DataViewObjects.getValue(objects, samples.bulletChartProps["values"]["maximumPercent"], defaultSettings.values.maximumPercent);
	                        settings.orientation.orientation = DataViewObjects.getValue(objects, samples.bulletChartProps["orientation"]["orientation"], defaultSettings.orientation.orientation);
	                        settings.colors.badColor = DataViewObjects.getFillColor(objects, samples.bulletChartProps["colors"]["badColor"], defaultSettings.colors.badColor);
	                        settings.colors.needsImprovementColor = DataViewObjects.getFillColor(objects, samples.bulletChartProps["colors"]["needsImprovementColor"], defaultSettings.colors.needsImprovementColor);
	                        settings.colors.satisfactoryColor = DataViewObjects.getFillColor(objects, samples.bulletChartProps["colors"]["satisfactoryColor"], defaultSettings.colors.satisfactoryColor);
	                        settings.colors.goodColor = DataViewObjects.getFillColor(objects, samples.bulletChartProps["colors"]["goodColor"], defaultSettings.colors.goodColor);
	                        settings.colors.veryGoodColor = DataViewObjects.getFillColor(objects, samples.bulletChartProps["colors"]["veryGoodColor"], defaultSettings.colors.veryGoodColor);
	                        settings.colors.bulletColor = DataViewObjects.getFillColor(objects, samples.bulletChartProps["colors"]["bulletColor"], defaultSettings.colors.bulletColor);
	                        settings.axis.axis = DataViewObjects.getValue(objects, samples.bulletChartProps["axis"]["axis"], defaultSettings.axis.axis);
	                        settings.axis.axisColor = DataViewObjects.getFillColor(objects, samples.bulletChartProps["axis"]["axisColor"], defaultSettings.axis.axisColor);
	                        settings.axis.measureUnits = TextMeasurementService.getTailoredTextOrDefault(BulletChart.getTextProperties(DataViewObjects.getValue(objects, samples.bulletChartProps["axis"]["measureUnits"], defaultSettings.axis.measureUnits), BulletChart.DefaultSubtitleFontSizeInPt), BulletChart.MaxLabelWidth);
	                        settings.axis.unitsColor = DataViewObjects.getFillColor(objects, samples.bulletChartProps["axis"]["unitsColor"], defaultSettings.axis.unitsColor);
	                        settings.labelSettings.fontSize = DataViewObjects.getValue(objects, samples.bulletChartProps["labels"]["fontSize"], defaultSettings.labelSettings.fontSize);
	                        settings.labelSettings.show = DataViewObjects.getValue(objects, samples.bulletChartProps["labels"]["show"], defaultSettings.labelSettings.show);
	                        settings.labelSettings.labelColor = DataViewObjects.getFillColor(objects, samples.bulletChartProps["labels"]["labelColor"], defaultSettings.labelSettings.labelColor);
	                    }
	                    if (settings.orientation.orientation === Orientation.HORIZONTALRIGHT || settings.orientation.orientation === Orientation.VERTICALBOTTOM)
	                        settings.orientation.reverse = true;
	                    if (settings.orientation.orientation === Orientation.VERTICALTOP || settings.orientation.orientation === Orientation.VERTICALBOTTOM)
	                        settings.orientation.vertical = true;
	                    var categories, categoryValues, categoryValuesLen = 1, categoryFormatString;
	                    if (dataView.categorical.categories) {
	                        categories = dataView.categorical.categories[0];
	                        categoryValues = categories.values;
	                        categoryValuesLen = categoryValues.length;
	                        categoryFormatString = valueFormatter.getFormatString(categories.source, samples.bulletChartProps["general"]["formatString"]);
	                    }
	                    bulletModel.labelHeight = (settings.labelSettings.show || 0) && parseFloat(PixelConverter.fromPoint(settings.labelSettings.fontSize));
	                    bulletModel.labelHeightTop = (settings.labelSettings.show || 0) && parseFloat(PixelConverter.fromPoint(settings.labelSettings.fontSize)) / 1.4;
	                    bulletModel.spaceRequiredForBarHorizontally = Math.max(60, bulletModel.labelHeight + 20);
	                    bulletModel.bulletValueFormatString = valueFormatter.getFormatString(dataView.categorical.values[0].source, samples.bulletChartProps["general"]["formatString"]);
	                    bulletModel.viewportLength = (settings.orientation.vertical
	                        ? (options.viewport.height - bulletModel.labelHeightTop - BulletChart.SubtitleMargin - 20 - BulletChart.YMarginVertical * 2)
	                        : (options.viewport.width - BulletChart.MaxLabelWidth - BulletChart.XMarginHorizontal * 3)) - BulletChart.ScrollBarSize;
	                    for (var idx = 0; idx < categoryValuesLen; idx++) {
	                        var toolTipItems = [];
	                        var category = void 0, value = void 0, targetValue = void 0, targetValue2 = void 0, minimum = void 0, satisfactory = void 0, good = void 0, maximum = void 0, needsImprovement = void 0, veryGood = void 0;
	                        var highlight = false, categoryIdentity = void 0;
	                        if (categoryValues) {
	                            var categoryValue = categoryValues[idx];
	                            category = valueFormatter.format(categoryValue, categoryFormatString);
	                            categoryIdentity = categories.identity ? categories.identity[idx] : null;
	                            var textProperties = BulletChart.getTextProperties(category, settings.labelSettings.fontSize);
	                            category = TextMeasurementService.getTailoredTextOrDefault(textProperties, BulletChart.MaxLabelWidth);
	                        }
	                        var values = dataView.categorical.values;
	                        targetValue = settings.values.targetValue;
	                        targetValue2 = settings.values.targetValue2;
	                        bulletModel.hasHighlights = !!(values.length > 0 && values[0].highlights);
	                        for (var i = 0; i < values.length; i++) {
	                            var col = values[i].source;
	                            var currentVal = values[i].values[idx] || 0;
	                            if (col && col.roles) {
	                                if (col.roles[samples.bulletChartRoleNames.value]) {
	                                    if (values[i].highlights)
	                                        highlight = values[i].highlights[idx] !== null;
	                                    toolTipItems.push({ value: currentVal, metadata: values[i] });
	                                    value = currentVal;
	                                }
	                                else if (col.roles[samples.bulletChartRoleNames.targetValue]) {
	                                    toolTipItems.push({ value: currentVal, metadata: values[i] });
	                                    targetValue = currentVal;
	                                }
	                                else if (col.roles[samples.bulletChartRoleNames.targetValue2]) {
	                                    toolTipItems.push({ value: currentVal, metadata: values[i] });
	                                    targetValue2 = currentVal;
	                                }
	                                else if (col.roles[samples.bulletChartRoleNames.minValue])
	                                    minimum = currentVal;
	                                else if (col.roles[samples.bulletChartRoleNames.needsImprovementValue])
	                                    needsImprovement = currentVal;
	                                else if (col.roles[samples.bulletChartRoleNames.satisfactoryValue])
	                                    satisfactory = currentVal;
	                                else if (col.roles[samples.bulletChartRoleNames.goodValue])
	                                    good = currentVal;
	                                else if (col.roles[samples.bulletChartRoleNames.veryGoodValue])
	                                    veryGood = currentVal;
	                                else if (col.roles[samples.bulletChartRoleNames.maxValue])
	                                    maximum = currentVal;
	                            }
	                        }
	                        if (!minimum)
	                            minimum = settings.values.minimumPercent * targetValue / 100;
	                        if (!needsImprovement)
	                            needsImprovement = settings.values.needsImprovementPercent * targetValue / 100;
	                        if (!satisfactory)
	                            satisfactory = settings.values.satisfactoryPercent * targetValue / 100;
	                        if (!good)
	                            good = settings.values.goodPercent * targetValue / 100;
	                        if (!veryGood)
	                            veryGood = settings.values.veryGoodPercent * targetValue / 100;
	                        if (!maximum)
	                            maximum = settings.values.maximumPercent * targetValue / 100;
	                        var sortedRanges = [minimum, needsImprovement, satisfactory, good, veryGood, maximum].sort(d3.descending);
	                        var scale = (d3.scale.linear()
	                            .clamp(true)
	                            .domain([minimum, Math.max(sortedRanges[0], targetValue, value)])
	                            .range(settings.orientation.vertical ? [bulletModel.viewportLength, 0] : [0, bulletModel.viewportLength]));
	                        // Scalles without
	                        var firstScale = scale(minimum);
	                        var secondScale = scale(needsImprovement);
	                        var thirdScale = scale(satisfactory);
	                        var fourthScale = scale(good);
	                        var fifthScale = scale(veryGood);
	                        var lastScale = scale(maximum);
	                        var valueScale = scale(value);
	                        var firstColor = settings.colors.badColor, secondColor = settings.colors.needsImprovementColor, thirdColor = settings.colors.satisfactoryColor, fourthColor = settings.colors.goodColor, lastColor = settings.colors.veryGoodColor;
	                        BulletChart.addItemToBarArray(bulletModel.barRects, idx, firstScale, secondScale, firstColor, toolTipItems, categoryIdentity, highlight);
	                        BulletChart.addItemToBarArray(bulletModel.barRects, idx, secondScale, thirdScale, secondColor, toolTipItems, categoryIdentity, highlight);
	                        BulletChart.addItemToBarArray(bulletModel.barRects, idx, thirdScale, fourthScale, thirdColor, toolTipItems, categoryIdentity, highlight);
	                        BulletChart.addItemToBarArray(bulletModel.barRects, idx, fourthScale, fifthScale, fourthColor, toolTipItems, categoryIdentity, highlight);
	                        BulletChart.addItemToBarArray(bulletModel.barRects, idx, fifthScale, lastScale, lastColor, toolTipItems, categoryIdentity, highlight);
	                        BulletChart.addItemToBarArray(bulletModel.valueRects, idx, firstScale, valueScale, settings.colors.bulletColor, toolTipItems, categoryIdentity, highlight);
	                        // markerValue
	                        bulletModel.targetValues.push({
	                            barIndex: idx,
	                            value: scale(targetValue),
	                            fill: settings.colors.bulletColor,
	                            key: SelectionId.createWithIdAndMeasure(categoryIdentity, scale(targetValue).toString()).getKey(),
	                            value2: scale(targetValue2),
	                        });
	                        var xAxis = null;
	                        if (settings.axis.axis) {
	                            xAxis = d3.svg.axis();
	                            xAxis.orient(settings.orientation.vertical ? "left" : "bottom");
	                            var minTickSize = Math.round(Math.max(3, bulletModel.viewportLength / 100));
	                            var axisValues = [value, targetValue, good, satisfactory, maximum, minimum, needsImprovement, veryGood]
	                                .filter(function (x) { return !isNaN(x); });
	                            xAxis.tickFormat(valueFormatter.create({
	                                format: bulletModel.bulletValueFormatString,
	                                value: axisValues.length ? Math.max.apply(null, axisValues) : 0
	                            }).format);
	                            xAxis.ticks(minTickSize);
	                            xAxis.scale(scale);
	                        }
	                        var bar = {
	                            scale: scale,
	                            barIndex: idx,
	                            categoryLabel: category,
	                            x: (settings.orientation.vertical) ? BulletChart.XMarginVertical + BulletChart.SpaceRequiredForBarVertically * idx : BulletChart.XMarginHorizontal,
	                            y: (settings.orientation.vertical) ? BulletChart.YMarginVertical : BulletChart.YMarginHorizontal + bulletModel.spaceRequiredForBarHorizontally * idx,
	                            axis: xAxis,
	                            key: SelectionId.createWithIdAndMeasure(categoryIdentity, idx.toString()).getKey(),
	                        };
	                        bulletModel.bars.push(bar);
	                    }
	                    return bulletModel;
	                };
	                BulletChart.addItemToBarArray = function (collection, barIndex, start, end, fill, tooltipInfo, categoryIdentity, highlight) {
	                    if (!isNaN(start) && !isNaN(end))
	                        collection.push({
	                            barIndex: barIndex,
	                            start: start,
	                            end: end,
	                            fill: fill,
	                            tooltipInfo: TooltipBuilder.createTooltipInfo(samples.bulletChartProps["general"]["formatString"], null, null, null, null, tooltipInfo),
	                            selected: false,
	                            identity: SelectionId.createWithId(categoryIdentity),
	                            key: SelectionId.createWithIdAndMeasure(categoryIdentity, start + " " + end).getKey(),
	                            highlight: highlight,
	                        });
	                };
	                /* One time setup*/
	                BulletChart.prototype.init = function (options) {
	                    var body = d3.select(options.element.get(0));
	                    this.hostService = options.host;
	                    this.bulletBody = body
	                        .append('div')
	                        .classed('bulletChart', true)
	                        .attr("drag-resize-disabled", true);
	                    this.scrollContainer = this.bulletBody.append('svg')
	                        .classed('bullet-scroll-region', true);
	                    this.clearCatcher = appendClearCatcher(this.scrollContainer);
	                    this.labelGraphicsContext = this.scrollContainer.append('g');
	                    this.bulletGraphicsContext = this.scrollContainer.append('g');
	                    this.behavior = new BulletWebBehavior();
	                    this.interactivityService = createInteractivityService(options.host);
	                };
	                /* Called for data, size, formatting changes*/
	                BulletChart.prototype.update = function (options) {
	                    if (!options.dataViews || !options.dataViews[0]) {
	                        return;
	                    }
	                    var dataView = options.dataViews[0];
	                    this.viewport = options.viewport;
	                    this.model = BulletChart.converter(dataView, options);
	                    //TODO: Calculating the baseline delta of the text. needs to be removed once the TExtMeasurementService.estimateSVGTextBaselineDelta is available.
	                    this.baselineDelta = TextMeasurementHelper.estimateSvgTextBaselineDelta(BulletChart.getTextProperties("1", this.model.bulletChartSettings.labelSettings.fontSize));
	                    this.ClearViewport();
	                    if (!this.model) {
	                        return;
	                    }
	                    if (this.interactivityService) {
	                        this.interactivityService.applySelectionStateToData(this.model.barRects);
	                    }
	                    this.bulletBody.style({
	                        'height': this.viewportIn.height + 'px',
	                        'width': this.viewportIn.width + 'px',
	                    });
	                    if (this.vertical) {
	                        this.scrollContainer.attr({
	                            width: (this.model.bars.length * BulletChart.SpaceRequiredForBarVertically + BulletChart.XMarginVertical) + 'px',
	                            height: this.viewportScroll.height + 'px'
	                        });
	                    }
	                    else {
	                        this.scrollContainer.attr({
	                            height: (this.model.bars.length * this.model.spaceRequiredForBarHorizontally) + 'px',
	                            width: this.viewportScroll.width + 'px'
	                        });
	                    }
	                    if (this.vertical)
	                        this.setUpBulletsVertically(this.bulletBody, this.model, this.reverse);
	                    else
	                        this.setUpBulletsHorizontally(this.bulletBody, this.model, this.reverse);
	                };
	                BulletChart.prototype.ClearViewport = function () {
	                    this.labelGraphicsContext.selectAll("text").remove();
	                    this.bulletGraphicsContext.selectAll("rect").remove();
	                    this.bulletGraphicsContext.selectAll("text").remove();
	                    this.bulletGraphicsContext.selectAll('axis').remove();
	                    this.bulletGraphicsContext.selectAll('path').remove();
	                    this.bulletGraphicsContext.selectAll('line').remove();
	                    this.bulletGraphicsContext.selectAll('tick').remove();
	                    this.bulletGraphicsContext.selectAll('g').remove();
	                };
	                BulletChart.prototype.onClearSelection = function () {
	                    if (this.interactivityService)
	                        this.interactivityService.clearSelection();
	                };
	                BulletChart.prototype.calculateLabelWidth = function (barData, bar, reversed) {
	                    return (reversed ? 0 : barData.x + BulletChart.MaxLabelWidth) + BulletChart.XMarginHorizontal + (bar ? bar.start : 0);
	                };
	                BulletChart.prototype.calculateLabelHeight = function (barData, bar, reversed) {
	                    return BulletChart.YMarginVertical + (reversed ? 5 :
	                        barData.y + this.model.labelHeightTop + BulletChart.BarMargin + BulletChart.SubtitleMargin)
	                        + (bar ? bar.end : 0);
	                };
	                BulletChart.prototype.setUpBulletsHorizontally = function (bulletBody, model, reveresed) {
	                    var _this = this;
	                    var bars = model.bars;
	                    var rects = model.barRects;
	                    var valueRects = model.valueRects;
	                    var targetValues = model.targetValues;
	                    var barSelection = this.labelGraphicsContext.selectAll('text').data(bars, function (d) { return d.key; });
	                    var rectSelection = this.bulletGraphicsContext.selectAll('rect.range').data(rects, function (d) { return d.key; });
	                    var hasSelection = this.interactivityService && this.interactivityService.hasSelection();
	                    var hasHighlights = model.hasHighlights;
	                    // Draw bullets
	                    var bullets = rectSelection.enter().append('rect').attr({
	                        'x': (function (d) { return _this.calculateLabelWidth(bars[d.barIndex], d, reveresed); }),
	                        'y': (function (d) { return bars[d.barIndex].y - BulletChart.BulletSize / 2; }),
	                        'width': (function (d) { return d.end - d.start; }),
	                        'height': BulletChart.BulletSize,
	                    }).classed('range', true).style({
	                        'fill': function (d) { return d.fill; },
	                        'opacity': function (d) { return bulletChartUtils.getFillOpacity(d.selected, d.highlight, hasSelection, hasHighlights); },
	                    });
	                    rectSelection.exit();
	                    // Draw value rects
	                    var valueSelection = this.bulletGraphicsContext.selectAll('rect').data(valueRects, function (d) { return d.key; });
	                    valueSelection.enter().append('rect').attr({
	                        'x': (function (d) { return _this.calculateLabelWidth(bars[d.barIndex], d, reveresed); }),
	                        'y': (function (d) { return bars[d.barIndex].y - BulletChart.BulletSize / 8; }),
	                        'width': (function (d) { return d.end - d.start; }),
	                        'height': BulletChart.BulletSize * 1 / 4,
	                    }).classed('value', true).style({
	                        'fill': function (d) { return d.fill; },
	                        'opacity': function (d) { return bulletChartUtils.getFillOpacity(d.selected, d.highlight, hasSelection, hasHighlights); },
	                    });
	                    valueSelection.exit();
	                    // Draw markers
	                    var markerSelection = this.bulletGraphicsContext.selectAll('values').data(targetValues, function (d) {
	                        if (!isNaN(d.value) && !isNaN(d.value2))
	                            return d.key;
	                    });
	                    markerSelection.enter().append('line').attr({
	                        'x1': (function (d) { return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value; }),
	                        'x2': (function (d) { return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value; }),
	                        'y1': (function (d) { return bars[d.barIndex].y - BulletChart.MarkerMarginHorizontal; }),
	                        'y2': (function (d) { return bars[d.barIndex].y + BulletChart.MarkerMarginHorizontal; }),
	                    }).style({
	                        'stroke': (function (d) { return d.fill; }),
	                        'stroke-width': 2,
	                    });
	                    if (model.bulletChartSettings.values.secondTargetVisibility) {
	                        this.drawSecondTarget(markerSelection.enter(), function (d) { return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value2; }, function (d) { return bars[d.barIndex].y; });
	                    }
	                    markerSelection.exit();
	                    // Draw axes
	                    if (model.bulletChartSettings.axis.axis) {
	                        // Using var instead of let since you can't pass let parameters to functions inside loops.
	                        // needs to be changed to let when typescript 1.8 comes out.
	                        for (var idx = 0; idx < bars.length; idx++) {
	                            var bar = bars[idx];
	                            this.bulletGraphicsContext.append("g").attr({
	                                'transform': function () {
	                                    var xLocation = _this.calculateLabelWidth(bar, null, reveresed);
	                                    var yLocation = bar.y + BulletChart.BulletSize / 2;
	                                    return 'translate(' + xLocation + ',' + yLocation + ')';
	                                },
	                            }).classed("axis", true).call(bar.axis.scale(bar.scale)).style({
	                                'fill': model.bulletChartSettings.axis.axisColor,
	                                'font-size': PixelConverter.fromPoint(BulletChart.AxisFontSizeInPt)
	                            }).selectAll('line').style({
	                                'stroke': model.bulletChartSettings.axis.axisColor,
	                            });
	                        }
	                    }
	                    // Draw Labels
	                    if (model.bulletChartSettings.labelSettings.show) {
	                        barSelection.enter().append('text').classed("title", true).attr({
	                            'x': (function (d) {
	                                if (reveresed)
	                                    return BulletChart.XMarginHorizontal * 2 + model.viewportLength;
	                                return d.x;
	                            }),
	                            'y': (function (d) { return d.y + _this.baselineDelta; }),
	                            'fill': model.bulletChartSettings.labelSettings.labelColor,
	                            'font-size': PixelConverter.fromPoint(model.bulletChartSettings.labelSettings.fontSize),
	                        }).text(function (d) { return d.categoryLabel; });
	                    }
	                    var measureUnitsText = TextMeasurementService.getTailoredTextOrDefault(BulletChart.getTextProperties(model.bulletChartSettings.axis.measureUnits, BulletChart.DefaultSubtitleFontSizeInPt), BulletChart.MaxMeasureUnitWidth);
	                    // Draw measure label
	                    if (model.bulletChartSettings.axis.measureUnits) {
	                        barSelection.enter().append('text').attr({
	                            'x': (function (d) {
	                                if (reveresed)
	                                    return BulletChart.XMarginHorizontal * 2 + model.viewportLength + BulletChart.SubtitleMargin;
	                                return d.x - BulletChart.SubtitleMargin;
	                            }),
	                            'y': (function (d) { return d.y + _this.model.labelHeight / 2 + 12; }),
	                            'fill': model.bulletChartSettings.axis.unitsColor,
	                            'font-size': PixelConverter.fromPoint(BulletChart.DefaultSubtitleFontSizeInPt)
	                        }).text(measureUnitsText);
	                    }
	                    if (this.interactivityService) {
	                        var behaviorOptions = {
	                            rects: bullets,
	                            valueRects: valueSelection,
	                            clearCatcher: this.clearCatcher,
	                            interactivityService: this.interactivityService,
	                            bulletChartSettings: this.model.bulletChartSettings,
	                            hasHighlights: false,
	                        };
	                        var targetCollection = this.model.barRects.concat(this.model.valueRects);
	                        this.interactivityService.bind(targetCollection, this.behavior, behaviorOptions);
	                    }
	                    barSelection.exit();
	                    TooltipManager.addTooltip(valueSelection, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; }, true);
	                    TooltipManager.addTooltip(rectSelection, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; }, true);
	                };
	                BulletChart.prototype.setUpBulletsVertically = function (bulletBody, model, reveresed) {
	                    var _this = this;
	                    var bars = model.bars;
	                    var rects = model.barRects;
	                    var valueRects = model.valueRects;
	                    var targetValues = model.targetValues;
	                    var barSelection = this.labelGraphicsContext.selectAll('text').data(bars, function (d) { return d.key; });
	                    var rectSelection = this.bulletGraphicsContext.selectAll('rect.range').data(rects, function (d) { return d.key; });
	                    var hasSelection = this.interactivityService && this.interactivityService.hasSelection();
	                    var hasHighlights = model.hasHighlights;
	                    // Draw bullets
	                    var bullets = rectSelection.enter().append('rect').attr({
	                        'x': (function (d) { return bars[d.barIndex].x; }),
	                        'y': (function (d) { return _this.calculateLabelHeight(bars[d.barIndex], d, reveresed); }),
	                        'height': (function (d) { return d.start - d.end; }),
	                        'width': BulletChart.BulletSize,
	                    }).classed('range', true).style({
	                        'fill': function (d) { return d.fill; },
	                        'opacity': function (d) { return bulletChartUtils.getFillOpacity(d.selected, d.highlight, hasSelection, hasHighlights); },
	                    });
	                    rectSelection.exit();
	                    // Draw value rects
	                    var valueSelection = this.bulletGraphicsContext.selectAll('rect').data(valueRects, function (d) { return d.key; });
	                    valueSelection.enter().append('rect').attr({
	                        'x': (function (d) { return bars[d.barIndex].x + BulletChart.BulletSize / 3; }),
	                        'y': (function (d) { return _this.calculateLabelHeight(bars[d.barIndex], d, reveresed); }),
	                        'height': (function (d) { return d.start - d.end; }),
	                        'width': BulletChart.BulletSize * 1 / 4,
	                    }).classed('value', true).style({
	                        'fill': function (d) { return d.fill; },
	                        'opacity': function (d) { return bulletChartUtils.getFillOpacity(d.selected, d.highlight, hasSelection, hasHighlights); },
	                    });
	                    valueSelection.exit();
	                    // Draw markers
	                    var markerSelection = this.bulletGraphicsContext.selectAll('values').data(targetValues, function (d) {
	                        if (!isNaN(d.value) && !isNaN(d.value2))
	                            return d.key;
	                    });
	                    markerSelection.enter().append('line').attr({
	                        'x2': (function (d) { return bars[d.barIndex].x + (BulletChart.MarkerMarginVertical * 3); }),
	                        'x1': (function (d) { return bars[d.barIndex].x + BulletChart.MarkerMarginVertical; }),
	                        'y2': (function (d) { return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value; }),
	                        'y1': (function (d) { return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value; }),
	                    }).style({
	                        'stroke': (function (d) { return d.fill; }),
	                        'stroke-width': 2,
	                    });
	                    if (model.bulletChartSettings.values.secondTargetVisibility) {
	                        this.drawSecondTarget(markerSelection.enter(), function (d) { return bars[d.barIndex].x + BulletChart.BulletSize / 3 + BulletChart.BulletSize / 8; }, function (d) { return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value2; });
	                    }
	                    markerSelection.exit();
	                    // // Draw axes
	                    if (model.bulletChartSettings.axis.axis) {
	                        // Using var instead of let since you can't pass let parameters to functions inside loops.
	                        // needs to be changed to let when typescript 1.8 comes out.
	                        for (var idx = 0; idx < bars.length; idx++) {
	                            var bar = bars[idx];
	                            this.bulletGraphicsContext.append("g").attr({
	                                'transform': function () {
	                                    var xLocation = bar.x;
	                                    var yLocation = _this.calculateLabelHeight(bar, null, reveresed);
	                                    // let yLocation = bar.y + BulletChart.BulletSize / 2;
	                                    return 'translate(' + xLocation + ',' + yLocation + ')';
	                                },
	                            }).classed("axis", true).call(bar.axis.scale(bar.scale)).style({
	                                'fill': model.bulletChartSettings.axis.axisColor,
	                                'font-size': PixelConverter.fromPoint(BulletChart.AxisFontSizeInPt),
	                            }).selectAll('line').style({
	                                'stroke': model.bulletChartSettings.axis.axisColor,
	                            });
	                        }
	                    }
	                    var labelsStartPos = BulletChart.YMarginVertical + (reveresed ? model.viewportLength + 15 : 0) + this.model.labelHeightTop;
	                    // Draw Labels
	                    if (model.bulletChartSettings.labelSettings.show) {
	                        barSelection.enter().append('text').classed("title", true).attr({
	                            'x': (function (d) { return d.x; }),
	                            'y': (function (d) {
	                                return labelsStartPos;
	                            }),
	                            'fill': model.bulletChartSettings.labelSettings.labelColor,
	                            'font-size': PixelConverter.fromPoint(model.bulletChartSettings.labelSettings.fontSize),
	                        }).text(function (d) { return d.categoryLabel; });
	                    }
	                    var measureUnitsText = TextMeasurementService.getTailoredTextOrDefault(BulletChart.getTextProperties(model.bulletChartSettings.axis.measureUnits, BulletChart.DefaultSubtitleFontSizeInPt), BulletChart.MaxMeasureUnitWidth);
	                    // Draw measure label
	                    if (model.bulletChartSettings.axis.measureUnits) {
	                        barSelection.enter().append('text').attr({
	                            'x': (function (d) { return d.x + BulletChart.BulletSize; }),
	                            'y': (function (d) {
	                                return labelsStartPos + BulletChart.SubtitleMargin + 12;
	                            }),
	                            'fill': model.bulletChartSettings.axis.unitsColor,
	                            'font-size': PixelConverter.fromPoint(BulletChart.DefaultSubtitleFontSizeInPt)
	                        }).text(measureUnitsText);
	                    }
	                    if (this.interactivityService) {
	                        var behaviorOptions = {
	                            rects: bullets,
	                            valueRects: valueSelection,
	                            clearCatcher: this.clearCatcher,
	                            interactivityService: this.interactivityService,
	                            bulletChartSettings: this.model.bulletChartSettings,
	                            hasHighlights: false,
	                        };
	                        var targetCollection = this.model.barRects.concat(this.model.valueRects);
	                        this.interactivityService.bind(targetCollection, this.behavior, behaviorOptions);
	                    }
	                    barSelection.exit();
	                    TooltipManager.addTooltip(valueSelection, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; }, true);
	                    TooltipManager.addTooltip(rectSelection, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; }, true);
	                };
	                BulletChart.prototype.drawSecondTarget = function (selection, getX, getY) {
	                    var targetStyle = {
	                        'stroke': (function (d) { return d.fill; }),
	                        'stroke-width': 2
	                    };
	                    selection.append('line').attr({
	                        'x1': (function (d) { return getX(d) - BulletChart.SecondTargetLineSize; }),
	                        'y1': (function (d) { return getY(d) - BulletChart.SecondTargetLineSize; }),
	                        'x2': (function (d) { return getX(d) + BulletChart.SecondTargetLineSize; }),
	                        'y2': (function (d) { return getY(d) + BulletChart.SecondTargetLineSize; }),
	                    }).style(targetStyle);
	                    selection.append('line').attr({
	                        'x1': (function (d) { return getX(d) + BulletChart.SecondTargetLineSize; }),
	                        'y1': (function (d) { return getY(d) - BulletChart.SecondTargetLineSize; }),
	                        'x2': (function (d) { return getX(d) - BulletChart.SecondTargetLineSize; }),
	                        'y2': (function (d) { return getY(d) + BulletChart.SecondTargetLineSize; }),
	                    }).style(targetStyle);
	                };
	                /*About to remove your visual, do clean up here */
	                BulletChart.prototype.destroy = function () { };
	                BulletChart.prototype.enumerateObjectInstances = function (options) {
	                    var data = this.model;
	                    if (!data) {
	                        return;
	                    }
	                    var objectName = options.objectName;
	                    switch (objectName) {
	                        case 'labels':
	                            return this.enumerateLabels(data);
	                        case 'values':
	                            return this.enumerateValues(data);
	                        case 'orientation':
	                            return this.enumerateOrientation(data);
	                        case 'axis':
	                            return this.enumerateAxis(data);
	                        case 'colors':
	                            return this.enumerateColors(data);
	                    }
	                };
	                BulletChart.prototype.enumerateLabels = function (data) {
	                    return [{
	                            selector: null,
	                            objectName: 'labels',
	                            properties: {
	                                show: this.model.bulletChartSettings.labelSettings.show,
	                                labelColor: this.model.bulletChartSettings.labelSettings.labelColor,
	                                fontSize: this.model.bulletChartSettings.labelSettings.fontSize,
	                            }
	                        }];
	                };
	                BulletChart.prototype.enumerateValues = function (data) {
	                    return [{
	                            selector: null,
	                            objectName: 'values',
	                            properties: {
	                                targetValue: this.model.bulletChartSettings.values.targetValue,
	                                targetValue2: this.model.bulletChartSettings.values.targetValue2,
	                                secondTargetVisibility: this.model.bulletChartSettings.values.secondTargetVisibility,
	                                minimumPercent: this.model.bulletChartSettings.values.minimumPercent,
	                                needsImprovementPercent: this.model.bulletChartSettings.values.needsImprovementPercent,
	                                satisfactoryPercent: this.model.bulletChartSettings.values.satisfactoryPercent,
	                                goodPercent: this.model.bulletChartSettings.values.goodPercent,
	                                veryGoodPercent: this.model.bulletChartSettings.values.veryGoodPercent,
	                                maximumPercent: this.model.bulletChartSettings.values.maximumPercent,
	                            }
	                        }];
	                };
	                BulletChart.prototype.enumerateOrientation = function (data) {
	                    return [{
	                            selector: null,
	                            objectName: 'orientation',
	                            properties: {
	                                orientation: this.model.bulletChartSettings.orientation.orientation
	                            }
	                        }];
	                };
	                BulletChart.prototype.enumerateAxis = function (data) {
	                    return [{
	                            selector: null,
	                            objectName: 'axis',
	                            properties: {
	                                axis: this.model.bulletChartSettings.axis.axis,
	                                axisColor: this.model.bulletChartSettings.axis.axisColor,
	                                measureUnits: this.model.bulletChartSettings.axis.measureUnits,
	                                unitsColor: this.model.bulletChartSettings.axis.unitsColor,
	                            }
	                        }];
	                };
	                BulletChart.prototype.enumerateColors = function (data) {
	                    return [{
	                            selector: null,
	                            objectName: 'colors',
	                            properties: {
	                                badColor: this.model.bulletChartSettings.colors.badColor,
	                                needsImprovementColor: this.model.bulletChartSettings.colors.needsImprovementColor,
	                                satisfactoryColor: this.model.bulletChartSettings.colors.satisfactoryColor,
	                                goodColor: this.model.bulletChartSettings.colors.goodColor,
	                                veryGoodColor: this.model.bulletChartSettings.colors.veryGoodColor,
	                                bulletColor: this.model.bulletChartSettings.colors.bulletColor,
	                            }
	                        }];
	                };
	                BulletChart.ScrollBarSize = 22;
	                BulletChart.SpaceRequiredForBarVertically = 100;
	                BulletChart.XMarginHorizontal = 20;
	                BulletChart.YMarginHorizontal = 30;
	                BulletChart.XMarginVertical = 50;
	                BulletChart.YMarginVertical = 10;
	                BulletChart.BulletSize = 25;
	                BulletChart.DefaultSubtitleFontSizeInPt = 9;
	                BulletChart.BarMargin = 10;
	                BulletChart.MaxLabelWidth = 80;
	                BulletChart.MaxMeasureUnitWidth = BulletChart.MaxLabelWidth - 20;
	                BulletChart.SubtitleMargin = 10;
	                BulletChart.AxisFontSizeInPt = 8;
	                BulletChart.SecondTargetLineSize = 7;
	                BulletChart.MarkerMarginHorizontal = BulletChart.BulletSize / 3;
	                BulletChart.MarkerMarginVertical = BulletChart.BulletSize / 4;
	                BulletChart.FontFamily = "Segoe UI";
	                BulletChart.capabilities = {
	                    dataRoles: [
	                        {
	                            name: 'Category',
	                            kind: VisualDataRoleKind.Grouping,
	                            displayName: 'Category',
	                        }, {
	                            name: 'Value',
	                            kind: VisualDataRoleKind.Measure,
	                            displayName: 'Value',
	                        }, {
	                            name: 'TargetValue',
	                            kind: VisualDataRoleKind.Measure,
	                            displayName: 'Target Value',
	                        }, {
	                            name: 'Minimum',
	                            kind: VisualDataRoleKind.Measure,
	                            displayName: 'Minimum',
	                        }, {
	                            name: 'NeedsImprovement',
	                            kind: VisualDataRoleKind.Measure,
	                            displayName: 'Needs Improvement',
	                        }, {
	                            name: 'Satisfactory',
	                            kind: VisualDataRoleKind.Measure,
	                            displayName: 'Satisfactory',
	                        }, {
	                            name: 'Good',
	                            kind: VisualDataRoleKind.Measure,
	                            displayName: 'Good',
	                        }, {
	                            name: 'VeryGood',
	                            kind: VisualDataRoleKind.Measure,
	                            displayName: 'Very Good',
	                        }, {
	                            name: 'Maximum',
	                            kind: VisualDataRoleKind.Measure,
	                            displayName: 'Maximum',
	                        }, {
	                            name: 'TargetValue2',
	                            kind: VisualDataRoleKind.Measure,
	                            displayName: 'Target Value 2'
	                        }
	                    ],
	                    objects: {
	                        general: {
	                            displayName: createDisplayNameGetter('Visual_General'),
	                            properties: {
	                                formatString: {
	                                    type: { formatting: { formatString: true } },
	                                },
	                            },
	                        },
	                        values: {
	                            displayName: 'Data values',
	                            properties: {
	                                targetValue: {
	                                    displayName: 'Target Value',
	                                    type: { numeric: true }
	                                },
	                                targetValue2: {
	                                    displayName: 'Target Value 2',
	                                    type: { numeric: true },
	                                },
	                                secondTargetVisibility: {
	                                    displayName: 'Second Target Visibility',
	                                    type: { bool: true },
	                                },
	                                minimumPercent: {
	                                    displayName: 'Minimum %',
	                                    type: { numeric: true }
	                                },
	                                needsImprovementPercent: {
	                                    displayName: 'Needs Improvement %',
	                                    type: { numeric: true },
	                                },
	                                satisfactoryPercent: {
	                                    displayName: 'Satisfactory %',
	                                    type: { numeric: true }
	                                },
	                                goodPercent: {
	                                    displayName: 'Good %',
	                                    type: { numeric: true }
	                                },
	                                veryGoodPercent: {
	                                    displayName: 'Very Good %',
	                                    type: { numeric: true },
	                                },
	                                maximumPercent: {
	                                    displayName: 'Maximum %',
	                                    type: { numeric: true }
	                                },
	                            }
	                        },
	                        labels: {
	                            displayName: 'Category labels',
	                            properties: {
	                                show: {
	                                    displayName: createDisplayNameGetter('Visual_Show'),
	                                    type: { bool: true },
	                                },
	                                labelColor: {
	                                    displayName: createDisplayNameGetter('Visual_LabelsFill'),
	                                    description: createDisplayNameGetter('Visual_LabelsFillDescription'),
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                fontSize: {
	                                    displayName: createDisplayNameGetter('Visual_TextSize'),
	                                    type: { formatting: { fontSize: true } },
	                                },
	                            },
	                        },
	                        orientation: {
	                            displayName: 'Orientation',
	                            properties: {
	                                orientation: {
	                                    displayName: 'Orientation',
	                                    type: { enumeration: Orientation.type }
	                                }
	                            }
	                        },
	                        colors: {
	                            displayName: 'Colors',
	                            properties: {
	                                badColor: {
	                                    type: { fill: { solid: { color: true } } },
	                                    displayName: 'Bad Color'
	                                },
	                                needsImprovementColor: {
	                                    type: { fill: { solid: { color: true } } },
	                                    displayName: 'Needs Improvement Color',
	                                },
	                                satisfactoryColor: {
	                                    type: { fill: { solid: { color: true } } },
	                                    displayName: 'Satisfactory Color'
	                                },
	                                goodColor: {
	                                    type: { fill: { solid: { color: true } } },
	                                    displayName: 'Good Color'
	                                },
	                                veryGoodColor: {
	                                    type: { fill: { solid: { color: true } } },
	                                    displayName: 'Very Good Color',
	                                },
	                                bulletColor: {
	                                    type: { fill: { solid: { color: true } } },
	                                    displayName: 'Bullet Color'
	                                }
	                            },
	                        },
	                        axis: {
	                            displayName: 'Axis',
	                            properties: {
	                                axis: {
	                                    displayName: 'Axis',
	                                    type: { bool: true }
	                                },
	                                axisColor: {
	                                    type: { fill: { solid: { color: true } } },
	                                    displayName: 'Axis Color'
	                                },
	                                measureUnits: {
	                                    type: { text: true },
	                                    displayName: 'Measure Units '
	                                },
	                                unitsColor: {
	                                    type: { fill: { solid: { color: true } } },
	                                    displayName: 'Units Color'
	                                },
	                            }
	                        }
	                    },
	                    dataViewMappings: [{
	                            conditions: [
	                                {
	                                    'Category': { max: 1 }, 'Value': { max: 1 }, 'TargetValue': { max: 1 }, 'Minimum': { max: 1 }, 'NeedsImprovement': { max: 1 },
	                                    'Satisfactory': { max: 1 }, 'Good': { max: 1 }, 'VeryGood': { max: 1 }, 'Maximum': { max: 1 }, 'TargetValue2': { max: 1 },
	                                },
	                            ],
	                            categorical: {
	                                categories: {
	                                    for: { in: 'Category' },
	                                    dataReductionAlgorithm: { top: {} }
	                                },
	                                values: {
	                                    select: [
	                                        { bind: { to: 'Value' } },
	                                        { bind: { to: 'TargetValue' } },
	                                        { bind: { to: 'TargetValue2' } },
	                                        { bind: { to: 'Minimum' } },
	                                        { bind: { to: 'NeedsImprovement' } },
	                                        { bind: { to: 'Satisfactory' } },
	                                        { bind: { to: 'Good' } },
	                                        { bind: { to: 'VeryGood' } },
	                                        { bind: { to: 'Maximum' } },
	                                    ]
	                                },
	                            },
	                        }],
	                    supportsHighlight: true,
	                    sorting: {
	                        default: {},
	                    },
	                    drilldown: {
	                        roles: ['Category']
	                    }
	                };
	                return BulletChart;
	            }());
	            samples.BulletChart = BulletChart;
	            //TODO: This module should be removed once TextMeasruementService exports the "estimateSvgTextBaselineDelta" function.
	            var TextMeasurementHelper;
	            (function (TextMeasurementHelper) {
	                var spanElement;
	                var svgTextElement;
	                var canvasCtx;
	                function estimateSvgTextBaselineDelta(textProperties) {
	                    var rect = estimateSvgTextRect(textProperties);
	                    return rect.y + rect.height;
	                }
	                TextMeasurementHelper.estimateSvgTextBaselineDelta = estimateSvgTextBaselineDelta;
	                function ensureDOM() {
	                    if (spanElement)
	                        return;
	                    spanElement = $('<span/>');
	                    $('body').append(spanElement);
	                    //The style hides the svg element from the canvas, preventing canvas from scrolling down to show svg black square.
	                    svgTextElement = d3.select($('body').get(0))
	                        .append('svg')
	                        .style({
	                        'height': '0px',
	                        'width': '0px',
	                        'position': 'absolute'
	                    })
	                        .append('text');
	                    canvasCtx = $('<canvas/>').get(0).getContext("2d");
	                }
	                function measureSvgTextRect(textProperties) {
	                    debug.assertValue(textProperties, 'textProperties');
	                    ensureDOM();
	                    svgTextElement.style(null);
	                    svgTextElement
	                        .text(textProperties.text)
	                        .attr({
	                        'visibility': 'hidden',
	                        'font-family': textProperties.fontFamily,
	                        'font-size': textProperties.fontSize,
	                        'font-weight': textProperties.fontWeight,
	                        'font-style': textProperties.fontStyle,
	                        'white-space': textProperties.whiteSpace || 'nowrap'
	                    });
	                    // We're expecting the browser to give a synchronous measurement here
	                    // We're using SVGTextElement because it works across all browsers 
	                    return svgTextElement.node().getBBox();
	                }
	                function estimateSvgTextRect(textProperties) {
	                    debug.assertValue(textProperties, 'textProperties');
	                    var estimatedTextProperties = {
	                        fontFamily: textProperties.fontFamily,
	                        fontSize: textProperties.fontSize,
	                        text: "M",
	                    };
	                    var rect = measureSvgTextRect(estimatedTextProperties);
	                    return rect;
	                }
	            })(TextMeasurementHelper = samples.TextMeasurementHelper || (samples.TextMeasurementHelper = {}));
	            var BulletWebBehavior = (function () {
	                function BulletWebBehavior() {
	                }
	                BulletWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
	                    this.options = options;
	                    var clearCatcher = options.clearCatcher;
	                    options.valueRects.on('click', function (d, i) {
	                        d3.event.stopPropagation();
	                        selectionHandler.handleSelection(d, d3.event.ctrlKey);
	                    });
	                    options.rects.on('click', function (d, i) {
	                        d3.event.stopPropagation();
	                        selectionHandler.handleSelection(d, d3.event.ctrlKey);
	                    });
	                    clearCatcher.on('click', function () {
	                        selectionHandler.handleClearSelection();
	                    });
	                };
	                BulletWebBehavior.prototype.renderSelection = function (hasSelection) {
	                    var options = this.options;
	                    var hasHighlights = options.hasHighlights;
	                    options.valueRects.style("opacity", function (d) {
	                        return bulletChartUtils.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights);
	                    });
	                    options.rects.style("opacity", function (d) {
	                        return bulletChartUtils.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights);
	                    });
	                };
	                return BulletWebBehavior;
	            }());
	            samples.BulletWebBehavior = BulletWebBehavior;
	            var bulletChartUtils;
	            (function (bulletChartUtils) {
	                bulletChartUtils.DimmedOpacity = 0.4;
	                bulletChartUtils.DefaultOpacity = 1.0;
	                function getFillOpacity(selected, highlight, hasSelection, hasPartialHighlights) {
	                    if ((hasPartialHighlights && !highlight) || (hasSelection && !selected))
	                        return bulletChartUtils.DimmedOpacity;
	                    return bulletChartUtils.DefaultOpacity;
	                }
	                bulletChartUtils.getFillOpacity = getFillOpacity;
	            })(bulletChartUtils = samples.bulletChartUtils || (samples.bulletChartUtils = {}));
	        })(samples = visuals.samples || (visuals.samples = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 43 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	// Word cloud layout by Jason Davies, https://www.jasondavies.com/wordcloud/ https://github.com/jasondavies/d3-cloud
	// Algorithm due to Jonathan Feinberg, http://static.mrfeinberg.com/bv_ch03.pdf
	/// <reference path="../../../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var samples;
	        (function (samples) {
	            var ValueFormatter = powerbi.visuals.valueFormatter;
	            var getAnimationDuration = visuals.AnimatorCommon.GetAnimationDuration;
	            (function (WordCloudScaleType) {
	                WordCloudScaleType[WordCloudScaleType["logn"] = 0] = "logn";
	                WordCloudScaleType[WordCloudScaleType["sqrt"] = 1] = "sqrt";
	                WordCloudScaleType[WordCloudScaleType["value"] = 2] = "value";
	            })(samples.WordCloudScaleType || (samples.WordCloudScaleType = {}));
	            var WordCloudScaleType = samples.WordCloudScaleType;
	            ;
	            var CustomSelectionManager = (function () {
	                function CustomSelectionManager(hostServices) {
	                    this.selectionIdsValue = [];
	                    this.hostServices = hostServices;
	                }
	                Object.defineProperty(CustomSelectionManager.prototype, "selectionIds", {
	                    get: function () {
	                        return this.selectionIdsValue;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(CustomSelectionManager.prototype, "hasSelection", {
	                    get: function () {
	                        return this.selectionIds.length > 0;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                CustomSelectionManager.prototype.selectAndSendSelection = function (selectionId, multiSelect) {
	                    if (multiSelect === void 0) { multiSelect = false; }
	                    var selectionIds = (_.isArray(selectionId) ? selectionId : [selectionId]);
	                    if (this.hostServices.shouldRetainSelection()) {
	                        return this.sendSelectionToHost(selectionIds);
	                    }
	                    else {
	                        this.selectInternal(selectionIds, multiSelect);
	                        return this.sendSelection();
	                    }
	                };
	                CustomSelectionManager.prototype.select = function (selectionId, multiSelect) {
	                    if (multiSelect === void 0) { multiSelect = false; }
	                    var selectionIds = (_.isArray(selectionId) ? selectionId : [selectionId]);
	                    this.selectInternal(selectionIds, multiSelect);
	                };
	                CustomSelectionManager.prototype.isSelected = function (selectionId) {
	                    var _this = this;
	                    var selectionIds = (_.isArray(selectionId) ? selectionId : [selectionId]);
	                    return selectionIds.every(function (x) { return visuals.utility.SelectionManager.containsSelection(_this.selectionIds, x); });
	                };
	                CustomSelectionManager.prototype.sendSelection = function () {
	                    return this.sendSelectionToHost(this.selectionIds);
	                };
	                CustomSelectionManager.prototype.clear = function (sendToHost) {
	                    if (sendToHost === void 0) { sendToHost = true; }
	                    this.selectionIds.length = 0;
	                    if (sendToHost) {
	                        return this.sendSelection();
	                    }
	                    return $.Deferred().resolve();
	                };
	                CustomSelectionManager.prototype.selectInternal = function (selectionIds, multiSelect) {
	                    var _this = this;
	                    var resultSelectionIds = [];
	                    if (selectionIds.every(function (x) { return _this.isSelected(x); })) {
	                        resultSelectionIds = multiSelect
	                            ? this.selectionIds.filter(function (x) { return !visuals.utility.SelectionManager.containsSelection(selectionIds, x); })
	                            : this.selectionIds.length === selectionIds.length ? [] : selectionIds;
	                    }
	                    else {
	                        resultSelectionIds = multiSelect
	                            ? selectionIds.filter(function (x) { return !_this.isSelected(x); }).concat(this.selectionIds)
	                            : selectionIds;
	                    }
	                    this.selectionIds.length = 0;
	                    resultSelectionIds.forEach(function (x) { return _this.selectionIds.push(x); });
	                };
	                CustomSelectionManager.prototype.sendSelectionToHost = function (ids) {
	                    var deferred = $.Deferred();
	                    var selectArgs = {
	                        visualObjects: _.chain(ids)
	                            .filter(function (value) { return value.hasIdentity(); })
	                            .map(function (value) {
	                            return {
	                                objectName: undefined,
	                                selectorsByColumn: value.getSelectorsByColumn(),
	                            };
	                        })
	                            .value(),
	                    };
	                    this.hostServices.onSelect(selectArgs);
	                    deferred.resolve(this.selectionIds);
	                    return deferred;
	                };
	                return CustomSelectionManager;
	            }());
	            var VisualLayout = (function () {
	                function VisualLayout(defaultViewport, defaultMargin) {
	                    this.defaultViewport = defaultViewport || { width: 0, height: 0 };
	                    this.defaultMargin = defaultMargin || { top: 0, bottom: 0, right: 0, left: 0 };
	                }
	                Object.defineProperty(VisualLayout.prototype, "viewport", {
	                    get: function () {
	                        return this.viewportValue || (this.viewportValue = this.defaultViewport);
	                    },
	                    set: function (value) {
	                        var _this = this;
	                        this.previousOriginalViewportValue = _.clone(this.originalViewportValue);
	                        this.originalViewportValue = _.clone(value);
	                        this.setUpdateObject(value, function (v) { return _this.viewportValue = v; }, function (o) { return VisualLayout.restrictToMinMax(o, _this.minViewport); });
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(VisualLayout.prototype, "viewportCopy", {
	                    get: function () {
	                        return _.clone(this.viewport);
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(VisualLayout.prototype, "viewportIn", {
	                    //Returns viewport minus margin
	                    get: function () {
	                        return this.viewportInValue || this.viewport;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(VisualLayout.prototype, "minViewport", {
	                    get: function () {
	                        return this.minViewportValue || { width: 0, height: 0 };
	                    },
	                    set: function (value) {
	                        var _this = this;
	                        this.setUpdateObject(value, function (v) { return _this.minViewportValue = v; }, VisualLayout.restrictToMinMax);
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(VisualLayout.prototype, "margin", {
	                    get: function () {
	                        return this.marginValue || (this.marginValue = this.defaultMargin);
	                    },
	                    set: function (value) {
	                        var _this = this;
	                        this.setUpdateObject(value, function (v) { return _this.marginValue = v; }, VisualLayout.restrictToMinMax);
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(VisualLayout.prototype, "viewportChanged", {
	                    //Returns true if viewport has updated after last change.
	                    get: function () {
	                        return !!this.originalViewportValue && (!this.previousOriginalViewportValue
	                            || this.previousOriginalViewportValue.height !== this.originalViewportValue.height
	                            || this.previousOriginalViewportValue.width !== this.originalViewportValue.width);
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(VisualLayout.prototype, "viewportInIsZero", {
	                    get: function () {
	                        return this.viewportIn.width === 0 || this.viewportIn.height === 0;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                VisualLayout.prototype.resetMargin = function () {
	                    this.margin = this.defaultMargin;
	                };
	                VisualLayout.prototype.update = function () {
	                    this.viewportInValue = VisualLayout.restrictToMinMax({
	                        width: this.viewport.width - (this.margin.left + this.margin.right),
	                        height: this.viewport.height - (this.margin.top + this.margin.bottom)
	                    }, this.minViewportValue);
	                };
	                VisualLayout.prototype.setUpdateObject = function (object, setObjectFn, beforeUpdateFn) {
	                    var _this = this;
	                    object = _.clone(object);
	                    setObjectFn(VisualLayout.createNotifyChangedObject(object, function (o) {
	                        if (beforeUpdateFn)
	                            beforeUpdateFn(object);
	                        _this.update();
	                    }));
	                    if (beforeUpdateFn)
	                        beforeUpdateFn(object);
	                    this.update();
	                };
	                VisualLayout.createNotifyChangedObject = function (object, objectChanged) {
	                    var result = {};
	                    _.keys(object).forEach(function (key) { return Object.defineProperty(result, key, {
	                        get: function () { return object[key]; },
	                        set: function (value) { object[key] = value; objectChanged(object, key); },
	                        enumerable: true,
	                        configurable: true
	                    }); });
	                    return result;
	                };
	                VisualLayout.restrictToMinMax = function (value, minValue) {
	                    _.keys(value).forEach(function (x) { return value[x] = Math.max(minValue && minValue[x] || 0, value[x]); });
	                    return value;
	                };
	                return VisualLayout;
	            }());
	            var WordCloudSettings = (function () {
	                function WordCloudSettings() {
	                    //Default Settings
	                    this.general = {
	                        maxNumberOfWords: 200,
	                        minFontSize: 20 / WordCloud.FontSizePercentageCoefficent,
	                        maxFontSize: 100 / WordCloud.FontSizePercentageCoefficent,
	                        isBrokenText: true
	                    };
	                    this.stopWords = {
	                        show: true,
	                        isDefaultStopWords: false,
	                        words: null
	                    };
	                    this.rotateText = {
	                        show: true,
	                        minAngle: -60,
	                        maxAngle: 90,
	                        maxNumberOfOrientations: 2
	                    };
	                }
	                Object.defineProperty(WordCloudSettings, "Default", {
	                    get: function () {
	                        return new this();
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                WordCloudSettings.parse = function (dataView, capabilities) {
	                    var settings = new this();
	                    if (!dataView || !dataView.metadata || !dataView.metadata.objects) {
	                        return settings;
	                    }
	                    var properties = this.getProperties(capabilities);
	                    for (var objectKey in capabilities.objects) {
	                        for (var propKey in capabilities.objects[objectKey].properties) {
	                            if (!settings[objectKey] || !_.has(settings[objectKey], propKey)) {
	                                continue;
	                            }
	                            var type = capabilities.objects[objectKey].properties[propKey].type;
	                            var getValueFn = this.getValueFnByType(type);
	                            settings[objectKey][propKey] = getValueFn(dataView.metadata.objects, properties[objectKey][propKey], settings[objectKey][propKey]);
	                        }
	                    }
	                    return settings;
	                };
	                WordCloudSettings.getProperties = function (capabilities) {
	                    var objects = _.merge({
	                        general: { properties: { formatString: {} } }
	                    }, capabilities.objects);
	                    var properties = {};
	                    for (var objectKey in objects) {
	                        properties[objectKey] = {};
	                        for (var propKey in objects[objectKey].properties) {
	                            properties[objectKey][propKey] = {
	                                objectName: objectKey,
	                                propertyName: propKey
	                            };
	                        }
	                    }
	                    return properties;
	                };
	                WordCloudSettings.createEnumTypeFromEnum = function (type) {
	                    var even = false;
	                    return powerbi.createEnumType(Object.keys(type)
	                        .filter(function (key, i) { return ((!!(i % 2)) === even && type[key] === key
	                        && !void (even = !even)) || (!!(i % 2)) !== even; })
	                        .map(function (x) { return { value: x, displayName: x }; }));
	                };
	                WordCloudSettings.getValueFnByType = function (type) {
	                    switch (_.keys(type)[0]) {
	                        case "fill":
	                            return powerbi.DataViewObjects.getFillColor;
	                        default:
	                            return powerbi.DataViewObjects.getValue;
	                    }
	                };
	                WordCloudSettings.enumerateObjectInstances = function (settings, options, capabilities) {
	                    if (settings === void 0) { settings = new this(); }
	                    var enumeration = new visuals.ObjectEnumerationBuilder();
	                    var object = settings && settings[options.objectName];
	                    if (!object) {
	                        return enumeration;
	                    }
	                    var instance = {
	                        objectName: options.objectName,
	                        selector: null,
	                        properties: {}
	                    };
	                    for (var key in object) {
	                        if (_.has(object, key)) {
	                            instance.properties[key] = object[key];
	                        }
	                    }
	                    enumeration.pushInstance(instance);
	                    return enumeration;
	                };
	                WordCloudSettings.prototype.createOriginalSettings = function () {
	                    this.originalSettings = _.cloneDeep(this);
	                };
	                return WordCloudSettings;
	            }());
	            samples.WordCloudSettings = WordCloudSettings;
	            var WordCloudColumns = (function () {
	                function WordCloudColumns() {
	                    //Data Roles
	                    this.Category = null;
	                    this.Values = null;
	                }
	                WordCloudColumns.getColumnSources = function (dataView) {
	                    return this.getColumnSourcesT(dataView);
	                };
	                WordCloudColumns.getTableValues = function (dataView) {
	                    var table = dataView && dataView.table;
	                    var columns = this.getColumnSourcesT(dataView);
	                    return columns && table && _.mapValues(columns, function (n, i) { return n && table.rows.map(function (row) { return row[n.index]; }); });
	                };
	                WordCloudColumns.getTableRows = function (dataView) {
	                    var table = dataView && dataView.table;
	                    var columns = this.getColumnSourcesT(dataView);
	                    return columns && table && table.rows.map(function (row) {
	                        return _.mapValues(columns, function (n, i) { return n && row[n.index]; });
	                    });
	                };
	                WordCloudColumns.getCategoricalValues = function (dataView) {
	                    var categorical = dataView && dataView.categorical;
	                    var categories = categorical && categorical.categories || [];
	                    var values = categorical && categorical.values || [];
	                    var series = categorical && values.source && this.getSeriesValues(dataView);
	                    return categorical && _.mapValues(new this(), function (n, i) {
	                        return _.toArray(categories).concat(_.toArray(values))
	                            .filter(function (x) { return x.source.roles && x.source.roles[i]; }).map(function (x) { return x.values; })[0]
	                            || values.source && values.source.roles && values.source.roles[i] && series;
	                    });
	                };
	                WordCloudColumns.getSeriesValues = function (dataView) {
	                    return dataView && dataView.categorical && dataView.categorical.values
	                        && dataView.categorical.values.map(function (x) { return visuals.converterHelper.getSeriesName(x.source); });
	                };
	                WordCloudColumns.getCategoricalColumns = function (dataView) {
	                    var categorical = dataView && dataView.categorical;
	                    var categories = categorical && categorical.categories || [];
	                    var values = categorical && categorical.values || [];
	                    return categorical && _.mapValues(new this(), function (n, i) { return categories.filter(function (x) { return x.source.roles && x.source.roles[i]; })[0]
	                        || values.source && values.source.roles && values.source.roles[i]
	                        || values.filter(function (x) { return x.source.roles && x.source.roles[i]; }); });
	                };
	                WordCloudColumns.getColumnSourcesT = function (dataView) {
	                    var columns = dataView && dataView.metadata && dataView.metadata.columns;
	                    return columns && _.mapValues(new this(), function (n, i) { return columns.filter(function (x) { return x.roles && x.roles[i]; })[0]; });
	                };
	                WordCloudColumns.Roles = Object.freeze(_.mapValues(new WordCloudColumns(), function (x, i) { return i; }));
	                return WordCloudColumns;
	            }());
	            samples.WordCloudColumns = WordCloudColumns;
	            var WordCloud = (function () {
	                function WordCloud(options) {
	                    this.durationAnimations = 500;
	                    this.fakeViewport = {
	                        width: 1500,
	                        height: 1000
	                    };
	                    this.canvasViewport = {
	                        width: 128,
	                        height: 2048
	                    };
	                    if (options) {
	                        this.svg = options.svg || this.svg;
	                        this.layout = new VisualLayout(null, options.margin || WordCloud.DefaultMargin);
	                        if (options.animator)
	                            this.animator = options.animator;
	                    }
	                    this.isUpdating = false;
	                }
	                WordCloud.converter = function (dataView, colors, previousData) {
	                    var categorical = WordCloudColumns.getCategoricalColumns(dataView);
	                    if (!categorical || !categorical.Category || _.isEmpty(categorical.Category.values)) {
	                        return null;
	                    }
	                    var catValues = WordCloudColumns.getCategoricalValues(dataView);
	                    var properties = WordCloudSettings.getProperties(WordCloud.capabilities);
	                    var settings = WordCloud.parseSettings(dataView, previousData && previousData.settings);
	                    var wordValueFormatter = ValueFormatter.create({
	                        format: ValueFormatter.getFormatString(categorical.Category.source, properties.general.formatString),
	                        value: catValues.Category[0]
	                    });
	                    var stopWords = _.isString(settings.stopWords.words) ? settings.stopWords.words.split(WordCloud.StopWordsDelemiter) : [];
	                    stopWords = settings.stopWords.isDefaultStopWords ? stopWords.concat(WordCloud.StopWords) : stopWords;
	                    var colorHelper = new visuals.ColorHelper(colors, properties.dataPoint.fill, explore.util.getRandomColor());
	                    var texts = catValues.Category.map(function (item, index) {
	                        var color;
	                        if (categorical.Category.objects && categorical.Category.objects[index]) {
	                            color = explore.util.hexToRgb(colorHelper.getColorForMeasure(categorical.Category.objects[index], ""));
	                        }
	                        else {
	                            color = previousData && previousData.texts && previousData.texts[index]
	                                ? previousData.texts[index].color
	                                : explore.util.getRandomColor();
	                        }
	                        var selectionId = new visuals.SelectionIdBuilder()
	                            .withCategory(dataView.categorical.categories[0], index)
	                            .createSelectionId();
	                        return {
	                            text: item,
	                            count: (catValues.Values && catValues.Values[index] && !isNaN(catValues.Values[index])) ? catValues.Values[index] : 1,
	                            index: index,
	                            selectionId: selectionId,
	                            color: color,
	                            textGroup: item
	                        };
	                    });
	                    var reducedTexts = WordCloud.getReducedText(texts, stopWords, settings);
	                    var dataPoints = WordCloud.getDataPoints(reducedTexts, settings, wordValueFormatter);
	                    return {
	                        dataView: dataView,
	                        settings: settings,
	                        texts: texts,
	                        dataPoints: dataPoints
	                    };
	                };
	                WordCloud.parseSettings = function (dataView, previousSettings) {
	                    var settings = WordCloudSettings.parse(dataView, WordCloud.capabilities);
	                    settings.general.minFontSize = Math.max(settings.general.minFontSize, 1);
	                    settings.general.maxFontSize = Math.max(settings.general.maxFontSize, 1);
	                    settings.general.maxFontSize = Math.max(settings.general.maxFontSize, settings.general.minFontSize);
	                    settings.rotateText.minAngle = Math.max(Math.min(settings.rotateText.minAngle, WordCloud.MaxAngle), WordCloud.MinAngle);
	                    settings.rotateText.maxAngle = Math.max(Math.min(settings.rotateText.maxAngle, WordCloud.MaxAngle), WordCloud.MinAngle);
	                    settings.rotateText.maxAngle = Math.max(settings.rotateText.maxAngle, settings.rotateText.minAngle);
	                    settings.general.maxNumberOfWords = Math.max(Math.min(settings.general.maxNumberOfWords, WordCloud.MaxNumberOfWords), 1);
	                    settings.rotateText.maxNumberOfOrientations = Math.max(Math.min(settings.rotateText.maxNumberOfOrientations, WordCloud.MaxNumberOfWords), 1);
	                    settings.createOriginalSettings();
	                    return settings;
	                };
	                WordCloud.getReducedText = function (texts, stopWords, settings) {
	                    var brokenStrings = WordCloud.getBrokenWords(texts, stopWords, settings);
	                    var result = _.values(_.groupBy(brokenStrings, function (x) { return x.text; }));
	                    result = result.map(function (texts) { return _.sortBy(texts, function (x) { return x.textGroup.length; }); });
	                    return result;
	                };
	                WordCloud.getBrokenWords = function (words, stopWords, settings) {
	                    var brokenStrings = [];
	                    var whiteSpaceRegExp = /\s/;
	                    var punctuatuinRegExp = new RegExp("[" + WordCloud.Punctuation.join("\\") + "]", "gim");
	                    if (!settings.general.isBrokenText) {
	                        return words;
	                    }
	                    words.forEach(function (item) {
	                        if (typeof item.text === "string") {
	                            var words = item.text.replace(punctuatuinRegExp, " ").split(whiteSpaceRegExp);
	                            if (settings.stopWords.show) {
	                                words = words.filter(function (value) {
	                                    return value.length > 0 && !stopWords.some(function (removeWord) {
	                                        return value.toLocaleLowerCase() === removeWord.toLocaleLowerCase();
	                                    });
	                                });
	                            }
	                            words.forEach(function (element) {
	                                if (element.length > 0 && !whiteSpaceRegExp.test(element)) {
	                                    brokenStrings.push({
	                                        text: element,
	                                        textGroup: item.textGroup,
	                                        count: item.count,
	                                        index: item.index,
	                                        selectionId: item.selectionId,
	                                        color: item.color
	                                    });
	                                }
	                            });
	                        }
	                        else {
	                            brokenStrings.push(item);
	                        }
	                    });
	                    return brokenStrings;
	                };
	                WordCloud.getDataPoints = function (textGroups, settings, wordValueFormatter) {
	                    if (_.isEmpty(textGroups)) {
	                        return [];
	                    }
	                    var returnValues = textGroups.map(function (values) {
	                        return {
	                            text: wordValueFormatter.format(values[0].text),
	                            x: 0,
	                            y: 0,
	                            rotate: WordCloud.getAngle(settings),
	                            padding: 1,
	                            width: 0,
	                            height: 0,
	                            xOff: 0,
	                            yOff: 0,
	                            x0: 0,
	                            y0: 0,
	                            x1: 0,
	                            y1: 0,
	                            color: values[0].color,
	                            selectionIds: values.map(function (x) { return x.selectionId; }),
	                            wordIndex: values[0].index,
	                            count: _.sum(values, function (x) { return x.count; })
	                        };
	                    });
	                    var minValue = _.min(returnValues, function (x) { return x.count; }).count;
	                    var maxValue = _.max(returnValues, function (x) { return x.count; }).count;
	                    var texts = textGroups.map(function (x) { return x[0]; });
	                    returnValues.forEach(function (x) { return x.size = WordCloud.getWordFontSize(texts, settings, x.count, minValue, maxValue); });
	                    return returnValues.sort(function (a, b) { return b.count - a.count; });
	                };
	                WordCloud.getWordFontSize = function (texts, settings, value, minValue, maxValue, scaleType) {
	                    if (scaleType === void 0) { scaleType = WordCloudScaleType.value; }
	                    var weight, fontSize;
	                    var minFontSize = settings.general.minFontSize * WordCloud.FontSizePercentageCoefficent;
	                    var maxFontSize = settings.general.maxFontSize * WordCloud.FontSizePercentageCoefficent;
	                    if (texts.length < 2) {
	                        return maxFontSize;
	                    }
	                    switch (scaleType) {
	                        case WordCloudScaleType.logn: {
	                            weight = Math.log(value);
	                        }
	                        case WordCloudScaleType.sqrt: {
	                            weight = Math.sqrt(value);
	                        }
	                        case WordCloudScaleType.value: {
	                            weight = value;
	                        }
	                    }
	                    if (weight > minValue) {
	                        fontSize = (maxValue - minValue) !== 0
	                            ? (maxFontSize * (weight - minValue)) / (maxValue - minValue)
	                            : 0;
	                    }
	                    else {
	                        fontSize = 0;
	                    }
	                    fontSize = (fontSize * 100) / maxFontSize;
	                    fontSize = (fontSize * (maxFontSize - minFontSize)) / 100 + minFontSize;
	                    return fontSize;
	                };
	                WordCloud.getAngle = function (settings) {
	                    if (!settings.rotateText.show) {
	                        return 0;
	                    }
	                    var angle = ((settings.rotateText.maxAngle - settings.rotateText.minAngle)
	                        / settings.rotateText.maxNumberOfOrientations)
	                        * Math.floor(Math.random() * settings.rotateText.maxNumberOfOrientations);
	                    return settings.rotateText.minAngle + angle;
	                };
	                Object.defineProperty(WordCloud.prototype, "settings", {
	                    get: function () {
	                        return this.data && this.data.settings;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                WordCloud.prototype.init = function (options) {
	                    var _this = this;
	                    if (this.svg) {
	                        this.root = this.svg;
	                    }
	                    else {
	                        this.root = d3.select(options.element.get(0)).append("svg");
	                    }
	                    this.colors = options.style.colorPalette.dataColors;
	                    this.hostService = options.host;
	                    this.selectionManager = new CustomSelectionManager(this.hostService);
	                    this.layout = new VisualLayout(null, WordCloud.DefaultMargin);
	                    this.root.classed(WordCloud.ClassName, true);
	                    this.root.on("click", function () {
	                        _this.setSelection(null);
	                    });
	                    this.fontFamily = this.root.style("font-family");
	                    this.main = this.root.append("g");
	                    this.wordsContainerSelection = this.main
	                        .append("g")
	                        .classed(WordCloud.Words["class"], true);
	                    this.canvas = document.createElement("canvas");
	                };
	                WordCloud.prototype.update = function (visualUpdateOptions) {
	                    var _this = this;
	                    if (!visualUpdateOptions ||
	                        !visualUpdateOptions.viewport ||
	                        !visualUpdateOptions.dataViews ||
	                        !visualUpdateOptions.dataViews[0] ||
	                        !visualUpdateOptions.viewport ||
	                        !(visualUpdateOptions.viewport.height >= 0) ||
	                        !(visualUpdateOptions.viewport.width >= 0))
	                        return;
	                    if (visualUpdateOptions !== this.visualUpdateOptions) {
	                        this.incomingUpdateOptions = visualUpdateOptions;
	                    }
	                    if (!this.isUpdating && (this.incomingUpdateOptions !== this.visualUpdateOptions)) {
	                        this.visualUpdateOptions = this.incomingUpdateOptions;
	                        this.layout.viewport = this.visualUpdateOptions.viewport;
	                        var dataView = visualUpdateOptions.dataViews[0];
	                        if (this.layout.viewportInIsZero) {
	                            return;
	                        }
	                        this.durationAnimations = getAnimationDuration(this.animator, visualUpdateOptions.suppressAnimations);
	                        this.UpdateSize();
	                        var data = WordCloud.converter(dataView, this.colors, this.data);
	                        if (!data) {
	                            //ClearVisual?
	                            return;
	                        }
	                        this.data = data;
	                        this.computePositions(function (wordCloudDataView) { return _this.render(wordCloudDataView); });
	                    }
	                };
	                WordCloud.prototype.computePositions = function (onPositionsComputed) {
	                    var _this = this;
	                    var words = this.data.dataPoints;
	                    if (_.isEmpty(words)) {
	                        return null;
	                    }
	                    requestAnimationFrame(function () {
	                        var surface = _.range(0, (_this.specialViewport.width >> 5) * _this.specialViewport.height, 0);
	                        if (words.length > _this.settings.general.maxNumberOfWords) {
	                            words = words.slice(0, _this.settings.general.maxNumberOfWords);
	                        }
	                        words.forEach(function (data) {
	                            data.widthOfWord = powerbi.TextMeasurementService.measureSvgTextWidth({
	                                fontFamily: _this.fontFamily,
	                                fontSize: (data.size + 1) + WordCloud.Size,
	                                //fontWeight: "normal",
	                                //fontStyle: "normal",
	                                text: data.text
	                            }) + 2;
	                        });
	                        _this.computeCycle(words, _this.getCanvasContext(), surface, null, onPositionsComputed, [], 0);
	                    });
	                };
	                WordCloud.prototype.computeCycle = function (words, context, surface, borders, onPositionsComputed, wordsForDraw, index) {
	                    if (wordsForDraw === void 0) { wordsForDraw = []; }
	                    if (index === void 0) { index = 0; }
	                    var word = words[index], ratio = 1;
	                    if (words.length <= 10)
	                        ratio = 5;
	                    else if (words.length <= 25)
	                        ratio = 3;
	                    else if (words.length <= 75)
	                        ratio = 1.5;
	                    else if (words.length <= 100)
	                        ratio = 1.25;
	                    word.x = (this.specialViewport.width / ratio * (Math.random() + 0.5)) >> 1;
	                    word.y = (this.specialViewport.height / ratio * (Math.random() + 0.5)) >> 1;
	                    if (!word.sprite) {
	                        this.generateSprites(context, words, index);
	                    }
	                    if (word.sprite && this.findPosition(surface, word, borders)) {
	                        wordsForDraw.push(word);
	                        borders = this.updateBorders(word, borders);
	                        word.x -= this.specialViewport.width >> 1;
	                        word.y -= this.specialViewport.height >> 1;
	                    }
	                    if (++index < words.length && this.root) {
	                        this.computeCycle(words, context, surface, borders, onPositionsComputed, wordsForDraw, index);
	                    }
	                    else {
	                        onPositionsComputed({
	                            data: wordsForDraw,
	                            leftBorder: borders && borders[0],
	                            rightBorder: borders && borders[1]
	                        });
	                    }
	                };
	                WordCloud.prototype.updateBorders = function (word, borders) {
	                    if (borders && borders.length === 2) {
	                        var leftBorder = borders[0], rightBorder = borders[1];
	                        if (word.x + word.x0 < leftBorder.x)
	                            leftBorder.x = word.x + word.x0;
	                        if (word.y + word.y0 < leftBorder.y)
	                            leftBorder.y = word.y + word.y0;
	                        if (word.x + word.x1 > rightBorder.x)
	                            rightBorder.x = word.x + word.x1;
	                        if (word.y + word.y1 > rightBorder.y)
	                            rightBorder.y = word.y + word.y1;
	                    }
	                    else {
	                        borders = [
	                            {
	                                x: word.x + word.x0,
	                                y: word.y + word.y0
	                            }, {
	                                x: word.x + word.x1,
	                                y: word.y + word.y1
	                            }
	                        ];
	                    }
	                    return borders;
	                };
	                WordCloud.prototype.generateSprites = function (context, words, startIndex) {
	                    context.clearRect(0, 0, this.canvasViewport.width << 5, this.canvasViewport.height);
	                    var x = 0, y = 0, maxHeight = 0;
	                    for (var i = startIndex, length = words.length; i < length; i++) {
	                        var currentWordData = words[i];
	                        var widthOfWord = currentWordData.widthOfWord;
	                        var heightOfWord = currentWordData.size << 1;
	                        if (currentWordData.rotate) {
	                            var sr = Math.sin(currentWordData.rotate * WordCloud.Radians), cr = Math.cos(currentWordData.rotate * WordCloud.Radians), widthCr = widthOfWord * cr, widthSr = widthOfWord * sr, heightCr = heightOfWord * cr, heightSr = heightOfWord * sr;
	                            widthOfWord = (Math.max(Math.abs(widthCr + heightSr), Math.abs(widthCr - heightSr)) + 31) >> 5 << 5;
	                            heightOfWord = Math.floor(Math.max(Math.abs(widthSr + heightCr), Math.abs(widthSr - heightCr)));
	                        }
	                        else {
	                            widthOfWord = (widthOfWord + 31) >> 5 << 5;
	                        }
	                        if (heightOfWord > maxHeight) {
	                            maxHeight = heightOfWord;
	                        }
	                        if (x + widthOfWord >= (this.canvasViewport.width << 5)) {
	                            x = 0;
	                            y += maxHeight;
	                            maxHeight = 0;
	                        }
	                        context.save();
	                        context.font = "normal normal " + (currentWordData.size + 1) + WordCloud.Size + " " + this.fontFamily;
	                        context.translate((x + (widthOfWord >> 1)), (y + (heightOfWord >> 1)));
	                        if (currentWordData.rotate) {
	                            context.rotate(currentWordData.rotate * WordCloud.Radians);
	                        }
	                        context.fillText(currentWordData.text, 0, 0);
	                        if (currentWordData.padding) {
	                            context.lineWidth = 2 * currentWordData.padding;
	                            context.strokeText(currentWordData.text, 0, 0);
	                        }
	                        context.restore();
	                        currentWordData.width = widthOfWord;
	                        currentWordData.height = heightOfWord;
	                        currentWordData.xOff = x;
	                        currentWordData.yOff = y;
	                        currentWordData.x1 = widthOfWord >> 1;
	                        currentWordData.y1 = heightOfWord >> 1;
	                        currentWordData.x0 = -currentWordData.x1;
	                        currentWordData.y0 = -currentWordData.y1;
	                        x += widthOfWord;
	                    }
	                    this.setSprites(context, words);
	                };
	                WordCloud.prototype.setSprites = function (context, words) {
	                    var pixels = context.getImageData(0, 0, this.canvasViewport.width << 5, this.canvasViewport.height).data;
	                    var sprites = [];
	                    for (var i = words.length - 1; i >= 0; i--) {
	                        var currentWordData = words[i], width = currentWordData.width, width32 = width >> 5, height = currentWordData.y1 - currentWordData.y0, x = 0, y = 0, seen = 0, seenRow = 0;
	                        if (currentWordData.xOff + width >= (this.canvasViewport.width << 5) ||
	                            currentWordData.yOff + height >= this.canvasViewport.height) {
	                            currentWordData.sprite = null;
	                            continue;
	                        }
	                        for (var j = 0; j < height * width32; j++) {
	                            sprites[j] = 0;
	                        }
	                        if (currentWordData.xOff !== null) {
	                            x = currentWordData.xOff;
	                        }
	                        else {
	                            return;
	                        }
	                        y = currentWordData.yOff;
	                        seen = 0;
	                        seenRow = -1;
	                        for (var j = 0; j < height; j++) {
	                            for (var k = 0; k < width; k++) {
	                                var l = width32 * j + (k >> 5);
	                                var index = ((y + j) * (this.canvasViewport.width << 5) + (x + k)) << 2;
	                                var m = pixels[index]
	                                    ? 1 << (31 - (k % 32))
	                                    : 0;
	                                sprites[l] |= m;
	                                seen |= m;
	                            }
	                            if (seen) {
	                                seenRow = j;
	                            }
	                            else {
	                                currentWordData.y0++;
	                                height--;
	                                j--;
	                                y++;
	                            }
	                        }
	                        currentWordData.y1 = currentWordData.y0 + seenRow;
	                        currentWordData.sprite = sprites.slice(0, (currentWordData.y1 - currentWordData.y0) * width32);
	                    }
	                };
	                WordCloud.prototype.findPosition = function (surface, word, borders) {
	                    var startPoint = { x: word.x, y: word.y }, delta = Math.sqrt(this.specialViewport.width * this.specialViewport.width + this.specialViewport.height * this.specialViewport.height), point, dt = Math.random() < 0.5 ? 1 : -1, shift = -dt, dx, dy;
	                    while (true) {
	                        shift += dt;
	                        point = this.archimedeanSpiral(shift);
	                        dx = Math.floor(point.x);
	                        dy = Math.floor(point.y);
	                        if (Math.min(Math.abs(dx), Math.abs(dy)) >= delta) {
	                            break;
	                        }
	                        word.x = startPoint.x + dx;
	                        word.y = startPoint.y + dy;
	                        if (word.x + word.x0 < 0 ||
	                            word.y + word.y0 < 0 ||
	                            word.x + word.x1 > this.specialViewport.width ||
	                            word.y + word.y1 > this.specialViewport.height)
	                            continue;
	                        if (!borders || !this.checkIntersect(word, surface)) {
	                            if (!borders || this.checkIntersectOfRectangles(word, borders[0], borders[1])) {
	                                var sprite = word.sprite, width = word.width >> 5, shiftWidth = this.specialViewport.width >> 5, lx = word.x - (width << 4), sx = lx & 127, msx = 32 - sx, height = word.y1 - word.y0, x = (word.y + word.y0) * shiftWidth + (lx >> 5);
	                                for (var i = 0; i < height; i++) {
	                                    var lastSprite = 0;
	                                    for (var j = 0; j <= width; j++) {
	                                        var leftMask = lastSprite << msx, rightMask;
	                                        if (j < width)
	                                            lastSprite = sprite[i * width + j];
	                                        rightMask = j < width
	                                            ? lastSprite >>> sx
	                                            : 0;
	                                        surface[x + j] |= leftMask | rightMask;
	                                    }
	                                    x += shiftWidth;
	                                }
	                                word.sprite = null;
	                                return true;
	                            }
	                        }
	                    }
	                    return false;
	                };
	                WordCloud.prototype.archimedeanSpiral = function (value) {
	                    var ratio = this.specialViewport.width / this.specialViewport.height;
	                    value = value * 0.1;
	                    return {
	                        x: ratio * value * Math.cos(value),
	                        y: value * Math.sin(value)
	                    };
	                };
	                WordCloud.prototype.checkIntersect = function (word, surface) {
	                    var shiftWidth = this.specialViewport.width >> 5, sprite = word.sprite, widthOfWord = word.width >> 5, lx = word.x - (widthOfWord << 4), sx = lx & 127, msx = 32 - sx, heightOfWord = word.y1 - word.y0, x = (word.y + word.y0) * shiftWidth + (lx >> 5);
	                    for (var i = 0; i < heightOfWord; i++) {
	                        var lastSprite = 0;
	                        for (var j = 0; j <= widthOfWord; j++) {
	                            var mask = 0, leftMask, intersectMask = 0;
	                            leftMask = lastSprite << msx;
	                            if (j < widthOfWord)
	                                lastSprite = sprite[i * widthOfWord + j];
	                            mask = j < widthOfWord
	                                ? lastSprite >>> sx
	                                : 0;
	                            intersectMask = (leftMask | mask) & surface[x + j];
	                            if (intersectMask)
	                                return true;
	                        }
	                        x += shiftWidth;
	                    }
	                    return false;
	                };
	                WordCloud.prototype.checkIntersectOfRectangles = function (word, leftBorder, rightBorder) {
	                    return (word.x + word.x1) > leftBorder.x &&
	                        (word.x + word.x0) < rightBorder.x &&
	                        (word.y + word.y1) > leftBorder.y &&
	                        (word.y + word.y0) < rightBorder.y;
	                };
	                WordCloud.prototype.getCanvasContext = function () {
	                    if (!this.canvasViewport)
	                        return null;
	                    this.canvas.width = 1;
	                    this.canvas.height = 1;
	                    var context = this.canvas.getContext("2d");
	                    this.canvas.width = this.canvasViewport.width << 5;
	                    this.canvas.height = this.canvasViewport.height;
	                    context = this.canvas.getContext("2d");
	                    context.fillStyle = context.strokeStyle = "red";
	                    context.textAlign = "center";
	                    return context;
	                };
	                WordCloud.prototype.UpdateSize = function () {
	                    var fakeWidth, fakeHeight, ratio;
	                    ratio = Math.sqrt((this.fakeViewport.width * this.fakeViewport.height)
	                        / (this.layout.viewportIn.width * this.layout.viewportIn.height));
	                    if (isNaN(ratio)) {
	                        fakeHeight = fakeWidth = 1;
	                    }
	                    else {
	                        fakeHeight = this.layout.viewportIn.height * ratio;
	                        fakeWidth = this.layout.viewportIn.width * ratio;
	                    }
	                    this.specialViewport = {
	                        height: fakeHeight,
	                        width: fakeWidth
	                    };
	                    this.root.attr({
	                        "height": this.layout.viewport.height,
	                        "width": this.layout.viewport.width
	                    });
	                };
	                WordCloud.prototype.render = function (wordCloudDataView) {
	                    var _this = this;
	                    if (!wordCloudDataView || !wordCloudDataView.data) {
	                        return;
	                    }
	                    this.scaleMainView(wordCloudDataView);
	                    this.wordsGroupUpdateSelection = this.main
	                        .select(WordCloud.Words.selector)
	                        .selectAll("g")
	                        .data(wordCloudDataView.data);
	                    var wordGroupEnterSelection = this.wordsGroupUpdateSelection
	                        .enter()
	                        .append("svg:g")
	                        .classed(WordCloud.WordGroup.class, true);
	                    wordGroupEnterSelection
	                        .append("svg:text")
	                        .style("font-size", "1px")
	                        .attr('pointer-events', "none");
	                    wordGroupEnterSelection
	                        .append("svg:rect");
	                    this.wordsGroupUpdateSelection.exit().remove();
	                    this.wordsGroupUpdateSelection
	                        .attr('transform', function (d) { return (visuals.SVGUtil.translate(d.x, d.y) + " rotate(" + d.rotate + ")"); })
	                        .sort(function (a, b) { return b.height * b.width - a.height * a.width; });
	                    this.wordsTextUpdateSelection = this.wordsGroupUpdateSelection.selectAll("text").data(function (d) { return [d]; });
	                    this.wordsTextUpdateSelection.text(function (d) { return d.text; });
	                    this.animation(this.wordsTextUpdateSelection, this.durationAnimations)
	                        .style({
	                        "font-size": (function (item) { return ("" + item.size + WordCloud.Size); }),
	                        "fill": (function (item) { return item.color; }),
	                    });
	                    this.wordsGroupUpdateSelection.selectAll("rect").data(function (d) { return [d]; })
	                        .attr({
	                        x: function (d) { return -d.widthOfWord * 0.5; },
	                        width: function (d) { return d.widthOfWord; },
	                        y: function (d) { return -d.size * 0.75; },
	                        height: function (d) { return d.size * 0.85; },
	                        fill: function (d) { return "rgba(63, 191, 191, 0.0)"; },
	                    })
	                        .on("click", function (d) { _this.setSelection(d); d3.event.stopPropagation(); });
	                    this.renderSelection();
	                    this.isUpdating = false;
	                    if (this.incomingUpdateOptions !== this.visualUpdateOptions) {
	                        this.update(this.incomingUpdateOptions);
	                    }
	                };
	                WordCloud.prototype.setSelection = function (dataPoint) {
	                    var _this = this;
	                    if (!dataPoint) {
	                        this.selectionManager.clear().then(function () { return _this.renderSelection(); });
	                        return;
	                    }
	                    var selectionIds = dataPoint.selectionIds;
	                    if (this.selectionManager.isSelected(selectionIds) && d3.event.ctrlKey) {
	                        var dataPoints = this.wordsGroupUpdateSelection.data()
	                            .filter(function (d) { return d.text !== dataPoint.text; });
	                        selectionIds = selectionIds.filter(function (x) { return !dataPoints.some(function (d) {
	                            return _this.selectionManager.isSelected(d.selectionIds)
	                                && visuals.utility.SelectionManager.containsSelection(d.selectionIds, x);
	                        }); });
	                    }
	                    this.selectionManager.selectAndSendSelection(selectionIds, d3.event.ctrlKey);
	                    this.renderSelection();
	                };
	                WordCloud.prototype.scaleMainView = function (wordCloudDataView) {
	                    var rectangles = wordCloudDataView.data.map(function (d) {
	                        var hw = d.width / 2;
	                        var hh = d.height / 2;
	                        return { left: d.x - hw, top: d.y - hh, right: d.x + hw, bottom: d.y + hh };
	                    });
	                    var rectangle = {
	                        left: _.min(rectangles, function (x) { return x.left; }).left,
	                        top: _.min(rectangles, function (x) { return x.top; }).top,
	                        right: _.max(rectangles, function (x) { return x.right; }).right,
	                        bottom: _.max(rectangles, function (x) { return x.bottom; }).bottom
	                    };
	                    rectangle.width = rectangle.right - rectangle.left;
	                    rectangle.height = rectangle.bottom - rectangle.top;
	                    var scaleByX = this.layout.viewportIn.width / (rectangle.width);
	                    var scaleByY = this.layout.viewportIn.height / (rectangle.height);
	                    var scale = Math.min(scaleByX, scaleByY);
	                    var x = -rectangle.left * scale + 5;
	                    var y = -rectangle.top * scale + 5;
	                    this.main
	                        .style("line-height", "5px"); //TODO: This construction fixes bug #6343.
	                    this.main
	                        .attr("transform", visuals.SVGUtil.translate(x, y) + " scale(" + scale + ")")
	                        .style("line-height", "10px"); //TODO: This construction fixes bug #6343.
	                };
	                WordCloud.prototype.renderSelection = function () {
	                    var _this = this;
	                    if (this.selectionManager.selectionIds.some(function (x) {
	                        return !_this.wordsGroupUpdateSelection.data().some(function (y) {
	                            return y.selectionIds.some(function (z) { return z.getKey() === x.getKey(); });
	                        });
	                    })) {
	                        this.selectionManager.clear(false);
	                    }
	                    if (!this.selectionManager.hasSelection) {
	                        this.setOpacity(this.wordsTextUpdateSelection, WordCloud.MaxOpacity);
	                        return;
	                    }
	                    var selectedColumns = this.wordsTextUpdateSelection.filter(function (x) {
	                        return _this.selectionManager.isSelected(x.selectionIds[0]);
	                    });
	                    this.setOpacity(this.wordsTextUpdateSelection, WordCloud.MinOpacity);
	                    this.setOpacity(selectedColumns, WordCloud.MaxOpacity);
	                };
	                WordCloud.prototype.setOpacity = function (element, opacityValue) {
	                    element.style("fill-opacity", opacityValue);
	                    if (this.main) {
	                        this.main.style("line-height", "14px");
	                        this.animation(this.main, 0, this.durationAnimations)
	                            .style("line-height", "15px");
	                    }
	                };
	                WordCloud.prototype.enumerateObjectInstances = function (options) {
	                    var _this = this;
	                    var instances = WordCloudSettings.enumerateObjectInstances(this.settings && this.settings.originalSettings, options, WordCloud.capabilities);
	                    switch (options.objectName) {
	                        case "dataPoint":
	                            if (this.data && this.data.dataPoints) {
	                                var wordCategoriesIndex = [];
	                                _.unique(this.data.dataPoints, function (x) { return x.wordIndex; }).forEach(function (item) {
	                                    if (wordCategoriesIndex.indexOf(item.wordIndex) === -1) {
	                                        wordCategoriesIndex.push(item.wordIndex);
	                                        instances.pushInstance({
	                                            objectName: options.objectName,
	                                            displayName: _this.data.texts[item.wordIndex].text,
	                                            selector: visuals.ColorHelper.normalizeSelector(item.selectionIds[0].getSelector(), false),
	                                            properties: { fill: { solid: { color: item.color } } }
	                                        });
	                                    }
	                                });
	                            }
	                            break;
	                    }
	                    return instances.complete();
	                };
	                WordCloud.prototype.animation = function (element, duration, delay, callback) {
	                    if (duration === void 0) { duration = 0; }
	                    if (delay === void 0) { delay = 0; }
	                    return element
	                        .transition()
	                        .delay(delay)
	                        .duration(duration)
	                        .each("end", callback);
	                };
	                WordCloud.prototype.destroy = function () {
	                    this.root = null;
	                    this.canvas = null;
	                };
	                WordCloud.ClassName = "wordCloud";
	                WordCloud.Words = {
	                    "class": "words",
	                    selector: ".words"
	                };
	                WordCloud.WordGroup = {
	                    "class": "word",
	                    selector: ".word"
	                };
	                WordCloud.Size = "px";
	                WordCloud.StopWordsDelemiter = " ";
	                WordCloud.Radians = Math.PI / 180;
	                WordCloud.MinAngle = -180;
	                WordCloud.MaxAngle = 180;
	                WordCloud.MaxNumberOfWords = 2500;
	                WordCloud.MinOpacity = 0.2;
	                WordCloud.MaxOpacity = 1;
	                WordCloud.FontSizePercentageCoefficent = 1;
	                WordCloud.capabilities = {
	                    dataRoles: [{
	                            name: WordCloudColumns.Roles.Category,
	                            kind: powerbi.VisualDataRoleKind.Grouping,
	                            displayName: "Category"
	                        }, {
	                            name: WordCloudColumns.Roles.Values,
	                            kind: powerbi.VisualDataRoleKind.Measure,
	                            displayName: "Values"
	                        }],
	                    dataViewMappings: [{
	                            conditions: [{
	                                    "Category": {
	                                        min: 1,
	                                        max: 1
	                                    },
	                                    "Values": {
	                                        min: 0,
	                                        max: 1
	                                    }
	                                }],
	                            categorical: {
	                                categories: {
	                                    for: { in: "Category" },
	                                    dataReductionAlgorithm: { top: { count: WordCloud.MaxNumberOfWords } }
	                                },
	                                values: {
	                                    for: { in: "Values" }
	                                }
	                            }
	                        }],
	                    sorting: {
	                        implicit: {
	                            clauses: [{
	                                    role: "Values",
	                                    direction: 2 /*SortDirection.Descending*/ //Constant SortDirection.Descending currently is not supported on the msit
	                                }]
	                        }
	                    },
	                    objects: {
	                        general: {
	                            displayName: "General",
	                            properties: {
	                                formatString: {
	                                    type: {
	                                        formatting: {
	                                            formatString: true
	                                        }
	                                    }
	                                },
	                                maxNumberOfWords: {
	                                    displayName: "Max number of words",
	                                    type: { numeric: true }
	                                },
	                                minFontSize: {
	                                    displayName: "Min Font",
	                                    type: { formatting: { fontSize: true } }
	                                },
	                                maxFontSize: {
	                                    displayName: "Max Font",
	                                    type: { formatting: { fontSize: true } }
	                                },
	                                isBrokenText: {
	                                    displayName: "Word-breaking",
	                                    type: { bool: true }
	                                },
	                            }
	                        },
	                        dataPoint: {
	                            displayName: "Data colors",
	                            properties: {
	                                fill: {
	                                    displayName: "Fill",
	                                    type: { fill: { solid: { color: true } } }
	                                }
	                            }
	                        },
	                        stopWords: {
	                            displayName: "Stop Words",
	                            properties: {
	                                show: {
	                                    displayName: "Show",
	                                    type: { bool: true }
	                                },
	                                isDefaultStopWords: {
	                                    displayName: "Default Stop Words",
	                                    type: { bool: true }
	                                },
	                                words: {
	                                    displayName: "Words",
	                                    type: { text: true }
	                                }
	                            }
	                        },
	                        rotateText: {
	                            displayName: "Rotate Text",
	                            properties: {
	                                show: {
	                                    displayName: "Show",
	                                    type: { bool: true }
	                                },
	                                minAngle: {
	                                    displayName: "Min Angle",
	                                    type: { numeric: true }
	                                },
	                                maxAngle: {
	                                    displayName: "Max Angle",
	                                    type: { numeric: true }
	                                },
	                                maxNumberOfOrientations: {
	                                    displayName: "Max number of orientations",
	                                    type: { numeric: true }
	                                }
	                            }
	                        }
	                    }
	                };
	                WordCloud.Punctuation = [
	                    "!", ".", ":", "'", ";", ",", "!",
	                    "@", "#", "$", "%", "^", "&", "*",
	                    "(", ")", "[", "]", "\"", "\\", "/",
	                    "-", "_", "+", "="
	                ];
	                WordCloud.StopWords = [
	                    "a", "able", "about", "across", "after", "all", "almost", "also", "am", "among", "an",
	                    "and", "any", "are", "as", "at", "be", "because", "been", "but", "by", "can", "cannot",
	                    "could", "did", "do", "does", "either", "else", "ever", "every", "for", "from", "get",
	                    "got", "had", "has", "have", "he", "her", "hers", "him", "his", "how", "however", "i",
	                    "if", "in", "into", "is", "it", "its", "just", "least", "let", "like", "likely", "may",
	                    "me", "might", "most", "must", "my", "neither", "no", "nor", "not", "of", "off", "often",
	                    "on", "only", "or", "other", "our", "own", "rather", "said", "say", "says", "she", "should",
	                    "since", "so", "some", "than", "that", "the", "their", "them", "then", "there", "these",
	                    "they", "this", "tis", "to", "too", "twas", "us", "wants", "was", "we", "were", "what",
	                    "when", "where", "which", "while", "who", "whom", "why", "will", "with", "would", "yet",
	                    "you", "your"
	                ];
	                WordCloud.DefaultMargin = {
	                    top: 10,
	                    right: 10,
	                    bottom: 10,
	                    left: 10
	                };
	                return WordCloud;
	            }());
	            samples.WordCloud = WordCloud;
	            var explore;
	            (function (explore) {
	                var util;
	                (function (util) {
	                    function hexToRgb(hex) {
	                        // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
	                        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
	                        hex = hex.replace(shorthandRegex, function (m, r, g, b) {
	                            return r + r + g + g + b + b;
	                        });
	                        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
	                        return result ? "rgb(" + parseInt(result[1], 16) + "," + parseInt(result[2], 16) + "," + parseInt(result[3], 16) + ")" : null;
	                    }
	                    util.hexToRgb = hexToRgb;
	                    function getRandomColor() {
	                        var red = Math.floor(Math.random() * 255), green = Math.floor(Math.random() * 255), blue = Math.floor(Math.random() * 255);
	                        return "rgb(" + red + "," + green + "," + blue + ")";
	                    }
	                    util.getRandomColor = getRandomColor;
	                })(util = explore.util || (explore.util = {}));
	            })(explore || (explore = {}));
	        })(samples = visuals.samples || (visuals.samples = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 44 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../../../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var samples;
	        (function (samples) {
	            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
	            var PixelConverter = jsCommon.PixelConverter;
	            var SQExprConverter = powerbi.data.SQExprConverter;
	            var SelectionIdBuilder = powerbi.visuals.SelectionIdBuilder;
	            var Selector = powerbi.data.Selector;
	            var TableViewFactory;
	            (function (TableViewFactory) {
	                function createTableView(options) {
	                    return new TableView(options);
	                }
	                TableViewFactory.createTableView = createTableView;
	            })(TableViewFactory = samples.TableViewFactory || (samples.TableViewFactory = {}));
	            /**
	             * A UI Virtualized List, that uses the D3 Enter, Update & Exit pattern to update rows.
	             * It can create lists containing either HTML or SVG elements.
	             */
	            var TableView = (function () {
	                function TableView(options) {
	                    // make a copy of options so that it is not modified later by caller
	                    this.options = $.extend(true, {}, options);
	                    this.options.baseContainer
	                        .style('overflow-y', 'auto')
	                        .attr('drag-resize-disabled', true);
	                    this.scrollContainer = options.baseContainer
	                        .append('div')
	                        .attr('class', 'scrollRegion');
	                    this.visibleGroupContainer = this.scrollContainer
	                        .append('div')
	                        .attr('class', 'visibleGroup');
	                    TableView.SetDefaultOptions(options);
	                }
	                TableView.SetDefaultOptions = function (options) {
	                    options.rowHeight = options.rowHeight || TableView.defaultRowHeight;
	                };
	                TableView.prototype.rowHeight = function (rowHeight) {
	                    this.options.rowHeight = Math.ceil(rowHeight);
	                    return this;
	                };
	                TableView.prototype.columnWidth = function (columnWidth) {
	                    this.options.columnWidth = Math.ceil(columnWidth);
	                    return this;
	                };
	                TableView.prototype.orientation = function (orientation) {
	                    this.options.orientation = orientation;
	                    return this;
	                };
	                TableView.prototype.rows = function (rows) {
	                    this.options.rows = Math.ceil(rows);
	                    return this;
	                };
	                TableView.prototype.columns = function (columns) {
	                    this.options.columns = Math.ceil(columns);
	                    return this;
	                };
	                TableView.prototype.data = function (data, getDatumIndex, dataReset) {
	                    if (dataReset === void 0) { dataReset = false; }
	                    this._data = data;
	                    this.getDatumIndex = getDatumIndex;
	                    this.setTotalRows();
	                    if (dataReset) {
	                        $(this.options.baseContainer.node()).scrollTop(0);
	                    }
	                    return this;
	                };
	                TableView.prototype.viewport = function (viewport) {
	                    this.options.viewport = viewport;
	                    return this;
	                };
	                TableView.prototype.empty = function () {
	                    this._data = [];
	                    this.render();
	                };
	                TableView.prototype.setTotalRows = function () {
	                    var count = this._data.length;
	                    var rows = Math.min(this.options.rows, count);
	                    var columns = Math.min(this.options.columns, count);
	                    if ((columns > 0) && (rows > 0)) {
	                        this._totalColumns = columns;
	                        this._totalRows = rows;
	                    }
	                    else if (rows > 0) {
	                        this._totalRows = rows;
	                        this._totalColumns = Math.ceil(count / rows);
	                    }
	                    else if (columns > 0) {
	                        this._totalColumns = columns;
	                        this._totalRows = Math.ceil(count / columns);
	                    }
	                    else {
	                        this._totalColumns = TableView.defaultColumns;
	                        this._totalRows = Math.ceil(count / TableView.defaultColumns);
	                    }
	                };
	                TableView.prototype.render = function () {
	                    var options = this.options;
	                    var visibleGroupContainer = this.visibleGroupContainer;
	                    var rowHeight = options.rowHeight || TableView.defaultRowHeight;
	                    var groupedData = [];
	                    var totalRows = options.rows;
	                    var totalColumns = options.columns;
	                    var totalItems = this._data.length;
	                    var totalRows = options.rows > totalItems ? totalItems : options.rows;
	                    var totalColumns = options.columns > totalItems ? totalItems : options.columns;
	                    if (totalColumns === 0 && totalRows === 0) {
	                        if (options.orientation === Orientation.HORIZONTAL) {
	                            totalColumns = totalItems;
	                            totalRows = 1;
	                        }
	                        else {
	                            totalColumns = 1;
	                            totalRows = totalItems;
	                        }
	                    }
	                    else if (totalColumns === 0 && totalRows > 0) {
	                        totalColumns = Math.ceil(totalItems / totalRows);
	                    }
	                    else if (totalColumns > 0 && totalRows === 0) {
	                        totalRows = Math.ceil(totalItems / totalColumns);
	                    }
	                    if (this.options.orientation === Orientation.VERTICAL) {
	                        var n = totalRows;
	                        totalRows = totalColumns;
	                        totalColumns = n;
	                    }
	                    else if (this.options.orientation === Orientation.HORIZONTAL) {
	                        if (totalRows === 0)
	                            totalRows = this._totalRows;
	                        if (totalColumns === 0)
	                            totalColumns = this._totalColumns;
	                    }
	                    var m = 0;
	                    var k = 0;
	                    for (var i = 0; i < totalRows; i++) {
	                        if (this.options.orientation === Orientation.VERTICAL
	                            && options.rows === 0
	                            && totalItems % options.columns > 0
	                            && options.columns <= totalItems) {
	                            if (totalItems % options.columns > i) {
	                                m = i * Math.ceil(totalItems / options.columns);
	                                k = m + Math.ceil(totalItems / options.columns);
	                                groupedData.push(this._data.slice(m, k));
	                            }
	                            else {
	                                groupedData.push(this._data.slice(k, k + Math.floor(totalItems / options.columns)));
	                                k = k + Math.floor(totalItems / options.columns);
	                            }
	                        }
	                        else if (this.options.orientation === Orientation.HORIZONTAL
	                            && options.columns === 0
	                            && totalItems % options.rows > 0
	                            && options.rows <= totalItems) {
	                            if (totalItems % options.rows > i) {
	                                m = i * Math.ceil(totalItems / options.rows);
	                                k = m + Math.ceil(totalItems / options.rows);
	                                groupedData.push(this._data.slice(m, k));
	                            }
	                            else {
	                                groupedData.push(this._data.slice(k, k + Math.floor(totalItems / options.rows)));
	                                k = k + Math.floor(totalItems / options.rows);
	                            }
	                        }
	                        else {
	                            var k = i * totalColumns;
	                            groupedData.push(this._data.slice(k, k + totalColumns));
	                        }
	                    }
	                    visibleGroupContainer.selectAll(".row").remove();
	                    var cellSelection = visibleGroupContainer.selectAll(".row")
	                        .data(groupedData)
	                        .enter()
	                        .append("div")
	                        .classed('row', true)
	                        .selectAll(".cell")
	                        .data(function (d) { return d; });
	                    cellSelection
	                        .enter()
	                        .append('div')
	                        .classed('cell', true)
	                        .call(function (d) { return options.enter(d); });
	                    cellSelection.order();
	                    var cellUpdateSelection = visibleGroupContainer.selectAll('.cell:not(.transitioning)');
	                    cellUpdateSelection.call(function (d) { return options.update(d); });
	                    cellUpdateSelection.style({ 'height': (rowHeight > 0) ? rowHeight + 'px' : 'auto' });
	                    if (this.options.orientation === Orientation.VERTICAL) {
	                        var realColumnNumber = 0;
	                        for (var i = 0; i < groupedData.length; i++) {
	                            if (groupedData[i].length !== 0)
	                                realColumnNumber = i + 1;
	                        }
	                        cellUpdateSelection.style({ 'width': '100%' });
	                        var rowUpdateSelection = visibleGroupContainer.selectAll('div.row');
	                        rowUpdateSelection.style({ 'width': (options.columnWidth > 0) ? options.columnWidth + 'px' : (100 / realColumnNumber) + '%' });
	                    }
	                    else {
	                        cellUpdateSelection.style({
	                            'width': (options.columnWidth > 0) ? options.columnWidth + 'px' : (100 / totalColumns) + '%'
	                        });
	                    }
	                    cellSelection
	                        .exit()
	                        .call(function (d) { return options.exit(d); })
	                        .remove();
	                };
	                TableView.defaultRowHeight = 0;
	                TableView.defaultColumns = 1;
	                return TableView;
	            }());
	            // TODO: Generate these from above, defining twice just introduces potential for error
	            samples.chicletSlicerProps = {
	                general: {
	                    orientation: { objectName: 'general', propertyName: 'orientation' },
	                    columns: { objectName: 'general', propertyName: 'columns' },
	                    rows: { objectName: 'general', propertyName: 'rows' },
	                    showDisabled: { objectName: 'general', propertyName: 'showDisabled' },
	                    multiselect: { objectName: 'general', propertyName: 'multiselect' },
	                    selection: { objectName: 'general', propertyName: 'selection' },
	                    selfFilterEnabled: { objectName: 'general', propertyName: 'selfFilterEnabled' },
	                },
	                header: {
	                    show: { objectName: 'header', propertyName: 'show' },
	                    title: { objectName: 'header', propertyName: 'title' },
	                    fontColor: { objectName: 'header', propertyName: 'fontColor' },
	                    background: { objectName: 'header', propertyName: 'background' },
	                    outline: { objectName: 'header', propertyName: 'outline' },
	                    textSize: { objectName: 'header', propertyName: 'textSize' },
	                    outlineColor: { objectName: 'header', propertyName: 'outlineColor' },
	                    outlineWeight: { objectName: 'header', propertyName: 'outlineWeight' }
	                },
	                rows: {
	                    fontColor: { objectName: 'rows', propertyName: 'fontColor' },
	                    textSize: { objectName: 'rows', propertyName: 'textSize' },
	                    height: { objectName: 'rows', propertyName: 'height' },
	                    width: { objectName: 'rows', propertyName: 'width' },
	                    background: { objectName: 'rows', propertyName: 'background' },
	                    transparency: { objectName: 'rows', propertyName: 'transparency' },
	                    selectedColor: { objectName: 'rows', propertyName: 'selectedColor' },
	                    hoverColor: { objectName: 'rows', propertyName: 'hoverColor' },
	                    unselectedColor: { objectName: 'rows', propertyName: 'unselectedColor' },
	                    disabledColor: { objectName: 'rows', propertyName: 'disabledColor' },
	                    outline: { objectName: 'rows', propertyName: 'outline' },
	                    outlineColor: { objectName: 'rows', propertyName: 'outlineColor' },
	                    outlineWeight: { objectName: 'rows', propertyName: 'outlineWeight' },
	                    borderStyle: { objectName: 'rows', propertyName: 'borderStyle' },
	                },
	                images: {
	                    imageSplit: { objectName: 'images', propertyName: 'imageSplit' },
	                    stretchImage: { objectName: 'images', propertyName: 'stretchImage' },
	                    bottomImage: { objectName: 'images', propertyName: 'bottomImage' },
	                },
	                selectedPropertyIdentifier: { objectName: 'general', propertyName: 'selected' },
	                filterPropertyIdentifier: { objectName: 'general', propertyName: 'filter' },
	                formatString: { objectName: 'general', propertyName: 'formatString' },
	                hasSavedSelection: true,
	            };
	            var ChicletBorderStyle;
	            (function (ChicletBorderStyle) {
	                ChicletBorderStyle.ROUNDED = 'Rounded';
	                ChicletBorderStyle.CUT = 'Cut';
	                ChicletBorderStyle.SQUARE = 'Square';
	                ChicletBorderStyle.type = powerbi.createEnumType([
	                    { value: ChicletBorderStyle.ROUNDED, displayName: ChicletBorderStyle.ROUNDED },
	                    { value: ChicletBorderStyle.CUT, displayName: ChicletBorderStyle.CUT },
	                    { value: ChicletBorderStyle.SQUARE, displayName: ChicletBorderStyle.SQUARE },
	                ]);
	            })(ChicletBorderStyle || (ChicletBorderStyle = {}));
	            var ChicletSlicerShowDisabled;
	            (function (ChicletSlicerShowDisabled) {
	                ChicletSlicerShowDisabled.INPLACE = 'Inplace';
	                ChicletSlicerShowDisabled.BOTTOM = 'Bottom';
	                ChicletSlicerShowDisabled.HIDE = 'Hide';
	                ChicletSlicerShowDisabled.type = powerbi.createEnumType([
	                    { value: ChicletSlicerShowDisabled.INPLACE, displayName: ChicletSlicerShowDisabled.INPLACE },
	                    { value: ChicletSlicerShowDisabled.BOTTOM, displayName: ChicletSlicerShowDisabled.BOTTOM },
	                    { value: ChicletSlicerShowDisabled.HIDE, displayName: ChicletSlicerShowDisabled.HIDE },
	                ]);
	            })(ChicletSlicerShowDisabled || (ChicletSlicerShowDisabled = {}));
	            var Orientation;
	            (function (Orientation) {
	                Orientation.HORIZONTAL = 'Horizontal';
	                Orientation.VERTICAL = 'Vertical';
	                Orientation.type = powerbi.createEnumType([
	                    { value: Orientation.HORIZONTAL, displayName: Orientation.HORIZONTAL },
	                    { value: Orientation.VERTICAL, displayName: Orientation.VERTICAL }
	                ]);
	            })(Orientation || (Orientation = {}));
	            var ChicletSlicer = (function () {
	                function ChicletSlicer(options) {
	                    if (options) {
	                        if (options.behavior) {
	                            this.behavior = options.behavior;
	                        }
	                    }
	                    if (!this.behavior) {
	                        this.behavior = new ChicletSlicerWebBehavior();
	                    }
	                }
	                ChicletSlicer.DefaultStyleProperties = function () {
	                    return {
	                        general: {
	                            orientation: Orientation.VERTICAL,
	                            columns: 3,
	                            rows: 0,
	                            multiselect: true,
	                            showDisabled: ChicletSlicerShowDisabled.INPLACE,
	                            selection: null,
	                            selfFilterEnabled: false
	                        },
	                        margin: {
	                            top: 50,
	                            bottom: 50,
	                            right: 50,
	                            left: 50
	                        },
	                        header: {
	                            borderBottomWidth: 1,
	                            show: true,
	                            outline: 'BottomOnly',
	                            fontColor: '#a6a6a6',
	                            background: null,
	                            textSize: 10,
	                            outlineColor: '#a6a6a6',
	                            outlineWeight: 1,
	                            title: '',
	                        },
	                        headerText: {
	                            marginLeft: 8,
	                            marginTop: 0
	                        },
	                        slicerText: {
	                            textSize: 10,
	                            height: 0,
	                            width: 0,
	                            fontColor: '#666666',
	                            hoverColor: '#212121',
	                            selectedColor: '#BDD7EE',
	                            unselectedColor: '#ffffff',
	                            disabledColor: 'grey',
	                            marginLeft: 8,
	                            outline: 'Frame',
	                            background: null,
	                            transparency: 0,
	                            outlineColor: '#000000',
	                            outlineWeight: 1,
	                            borderStyle: 'Cut',
	                        },
	                        slicerItemContainer: {
	                            // The margin is assigned in the less file. This is needed for the height calculations.
	                            marginTop: 5,
	                            marginLeft: 0,
	                        },
	                        images: {
	                            imageSplit: 50,
	                            stretchImage: false,
	                            bottomImage: false
	                        }
	                    };
	                };
	                /**
	                 * Public to testability.
	                 */
	                ChicletSlicer.getValidImageSplit = function (imageSplit) {
	                    if (imageSplit < ChicletSlicer.MinImageSplit) {
	                        return ChicletSlicer.MinImageSplit;
	                    }
	                    else if (imageSplit > ChicletSlicer.MaxImageSplit) {
	                        return ChicletSlicer.MaxImageSplit;
	                    }
	                    else {
	                        return imageSplit;
	                    }
	                };
	                ChicletSlicer.converter = function (dataView, localizedSelectAllText, searchText, interactivityService) {
	                    if (!dataView ||
	                        !dataView.categorical ||
	                        !dataView.categorical.categories ||
	                        !dataView.categorical.categories[0] ||
	                        !dataView.categorical.categories[0].values ||
	                        !(dataView.categorical.categories[0].values.length > 0)) {
	                        return;
	                    }
	                    var converter = new ChicletSlicerChartConversion.ChicletSlicerConverter(dataView, interactivityService);
	                    converter.convert();
	                    var slicerData;
	                    var defaultSettings = this.DefaultStyleProperties();
	                    var objects = dataView.metadata.objects;
	                    if (objects) {
	                        defaultSettings.general.orientation = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.orientation, defaultSettings.general.orientation);
	                        defaultSettings.general.columns = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.columns, defaultSettings.general.columns);
	                        defaultSettings.general.rows = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.rows, defaultSettings.general.rows);
	                        defaultSettings.general.multiselect = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.multiselect, defaultSettings.general.multiselect);
	                        defaultSettings.general.showDisabled = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.showDisabled, defaultSettings.general.showDisabled);
	                        defaultSettings.general.selection = powerbi.DataViewObjects.getValue(dataView.metadata.objects, samples.chicletSlicerProps.general.selection, defaultSettings.general.selection);
	                        defaultSettings.general.selfFilterEnabled = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.selfFilterEnabled, defaultSettings.general.selfFilterEnabled);
	                        defaultSettings.header.show = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.show, defaultSettings.header.show);
	                        defaultSettings.header.title = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.title, defaultSettings.header.title);
	                        defaultSettings.header.fontColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.header.fontColor, defaultSettings.header.fontColor);
	                        defaultSettings.header.background = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.header.background, defaultSettings.header.background);
	                        defaultSettings.header.textSize = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.textSize, defaultSettings.header.textSize);
	                        defaultSettings.header.outline = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.outline, defaultSettings.header.outline);
	                        defaultSettings.header.outlineColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.header.outlineColor, defaultSettings.header.outlineColor);
	                        defaultSettings.header.outlineWeight = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.outlineWeight, defaultSettings.header.outlineWeight);
	                        defaultSettings.slicerText.textSize = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.textSize, defaultSettings.slicerText.textSize);
	                        defaultSettings.slicerText.height = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.height, defaultSettings.slicerText.height);
	                        defaultSettings.slicerText.width = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.width, defaultSettings.slicerText.width);
	                        defaultSettings.slicerText.selectedColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.selectedColor, defaultSettings.slicerText.selectedColor);
	                        defaultSettings.slicerText.hoverColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.hoverColor, defaultSettings.slicerText.hoverColor);
	                        defaultSettings.slicerText.unselectedColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.unselectedColor, defaultSettings.slicerText.unselectedColor);
	                        defaultSettings.slicerText.disabledColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.disabledColor, defaultSettings.slicerText.disabledColor);
	                        defaultSettings.slicerText.background = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.background, defaultSettings.slicerText.background);
	                        defaultSettings.slicerText.transparency = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.transparency, defaultSettings.slicerText.transparency);
	                        defaultSettings.slicerText.fontColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.fontColor, defaultSettings.slicerText.fontColor);
	                        defaultSettings.slicerText.outline = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.outline, defaultSettings.slicerText.outline);
	                        defaultSettings.slicerText.outlineColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.outlineColor, defaultSettings.slicerText.outlineColor);
	                        defaultSettings.slicerText.outlineWeight = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.outlineWeight, defaultSettings.slicerText.outlineWeight);
	                        defaultSettings.slicerText.borderStyle = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.borderStyle, defaultSettings.slicerText.borderStyle);
	                        defaultSettings.images.imageSplit = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.images.imageSplit, defaultSettings.images.imageSplit);
	                        defaultSettings.images.stretchImage = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.images.stretchImage, defaultSettings.images.stretchImage);
	                        defaultSettings.images.bottomImage = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.images.bottomImage, defaultSettings.images.bottomImage);
	                    }
	                    if (defaultSettings.general.selfFilterEnabled && searchText) {
	                        searchText = searchText.toLowerCase();
	                        converter.dataPoints.forEach(function (x) { return x.filtered = x.category.toLowerCase().indexOf(searchText) < 0; });
	                    }
	                    var categories = dataView.categorical.categories[0];
	                    slicerData = {
	                        categorySourceName: categories.source.displayName,
	                        formatString: visuals.valueFormatter.getFormatString(categories.source, samples.chicletSlicerProps.formatString),
	                        slicerSettings: defaultSettings,
	                        slicerDataPoints: converter.dataPoints,
	                    };
	                    // Override hasSelection if a objects contained more scopeIds than selections we found in the data
	                    slicerData.hasSelectionOverride = converter.hasSelectionOverride;
	                    return slicerData;
	                };
	                ChicletSlicer.prototype.init = function (options) {
	                    this.element = options.element;
	                    this.currentViewport = options.viewport;
	                    if (this.behavior) {
	                        this.interactivityService = visuals.createInteractivityService(options.host);
	                    }
	                    this.hostServices = options.host;
	                    this.hostServices.canSelect = ChicletSlicer.canSelect;
	                    this.settings = ChicletSlicer.DefaultStyleProperties();
	                    this.initContainer();
	                };
	                ChicletSlicer.canSelect = function (args) {
	                    var selectors = _.map(args.visualObjects, function (visualObject) { return Selector.convertSelectorsByColumnToSelector(visualObject.selectorsByColumn); });
	                    // We can't have multiple selections if any include more than one identity
	                    if (selectors && (selectors.length > 1)) {
	                        if (selectors.some(function (value) { return value && value.data && value.data.length > 1; })) {
	                            return false;
	                        }
	                    }
	                    // Todo: check for cases of trying to select a category and a series (not the intersection)
	                    return true;
	                };
	                ChicletSlicer.prototype.update = function (options) {
	                    if (!options ||
	                        !options.dataViews ||
	                        !options.dataViews[0] ||
	                        !options.viewport) {
	                        return;
	                    }
	                    var existingDataView = this.dataView;
	                    this.dataView = options.dataViews[0];
	                    var resetScrollbarPosition = true;
	                    if (existingDataView) {
	                        resetScrollbarPosition = !powerbi.DataViewAnalysis.hasSameCategoryIdentity(existingDataView, this.dataView);
	                    }
	                    if (options.viewport.height === this.currentViewport.height
	                        && options.viewport.width === this.currentViewport.width) {
	                        this.waitingForData = false;
	                    }
	                    else {
	                        this.currentViewport = options.viewport;
	                    }
	                    this.updateInternal(resetScrollbarPosition);
	                };
	                ChicletSlicer.prototype.onResizing = function (finalViewport) {
	                    this.currentViewport = finalViewport;
	                    this.updateInternal(false /* resetScrollbarPosition */);
	                };
	                ChicletSlicer.prototype.enumerateObjectInstances = function (options) {
	                    var data = this.slicerData;
	                    if (!data) {
	                        return;
	                    }
	                    var objectName = options.objectName;
	                    switch (objectName) {
	                        case 'rows':
	                            return this.enumerateRows(data);
	                        case 'header':
	                            return this.enumerateHeader(data);
	                        case 'general':
	                            return this.enumerateGeneral(data);
	                        case 'images':
	                            return this.enumerateImages(data);
	                    }
	                };
	                ChicletSlicer.prototype.enumerateHeader = function (data) {
	                    var slicerSettings = this.settings;
	                    return [{
	                            selector: null,
	                            objectName: 'header',
	                            properties: {
	                                show: slicerSettings.header.show,
	                                title: slicerSettings.header.title,
	                                fontColor: slicerSettings.header.fontColor,
	                                background: slicerSettings.header.background,
	                                textSize: slicerSettings.header.textSize,
	                                outline: slicerSettings.header.outline,
	                                outlineColor: slicerSettings.header.outlineColor,
	                                outlineWeight: slicerSettings.header.outlineWeight
	                            }
	                        }];
	                };
	                ChicletSlicer.prototype.enumerateRows = function (data) {
	                    var slicerSettings = this.settings;
	                    return [{
	                            selector: null,
	                            objectName: 'rows',
	                            properties: {
	                                textSize: slicerSettings.slicerText.textSize,
	                                height: slicerSettings.slicerText.height,
	                                width: slicerSettings.slicerText.width,
	                                background: slicerSettings.slicerText.background,
	                                transparency: slicerSettings.slicerText.transparency,
	                                selectedColor: slicerSettings.slicerText.selectedColor,
	                                hoverColor: slicerSettings.slicerText.hoverColor,
	                                unselectedColor: slicerSettings.slicerText.unselectedColor,
	                                disabledColor: slicerSettings.slicerText.disabledColor,
	                                outline: slicerSettings.slicerText.outline,
	                                outlineColor: slicerSettings.slicerText.outlineColor,
	                                outlineWeight: slicerSettings.slicerText.outlineWeight,
	                                fontColor: slicerSettings.slicerText.fontColor,
	                                borderStyle: slicerSettings.slicerText.borderStyle,
	                            }
	                        }];
	                };
	                ChicletSlicer.prototype.enumerateGeneral = function (data) {
	                    var slicerSettings = this.settings;
	                    return [{
	                            selector: null,
	                            objectName: 'general',
	                            properties: {
	                                orientation: slicerSettings.general.orientation,
	                                columns: slicerSettings.general.columns,
	                                rows: slicerSettings.general.rows,
	                                showDisabled: slicerSettings.general.showDisabled,
	                                multiselect: slicerSettings.general.multiselect,
	                                selfFilterEnabled: slicerSettings.general.selfFilterEnabled
	                            }
	                        }];
	                };
	                ChicletSlicer.prototype.enumerateImages = function (data) {
	                    var slicerSettings = this.settings;
	                    return [{
	                            selector: null,
	                            objectName: 'images',
	                            properties: {
	                                imageSplit: slicerSettings.images.imageSplit,
	                                stretchImage: slicerSettings.images.stretchImage,
	                                bottomImage: slicerSettings.images.bottomImage,
	                            }
	                        }];
	                };
	                ChicletSlicer.prototype.updateInternal = function (resetScrollbarPosition) {
	                    var _this = this;
	                    this.updateSlicerBodyDimensions();
	                    var localizedSelectAllText = 'Select All';
	                    var data = ChicletSlicer.converter(this.dataView, localizedSelectAllText, this.searchInput.val(), this.interactivityService);
	                    if (!data) {
	                        this.tableView.empty();
	                        return;
	                    }
	                    if (this.interactivityService) {
	                        this.interactivityService.applySelectionStateToData(data.slicerDataPoints);
	                    }
	                    data.slicerSettings.header.outlineWeight = data.slicerSettings.header.outlineWeight < 0 ? 0 : data.slicerSettings.header.outlineWeight;
	                    data.slicerSettings.slicerText.outlineWeight = data.slicerSettings.slicerText.outlineWeight < 0 ? 0 : data.slicerSettings.slicerText.outlineWeight;
	                    data.slicerSettings.slicerText.height = data.slicerSettings.slicerText.height < 0 ? 0 : data.slicerSettings.slicerText.height;
	                    data.slicerSettings.slicerText.width = data.slicerSettings.slicerText.width < 0 ? 0 : data.slicerSettings.slicerText.width;
	                    data.slicerSettings.images.imageSplit = ChicletSlicer.getValidImageSplit(data.slicerSettings.images.imageSplit);
	                    data.slicerSettings.general.columns = data.slicerSettings.general.columns < 0 ? 0 : data.slicerSettings.general.columns;
	                    data.slicerSettings.general.rows = data.slicerSettings.general.rows < 0 ? 0 : data.slicerSettings.general.rows;
	                    data.slicerSettings.general.getSavedSelection = function () {
	                        try {
	                            return JSON.parse(_this.slicerData.slicerSettings.general.selection) || [];
	                        }
	                        catch (ex) {
	                            return [];
	                        }
	                    };
	                    data.slicerSettings.general.setSavedSelection = function (filter, selectionIds) {
	                        _this.isSelectionSaved = true;
	                        _this.hostServices.persistProperties({
	                            merge: [{
	                                    objectName: "general",
	                                    selector: null,
	                                    properties: {
	                                        filter: filter,
	                                        selection: selectionIds && JSON.stringify(selectionIds) || "" }
	                                }]
	                        });
	                    };
	                    if (this.slicerData) {
	                        if (this.isSelectionSaved) {
	                            this.isSelectionLoaded = true;
	                        }
	                        else {
	                            this.isSelectionLoaded = this.slicerData.slicerSettings.general.selection === data.slicerSettings.general.selection;
	                        }
	                    }
	                    else {
	                        this.isSelectionLoaded = false;
	                    }
	                    this.slicerData = data;
	                    this.settings = this.slicerData.slicerSettings;
	                    if (this.settings.general.showDisabled === ChicletSlicerShowDisabled.BOTTOM) {
	                        data.slicerDataPoints.sort(function (a, b) {
	                            if (a.selectable === b.selectable) {
	                                return 0;
	                            }
	                            else if (a.selectable && !b.selectable) {
	                                return -1;
	                            }
	                            else {
	                                return 1;
	                            }
	                        });
	                    }
	                    else if (this.settings.general.showDisabled === ChicletSlicerShowDisabled.HIDE) {
	                        data.slicerDataPoints = data.slicerDataPoints.filter(function (x) { return x.selectable; });
	                    }
	                    var height = this.settings.slicerText.height;
	                    if (height === 0) {
	                        var extraSpaceForCell = ChicletSlicer.cellTotalInnerPaddings + ChicletSlicer.cellTotalInnerBorders;
	                        var textProperties = ChicletSlicer.getChicletTextProperties(this.settings.slicerText.textSize);
	                        height = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties) + powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(textProperties) + extraSpaceForCell;
	                        var hasImage = _.any(data.slicerDataPoints, function (x) { return x.imageURL !== '' && typeof x.imageURL !== "undefined"; });
	                        if (hasImage)
	                            height += 100;
	                    }
	                    this.tableView
	                        .rowHeight(height)
	                        .columnWidth(this.settings.slicerText.width)
	                        .orientation(this.settings.general.orientation)
	                        .rows(this.settings.general.rows)
	                        .columns(this.settings.general.columns)
	                        .data(data.slicerDataPoints.filter(function (x) { return !x.filtered; }), function (d) { return $.inArray(d, data.slicerDataPoints); }, resetScrollbarPosition)
	                        .viewport(this.getSlicerBodyViewport(this.currentViewport))
	                        .render();
	                    this.updateSearchHeader();
	                };
	                ChicletSlicer.prototype.initContainer = function () {
	                    var _this = this;
	                    var settings = this.settings;
	                    var slicerBodyViewport = this.getSlicerBodyViewport(this.currentViewport);
	                    var slicerContainer = d3.select(this.element.get(0))
	                        .append('div')
	                        .classed(ChicletSlicer.Container.class, true);
	                    this.slicerHeader = slicerContainer
	                        .append('div')
	                        .classed(ChicletSlicer.Header.class, true);
	                    this.slicerHeader
	                        .append('span')
	                        .classed(ChicletSlicer.Clear.class, true)
	                        .attr('title', 'Clear');
	                    this.slicerHeader
	                        .append('div')
	                        .classed(ChicletSlicer.HeaderText.class, true)
	                        .style({
	                        'margin-left': PixelConverter.toString(settings.headerText.marginLeft),
	                        'margin-top': PixelConverter.toString(settings.headerText.marginTop),
	                        'border-style': this.getBorderStyle(settings.header.outline),
	                        'border-color': settings.header.outlineColor,
	                        'border-width': this.getBorderWidth(settings.header.outline, settings.header.outlineWeight),
	                        'font-size': PixelConverter.fromPoint(settings.header.textSize),
	                    });
	                    this.createSearchHeader($(slicerContainer.node()));
	                    this.slicerBody = slicerContainer
	                        .append('div').classed(ChicletSlicer.Body.class, true)
	                        .classed('slicerBody-horizontal', settings.general.orientation === Orientation.HORIZONTAL)
	                        .classed('slicerBody-vertical', settings.general.orientation === Orientation.VERTICAL)
	                        .style({
	                        'height': PixelConverter.toString(slicerBodyViewport.height),
	                        'width': '100%',
	                    });
	                    var rowEnter = function (rowSelection) {
	                        var settings = _this.settings;
	                        var listItemElement = rowSelection
	                            .append('ul')
	                            .append('li')
	                            .classed(ChicletSlicer.ItemContainer.class, true)
	                            .style({
	                            'margin-left': PixelConverter.toString(settings.slicerItemContainer.marginLeft),
	                        });
	                        listItemElement.append('img')
	                            .classed('slicer-img-wrapper', true);
	                        listItemElement.append('div')
	                            .classed('slicer-text-wrapper', true)
	                            .append('span')
	                            .classed(ChicletSlicer.LabelText.class, true)
	                            .style({
	                            'font-size': PixelConverter.fromPoint(settings.slicerText.textSize),
	                        });
	                    };
	                    var rowUpdate = function (rowSelection) {
	                        var settings = _this.settings;
	                        var data = _this.slicerData;
	                        if (data && settings) {
	                            _this.slicerHeader.classed('hidden', !settings.header.show);
	                            _this.slicerHeader.select(ChicletSlicer.HeaderText.selector)
	                                .text(settings.header.title.trim() !== "" ? settings.header.title.trim() : _this.slicerData.categorySourceName)
	                                .style({
	                                'border-style': _this.getBorderStyle(settings.header.outline),
	                                'border-color': settings.header.outlineColor,
	                                'border-width': _this.getBorderWidth(settings.header.outline, settings.header.outlineWeight),
	                                'color': settings.header.fontColor,
	                                'background-color': settings.header.background,
	                                'font-size': PixelConverter.fromPoint(settings.header.textSize),
	                            });
	                            _this.slicerBody
	                                .classed('slicerBody-horizontal', settings.general.orientation === Orientation.HORIZONTAL)
	                                .classed('slicerBody-vertical', settings.general.orientation === Orientation.VERTICAL);
	                            var slicerText = rowSelection.selectAll(ChicletSlicer.LabelText.selector);
	                            var textProperties = ChicletSlicer.getChicletTextProperties(settings.slicerText.textSize);
	                            var formatString = data.formatString;
	                            slicerText.text(function (d) {
	                                var text = visuals.valueFormatter.format(d.category, formatString);
	                                textProperties.text = text;
	                                if (_this.settings.slicerText.width === 0)
	                                    return powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, (_this.currentViewport.width / _this.settings.general.columns) - ChicletSlicer.chicletTotalInnerRightLeftPaddings - ChicletSlicer.cellTotalInnerBorders - settings.slicerText.outlineWeight);
	                                else
	                                    return powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, _this.settings.slicerText.width - ChicletSlicer.chicletTotalInnerRightLeftPaddings - ChicletSlicer.cellTotalInnerBorders - settings.slicerText.outlineWeight);
	                            });
	                            var slicerImg = rowSelection.selectAll('.slicer-img-wrapper');
	                            slicerImg
	                                .style('max-height', settings.images.imageSplit + '%')
	                                .classed('hidden', function (d) {
	                                if (!(d.imageURL)) {
	                                    return true;
	                                }
	                                if (settings.images.imageSplit < 10) {
	                                    return true;
	                                }
	                            })
	                                .style('display', function (d) { return (d.imageURL) ? 'flex' : 'none'; })
	                                .classed('stretchImage', settings.images.stretchImage)
	                                .classed('bottomImage', settings.images.bottomImage)
	                                .attr('src', function (d) {
	                                return d.imageURL ? d.imageURL : '';
	                            });
	                            rowSelection.selectAll('.slicer-text-wrapper')
	                                .style('height', function (d) {
	                                return d.imageURL ? (100 - settings.images.imageSplit) + '%' : '100%';
	                            })
	                                .classed('hidden', function (d) {
	                                if (settings.images.imageSplit > 90) {
	                                    return true;
	                                }
	                            });
	                            rowSelection.selectAll('.slicerItemContainer').style({
	                                'color': settings.slicerText.fontColor,
	                                'border-style': _this.getBorderStyle(settings.slicerText.outline),
	                                'border-color': settings.slicerText.outlineColor,
	                                'border-width': _this.getBorderWidth(settings.slicerText.outline, settings.slicerText.outlineWeight),
	                                'font-size': PixelConverter.fromPoint(settings.slicerText.textSize),
	                                'border-radius': _this.getBorderRadius(settings.slicerText.borderStyle),
	                            });
	                            if (settings.slicerText.background)
	                                _this.slicerBody.style('background-color', explore.util.hexToRGBString(settings.slicerText.background, (100 - settings.slicerText.transparency) / 100));
	                            else
	                                _this.slicerBody.style('background-color', null);
	                            if (_this.interactivityService && _this.slicerBody) {
	                                _this.interactivityService.applySelectionStateToData(data.slicerDataPoints);
	                                var slicerBody = _this.slicerBody.attr('width', _this.currentViewport.width);
	                                var slicerItemContainers = slicerBody.selectAll(ChicletSlicer.ItemContainer.selector);
	                                var slicerItemLabels = slicerBody.selectAll(ChicletSlicer.LabelText.selector);
	                                var slicerItemInputs = slicerBody.selectAll(ChicletSlicer.Input.selector);
	                                var slicerClear = _this.slicerHeader.select(ChicletSlicer.Clear.selector);
	                                var behaviorOptions = {
	                                    dataPoints: data.slicerDataPoints,
	                                    slicerItemContainers: slicerItemContainers,
	                                    slicerItemLabels: slicerItemLabels,
	                                    slicerItemInputs: slicerItemInputs,
	                                    slicerClear: slicerClear,
	                                    interactivityService: _this.interactivityService,
	                                    slicerSettings: data.slicerSettings,
	                                    isSelectionLoaded: _this.isSelectionLoaded
	                                };
	                                _this.interactivityService.bind(data.slicerDataPoints, _this.behavior, behaviorOptions, {
	                                    overrideSelectionFromData: true,
	                                    hasSelectionOverride: data.hasSelectionOverride,
	                                });
	                                _this.behavior.styleSlicerInputs(rowSelection.select(ChicletSlicer.ItemContainer.selector), _this.interactivityService.hasSelection());
	                            }
	                            else {
	                                _this.behavior.styleSlicerInputs(rowSelection.select(ChicletSlicer.ItemContainer.selector), false);
	                            }
	                        }
	                    };
	                    var rowExit = function (rowSelection) {
	                        rowSelection.remove();
	                    };
	                    var tableViewOptions = {
	                        rowHeight: this.getRowHeight(),
	                        columnWidth: this.settings.slicerText.width,
	                        orientation: this.settings.general.orientation,
	                        rows: this.settings.general.rows,
	                        columns: this.settings.general.columns,
	                        enter: rowEnter,
	                        exit: rowExit,
	                        update: rowUpdate,
	                        loadMoreData: function () { return _this.onLoadMoreData(); },
	                        scrollEnabled: true,
	                        viewport: this.getSlicerBodyViewport(this.currentViewport),
	                        baseContainer: this.slicerBody,
	                    };
	                    this.tableView = TableViewFactory.createTableView(tableViewOptions);
	                };
	                ChicletSlicer.prototype.createSearchHeader = function (container) {
	                    var _this = this;
	                    this.searchHeader = $("<div>")
	                        .appendTo(container)
	                        .addClass("searchHeader")
	                        .addClass("collapsed");
	                    $("<div>").appendTo(this.searchHeader)
	                        .attr("title", "Search")
	                        .addClass("search");
	                    var counter = 0;
	                    this.searchInput = $("<input>").appendTo(this.searchHeader)
	                        .attr("type", "text")
	                        .attr("drag-resize-disabled", "true")
	                        .addClass("searchInput")
	                        .on("input", function () { return _this.hostServices.persistProperties({
	                        merge: [{
	                                objectName: "general",
	                                selector: null,
	                                properties: {
	                                    counter: counter++
	                                } }]
	                    }); });
	                };
	                ChicletSlicer.prototype.updateSearchHeader = function () {
	                    this.searchHeader.toggleClass("show", this.slicerData.slicerSettings.general.selfFilterEnabled);
	                    this.searchHeader.toggleClass("collapsed", !this.slicerData.slicerSettings.general.selfFilterEnabled);
	                };
	                ChicletSlicer.prototype.onLoadMoreData = function () {
	                    if (!this.waitingForData && this.dataView.metadata && this.dataView.metadata.segment) {
	                        this.hostServices.loadMoreData();
	                        this.waitingForData = true;
	                    }
	                };
	                ChicletSlicer.prototype.getSlicerBodyViewport = function (currentViewport) {
	                    var settings = this.settings;
	                    var headerHeight = (settings.header.show) ? this.getHeaderHeight() : 0;
	                    var slicerBodyHeight = currentViewport.height - (headerHeight + settings.header.borderBottomWidth);
	                    return {
	                        height: slicerBodyHeight,
	                        width: currentViewport.width
	                    };
	                };
	                ChicletSlicer.prototype.updateSlicerBodyDimensions = function () {
	                    var slicerViewport = this.getSlicerBodyViewport(this.currentViewport);
	                    this.slicerBody
	                        .style({
	                        'height': PixelConverter.toString(slicerViewport.height),
	                        'width': '100%',
	                    });
	                };
	                ChicletSlicer.getChicletTextProperties = function (textSize) {
	                    return {
	                        fontFamily: ChicletSlicer.DefaultFontFamily,
	                        fontSize: PixelConverter.fromPoint(textSize || ChicletSlicer.DefaultFontSizeInPt),
	                    };
	                };
	                ChicletSlicer.prototype.getHeaderHeight = function () {
	                    return powerbi.TextMeasurementService.estimateSvgTextHeight(ChicletSlicer.getChicletTextProperties(this.settings.header.textSize));
	                };
	                ChicletSlicer.prototype.getRowHeight = function () {
	                    var textSettings = this.settings.slicerText;
	                    return textSettings.height !== 0
	                        ? textSettings.height
	                        : powerbi.TextMeasurementService.estimateSvgTextHeight(ChicletSlicer.getChicletTextProperties(textSettings.textSize));
	                };
	                ChicletSlicer.prototype.getBorderStyle = function (outlineElement) {
	                    return outlineElement === '0px' ? 'none' : 'solid';
	                };
	                ChicletSlicer.prototype.getBorderWidth = function (outlineElement, outlineWeight) {
	                    switch (outlineElement) {
	                        case 'None':
	                            return '0px';
	                        case 'BottomOnly':
	                            return '0px 0px ' + outlineWeight + 'px 0px';
	                        case 'TopOnly':
	                            return outlineWeight + 'px 0px 0px 0px';
	                        case 'TopBottom':
	                            return outlineWeight + 'px 0px ' + outlineWeight + 'px 0px';
	                        case 'LeftRight':
	                            return '0px ' + outlineWeight + 'px 0px ' + outlineWeight + 'px';
	                        case 'Frame':
	                            return outlineWeight + 'px';
	                        default:
	                            return outlineElement.replace("1", outlineWeight.toString());
	                    }
	                };
	                ChicletSlicer.prototype.getBorderRadius = function (borderType) {
	                    switch (borderType) {
	                        case ChicletBorderStyle.ROUNDED:
	                            return "10px";
	                        case ChicletBorderStyle.SQUARE:
	                            return "0px";
	                        default:
	                            return "5px";
	                    }
	                };
	                ChicletSlicer.capabilities = {
	                    dataRoles: [
	                        {
	                            name: 'Category',
	                            kind: powerbi.VisualDataRoleKind.Grouping,
	                            displayName: 'Category',
	                        },
	                        {
	                            name: 'Values',
	                            kind: powerbi.VisualDataRoleKind.Measure,
	                            displayName: 'Values',
	                        },
	                        {
	                            name: 'Image',
	                            kind: powerbi.VisualDataRoleKind.Grouping,
	                            displayName: 'Image',
	                        },
	                    ],
	                    objects: {
	                        general: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
	                            properties: {
	                                selection: {
	                                    displayName: "Selection",
	                                    type: { text: true }
	                                },
	                                orientation: {
	                                    displayName: 'Orientation',
	                                    type: { enumeration: Orientation.type }
	                                },
	                                columns: {
	                                    displayName: 'Columns',
	                                    type: { numeric: true }
	                                },
	                                rows: {
	                                    displayName: 'Rows',
	                                    type: { numeric: true }
	                                },
	                                showDisabled: {
	                                    displayName: 'Show Disabled',
	                                    type: { enumeration: ChicletSlicerShowDisabled.type }
	                                },
	                                multiselect: {
	                                    displayName: 'Multiple selection',
	                                    type: { bool: true }
	                                },
	                                selected: {
	                                    type: { bool: true }
	                                },
	                                filter: {
	                                    type: { filter: {} },
	                                },
	                                selfFilter: {
	                                    type: { filter: { selfFilter: true } },
	                                },
	                                selfFilterEnabled: {
	                                    type: { operations: { searchEnabled: true } }
	                                },
	                                formatString: {
	                                    type: { formatting: { formatString: true } },
	                                },
	                            },
	                        },
	                        header: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Header'),
	                            properties: {
	                                show: {
	                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
	                                    type: { bool: true }
	                                },
	                                title: {
	                                    displayName: 'Title',
	                                    type: { text: true }
	                                },
	                                fontColor: {
	                                    displayName: powerbi.data.createDisplayNameGetter('Visual_FontColor'),
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                background: {
	                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Background'),
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                outline: {
	                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Outline'),
	                                    type: { formatting: { outline: true } }
	                                },
	                                textSize: {
	                                    displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
	                                    type: { numeric: true }
	                                },
	                                outlineColor: {
	                                    displayName: 'Outline Color',
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                outlineWeight: {
	                                    displayName: 'Outline Weight',
	                                    type: { numeric: true }
	                                }
	                            }
	                        },
	                        rows: {
	                            displayName: 'Chiclets',
	                            properties: {
	                                fontColor: {
	                                    displayName: 'Text color',
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                textSize: {
	                                    displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
	                                    type: { numeric: true }
	                                },
	                                height: {
	                                    displayName: 'Height',
	                                    type: { numeric: true }
	                                },
	                                width: {
	                                    displayName: 'Width',
	                                    type: { numeric: true }
	                                },
	                                selectedColor: {
	                                    displayName: 'Selected Color',
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                hoverColor: {
	                                    displayName: 'Hover Color',
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                unselectedColor: {
	                                    displayName: 'Unselected Color',
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                disabledColor: {
	                                    displayName: 'Disabled Color',
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                background: {
	                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Background'),
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                transparency: {
	                                    displayName: "Transparency",
	                                    description: "Set transparency for background color",
	                                    type: { numeric: true }
	                                },
	                                outline: {
	                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Outline'),
	                                    type: { formatting: { outline: true } }
	                                },
	                                outlineColor: {
	                                    displayName: 'Outline Color',
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                outlineWeight: {
	                                    displayName: 'Outline Weight',
	                                    type: { numeric: true }
	                                },
	                                borderStyle: {
	                                    displayName: 'Outline Style',
	                                    type: { enumeration: ChicletBorderStyle.type }
	                                },
	                            }
	                        },
	                        images: {
	                            displayName: 'Images',
	                            properties: {
	                                imageSplit: {
	                                    displayName: 'Image Split',
	                                    type: { numeric: true }
	                                },
	                                stretchImage: {
	                                    displayName: 'Stretch image',
	                                    type: { bool: true }
	                                },
	                                bottomImage: {
	                                    displayName: 'Bottom image',
	                                    type: { bool: true }
	                                },
	                            }
	                        },
	                    },
	                    dataViewMappings: [{
	                            conditions: [
	                                { 'Category': { max: 1 }, 'Image': { min: 0, max: 1 }, 'Values': { min: 0, max: 1 } }],
	                            categorical: {
	                                categories: {
	                                    for: { in: 'Category' },
	                                    dataReductionAlgorithm: { top: { count: 10000 } }
	                                },
	                                values: {
	                                    group: {
	                                        by: 'Image',
	                                        select: [{ bind: { to: 'Values' } },
	                                        ],
	                                        dataReductionAlgorithm: { top: { count: 10000 } }
	                                    }
	                                },
	                                includeEmptyGroups: true
	                            }
	                        }],
	                    supportsHighlight: true,
	                    sorting: {
	                        default: {},
	                    },
	                    suppressDefaultTitle: true,
	                };
	                ChicletSlicer.DefaultFontFamily = 'Segoe UI, Tahoma, Verdana, Geneva, sans-serif';
	                ChicletSlicer.DefaultFontSizeInPt = 11;
	                ChicletSlicer.cellTotalInnerPaddings = 8;
	                ChicletSlicer.cellTotalInnerBorders = 2;
	                ChicletSlicer.chicletTotalInnerRightLeftPaddings = 14;
	                ChicletSlicer.MinImageSplit = 0;
	                ChicletSlicer.MaxImageSplit = 100;
	                ChicletSlicer.ItemContainer = createClassAndSelector('slicerItemContainer');
	                ChicletSlicer.HeaderText = createClassAndSelector('headerText');
	                ChicletSlicer.Container = createClassAndSelector('chicletSlicer');
	                ChicletSlicer.LabelText = createClassAndSelector('slicerText');
	                ChicletSlicer.Header = createClassAndSelector('slicerHeader');
	                ChicletSlicer.Input = createClassAndSelector('slicerCheckbox');
	                ChicletSlicer.Clear = createClassAndSelector('clear');
	                ChicletSlicer.Body = createClassAndSelector('slicerBody');
	                return ChicletSlicer;
	            }());
	            samples.ChicletSlicer = ChicletSlicer;
	            var ChicletSlicerChartConversion;
	            (function (ChicletSlicerChartConversion) {
	                var ChicletSlicerConverter = (function () {
	                    function ChicletSlicerConverter(dataView, interactivityService) {
	                        var dataViewCategorical = dataView.categorical;
	                        this.dataViewCategorical = dataViewCategorical;
	                        this.dataViewMetadata = dataView.metadata;
	                        if (dataViewCategorical.categories && dataViewCategorical.categories.length > 0) {
	                            this.category = dataViewCategorical.categories[0];
	                            this.categoryIdentities = this.category.identity;
	                            this.categoryValues = this.category.values;
	                            this.categoryColumnRef = this.category.identityFields;
	                            this.categoryFormatString = visuals.valueFormatter.getFormatString(this.category.source, samples.chicletSlicerProps.formatString);
	                        }
	                        this.dataPoints = [];
	                        this.interactivityService = interactivityService;
	                        this.hasSelectionOverride = false;
	                    }
	                    ChicletSlicerConverter.prototype.convert = function () {
	                        this.dataPoints = [];
	                        this.numberOfCategoriesSelectedInData = 0;
	                        // If category exists, we render labels using category values. If not, we render labels
	                        // using measure labels.
	                        if (this.categoryValues) {
	                            var objects = this.dataViewMetadata ? this.dataViewMetadata.objects : undefined;
	                            var isInvertedSelectionMode = undefined;
	                            var numberOfScopeIds;
	                            if (objects && objects.general && objects.general.filter) {
	                                if (!this.categoryColumnRef)
	                                    return;
	                                var filter = objects.general.filter;
	                                var scopeIds = SQExprConverter.asScopeIdsContainer(filter, this.categoryColumnRef);
	                                if (scopeIds) {
	                                    isInvertedSelectionMode = scopeIds.isNot;
	                                    numberOfScopeIds = scopeIds.scopeIds ? scopeIds.scopeIds.length : 0;
	                                }
	                                else {
	                                    isInvertedSelectionMode = false;
	                                }
	                            }
	                            if (this.interactivityService) {
	                                if (isInvertedSelectionMode === undefined) {
	                                    // The selection state is read from the Interactivity service in case of SelectAll or Clear when query doesn't update the visual
	                                    isInvertedSelectionMode = this.interactivityService.isSelectionModeInverted();
	                                }
	                                else {
	                                    this.interactivityService.setSelectionModeInverted(isInvertedSelectionMode);
	                                }
	                            }
	                            var hasSelection = undefined;
	                            for (var idx = 0; idx < this.categoryValues.length; idx++) {
	                                var selected = visuals.isCategoryColumnSelected(samples.chicletSlicerProps.selectedPropertyIdentifier, this.category, idx);
	                                if (selected != null) {
	                                    hasSelection = selected;
	                                    break;
	                                }
	                            }
	                            var dataViewCategorical = this.dataViewCategorical;
	                            var formatStringProp = samples.chicletSlicerProps.formatString;
	                            var value = -Infinity;
	                            var imageURL = '';
	                            for (var categoryIndex = 0, categoryCount = this.categoryValues.length; categoryIndex < categoryCount; categoryIndex++) {
	                                //var categoryIdentity = this.category.identity ? this.category.identity[categoryIndex] : null;
	                                var categoryIsSelected = visuals.isCategoryColumnSelected(samples.chicletSlicerProps.selectedPropertyIdentifier, this.category, categoryIndex);
	                                var selectable = true;
	                                if (hasSelection != null) {
	                                    if (isInvertedSelectionMode) {
	                                        if (this.category.objects == null)
	                                            categoryIsSelected = undefined;
	                                        if (categoryIsSelected != null) {
	                                            categoryIsSelected = hasSelection;
	                                        }
	                                        else if (categoryIsSelected == null)
	                                            categoryIsSelected = !hasSelection;
	                                    }
	                                    else {
	                                        if (categoryIsSelected == null) {
	                                            categoryIsSelected = !hasSelection;
	                                        }
	                                    }
	                                }
	                                if (categoryIsSelected) {
	                                    this.numberOfCategoriesSelectedInData++;
	                                }
	                                var categoryValue = this.categoryValues[categoryIndex];
	                                var categoryLabel = visuals.valueFormatter.format(categoryValue, this.categoryFormatString);
	                                if (this.dataViewCategorical.values) {
	                                    // Series are either measures in the multi-measure case, or the single series otherwise
	                                    for (var seriesIndex = 0; seriesIndex < this.dataViewCategorical.values.length; seriesIndex++) {
	                                        var seriesData = dataViewCategorical.values[seriesIndex];
	                                        if (seriesData.values[categoryIndex] != null) {
	                                            value = seriesData.values[categoryIndex];
	                                            if (seriesData.highlights) {
	                                                selectable = !(seriesData.highlights[categoryIndex] === null);
	                                            }
	                                            if (seriesData.source.groupName && seriesData.source.groupName !== '') {
	                                                imageURL = visuals.converterHelper.getFormattedLegendLabel(seriesData.source, dataViewCategorical.values, formatStringProp);
	                                                if (!/^(ftp|http|https):\/\/[^ "]+$/.test(imageURL)) {
	                                                    imageURL = undefined;
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                                var categorySelectionId = SelectionIdBuilder.builder().withCategory(this.category, categoryIndex).createSelectionId();
	                                this.dataPoints.push({
	                                    identity: categorySelectionId,
	                                    category: categoryLabel,
	                                    imageURL: imageURL,
	                                    value: value,
	                                    selected: categoryIsSelected,
	                                    selectable: selectable
	                                });
	                            }
	                            if (numberOfScopeIds != null && numberOfScopeIds > this.numberOfCategoriesSelectedInData) {
	                                this.hasSelectionOverride = true;
	                            }
	                        }
	                    };
	                    return ChicletSlicerConverter;
	                }());
	                ChicletSlicerChartConversion.ChicletSlicerConverter = ChicletSlicerConverter;
	            })(ChicletSlicerChartConversion || (ChicletSlicerChartConversion = {}));
	            //TODO: This module should be removed once TextMeasruementService exports the "estimateSvgTextBaselineDelta" function.
	            var ChicletSlicerTextMeasurementHelper;
	            (function (ChicletSlicerTextMeasurementHelper) {
	                var spanElement;
	                var svgTextElement;
	                var canvasCtx;
	                function estimateSvgTextBaselineDelta(textProperties) {
	                    var rect = estimateSvgTextRect(textProperties);
	                    return rect.y + rect.height;
	                }
	                ChicletSlicerTextMeasurementHelper.estimateSvgTextBaselineDelta = estimateSvgTextBaselineDelta;
	                function ensureDOM() {
	                    if (spanElement)
	                        return;
	                    spanElement = $('<span/>');
	                    $('body').append(spanElement);
	                    //The style hides the svg element from the canvas, preventing canvas from scrolling down to show svg black square.
	                    svgTextElement = d3.select($('body').get(0))
	                        .append('svg')
	                        .style({
	                        'height': '0px',
	                        'width': '0px',
	                        'position': 'absolute'
	                    })
	                        .append('text');
	                    canvasCtx = $('<canvas/>').get(0).getContext("2d");
	                }
	                function measureSvgTextRect(textProperties) {
	                    debug.assertValue(textProperties, 'textProperties');
	                    ensureDOM();
	                    svgTextElement.style(null);
	                    svgTextElement
	                        .text(textProperties.text)
	                        .attr({
	                        'visibility': 'hidden',
	                        'font-family': textProperties.fontFamily,
	                        'font-size': textProperties.fontSize,
	                        'font-weight': textProperties.fontWeight,
	                        'font-style': textProperties.fontStyle,
	                        'white-space': textProperties.whiteSpace || 'nowrap'
	                    });
	                    // We're expecting the browser to give a synchronous measurement here
	                    // We're using SVGTextElement because it works across all browsers
	                    return svgTextElement.node().getBBox();
	                }
	                function estimateSvgTextRect(textProperties) {
	                    debug.assertValue(textProperties, 'textProperties');
	                    var estimatedTextProperties = {
	                        fontFamily: textProperties.fontFamily,
	                        fontSize: textProperties.fontSize,
	                        text: "M",
	                    };
	                    var rect = measureSvgTextRect(estimatedTextProperties);
	                    return rect;
	                }
	            })(ChicletSlicerTextMeasurementHelper = samples.ChicletSlicerTextMeasurementHelper || (samples.ChicletSlicerTextMeasurementHelper = {}));
	            var ChicletSlicerWebBehavior = (function () {
	                function ChicletSlicerWebBehavior() {
	                }
	                ChicletSlicerWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
	                    var _this = this;
	                    var slicers = this.slicers = options.slicerItemContainers;
	                    this.slicerItemLabels = options.slicerItemLabels;
	                    this.slicerItemInputs = options.slicerItemInputs;
	                    var slicerClear = options.slicerClear;
	                    this.dataPoints = options.dataPoints;
	                    this.interactivityService = options.interactivityService;
	                    this.slicerSettings = options.slicerSettings;
	                    this.options = options;
	                    if (!this.options.isSelectionLoaded) {
	                        this.loadSelection(selectionHandler);
	                    }
	                    slicers.on("mouseover", function (d) {
	                        if (d.selectable) {
	                            d.mouseOver = true;
	                            d.mouseOut = false;
	                            _this.renderMouseover();
	                        }
	                    });
	                    slicers.on("mouseout", function (d) {
	                        if (d.selectable) {
	                            d.mouseOver = false;
	                            d.mouseOut = true;
	                            _this.renderMouseover();
	                        }
	                    });
	                    slicers.on("click", function (d, index) {
	                        if (!d.selectable) {
	                            return;
	                        }
	                        var settings = _this.slicerSettings;
	                        d3.event.preventDefault();
	                        if (d3.event.altKey && settings.general.multiselect) {
	                            var selectedIndexes = jQuery.map(_this.dataPoints, function (d, index) { if (d.selected)
	                                return index; });
	                            var selIndex = selectedIndexes.length > 0 ? (selectedIndexes[selectedIndexes.length - 1]) : 0;
	                            if (selIndex > index) {
	                                var temp = index;
	                                index = selIndex;
	                                selIndex = temp;
	                            }
	                            selectionHandler.handleClearSelection();
	                            for (var i = selIndex; i <= index; i++) {
	                                selectionHandler.handleSelection(_this.dataPoints[i], true /* isMultiSelect */);
	                            }
	                        }
	                        else if (d3.event.ctrlKey && settings.general.multiselect) {
	                            selectionHandler.handleSelection(d, true /* isMultiSelect */);
	                        }
	                        else {
	                            selectionHandler.handleSelection(d, false /* isMultiSelect */);
	                        }
	                        _this.saveSelection(selectionHandler);
	                    });
	                    slicerClear.on("click", function (d) {
	                        selectionHandler.handleClearSelection();
	                        _this.saveSelection(selectionHandler);
	                    });
	                };
	                ChicletSlicerWebBehavior.prototype.loadSelection = function (selectionHandler) {
	                    selectionHandler.handleClearSelection();
	                    var savedSelectionIds = this.slicerSettings.general.getSavedSelection();
	                    if (savedSelectionIds.length) {
	                        var selectedDataPoints = this.dataPoints.filter(function (d) { return savedSelectionIds.some(function (x) { return d.identity.getKey() === x; }); });
	                        selectedDataPoints.forEach(function (x) { return selectionHandler.handleSelection(x, true); });
	                        selectionHandler.persistSelectionFilter(samples.chicletSlicerProps.filterPropertyIdentifier);
	                    }
	                };
	                ChicletSlicerWebBehavior.getFilterFromSelectors = function (selectionHandler, isSelectionModeInverted) {
	                    var selectors = [];
	                    var selectedIds = selectionHandler.selectedIds;
	                    if (selectedIds.length > 0) {
	                        selectors = _.chain(selectedIds)
	                            .filter(function (value) { return value.hasIdentity(); })
	                            .map(function (value) { return value.getSelector(); })
	                            .value();
	                    }
	                    var filter = powerbi.data.Selector.filterFromSelector(selectors, isSelectionModeInverted);
	                    return filter;
	                };
	                ChicletSlicerWebBehavior.prototype.saveSelection = function (selectionHandler) {
	                    var filter = ChicletSlicerWebBehavior.getFilterFromSelectors(selectionHandler, this.interactivityService.isSelectionModeInverted());
	                    var selectionIdKeys = selectionHandler.selectedIds.map(function (x) { return x.getKey(); });
	                    this.slicerSettings.general.setSavedSelection(filter, selectionIdKeys);
	                };
	                ChicletSlicerWebBehavior.prototype.renderSelection = function (hasSelection) {
	                    if (!hasSelection && !this.interactivityService.isSelectionModeInverted()) {
	                        this.slicers.style('background', this.slicerSettings.slicerText.unselectedColor);
	                    }
	                    else {
	                        this.styleSlicerInputs(this.slicers, hasSelection);
	                    }
	                };
	                ChicletSlicerWebBehavior.prototype.renderMouseover = function () {
	                    var _this = this;
	                    this.slicerItemLabels.style({
	                        'color': function (d) {
	                            if (d.mouseOver)
	                                return _this.slicerSettings.slicerText.hoverColor;
	                            if (d.mouseOut) {
	                                if (d.selected)
	                                    return _this.slicerSettings.slicerText.fontColor;
	                                else
	                                    return _this.slicerSettings.slicerText.fontColor;
	                            }
	                        }
	                    });
	                };
	                ChicletSlicerWebBehavior.prototype.styleSlicerInputs = function (slicers, hasSelection) {
	                    var settings = this.slicerSettings;
	                    var selectedItems = [];
	                    slicers.each(function (d) {
	                        // get selected items
	                        if (d.selectable && d.selected) {
	                            selectedItems.push(d);
	                        }
	                        d3.select(this).style({
	                            'background': d.selectable ? (d.selected ? settings.slicerText.selectedColor : settings.slicerText.unselectedColor)
	                                : settings.slicerText.disabledColor
	                        });
	                        d3.select(this).classed('slicerItem-disabled', !d.selectable);
	                    });
	                };
	                return ChicletSlicerWebBehavior;
	            }());
	            samples.ChicletSlicerWebBehavior = ChicletSlicerWebBehavior;
	            var explore;
	            (function (explore) {
	                var util;
	                (function (util) {
	                    function hexToRGBString(hex, transparency) {
	                        // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
	                        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
	                        hex = hex.replace(shorthandRegex, function (m, r, g, b) {
	                            return r + r + g + g + b + b;
	                        });
	                        // Hex format which return the format r-g-b
	                        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
	                        var rgb = result ? {
	                            r: parseInt(result[1], 16),
	                            g: parseInt(result[2], 16),
	                            b: parseInt(result[3], 16)
	                        } : null;
	                        // Wrong input
	                        if (rgb === null) {
	                            return '';
	                        }
	                        if (!transparency && transparency !== 0) {
	                            return "rgb(" + rgb.r + "," + rgb.g + "," + rgb.b + ")";
	                        }
	                        else {
	                            return "rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + "," + transparency + ")";
	                        }
	                    }
	                    util.hexToRGBString = hexToRGBString;
	                })(util = explore.util || (explore.util = {}));
	            })(explore || (explore = {}));
	        })(samples = visuals.samples || (visuals.samples = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 45 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../../../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var samples;
	        (function (samples) {
	            var PixelConverter = jsCommon.PixelConverter;
	            var createEnumType = powerbi.createEnumType;
	            var DataViewObjects = powerbi.DataViewObjects;
	            var ObjectEnumerationBuilder = powerbi.visuals.ObjectEnumerationBuilder;
	            var dataLabelUtils = powerbi.visuals.dataLabelUtils;
	            var converterHelper = powerbi.visuals.converterHelper;
	            var VisualDataRoleKind = powerbi.VisualDataRoleKind;
	            var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
	            var SelectionManager = powerbi.visuals.utility.SelectionManager;
	            var ColorHelper = powerbi.visuals.ColorHelper;
	            var valueFormatter = powerbi.visuals.valueFormatter;
	            var SelectionId = powerbi.visuals.SelectionId;
	            var SelectionIdBuilder = powerbi.visuals.SelectionIdBuilder;
	            var TooltipBuilder = powerbi.visuals.TooltipBuilder;
	            var AnimatorCommon = powerbi.visuals.AnimatorCommon;
	            var DataLabelManager = powerbi.DataLabelManager;
	            var shapes = powerbi.visuals.shapes;
	            var SVGUtil = powerbi.visuals.SVGUtil;
	            var TooltipManager = powerbi.visuals.TooltipManager;
	            var lessWithPrecision = powerbi.Double.lessWithPrecision;
	            var VisualLayout = (function () {
	                function VisualLayout(defaultViewport, defaultMargin) {
	                    this.defaultViewport = defaultViewport || { width: 0, height: 0 };
	                    this.defaultMargin = defaultMargin || { top: 0, bottom: 0, right: 0, left: 0 };
	                }
	                Object.defineProperty(VisualLayout.prototype, "margin", {
	                    get: function () {
	                        return this.marginValue || (this.margin = this.defaultMargin);
	                    },
	                    set: function (value) {
	                        this.marginValue = VisualLayout.restrictToMinMax(value);
	                        this.update();
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(VisualLayout.prototype, "viewport", {
	                    get: function () {
	                        return this.viewportValue || (this.viewportValue = this.defaultViewport);
	                    },
	                    set: function (value) {
	                        this.viewportValue = VisualLayout.restrictToMinMax(value, this.minViewport);
	                        this.update();
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(VisualLayout.prototype, "viewportIn", {
	                    get: function () {
	                        return this.viewportInValue || this.viewport;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(VisualLayout.prototype, "minViewport", {
	                    get: function () {
	                        return this.minViewportValue;
	                    },
	                    set: function (value) {
	                        this.minViewportValue = value;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(VisualLayout.prototype, "viewportInIsZero", {
	                    get: function () {
	                        return this.viewportIn.width === 0 || this.viewportIn.height === 0;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                VisualLayout.prototype.resetMargin = function () {
	                    this.margin = this.defaultMargin;
	                };
	                VisualLayout.prototype.update = function () {
	                    this.viewportInValue = VisualLayout.restrictToMinMax({
	                        width: this.viewport.width - (this.margin.left + this.margin.right),
	                        height: this.viewport.height - (this.margin.top + this.margin.bottom)
	                    }, this.minViewportValue);
	                };
	                VisualLayout.restrictToMinMax = function (value, minValue) {
	                    var result = $.extend({}, value);
	                    _.keys(value).forEach(function (x) { return result[x] = Math.max(minValue && minValue[x] || 0, value[x]); });
	                    return result;
	                };
	                return VisualLayout;
	            }());
	            var ChordChartHelpers = (function () {
	                function ChordChartHelpers() {
	                }
	                ChordChartHelpers.interpolateArc = function (arc) {
	                    return function (data) {
	                        if (!this.oldData) {
	                            this.oldData = data;
	                            return function () { return arc(data); };
	                        }
	                        var interpolation = d3.interpolate(this.oldData, data);
	                        this.oldData = interpolation(0);
	                        return function (x) { return arc(interpolation(x)); };
	                    };
	                };
	                ChordChartHelpers.addContext = function (context, fn) {
	                    return function () {
	                        return fn.apply(context, [this].concat(_.toArray(arguments)));
	                    };
	                };
	                return ChordChartHelpers;
	            }());
	            var ChordChartSettings = (function () {
	                function ChordChartSettings() {
	                    //Default Settings
	                    this.dataPoint = {
	                        defaultColor: null,
	                        showAllDataPoints: false
	                    };
	                    this.axis = {
	                        show: true
	                    };
	                    this.labels = {
	                        show: true,
	                        color: dataLabelUtils.defaultLabelColor,
	                        fontSize: dataLabelUtils.DefaultFontSizeInPt
	                    };
	                }
	                Object.defineProperty(ChordChartSettings, "Default", {
	                    get: function () {
	                        return new this();
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                ChordChartSettings.parse = function (dataView, capabilities) {
	                    var settings = new this();
	                    if (!dataView || !dataView.metadata || !dataView.metadata.objects) {
	                        return settings;
	                    }
	                    var properties = this.getProperties(capabilities);
	                    for (var objectKey in capabilities.objects) {
	                        for (var propKey in capabilities.objects[objectKey].properties) {
	                            if (!settings[objectKey] || !_.has(settings[objectKey], propKey)) {
	                                continue;
	                            }
	                            var type = capabilities.objects[objectKey].properties[propKey].type;
	                            var getValueFn = this.getValueFnByType(type);
	                            settings[objectKey][propKey] = getValueFn(dataView.metadata.objects, properties[objectKey][propKey], settings[objectKey][propKey]);
	                        }
	                    }
	                    return settings;
	                };
	                ChordChartSettings.getProperties = function (capabilities) {
	                    var objects = _.merge({
	                        general: { properties: { formatString: {} } }
	                    }, capabilities.objects);
	                    var properties = {};
	                    for (var objectKey in objects) {
	                        properties[objectKey] = {};
	                        for (var propKey in objects[objectKey].properties) {
	                            properties[objectKey][propKey] = {
	                                objectName: objectKey,
	                                propertyName: propKey
	                            };
	                        }
	                    }
	                    return properties;
	                };
	                ChordChartSettings.createEnumTypeFromEnum = function (type) {
	                    var even = false;
	                    return createEnumType(Object.keys(type)
	                        .filter(function (key, i) { return ((!!(i % 2)) === even && type[key] === key
	                        && !void (even = !even)) || (!!(i % 2)) !== even; })
	                        .map(function (x) { return { value: x, displayName: x }; }));
	                };
	                ChordChartSettings.getValueFnByType = function (type) {
	                    switch (_.keys(type)[0]) {
	                        case "fill":
	                            return DataViewObjects.getFillColor;
	                        default:
	                            return DataViewObjects.getValue;
	                    }
	                };
	                ChordChartSettings.enumerateObjectInstances = function (settings, options, capabilities) {
	                    var enumeration = new ObjectEnumerationBuilder();
	                    var object = settings && settings[options.objectName];
	                    if (!object) {
	                        return enumeration;
	                    }
	                    var instance = {
	                        objectName: options.objectName,
	                        selector: null,
	                        properties: {}
	                    };
	                    for (var key in object) {
	                        if (_.has(object, key)) {
	                            instance.properties[key] = object[key];
	                        }
	                    }
	                    enumeration.pushInstance(instance);
	                    return enumeration;
	                };
	                return ChordChartSettings;
	            }());
	            samples.ChordChartSettings = ChordChartSettings;
	            var ChordChartColumns = (function () {
	                function ChordChartColumns() {
	                    //Data Roles
	                    this.Category = null;
	                    this.Series = null;
	                    this.Y = null;
	                }
	                ChordChartColumns.getColumnSources = function (dataView) {
	                    return this.getColumnSourcesT(dataView);
	                };
	                ChordChartColumns.getTableValues = function (dataView) {
	                    var table = dataView && dataView.table;
	                    var columns = this.getColumnSourcesT(dataView);
	                    return columns && table && _.mapValues(columns, function (n, i) { return n && table.rows.map(function (row) { return row[n.index]; }); });
	                };
	                ChordChartColumns.getTableRows = function (dataView) {
	                    var table = dataView && dataView.table;
	                    var columns = this.getColumnSourcesT(dataView);
	                    return columns && table && table.rows.map(function (row) {
	                        return _.mapValues(columns, function (n, i) { return n && row[n.index]; });
	                    });
	                };
	                ChordChartColumns.getCategoricalValues = function (dataView) {
	                    var categorical = dataView && dataView.categorical;
	                    var categories = categorical && categorical.categories || [];
	                    var values = categorical && categorical.values || [];
	                    var series = categorical && values.source && this.getSeriesValues(dataView);
	                    return categorical && _.mapValues(new this(), function (n, i) {
	                        return _.toArray(categories).concat(_.toArray(values))
	                            .filter(function (x) { return x.source.roles && x.source.roles[i]; }).map(function (x) { return x.values; })[0]
	                            || values.source && values.source.roles && values.source.roles[i] && series;
	                    });
	                };
	                ChordChartColumns.getSeriesValues = function (dataView) {
	                    return dataView && dataView.categorical && dataView.categorical.values
	                        && dataView.categorical.values.map(function (x) { return converterHelper.getSeriesName(x.source); });
	                };
	                ChordChartColumns.getCategoricalColumns = function (dataView) {
	                    var categorical = dataView && dataView.categorical;
	                    var categories = categorical && categorical.categories || [];
	                    var values = categorical && categorical.values || [];
	                    return categorical && _.mapValues(new this(), function (n, i) { return categories.filter(function (x) { return x.source.roles && x.source.roles[i]; })[0]
	                        || values.source && values.source.roles && values.source.roles[i]
	                        || values.filter(function (x) { return x.source.roles && x.source.roles[i]; }); });
	                };
	                ChordChartColumns.getColumnSourcesT = function (dataView) {
	                    var columns = dataView && dataView.metadata && dataView.metadata.columns;
	                    return columns && _.mapValues(new this(), function (n, i) { return columns.filter(function (x) { return x.roles && x.roles[i]; })[0]; });
	                };
	                ChordChartColumns.Roles = Object.freeze(_.mapValues(new ChordChartColumns(), function (x, i) { return i; }));
	                return ChordChartColumns;
	            }());
	            samples.ChordChartColumns = ChordChartColumns;
	            var ChordChart = (function () {
	                function ChordChart() {
	                }
	                Object.defineProperty(ChordChart.prototype, "settings", {
	                    get: function () {
	                        return this.data && this.data.settings;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(ChordChart.prototype, "innerRadius", {
	                    get: function () {
	                        return this.radius * ChordChart.InnerArcRadiusRatio;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(ChordChart.prototype, "outerRadius", {
	                    get: function () {
	                        return this.radius * ChordChart.OuterArcRadiusRatio;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                /* Convert a DataView into a view model */
	                ChordChart.converter = function (dataView, colors, prevAxisVisible) {
	                    var properties = ChordChartSettings.getProperties(ChordChart.capabilities);
	                    var settings = ChordChart.parseSettings(dataView);
	                    var columns = ChordChartColumns.getCategoricalColumns(dataView);
	                    var sources = ChordChartColumns.getColumnSources(dataView);
	                    var catValues = ChordChartColumns.getCategoricalValues(dataView);
	                    if (!catValues || _.isEmpty(catValues.Category) || _.isEmpty(catValues.Y)) {
	                        return null;
	                    }
	                    catValues.Series = catValues.Series || ChordChartColumns.getSeriesValues(dataView);
	                    var dataMatrix = [];
	                    var legendData = {
	                        dataPoints: [],
	                        title: sources.Y.displayName || "",
	                    };
	                    var toolTipData = [];
	                    var sliceTooltipData = [];
	                    var max = 1000;
	                    var seriesIndex = _.mapValues(_.invert(catValues.Series), parseFloat); /* series index array */
	                    var catIndex = _.mapValues(_.invert(catValues.Category), parseFloat); /* index array for category names */
	                    var isDiffFromTo = false; /* boolean variable indicates that From and To are different */
	                    var labelData = []; /* label data: !important */
	                    var colorHelper = new ColorHelper(colors, properties.dataPoint.fill, settings.dataPoint.defaultColor);
	                    var totalFields = this.union_arrays(catValues.Category, catValues.Series).reverse();
	                    if (ChordChart.getValidArrayLength(totalFields) ===
	                        ChordChart.getValidArrayLength(catValues.Category) + ChordChart.getValidArrayLength(catValues.Series)) {
	                        isDiffFromTo = true;
	                    }
	                    var categoryColumnFormatter = valueFormatter.create({
	                        format: valueFormatter.getFormatString(sources.Category, properties.general.formatString, true)
	                            || sources.Category.format
	                    });
	                    var valueColumnFormatter = valueFormatter.create({
	                        format: valueFormatter.getFormatString(sources.Y, properties.general.formatString, true)
	                            || sources.Y.format
	                    });
	                    for (var i = 0, iLen = totalFields.length; i < iLen; i++) {
	                        var id = null;
	                        var color = "";
	                        var isCategory = false;
	                        if (catIndex[totalFields[i]] !== undefined) {
	                            var index = catIndex[totalFields[i]];
	                            id = SelectionIdBuilder
	                                .builder()
	                                .withCategory(columns.Category, catIndex[totalFields[i]])
	                                .createSelectionId();
	                            isCategory = true;
	                            var thisCategoryObjects = columns.Category.objects ? columns.Category.objects[index] : undefined;
	                            color = colorHelper.getColorForSeriesValue(thisCategoryObjects, /* cat.identityFields */ undefined, catValues.Category[index]);
	                        }
	                        else if (seriesIndex[totalFields[i]] !== undefined) {
	                            var index = seriesIndex[totalFields[i]];
	                            var seriesData = columns.Y[index];
	                            var seriesObjects = seriesData && seriesData.objects && seriesData.objects[0];
	                            var seriesNameStr = converterHelper.getSeriesName(seriesData.source);
	                            id = SelectionId.createWithId(seriesData.identity);
	                            isCategory = false;
	                            color = colorHelper.getColorForSeriesValue(seriesObjects, /* values.identityFields */ undefined, seriesNameStr);
	                        }
	                        labelData.push({
	                            label: totalFields[i],
	                            labelColor: settings.labels.color,
	                            barColor: color,
	                            isCategory: isCategory,
	                            identity: id,
	                            selected: false,
	                            labelFontSize: PixelConverter.fromPointToPixel(settings.labels.fontSize)
	                        });
	                        dataMatrix.push([]);
	                        toolTipData.push([]);
	                        for (var j = 0, jLen = totalFields.length; j < jLen; j++) {
	                            var elementValue = 0;
	                            var tooltipInfo = [];
	                            if (catIndex[totalFields[i]] !== undefined &&
	                                seriesIndex[totalFields[j]] !== undefined) {
	                                var row = catIndex[totalFields[i]];
	                                var col = seriesIndex[totalFields[j]];
	                                if (columns.Y[col].values[row] !== null) {
	                                    elementValue = columns.Y[col].values[row];
	                                    if (elementValue > max)
	                                        max = elementValue;
	                                    tooltipInfo = TooltipBuilder.createTooltipInfo(properties.general.formatString, dataView.categorical, categoryColumnFormatter.format(catValues.Category[i]), valueColumnFormatter.format(elementValue), null, null, col, row);
	                                }
	                            }
	                            else if (isDiffFromTo && catIndex[totalFields[j]] !== undefined &&
	                                seriesIndex[totalFields[i]] !== undefined) {
	                                var row = catIndex[totalFields[j]];
	                                var col = seriesIndex[totalFields[i]];
	                                if (columns.Y[col].values[row] !== null) {
	                                    elementValue = columns.Y[col].values[row];
	                                }
	                            }
	                            dataMatrix[i].push(elementValue || 0);
	                            toolTipData[i].push({
	                                tooltipInfo: tooltipInfo
	                            });
	                        }
	                        var totalSum = d3.sum(dataMatrix[i]);
	                        sliceTooltipData.push({
	                            tooltipInfo: [{
	                                    displayName: totalFields[i],
	                                    value: valueColumnFormatter.format(totalSum)
	                                }]
	                        });
	                    }
	                    var chordLayout = d3.layout.chord()
	                        .padding(ChordChart.ChordLayoutPadding)
	                        .matrix(dataMatrix);
	                    var labelDataPoints, chordLayoutGroups = chordLayout.groups(), groups = ChordChart.copyArcDescriptorsWithoutNaNValues(chordLayoutGroups), chords = chordLayout.chords(), unitLength = Math.round(max / 5).toString().length - 1;
	                    labelDataPoints = ChordChart.getChordArcDescriptors(ChordChart.copyArcDescriptorsWithoutNaNValues(chordLayoutGroups), labelData);
	                    return {
	                        dataMatrix: dataMatrix,
	                        dataView: dataView,
	                        settings: settings,
	                        labelDataPoints: labelDataPoints,
	                        legendData: legendData,
	                        tooltipData: toolTipData,
	                        sliceTooltipData: sliceTooltipData,
	                        tickUnit: Math.pow(10, unitLength),
	                        differentFromTo: isDiffFromTo,
	                        prevAxisVisible: prevAxisVisible === undefined
	                            ? settings.axis.show
	                            : prevAxisVisible,
	                        groups: groups,
	                        chords: chords
	                    };
	                };
	                ChordChart.parseSettings = function (dataView) {
	                    return ChordChartSettings.parse(dataView, ChordChart.capabilities);
	                };
	                /* Check every element of the array and returns the count of elements which are valid(not undefined) */
	                ChordChart.getValidArrayLength = function (array) {
	                    var len = 0;
	                    for (var i = 0, iLen = array.length; i < iLen; i++) {
	                        if (array[i] !== undefined) {
	                            len++;
	                        }
	                    }
	                    return len;
	                };
	                ChordChart.getChordArcDescriptors = function (groups, datum) {
	                    groups.forEach(function (x, index) {
	                        x.data = datum[index];
	                    });
	                    return groups;
	                };
	                ChordChart.prototype.init = function (options) {
	                    var element = options.element;
	                    this.selectionManager = new SelectionManager({ hostServices: options.host });
	                    this.layout = new VisualLayout(options.viewport, ChordChart.DefaultMargin);
	                    this.layout.minViewport = { width: 150, height: 150 };
	                    this.svg = d3.select(element.get(0))
	                        .append("svg")
	                        .style("position", "absolute")
	                        .classed(ChordChart.VisualClassName, true);
	                    this.mainGraphicsContext = this.svg
	                        .append("g");
	                    this.mainGraphicsContext
	                        .append("g")
	                        .classed("chords", true);
	                    this.slices = this.mainGraphicsContext
	                        .append("g")
	                        .classed("slices", true);
	                    this.mainGraphicsContext
	                        .append("g")
	                        .classed("ticks", true);
	                    this.labels = this.mainGraphicsContext
	                        .append("g")
	                        .classed(ChordChart.labelGraphicsContextClass.class, true);
	                    this.lines = this.mainGraphicsContext
	                        .append("g")
	                        .classed(ChordChart.linesGraphicsContextClass.class, true);
	                    this.colors = options.style.colorPalette.dataColors;
	                };
	                /* Called for data, size, formatting changes*/
	                ChordChart.prototype.update = function (options) {
	                    // assert dataView
	                    if (!options.dataViews || !options.dataViews[0]) {
	                        return;
	                    }
	                    this.layout.viewport = options.viewport;
	                    this.duration = options.suppressAnimations
	                        ? 0
	                        : AnimatorCommon.MinervaAnimationDuration;
	                    this.data = ChordChart.converter(options.dataViews[0], this.colors, this.settings && this.settings.axis.show);
	                    if (!this.data) {
	                        this.clear();
	                        return;
	                    }
	                    this.layout.resetMargin();
	                    this.layout.margin.top = this.layout.margin.bottom = PixelConverter.fromPointToPixel(this.settings.labels.fontSize) / 2;
	                    this.render();
	                };
	                /* Enumerate format values */
	                ChordChart.prototype.enumerateObjectInstances = function (options) {
	                    var instances = ChordChartSettings.enumerateObjectInstances(this.settings, options, ChordChart.capabilities);
	                    if (this.settings
	                        && options.objectName === "dataPoint"
	                        && !_.isEmpty(this.data.labelDataPoints)
	                        && this.settings.dataPoint.showAllDataPoints) {
	                        for (var i = 0, length = this.data.labelDataPoints.length; i < length; i++) {
	                            var labelDataPoint = this.data.labelDataPoints[i].data;
	                            if (labelDataPoint.isCategory) {
	                                var colorInstance = {
	                                    objectName: "dataPoint",
	                                    displayName: labelDataPoint.label,
	                                    selector: ColorHelper.normalizeSelector(labelDataPoint.identity.getSelector()),
	                                    properties: {
	                                        fill: { solid: { color: labelDataPoint.barColor } }
	                                    }
	                                };
	                                instances.pushInstance(colorInstance);
	                            }
	                        }
	                    }
	                    return instances.complete();
	                };
	                /* Calculate radius */
	                ChordChart.prototype.calculateRadius = function () {
	                    if (this.settings.labels.show) {
	                        // if we have category or data labels, use a sigmoid to blend the desired denominator from 2 to 3.
	                        // if we are taller than we are wide, we need to use a larger denominator to leave horizontal room for the labels.
	                        var hw = this.layout.viewportIn.height / this.layout.viewportIn.width;
	                        var denom = 2 + (1 / (1 + Math.exp(-5 * (hw - 1))));
	                        return Math.min(this.layout.viewportIn.height, this.layout.viewportIn.width) / denom;
	                    }
	                    // no labels
	                    return Math.min(this.layout.viewportIn.height, this.layout.viewportIn.width) / 2;
	                };
	                ChordChart.prototype.drawCategoryLabels = function () {
	                    /** Multiplier to place the end point of the reference line at 0.05 * radius away from the outer edge of the chord/pie. */
	                    var arc = d3.svg.arc()
	                        .innerRadius(0)
	                        .outerRadius(this.innerRadius);
	                    var outerArc = d3.svg.arc()
	                        .innerRadius(this.outerRadius)
	                        .outerRadius(this.outerRadius);
	                    if (this.settings.labels.show) {
	                        var labelLayout = this.getChordChartLabelLayout(outerArc);
	                        var filteredData = this.getDataLabelManager().hideCollidedLabels(this.layout.viewportIn, this.data.labelDataPoints, labelLayout, 
	                        /* addTransform */ true);
	                        this.renderLabels(filteredData, labelLayout, true);
	                        this.renderLines(filteredData, arc, outerArc);
	                    }
	                    else {
	                        dataLabelUtils.cleanDataLabels(this.labels);
	                        dataLabelUtils.cleanDataLabels(this.lines, true);
	                    }
	                };
	                ChordChart.prototype.getDataLabelManager = function () {
	                    var dataLabelManager = new DataLabelManager();
	                    dataLabelManager.hasCollisions = hasCollisions.bind(dataLabelManager);
	                    return dataLabelManager;
	                    function hasCollisions(arrangeGrid, info, position, size) {
	                        if (arrangeGrid.hasConflict(position)) {
	                            return true;
	                        }
	                        var intersection = { left: 0, top: position.height / 2, width: size.width, height: size.height };
	                        intersection = shapes.Rect.inflate(intersection, {
	                            left: DataLabelManager.InflateAmount,
	                            top: 0,
	                            right: DataLabelManager.InflateAmount,
	                            bottom: 0
	                        });
	                        intersection = shapes.Rect.intersect(intersection, position);
	                        if (shapes.Rect.isEmpty(intersection)) {
	                            return true;
	                        }
	                        return lessWithPrecision(intersection.height, position.height / 2);
	                    }
	                };
	                ChordChart.prototype.render = function () {
	                    var _this = this;
	                    this.radius = this.calculateRadius();
	                    var arc = d3.svg.arc()
	                        .innerRadius(this.radius)
	                        .outerRadius(this.innerRadius);
	                    this.svg
	                        .attr({
	                        "width": this.layout.viewport.width,
	                        "height": this.layout.viewport.height
	                    });
	                    this.mainGraphicsContext
	                        .attr("transform", SVGUtil.translate(this.layout.viewport.width / 2, this.layout.viewport.height / 2));
	                    var sliceShapes = this.slices
	                        .selectAll("path" + ChordChart.sliceClass.selector)
	                        .data(this.getChordTicksArcDescriptors());
	                    sliceShapes.enter()
	                        .insert("path")
	                        .classed(ChordChart.sliceClass.class, true);
	                    sliceShapes.style("fill", function (d, i) { return _this.data.labelDataPoints[i].data.barColor; })
	                        .style("stroke", function (d, i) { return _this.data.labelDataPoints[i].data.barColor; })
	                        .on("click", ChordChartHelpers.addContext(this, function (context, d, i) {
	                        _this.selectionManager.select(_this.data.labelDataPoints[i].data.identity).then(function (ids) {
	                            if (ids.length > 0) {
	                                _this.mainGraphicsContext
	                                    .selectAll(".chords path.chord")
	                                    .style("opacity", 1);
	                                _this.slices
	                                    .selectAll("path.slice")
	                                    .style("opacity", 0.3);
	                                _this.mainGraphicsContext
	                                    .selectAll(".chords path.chord")
	                                    .filter(function (d) { return d.source.index !== i && d.target.index !== i; })
	                                    .style("opacity", 0.3);
	                                d3.select(context).style("opacity", 1);
	                            }
	                            else {
	                                sliceShapes.style("opacity", 1);
	                                _this.mainGraphicsContext
	                                    .selectAll(".chords path.chord")
	                                    .filter(function (d) { return d.source.index !== i && d.target.index !== i; })
	                                    .style("opacity", 1);
	                            }
	                        });
	                        d3.event.stopPropagation();
	                    }))
	                        .transition()
	                        .duration(this.duration)
	                        .attrTween("d", ChordChartHelpers.interpolateArc(arc));
	                    sliceShapes
	                        .exit()
	                        .remove();
	                    TooltipManager.addTooltip(sliceShapes, function (tooltipEvent) {
	                        return _this.data.sliceTooltipData[tooltipEvent.data.index].tooltipInfo;
	                    });
	                    var chordShapes = this.svg.select(".chords")
	                        .selectAll("path" + ChordChart.chordClass.selector)
	                        .data(this.data.chords);
	                    chordShapes
	                        .enter()
	                        .insert("path")
	                        .classed(ChordChart.chordClass.class, true);
	                    chordShapes
	                        .style({
	                        "fill": function (d) {
	                            return _this.data.labelDataPoints[d.target.index].data.barColor;
	                        },
	                        "opacity": 1
	                    })
	                        .transition()
	                        .duration(this.duration)
	                        .attr("d", d3.svg.chord().radius(this.radius));
	                    chordShapes
	                        .exit()
	                        .remove();
	                    this.svg
	                        .on("click", function () { return _this.selectionManager.clear().then(function () {
	                        sliceShapes.style("opacity", 1);
	                        chordShapes.style("opacity", 1);
	                    }); });
	                    this.drawTicks();
	                    this.drawCategoryLabels();
	                    TooltipManager.addTooltip(chordShapes, function (tooltipEvent) {
	                        var tooltipInfo = [];
	                        if (_this.data.differentFromTo) {
	                            tooltipInfo = _this.data.tooltipData[tooltipEvent.data.source.index][tooltipEvent.data.source.subindex]
	                                .tooltipInfo;
	                        }
	                        else {
	                            tooltipInfo.push({
	                                displayName: _this.data.labelDataPoints[tooltipEvent.data.source.index].data.label
	                                    + "->" + _this.data.labelDataPoints[tooltipEvent.data.source.subindex].data.label,
	                                value: _this.data.dataMatrix[tooltipEvent.data.source.index][tooltipEvent.data.source.subindex].toString()
	                            });
	                            tooltipInfo.push({
	                                displayName: _this.data.labelDataPoints[tooltipEvent.data.target.index].data.label
	                                    + "->" + _this.data.labelDataPoints[tooltipEvent.data.target.subindex].data.label,
	                                value: _this.data.dataMatrix[tooltipEvent.data.target.index][tooltipEvent.data.target.subindex].toString()
	                            });
	                        }
	                        return tooltipInfo;
	                    });
	                };
	                ChordChart.prototype.clear = function () {
	                    this.mainGraphicsContext
	                        .selectAll(ChordChart.sliceClass.selector)
	                        .remove();
	                    this.mainGraphicsContext
	                        .selectAll(ChordChart.sliceTicksClass.selector)
	                        .remove();
	                    this.mainGraphicsContext
	                        .selectAll(ChordChart.chordClass.selector)
	                        .remove();
	                    this.mainGraphicsContext
	                        .selectAll(ChordChart.labelsClass.selector)
	                        .remove();
	                    this.mainGraphicsContext
	                        .selectAll(ChordChart.lineClass.selector)
	                        .remove();
	                };
	                ChordChart.prototype.clearTicks = function () {
	                    var empty = [];
	                    var tickLines = this.mainGraphicsContext
	                        .selectAll(ChordChart.tickLineClass.selector)
	                        .data(empty);
	                    tickLines
	                        .exit()
	                        .remove();
	                    var tickTexts = this.mainGraphicsContext
	                        .selectAll(ChordChart.tickTextClass.selector)
	                        .data(empty);
	                    tickTexts
	                        .exit()
	                        .remove();
	                    this.mainGraphicsContext
	                        .selectAll(ChordChart.tickPairClass.selector)
	                        .remove();
	                    this.mainGraphicsContext
	                        .selectAll(ChordChart.sliceTicksClass.selector)
	                        .remove();
	                };
	                ChordChart.prototype.getChordTicksArcDescriptors = function () {
	                    var groups = this.data.groups;
	                    var maxValue = !_.isEmpty(groups) && _.max(groups, function (x) { return x.value; }).value || 0;
	                    var minValue = !_.isEmpty(groups) && _.min(groups, function (x) { return x.value; }).value || 0;
	                    var radiusCoeff = this.radius / Math.abs(maxValue - minValue) * 1.25;
	                    var formatter = valueFormatter.create({
	                        format: "0.##",
	                        value: maxValue
	                    });
	                    groups.forEach(function (x) {
	                        var k = (x.endAngle - x.startAngle) / x.value, absValue = Math.abs(x.value), range = d3.range(0, absValue, absValue - 1 < 0.15 ? 0.15 : absValue - 1);
	                        if (x.value < 0) {
	                            range = range.map(function (x) { return x * -1; }).reverse();
	                        }
	                        for (var i = 1; i < range.length; i++) {
	                            var gapSize = Math.abs(range[i] - range[i - 1]) * radiusCoeff;
	                            if (gapSize < ChordChart.TicksFontSize) {
	                                if (range.length > 2 && i === range.length - 1) {
	                                    range.splice(--i, 1);
	                                }
	                                else {
	                                    range.splice(i--, 1);
	                                }
	                            }
	                        }
	                        x.angleLabels = range.map(function (v, i) { return { angle: v * k + x.startAngle, label: formatter.format(v) }; });
	                    });
	                    return groups;
	                };
	                ChordChart.copyArcDescriptorsWithoutNaNValues = function (arcDescriptors) {
	                    if (_.isEmpty(arcDescriptors)) {
	                        return arcDescriptors;
	                    }
	                    return arcDescriptors.map(function (sourceArcDescriptor) {
	                        var targetArcDescriptor = {};
	                        for (var propertyName in sourceArcDescriptor) {
	                            if (!sourceArcDescriptor[propertyName] && isNaN(sourceArcDescriptor[propertyName])) {
	                                targetArcDescriptor[propertyName] = 0;
	                            }
	                            else {
	                                targetArcDescriptor[propertyName] = sourceArcDescriptor[propertyName];
	                            }
	                        }
	                        return targetArcDescriptor;
	                    });
	                };
	                /* Draw axis(ticks) around the arc */
	                ChordChart.prototype.drawTicks = function () {
	                    var _this = this;
	                    if (this.settings.axis.show) {
	                        var tickShapes = this.mainGraphicsContext
	                            .select(".ticks")
	                            .selectAll("g" + ChordChart.sliceTicksClass.selector)
	                            .data(this.data.groups);
	                        var animDuration = (this.data.prevAxisVisible === this.settings.axis.show)
	                            ? this.duration
	                            : 0;
	                        tickShapes
	                            .enter()
	                            .insert("g")
	                            .classed(ChordChart.sliceTicksClass.class, true);
	                        var tickPairs = tickShapes
	                            .selectAll("g" + ChordChart.tickPairClass.selector)
	                            .data(function (d) { return d.angleLabels; });
	                        tickPairs
	                            .enter()
	                            .insert("g")
	                            .classed(ChordChart.tickPairClass.class, true);
	                        tickPairs.transition()
	                            .duration(animDuration)
	                            .attr("transform", function (d) {
	                            return "rotate(" + (d.angle * 180 / Math.PI - 90) + ")" + "translate(" + _this.innerRadius + ",0)";
	                        });
	                        tickPairs
	                            .selectAll("line" + ChordChart.tickLineClass.selector)
	                            .data(function (d) { return [d]; })
	                            .enter()
	                            .insert("line")
	                            .classed(ChordChart.tickLineClass.class, true)
	                            .style("stroke", "#000")
	                            .attr("x1", 1)
	                            .attr("y1", 0)
	                            .attr("x2", 5)
	                            .attr("y2", 0);
	                        tickPairs
	                            .selectAll("text" + ChordChart.tickTextClass.selector)
	                            .data(function (d) { return [d]; })
	                            .enter()
	                            .insert("text")
	                            .classed(ChordChart.tickTextClass.class, true)
	                            .style("pointer-events", "none")
	                            .attr("x", 8)
	                            .attr("dy", ".35em");
	                        tickPairs
	                            .selectAll("text" + ChordChart.tickTextClass.selector)
	                            .text(function (d) { return d.label; })
	                            .style("text-anchor", function (d) { return d.angle > Math.PI ? "end" : null; })
	                            .attr("transform", function (d) { return d.angle > Math.PI ? "rotate(180)translate(-16)" : null; });
	                        tickPairs.exit()
	                            .remove();
	                        tickShapes.exit()
	                            .remove();
	                    }
	                    else {
	                        this.clearTicks();
	                    }
	                };
	                ChordChart.prototype.renderLabels = function (filteredData, layout, isDonut, forAnimation) {
	                    if (isDonut === void 0) { isDonut = false; }
	                    if (forAnimation === void 0) { forAnimation = false; }
	                    // Check for a case where resizing leaves no labels - then we need to remove the labels "g"
	                    if (filteredData.length === 0) {
	                        dataLabelUtils.cleanDataLabels(this.labels, true);
	                        return null;
	                    }
	                    // line chart ViewModel has a special "key" property for point identification since the "identity" field is set to the series identity
	                    var hasKey = filteredData[0].key !== null;
	                    var hasDataPointIdentity = filteredData[0].identity !== null;
	                    var getIdentifier = hasKey
	                        ? function (d) { return d.key; }
	                        : hasDataPointIdentity
	                            ? function (d) { return d.identity.getKey(); }
	                            : undefined;
	                    var dataLabels = isDonut
	                        ? this.labels.selectAll(ChordChart.labelsClass.selector)
	                            .data(filteredData, function (d) { return d.data.identity.getKey(); })
	                        : getIdentifier !== null
	                            ? this.labels.selectAll(ChordChart.labelsClass.selector).data(filteredData, getIdentifier)
	                            : this.labels.selectAll(ChordChart.labelsClass.selector).data(filteredData);
	                    var newLabels = dataLabels.enter()
	                        .append("text")
	                        .classed(ChordChart.labelsClass.class, true);
	                    if (forAnimation) {
	                        newLabels.style("opacity", 0);
	                    }
	                    dataLabels
	                        .attr({
	                        x: function (d) { return d.labelX; },
	                        y: function (d) { return d.labelY; },
	                        dy: ".35em"
	                    })
	                        .text(function (d) { return d.labeltext; })
	                        .style(layout.style);
	                    dataLabels
	                        .exit()
	                        .remove();
	                };
	                ChordChart.prototype.renderLines = function (filteredData, arc, outerArc) {
	                    var _this = this;
	                    var lines = this.lines
	                        .selectAll("polyline")
	                        .data(filteredData, function (d) {
	                        return d.data.identity.getKey();
	                    });
	                    var midAngle = function (d) { return d.startAngle + (d.endAngle - d.startAngle) / 2; };
	                    lines.enter()
	                        .append("polyline")
	                        .classed(ChordChart.lineClass.class, true);
	                    lines
	                        .attr("points", function (d) {
	                        var textPoint = outerArc.centroid(d);
	                        textPoint[0] = (_this.radius + ChordChart.LabelMargin / 2) * (midAngle(d) < Math.PI ? 1 : -1);
	                        var midPoint = outerArc.centroid(d);
	                        var chartPoint = arc.centroid(d);
	                        chartPoint[0] *= ChordChart.InnerLinePointMultiplier;
	                        chartPoint[1] *= ChordChart.InnerLinePointMultiplier;
	                        return [
	                            chartPoint,
	                            midPoint,
	                            textPoint
	                        ];
	                    }).
	                        style({
	                        "opacity": function (d) { return ChordChart.PolylineOpacity; },
	                        "stroke": function (d) { return d.data.labelColor; },
	                        "pointer-events": "none"
	                    });
	                    lines
	                        .exit()
	                        .remove();
	                };
	                /* Get label layout */
	                ChordChart.prototype.getChordChartLabelLayout = function (outerArc) {
	                    var _this = this;
	                    var midAngle = function (d) { return d.startAngle + (d.endAngle - d.startAngle) / 2; };
	                    var maxLabelWidth = (this.layout.viewportIn.width - this.radius * 2 - ChordChart.LabelMargin * 2) / 1.6;
	                    return {
	                        labelText: function (d) {
	                            // show only category label
	                            return dataLabelUtils.getLabelFormattedText({
	                                label: d.data.label,
	                                maxWidth: maxLabelWidth,
	                                fontSize: PixelConverter.fromPointToPixel(_this.settings.labels.fontSize),
	                            });
	                        },
	                        labelLayout: {
	                            x: function (d) {
	                                return (_this.radius + ChordChart.LabelMargin) * (midAngle(d) < Math.PI ? 1 : -1);
	                            },
	                            y: function (d) {
	                                var pos = outerArc.centroid(d);
	                                return pos[1];
	                            },
	                        },
	                        filter: function (d) { return (d !== null && d.data !== null && d.data.label !== null); },
	                        style: {
	                            "fill": function (d) { return d.data.labelColor; },
	                            "text-anchor": function (d) { return midAngle(d) < Math.PI ? "start" : "end"; },
	                            "font-size": function (d) { return PixelConverter.fromPoint(_this.settings.labels.fontSize); },
	                        },
	                    };
	                };
	                /* Utility function for union two arrays without duplicates */
	                ChordChart.union_arrays = function (x, y) {
	                    var obj = {};
	                    for (var i = 0; i < x.length; i++) {
	                        obj[x[i]] = x[i];
	                    }
	                    for (var i = 0; i < y.length; i++) {
	                        obj[y[i]] = y[i];
	                    }
	                    var res = [];
	                    for (var k in obj) {
	                        if (obj.hasOwnProperty(k)) {
	                            res.push(obj[k]);
	                        }
	                    }
	                    return res;
	                };
	                ChordChart.capabilities = {
	                    dataRoles: [
	                        {
	                            name: ChordChartColumns.Roles.Category,
	                            kind: VisualDataRoleKind.Grouping,
	                            displayName: "From",
	                        }, {
	                            name: ChordChartColumns.Roles.Series,
	                            kind: VisualDataRoleKind.Grouping,
	                            displayName: "To",
	                        }, {
	                            name: ChordChartColumns.Roles.Y,
	                            kind: VisualDataRoleKind.Measure,
	                            displayName: "Values",
	                        }
	                    ],
	                    dataViewMappings: [{
	                            conditions: [
	                                { "Category": { max: 1 }, "Series": { max: 0 } },
	                                { "Category": { max: 1 }, "Series": { min: 1, max: 1 }, "Y": { max: 1 } },
	                                { "Category": { max: 1 }, "Series": { max: 0 }, "Y": { min: 0, max: 1 } },
	                            ],
	                            categorical: {
	                                categories: {
	                                    for: { in: "Category" },
	                                    dataReductionAlgorithm: { top: {} }
	                                },
	                                values: {
	                                    group: {
	                                        by: "Series",
	                                        select: [{ bind: { to: "Y" } }],
	                                        dataReductionAlgorithm: { top: {} }
	                                    },
	                                },
	                                rowCount: { preferred: { min: 2 }, supported: { min: 1 } }
	                            },
	                        }],
	                    objects: {
	                        dataPoint: {
	                            displayName: createDisplayNameGetter("Visual_DataPoint"),
	                            properties: {
	                                defaultColor: {
	                                    displayName: createDisplayNameGetter("Visual_DefaultColor"),
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                showAllDataPoints: {
	                                    displayName: createDisplayNameGetter("Visual_DataPoint_Show_All"),
	                                    type: { bool: true }
	                                },
	                                fill: {
	                                    displayName: createDisplayNameGetter("Visual_Fill"),
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                            },
	                        },
	                        axis: {
	                            displayName: "Axis",
	                            properties: {
	                                show: {
	                                    type: { bool: true }
	                                },
	                            },
	                        },
	                        labels: {
	                            displayName: "Labels",
	                            properties: {
	                                show: {
	                                    type: { bool: true }
	                                },
	                                color: {
	                                    displayName: createDisplayNameGetter("Visual_Reference_Line_Data_Label_Color"),
	                                    description: createDisplayNameGetter("Visual_Reference_Line_Data_Label_Color_Description"),
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                fontSize: {
	                                    displayName: createDisplayNameGetter("Visual_TextSize"),
	                                    type: { formatting: { fontSize: true } },
	                                },
	                            },
	                        }
	                    }
	                };
	                ChordChart.PolylineOpacity = 0.5;
	                ChordChart.OuterArcRadiusRatio = 0.9;
	                ChordChart.InnerArcRadiusRatio = 0.8;
	                ChordChart.LabelMargin = 10;
	                ChordChart.DefaultMargin = { left: 10, right: 10, top: 10, bottom: 10 };
	                ChordChart.VisualClassName = "chordChart";
	                ChordChart.TicksFontSize = 12;
	                ChordChart.InnerLinePointMultiplier = 2.05;
	                ChordChart.ChordLayoutPadding = 0.1;
	                ChordChart.sliceClass = {
	                    class: "slice",
	                    selector: ".slice",
	                };
	                ChordChart.chordClass = {
	                    class: "chord",
	                    selector: ".chord",
	                };
	                ChordChart.sliceTicksClass = {
	                    class: "slice-ticks",
	                    selector: ".slice-ticks"
	                };
	                ChordChart.tickPairClass = {
	                    class: "tick-pair",
	                    selector: ".tick-pair"
	                };
	                ChordChart.tickLineClass = {
	                    class: "tick-line",
	                    selector: ".tick-line"
	                };
	                ChordChart.tickTextClass = {
	                    class: "tick-text",
	                    selector: ".tick-text"
	                };
	                ChordChart.labelGraphicsContextClass = {
	                    class: "labels",
	                    selector: ".labels",
	                };
	                ChordChart.labelsClass = {
	                    class: "data-labels",
	                    selector: ".data-labels",
	                };
	                ChordChart.linesGraphicsContextClass = {
	                    class: "lines",
	                    selector: ".lines",
	                };
	                ChordChart.lineClass = {
	                    class: "line-label",
	                    selector: ".line-label",
	                };
	                return ChordChart;
	            }());
	            samples.ChordChart = ChordChart;
	        })(samples = visuals.samples || (visuals.samples = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 46 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../../../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var samples;
	        (function (samples) {
	            var PixelConverter = jsCommon.PixelConverter;
	            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
	            var getCategoryIndexOfRole = powerbi.data.DataRoleHelper.getCategoryIndexOfRole;
	            var getMeasureIndexOfRole = powerbi.data.DataRoleHelper.getMeasureIndexOfRole;
	            var registerStandardInteractivityHandlers = powerbi.visuals.InteractivityUtils.registerStandardInteractivityHandlers;
	            var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
	            var Lazy = jsCommon.Lazy;
	            var measureSvgTextWidth = powerbi.TextMeasurementService.measureSvgTextWidth;
	            var measureSvgTextHeight = powerbi.TextMeasurementService.measureSvgTextHeight;
	            var estimateSvgTextHeight = powerbi.TextMeasurementService.estimateSvgTextHeight;
	            var svgEllipsis = powerbi.TextMeasurementService.svgEllipsis;
	            var addTooltip = powerbi.visuals.TooltipManager.addTooltip;
	            var fromPoint = jsCommon.PixelConverter.fromPoint;
	            var LabelTextProperties = powerbi.visuals.dataLabelUtils.LabelTextProperties;
	            var getLabelFormattedText = powerbi.visuals.dataLabelUtils.getLabelFormattedText;
	            var equalWithPrecision = powerbi.Double.equalWithPrecision;
	            var GetAnimationDuration = powerbi.visuals.AnimatorCommon.GetAnimationDuration;
	            var getTailoredTextOrDefault = powerbi.TextMeasurementService.getTailoredTextOrDefault;
	            var LegendData = powerbi.visuals.LegendData;
	            var SelectionId = powerbi.visuals.SelectionId;
	            var DataViewObject = powerbi.DataViewObject;
	            var VisualDataRoleKind = powerbi.VisualDataRoleKind;
	            var legendPosition = powerbi.visuals.legendPosition;
	            var BaseAnimator = powerbi.visuals.BaseAnimator;
	            var yAxisPosition = powerbi.visuals.yAxisPosition;
	            var appendClearCatcher = powerbi.visuals.appendClearCatcher;
	            var createInteractivityService = powerbi.visuals.createInteractivityService;
	            var createLegend = powerbi.visuals.createLegend;
	            var AxisHelper = powerbi.visuals.AxisHelper;
	            var DataViewObjects = powerbi.DataViewObjects;
	            var valueFormatter = powerbi.visuals.valueFormatter;
	            var dataLabelUtils = powerbi.visuals.dataLabelUtils;
	            var ColorHelper = powerbi.visuals.ColorHelper;
	            var LegendIcon = powerbi.visuals.LegendIcon;
	            var SelectionIdBuilder = powerbi.visuals.SelectionIdBuilder;
	            var TooltipBuilder = powerbi.visuals.TooltipBuilder;
	            var getInvalidValueWarnings = powerbi.visuals.getInvalidValueWarnings;
	            var legendProps = powerbi.visuals.legendProps;
	            var LegendPosition = powerbi.visuals.LegendPosition;
	            var Legend = powerbi.visuals.Legend;
	            var SVGUtil = powerbi.visuals.SVGUtil;
	            var ObjectEnumerationBuilder = powerbi.visuals.ObjectEnumerationBuilder;
	            var GradientUtils = powerbi.visuals.GradientUtils;
	            var axisType = powerbi.visuals.axisType;
	            var axisScale = powerbi.visuals.axisScale;
	            var axisStyle = powerbi.visuals.axisStyle;
	            var EnhancedScatterChart = (function () {
	                function EnhancedScatterChart() {
	                    this.ScrollBarWidth = 10;
	                }
	                Object.defineProperty(EnhancedScatterChart.prototype, "margin", {
	                    get: function () {
	                        return this._margin || { left: 0, right: 0, top: 0, bottom: 0 };
	                    },
	                    set: function (value) {
	                        this._margin = $.extend({}, value);
	                        this._viewportIn = EnhancedScatterChart.substractMargin(this.viewport, this.margin);
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(EnhancedScatterChart.prototype, "viewport", {
	                    get: function () {
	                        return this._viewport || { width: 0, height: 0 };
	                    },
	                    set: function (value) {
	                        this._viewport = $.extend({}, value);
	                        this._viewportIn = EnhancedScatterChart.substractMargin(this.viewport, this.margin);
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(EnhancedScatterChart.prototype, "viewportIn", {
	                    get: function () {
	                        return this._viewportIn || this.viewport;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(EnhancedScatterChart.prototype, "legendViewport", {
	                    get: function () {
	                        return this.legend.getMargins();
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                /**
	                 * Public for testability.
	                 */
	                EnhancedScatterChart.getPropertiesByCapabilities = function (capabilities) {
	                    var propertiesByCapabilities = {};
	                    if (!capabilities) {
	                        return propertiesByCapabilities;
	                    }
	                    for (var objectName in capabilities.objects) {
	                        var objectDescriptor = capabilities.objects[objectName];
	                        propertiesByCapabilities[objectName] = {};
	                        if (objectDescriptor) {
	                            for (var propertyName in objectDescriptor.properties) {
	                                propertiesByCapabilities[objectName][propertyName] = {
	                                    objectName: objectName,
	                                    propertyName: propertyName
	                                };
	                            }
	                        }
	                    }
	                    return propertiesByCapabilities;
	                };
	                EnhancedScatterChart.substractMargin = function (viewport, margin) {
	                    return {
	                        width: Math.max(viewport.width - (margin.left + margin.right), 0),
	                        height: Math.max(viewport.height - (margin.top + margin.bottom), 0)
	                    };
	                };
	                EnhancedScatterChart.getCustomSymbolType = function (shape) {
	                    var customSymbolTypes = d3.map({
	                        "circle": function (size) {
	                            var r = Math.sqrt(size / Math.PI);
	                            return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + (-r) + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
	                        },
	                        "cross": function (size) {
	                            var r = Math.sqrt(size / 5) / 2;
	                            return "M" + -3 * r + "," + -r
	                                + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
	                        },
	                        "diamond": function (size) {
	                            var ry = Math.sqrt(size / (2 * Math.tan(Math.PI / 6))), rx = ry * Math.tan(Math.PI / 6);
	                            return "M0," + -ry
	                                + "L" + rx + ",0"
	                                + " 0," + ry
	                                + " " + -rx + ",0"
	                                + "Z";
	                        },
	                        "square": function (size) {
	                            var r = Math.sqrt(size) / 2;
	                            return "M" + -r + "," + -r
	                                + "L" + r + "," + -r
	                                + " " + r + "," + r
	                                + " " + -r + "," + r
	                                + "Z";
	                        },
	                        "triangle-up": function (size) {
	                            var rx = Math.sqrt(size / Math.sqrt(3)), ry = rx * Math.sqrt(3) / 2;
	                            return "M0," + -ry
	                                + "L" + rx + "," + ry
	                                + " " + -rx + "," + ry
	                                + "Z";
	                        },
	                        "triangle-down": function (size) {
	                            var rx = Math.sqrt(size / Math.sqrt(3)), ry = rx * Math.sqrt(3) / 2;
	                            return "M0," + ry
	                                + "L" + rx + "," + -ry
	                                + " " + -rx + "," + -ry
	                                + "Z";
	                        },
	                        "star": function (size) {
	                            var outerRadius = Math.sqrt(size / 2);
	                            var innerRadius = Math.sqrt(size / 10);
	                            var results = "";
	                            var angle = Math.PI / 5;
	                            for (var i = 0; i < 10; i++) {
	                                // Use outer or inner radius depending on what iteration we are in.
	                                var r = (i & 1) === 0 ? outerRadius : innerRadius;
	                                var currX = Math.cos(i * angle) * r;
	                                var currY = Math.sin(i * angle) * r;
	                                // Our first time we simply append the coordinates, subsequet times
	                                // we append a ", " to distinguish each coordinate pair.
	                                if (i === 0) {
	                                    results = "M" + currX + "," + currY + "L";
	                                }
	                                else {
	                                    results += " " + currX + "," + currY;
	                                }
	                            }
	                            return results + "Z";
	                        },
	                        "hexagon": function (size) {
	                            var r = Math.sqrt(size / (6 * Math.sqrt(3)));
	                            var r2 = Math.sqrt(size / (2 * Math.sqrt(3)));
	                            return "M0," + (2 * r) + "L" + (-r2) + "," + r + " " + (-r2) + "," + (-r) + " 0," + (-2 * r) + " " + r2 + "," + (-r) + " " + r2 + "," + r + "Z";
	                        },
	                        "x": function (size) {
	                            var r = Math.sqrt(size / 10);
	                            return "M0," + r + "L" + (-r) + "," + 2 * r + " " + (-2 * r) + "," + r + " " + (-r) + ",0 " + (-2 * r) + "," + (-r) + " " + (-r) + "," + (-2 * r) + " 0," + (-r) + " " + r + "," + (-2 * r) + " " + (2 * r) + "," + (-r) + " " + r + ",0 " + (2 * r) + "," + r + " " + r + "," + (2 * r) + "Z";
	                        },
	                        "uparrow": function (size) {
	                            var r = Math.sqrt(size / 12);
	                            return "M" + r + "," + (3 * r) + "L" + (-r) + "," + (3 * r) + " " + (-r) + "," + (-r) + " " + (-2 * r) + "," + (-r) + " 0," + (-3 * r) + " " + (2 * r) + "," + (-r) + " " + r + "," + (-r) + "Z";
	                        },
	                        "downarrow": function (size) {
	                            var r = Math.sqrt(size / 12);
	                            return "M0," + (3 * r) + "L" + (-2 * r) + "," + r + " " + (-r) + "," + r + " " + (-r) + "," + (-3 * r) + " " + r + "," + (-3 * r) + " " + r + "," + r + " " + (2 * r) + "," + r + "Z";
	                        }
	                    });
	                    var defaultValue = customSymbolTypes.entries()[0].value;
	                    if (!shape) {
	                        return defaultValue;
	                    }
	                    else if (isNaN(shape)) {
	                        return customSymbolTypes[shape && shape.toString().toLowerCase()] || defaultValue;
	                    }
	                    else {
	                        var result = customSymbolTypes.entries()[Math.floor(shape)];
	                        return result ? result.value : defaultValue;
	                    }
	                };
	                EnhancedScatterChart.prototype.init = function (options) {
	                    this.options = options;
	                    this.animator = new BaseAnimator();
	                    this.behavior = new CustomVisualBehavior([new EnhancedScatterChartWebBehavior(EnhancedScatterChart.DimmedBubbleOpacity, EnhancedScatterChart.DefaultBubbleOpacity)]);
	                    var element = this.element = options.element;
	                    this.viewport = _.clone(options.viewport);
	                    this.style = options.style;
	                    this.hostServices = options.host;
	                    this.colors = this.style.colorPalette.dataColors;
	                    this.interactivity = options.interactivity;
	                    this.margin = {
	                        top: 1,
	                        right: 1,
	                        bottom: 1,
	                        left: 1
	                    };
	                    this.yAxisOrientation = yAxisPosition.left;
	                    this.adjustMargins();
	                    var showLinesOnX = this.scrollY = true;
	                    var showLinesOnY = this.scrollX = true;
	                    var svg = this.svg = d3.select(element.get(0))
	                        .append("svg")
	                        .style("position", "absolute")
	                        .classed(EnhancedScatterChart.ClassName, true);
	                    var axisGraphicsContext = this.axisGraphicsContext = svg.append("g")
	                        .classed(EnhancedScatterChart.AxisGraphicsContextClassName, true);
	                    this.svgScrollable = svg.append("svg")
	                        .classed("svgScrollable", true)
	                        .style("overflow", "hidden");
	                    var axisGraphicsContextScrollable = this.axisGraphicsContextScrollable = this.svgScrollable.append("g")
	                        .classed(EnhancedScatterChart.AxisGraphicsContextClassName, true);
	                    this.clearCatcher = appendClearCatcher(this.axisGraphicsContextScrollable);
	                    var axisGroup = showLinesOnX
	                        ? axisGraphicsContextScrollable
	                        : axisGraphicsContext;
	                    this.backgroundGraphicsContext = axisGraphicsContext.append("svg:image");
	                    this.xAxisGraphicsContext = showLinesOnX
	                        ? axisGraphicsContext.append("g").attr("class", "x axis")
	                        : axisGraphicsContextScrollable.append("g").attr("class", "x axis");
	                    this.y1AxisGraphicsContext = axisGroup.append("g").attr("class", "y axis");
	                    this.xAxisGraphicsContext.classed("showLinesOnAxis", showLinesOnX);
	                    this.y1AxisGraphicsContext.classed("showLinesOnAxis", showLinesOnY);
	                    this.xAxisGraphicsContext.classed("hideLinesOnAxis", !showLinesOnX);
	                    this.y1AxisGraphicsContext.classed("hideLinesOnAxis", !showLinesOnY);
	                    this.interactivityService = createInteractivityService(this.hostServices);
	                    this.legend = createLegend(element, this.interactivity && this.interactivity.isInteractiveLegend, this.interactivityService, true);
	                    this.mainGraphicsG = this.axisGraphicsContextScrollable
	                        .append("g")
	                        .classed(EnhancedScatterChart.MainGraphicsContextClassName, true);
	                    this.mainGraphicsSVGSelection = this.mainGraphicsG.append("svg");
	                    this.mainGraphicsContext = this.mainGraphicsSVGSelection.append("g");
	                    this.svgDefaultImage = "";
	                    this.keyArray = [];
	                };
	                EnhancedScatterChart.prototype.adjustMargins = function () {
	                    // Adjust margins if ticks are not going to be shown on either axis
	                    var xAxis = this.element.find(".x.axis");
	                    if (AxisHelper.getRecommendedNumberOfTicksForXAxis(this.viewportIn.width) === 0
	                        && AxisHelper.getRecommendedNumberOfTicksForYAxis(this.viewportIn.height) === 0) {
	                        this.margin = {
	                            top: 0,
	                            right: 0,
	                            bottom: 0,
	                            left: 0
	                        };
	                        xAxis.hide();
	                    }
	                    else {
	                        xAxis.show();
	                    }
	                };
	                EnhancedScatterChart.prototype.getValueAxisProperties = function (dataViewMetadata, axisTitleOnByDefault) {
	                    var toReturn = {};
	                    if (!dataViewMetadata) {
	                        return toReturn;
	                    }
	                    var objects = dataViewMetadata.objects;
	                    if (objects) {
	                        var valueAxisObject = objects["valueAxis"];
	                        if (valueAxisObject) {
	                            toReturn = {
	                                show: valueAxisObject["show"],
	                                position: valueAxisObject["position"],
	                                axisScale: valueAxisObject["axisScale"],
	                                start: valueAxisObject["start"],
	                                end: valueAxisObject["end"],
	                                showAxisTitle: valueAxisObject["showAxisTitle"] == null ? axisTitleOnByDefault : valueAxisObject["showAxisTitle"],
	                                axisStyle: valueAxisObject["axisStyle"],
	                                axisColor: valueAxisObject["axisColor"],
	                                secShow: valueAxisObject["secShow"],
	                                secPosition: valueAxisObject["secPosition"],
	                                secAxisScale: valueAxisObject["secAxisScale"],
	                                secStart: valueAxisObject["secStart"],
	                                secEnd: valueAxisObject["secEnd"],
	                                secShowAxisTitle: valueAxisObject["secShowAxisTitle"],
	                                secAxisStyle: valueAxisObject["secAxisStyle"],
	                                labelDisplayUnits: valueAxisObject["labelDisplayUnits"],
	                            };
	                        }
	                    }
	                    return toReturn;
	                };
	                EnhancedScatterChart.prototype.getCategoryAxisProperties = function (dataViewMetadata, axisTitleOnByDefault) {
	                    var toReturn = {};
	                    if (!dataViewMetadata) {
	                        return toReturn;
	                    }
	                    var objects = dataViewMetadata.objects;
	                    if (objects) {
	                        var categoryAxisObject = objects["categoryAxis"];
	                        if (categoryAxisObject) {
	                            toReturn = {
	                                show: categoryAxisObject["show"],
	                                axisType: categoryAxisObject["axisType"],
	                                axisScale: categoryAxisObject["axisScale"],
	                                axisColor: categoryAxisObject["axisColor"],
	                                start: categoryAxisObject["start"],
	                                end: categoryAxisObject["end"],
	                                showAxisTitle: categoryAxisObject["showAxisTitle"] == null
	                                    ? axisTitleOnByDefault : categoryAxisObject["showAxisTitle"],
	                                axisStyle: categoryAxisObject["axisStyle"],
	                                labelDisplayUnits: categoryAxisObject["labelDisplayUnits"]
	                            };
	                        }
	                    }
	                    return toReturn;
	                };
	                EnhancedScatterChart.converter = function (dataView, colorPalette, interactivityService, categoryAxisProperties, valueAxisProperties) {
	                    if (!dataView) {
	                        return EnhancedScatterChart.getDefaultData();
	                    }
	                    var categoryValues, categoryFormatter, categoryObjects, categoryIdentities, categoryQueryName, dataViewCategorical = dataView.categorical, dataViewMetadata = dataView.metadata, categories = dataViewCategorical.categories || [], dataValues = dataViewCategorical.values, hasDynamicSeries = !!dataValues.source, grouped = dataValues.grouped(), dvSource = dataValues.source, scatterMetadata = EnhancedScatterChart.getMetadata(categories, grouped, dvSource), categoryIndex = scatterMetadata.idx.category, useShape = scatterMetadata.idx.image >= 0, useCustomColor = scatterMetadata.idx.colorFill >= 0;
	                    if (dataViewCategorical.categories &&
	                        dataViewCategorical.categories.length > 0 &&
	                        dataViewCategorical.categories[categoryIndex]) {
	                        var mainCategory = dataViewCategorical.categories[categoryIndex];
	                        categoryValues = mainCategory.values;
	                        categoryFormatter = valueFormatter.create({
	                            format: valueFormatter.getFormatString(mainCategory.source, EnhancedScatterChart.Properties["general"]["formatString"]),
	                            value: categoryValues[0],
	                            value2: categoryValues[categoryValues.length - 1]
	                        });
	                        categoryIdentities = mainCategory.identity;
	                        categoryObjects = mainCategory.objects;
	                        categoryQueryName = mainCategory.source ? mainCategory.source.queryName : null;
	                    }
	                    else {
	                        categoryValues = [null];
	                        // creating default formatter for null value (to get the right string of empty value from the locale)
	                        categoryFormatter = valueFormatter.createDefaultFormatter(null);
	                    }
	                    var dataLabelsSettings = dataLabelUtils.getDefaultPointLabelSettings(), fillPoint = false, backdrop = { show: false, url: "" }, crosshair = false, outline = false, defaultDataPointColor = "", showAllDataPoints = true;
	                    if (dataViewMetadata && dataViewMetadata.objects) {
	                        var objects = dataViewMetadata.objects;
	                        defaultDataPointColor = DataViewObjects.getFillColor(objects, EnhancedScatterChart.Properties["dataPoint"]["defaultColor"]);
	                        showAllDataPoints = DataViewObjects.getValue(objects, EnhancedScatterChart.Properties["dataPoint"]["showAllDataPoints"]);
	                        var labelsObj = objects["categoryLabels"];
	                        if (labelsObj) {
	                            dataLabelsSettings.show = (labelsObj["show"] !== undefined)
	                                ? labelsObj["show"] : dataLabelsSettings.show;
	                            dataLabelsSettings.fontSize = (labelsObj["fontSize"] !== undefined)
	                                ? labelsObj["fontSize"] : dataLabelsSettings.fontSize;
	                            if (labelsObj["color"] !== undefined) {
	                                dataLabelsSettings.labelColor = labelsObj["color"].solid.color;
	                            }
	                        }
	                        fillPoint = DataViewObjects.getValue(objects, EnhancedScatterChart.Properties["fillPoint"]["show"], fillPoint);
	                        var backdropObject = objects["backdrop"];
	                        if (backdropObject !== undefined) {
	                            backdrop.show = backdropObject["show"];
	                            if (backdrop.show) {
	                                backdrop.url = backdropObject["url"];
	                            }
	                        }
	                        var crosshairObject = objects["crosshair"];
	                        if (crosshairObject !== undefined) {
	                            crosshair = crosshairObject["show"];
	                        }
	                        var outlineObject = objects["outline"];
	                        if (outlineObject !== undefined) {
	                            outline = outlineObject["show"];
	                        }
	                    }
	                    var dataPoints = EnhancedScatterChart.createDataPoints(dataValues, scatterMetadata, categories, categoryValues, categoryFormatter, categoryIdentities, categoryObjects, colorPalette, hasDynamicSeries, dataLabelsSettings, defaultDataPointColor, categoryQueryName);
	                    if (interactivityService) {
	                        interactivityService.applySelectionStateToData(dataPoints);
	                    }
	                    var legendItems = [];
	                    if (hasDynamicSeries) {
	                        var formatString = valueFormatter.getFormatString(dvSource, EnhancedScatterChart.Properties["general"]["formatString"]);
	                        legendItems = EnhancedScatterChart.createSeriesLegend(dataValues, colorPalette, dataValues, formatString, defaultDataPointColor);
	                    }
	                    var legendTitle = dataValues && dvSource
	                        ? dvSource.displayName
	                        : "";
	                    if (!legendTitle) {
	                        legendTitle = categories &&
	                            categories[categoryIndex] &&
	                            categories[categoryIndex].source &&
	                            categories[categoryIndex].source.displayName
	                            ? categories[categoryIndex].source.displayName : "";
	                    }
	                    var legendData = { title: legendTitle, dataPoints: legendItems };
	                    var sizeRange = EnhancedScatterChart.getSizeRangeForGroups(grouped, scatterMetadata.idx.size);
	                    if (categoryAxisProperties && categoryAxisProperties["showAxisTitle"] !== null && categoryAxisProperties["showAxisTitle"] === false) {
	                        scatterMetadata.axesLabels.x = null;
	                    }
	                    if (valueAxisProperties && valueAxisProperties["showAxisTitle"] !== null && valueAxisProperties["showAxisTitle"] === false) {
	                        scatterMetadata.axesLabels.y = null;
	                    }
	                    if (dataPoints && dataPoints[0]) {
	                        var point = dataPoints[0];
	                        if (point.backdrop != null) {
	                            backdrop.show = true;
	                            backdrop.url = point.backdrop;
	                        }
	                        if (point.xStart != null) {
	                            categoryAxisProperties["start"] = point.xStart;
	                        }
	                        if (point.xEnd != null) {
	                            categoryAxisProperties["end"] = point.xEnd;
	                        }
	                        if (point.yStart != null) {
	                            valueAxisProperties["start"] = point.yStart;
	                        }
	                        if (point.yEnd != null) {
	                            valueAxisProperties["end"] = point.yEnd;
	                        }
	                    }
	                    return {
	                        xCol: scatterMetadata.cols.x,
	                        yCol: scatterMetadata.cols.y,
	                        dataPoints: dataPoints,
	                        legendData: legendData,
	                        axesLabels: scatterMetadata.axesLabels,
	                        selectedIds: [],
	                        size: scatterMetadata.cols.size,
	                        sizeRange: sizeRange,
	                        dataLabelsSettings: dataLabelsSettings,
	                        defaultDataPointColor: defaultDataPointColor,
	                        hasDynamicSeries: hasDynamicSeries,
	                        showAllDataPoints: showAllDataPoints,
	                        fillPoint: fillPoint,
	                        useShape: useShape,
	                        useCustomColor: useCustomColor,
	                        backdrop: backdrop,
	                        crosshair: crosshair,
	                        outline: outline
	                    };
	                };
	                EnhancedScatterChart.createSeriesLegend = function (dataValues, colorPalette, categorical, formatString, defaultDataPointColor) {
	                    var legendItems = [], grouped = dataValues.grouped(), colorHelper = new ColorHelper(colorPalette, EnhancedScatterChart.Properties["dataPoint"]["fill"], defaultDataPointColor);
	                    for (var i = 0, len = grouped.length; i < len; i++) {
	                        var grouping = grouped[i], selectionId, color;
	                        color = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name);
	                        selectionId = grouping.identity
	                            ? SelectionId.createWithId(grouping.identity)
	                            : SelectionId.createNull();
	                        legendItems.push({
	                            color: color,
	                            icon: LegendIcon.Circle,
	                            label: valueFormatter.format(grouping.name, formatString),
	                            identity: selectionId,
	                            selected: false,
	                        });
	                    }
	                    return legendItems;
	                };
	                EnhancedScatterChart.getSizeRangeForGroups = function (dataViewValueGroups, sizeColumnIndex) {
	                    var result = {};
	                    if (dataViewValueGroups) {
	                        dataViewValueGroups.forEach(function (group) {
	                            var sizeColumn = EnhancedScatterChart.getMeasureValue(sizeColumnIndex, group.values), currentRange = AxisHelper.getRangeForColumn(sizeColumn);
	                            if (result.min == null || result.min > currentRange.min) {
	                                result.min = currentRange.min;
	                            }
	                            if (result.max == null || result.max < currentRange.max) {
	                                result.max = currentRange.max;
	                            }
	                        });
	                    }
	                    return result;
	                };
	                EnhancedScatterChart.getMetadata = function (categories, grouped, source) {
	                    var categoryIndex = getCategoryIndexOfRole(categories, EnhancedScatterChart.ColumnCategory), colorFillIndex = getCategoryIndexOfRole(categories, EnhancedScatterChart.ColumnColorFill), imageIndex = getCategoryIndexOfRole(categories, EnhancedScatterChart.ColumnImage), backdropIndex = getCategoryIndexOfRole(categories, EnhancedScatterChart.ColumnBackdrop), xIndex = getMeasureIndexOfRole(grouped, EnhancedScatterChart.ColumnX), yIndex = getMeasureIndexOfRole(grouped, EnhancedScatterChart.ColumnY), sizeIndex = getMeasureIndexOfRole(grouped, EnhancedScatterChart.ColumnSize), shapeIndex = getMeasureIndexOfRole(grouped, EnhancedScatterChart.ColumnShape), rotationIndex = getMeasureIndexOfRole(grouped, EnhancedScatterChart.ColumnRotation), xStartIndex = getMeasureIndexOfRole(grouped, EnhancedScatterChart.ColumnXStart), xEndIndex = getMeasureIndexOfRole(grouped, EnhancedScatterChart.ColumnXEnd), yStartIndex = getMeasureIndexOfRole(grouped, EnhancedScatterChart.ColumnYStart), yEndIndex = getMeasureIndexOfRole(grouped, EnhancedScatterChart.ColumnYEnd), xCol, yCol, sizeCol, xAxisLabel = "", yAxisLabel = "";
	                    if (grouped && grouped.length) {
	                        var firstGroup = grouped[0];
	                        if (xIndex >= 0) {
	                            xCol = firstGroup.values[xIndex].source;
	                            xAxisLabel = firstGroup.values[xIndex].source.displayName;
	                        }
	                        if (yIndex >= 0) {
	                            yCol = firstGroup.values[yIndex].source;
	                            yAxisLabel = firstGroup.values[yIndex].source.displayName;
	                        }
	                        if (sizeIndex >= 0) {
	                            sizeCol = firstGroup.values[sizeIndex].source;
	                        }
	                    }
	                    return {
	                        idx: {
	                            category: categoryIndex,
	                            x: xIndex,
	                            y: yIndex,
	                            size: sizeIndex,
	                            colorFill: colorFillIndex,
	                            shape: shapeIndex,
	                            image: imageIndex,
	                            rotation: rotationIndex,
	                            backdrop: backdropIndex,
	                            xStart: xStartIndex,
	                            xEnd: xEndIndex,
	                            yStart: yStartIndex,
	                            yEnd: yEndIndex
	                        },
	                        cols: {
	                            x: xCol,
	                            y: yCol,
	                            size: sizeCol
	                        },
	                        axesLabels: {
	                            x: xAxisLabel,
	                            y: yAxisLabel
	                        }
	                    };
	                };
	                EnhancedScatterChart.createLazyFormattedCategory = function (formatter, value) {
	                    return new Lazy(function () { return formatter.format(value); });
	                };
	                EnhancedScatterChart.createDataPoints = function (dataValues, metadata, categories, categoryValues, categoryFormatter, categoryIdentities, categoryObjects, colorPalette, hasDynamicSeries, labelSettings, defaultDataPointColor, categoryQueryName) {
	                    var dataPoints = [], colorHelper, indicies = metadata.idx, formatStringProp, dataValueSource = dataValues.source, grouped = dataValues.grouped(), fontSizeInPx = PixelConverter.fromPoint(labelSettings.fontSize);
	                    formatStringProp = EnhancedScatterChart.Properties["general"]["formatString"];
	                    colorHelper = new ColorHelper(colorPalette, EnhancedScatterChart.Properties["dataPoint"]["fill"], defaultDataPointColor);
	                    for (var categoryIdx = 0, ilen = categoryValues.length; categoryIdx < ilen; categoryIdx++) {
	                        var categoryValue = categoryValues[categoryIdx];
	                        for (var seriesIdx = 0, len = grouped.length; seriesIdx < len; seriesIdx++) {
	                            var measureColorFill = categories[indicies.colorFill], measureImage = categories[indicies.image], measureBackdrop = categories[indicies.backdrop];
	                            var grouping = grouped[seriesIdx], seriesValues = grouping.values, measureX = EnhancedScatterChart.getMeasureValue(indicies.x, seriesValues), measureY = EnhancedScatterChart.getMeasureValue(indicies.y, seriesValues), measureSize = EnhancedScatterChart.getMeasureValue(indicies.size, seriesValues), measureShape = EnhancedScatterChart.getMeasureValue(indicies.shape, seriesValues), measureRotation = EnhancedScatterChart.getMeasureValue(indicies.rotation, seriesValues), measureXStart = EnhancedScatterChart.getMeasureValue(indicies.xStart, seriesValues), measureXEnd = EnhancedScatterChart.getMeasureValue(indicies.xEnd, seriesValues), measureYStart = EnhancedScatterChart.getMeasureValue(indicies.yStart, seriesValues), measureYEnd = EnhancedScatterChart.getMeasureValue(indicies.yEnd, seriesValues);
	                            //TODO: need to update (refactor) these lines below.
	                            var xVal = measureX && measureX.values && !isNaN(measureX.values[categoryIdx]) ? measureX.values[categoryIdx] : null, yVal = measureY && measureY.values && !isNaN(measureY.values[categoryIdx]) ? measureY.values[categoryIdx] : 0;
	                            var hasNullValue = (xVal == null) || (yVal == null);
	                            if (hasNullValue) {
	                                continue;
	                            }
	                            var size, colorFill, shapeSymbolType, image, rotation, backdrop, xStart, xEnd, yStart, yEnd, color;
	                            size = EnhancedScatterChart.getValueFromDataViewValueColumnById(measureSize, categoryIdx);
	                            colorFill = EnhancedScatterChart.getValueFromDataViewValueColumnById(measureColorFill, categoryIdx);
	                            shapeSymbolType = EnhancedScatterChart.getCustomSymbolType(EnhancedScatterChart.getValueFromDataViewValueColumnById(measureShape, categoryIdx));
	                            image = EnhancedScatterChart.getValueFromDataViewValueColumnById(measureImage, categoryIdx);
	                            rotation = EnhancedScatterChart.getNumberFromDataViewValueColumnById(measureRotation, categoryIdx);
	                            backdrop = EnhancedScatterChart.getValueFromDataViewValueColumnById(measureBackdrop, categoryIdx);
	                            xStart = EnhancedScatterChart.getValueFromDataViewValueColumnById(measureXStart, categoryIdx);
	                            xEnd = EnhancedScatterChart.getValueFromDataViewValueColumnById(measureXEnd, categoryIdx);
	                            yStart = EnhancedScatterChart.getValueFromDataViewValueColumnById(measureYStart, categoryIdx);
	                            yEnd = EnhancedScatterChart.getValueFromDataViewValueColumnById(measureYEnd, categoryIdx);
	                            if (hasDynamicSeries) {
	                                color = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name);
	                            }
	                            else {
	                                // If we have no Size measure then use a blank query name
	                                var measureSource = (measureSize != null)
	                                    ? measureSize.source.queryName
	                                    : "";
	                                color = colorHelper.getColorForMeasure(categoryObjects && categoryObjects[categoryIdx], measureSource);
	                            }
	                            var category = categories && categories.length > 0
	                                ? categories[indicies.category]
	                                : null;
	                            var identity = SelectionIdBuilder.builder()
	                                .withCategory(category, categoryIdx)
	                                .withSeries(dataValues, grouping)
	                                .createSelectionId();
	                            //TODO: need to refactor these lines below.
	                            var seriesData = [];
	                            if (dataValueSource) {
	                                // Dynamic series
	                                seriesData.push({ value: grouping.name, metadata: { source: dataValueSource, values: [] } });
	                            }
	                            if (measureX) {
	                                seriesData.push({ value: xVal, metadata: measureX });
	                            }
	                            if (measureY) {
	                                seriesData.push({ value: yVal, metadata: measureY });
	                            }
	                            if (measureSize && measureSize.values && measureSize.values.length > 0) {
	                                seriesData.push({ value: measureSize.values[categoryIdx], metadata: measureSize });
	                            }
	                            if (measureColorFill && measureColorFill.values && measureColorFill.values.length > 0) {
	                                seriesData.push({ value: measureColorFill.values[categoryIdx], metadata: measureColorFill });
	                            }
	                            if (measureShape && measureShape.values && measureShape.values.length > 0) {
	                                seriesData.push({ value: measureShape.values[categoryIdx], metadata: measureShape });
	                            }
	                            if (measureImage && measureImage.values && measureImage.values.length > 0) {
	                                seriesData.push({ value: measureImage.values[categoryIdx], metadata: measureImage });
	                            }
	                            if (measureRotation && measureRotation.values && measureRotation.values.length > 0) {
	                                seriesData.push({ value: measureRotation.values[categoryIdx], metadata: measureRotation });
	                            }
	                            if (measureBackdrop && measureBackdrop.values && measureBackdrop.values.length > 0) {
	                                seriesData.push({ value: measureBackdrop.values[categoryIdx], metadata: measureBackdrop });
	                            }
	                            if (measureXStart && measureXStart.values && measureXStart.values.length > 0) {
	                                seriesData.push({ value: measureXStart.values[categoryIdx], metadata: measureXStart });
	                            }
	                            if (measureXEnd && measureXEnd.values && measureXEnd.values.length > 0) {
	                                seriesData.push({ value: measureXEnd.values[categoryIdx], metadata: measureXEnd });
	                            }
	                            if (measureYStart && measureYStart.values && measureYStart.values.length > 0) {
	                                seriesData.push({ value: measureYStart.values[categoryIdx], metadata: measureYStart });
	                            }
	                            if (measureYEnd && measureYEnd.values && measureYEnd.values.length > 0) {
	                                seriesData.push({ value: measureYEnd.values[categoryIdx], metadata: measureYEnd });
	                            }
	                            var tooltipInfo = TooltipBuilder.createTooltipInfo(formatStringProp, /* formatStringProp */ undefined, /* dataViewCat */ categoryValue, /* categoryValue */ null, /* value */ category ? [category] : undefined, /* categories */ seriesData, /* seriesData */ undefined /* seriesIndex */);
	                            var dataPoint = {
	                                x: xVal,
	                                y: yVal,
	                                size: size,
	                                radius: { sizeMeasure: measureSize, index: categoryIdx },
	                                fill: color,
	                                formattedCategory: this.createLazyFormattedCategory(categoryFormatter, categoryValue),
	                                selected: false,
	                                identity: identity,
	                                tooltipInfo: tooltipInfo,
	                                labelFill: labelSettings.labelColor,
	                                labelFontSize: fontSizeInPx,
	                                contentPosition: 8,
	                                colorFill: colorFill,
	                                shapeSymbolType: shapeSymbolType,
	                                svgurl: image,
	                                rotation: rotation,
	                                backdrop: backdrop,
	                                xStart: xStart,
	                                xEnd: xEnd,
	                                yStart: yStart,
	                                yEnd: yEnd
	                            };
	                            dataPoints.push(dataPoint);
	                        }
	                    }
	                    return dataPoints;
	                };
	                EnhancedScatterChart.getMeasureValue = function (measureIndex, seriesValues) {
	                    if (seriesValues && measureIndex >= 0) {
	                        return seriesValues[measureIndex];
	                    }
	                    return null;
	                };
	                EnhancedScatterChart.getNumberFromDataViewValueColumnById = function (dataViewValueColumn, index) {
	                    var value = EnhancedScatterChart.getValueFromDataViewValueColumnById(dataViewValueColumn, index);
	                    return value && !isNaN(value)
	                        ? value
	                        : 0;
	                };
	                EnhancedScatterChart.getValueFromDataViewValueColumnById = function (dataViewValueColumn, index) {
	                    return dataViewValueColumn && dataViewValueColumn.values
	                        ? dataViewValueColumn.values[index]
	                        : null;
	                };
	                EnhancedScatterChart.getDefaultData = function () {
	                    return {
	                        xCol: undefined,
	                        yCol: undefined,
	                        dataPoints: [],
	                        legendData: { dataPoints: [] },
	                        axesLabels: { x: "", y: "" },
	                        selectedIds: [],
	                        sizeRange: [],
	                        dataLabelsSettings: dataLabelUtils.getDefaultPointLabelSettings(),
	                        defaultDataPointColor: null,
	                        hasDynamicSeries: false,
	                        useShape: false,
	                        useCustomColor: false,
	                    };
	                };
	                EnhancedScatterChart.prototype.setData = function (dataViews) {
	                    this.data = EnhancedScatterChart.getDefaultData();
	                    if (dataViews && dataViews.length > 0) {
	                        var dataView = dataViews[0];
	                        if (dataView) {
	                            this.categoryAxisProperties = this.getCategoryAxisProperties(dataView.metadata, true);
	                            this.valueAxisProperties = this.getValueAxisProperties(dataView.metadata, true);
	                            this.dataView = dataView;
	                            if (dataView.categorical && dataView.categorical.values) {
	                                this.data = EnhancedScatterChart.converter(dataView, this.colors, this.interactivityService, this.categoryAxisProperties, this.valueAxisProperties);
	                            }
	                        }
	                    }
	                };
	                EnhancedScatterChart.prototype.update = function (options) {
	                    debug.assertValue(options, "options");
	                    var dataViews = this.dataViews = options.dataViews;
	                    this.viewport = _.clone(options.viewport);
	                    if (!dataViews) {
	                        return;
	                    }
	                    if (dataViews && dataViews.length > 0) {
	                        var warnings = getInvalidValueWarnings(dataViews, false /*supportsNaN*/, false /*supportsNegativeInfinity*/, false /*supportsPositiveInfinity*/);
	                        if (warnings && warnings.length > 0)
	                            this.hostServices.setWarnings(warnings);
	                        this.populateObjectProperties(dataViews);
	                    }
	                    this.setData(dataViews);
	                    // Note: interactive legend shouldn"t be rendered explicitly here
	                    // The interactive legend is being rendered in the render method of ICartesianVisual
	                    if (!(this.options.interactivity && this.options.interactivity.isInteractiveLegend)) {
	                        this.renderLegend();
	                    }
	                    this.render(options.suppressAnimations);
	                };
	                EnhancedScatterChart.prototype.populateObjectProperties = function (dataViews) {
	                    if (dataViews && dataViews.length > 0) {
	                        var dataViewMetadata = dataViews[0].metadata;
	                        if (dataViewMetadata) {
	                            this.legendObjectProperties = DataViewObjects.getObject(dataViewMetadata.objects, "legend", {});
	                        }
	                        else {
	                            this.legendObjectProperties = {};
	                        }
	                        this.categoryAxisProperties = this.getCategoryAxisProperties(dataViewMetadata);
	                        this.valueAxisProperties = this.getValueAxisProperties(dataViewMetadata);
	                        var axisPosition = this.valueAxisProperties["position"];
	                        this.yAxisOrientation = axisPosition ? axisPosition.toString() : yAxisPosition.left;
	                    }
	                };
	                EnhancedScatterChart.prototype.renderLegend = function () {
	                    var legendData = { title: "", dataPoints: [] };
	                    var legend = this.legend;
	                    this.layerLegendData = this.data.legendData;
	                    if (this.layerLegendData) {
	                        legendData.title = this.layerLegendData.title || "";
	                        legendData.dataPoints = legendData.dataPoints.concat(this.layerLegendData.dataPoints || []);
	                        legendData.fontSize = this.legendLabelFontSize ? this.legendLabelFontSize : EnhancedScatterChart.LegendLabelFontSizeDefault;
	                        if (this.layerLegendData.grouped) {
	                            legendData.grouped = true;
	                        }
	                    }
	                    var legendProperties = this.legendObjectProperties;
	                    if (legendProperties) {
	                        LegendData.update(legendData, legendProperties);
	                        var position = legendProperties[legendProps.position];
	                        if (position)
	                            legend.changeOrientation(LegendPosition[position]);
	                    }
	                    else {
	                        legend.changeOrientation(LegendPosition.Top);
	                    }
	                    if (legendData.dataPoints.length === 1 && !legendData.grouped) {
	                        legendData.dataPoints = [];
	                    }
	                    var viewport = this.viewport;
	                    legend.drawLegend(legendData, { height: viewport.height, width: viewport.width });
	                    Legend.positionChartArea(this.svg, legend);
	                };
	                EnhancedScatterChart.prototype.shouldRenderAxis = function (axisProperties, propertyName) {
	                    if (propertyName === void 0) { propertyName = "show"; }
	                    if (!axisProperties) {
	                        return false;
	                    }
	                    else if (axisProperties.isCategoryAxis && (!this.categoryAxisProperties || this.categoryAxisProperties[propertyName] == null || this.categoryAxisProperties[propertyName])) {
	                        return axisProperties.values && axisProperties.values.length > 0;
	                    }
	                    else if (!axisProperties.isCategoryAxis && (!this.valueAxisProperties || this.valueAxisProperties[propertyName] == null || this.valueAxisProperties[propertyName])) {
	                        return axisProperties.values && axisProperties.values.length > 0;
	                    }
	                    return false;
	                };
	                EnhancedScatterChart.prototype.getMaxMarginFactor = function () {
	                    return this.options.style.maxMarginFactor || 0.25;
	                };
	                EnhancedScatterChart.prototype.adjustViewportbyBackdrop = function () {
	                    var img = new Image();
	                    var that = this;
	                    img.src = this.data.backdrop.url;
	                    img.onload = function () {
	                        if (that.oldBackdrop !== this.src) {
	                            that.render(true);
	                            that.oldBackdrop = this.src;
	                        }
	                    };
	                    if (img.width > 0 && img.height > 0) {
	                        if (img.width * this.viewportIn.height < this.viewportIn.width * img.height) {
	                            var deltaWidth = this.viewportIn.width - this.viewportIn.height * img.width / img.height;
	                            this.viewport = { width: this.viewport.width - deltaWidth, height: this.viewport.height };
	                        }
	                        else {
	                            var deltaHeight = this.viewportIn.height - this.viewportIn.width * img.height / img.width;
	                            this.viewport = { width: this.viewport.width, height: this.viewport.height - deltaHeight };
	                        }
	                    }
	                };
	                EnhancedScatterChart.prototype.render = function (suppressAnimations) {
	                    this.viewport.height -= this.legendViewport.height;
	                    this.viewport.width -= this.legendViewport.width;
	                    if (this.viewportIn.width === 0 || this.viewportIn.height === 0) {
	                        return;
	                    }
	                    var maxMarginFactor = this.getMaxMarginFactor();
	                    this.leftRightMarginLimit = this.viewport.width * maxMarginFactor;
	                    var bottomMarginLimit = this.bottomMarginLimit = Math.max(25, Math.ceil(this.viewport.height * maxMarginFactor));
	                    // reset defaults
	                    this.margin.top = 8;
	                    this.margin.bottom = bottomMarginLimit;
	                    this.margin.right = 0;
	                    this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, EnhancedScatterChart.TextProperties, true);
	                    this.yAxisIsCategorical = this.yAxisProperties.isCategoryAxis;
	                    this.hasCategoryAxis = this.yAxisIsCategorical ? this.yAxisProperties && this.yAxisProperties.values.length > 0 : this.xAxisProperties && this.xAxisProperties.values.length > 0;
	                    var renderXAxis = this.shouldRenderAxis(this.xAxisProperties);
	                    var renderY1Axis = this.shouldRenderAxis(this.yAxisProperties);
	                    var mainAxisScale;
	                    this.isXScrollBarVisible = false;
	                    this.isYScrollBarVisible = false;
	                    var tickLabelMargins;
	                    var axisLabels;
	                    var chartHasAxisLabels;
	                    var yAxisOrientation = this.yAxisOrientation;
	                    var showY1OnRight = yAxisOrientation === yAxisPosition.right;
	                    this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, EnhancedScatterChart.TextProperties, true);
	                    var doneWithMargins = false, maxIterations = 2, numIterations = 0;
	                    while (!doneWithMargins && numIterations < maxIterations) {
	                        numIterations++;
	                        tickLabelMargins = AxisHelper.getTickLabelMargins({ width: this.viewportIn.width, height: this.viewport.height }, this.leftRightMarginLimit, measureSvgTextWidth, measureSvgTextHeight, { x: this.xAxisProperties, y1: this.yAxisProperties }, this.bottomMarginLimit, EnhancedScatterChart.TextProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, showY1OnRight, renderXAxis, renderY1Axis, false);
	                        // We look at the y axes as main and second sides, if the y axis orientation is right so the main side represents the right side
	                        var maxMainYaxisSide = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft, maxSecondYaxisSide = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight, xMax = tickLabelMargins.xMax;
	                        maxMainYaxisSide += 10;
	                        maxSecondYaxisSide += 10;
	                        xMax += 12;
	                        if (showY1OnRight && renderY1Axis) {
	                            maxSecondYaxisSide += 20;
	                        }
	                        if (!showY1OnRight && renderY1Axis) {
	                            maxMainYaxisSide += 20;
	                        }
	                        this.addUnitTypeToAxisLabel(this.xAxisProperties, this.yAxisProperties);
	                        axisLabels = { x: this.xAxisProperties.axisLabel, y: this.yAxisProperties.axisLabel, y2: null };
	                        chartHasAxisLabels = (axisLabels.x != null) || (axisLabels.y != null || axisLabels.y2 != null);
	                        if (axisLabels.x != null)
	                            xMax += 18;
	                        if (axisLabels.y != null)
	                            maxMainYaxisSide += 20;
	                        if (axisLabels.y2 != null)
	                            maxSecondYaxisSide += 20;
	                        this.margin.left = showY1OnRight ? maxSecondYaxisSide : maxMainYaxisSide;
	                        this.margin.right = showY1OnRight ? maxMainYaxisSide : maxSecondYaxisSide;
	                        this.margin.bottom = xMax;
	                        // re-calculate the axes with the new margins
	                        var previousTickCountY1 = this.yAxisProperties.values.length;
	                        this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, EnhancedScatterChart.TextProperties, true);
	                        // the minor padding adjustments could have affected the chosen tick values, which would then need to calculate margins again
	                        // e.g. [0,2,4,6,8] vs. [0,5,10] the 10 is wider and needs more margin.
	                        if (this.yAxisProperties.values.length === previousTickCountY1)
	                            doneWithMargins = true;
	                    }
	                    // we have to do the above process again since changes are made to viewport.
	                    if (this.data.backdrop && this.data.backdrop.show && (this.data.backdrop.url !== undefined)) {
	                        this.adjustViewportbyBackdrop();
	                        doneWithMargins = false;
	                        maxIterations = 2;
	                        numIterations = 0;
	                        while (!doneWithMargins && numIterations < maxIterations) {
	                            numIterations++;
	                            tickLabelMargins = AxisHelper.getTickLabelMargins({ width: this.viewportIn.width, height: this.viewport.height }, this.leftRightMarginLimit, measureSvgTextWidth, measureSvgTextHeight, { x: this.xAxisProperties, y1: this.yAxisProperties }, this.bottomMarginLimit, EnhancedScatterChart.TextProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, showY1OnRight, renderXAxis, renderY1Axis, false);
	                            // We look at the y axes as main and second sides, if the y axis orientation is right so the main side represents the right side
	                            var maxMainYaxisSide = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft, maxSecondYaxisSide = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight, xMax = tickLabelMargins.xMax;
	                            maxMainYaxisSide += 10;
	                            if (showY1OnRight && renderY1Axis) {
	                                maxSecondYaxisSide += 15;
	                            }
	                            xMax += 12;
	                            this.addUnitTypeToAxisLabel(this.xAxisProperties, this.yAxisProperties);
	                            axisLabels = { x: this.xAxisProperties.axisLabel, y: this.yAxisProperties.axisLabel, y2: null };
	                            chartHasAxisLabels = (axisLabels.x != null) || (axisLabels.y != null || axisLabels.y2 != null);
	                            if (axisLabels.x != null)
	                                xMax += 18;
	                            if (axisLabels.y != null)
	                                maxMainYaxisSide += 20;
	                            if (axisLabels.y2 != null)
	                                maxSecondYaxisSide += 20;
	                            this.margin.left = showY1OnRight ? maxSecondYaxisSide : maxMainYaxisSide;
	                            this.margin.right = showY1OnRight ? maxMainYaxisSide : maxSecondYaxisSide;
	                            this.margin.bottom = xMax;
	                            // re-calculate the axes with the new margins
	                            var previousTickCountY1 = this.yAxisProperties.values.length;
	                            this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, EnhancedScatterChart.TextProperties, true);
	                            // the minor padding adjustments could have affected the chosen tick values, which would then need to calculate margins again
	                            // e.g. [0,2,4,6,8] vs. [0,5,10] the 10 is wider and needs more margin.
	                            if (this.yAxisProperties.values.length === previousTickCountY1)
	                                doneWithMargins = true;
	                        }
	                    }
	                    this.renderChart(mainAxisScale, this.xAxisProperties, this.yAxisProperties, tickLabelMargins, chartHasAxisLabels, axisLabels, suppressAnimations);
	                    this.updateAxis();
	                    if (!this.data) {
	                        return;
	                    }
	                    var data = this.data, dataPoints = this.data.dataPoints, hasSelection = this.interactivityService && this.interactivityService.hasSelection();
	                    this.mainGraphicsSVGSelection
	                        .attr("width", this.viewportIn.width)
	                        .attr("height", this.viewportIn.height);
	                    var sortedData = dataPoints.sort(function (a, b) {
	                        return b.radius.sizeMeasure
	                            ? (b.radius.sizeMeasure.values[b.radius.index] - a.radius.sizeMeasure.values[a.radius.index])
	                            : 0;
	                    });
	                    var duration = GetAnimationDuration(this.animator, suppressAnimations), scatterMarkers = this.drawScatterMarkers(sortedData, hasSelection, data.sizeRange, duration), dataLabelsSettings = this.data.dataLabelsSettings;
	                    if (dataLabelsSettings.show) {
	                        var layout, clonedDataPoints, labels;
	                        layout = this.getEnhanchedScatterChartLabelLayout(dataLabelsSettings, this.viewportIn, data.sizeRange);
	                        clonedDataPoints = this.cloneDataPoints(dataPoints);
	                        //fix bug 3863: drawDefaultLabelsForDataPointChart add to datapoints[xxx].size = object , which causes when
	                        //category labels is on and Fill Points option off to fill the points when mouse click occures because of default size
	                        //is set to datapoints.
	                        labels = dataLabelUtils.drawDefaultLabelsForDataPointChart(clonedDataPoints, this.mainGraphicsG, layout, this.viewportIn);
	                        if (labels) {
	                            labels.attr("transform", function (d) {
	                                var size = d.size, dx, dy;
	                                dx = size.width / EnhancedScatterChart.DataLabelXOffset;
	                                dy = size.height / EnhancedScatterChart.DataLabelYOffset;
	                                return SVGUtil.translate(dx, dy);
	                            });
	                        }
	                    }
	                    else {
	                        dataLabelUtils.cleanDataLabels(this.mainGraphicsG);
	                    }
	                    this.renderCrosshair();
	                    var behaviorOptions;
	                    if (this.interactivityService) {
	                        behaviorOptions = {
	                            dataPointsSelection: scatterMarkers,
	                            data: this.data,
	                            plotContext: this.mainGraphicsSVGSelection,
	                        };
	                    }
	                    addTooltip(scatterMarkers, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
	                    SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
	                    if (this.behavior) {
	                        var layerBehaviorOptions = [behaviorOptions];
	                        if (this.interactivityService) {
	                            var cbehaviorOptions = {
	                                layerOptions: layerBehaviorOptions,
	                                clearCatcher: this.clearCatcher,
	                            };
	                            this.interactivityService.bind(dataPoints, this.behavior, cbehaviorOptions);
	                        }
	                    }
	                };
	                EnhancedScatterChart.prototype.cloneDataPoints = function (dataPoints) {
	                    return dataPoints.map(function (dataPoint) {
	                        return _.clone(dataPoint);
	                    });
	                };
	                EnhancedScatterChart.prototype.darkenZeroLine = function (g) {
	                    var zeroTick = g.selectAll("g.tick").filter(function (data) { return data === 0; }).node();
	                    if (zeroTick) {
	                        d3.select(zeroTick).select("line").classed("zero-line", true);
	                    }
	                };
	                EnhancedScatterChart.prototype.getCategoryAxisFill = function () {
	                    if (this.dataView && this.dataView.metadata.objects) {
	                        var label = this.dataView.metadata.objects["categoryAxis"];
	                        if (label) {
	                            return label["axisColor"];
	                        }
	                    }
	                    return { solid: { color: "#333" } };
	                };
	                EnhancedScatterChart.prototype.getEnhanchedScatterChartLabelLayout = function (labelSettings, viewport, sizeRange) {
	                    var xScale = this.xAxisProperties.scale;
	                    var yScale = this.yAxisProperties.scale;
	                    var fontSizeInPx = fromPoint(labelSettings.fontSize);
	                    var fontFamily = LabelTextProperties.fontFamily;
	                    return {
	                        labelText: function (d) {
	                            return getLabelFormattedText({
	                                label: d.formattedCategory.getValue(),
	                                fontSize: labelSettings.fontSize,
	                                maxWidth: viewport.width,
	                            });
	                        },
	                        labelLayout: {
	                            x: function (d) { return xScale(d.x); },
	                            y: function (d) {
	                                var margin = EnhancedScatterChart.getBubbleRadius(d.radius, sizeRange, viewport) + dataLabelUtils.labelMargin;
	                                return labelSettings.position === 0 /* Above */
	                                    ? yScale(d.y) - margin
	                                    : yScale(d.y) + margin;
	                            },
	                        },
	                        filter: function (d) { return (d != null && d.formattedCategory.getValue() != null); },
	                        style: {
	                            "fill": function (d) { return d.labelFill; },
	                            "font-size": fontSizeInPx,
	                            "font-family": fontFamily,
	                        },
	                    };
	                };
	                EnhancedScatterChart.getBubbleRadius = function (radiusData, sizeRange, viewport) {
	                    var actualSizeDataRange = null, bubblePixelAreaSizeRange = null, measureSize = radiusData.sizeMeasure;
	                    if (!measureSize) {
	                        return EnhancedScatterChart.BubbleRadius;
	                    }
	                    var minSize = sizeRange.min ? sizeRange.min : 0, maxSize = sizeRange.max ? sizeRange.max : 0;
	                    var min = Math.min(minSize, 0), max = Math.max(maxSize, 0);
	                    actualSizeDataRange = {
	                        minRange: min,
	                        maxRange: max,
	                        delta: max - min
	                    };
	                    bubblePixelAreaSizeRange = EnhancedScatterChart.getBubblePixelAreaSizeRange(viewport, EnhancedScatterChart.MinSizeRange, EnhancedScatterChart.MaxSizeRange);
	                    if (measureSize.values) {
	                        var sizeValue = measureSize.values[radiusData.index];
	                        if (sizeValue != null) {
	                            return EnhancedScatterChart.projectSizeToPixels(sizeValue, actualSizeDataRange, bubblePixelAreaSizeRange) / 2;
	                        }
	                    }
	                    return EnhancedScatterChart.BubbleRadius;
	                };
	                EnhancedScatterChart.getBubblePixelAreaSizeRange = function (viewPort, minSizeRange, maxSizeRange) {
	                    var ratio = 1.0;
	                    if (viewPort.height > 0 && viewPort.width > 0) {
	                        var minSize = Math.min(viewPort.height, viewPort.width);
	                        ratio = (minSize * minSize) / EnhancedScatterChart.AreaOf300By300Chart;
	                    }
	                    var minRange = Math.round(minSizeRange * ratio), maxRange = Math.round(maxSizeRange * ratio);
	                    return {
	                        minRange: minRange,
	                        maxRange: maxRange,
	                        delta: maxRange - minRange
	                    };
	                };
	                EnhancedScatterChart.projectSizeToPixels = function (size, actualSizeDataRange, bubblePixelAreaSizeRange) {
	                    var projectedSize = 0;
	                    if (actualSizeDataRange) {
	                        // Project value on the required range of bubble area sizes
	                        projectedSize = bubblePixelAreaSizeRange.maxRange;
	                        if (actualSizeDataRange.delta !== 0) {
	                            var value = Math.min(Math.max(size, actualSizeDataRange.minRange), actualSizeDataRange.maxRange);
	                            projectedSize = EnhancedScatterChart.project(value, actualSizeDataRange, bubblePixelAreaSizeRange);
	                        }
	                        projectedSize = Math.sqrt(projectedSize / Math.PI) * 2;
	                    }
	                    return Math.round(projectedSize);
	                };
	                EnhancedScatterChart.project = function (value, actualSizeDataRange, bubblePixelAreaSizeRange) {
	                    if (actualSizeDataRange.delta === 0 || bubblePixelAreaSizeRange.delta === 0) {
	                        return (EnhancedScatterChart.rangeContains(actualSizeDataRange, value))
	                            ? bubblePixelAreaSizeRange.minRange
	                            : null;
	                    }
	                    var relativeX = (value - actualSizeDataRange.minRange) / actualSizeDataRange.delta;
	                    return bubblePixelAreaSizeRange.minRange + relativeX * bubblePixelAreaSizeRange.delta;
	                };
	                EnhancedScatterChart.rangeContains = function (range, value) {
	                    return range.minRange <= value && value <= range.maxRange;
	                };
	                EnhancedScatterChart.prototype.getValueAxisFill = function () {
	                    if (this.dataView && this.dataView.metadata.objects) {
	                        var label = this.dataView.metadata.objects["valueAxis"];
	                        if (label) {
	                            return label["axisColor"];
	                        }
	                    }
	                    return { solid: { color: "#333" } };
	                };
	                /**
	                 * Public for testability.
	                 */
	                EnhancedScatterChart.prototype.renderCrosshair = function () {
	                    if (!this.mainGraphicsSVGSelection) {
	                        return;
	                    }
	                    this.crosshairCanvasSelection = this.addCrosshairCanvasToDOM(this.mainGraphicsSVGSelection);
	                    if (this.data && this.data.crosshair) {
	                        this.crosshairVerticalLineSelection = this.addCrosshairLineToDOM(this.crosshairCanvasSelection, EnhancedScatterChart.CrosshairVerticalLineSelector);
	                        this.crosshairHorizontalLineSelection = this.addCrosshairLineToDOM(this.crosshairCanvasSelection, EnhancedScatterChart.CrosshairHorizontalLineSelector);
	                        this.crosshairTextSelection = this.addCrosshairTextToDOM(this.crosshairCanvasSelection);
	                        this.bindCrosshairEvents();
	                    }
	                    return this.crosshairCanvasSelection;
	                };
	                /**
	                 * Public for testability.
	                 */
	                EnhancedScatterChart.prototype.addCrosshairCanvasToDOM = function (rootElement) {
	                    var crosshairCanvasSelector = EnhancedScatterChart.CrosshairCanvasSelector;
	                    return this.addElementToDOM(rootElement, {
	                        name: "g",
	                        selector: crosshairCanvasSelector.selector,
	                        className: crosshairCanvasSelector.class,
	                        styles: { display: "none" }
	                    });
	                };
	                /**
	                 * Public for testability.
	                 */
	                EnhancedScatterChart.prototype.addCrosshairLineToDOM = function (rootElement, elementSelector) {
	                    var crosshairLineSelector = EnhancedScatterChart.CrosshairLineSelector;
	                    return this.addElementToDOM(rootElement, {
	                        name: "line",
	                        selector: elementSelector.selector,
	                        className: crosshairLineSelector.class + " " + elementSelector.class,
	                        attributes: { x1: 0, y1: 0, x2: 0, y2: 0 }
	                    });
	                };
	                /**
	                 * Public for testability.
	                 */
	                EnhancedScatterChart.prototype.addCrosshairTextToDOM = function (rootElement) {
	                    var crosshairTextSelector = EnhancedScatterChart.CrosshairTextSelector;
	                    return this.addElementToDOM(rootElement, {
	                        name: "text",
	                        selector: crosshairTextSelector.selector,
	                        className: crosshairTextSelector.class
	                    });
	                };
	                /**
	                 * Public for testability.
	                 */
	                EnhancedScatterChart.prototype.bindCrosshairEvents = function () {
	                    var _this = this;
	                    if (!this.axisGraphicsContextScrollable) {
	                        return;
	                    }
	                    this.axisGraphicsContextScrollable
	                        .on("mousemove", function () {
	                        var currentTarget = d3.event.currentTarget, coordinates = d3.mouse(currentTarget), svgNode = currentTarget.viewportElement, scaledRect = svgNode.getBoundingClientRect(), domRect = svgNode.getBBox(), ratioX = scaledRect.width / domRect.width, ratioY = scaledRect.height / domRect.height, x = coordinates[0], y = coordinates[1];
	                        if (domRect.width > 0 && !equalWithPrecision(ratioX, 1.0, 0.00001)) {
	                            x = x / ratioX;
	                        }
	                        if (domRect.height > 0 && !equalWithPrecision(ratioY, 1.0, 0.00001)) {
	                            y = y / ratioY;
	                        }
	                        _this.updateCrosshair(x, y);
	                    })
	                        .on("mouseover", function () {
	                        _this.crosshairCanvasSelection.style("display", "block");
	                    })
	                        .on("mouseout", function () {
	                        _this.crosshairCanvasSelection.style("display", "none");
	                    });
	                };
	                /**
	                 * Public for testability.
	                 */
	                EnhancedScatterChart.prototype.updateCrosshair = function (x, y) {
	                    if (!this.viewportIn ||
	                        !this.crosshairHorizontalLineSelection ||
	                        !this.crosshairVerticalLineSelection ||
	                        !this.crosshairTextSelection ||
	                        !this.xAxisProperties) {
	                        return;
	                    }
	                    var crosshairTextMargin = EnhancedScatterChart.CrosshairTextMargin, xScale = this.xAxisProperties.scale, yScale = this.yAxisProperties.scale, xFormated, yFormated;
	                    this.crosshairHorizontalLineSelection
	                        .attr({ x1: 0, y1: y, x2: this.viewportIn.width, y2: y });
	                    this.crosshairVerticalLineSelection
	                        .attr({ x1: x, y1: 0, x2: x, y2: this.viewportIn.height });
	                    xFormated = Math.round(xScale.invert(x) * 100) / 100;
	                    yFormated = Math.round(yScale.invert(y) * 100) / 100;
	                    this.crosshairTextSelection
	                        .attr({ x: x + crosshairTextMargin, y: y - crosshairTextMargin })
	                        .text("(" + xFormated + ", " + yFormated + ")");
	                };
	                /**
	                 * Public for testability.
	                 */
	                EnhancedScatterChart.prototype.addElementToDOM = function (rootElement, properties) {
	                    if (!rootElement || !properties) {
	                        return null;
	                    }
	                    var elementSelection, elementUpdateSelection;
	                    elementSelection = rootElement
	                        .selectAll(properties.selector);
	                    elementUpdateSelection = elementSelection.data(properties.data || [[]]);
	                    elementUpdateSelection
	                        .enter()
	                        .append(properties.name)
	                        .attr(properties.attributes)
	                        .style(properties.styles)
	                        .classed(properties.className, true);
	                    elementUpdateSelection
	                        .exit()
	                        .remove();
	                    return elementUpdateSelection;
	                };
	                EnhancedScatterChart.prototype.renderBackground = function () {
	                    if (this.data.backdrop && this.data.backdrop.show && (this.data.backdrop.url !== undefined)) {
	                        this.backgroundGraphicsContext
	                            .attr("xlink:href", this.data.backdrop.url)
	                            .attr("x", 0)
	                            .attr("y", 0)
	                            .attr("width", this.viewportIn.width)
	                            .attr("height", this.viewportIn.height);
	                    }
	                    else {
	                        this.backgroundGraphicsContext
	                            .attr("width", 0)
	                            .attr("height", 0);
	                    }
	                };
	                EnhancedScatterChart.prototype.renderChart = function (mainAxisScale, xAxis, yAxis, tickLabelMargins, chartHasAxisLabels, axisLabels, suppressAnimations, scrollScale, extent) {
	                    var bottomMarginLimit = this.bottomMarginLimit, leftRightMarginLimit = this.leftRightMarginLimit, duration = GetAnimationDuration(this.animator, suppressAnimations);
	                    this.renderBackground();
	                    //hide show x-axis here
	                    if (this.shouldRenderAxis(xAxis)) {
	                        xAxis.axis.orient("bottom");
	                        if (!xAxis.willLabelsFit)
	                            xAxis.axis.tickPadding(5);
	                        var xAxisGraphicsElement = this.xAxisGraphicsContext;
	                        if (duration) {
	                            xAxisGraphicsElement
	                                .transition()
	                                .duration(duration)
	                                .call(xAxis.axis)
	                                .call(this.darkenZeroLine);
	                        }
	                        else {
	                            xAxisGraphicsElement
	                                .call(xAxis.axis)
	                                .call(this.darkenZeroLine);
	                        }
	                        var xZeroTick = xAxisGraphicsElement
	                            .selectAll("g.tick")
	                            .filter(function (data) { return data === 0; });
	                        if (xZeroTick) {
	                            var xZeroColor = this.getValueAxisFill();
	                            if (xZeroColor) {
	                                xZeroTick
	                                    .selectAll("line")
	                                    .style({ "stroke": xZeroColor.solid.color });
	                            }
	                        }
	                        var xAxisTextNodes = xAxisGraphicsElement.selectAll("text");
	                        if (xAxis.willLabelsWordBreak) {
	                            xAxisTextNodes.call(AxisHelper.LabelLayoutStrategy.wordBreak, xAxis, bottomMarginLimit);
	                        }
	                        else {
	                            xAxisTextNodes.call(AxisHelper.LabelLayoutStrategy.rotate, bottomMarginLimit, getTailoredTextOrDefault, EnhancedScatterChart.TextProperties, !xAxis.willLabelsFit, bottomMarginLimit === tickLabelMargins.xMax, xAxis, this.margin, this.isXScrollBarVisible || this.isYScrollBarVisible);
	                        }
	                    }
	                    else {
	                        this.xAxisGraphicsContext.selectAll("*").remove();
	                    }
	                    if (this.shouldRenderAxis(yAxis)) {
	                        var yAxisOrientation = this.yAxisOrientation;
	                        yAxis.axis
	                            .tickSize(-this.viewportIn.width)
	                            .tickPadding(10)
	                            .orient(yAxisOrientation.toLowerCase());
	                        var y1AxisGraphicsElement = this.y1AxisGraphicsContext;
	                        if (duration) {
	                            y1AxisGraphicsElement
	                                .transition()
	                                .duration(duration)
	                                .call(yAxis.axis)
	                                .call(this.darkenZeroLine);
	                        }
	                        else {
	                            y1AxisGraphicsElement
	                                .call(yAxis.axis)
	                                .call(this.darkenZeroLine);
	                        }
	                        var yZeroTick = y1AxisGraphicsElement.selectAll("g.tick").filter(function (data) { return data === 0; });
	                        if (yZeroTick) {
	                            var yZeroColor = this.getCategoryAxisFill();
	                            if (yZeroColor) {
	                                yZeroTick.selectAll("line").style({ "stroke": yZeroColor.solid.color });
	                            }
	                        }
	                        if (tickLabelMargins.yLeft >= leftRightMarginLimit) {
	                            y1AxisGraphicsElement.selectAll("text")
	                                .call(AxisHelper.LabelLayoutStrategy.clip, 
	                            // Can"t use padding space to render text, so subtract that from available space for ellipses calculations
	                            leftRightMarginLimit - 10, svgEllipsis);
	                        }
	                    }
	                    else {
	                        this.y1AxisGraphicsContext.selectAll("*").remove();
	                    }
	                    // Axis labels
	                    //TODO: Add label for second Y axis for combo chart
	                    if (chartHasAxisLabels) {
	                        var hideXAxisTitle = !this.shouldRenderAxis(xAxis, "showAxisTitle");
	                        var hideYAxisTitle = !this.shouldRenderAxis(yAxis, "showAxisTitle");
	                        var hideY2AxisTitle = this.valueAxisProperties && this.valueAxisProperties["secShowAxisTitle"] != null && this.valueAxisProperties["secShowAxisTitle"] === false;
	                        this.renderAxesLabels(axisLabels, this.legendViewport.height, hideXAxisTitle, hideYAxisTitle, hideY2AxisTitle);
	                    }
	                    else {
	                        this.axisGraphicsContext.selectAll(".xAxisLabel").remove();
	                        this.axisGraphicsContext.selectAll(".yAxisLabel").remove();
	                    }
	                };
	                EnhancedScatterChart.prototype.renderAxesLabels = function (axisLabels, legendMargin, hideXAxisTitle, hideYAxisTitle, hideY2AxisTitle) {
	                    this.axisGraphicsContext.selectAll(".xAxisLabel").remove();
	                    this.axisGraphicsContext.selectAll(".yAxisLabel").remove();
	                    var margin = this.margin;
	                    var width = this.viewportIn.width;
	                    var height = this.viewport.height;
	                    var fontSize = EnhancedScatterChart.AxisFontSize;
	                    var yAxisOrientation = this.yAxisOrientation;
	                    var showY1OnRight = yAxisOrientation === yAxisPosition.right;
	                    if (!hideXAxisTitle) {
	                        var xAxisLabel = this.axisGraphicsContext.append("text")
	                            .style("text-anchor", "middle")
	                            .text(axisLabels.x)
	                            .call(function (text) {
	                            text.each(function () {
	                                var text = d3.select(this);
	                                text.attr({
	                                    "class": "xAxisLabel",
	                                    "transform": SVGUtil.translate(width / 2, height - fontSize - 2)
	                                });
	                            });
	                        });
	                        xAxisLabel.call(AxisHelper.LabelLayoutStrategy.clip, width, svgEllipsis);
	                    }
	                    if (!hideYAxisTitle) {
	                        var yAxisLabel = this.axisGraphicsContext.append("text")
	                            .style("text-anchor", "middle")
	                            .text(axisLabels.y)
	                            .call(function (text) {
	                            text.each(function () {
	                                var text = d3.select(this);
	                                text.attr({
	                                    "class": "yAxisLabel",
	                                    "transform": "rotate(-90)",
	                                    "y": showY1OnRight ? width + margin.right - fontSize : -margin.left,
	                                    "x": -((height - margin.top - legendMargin) / 2),
	                                    "dy": "1em"
	                                });
	                            });
	                        });
	                        yAxisLabel.call(AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), svgEllipsis);
	                    }
	                    if (!hideY2AxisTitle && axisLabels.y2) {
	                        var y2AxisLabel = this.axisGraphicsContext.append("text")
	                            .style("text-anchor", "middle")
	                            .text(axisLabels.y2)
	                            .call(function (text) {
	                            text.each(function () {
	                                var text = d3.select(this);
	                                text.attr({
	                                    "class": "yAxisLabel",
	                                    "transform": "rotate(-90)",
	                                    "y": showY1OnRight ? -margin.left : width + margin.right - fontSize,
	                                    "x": -((height - margin.top - legendMargin) / 2),
	                                    "dy": "1em"
	                                });
	                            });
	                        });
	                        y2AxisLabel.call(AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), svgEllipsis);
	                    }
	                };
	                EnhancedScatterChart.prototype.updateAxis = function () {
	                    this.adjustMargins();
	                    var yAxisOrientation = this.yAxisOrientation;
	                    var showY1OnRight = yAxisOrientation === yAxisPosition.right;
	                    this.xAxisGraphicsContext
	                        .attr("transform", SVGUtil.translate(0, this.viewportIn.height));
	                    this.y1AxisGraphicsContext
	                        .attr("transform", SVGUtil.translate(showY1OnRight ? this.viewportIn.width : 0, 0));
	                    this.svg.attr({
	                        "width": this.viewport.width,
	                        "height": this.viewport.height
	                    });
	                    this.svgScrollable.attr({
	                        "width": this.viewport.width,
	                        "height": this.viewport.height
	                    });
	                    this.svgScrollable.attr({
	                        "x": 0
	                    });
	                    var left = this.margin.left;
	                    var top = this.margin.top;
	                    this.axisGraphicsContext.attr("transform", SVGUtil.translate(left, top));
	                    this.axisGraphicsContextScrollable.attr("transform", SVGUtil.translate(left, top));
	                    this.clearCatcher.attr("transform", SVGUtil.translate(-left, -top));
	                    if (this.isXScrollBarVisible) {
	                        this.svgScrollable.attr({
	                            "x": left
	                        });
	                        this.axisGraphicsContextScrollable.attr("transform", SVGUtil.translate(0, top));
	                        this.svgScrollable.attr("width", this.viewportIn.width);
	                        this.svg.attr("width", this.viewport.width)
	                            .attr("height", this.viewport.height + this.ScrollBarWidth);
	                    }
	                    else if (this.isYScrollBarVisible) {
	                        this.svgScrollable.attr("height", this.viewportIn.height + top);
	                        this.svg.attr("width", this.viewport.width + this.ScrollBarWidth)
	                            .attr("height", this.viewport.height);
	                    }
	                };
	                EnhancedScatterChart.prototype.getUnitType = function (xAxis) {
	                    if (xAxis.formatter &&
	                        xAxis.formatter.displayUnit &&
	                        xAxis.formatter.displayUnit.value > 1)
	                        return xAxis.formatter.displayUnit.title;
	                    return null;
	                };
	                EnhancedScatterChart.prototype.addUnitTypeToAxisLabel = function (xAxis, yAxis) {
	                    var unitType = this.getUnitType(xAxis);
	                    if (xAxis.isCategoryAxis) {
	                        this.categoryAxisHasUnitType = unitType !== null;
	                    }
	                    else {
	                        this.valueAxisHasUnitType = unitType !== null;
	                    }
	                    if (xAxis.axisLabel && unitType) {
	                        if (xAxis.isCategoryAxis) {
	                            xAxis.axisLabel = AxisHelper.createAxisLabel(this.categoryAxisProperties, xAxis.axisLabel, unitType);
	                        }
	                        else {
	                            xAxis.axisLabel = AxisHelper.createAxisLabel(this.valueAxisProperties, xAxis.axisLabel, unitType);
	                        }
	                    }
	                    unitType = this.getUnitType(yAxis);
	                    if (!yAxis.isCategoryAxis) {
	                        this.valueAxisHasUnitType = unitType !== null;
	                    }
	                    else {
	                        this.categoryAxisHasUnitType = unitType !== null;
	                    }
	                    if (yAxis.axisLabel && unitType) {
	                        if (!yAxis.isCategoryAxis) {
	                            yAxis.axisLabel = AxisHelper.createAxisLabel(this.valueAxisProperties, yAxis.axisLabel, unitType);
	                        }
	                        else {
	                            yAxis.axisLabel = AxisHelper.createAxisLabel(this.categoryAxisProperties, yAxis.axisLabel, unitType);
	                        }
	                    }
	                };
	                EnhancedScatterChart.prototype.drawScatterMarkers = function (scatterData, hasSelection, sizeRange, duration) {
	                    var _this = this;
	                    var xScale = this.xAxisProperties.scale, yScale = this.yAxisProperties.scale, shouldEnableFill = (!sizeRange || !sizeRange.min) && this.data.fillPoint;
	                    var markers, useCustomColor = this.data.useCustomColor;
	                    if (!this.data.useShape) {
	                        this.mainGraphicsContext
	                            .selectAll(EnhancedScatterChart.ImageClasses.selector)
	                            .remove();
	                        markers = this.mainGraphicsContext
	                            .classed("ScatterMarkers", true)
	                            .selectAll(EnhancedScatterChart.DotClasses.selector)
	                            .data(scatterData, function (d) { return d.identity.getKey(); });
	                        markers
	                            .enter()
	                            .append("path")
	                            .classed(EnhancedScatterChart.DotClasses.class, true)
	                            .attr("id", "markershape");
	                        markers
	                            .style({
	                            "stroke-opacity": function (d) {
	                                return EnhancedScatterChart.getBubbleOpacity(d, hasSelection);
	                            },
	                            "stroke-width": "1px",
	                            "stroke": function (d) {
	                                var color = useCustomColor ? d.colorFill : d.fill;
	                                if (_this.data.outline) {
	                                    return d3.rgb(color).darker();
	                                }
	                                else {
	                                    return d3.rgb(color);
	                                }
	                            },
	                            "fill": function (d) { return d3.rgb(useCustomColor ? d.colorFill : d.fill); },
	                            "fill-opacity": function (d) { return (d.size != null || shouldEnableFill)
	                                ? EnhancedScatterChart.getBubbleOpacity(d, hasSelection) : 0; },
	                        })
	                            .attr("d", function (d) {
	                            var r = EnhancedScatterChart.getBubbleRadius(d.radius, sizeRange, _this.viewport), area = 4 * r * r;
	                            return d.shapeSymbolType(area);
	                        })
	                            .transition()
	                            .duration(function (d) {
	                            if (_this.keyArray.indexOf(d.identity.getKey()) >= 0) {
	                                return duration;
	                            }
	                            else {
	                                return 0;
	                            }
	                        })
	                            .attr("transform", function (d) { return "translate(" + xScale(d.x) + "," + yScale(d.y) + ") rotate(" + d.rotation + ")"; });
	                    }
	                    else {
	                        this.mainGraphicsContext
	                            .selectAll(EnhancedScatterChart.DotClasses.selector)
	                            .remove();
	                        markers = this.mainGraphicsContext
	                            .classed("ScatterMarkers", true)
	                            .selectAll(EnhancedScatterChart.ImageClasses.selector)
	                            .data(scatterData, function (d) { return d.identity.getKey(); });
	                        markers
	                            .enter()
	                            .append("svg:image")
	                            .classed(EnhancedScatterChart.ImageClasses.class, true)
	                            .attr("id", "markerimage");
	                        markers
	                            .attr("xlink:href", function (d) {
	                            if (d.svgurl !== undefined && d.svgurl != null && d.svgurl !== "") {
	                                return d.svgurl;
	                            }
	                            else {
	                                return _this.svgDefaultImage;
	                            }
	                        })
	                            .attr("width", function (d) {
	                            return EnhancedScatterChart.getBubbleRadius(d.radius, sizeRange, _this.viewport) * 2;
	                        })
	                            .attr("height", function (d) {
	                            return EnhancedScatterChart.getBubbleRadius(d.radius, sizeRange, _this.viewport) * 2;
	                        })
	                            .transition()
	                            .duration(function (d) {
	                            if (_this.keyArray.indexOf(d.identity.getKey()) >= 0) {
	                                return duration;
	                            }
	                            else {
	                                return 0;
	                            }
	                        })
	                            .attr("transform", function (d) {
	                            var radius = EnhancedScatterChart.getBubbleRadius(d.radius, sizeRange, _this.viewport);
	                            return "translate(" + (xScale(d.x) - radius) + "," + (yScale(d.y) - radius) + ") rotate(" + d.rotation + "," + radius + "," + radius + ")";
	                        });
	                    }
	                    markers.exit().remove();
	                    this.keyArray = [];
	                    for (var i = 0; i < scatterData.length; i++) {
	                        this.keyArray.push(scatterData[i].identity.getKey());
	                    }
	                    return markers;
	                };
	                EnhancedScatterChart.getBubbleOpacity = function (d, hasSelection) {
	                    if (hasSelection && !d.selected) {
	                        return EnhancedScatterChart.DimmedBubbleOpacity;
	                    }
	                    return EnhancedScatterChart.DefaultBubbleOpacity;
	                };
	                EnhancedScatterChart.prototype.calculateAxes = function (categoryAxisProperties, valueAxisProperties, textProperties, scrollbarVisible) {
	                    var visualOptions = {
	                        viewport: this.viewport,
	                        margin: this.margin,
	                        forcedXDomain: [categoryAxisProperties ? categoryAxisProperties["start"] : null, categoryAxisProperties ? categoryAxisProperties["end"] : null],
	                        forceMerge: valueAxisProperties && valueAxisProperties["secShow"] === false,
	                        showCategoryAxisLabel: false,
	                        showValueAxisLabel: false,
	                        categoryAxisScaleType: categoryAxisProperties && categoryAxisProperties["axisScale"] != null ? categoryAxisProperties["axisScale"] : null,
	                        valueAxisScaleType: valueAxisProperties && valueAxisProperties["axisScale"] != null ? valueAxisProperties["axisScale"] : null,
	                        valueAxisDisplayUnits: valueAxisProperties && valueAxisProperties["labelDisplayUnits"] != null ? valueAxisProperties["labelDisplayUnits"] : EnhancedScatterChart.LabelDisplayUnitsDefault,
	                        categoryAxisDisplayUnits: categoryAxisProperties && categoryAxisProperties["labelDisplayUnits"] != null ? categoryAxisProperties["labelDisplayUnits"] : EnhancedScatterChart.LabelDisplayUnitsDefault,
	                        trimOrdinalDataOnOverflow: false
	                    };
	                    if (valueAxisProperties) {
	                        visualOptions.forcedYDomain = AxisHelper.applyCustomizedDomain([valueAxisProperties["start"], valueAxisProperties["end"]], visualOptions.forcedYDomain);
	                    }
	                    visualOptions.showCategoryAxisLabel = (!!categoryAxisProperties && !!categoryAxisProperties["showAxisTitle"]);
	                    visualOptions.showValueAxisLabel = true;
	                    var width = this.viewport.width - (this.margin.left + this.margin.right);
	                    var axes = this.calculateAxesProperties(visualOptions);
	                    axes[0].willLabelsFit = AxisHelper.LabelLayoutStrategy.willLabelsFit(axes[0], width, measureSvgTextWidth, textProperties);
	                    // If labels do not fit and we are not scrolling, try word breaking
	                    axes[0].willLabelsWordBreak = (!axes[0].willLabelsFit && !scrollbarVisible) && AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(axes[0], this.margin, width, measureSvgTextWidth, estimateSvgTextHeight, getTailoredTextOrDefault, textProperties);
	                    return axes;
	                };
	                EnhancedScatterChart.prototype.calculateAxesProperties = function (options) {
	                    var data = this.data, dataPoints = data.dataPoints;
	                    this.margin = options.margin;
	                    this.viewport = options.viewport;
	                    var minY = 0, maxY = 10, minX = 0, maxX = 10;
	                    if (dataPoints.length > 0) {
	                        minY = d3.min(dataPoints, function (d) { return d.y; });
	                        maxY = d3.max(dataPoints, function (d) { return d.y; });
	                        minX = d3.min(dataPoints, function (d) { return d.x; });
	                        maxX = d3.max(dataPoints, function (d) { return d.x; });
	                    }
	                    var xDomain = [minX, maxX], combinedXDomain, combinedYDomain, xAxisFormatString, yAxisFormatString;
	                    combinedXDomain = AxisHelper.combineDomain(this.optimizeTranslateValues(options.forcedXDomain), xDomain);
	                    xAxisFormatString = valueFormatter.getFormatString(data.xCol, EnhancedScatterChart.Properties["general"]["formatString"]);
	                    this.xAxisProperties = AxisHelper.createAxis({
	                        pixelSpan: this.viewportIn.width,
	                        dataDomain: combinedXDomain,
	                        metaDataColumn: data.xCol,
	                        formatString: xAxisFormatString,
	                        outerPadding: 0,
	                        isScalar: true,
	                        isVertical: false,
	                        forcedTickCount: options.forcedTickCount,
	                        useTickIntervalForDisplayUnits: true,
	                        isCategoryAxis: true,
	                        scaleType: options.categoryAxisScaleType,
	                        axisDisplayUnits: options.categoryAxisDisplayUnits
	                    });
	                    this.xAxisProperties.axis.tickSize(-this.viewportIn.height, 0);
	                    this.xAxisProperties.axisLabel = this.data.axesLabels.x;
	                    combinedYDomain = AxisHelper.combineDomain(this.optimizeTranslateValues(options.forcedYDomain), [minY, maxY]);
	                    yAxisFormatString = valueFormatter.getFormatString(data.yCol, EnhancedScatterChart.Properties["general"]["formatString"]);
	                    this.yAxisProperties = AxisHelper.createAxis({
	                        pixelSpan: this.viewportIn.height,
	                        dataDomain: combinedYDomain,
	                        metaDataColumn: data.yCol,
	                        formatString: yAxisFormatString,
	                        outerPadding: 0,
	                        isScalar: true,
	                        isVertical: true,
	                        forcedTickCount: options.forcedTickCount,
	                        useTickIntervalForDisplayUnits: true,
	                        isCategoryAxis: false,
	                        scaleType: options.valueAxisScaleType,
	                        axisDisplayUnits: options.valueAxisDisplayUnits
	                    });
	                    this.yAxisProperties.axisLabel = this.data.axesLabels.y;
	                    return [this.xAxisProperties, this.yAxisProperties];
	                };
	                /**
	                 * Public for testability.
	                 */
	                EnhancedScatterChart.prototype.optimizeTranslateValues = function (values) {
	                    var _this = this;
	                    if (values && values.map) {
	                        return values.map(function (value) {
	                            return _this.optimizeTranslateValue(value);
	                        });
	                    }
	                    return values;
	                };
	                /**
	                 * Public for testability.
	                 */
	                EnhancedScatterChart.prototype.optimizeTranslateValue = function (value) {
	                    if (value) {
	                        var numberSign = value >= 0 ? 1 : -1, absoluteValue = Math.abs(value);
	                        if (absoluteValue > EnhancedScatterChart.MaxTranslateValue) {
	                            return EnhancedScatterChart.MaxTranslateValue * numberSign;
	                        }
	                        else if (absoluteValue < EnhancedScatterChart.MinTranslateValue) {
	                            return EnhancedScatterChart.MinTranslateValue * numberSign;
	                        }
	                    }
	                    return value;
	                };
	                EnhancedScatterChart.prototype.enumerateDataPoints = function (enumeration) {
	                    var data = this.data;
	                    if (!data)
	                        return;
	                    var seriesCount = data.dataPoints.length;
	                    if (!data.hasDynamicSeries) {
	                        var showAllDataPoints = data.showAllDataPoints;
	                        // Add default color and show all slices
	                        enumeration.pushInstance({
	                            objectName: "dataPoint",
	                            selector: null,
	                            properties: {
	                                defaultColor: {
	                                    solid: { color: data.defaultDataPointColor || this.colors.getColorByIndex(0).value }
	                                }
	                            }
	                        }).pushInstance({
	                            objectName: "dataPoint",
	                            selector: null,
	                            properties: { showAllDataPoints: showAllDataPoints }
	                        });
	                        if (showAllDataPoints) {
	                            for (var i = 0; i < seriesCount; i++) {
	                                var seriesDataPoints = data.dataPoints[i];
	                                enumeration.pushInstance({
	                                    objectName: "dataPoint",
	                                    displayName: seriesDataPoints.formattedCategory.getValue(),
	                                    selector: ColorHelper.normalizeSelector(seriesDataPoints.identity.getSelector(), /*isSingleSeries*/ true),
	                                    properties: {
	                                        fill: { solid: { color: seriesDataPoints.fill } }
	                                    },
	                                });
	                            }
	                        }
	                    }
	                    else {
	                        var legendDataPointLength = data.legendData.dataPoints.length;
	                        for (var i = 0; i < legendDataPointLength; i++) {
	                            var series = data.legendData.dataPoints[i];
	                            enumeration.pushInstance({
	                                objectName: "dataPoint",
	                                displayName: series.label,
	                                selector: ColorHelper.normalizeSelector(series.identity.getSelector()),
	                                properties: {
	                                    fill: { solid: { color: series.color } }
	                                },
	                            });
	                        }
	                    }
	                };
	                EnhancedScatterChart.prototype.enumerateObjectInstances = function (options) {
	                    var enumeration = new ObjectEnumerationBuilder();
	                    switch (options.objectName) {
	                        case "dataPoint":
	                            var categoricalDataView = this.dataView && this.dataView.categorical ? this.dataView.categorical : null;
	                            if (!GradientUtils.hasGradientRole(categoricalDataView))
	                                this.enumerateDataPoints(enumeration);
	                            break;
	                        case "categoryAxis":
	                            this.getCategoryAxisValues(enumeration);
	                            break;
	                        case "valueAxis":
	                            this.getValueAxisValues(enumeration);
	                            break;
	                        case "categoryLabels":
	                            if (this.data)
	                                dataLabelUtils.enumerateCategoryLabels(enumeration, this.data.dataLabelsSettings, true);
	                            else
	                                dataLabelUtils.enumerateCategoryLabels(enumeration, null, true);
	                            break;
	                        case "fillPoint":
	                            var sizeRange = this.data.sizeRange;
	                            // Check if the card should be shown or not
	                            if (sizeRange && sizeRange.min)
	                                break;
	                            enumeration.pushInstance({
	                                objectName: "fillPoint",
	                                selector: null,
	                                properties: {
	                                    show: this.data.fillPoint,
	                                },
	                            });
	                            break;
	                        case "backdrop":
	                            enumeration.pushInstance({
	                                objectName: "backdrop",
	                                displayName: "Backdrop",
	                                selector: null,
	                                properties: {
	                                    show: this.data.backdrop ? this.data.backdrop.show : false,
	                                    url: this.data.backdrop ? this.data.backdrop.url : null
	                                },
	                            });
	                            break;
	                        case "crosshair":
	                            enumeration.pushInstance({
	                                objectName: "crosshair",
	                                selector: null,
	                                properties: {
	                                    show: this.data.crosshair
	                                },
	                            });
	                            break;
	                        case "outline":
	                            enumeration.pushInstance({
	                                objectName: "outline",
	                                selector: null,
	                                properties: {
	                                    show: this.data.outline
	                                },
	                            });
	                            break;
	                        case "legend":
	                            this.enumerateLegend(enumeration);
	                            break;
	                    }
	                    return enumeration.complete();
	                };
	                EnhancedScatterChart.prototype.hasLegend = function () {
	                    return this.data && this.data.hasDynamicSeries;
	                };
	                EnhancedScatterChart.prototype.enumerateLegend = function (enumeration) {
	                    if (!this.hasLegend()) {
	                        return;
	                    }
	                    var show = DataViewObject.getValue(this.legendObjectProperties, legendProps.show, this.legend.isVisible());
	                    var showTitle = DataViewObject.getValue(this.legendObjectProperties, legendProps.showTitle, true);
	                    var titleText = DataViewObject.getValue(this.legendObjectProperties, legendProps.titleText, this.layerLegendData ? this.layerLegendData.title : "");
	                    var legendLabelColor = DataViewObject.getValue(this.legendObjectProperties, legendProps.labelColor, LegendData.DefaultLegendLabelFillColor);
	                    this.legendLabelFontSize = DataViewObject.getValue(this.legendObjectProperties, legendProps.fontSize, EnhancedScatterChart.LegendLabelFontSizeDefault);
	                    var position = DataViewObject.getValue(this.legendObjectProperties, legendProps.position, legendPosition.top);
	                    enumeration.pushInstance({
	                        selector: null,
	                        properties: {
	                            show: show,
	                            position: position,
	                            showTitle: showTitle,
	                            titleText: titleText,
	                            labelColor: legendLabelColor,
	                            fontSize: this.legendLabelFontSize,
	                        },
	                        objectName: "legend"
	                    });
	                };
	                EnhancedScatterChart.prototype.getCategoryAxisValues = function (enumeration) {
	                    var supportedType = axisType.both, isScalar = true, logPossible = false, scaleOptions = [
	                        axisScale.log,
	                        axisScale.linear
	                    ]; //until options can be update in propPane, show all options
	                    if (!isScalar) {
	                        if (this.categoryAxisProperties) {
	                            this.categoryAxisProperties["start"] = null;
	                            this.categoryAxisProperties["end"] = null;
	                        }
	                    }
	                    var instance = {
	                        selector: null,
	                        properties: {},
	                        objectName: "categoryAxis",
	                        validValues: {
	                            axisScale: scaleOptions
	                        }
	                    };
	                    instance.properties["show"] = this.categoryAxisProperties && this.categoryAxisProperties["show"] != null ? this.categoryAxisProperties["show"] : true;
	                    if (this.yAxisIsCategorical)
	                        instance.properties["position"] = this.valueAxisProperties && this.valueAxisProperties["position"] != null ? this.valueAxisProperties["position"] : yAxisPosition.left;
	                    if (supportedType === axisType.both) {
	                        instance.properties["axisType"] = isScalar ? axisType.scalar : axisType.categorical;
	                    }
	                    if (isScalar) {
	                        instance.properties["axisScale"] = (this.categoryAxisProperties && this.categoryAxisProperties["axisScale"] != null && logPossible) ? this.categoryAxisProperties["axisScale"] : axisScale.linear;
	                        instance.properties["start"] = this.categoryAxisProperties ? this.categoryAxisProperties["start"] : null;
	                        instance.properties["end"] = this.categoryAxisProperties ? this.categoryAxisProperties["end"] : null;
	                        instance.properties["labelDisplayUnits"] = this.categoryAxisProperties && this.categoryAxisProperties["labelDisplayUnits"] != null ? this.categoryAxisProperties["labelDisplayUnits"] : EnhancedScatterChart.LabelDisplayUnitsDefault;
	                    }
	                    instance.properties["showAxisTitle"] = this.categoryAxisProperties && this.categoryAxisProperties["showAxisTitle"] != null ? this.categoryAxisProperties["showAxisTitle"] : true;
	                    enumeration
	                        .pushInstance(instance)
	                        .pushInstance({
	                        selector: null,
	                        properties: {
	                            axisStyle: this.categoryAxisProperties && this.categoryAxisProperties["axisStyle"]
	                                ? this.categoryAxisProperties["axisStyle"] : axisStyle.showTitleOnly,
	                            labelColor: this.categoryAxisProperties ? this.categoryAxisProperties["labelColor"] : null
	                        },
	                        objectName: "categoryAxis",
	                        validValues: {
	                            axisStyle: this.categoryAxisHasUnitType
	                                ? [axisStyle.showTitleOnly, axisStyle.showUnitOnly, axisStyle.showBoth]
	                                : [axisStyle.showTitleOnly]
	                        }
	                    });
	                };
	                //todo: wrap all these object getters and other related stuff into an interface
	                EnhancedScatterChart.prototype.getValueAxisValues = function (enumeration) {
	                    var scaleOptions = [axisScale.log, axisScale.linear]; //until options can be update in propPane, show all options
	                    var logPossible = false;
	                    var instance = {
	                        selector: null,
	                        properties: {},
	                        objectName: "valueAxis",
	                        validValues: {
	                            axisScale: scaleOptions,
	                            secAxisScale: scaleOptions
	                        }
	                    };
	                    instance.properties["show"] = this.valueAxisProperties && this.valueAxisProperties["show"] != null ? this.valueAxisProperties["show"] : true;
	                    if (!this.yAxisIsCategorical) {
	                        instance.properties["position"] = this.valueAxisProperties && this.valueAxisProperties["position"] != null ? this.valueAxisProperties["position"] : yAxisPosition.left;
	                    }
	                    instance.properties["axisScale"] = (this.valueAxisProperties && this.valueAxisProperties["axisScale"] != null && logPossible) ? this.valueAxisProperties["axisScale"] : axisScale.linear;
	                    instance.properties["start"] = this.valueAxisProperties ? this.valueAxisProperties["start"] : null;
	                    instance.properties["end"] = this.valueAxisProperties ? this.valueAxisProperties["end"] : null;
	                    instance.properties["showAxisTitle"] = this.valueAxisProperties && this.valueAxisProperties["showAxisTitle"] != null ? this.valueAxisProperties["showAxisTitle"] : true;
	                    instance.properties["labelDisplayUnits"] = this.valueAxisProperties && this.valueAxisProperties["labelDisplayUnits"] != null ? this.valueAxisProperties["labelDisplayUnits"] : EnhancedScatterChart.LabelDisplayUnitsDefault;
	                    enumeration
	                        .pushInstance(instance)
	                        .pushInstance({
	                        selector: null,
	                        properties: {
	                            axisStyle: this.valueAxisProperties && this.valueAxisProperties["axisStyle"] != null ? this.valueAxisProperties["axisStyle"] : axisStyle.showTitleOnly,
	                            labelColor: this.valueAxisProperties ? this.valueAxisProperties["labelColor"] : null
	                        },
	                        objectName: "valueAxis",
	                        validValues: {
	                            axisStyle: this.valueAxisHasUnitType ? [axisStyle.showTitleOnly, axisStyle.showUnitOnly, axisStyle.showBoth] : [axisStyle.showTitleOnly]
	                        },
	                    });
	                };
	                EnhancedScatterChart.prototype.onClearSelection = function () {
	                    if (this.interactivityService)
	                        this.interactivityService.clearSelection();
	                };
	                EnhancedScatterChart.AxisGraphicsContextClassName = "axisGraphicsContext";
	                EnhancedScatterChart.ClassName = "enhancedScatterChart";
	                EnhancedScatterChart.MainGraphicsContextClassName = "mainGraphicsContext";
	                EnhancedScatterChart.LegendLabelFontSizeDefault = 9;
	                EnhancedScatterChart.LabelDisplayUnitsDefault = 0;
	                EnhancedScatterChart.AxisFontSize = 11;
	                EnhancedScatterChart.CrosshairTextMargin = 5;
	                EnhancedScatterChart.BubbleRadius = 3 * 2;
	                EnhancedScatterChart.MinSizeRange = 200;
	                EnhancedScatterChart.MaxSizeRange = 3000;
	                EnhancedScatterChart.AreaOf300By300Chart = 90000;
	                EnhancedScatterChart.DataLabelXOffset = 2;
	                EnhancedScatterChart.DataLabelYOffset = 1.8;
	                EnhancedScatterChart.DotClasses = createClassAndSelector("dot");
	                EnhancedScatterChart.ImageClasses = createClassAndSelector("img");
	                EnhancedScatterChart.TextProperties = {
	                    fontFamily: "'Segoe UI', wf_segoe-ui_normal, helvetica, arial, sans-serif",
	                    fontSize: PixelConverter.toString(EnhancedScatterChart.AxisFontSize),
	                };
	                EnhancedScatterChart.CrosshairCanvasSelector = createClassAndSelector("crosshairCanvas");
	                EnhancedScatterChart.CrosshairLineSelector = createClassAndSelector("crosshairLine");
	                EnhancedScatterChart.CrosshairVerticalLineSelector = createClassAndSelector("crosshairVerticalLine");
	                EnhancedScatterChart.CrosshairHorizontalLineSelector = createClassAndSelector("crosshairHorizontalLine");
	                EnhancedScatterChart.CrosshairTextSelector = createClassAndSelector("crosshairText");
	                EnhancedScatterChart.MaxTranslateValue = 1e+25;
	                EnhancedScatterChart.MinTranslateValue = 1e-25;
	                EnhancedScatterChart.DefaultBubbleOpacity = 0.85;
	                EnhancedScatterChart.DimmedBubbleOpacity = 0.4;
	                EnhancedScatterChart.ColumnCategory = "Category";
	                EnhancedScatterChart.ColumnSeries = "Series";
	                EnhancedScatterChart.ColumnX = "X";
	                EnhancedScatterChart.ColumnY = "Y";
	                EnhancedScatterChart.ColumnSize = "Size";
	                EnhancedScatterChart.ColumnGradient = "Gradient";
	                EnhancedScatterChart.ColumnColorFill = "ColorFill";
	                EnhancedScatterChart.ColumnShape = "Shape";
	                EnhancedScatterChart.ColumnImage = "Image";
	                EnhancedScatterChart.ColumnRotation = "Rotation";
	                EnhancedScatterChart.ColumnBackdrop = "Backdrop";
	                EnhancedScatterChart.ColumnXStart = "X Start";
	                EnhancedScatterChart.ColumnXEnd = "X End";
	                EnhancedScatterChart.ColumnYStart = "Y Start";
	                EnhancedScatterChart.ColumnYEnd = "Y End";
	                EnhancedScatterChart.capabilities = {
	                    dataRoles: [
	                        {
	                            name: EnhancedScatterChart.ColumnCategory,
	                            kind: VisualDataRoleKind.Grouping,
	                            displayName: createDisplayNameGetter("Role_DisplayName_Details"),
	                        }, {
	                            name: EnhancedScatterChart.ColumnSeries,
	                            kind: VisualDataRoleKind.Grouping,
	                            displayName: createDisplayNameGetter("Role_DisplayName_Legend"),
	                        }, {
	                            name: EnhancedScatterChart.ColumnX,
	                            kind: VisualDataRoleKind.Measure,
	                            displayName: createDisplayNameGetter("Role_DisplayName_X"),
	                        }, {
	                            name: EnhancedScatterChart.ColumnY,
	                            kind: VisualDataRoleKind.Measure,
	                            displayName: createDisplayNameGetter("Role_DisplayName_Y"),
	                        }, {
	                            name: EnhancedScatterChart.ColumnSize,
	                            kind: VisualDataRoleKind.Measure,
	                            displayName: createDisplayNameGetter("Role_DisplayName_Size"),
	                        }, {
	                            name: EnhancedScatterChart.ColumnGradient,
	                            kind: VisualDataRoleKind.Measure,
	                            displayName: createDisplayNameGetter("Role_DisplayName_Gradient"),
	                        }, {
	                            name: EnhancedScatterChart.ColumnColorFill,
	                            kind: VisualDataRoleKind.Grouping,
	                            displayName: "Customized Color",
	                        }, {
	                            name: EnhancedScatterChart.ColumnShape,
	                            kind: VisualDataRoleKind.Measure,
	                            displayName: "Shape",
	                        }, {
	                            name: EnhancedScatterChart.ColumnImage,
	                            kind: VisualDataRoleKind.Grouping,
	                            displayName: "Image",
	                        }, {
	                            name: EnhancedScatterChart.ColumnRotation,
	                            kind: VisualDataRoleKind.Measure,
	                            displayName: "Rotation",
	                        }, {
	                            name: EnhancedScatterChart.ColumnBackdrop,
	                            kind: VisualDataRoleKind.Grouping,
	                            displayName: "Backdrop",
	                        }, {
	                            name: EnhancedScatterChart.ColumnXStart,
	                            kind: VisualDataRoleKind.Measure,
	                            displayName: "X Start",
	                        }, {
	                            name: EnhancedScatterChart.ColumnXEnd,
	                            kind: VisualDataRoleKind.Measure,
	                            displayName: "X End",
	                        }, {
	                            name: EnhancedScatterChart.ColumnYStart,
	                            kind: VisualDataRoleKind.Measure,
	                            displayName: "Y Start",
	                        }, {
	                            name: EnhancedScatterChart.ColumnYEnd,
	                            kind: VisualDataRoleKind.Measure,
	                            displayName: "Y End",
	                        }
	                    ],
	                    dataViewMappings: [{
	                            conditions: [{
	                                    "Category": { max: 1 },
	                                    "Series": { max: 1 },
	                                    "X": { max: 1 },
	                                    "Y": { max: 1 },
	                                    "Size": { max: 1 },
	                                    "Gradient": { max: 0 },
	                                    "ColorFill": { max: 1 },
	                                    "Shape": { max: 1 },
	                                    "Image": { max: 0 },
	                                    "Rotation": { max: 1 },
	                                    "Backdrop": { max: 1 },
	                                    "X Start": { max: 1 },
	                                    "X End": { max: 1 },
	                                    "Y Start": { max: 1 },
	                                    "Y End": { max: 1 }
	                                }, {
	                                    "Category": { max: 1 },
	                                    "Series": { max: 0 },
	                                    "X": { max: 1 },
	                                    "Y": { max: 1 },
	                                    "Size": { max: 1 },
	                                    "Gradient": { max: 1 },
	                                    "ColorFill": { max: 1 },
	                                    "Shape": { max: 1 },
	                                    "Image": { max: 0 },
	                                    "Rotation": { max: 1 },
	                                    "Backdrop": { max: 1 },
	                                    "X Start": { max: 1 },
	                                    "X End": { max: 1 },
	                                    "Y Start": { max: 1 },
	                                    "Y End": { max: 1 }
	                                }, {
	                                    "Category": { max: 1 },
	                                    "Series": { max: 1 },
	                                    "X": { max: 1 },
	                                    "Y": { max: 1 },
	                                    "Size": { max: 1 },
	                                    "Gradient": { max: 0 },
	                                    "ColorFill": { max: 0 },
	                                    "Shape": { max: 0 },
	                                    "Image": { max: 1 },
	                                    "Rotation": { max: 1 },
	                                    "Backdrop": { max: 1 },
	                                    "X Start": { max: 1 },
	                                    "X End": { max: 1 },
	                                    "Y Start": { max: 1 },
	                                    "Y End": { max: 1 }
	                                }, {
	                                    "Category": { max: 1 },
	                                    "Series": { max: 0 },
	                                    "X": { max: 1 },
	                                    "Y": { max: 1 },
	                                    "Size": { max: 1 },
	                                    "Gradient": { max: 1 },
	                                    "ColorFill": { max: 0 },
	                                    "Shape": { max: 0 },
	                                    "Image": { max: 1 },
	                                    "Rotation": { max: 1 },
	                                    "Backdrop": { max: 1 },
	                                    "X Start": { max: 1 },
	                                    "X End": { max: 1 },
	                                    "Y Start": { max: 1 },
	                                    "Y End": { max: 1 }
	                                }],
	                            categorical: {
	                                categories: {
	                                    for: { in: EnhancedScatterChart.ColumnCategory },
	                                    dataReductionAlgorithm: { sample: {} }
	                                },
	                                values: {
	                                    group: {
	                                        by: EnhancedScatterChart.ColumnSeries,
	                                        select: [
	                                            { bind: { to: EnhancedScatterChart.ColumnX } },
	                                            { bind: { to: EnhancedScatterChart.ColumnY } },
	                                            { bind: { to: EnhancedScatterChart.ColumnSize } },
	                                            { bind: { to: EnhancedScatterChart.ColumnGradient } },
	                                            { bind: { to: EnhancedScatterChart.ColumnColorFill } },
	                                            { bind: { to: EnhancedScatterChart.ColumnShape } },
	                                            { bind: { to: EnhancedScatterChart.ColumnImage } },
	                                            { bind: { to: EnhancedScatterChart.ColumnRotation } },
	                                            { bind: { to: EnhancedScatterChart.ColumnBackdrop } },
	                                            { bind: { to: EnhancedScatterChart.ColumnXStart } },
	                                            { bind: { to: EnhancedScatterChart.ColumnXEnd } },
	                                            { bind: { to: EnhancedScatterChart.ColumnYStart } },
	                                            { bind: { to: EnhancedScatterChart.ColumnYEnd } },
	                                        ],
	                                        dataReductionAlgorithm: { top: {} }
	                                    }
	                                },
	                                rowCount: { preferred: { min: 2 } }
	                            },
	                        }],
	                    objects: {
	                        dataPoint: {
	                            displayName: createDisplayNameGetter("Visual_DataPoint"),
	                            properties: {
	                                defaultColor: {
	                                    displayName: createDisplayNameGetter("Visual_DefaultColor"),
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                showAllDataPoints: {
	                                    displayName: createDisplayNameGetter("Visual_DataPoint_Show_All"),
	                                    type: { bool: true }
	                                },
	                                useShape: {
	                                    displayName: createDisplayNameGetter("Visual_UseImage"),
	                                    type: { bool: true }
	                                },
	                                fill: {
	                                    displayName: createDisplayNameGetter("Visual_Fill"),
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                fillRule: {
	                                    displayName: createDisplayNameGetter("Visual_Gradient"),
	                                    type: { fillRule: {} },
	                                    rule: {
	                                        inputRole: EnhancedScatterChart.ColumnGradient,
	                                        output: {
	                                            property: "fill",
	                                            selector: [EnhancedScatterChart.ColumnCategory],
	                                        },
	                                    }
	                                }
	                            }
	                        },
	                        general: {
	                            displayName: createDisplayNameGetter("Visual_General"),
	                            properties: {
	                                formatString: {
	                                    type: { formatting: { formatString: true } },
	                                },
	                            },
	                        },
	                        categoryAxis: {
	                            displayName: createDisplayNameGetter("Visual_XAxis"),
	                            properties: {
	                                show: {
	                                    displayName: createDisplayNameGetter("Visual_Show"),
	                                    type: { bool: true }
	                                },
	                                axisScale: {
	                                    displayName: createDisplayNameGetter("Visual_Axis_Scale"),
	                                    type: { formatting: { axisScale: true } }
	                                },
	                                start: {
	                                    displayName: createDisplayNameGetter("Visual_Axis_Start"),
	                                    type: { numeric: true }
	                                },
	                                end: {
	                                    displayName: createDisplayNameGetter("Visual_Axis_End"),
	                                    type: { numeric: true }
	                                },
	                                showAxisTitle: {
	                                    displayName: createDisplayNameGetter("Visual_Axis_Title"),
	                                    type: { bool: true }
	                                },
	                                axisStyle: {
	                                    displayName: createDisplayNameGetter("Visual_Axis_Style"),
	                                    type: { formatting: { axisStyle: true } }
	                                },
	                                axisColor: {
	                                    displayName: "Color",
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                labelDisplayUnits: {
	                                    displayName: "Display Units",
	                                    type: { formatting: { labelDisplayUnits: true } },
	                                },
	                            }
	                        },
	                        valueAxis: {
	                            displayName: createDisplayNameGetter("Visual_YAxis"),
	                            properties: {
	                                show: {
	                                    displayName: createDisplayNameGetter("Visual_Show"),
	                                    type: { bool: true }
	                                },
	                                position: {
	                                    displayName: createDisplayNameGetter("Visual_YAxis_Position"),
	                                    type: { formatting: { yAxisPosition: true } }
	                                },
	                                axisScale: {
	                                    displayName: createDisplayNameGetter("Visual_Axis_Scale"),
	                                    type: { formatting: { axisScale: true } }
	                                },
	                                start: {
	                                    displayName: createDisplayNameGetter("Visual_Axis_Start"),
	                                    type: { numeric: true }
	                                },
	                                end: {
	                                    displayName: createDisplayNameGetter("Visual_Axis_End"),
	                                    type: { numeric: true }
	                                },
	                                showAxisTitle: {
	                                    displayName: createDisplayNameGetter("Visual_Axis_Title"),
	                                    type: { bool: true }
	                                },
	                                axisStyle: {
	                                    displayName: createDisplayNameGetter("Visual_Axis_Style"),
	                                    type: { formatting: { axisStyle: true } }
	                                },
	                                axisColor: {
	                                    displayName: "Color",
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                labelDisplayUnits: {
	                                    displayName: "Display Units",
	                                    type: { formatting: { labelDisplayUnits: true } },
	                                }
	                            }
	                        },
	                        legend: {
	                            displayName: createDisplayNameGetter("Visual_Legend"),
	                            properties: {
	                                show: {
	                                    displayName: createDisplayNameGetter("Visual_Show"),
	                                    type: { bool: true }
	                                },
	                                position: {
	                                    displayName: createDisplayNameGetter("Visual_LegendPosition"),
	                                    description: createDisplayNameGetter("Visual_LegendPositionDescription"),
	                                    type: { enumeration: legendPosition.type },
	                                },
	                                showTitle: {
	                                    displayName: createDisplayNameGetter("Visual_LegendShowTitle"),
	                                    description: createDisplayNameGetter("Visual_LegendShowTitleDescription"),
	                                    type: { bool: true }
	                                },
	                                titleText: {
	                                    displayName: "Legend Name",
	                                    description: createDisplayNameGetter("Visual_LegendNameDescription"),
	                                    type: { text: true }
	                                },
	                                labelColor: {
	                                    displayName: "Color",
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                fontSize: {
	                                    displayName: "Text Size",
	                                    type: { formatting: { fontSize: true } }
	                                }
	                            }
	                        },
	                        categoryLabels: {
	                            displayName: createDisplayNameGetter("Visual_CategoryLabels"),
	                            properties: {
	                                show: {
	                                    displayName: createDisplayNameGetter("Visual_Show"),
	                                    type: { bool: true }
	                                },
	                                color: {
	                                    displayName: createDisplayNameGetter("Visual_LabelsFill"),
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                fontSize: {
	                                    displayName: "Text Size",
	                                    type: { formatting: { fontSize: true } }
	                                },
	                            },
	                        },
	                        fillPoint: {
	                            displayName: createDisplayNameGetter("Visual_FillPoint"),
	                            properties: {
	                                show: {
	                                    displayName: createDisplayNameGetter("Visual_Fill"),
	                                    type: { bool: true }
	                                },
	                            },
	                        },
	                        backdrop: {
	                            displayName: "Backdrop",
	                            properties: {
	                                show: {
	                                    displayName: createDisplayNameGetter("Visual_Show"),
	                                    type: { bool: true }
	                                },
	                                url: {
	                                    displayName: "Image URL",
	                                    type: { text: true }
	                                },
	                            },
	                        },
	                        crosshair: {
	                            displayName: "Crosshair",
	                            properties: {
	                                show: {
	                                    displayName: "Crosshair",
	                                    type: { bool: true }
	                                },
	                            },
	                        },
	                        outline: {
	                            displayName: "Outline",
	                            properties: {
	                                show: {
	                                    displayName: createDisplayNameGetter("Visual_Outline"),
	                                    type: { bool: true }
	                                }
	                            }
	                        }
	                    }
	                };
	                /**
	                 * Public for testability.
	                 */
	                EnhancedScatterChart.Properties = EnhancedScatterChart.getPropertiesByCapabilities(EnhancedScatterChart.capabilities);
	                return EnhancedScatterChart;
	            }());
	            samples.EnhancedScatterChart = EnhancedScatterChart;
	            var CustomVisualBehavior = (function () {
	                function CustomVisualBehavior(behaviors) {
	                    this.behaviors = behaviors || [];
	                }
	                CustomVisualBehavior.prototype.bindEvents = function (options, selectionHandler) {
	                    var behaviors = this.behaviors;
	                    for (var i = 0, ilen = behaviors.length; i < ilen; i++) {
	                        behaviors[i].bindEvents(options.layerOptions[i], selectionHandler);
	                    }
	                    options.clearCatcher.on("click", function () {
	                        selectionHandler.handleClearSelection();
	                    });
	                };
	                CustomVisualBehavior.prototype.renderSelection = function (hasSelection) {
	                    for (var _i = 0, _a = this.behaviors; _i < _a.length; _i++) {
	                        var behavior = _a[_i];
	                        behavior.renderSelection(hasSelection);
	                    }
	                };
	                return CustomVisualBehavior;
	            }());
	            samples.CustomVisualBehavior = CustomVisualBehavior;
	            var EnhancedScatterChartWebBehavior = (function () {
	                function EnhancedScatterChartWebBehavior(dimmedBubbleOpacity, defaultBubbleOpacity) {
	                    this.dimmedBubbleOpacity = dimmedBubbleOpacity;
	                    this.defaultBubbleOpacity = defaultBubbleOpacity;
	                }
	                EnhancedScatterChartWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
	                    var bubbles = this.bubbles = options.dataPointsSelection, data = options.data;
	                    this.shouldEnableFill = (!data.sizeRange || !data.sizeRange.min) && data.fillPoint;
	                    this.colorBorder = data.colorBorder;
	                    registerStandardInteractivityHandlers(bubbles, selectionHandler);
	                };
	                EnhancedScatterChartWebBehavior.prototype.renderSelection = function (hasSelection) {
	                    var _this = this;
	                    var shouldEnableFill = this.shouldEnableFill, colorBorder = this.colorBorder;
	                    this.bubbles.style("fill-opacity", function (d) {
	                        return _this.getMarkerFillOpacity(d.size != null, shouldEnableFill, hasSelection, d.selected);
	                    });
	                    this.bubbles.style("stroke-opacity", function (d) {
	                        return _this.getMarkerStrokeOpacity(d.size != null, colorBorder, hasSelection, d.selected);
	                    });
	                };
	                EnhancedScatterChartWebBehavior.prototype.getMarkerFillOpacity = function (hasSize, shouldEnableFill, hasSelection, isSelected) {
	                    if (hasSize || shouldEnableFill) {
	                        if (hasSelection && !isSelected) {
	                            return this.dimmedBubbleOpacity;
	                        }
	                        return this.defaultBubbleOpacity;
	                    }
	                    else {
	                        return 0;
	                    }
	                };
	                EnhancedScatterChartWebBehavior.prototype.getMarkerStrokeOpacity = function (hasSize, colorBorder, hasSelection, isSelected) {
	                    if (hasSize && colorBorder) {
	                        return 1;
	                    }
	                    else {
	                        if (hasSelection && !isSelected) {
	                            return this.dimmedBubbleOpacity;
	                        }
	                        return this.defaultBubbleOpacity;
	                    }
	                };
	                return EnhancedScatterChartWebBehavior;
	            }());
	            samples.EnhancedScatterChartWebBehavior = EnhancedScatterChartWebBehavior;
	        })(samples = visuals.samples || (visuals.samples = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 47 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../../../_references.ts"/>
	var THREE;
	var WebGLHeatmap;
	var GlobeMapCanvasLayers;
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var samples;
	        (function (samples) {
	            var VisualLayout = (function () {
	                function VisualLayout(defaultViewport, defaultMargin) {
	                    this.defaultViewport = defaultViewport || { width: 0, height: 0 };
	                    this.defaultMargin = defaultMargin || { top: 0, bottom: 0, right: 0, left: 0 };
	                }
	                Object.defineProperty(VisualLayout.prototype, "viewport", {
	                    get: function () {
	                        return this.viewportValue || (this.viewportValue = this.defaultViewport);
	                    },
	                    set: function (value) {
	                        var _this = this;
	                        this.previousOriginalViewportValue = _.clone(this.originalViewportValue);
	                        this.originalViewportValue = _.clone(value);
	                        this.setUpdateObject(value, function (v) { return _this.viewportValue = v; }, function (o) { return VisualLayout.restrictToMinMax(o, _this.minViewport); });
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(VisualLayout.prototype, "viewportCopy", {
	                    get: function () {
	                        return _.clone(this.viewport);
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(VisualLayout.prototype, "viewportIn", {
	                    //Returns viewport minus margin
	                    get: function () {
	                        return this.viewportInValue || this.viewport;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(VisualLayout.prototype, "minViewport", {
	                    get: function () {
	                        return this.minViewportValue || { width: 0, height: 0 };
	                    },
	                    set: function (value) {
	                        var _this = this;
	                        this.setUpdateObject(value, function (v) { return _this.minViewportValue = v; }, VisualLayout.restrictToMinMax);
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(VisualLayout.prototype, "margin", {
	                    get: function () {
	                        return this.marginValue || (this.marginValue = this.defaultMargin);
	                    },
	                    set: function (value) {
	                        var _this = this;
	                        this.setUpdateObject(value, function (v) { return _this.marginValue = v; }, VisualLayout.restrictToMinMax);
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(VisualLayout.prototype, "viewportChanged", {
	                    //Returns true if viewport has updated after last change.
	                    get: function () {
	                        return !!this.originalViewportValue && (!this.previousOriginalViewportValue
	                            || this.previousOriginalViewportValue.height !== this.originalViewportValue.height
	                            || this.previousOriginalViewportValue.width !== this.originalViewportValue.width);
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(VisualLayout.prototype, "viewportInIsZero", {
	                    get: function () {
	                        return this.viewportIn.width === 0 || this.viewportIn.height === 0;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                VisualLayout.prototype.resetMargin = function () {
	                    this.margin = this.defaultMargin;
	                };
	                VisualLayout.prototype.update = function () {
	                    this.viewportInValue = VisualLayout.restrictToMinMax({
	                        width: this.viewport.width - (this.margin.left + this.margin.right),
	                        height: this.viewport.height - (this.margin.top + this.margin.bottom)
	                    }, this.minViewportValue);
	                };
	                VisualLayout.prototype.setUpdateObject = function (object, setObjectFn, beforeUpdateFn) {
	                    var _this = this;
	                    object = _.clone(object);
	                    setObjectFn(VisualLayout.createNotifyChangedObject(object, function (o) {
	                        if (beforeUpdateFn)
	                            beforeUpdateFn(object);
	                        _this.update();
	                    }));
	                    if (beforeUpdateFn)
	                        beforeUpdateFn(object);
	                    this.update();
	                };
	                VisualLayout.createNotifyChangedObject = function (object, objectChanged) {
	                    var result = {};
	                    _.keys(object).forEach(function (key) { return Object.defineProperty(result, key, {
	                        get: function () { return object[key]; },
	                        set: function (value) { object[key] = value; objectChanged(object, key); },
	                        enumerable: true,
	                        configurable: true
	                    }); });
	                    return result;
	                };
	                VisualLayout.restrictToMinMax = function (value, minValue) {
	                    _.keys(value).forEach(function (x) { return value[x] = Math.max(minValue && minValue[x] || 0, value[x]); });
	                    return value;
	                };
	                return VisualLayout;
	            }());
	            var GlobeMapSettings = (function () {
	                function GlobeMapSettings() {
	                    //Default Settings
	                    this.dataPoint = {};
	                }
	                Object.defineProperty(GlobeMapSettings, "Default", {
	                    get: function () {
	                        return new this();
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                GlobeMapSettings.parse = function (dataView, capabilities) {
	                    var settings = new this();
	                    if (!dataView || !dataView.metadata || !dataView.metadata.objects) {
	                        return settings;
	                    }
	                    var properties = this.getProperties(capabilities);
	                    for (var objectKey in capabilities.objects) {
	                        for (var propKey in capabilities.objects[objectKey].properties) {
	                            if (!settings[objectKey] || !_.has(settings[objectKey], propKey)) {
	                                continue;
	                            }
	                            var type = capabilities.objects[objectKey].properties[propKey].type;
	                            var getValueFn = this.getValueFnByType(type);
	                            settings[objectKey][propKey] = getValueFn(dataView.metadata.objects, properties[objectKey][propKey], settings[objectKey][propKey]);
	                        }
	                    }
	                    return settings;
	                };
	                GlobeMapSettings.getProperties = function (capabilities) {
	                    var objects = _.merge({
	                        general: { properties: { formatString: {} } }
	                    }, capabilities.objects);
	                    var properties = {};
	                    for (var objectKey in objects) {
	                        properties[objectKey] = {};
	                        for (var propKey in objects[objectKey].properties) {
	                            properties[objectKey][propKey] = {
	                                objectName: objectKey,
	                                propertyName: propKey
	                            };
	                        }
	                    }
	                    return properties;
	                };
	                GlobeMapSettings.createEnumTypeFromEnum = function (type) {
	                    var even = false;
	                    return powerbi.createEnumType(Object.keys(type)
	                        .filter(function (key, i) { return ((!!(i % 2)) === even && type[key] === key
	                        && !void (even = !even)) || (!!(i % 2)) !== even; })
	                        .map(function (x) { return { value: x, displayName: x }; }));
	                };
	                GlobeMapSettings.getValueFnByType = function (type) {
	                    switch (_.keys(type)[0]) {
	                        case "fill":
	                            return powerbi.DataViewObjects.getFillColor;
	                        default:
	                            return powerbi.DataViewObjects.getValue;
	                    }
	                };
	                GlobeMapSettings.enumerateObjectInstances = function (settings, options, capabilities) {
	                    if (settings === void 0) { settings = new this(); }
	                    var enumeration = new visuals.ObjectEnumerationBuilder();
	                    var object = settings && settings[options.objectName];
	                    if (!object) {
	                        return enumeration;
	                    }
	                    var instance = {
	                        objectName: options.objectName,
	                        selector: null,
	                        properties: {}
	                    };
	                    for (var key in object) {
	                        if (_.has(object, key)) {
	                            instance.properties[key] = object[key];
	                        }
	                    }
	                    enumeration.pushInstance(instance);
	                    return enumeration;
	                };
	                GlobeMapSettings.prototype.createOriginalSettings = function () {
	                    this.originalSettings = _.cloneDeep(this);
	                };
	                return GlobeMapSettings;
	            }());
	            samples.GlobeMapSettings = GlobeMapSettings;
	            var GlobeMapColumns = (function () {
	                function GlobeMapColumns() {
	                    //Data Roles
	                    this.Category = null;
	                    this.Series = null;
	                    this.X = null;
	                    this.Y = null;
	                    this.Height = null;
	                    this.Heat = null;
	                }
	                GlobeMapColumns.getColumnSources = function (dataView) {
	                    return this.getColumnSourcesT(dataView);
	                };
	                GlobeMapColumns.getTableValues = function (dataView) {
	                    var table = dataView && dataView.table;
	                    var columns = this.getColumnSourcesT(dataView);
	                    return columns && table && _.mapValues(columns, function (n, i) { return n && table.rows.map(function (row) { return row[n.index]; }); });
	                };
	                GlobeMapColumns.getTableRows = function (dataView) {
	                    var table = dataView && dataView.table;
	                    var columns = this.getColumnSourcesT(dataView);
	                    return columns && table && table.rows.map(function (row) {
	                        return _.mapValues(columns, function (n, i) { return n && row[n.index]; });
	                    });
	                };
	                GlobeMapColumns.getCategoricalValues = function (dataView) {
	                    var categorical = dataView && dataView.categorical;
	                    var categories = categorical && categorical.categories || [];
	                    var values = categorical && categorical.values || [];
	                    var series = categorical && values.source && this.getSeriesValues(dataView);
	                    return categorical && _.mapValues(new this(), function (n, i) {
	                        return _.toArray(categories).concat(_.toArray(values))
	                            .filter(function (x) { return x.source.roles && x.source.roles[i]; }).map(function (x) { return x.values; })[0]
	                            || values.source && values.source.roles && values.source.roles[i] && series;
	                    });
	                };
	                GlobeMapColumns.getSeriesValues = function (dataView) {
	                    return dataView && dataView.categorical && dataView.categorical.values
	                        && dataView.categorical.values.map(function (x) { return visuals.converterHelper.getSeriesName(x.source); });
	                };
	                GlobeMapColumns.getCategoricalColumns = function (dataView) {
	                    var categorical = dataView && dataView.categorical;
	                    var categories = categorical && categorical.categories || [];
	                    var values = categorical && categorical.values || [];
	                    return categorical && _.mapValues(new this(), function (n, i) { return categories.filter(function (x) { return x.source.roles && x.source.roles[i]; })[0]
	                        || values.source && values.source.roles && values.source.roles[i] && values
	                        || values.filter(function (x) { return x.source.roles && x.source.roles[i]; }); });
	                };
	                GlobeMapColumns.getGroupedValueColumns = function (dataView) {
	                    var _this = this;
	                    var categorical = dataView && dataView.categorical;
	                    var values = categorical && categorical.values;
	                    var grouped = values && values.grouped();
	                    return grouped && grouped.map(function (g) { return _.mapValues(new _this(), function (n, i) { return g.values.filter(function (v) { return v.source.roles[i]; })[0]; }); });
	                };
	                GlobeMapColumns.getColumnSourcesT = function (dataView) {
	                    var columns = dataView && dataView.metadata && dataView.metadata.columns;
	                    return columns && _.mapValues(new this(), function (n, i) { return columns.filter(function (x) { return x.roles && x.roles[i]; })[0]; });
	                };
	                GlobeMapColumns.Roles = Object.freeze(_.mapValues(new GlobeMapColumns(), function (x, i) { return i; }));
	                return GlobeMapColumns;
	            }());
	            samples.GlobeMapColumns = GlobeMapColumns;
	            var GlobeMap = (function () {
	                function GlobeMap() {
	                    this.locationsToLoad = 0;
	                    this.locationsLoaded = 0;
	                    this.renderLoopEnabled = true;
	                    this.needsRender = false;
	                }
	                Object.defineProperty(GlobeMap.prototype, "settings", {
	                    get: function () {
	                        return this.data && this.data.settings;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                GlobeMap.converter = function (dataView, globeMapLocationCache, colors) {
	                    var categorical = GlobeMapColumns.getCategoricalColumns(dataView);
	                    if (!categorical || !categorical.Category || _.isEmpty(categorical.Category.values)
	                        || (_.isEmpty(categorical.Height) && _.isEmpty(categorical.Heat))) {
	                        return null;
	                    }
	                    var properties = GlobeMapSettings.getProperties(GlobeMap.capabilities);
	                    var settings = GlobeMap.parseSettings(dataView);
	                    var groupedColumns = GlobeMapColumns.getGroupedValueColumns(dataView);
	                    var dataPoints = [];
	                    var seriesDataPoints = [];
	                    var locations = [];
	                    var colorHelper = new visuals.ColorHelper(colors, properties.dataPoint.fill);
	                    var locationType, heights, heightsBySeries, toolTipDataBySeries, heats;
	                    if (categorical.Category && categorical.Category.values) {
	                        locations = categorical.Category.values;
	                        var type = categorical.Category.source.type;
	                        locationType = type.category ? type.category.toLowerCase() : "";
	                    }
	                    else {
	                        locations = [];
	                    }
	                    if (!_.isEmpty(categorical.Height)) {
	                        if (groupedColumns.length > 1) {
	                            heights = new Array(locations.length);
	                            heightsBySeries = new Array(locations.length);
	                            toolTipDataBySeries = new Array(locations.length);
	                            seriesDataPoints = new Array(groupedColumns.length);
	                            //creating a matrix for drawing values by series later.
	                            for (var i = 0; i < groupedColumns.length; i++) {
	                                var values = groupedColumns[i].Height.values;
	                                seriesDataPoints[i] = GlobeMap.createDataPointForEnumeration(dataView, groupedColumns[i].Height.source, i, null, colorHelper, colors);
	                                for (var j = 0; j < values.length; j++) {
	                                    if (!heights[j])
	                                        heights[j] = 0;
	                                    heights[j] += values[j] ? values[j] : 0;
	                                    if (!heightsBySeries[j])
	                                        heightsBySeries[j] = [];
	                                    heightsBySeries[j][i] = values[j];
	                                    if (!toolTipDataBySeries[j])
	                                        toolTipDataBySeries[j] = [];
	                                    toolTipDataBySeries[j][i] = {
	                                        displayName: categorical.Series && categorical.Series.source.displayName,
	                                        value: dataView.categorical.values.grouped()[i].name,
	                                        dataPointValue: values[j]
	                                    };
	                                }
	                            }
	                            for (var i = 0; i < groupedColumns.length; i++) {
	                                var values = groupedColumns[i].Height.values;
	                                for (var j = 0; j < values.length; j++) {
	                                    //calculating relative size of series
	                                    heightsBySeries[j][i] = values[j] / heights[j];
	                                }
	                            }
	                        }
	                        else {
	                            heights = categorical.Height[0].values;
	                            heightsBySeries = new Array(groupedColumns.length);
	                            seriesDataPoints[0] = GlobeMap.createDataPointForEnumeration(dataView, groupedColumns[0].Height.source, 0, dataView.metadata, colorHelper, colors);
	                        }
	                    }
	                    else {
	                        heightsBySeries = new Array(locations.length);
	                        heights = new Array(locations.length);
	                    }
	                    if (!_.isEmpty(categorical.Heat)) {
	                        if (groupedColumns.length > 1) {
	                            heats = new Array(locations.length);
	                            for (var i = 0; i < groupedColumns.length; i++) {
	                                var values = groupedColumns[i].Heat.values;
	                                for (var j = 0; j < values.length; j++) {
	                                    if (!heats[j])
	                                        heats[j] = 0;
	                                    heats[j] += values[j] ? values[j] : 0;
	                                }
	                            }
	                        }
	                        else {
	                            heats = categorical.Heat[0].values;
	                        }
	                    }
	                    else {
	                        heats = new Array(locations.length);
	                    }
	                    var maxHeight = Math.max.apply(null, heights) || 1;
	                    var maxHeat = Math.max.apply(null, heats) || 1;
	                    var heatFormatter = visuals.valueFormatter.create({
	                        format: !_.isEmpty(categorical.Heat) && categorical.Heat[0].source.format,
	                        value: heats[0],
	                        value2: heats[1]
	                    });
	                    var heightFormatter = visuals.valueFormatter.create({
	                        format: !_.isEmpty(categorical.Height) && categorical.Height[0].source.format,
	                        value: heights[0],
	                        value2: heights[1]
	                    });
	                    for (var i = 0, len = locations.length; i < len; ++i) {
	                        if (typeof (locations[i]) === "string") {
	                            var place = locations[i].toLowerCase();
	                            var placeKey = place + "/" + locationType;
	                            var location = (_.isEmpty(categorical.X) || _.isEmpty(categorical.Y))
	                                ? globeMapLocationCache[placeKey]
	                                : { longitude: categorical.X[0].values[i] || 0, latitude: categorical.Y[0].values[i] || 0 };
	                            var height = heights[i] / maxHeight;
	                            var heat = heats[i] / maxHeat;
	                            var renderDatum = {
	                                location: location,
	                                placeKey: placeKey,
	                                place: place,
	                                locationType: locationType,
	                                height: height ? height || 0.01 : undefined,
	                                heightBySeries: heightsBySeries[i],
	                                seriesToolTipData: toolTipDataBySeries ? toolTipDataBySeries[i] : undefined,
	                                heat: heat || 0,
	                                toolTipData: {
	                                    location: { displayName: categorical.Category && categorical.Category.source.displayName, value: locations[i] },
	                                    height: { displayName: !_.isEmpty(categorical.Height) && categorical.Height[0].source.displayName, value: heightFormatter.format(heights[i]) },
	                                    heat: { displayName: !_.isEmpty(categorical.Heat) && categorical.Heat[0].source.displayName, value: heatFormatter.format(heats[i]) }
	                                }
	                            };
	                            dataPoints.push(renderDatum);
	                        }
	                    }
	                    return {
	                        dataView: dataView,
	                        dataPoints: dataPoints,
	                        seriesDataPoints: seriesDataPoints,
	                        settings: settings
	                    };
	                };
	                GlobeMap.parseSettings = function (dataView) {
	                    var settings = GlobeMapSettings.parse(dataView, GlobeMap.capabilities);
	                    settings.createOriginalSettings();
	                    return settings;
	                };
	                GlobeMap.createDataPointForEnumeration = function (dataView, source, seriesIndex, metaData, colorHelper, colors) {
	                    var columns = dataView.categorical.values.grouped()[seriesIndex];
	                    var label = visuals.converterHelper.getFormattedLegendLabel(source, columns.values, null);
	                    var identity = visuals.SelectionId.createWithId(columns.identity);
	                    var category = visuals.converterHelper.getSeriesName(source);
	                    var objects = columns.objects;
	                    var color = objects && objects.dataPoint ? objects.dataPoint.fill.solid.color : metaData && metaData.objects
	                        ? colorHelper.getColorForMeasure(metaData.objects, "")
	                        : colors.getColorByIndex(seriesIndex).value;
	                    return {
	                        label: label,
	                        identity: identity,
	                        category: category,
	                        color: color,
	                        selected: null
	                    };
	                };
	                GlobeMap.prototype.enumerateObjectInstances = function (options) {
	                    var instances = GlobeMapSettings.enumerateObjectInstances(this.settings && this.settings.originalSettings, options, GlobeMap.capabilities);
	                    switch (options.objectName) {
	                        case 'dataPoint':
	                            if (this.data && this.data.seriesDataPoints) {
	                                for (var i = 0; i < this.data.seriesDataPoints.length; i++) {
	                                    var dataPoint = this.data.seriesDataPoints[i];
	                                    instances.pushInstance({
	                                        objectName: 'dataPoint',
	                                        displayName: dataPoint.label,
	                                        selector: visuals.ColorHelper.normalizeSelector(dataPoint.identity.getSelector()),
	                                        properties: {
	                                            fill: { solid: { color: dataPoint.color } }
	                                        }
	                                    });
	                                }
	                            }
	                            break;
	                    }
	                    return instances.complete();
	                };
	                GlobeMap.prototype.init = function (options) {
	                    this.container = options.element;
	                    this.layout = new VisualLayout(options.viewport);
	                    this.readyToRender = false;
	                    if (!this.globeMapLocationCache) {
	                        this.globeMapLocationCache = {};
	                    }
	                    this.style = options.style;
	                    this.colors = this.style.colorPalette.dataColors;
	                    if (!THREE) {
	                        loadGlobeMapLibs();
	                    }
	                    if (THREE) {
	                        this.setup();
	                    }
	                };
	                GlobeMap.prototype.setup = function () {
	                    this.initTextures();
	                    this.initMercartorSphere();
	                    this.initZoomControl();
	                    this.initScene();
	                    this.initHeatmap();
	                    this.readyToRender = true;
	                    this.initRayCaster();
	                };
	                GlobeMap.prototype.initScene = function () {
	                    var _this = this;
	                    var clock = new THREE.Clock();
	                    var renderer = this.renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
	                    this.container.append(renderer.domElement);
	                    this.domElement = renderer.domElement;
	                    this.camera = new THREE.PerspectiveCamera(35, this.layout.viewportIn.width / this.layout.viewportIn.height, 0.1, 10000);
	                    var orbitControls = this.orbitControls = new THREE.OrbitControls(this.camera, this.domElement);
	                    this.scene = new THREE.Scene();
	                    renderer.setSize(this.layout.viewportIn.width, this.layout.viewportIn.height);
	                    renderer.setClearColor(0xbac4d2, 1);
	                    this.camera.position.z = GlobeMap.GlobeSettings.cameraRadius;
	                    orbitControls.maxDistance = GlobeMap.GlobeSettings.cameraRadius;
	                    orbitControls.minDistance = GlobeMap.GlobeSettings.earthRadius + 1;
	                    orbitControls.rotateSpeed = GlobeMap.GlobeSettings.rotateSpeed;
	                    orbitControls.zoomSpeed = GlobeMap.GlobeSettings.zoomSpeed;
	                    orbitControls.autoRotate = GlobeMap.GlobeSettings.autoRotate;
	                    var ambientLight = new THREE.AmbientLight(0x000000);
	                    var light1 = new THREE.DirectionalLight(0xffffff, 0.4);
	                    var light2 = new THREE.DirectionalLight(0xffffff, 0.4);
	                    var earth = this.earth = this.createEarth();
	                    this.scene.add(ambientLight);
	                    this.scene.add(light1);
	                    this.scene.add(light2);
	                    this.scene.add(earth);
	                    light1.position.set(20, 20, 20);
	                    light2.position.set(0, 0, -20);
	                    var _zis = this;
	                    var render = function () {
	                        try {
	                            if (_zis.renderLoopEnabled)
	                                requestAnimationFrame(render);
	                            if (!_zis.shouldRender())
	                                return;
	                            orbitControls.update(clock.getDelta());
	                            _zis.setEarthTexture();
	                            _zis.intersectBars();
	                            if (_zis.heatmap && _zis.heatmap.display) {
	                                _zis.heatmap.display(); // Needed for IE/Edge to behave nicely
	                            }
	                            renderer.render(_this.scene, _this.camera);
	                            _zis.needsRender = false;
	                        }
	                        catch (e) {
	                            console.error(e);
	                        }
	                    };
	                    requestAnimationFrame(render);
	                };
	                GlobeMap.prototype.shouldRender = function () {
	                    return this.readyToRender && this.needsRender;
	                };
	                GlobeMap.prototype.createEarth = function () {
	                    var geometry = new GlobeMap.MercartorSphere(GlobeMap.GlobeSettings.earthRadius, GlobeMap.GlobeSettings.earthSegments, GlobeMap.GlobeSettings.earthSegments);
	                    var material = new THREE.MeshPhongMaterial({
	                        map: this.mapTextures[0],
	                        side: THREE.DoubleSide,
	                        shininess: 1,
	                        emissive: 0xaaaaaa,
	                    });
	                    return new THREE.Mesh(geometry, material);
	                };
	                GlobeMap.prototype.zoomClicked = function (zoomDirection) {
	                    if (this.orbitControls.enabled === false || this.orbitControls.enableZoom === false)
	                        return;
	                    if (zoomDirection === -1)
	                        this.orbitControls.constraint.dollyOut(Math.pow(0.95, GlobeMap.GlobeSettings.zoomSpeed));
	                    else if (zoomDirection === 1)
	                        this.orbitControls.constraint.dollyIn(Math.pow(0.95, GlobeMap.GlobeSettings.zoomSpeed));
	                    this.orbitControls.update();
	                    this.animateCamera(this.camera.position);
	                };
	                GlobeMap.prototype.rotateCam = function (deltaX, deltaY) {
	                    if (this.orbitControls.enabled === false || this.orbitControls.enableRotate === false)
	                        return;
	                    this.orbitControls.constraint.rotateLeft(2 * Math.PI * deltaX / this.domElement.offsetHeight * GlobeMap.GlobeSettings.rotateSpeed);
	                    this.orbitControls.constraint.rotateUp(2 * Math.PI * deltaY / this.domElement.offsetHeight * GlobeMap.GlobeSettings.rotateSpeed);
	                    this.orbitControls.update();
	                    this.animateCamera(this.camera.position);
	                };
	                GlobeMap.prototype.initTextures = function () {
	                    var _this = this;
	                    if (!GlobeMapCanvasLayers) {
	                        // Initialize once, since this is a CPU + Network heavy operation.
	                        GlobeMapCanvasLayers = [];
	                        for (var level = 2; level <= 5; ++level) {
	                            var canvas = this.getBingMapCanvas(level);
	                            GlobeMapCanvasLayers.push(canvas);
	                        }
	                    }
	                    // Can't execute in for loop because variable assignement gets overwritten
	                    var createTexture = function (canvas) {
	                        var texture = new THREE.Texture(canvas.get(0));
	                        texture.needsUpdate = true;
	                        canvas.on("ready", function (e, resolution) {
	                            //console.log("level ready", resolution, texture)
	                            texture.needsUpdate = true;
	                            _this.needsRender = true;
	                        });
	                        return texture;
	                    };
	                    this.mapTextures = [];
	                    for (var i = 0; i < GlobeMapCanvasLayers.length; ++i) {
	                        this.mapTextures.push(createTexture(GlobeMapCanvasLayers[i]));
	                    }
	                };
	                GlobeMap.prototype.initHeatmap = function () {
	                    //console.log("initHeatmap");
	                    try {
	                        var heatmap = this.heatmap = new WebGLHeatmap({ width: GlobeMap.GlobeSettings.heatmapSize, height: GlobeMap.GlobeSettings.heatmapSize, intensityToAlpha: true });
	                    }
	                    catch (e) {
	                        // IE & Edge will throw an error about texImage2D, we need to ignore it
	                        console.error(e);
	                    }
	                    // canvas contents will be used for a texture
	                    var texture = this.heatTexture = new THREE.Texture(heatmap.canvas);
	                    texture.needsUpdate = true;
	                    var material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
	                    var geometry = new THREE.SphereGeometry(GlobeMap.GlobeSettings.earthRadius + 0.01, GlobeMap.GlobeSettings.earthSegments, GlobeMap.GlobeSettings.earthSegments);
	                    var mesh = new THREE.Mesh(geometry, material);
	                    window["heatmap"] = heatmap;
	                    window["heatmapTexture"] = texture;
	                    this.scene.add(mesh);
	                };
	                GlobeMap.prototype.setEarthTexture = function () {
	                    //get distance as arbitrary value from 0-1
	                    if (!this.camera)
	                        return;
	                    var maxDistance = GlobeMap.GlobeSettings.cameraRadius - GlobeMap.GlobeSettings.earthRadius;
	                    var distance = (this.camera.position.length() - GlobeMap.GlobeSettings.earthRadius) / maxDistance;
	                    var texture;
	                    if (distance <= 1 / 5) {
	                        texture = this.mapTextures[3];
	                    }
	                    else if (distance <= 2 / 5) {
	                        texture = this.mapTextures[2];
	                    }
	                    else if (distance <= 3 / 5) {
	                        texture = this.mapTextures[1];
	                    }
	                    else {
	                        texture = this.mapTextures[0];
	                    }
	                    if (this.earth.material.map !== texture) {
	                        this.earth.material.map = texture;
	                    }
	                    if (this.selectedBar) {
	                        this.orbitControls.rotateSpeed = GlobeMap.GlobeSettings.rotateSpeed;
	                    }
	                    else {
	                        this.orbitControls.rotateSpeed = GlobeMap.GlobeSettings.rotateSpeed * distance;
	                    }
	                    //console.log(distance, this.orbitControls.rotateSpeed);
	                };
	                GlobeMap.prototype.update = function (options) {
	                    this.needsRender = true;
	                    this.layout.viewport = options.viewport;
	                    if (this.layout.viewportChanged) {
	                        if (this.camera && this.renderer) {
	                            this.camera.aspect = this.layout.viewportIn.width / this.layout.viewportIn.height;
	                            this.camera.updateProjectionMatrix();
	                            this.renderer.setSize(this.layout.viewportIn.width, this.layout.viewportIn.height);
	                        }
	                    }
	                    if (options.type === powerbi.VisualUpdateType.Data) {
	                        this.cleanHeatAndBar();
	                        var data = GlobeMap.converter(options.dataViews[0], this.globeMapLocationCache, this.colors);
	                        if (data) {
	                            this.data = data;
	                            this.renderMagic();
	                        }
	                    }
	                };
	                GlobeMap.prototype.cleanHeatAndBar = function () {
	                    this.heatmap.clear();
	                    this.heatTexture.needsUpdate = true;
	                    if (this.barsGroup) {
	                        this.scene.remove(this.barsGroup);
	                    }
	                };
	                GlobeMap.prototype.renderMagic = function () {
	                    var _this = this;
	                    if (!this.data) {
	                        return;
	                    }
	                    this.data.dataPoints.forEach(function (d) { return _this.geocodeRenderDatum(d); });
	                    if (!this.readyToRender) {
	                        //console.log("not ready to render");
	                        this.defferedRender();
	                        return;
	                    }
	                    this.heatmap.clear();
	                    if (this.barsGroup) {
	                        this.scene.remove(this.barsGroup);
	                    }
	                    this.barsGroup = new THREE.Object3D();
	                    this.scene.add(this.barsGroup);
	                    this.averageBarVector = new THREE.Vector3();
	                    for (var i = 0, len = this.data.dataPoints.length; i < len; ++i) {
	                        var renderDatum = this.data.dataPoints[i];
	                        if (!renderDatum.location || renderDatum.location.longitude === undefined || renderDatum.location.latitude === undefined) {
	                            continue;
	                        }
	                        if (renderDatum.heat > 0.001) {
	                            if (renderDatum.heat < 0.1)
	                                renderDatum.heat = 0.1;
	                            var x = (180 + renderDatum.location.longitude) / 360 * GlobeMap.GlobeSettings.heatmapSize;
	                            var y = (1 - ((90 + renderDatum.location.latitude) / 180)) * GlobeMap.GlobeSettings.heatmapSize;
	                            this.heatmap.addPoint(x, y, GlobeMap.GlobeSettings.heatPointSize, renderDatum.heat * GlobeMap.GlobeSettings.heatIntensity);
	                        }
	                        if (renderDatum.height >= 0) {
	                            if (renderDatum.height < 0.01)
	                                renderDatum.height = 0.01;
	                            var latRadians = renderDatum.location.latitude / 180 * Math.PI; //radians
	                            var lngRadians = renderDatum.location.longitude / 180 * Math.PI;
	                            var x = Math.cos(lngRadians) * Math.cos(latRadians);
	                            var z = -Math.sin(lngRadians) * Math.cos(latRadians);
	                            var y = Math.sin(latRadians);
	                            var v = new THREE.Vector3(x, y, z);
	                            this.averageBarVector.add(v);
	                            var barHeight = GlobeMap.GlobeSettings.barHeight * renderDatum.height;
	                            //this array holds the relative series values to the actual measure for example [0.2,0.3,0.5]
	                            //this is how we draw the vectors relativly to the complete value one on top of another. 
	                            var measuresBySeries = [];
	                            //this array holds the original values of the series for the tool tips
	                            var dataPointToolTip = [];
	                            if (renderDatum.heightBySeries) {
	                                for (var c = 0; c < renderDatum.heightBySeries.length; c++) {
	                                    if (renderDatum.heightBySeries[c]) {
	                                        measuresBySeries.push(renderDatum.heightBySeries[c]);
	                                    }
	                                    dataPointToolTip.push(renderDatum.seriesToolTipData[c]);
	                                }
	                            }
	                            else {
	                                //no category series so we'll just draw one value
	                                measuresBySeries.push(1);
	                            }
	                            var previousMeasureValue = 0;
	                            for (var j = 0; j < measuresBySeries.length; j++) {
	                                previousMeasureValue += measuresBySeries[j];
	                                var geometry = new THREE.CubeGeometry(GlobeMap.GlobeSettings.barWidth, GlobeMap.GlobeSettings.barWidth, barHeight * measuresBySeries[j]);
	                                var bar = new THREE.Mesh(geometry, this.getBarMaterialByIndex(j));
	                                bar.position = v.clone().multiplyScalar(GlobeMap.GlobeSettings.earthRadius + ((barHeight / 2) * previousMeasureValue));
	                                bar.lookAt(v);
	                                bar.toolTipData = dataPointToolTip.length === 0 ? renderDatum.toolTipData : this.getToolTipDataForSeries(renderDatum.toolTipData, dataPointToolTip[j]);
	                                this.barsGroup.add(bar);
	                                previousMeasureValue += measuresBySeries[j];
	                            }
	                        }
	                    }
	                    if (this.barsGroup.children.length > 0 && this.camera) {
	                        this.averageBarVector.multiplyScalar(1 / this.barsGroup.children.length);
	                        if (this.locationsLoaded === this.locationsToLoad) {
	                            this.animateCamera(this.averageBarVector);
	                        }
	                    }
	                    this.heatmap.update();
	                    this.heatmap.blur();
	                    this.heatTexture.needsUpdate = true;
	                    this.needsRender = true;
	                    //console.log("renderMagic done! locations:", this.barsGroup.children.length, "toload/loaded", this.locationsToLoad, this.locationsLoaded)
	                };
	                GlobeMap.prototype.getBarMaterialByIndex = function (index) {
	                    return new THREE.MeshPhongMaterial({ color: this.data.seriesDataPoints[index].color });
	                };
	                GlobeMap.prototype.getToolTipDataForSeries = function (toolTipData, dataPointToolTip) {
	                    var result = jQuery.extend(true, {
	                        series: { displayName: dataPointToolTip.displayName, value: dataPointToolTip.value }
	                    }, toolTipData);
	                    result.height.value = dataPointToolTip.dataPointValue;
	                    return result;
	                };
	                GlobeMap.prototype.geocodeRenderDatum = function (renderDatum) {
	                    var _this = this;
	                    if (renderDatum.location) {
	                        return;
	                    }
	                    this.globeMapLocationCache[renderDatum.placeKey] = {}; //store empty object so we don't send AJAX request again
	                    this.locationsToLoad++;
	                    try {
	                        var geocoder = powerbi.visuals["BI"].Services.GeocodingManager.geocode;
	                    }
	                    catch (e) {
	                        geocoder = visuals.services.geocode;
	                    }
	                    if (geocoder) {
	                        geocoder(renderDatum.place, renderDatum.locationType).always(function (location) {
	                            // we use always because we want to cache unknown values. 
	                            // No point asking bing again and again when it tells us it doesn't know about a location
	                            _this.globeMapLocationCache[renderDatum.placeKey] = location;
	                            _this.locationsLoaded++;
	                            //console.log(place, latlng);
	                            renderDatum.location = location;
	                            _this.defferedRender();
	                        });
	                    }
	                };
	                GlobeMap.prototype.defferedRender = function () {
	                    var _this = this;
	                    if (!this.deferredRenderTimerId) {
	                        this.deferredRenderTimerId = setTimeout(function () {
	                            _this.deferredRenderTimerId = null;
	                            _this.renderMagic();
	                        }, 500);
	                    }
	                };
	                GlobeMap.prototype.initRayCaster = function () {
	                    var _this = this;
	                    this.rayCaster = new THREE.Raycaster();
	                    var mousePosNormalized = this.mousePosNormalized = new THREE.Vector2();
	                    var mousePos = this.mousePos = new THREE.Vector2();
	                    var element = this.container.get(0);
	                    var mouseDownTime;
	                    $(this.domElement).on("mousemove", function (event) {
	                        // get coordinates in -1 to +1 space
	                        var rect = element.getBoundingClientRect();
	                        mousePos.x = event.clientX;
	                        mousePos.y = event.clientY;
	                        mousePosNormalized.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
	                        mousePosNormalized.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
	                        _this.needsRender = true;
	                    }).on("mousedown", function (event) {
	                        mouseDownTime = Date.now();
	                    }).on("mouseup", function (event) {
	                        // Debounce slow clicks
	                        if ((Date.now() - mouseDownTime) > GlobeMap.GlobeSettings.clickInterval)
	                            return;
	                        if (_this.hoveredBar && event.shiftKey) {
	                            _this.selectedBar = _this.hoveredBar;
	                            _this.animateCamera(_this.selectedBar.position, function () {
	                                if (!_this.selectedBar)
	                                    return;
	                                _this.orbitControls.center.copy(_this.selectedBar.position.clone().normalize().multiplyScalar(GlobeMap.GlobeSettings.earthRadius));
	                                _this.orbitControls.minDistance = 1;
	                            });
	                        }
	                        else {
	                            if (_this.selectedBar) {
	                                _this.animateCamera(_this.selectedBar.position, function () {
	                                    _this.orbitControls.center.set(0, 0, 0);
	                                    _this.orbitControls.minDistance = GlobeMap.GlobeSettings.earthRadius + 1;
	                                });
	                                _this.selectedBar = null;
	                            }
	                        }
	                    }).on("mousewheel DOMMouseScroll", function (e) {
	                        _this.needsRender = true;
	                        if (_this.orbitControls.enabled && _this.orbitControls.enableZoom) {
	                            _this.heatTexture.needsUpdate = true;
	                            e = e.originalEvent;
	                            var delta = e.wheelDelta > 0 || e.detail < 0 ? 1 : -1;
	                            var scale = delta > 0 ? GlobeMap.GlobeSettings.heatmapScaleOnZoom : (1 / GlobeMap.GlobeSettings.heatmapScaleOnZoom);
	                            _this.heatmap.multiply(scale);
	                            _this.heatmap.update();
	                        }
	                    });
	                };
	                GlobeMap.prototype.intersectBars = function () {
	                    if (!this.rayCaster || !this.barsGroup)
	                        return;
	                    var rayCaster = this.rayCaster;
	                    rayCaster.setFromCamera(this.mousePosNormalized, this.camera);
	                    var intersects = rayCaster.intersectObjects(this.barsGroup.children);
	                    if (intersects && intersects.length > 0) {
	                        //console.log(intersects[0], this.mousePos.x, this.mousePos.y);
	                        var object = intersects[0].object;
	                        if (!object || !object.toolTipData)
	                            return;
	                        var toolTipData = object.toolTipData;
	                        var toolTipItems = [];
	                        if (toolTipData.location.displayName)
	                            toolTipItems.push(toolTipData.location);
	                        if (toolTipData.series)
	                            toolTipItems.push(toolTipData.series);
	                        if (toolTipData.height.displayName)
	                            toolTipItems.push(toolTipData.height);
	                        if (toolTipData.heat.displayName)
	                            toolTipItems.push(toolTipData.heat);
	                        this.hoveredBar = object;
	                        visuals.TooltipManager.ToolTipInstance.show(toolTipItems, { x: this.mousePos.x, y: this.mousePos.y, width: 0, height: 0 });
	                    }
	                    else {
	                        this.hoveredBar = null;
	                        visuals.TooltipManager.ToolTipInstance.hide();
	                    }
	                };
	                GlobeMap.prototype.animateCamera = function (to, done) {
	                    var _this = this;
	                    if (!this.camera)
	                        return;
	                    var startTime = Date.now();
	                    var duration = GlobeMap.GlobeSettings.cameraAnimDuration;
	                    var endTime = startTime + duration;
	                    var startPos = this.camera.position.clone().normalize();
	                    var endPos = to.clone().normalize();
	                    var length = this.camera.position.length();
	                    var easeInOut = function (t) {
	                        t *= 2;
	                        if (t < 1)
	                            return (t * t * t) / 2;
	                        t -= 2;
	                        return (t * t * t + 2) / 2;
	                    };
	                    var onUpdate = function () {
	                        var now = Date.now();
	                        var t = (now - startTime) / duration;
	                        if (t > 1)
	                            t = 1;
	                        t = easeInOut(t);
	                        var pos = new THREE.Vector3()
	                            .add(startPos.clone().multiplyScalar(1 - t))
	                            .add(endPos.clone().multiplyScalar(t))
	                            .normalize()
	                            .multiplyScalar(length);
	                        _this.camera.position = pos;
	                        if (now < endTime) {
	                            requestAnimationFrame(onUpdate);
	                        }
	                        else if (done) {
	                            done();
	                        }
	                        _this.needsRender = true;
	                    };
	                    requestAnimationFrame(onUpdate);
	                };
	                GlobeMap.prototype.destroy = function () {
	                    clearTimeout(this.deferredRenderTimerId);
	                    this.renderLoopEnabled = false;
	                    this.scene = null;
	                    this.heatmap = null;
	                    this.heatTexture = null;
	                    this.camera = null;
	                    if (this.renderer) {
	                        if (this.renderer.context) {
	                            var extension = this.renderer.context.getExtension('WEBGL_lose_context');
	                            if (extension)
	                                extension.loseContext();
	                            this.renderer.context = null;
	                        }
	                        this.renderer.domElement = null;
	                    }
	                    this.renderer = null;
	                    this.data = null;
	                    this.barsGroup = null;
	                    if (this.orbitControls)
	                        this.orbitControls.dispose();
	                    this.orbitControls = null;
	                    if (this.domElement)
	                        $(this.domElement)
	                            .off("mousemove mouseup mousedown mousewheel DOMMouseScroll");
	                    this.domElement = null;
	                    if (this.container)
	                        this.container.empty();
	                };
	                GlobeMap.prototype.initZoomControl = function () {
	                    var _this = this;
	                    var radius = 17;
	                    var zoomControlWidth = radius * 8.5;
	                    var zoomControlHeight = radius * 8.5;
	                    var startX = radius * 3;
	                    var startY = radius + 3;
	                    var gap = radius * 2;
	                    var zoomCss = {
	                        'position': 'absolute',
	                        'left': 'calc(100% - ' + zoomControlWidth + 'px)',
	                        'top': 'calc(100% - ' + zoomControlHeight + 'px)',
	                        'zIndex': '1000',
	                    };
	                    var zoomContainer = d3.select(this.container[0])
	                        .append('div')
	                        .style(zoomCss);
	                    this.zoomControl = zoomContainer.append("svg").attr({ "width": zoomControlWidth, "height": zoomControlHeight });
	                    var bottom = this.zoomControl.append("g").on("click", function () { return _this.rotateCam(0, -5); });
	                    bottom.append("circle").attr({ cx: startX + gap, cy: startY + (2 * gap), r: radius, fill: "white", opacity: 0.5, stroke: 'gray' });
	                    bottom.append("path").attr({ d: "M" + (startX + (2 * radius)) + " " + (startY + (radius * 4.7)) + " l12 -20 a40,70 0 0,1 -24,0z", fill: "gray" });
	                    var left = this.zoomControl.append("g").on("click", function () { return _this.rotateCam(5, 0); });
	                    left.append("circle").attr({ cx: startX, cy: startY + gap, r: radius, fill: "white", stroke: "gray", opacity: 0.5 });
	                    left.append("path").attr({ d: "M" + (startX - radius / 1.5) + " " + (startY + (radius * 2)) + " l20 -12 a70,40 0 0,0 0,24z", fill: "gray" });
	                    var top = this.zoomControl.append("g").on("click", function () { return _this.rotateCam(0, 5); });
	                    top.append("circle").attr({ cx: startX + gap, cy: startY, r: radius, fill: "white", stroke: "gray", opacity: 0.5 });
	                    top.append("path").attr({ d: "M" + (startX + (2 * radius)) + " " + (startY - (radius / 1.5)) + " l12 20 a40,70 0 0,0 -24,0z", fill: "gray" });
	                    var right = this.zoomControl.append("g").on("click", function () { return _this.rotateCam(-5, 0); });
	                    right.append("circle").attr({ cx: startX + (2 * gap), cy: startY + gap, r: radius, fill: "white", stroke: "gray", opacity: 0.5 });
	                    right.append("path").attr({ d: "M" + (startX + (4.7 * radius)) + " " + (startY + (radius * 2)) + " l-20 -12 a70,40 0 0,1 0,24z", fill: "gray" });
	                    var zoomIn = this.zoomControl.append("g").on("click", function () { return _this.zoomClicked(-1); });
	                    zoomIn.append("circle").attr({ cx: startX + 4 * radius, cy: startY + 6 * radius, r: radius, fill: "white", stroke: "gray", opacity: 0.5 });
	                    zoomIn.append("rect").attr({ x: startX + 3.5 * radius, y: startY + 5.9 * radius, width: radius, height: radius / 3, fill: "gray" });
	                    zoomIn.append("rect").attr({ x: startX + (4 * radius) - radius / 6, y: startY + 5.55 * radius, width: radius / 3, height: radius, fill: "gray" });
	                    var zoomOut = this.zoomControl.append("g").on("click", function () { return _this.zoomClicked(1); });
	                    zoomOut.append("circle").attr({ cx: startX, cy: startY + 6 * radius, r: radius, fill: "white", stroke: "gray", opacity: "0.50" });
	                    zoomOut.append("rect").attr({ x: startX - (radius / 2), y: startY + 5.9 * radius, width: radius, height: radius / 3, fill: "gray" });
	                };
	                GlobeMap.prototype.initMercartorSphere = function () {
	                    if (GlobeMap.MercartorSphere)
	                        return;
	                    var MercartorSphere = function (radius, widthSegments, heightSegments) {
	                        THREE.Geometry.call(this);
	                        this.radius = radius;
	                        this.widthSegments = widthSegments;
	                        this.heightSegments = heightSegments;
	                        this.t = 0;
	                        var x, y, vertices = [], uvs = [];
	                        function interplolate(a, b, t) {
	                            return (1 - t) * a + t * b;
	                        }
	                        // interpolates between sphere and plane
	                        function interpolateVertex(u, v, t) {
	                            var maxLng = Math.PI * 2;
	                            var maxLat = Math.PI;
	                            var radius = this.radius;
	                            var sphereX = -radius * Math.cos(u * maxLng) * Math.sin(v * maxLat);
	                            var sphereY = -radius * Math.cos(v * maxLat);
	                            var sphereZ = radius * Math.sin(u * maxLng) * Math.sin(v * maxLat);
	                            var planeX = u * radius * 2 - radius;
	                            var planeY = v * radius * 2 - radius;
	                            var planeZ = 0;
	                            var x = interplolate(sphereX, planeX, t);
	                            var y = interplolate(sphereY, planeY, t);
	                            var z = interplolate(sphereZ, planeZ, t);
	                            return new THREE.Vector3(x, y, z);
	                        }
	                        // http://mathworld.wolfram.com/MercatorProjection.html
	                        // Mercator projection goes form +85.05 to -85.05 degrees
	                        function interpolateUV(u, v, t) {
	                            var lat = (v - 0.5) * 90 * 2 / 180 * Math.PI; //turn from 0-1 into lat in radians
	                            var sin = Math.sin(lat);
	                            var normalizedV = 0.5 + 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;
	                            return new THREE.Vector2(u, normalizedV); //interplolate(normalizedV1, v, t))
	                        }
	                        for (y = 0; y <= heightSegments; y++) {
	                            var verticesRow = [];
	                            var uvsRow = [];
	                            for (x = 0; x <= widthSegments; x++) {
	                                var u = x / widthSegments;
	                                var v = y / heightSegments;
	                                this.vertices.push(interpolateVertex.call(this, u, v, this.t));
	                                uvsRow.push(interpolateUV.call(this, u, v, this.t));
	                                verticesRow.push(this.vertices.length - 1);
	                            }
	                            vertices.push(verticesRow);
	                            uvs.push(uvsRow);
	                        }
	                        //console.log(vertices, uvs);
	                        for (y = 0; y < this.heightSegments; y++) {
	                            for (x = 0; x < this.widthSegments; x++) {
	                                var v1 = vertices[y][x + 1];
	                                var v2 = vertices[y][x];
	                                var v3 = vertices[y + 1][x];
	                                var v4 = vertices[y + 1][x + 1];
	                                var n1 = this.vertices[v1].clone().normalize();
	                                var n2 = this.vertices[v2].clone().normalize();
	                                var n3 = this.vertices[v3].clone().normalize();
	                                var n4 = this.vertices[v4].clone().normalize();
	                                var uv1 = uvs[y][x + 1].clone();
	                                var uv2 = uvs[y][x].clone();
	                                var uv3 = uvs[y + 1][x].clone();
	                                var uv4 = uvs[y + 1][x + 1].clone();
	                                var normals = [n1, n2, n3, n4];
	                                this.faces.push(new THREE.Face4(v1, v2, v3, v4, normals));
	                                this.faceVertexUvs[0].push([uv1, uv2, uv3, uv4]);
	                            }
	                        }
	                        this.computeCentroids();
	                        this.computeFaceNormals();
	                        this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
	                    };
	                    MercartorSphere.prototype = Object.create(THREE.Geometry.prototype);
	                    GlobeMap.MercartorSphere = MercartorSphere;
	                };
	                GlobeMap.prototype.getBingMapCanvas = function (resolution) {
	                    var tileSize = 256;
	                    var numSegments = Math.pow(2, resolution);
	                    var numTiles = numSegments * numSegments;
	                    var tilesLoaded = 0;
	                    var canvasSize = tileSize * numSegments;
	                    var canvas = $('<canvas/>').attr({ width: canvasSize, height: canvasSize });
	                    var canvasElem = canvas.get(0);
	                    var canvasContext = canvasElem.getContext("2d");
	                    function generateQuads(res, quad) {
	                        if (res <= resolution) {
	                            if (res === resolution) {
	                                loadTile(quad);
	                            }
	                            generateQuads(res + 1, quad + "0");
	                            generateQuads(res + 1, quad + "1");
	                            generateQuads(res + 1, quad + "2");
	                            generateQuads(res + 1, quad + "3");
	                        }
	                    }
	                    function loadTile(quad) {
	                        var template = "https://t{server}.tiles.virtualearth.net/tiles/r{quad}.jpeg?g=0&mkt={language}";
	                        var numServers = 7;
	                        var server = Math.round(Math.random() * numServers);
	                        var language = (navigator["languages"] && navigator["languages"].length) ? navigator["languages"][0] : navigator.language;
	                        var url = template.replace("{server}", server)
	                            .replace("{quad}", quad)
	                            .replace("{language}", language);
	                        var coords = getCoords(quad);
	                        //console.log(quad, coords.x, coords.y)
	                        var tile = new Image();
	                        tile.onload = function () {
	                            tilesLoaded++;
	                            canvasContext.drawImage(tile, coords.x * tileSize, coords.y * tileSize, tileSize, tileSize);
	                            if (tilesLoaded === numTiles) {
	                                canvas.trigger("ready", resolution);
	                            }
	                        };
	                        // So the canvas doesn't get tainted
	                        tile.crossOrigin = '';
	                        tile.src = url;
	                    }
	                    function getCoords(quad) {
	                        var x = 0;
	                        var y = 0;
	                        var last = quad.length - 1;
	                        for (var i = last; i >= 0; i--) {
	                            var chr = quad.charAt(i);
	                            var pow = Math.pow(2, last - i);
	                            if (chr === "1") {
	                                x += pow;
	                            }
	                            else if (chr === "2") {
	                                y += pow;
	                            }
	                            else if (chr === "3") {
	                                x += pow;
	                                y += pow;
	                            }
	                        }
	                        return { x: x, y: y };
	                    }
	                    generateQuads(0, "");
	                    return canvas;
	                };
	                GlobeMap.GlobeSettings = {
	                    autoRotate: false,
	                    earthRadius: 30,
	                    cameraRadius: 100,
	                    earthSegments: 100,
	                    heatmapSize: 1000,
	                    heatPointSize: 7,
	                    heatIntensity: 10,
	                    heatmapScaleOnZoom: 0.95,
	                    barWidth: 0.3,
	                    barHeight: 5,
	                    rotateSpeed: 0.5,
	                    zoomSpeed: 0.8,
	                    cameraAnimDuration: 1000,
	                    clickInterval: 200 //ms
	                };
	                GlobeMap.capabilities = {
	                    dataRoles: [
	                        {
	                            name: 'Category',
	                            kind: powerbi.VisualDataRoleKind.Grouping,
	                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Location'),
	                            preferredTypes: [
	                                { geography: { address: true } },
	                                { geography: { city: true } },
	                                { geography: { continent: true } },
	                                { geography: { country: true } },
	                                { geography: { county: true } },
	                                { geography: { place: true } },
	                                { geography: { postalCode: true } },
	                                { geography: { region: true } },
	                                { geography: { stateOrProvince: true } },
	                            ],
	                        },
	                        {
	                            name: 'Series',
	                            kind: powerbi.VisualDataRoleKind.Grouping,
	                            displayName: "Legend",
	                        },
	                        {
	                            name: 'X',
	                            kind: powerbi.VisualDataRoleKind.Measure,
	                            displayName: 'Longitude',
	                            description: 'Use to override the longitude of locations',
	                            preferredTypes: [{ geography: { longitude: true } }],
	                        },
	                        {
	                            name: 'Y',
	                            kind: powerbi.VisualDataRoleKind.Measure,
	                            displayName: 'Latitude',
	                            description: 'Use to override the latitude of locations',
	                            preferredTypes: [{ geography: { latitude: true } }],
	                        },
	                        {
	                            name: 'Height',
	                            kind: powerbi.VisualDataRoleKind.Measure,
	                            displayName: 'Bar Height',
	                        },
	                        {
	                            name: 'Heat',
	                            kind: powerbi.VisualDataRoleKind.Measure,
	                            displayName: 'Heat Intensity',
	                        }
	                    ],
	                    objects: {
	                        general: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
	                            properties: {
	                                formatString: {
	                                    type: { formatting: { formatString: true } },
	                                },
	                            },
	                        },
	                        dataPoint: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
	                            properties: {
	                                defaultColor: {
	                                    displayName: powerbi.data.createDisplayNameGetter('Visual_DefaultColor'),
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                showAllDataPoints: {
	                                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint_Show_All'),
	                                    type: { bool: true }
	                                },
	                                fill: {
	                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                fillRule: {
	                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Gradient'),
	                                    type: { fillRule: {} },
	                                    rule: {
	                                        inputRole: 'Gradient',
	                                        output: {
	                                            property: 'fill',
	                                            selector: ['Category'],
	                                        },
	                                    },
	                                }
	                            }
	                        },
	                    },
	                    dataViewMappings: [{
	                            conditions: [
	                                { 'Category': { max: 1 }, 'Series': { max: 1 }, 'Height': { max: 1 }, 'Heat': { max: 1 } },
	                            ],
	                            categorical: {
	                                categories: {
	                                    for: { in: 'Category' },
	                                    dataReductionAlgorithm: { top: {} }
	                                },
	                                values: {
	                                    group: {
	                                        by: 'Series',
	                                        select: [
	                                            { bind: { to: 'Height' } },
	                                            { bind: { to: 'Heat' } },
	                                            { bind: { to: 'X' } },
	                                            { bind: { to: 'Y' } },
	                                        ],
	                                        dataReductionAlgorithm: { top: {} }
	                                    }
	                                },
	                                rowCount: { preferred: { min: 2 } }
	                            },
	                        }],
	                    sorting: {
	                        custom: {},
	                    }
	                };
	                return GlobeMap;
	            }());
	            samples.GlobeMap = GlobeMap;
	        })(samples = visuals.samples || (visuals.samples = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));
	function loadGlobeMapLibs() {
	    // include GlobeMapLibs.js
	}

	

/***/ },
/* 48 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../../../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var samples;
	        (function (samples) {
	            var CreateClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
	            var PixelConverter = jsCommon.PixelConverter;
	            /**
	             * RadarChartBehavior
	             */
	            var RadarChartWebBehavior = (function () {
	                function RadarChartWebBehavior() {
	                }
	                RadarChartWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
	                    var selection = this.selection = options.selection;
	                    var clearCatcher = options.clearCatcher;
	                    selection.on('click', function (d) {
	                        selectionHandler.handleSelection(d, d3.event.ctrlKey);
	                        d3.event.stopPropagation();
	                    });
	                    clearCatcher.on('click', function () {
	                        selectionHandler.handleClearSelection();
	                    });
	                };
	                RadarChartWebBehavior.prototype.renderSelection = function (hasSelection) {
	                    this.selection.style("opacity", function (d) { return (hasSelection && !d.selected) ? RadarChart.DimmedAreaFillOpacity : RadarChart.NodeFillOpacity; });
	                };
	                return RadarChartWebBehavior;
	            }());
	            samples.RadarChartWebBehavior = RadarChartWebBehavior;
	            var RadarChart = (function () {
	                function RadarChart(options) {
	                    if (options) {
	                        if (options.svg)
	                            this.svg = options.svg;
	                        if (options.animator)
	                            this.animator = options.animator;
	                        if (options.margin)
	                            this.margin = options.margin;
	                    }
	                }
	                RadarChart.converter = function (dataView, colors) {
	                    if (!dataView ||
	                        !dataView.categorical ||
	                        !dataView.categorical.categories ||
	                        !(dataView.categorical.categories.length > 0) ||
	                        !dataView.categorical.categories[0] ||
	                        !dataView.categorical.values ||
	                        !(dataView.categorical.values.length > 0) ||
	                        !colors) {
	                        return {
	                            legendData: {
	                                dataPoints: []
	                            },
	                            settings: {
	                                showLegend: true
	                            },
	                            series: [],
	                            dataLabelsSettings: visuals.dataLabelUtils.getDefaultPointLabelSettings(),
	                        };
	                    }
	                    var catDv = dataView.categorical, values = catDv.values, grouped = catDv && catDv.values ? catDv.values.grouped() : null, series = [], colorHelper = new visuals.ColorHelper(colors, RadarChart.Properties.dataPoint.fill);
	                    var legendData = {
	                        fontSize: 8.25,
	                        dataPoints: [],
	                        title: ""
	                    };
	                    //Parse legend settings          
	                    var legendSettings = RadarChart.parseSettings(dataView);
	                    var dataLabelsSettings = RadarChart.parseLabelSettings(dataView);
	                    for (var i = 0, iLen = values.length; i < iLen; i++) {
	                        var color = colors.getColorByIndex(i).value, serieIdentity, queryName, displayName, dataPoints = [];
	                        var columnGroup = grouped
	                            && grouped.length > i && grouped[i].values ? grouped[i] : null;
	                        if (values[i].source) {
	                            var source = values[i].source;
	                            if (source.queryName) {
	                                queryName = source.queryName;
	                                serieIdentity = visuals.SelectionId.createWithMeasure(queryName);
	                            }
	                            if (source.displayName)
	                                displayName = source.displayName;
	                            if (source.objects) {
	                                var objects = source.objects;
	                                color = colorHelper.getColorForMeasure(objects, queryName);
	                            }
	                        }
	                        legendData.dataPoints.push({
	                            label: displayName,
	                            color: color,
	                            icon: visuals.LegendIcon.Box,
	                            selected: false,
	                            identity: serieIdentity
	                        });
	                        for (var k = 0, kLen = values[i].values.length; k < kLen; k++) {
	                            var dataPointIdentity = visuals.SelectionIdBuilder
	                                .builder()
	                                .withMeasure(queryName)
	                                .withCategory(catDv.categories[0], k)
	                                .withSeries(dataView.categorical.values, columnGroup)
	                                .createSelectionId();
	                            var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(RadarChart.formatStringProp, catDv, catDv.categories[0].values[k], values[i].values[k], null, null, i);
	                            var labelFormatString = visuals.valueFormatter.getFormatString(catDv.values[i].source, RadarChart.formatStringProp);
	                            var fontSizeInPx = jsCommon.PixelConverter.fromPoint(dataLabelsSettings.fontSize);
	                            dataPoints.push({
	                                x: k,
	                                y: values[i].values[k],
	                                color: color,
	                                identity: dataPointIdentity,
	                                selected: false,
	                                tooltipInfo: tooltipInfo,
	                                value: values[i].values[k],
	                                labelFormatString: labelFormatString,
	                                labelFontSize: fontSizeInPx,
	                            });
	                        }
	                        if (dataPoints.length > 0)
	                            series.push({
	                                fill: color,
	                                name: displayName,
	                                data: dataPoints,
	                                identity: serieIdentity,
	                            });
	                    }
	                    return {
	                        legendData: legendData,
	                        settings: legendSettings,
	                        series: series,
	                        dataLabelsSettings: dataLabelsSettings,
	                    };
	                };
	                RadarChart.prototype.init = function (options) {
	                    var element = options.element;
	                    if (!this.svg) {
	                        this.svg = d3.select(element.get(0)).append('svg');
	                        this.svg.style('position', 'absolute');
	                    }
	                    if (!this.margin)
	                        this.margin = RadarChart.DefaultMargin;
	                    this.svg.classed(RadarChart.VisualClassName, true);
	                    this.interactivityService = visuals.createInteractivityService(options.host);
	                    this.isInteractiveChart = options.interactivity && options.interactivity.isInteractiveLegend;
	                    this.legend = visuals.createLegend(element, this.isInteractiveChart, this.interactivityService, true, visuals.LegendPosition.Top);
	                    this.colors = options.style.colorPalette.dataColors;
	                    this.mainGroupElement = this.svg.append('g');
	                    this.segments = this.mainGroupElement
	                        .append('g')
	                        .classed(RadarChart.Segments.class, true);
	                    this.zeroSegment = this.mainGroupElement
	                        .append('g')
	                        .classed(RadarChart.ZeroSegment.class, true);
	                    this.axis = this.mainGroupElement
	                        .append('g')
	                        .classed(RadarChart.Axis.class, true);
	                    this.chart = this.mainGroupElement
	                        .append('g')
	                        .classed(RadarChart.Chart.class, true);
	                };
	                RadarChart.prototype.update = function (options) {
	                    if (!options.dataViews || !options.dataViews[0])
	                        return;
	                    var dataView = options.dataViews[0];
	                    this.radarChartData = RadarChart.converter(dataView, this.colors);
	                    var categories = [], series = this.radarChartData.series, dataViewMetadataColumn, duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, options.suppressAnimations);
	                    if (dataView.categorical &&
	                        dataView.categorical.categories &&
	                        dataView.categorical.categories[0] &&
	                        dataView.categorical.categories[0].values)
	                        categories = dataView.categorical.categories[0].values;
	                    if (dataView.metadata && dataView.metadata.columns && dataView.metadata.columns.length > 0)
	                        dataViewMetadataColumn = dataView.metadata.columns[0];
	                    this.viewport = {
	                        height: options.viewport.height > 0 ? options.viewport.height : 0,
	                        width: options.viewport.width > 0 ? options.viewport.width : 0
	                    };
	                    this.parseLegendProperties(dataView);
	                    this.renderLegend(this.radarChartData);
	                    this.updateViewport();
	                    this.svg
	                        .attr({
	                        'height': this.viewport.height,
	                        'width': this.viewport.width
	                    });
	                    var mainGroup = this.mainGroupElement;
	                    mainGroup.attr('transform', visuals.SVGUtil.translate(this.viewport.width / 2, this.viewport.height / 2));
	                    var width = this.viewport.width - this.margin.left - this.margin.right;
	                    var height = this.viewport.height - this.margin.top - this.margin.bottom;
	                    this.angle = RadarChart.Radians / categories.length;
	                    this.radius = RadarChart.SegmentFactor * RadarChart.Scale * Math.min(width, height) / 2;
	                    this.drawCircularSegments(categories);
	                    this.drawAxes(categories);
	                    this.drawAxesLabels(categories, dataViewMetadataColumn);
	                    this.drawChart(series, duration);
	                    this.drawDataLabels(series);
	                    this.drawZeroCircularSegment(categories);
	                    if (this.zeroPointRadius !== 0)
	                        this.drawZeroLabel();
	                    else
	                        this.mainGroupElement.selectAll(RadarChart.ZeroLabel.selector).remove();
	                };
	                RadarChart.prototype.getRadarChartLabelLayout = function (labelSettings, allDataPoints) {
	                    var formattersCache = visuals.dataLabelUtils.createColumnFormatterCacheManager();
	                    var angle = this.angle;
	                    var viewport = this.viewport;
	                    var halfHeight = this.viewport.height / 2;
	                    var halfWidth = this.viewport.width / 2;
	                    var y = this.calculateChartDomain(this.radarChartData.series);
	                    return {
	                        labelText: function (d) {
	                            var formmater = formattersCache.getOrCreate(d.labelFormatString, labelSettings);
	                            if (labelSettings.displayUnits === 0) {
	                                var maxDataPoint = _.max(allDataPoints, function (d) { return d.value; });
	                                var maxValue = maxDataPoint.value > 0 ? maxDataPoint.value : 0;
	                                formmater = formattersCache.getOrCreate(d.labelFormatString, labelSettings, maxValue);
	                            }
	                            return visuals.dataLabelUtils.getLabelFormattedText({ label: formmater.format(d.value), maxWidth: viewport.width, fontSize: labelSettings.fontSize });
	                        },
	                        labelLayout: {
	                            x: function (d) { return -1 * y(d.y) * Math.sin(d.x * angle) + halfWidth; },
	                            y: function (d) { return -1 * y(d.y) * Math.cos(d.x * angle) + halfHeight - 7; },
	                        },
	                        filter: function (d) {
	                            return (d != null && d.value != null);
	                        },
	                        style: {
	                            'fill': labelSettings.labelColor,
	                            'font-size': function (d) { return PixelConverter.fromPoint(labelSettings.fontSize); },
	                        },
	                    };
	                };
	                RadarChart.prototype.drawCircularSegments = function (values) {
	                    var data = [];
	                    var angle = this.angle, factor = RadarChart.SegmentFactor, levels = RadarChart.SegmentLevels, radius = this.radius;
	                    for (var level = 0; level < levels - 1; level++) {
	                        var levelFactor = radius * ((level + 1) / levels);
	                        var transform = -1 * levelFactor;
	                        for (var i = 0; i < values.length; i++)
	                            data.push({
	                                x1: levelFactor * (1 - factor * Math.sin(i * angle)),
	                                y1: levelFactor * (1 - factor * Math.cos(i * angle)),
	                                x2: levelFactor * (1 - factor * Math.sin((i + 1) * angle)),
	                                y2: levelFactor * (1 - factor * Math.cos((i + 1) * angle)),
	                                translate: visuals.SVGUtil.translate(transform, transform)
	                            });
	                    }
	                    var selection = this.mainGroupElement
	                        .select(RadarChart.Segments.selector)
	                        .selectAll(RadarChart.SegmentNode.selector)
	                        .data(data);
	                    selection
	                        .enter()
	                        .append('svg:line')
	                        .classed(RadarChart.SegmentNode.class, true);
	                    selection
	                        .attr({
	                        'x1': function (item) { return item.x1; },
	                        'y1': function (item) { return item.y1; },
	                        'x2': function (item) { return item.x2; },
	                        'y2': function (item) { return item.y2; },
	                        'transform': function (item) { return item.translate; }
	                    });
	                    selection.exit().remove();
	                };
	                RadarChart.prototype.drawDataLabels = function (series) {
	                    var allDataPoints = this.getAllDataPointsList(series);
	                    if (this.radarChartData.dataLabelsSettings.show) {
	                        var layout = this.getRadarChartLabelLayout(this.radarChartData.dataLabelsSettings, allDataPoints);
	                        var viewport = this.viewport;
	                        var labels = visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(allDataPoints, this.mainGroupElement, layout, viewport);
	                        labels.attr('transform', visuals.SVGUtil.translate(-(viewport.width / 2), -(viewport.height / 2)));
	                    }
	                    else
	                        visuals.dataLabelUtils.cleanDataLabels(this.mainGroupElement);
	                };
	                RadarChart.prototype.drawAxes = function (values) {
	                    var angle = this.angle, radius = -1 * this.radius;
	                    var selection = this.mainGroupElement
	                        .select(RadarChart.Axis.selector)
	                        .selectAll(RadarChart.AxisNode.selector);
	                    var axis = selection.data(values);
	                    axis
	                        .enter()
	                        .append('svg:line');
	                    axis
	                        .attr({
	                        'x1': 0,
	                        'y1': 0,
	                        'x2': function (name, i) { return radius * Math.sin(i * angle); },
	                        'y2': function (name, i) { return radius * Math.cos(i * angle); }
	                    })
	                        .classed(RadarChart.AxisNode.class, true);
	                    axis.exit().remove();
	                };
	                RadarChart.prototype.drawAxesLabels = function (values, dataViewMetadataColumn) {
	                    var _this = this;
	                    var angle = this.angle, radius = -1 * this.radius, length = values.length;
	                    var formatter = visuals.valueFormatter.create({
	                        format: visuals.valueFormatter.getFormatString(dataViewMetadataColumn, RadarChart.formatStringProp, true),
	                        value: values[0],
	                        value2: values[length - 1],
	                    });
	                    var selection = this.mainGroupElement
	                        .select(RadarChart.Axis.selector)
	                        .selectAll(RadarChart.AxisLabel.selector);
	                    var labels = selection.data(values);
	                    labels
	                        .enter()
	                        .append('svg:text');
	                    labels
	                        .attr({
	                        'text-anchor': 'middle',
	                        'dy': '1.5em',
	                        'transform': visuals.SVGUtil.translate(0, -10),
	                        'x': function (name, i) { return (radius - 30) * Math.sin(i * angle); },
	                        'y': function (name, i) { return (radius - 20) * Math.cos(i * angle); }
	                    })
	                        .text(function (item) {
	                        var properties = {
	                            fontFamily: RadarChart.AxesLabelsFontFamily,
	                            fontSize: RadarChart.AxesLabelsfontSize,
	                            text: formatter.format(item)
	                        };
	                        return powerbi.TextMeasurementService.getTailoredTextOrDefault(properties, Math.min(RadarChart.AxesLabelsMaxWidth, _this.viewport.width));
	                    })
	                        .classed(RadarChart.AxisLabel.class, true);
	                    labels.exit().remove();
	                };
	                RadarChart.prototype.drawChart = function (series, duration) {
	                    var angle = this.angle, dotRadius = 5, dataPoints = this.getDataPoints(series);
	                    var stack = d3.layout.stack();
	                    var layers = stack(dataPoints);
	                    var y = this.calculateChartDomain(series);
	                    var calculatePoints = function (points) {
	                        return points.map(function (value) {
	                            var x1 = -1 * y(value.y) * Math.sin(value.x * angle);
	                            var y1 = -1 * y(value.y) * Math.cos(value.x * angle);
	                            return x1 + "," + y1;
	                        }).join(' ');
	                    };
	                    var areas = this.chart.selectAll(RadarChart.ChartArea.selector).data(layers);
	                    areas
	                        .enter()
	                        .append('g')
	                        .classed(RadarChart.ChartArea.class, true);
	                    var polygon = areas.selectAll(RadarChart.ChartPolygon.selector).data(function (d) {
	                        if (d && d.length > 0) {
	                            return [d];
	                        }
	                        return [];
	                    });
	                    polygon
	                        .enter()
	                        .append('polygon')
	                        .classed(RadarChart.ChartPolygon.class, true);
	                    polygon
	                        .style('fill', function (d) { return d[0].color; })
	                        .style('opacity', RadarChart.DimmedAreaFillOpacity)
	                        .on('mouseover', function (d) {
	                        d3.select(this).transition()
	                            .duration(duration)
	                            .style('opacity', RadarChart.AreaFillOpacity);
	                    })
	                        .on('mouseout', function (d) {
	                        d3.select(this).transition()
	                            .duration(duration)
	                            .style('opacity', RadarChart.DimmedAreaFillOpacity);
	                    })
	                        .attr('points', calculatePoints);
	                    polygon.exit().remove();
	                    areas.exit().remove();
	                    var selection = this.chart.selectAll(RadarChart.ChartNode.selector).data(layers);
	                    selection
	                        .enter()
	                        .append('g')
	                        .classed(RadarChart.ChartNode.class, true);
	                    var dots = selection.selectAll(RadarChart.ChartDot.selector)
	                        .data(function (d) { return d.filter(function (d) { return d.y != null; }); });
	                    dots.enter()
	                        .append('svg:circle')
	                        .classed(RadarChart.ChartDot.class, true);
	                    dots.attr('r', dotRadius)
	                        .attr({
	                        'cx': function (value) { return -1 * y(value.y) * Math.sin(value.x * angle); },
	                        'cy': function (value) { return -1 * y(value.y) * Math.cos(value.x * angle); }
	                    })
	                        .style('fill', function (d) { return d.color; });
	                    dots.exit().remove();
	                    visuals.TooltipManager.addTooltip(dots, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; }, true);
	                    selection.exit().remove();
	                    var behaviorOptions = undefined;
	                    if (this.interactivityService) {
	                        // Register interactivity
	                        var dataPointsToBind = this.getAllDataPointsList(series);
	                        behaviorOptions = { selection: dots, clearCatcher: this.svg };
	                        this.interactivityService.bind(dataPointsToBind, new RadarChartWebBehavior(), behaviorOptions);
	                    }
	                };
	                RadarChart.prototype.calculateChartDomain = function (series) {
	                    var radius = this.radius, dataPointsList = this.getAllDataPointsList(series);
	                    var minValue = d3.min(dataPointsList, function (d) { return d.y; });
	                    var maxValue = d3.max(dataPointsList, function (d) { return d.y; });
	                    if (this.isPercentChart(dataPointsList)) {
	                        minValue = minValue >= 0 ? 0 : -1;
	                        maxValue = maxValue <= 0 ? 0 : 1;
	                    }
	                    var y = d3.scale.linear()
	                        .domain([minValue, maxValue]).range([0, radius]);
	                    // Calculate zero ring radius
	                    this.zeroPointRadius = ((minValue < 0) && (maxValue > 0)) ? y(0) : 0;
	                    return y;
	                };
	                RadarChart.prototype.renderLegend = function (radarChartData) {
	                    if (!radarChartData.legendData)
	                        return;
	                    var legendData = radarChartData.legendData;
	                    if (this.legendObjectProperties) {
	                        visuals.LegendData.update(legendData, this.legendObjectProperties);
	                        var position = this.legendObjectProperties[visuals.legendProps.position];
	                        if (position)
	                            this.legend.changeOrientation(visuals.LegendPosition[position]);
	                    }
	                    else
	                        this.legend.changeOrientation(visuals.LegendPosition.Top);
	                    var viewport = this.viewport;
	                    this.legend.drawLegend(legendData, { height: viewport.height, width: viewport.width });
	                    visuals.Legend.positionChartArea(this.svg, this.legend);
	                };
	                RadarChart.prototype.drawZeroCircularSegment = function (values) {
	                    var data = [];
	                    var angle = this.angle, factor = RadarChart.SegmentFactor, radius = this.zeroPointRadius, transform = -1 * radius;
	                    for (var i = 0; i < values.length; i++)
	                        data.push({
	                            x1: radius * (1 - factor * Math.sin(i * angle)),
	                            y1: radius * (1 - factor * Math.cos(i * angle)),
	                            x2: radius * (1 - factor * Math.sin((i + 1) * angle)),
	                            y2: radius * (1 - factor * Math.cos((i + 1) * angle)),
	                            translate: visuals.SVGUtil.translate(transform, transform)
	                        });
	                    var selection = this.mainGroupElement
	                        .select(RadarChart.ZeroSegment.selector)
	                        .selectAll(RadarChart.ZeroSegmentNode.selector)
	                        .data(data);
	                    selection
	                        .enter()
	                        .append('svg:line')
	                        .classed(RadarChart.ZeroSegmentNode.class, true);
	                    selection
	                        .attr({
	                        'x1': function (item) { return item.x1; },
	                        'y1': function (item) { return item.y1; },
	                        'x2': function (item) { return item.x2; },
	                        'y2': function (item) { return item.y2; },
	                        'transform': function (item) { return item.translate; }
	                    });
	                    selection.exit().remove();
	                };
	                RadarChart.prototype.drawZeroLabel = function () {
	                    var data = [];
	                    data.push({
	                        'x': this.zeroPointRadius * (1 - RadarChart.SegmentFactor) + 5,
	                        'y': -1 * this.zeroPointRadius
	                    });
	                    var zeroLabel = this.mainGroupElement
	                        .select(RadarChart.ZeroSegment.selector)
	                        .selectAll(RadarChart.ZeroLabel.selector).data(data);
	                    zeroLabel
	                        .enter()
	                        .append('text')
	                        .classed(RadarChart.ZeroLabel.class, true).text("0");
	                    zeroLabel
	                        .attr({
	                        'x': function (item) { return item.x; },
	                        'y': function (item) { return item.y; }
	                    });
	                };
	                RadarChart.prototype.getDataPoints = function (series) {
	                    var dataPoints = [];
	                    for (var i = 0; i < series.length; i++) {
	                        dataPoints.push(series[i].data);
	                    }
	                    return dataPoints;
	                };
	                RadarChart.prototype.getAllDataPointsList = function (series) {
	                    var dataPoints = [];
	                    for (var i = 0; i < series.length; i++) {
	                        dataPoints = dataPoints.concat(series[i].data);
	                    }
	                    return dataPoints;
	                };
	                RadarChart.prototype.isPercentChart = function (dataPointsList) {
	                    for (var i = 0; i < dataPointsList.length; i++) {
	                        if (dataPointsList[i].labelFormatString.indexOf("%") === -1) {
	                            return false;
	                        }
	                    }
	                    return true;
	                };
	                RadarChart.prototype.parseLegendProperties = function (dataView) {
	                    if (!dataView || !dataView.metadata) {
	                        this.legendObjectProperties = {};
	                        return;
	                    }
	                    this.legendObjectProperties = powerbi.DataViewObjects.getObject(dataView.metadata.objects, "legend", {});
	                };
	                RadarChart.parseSettings = function (dataView) {
	                    var objects;
	                    if (!dataView || !dataView.metadata || !dataView.metadata.columns || !dataView.metadata.objects)
	                        objects = null;
	                    else
	                        objects = dataView.metadata.objects;
	                    return {
	                        showLegend: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.legend.show, true)
	                    };
	                };
	                RadarChart.getPrecision = function (value) {
	                    return Math.max(RadarChart.MinPrecision, Math.min(RadarChart.MaxPrecision, value));
	                };
	                RadarChart.parseLabelSettings = function (dataView) {
	                    var objects;
	                    if (!dataView || !dataView.metadata || !dataView.metadata.objects)
	                        objects = null;
	                    else
	                        objects = dataView.metadata.objects;
	                    var dataLabelsSettings = visuals.dataLabelUtils.getDefaultPointLabelSettings();
	                    var labelsObj = {
	                        show: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.labels.show, dataLabelsSettings.show),
	                        labelColor: powerbi.DataViewObjects.getFillColor(objects, RadarChart.Properties.labels.color, dataLabelsSettings.labelColor),
	                        displayUnits: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.labels.displayUnits, dataLabelsSettings.displayUnits),
	                        precision: RadarChart.getPrecision(powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.labels.precision, dataLabelsSettings.precision)),
	                        fontSize: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.labels.fontSize, dataLabelsSettings.fontSize),
	                        position: dataLabelsSettings.position
	                    };
	                    return labelsObj;
	                };
	                // This function returns the values to be displayed in the property pane for each object.
	                // Usually it is a bind pass of what the property pane gave you, but sometimes you may want to do
	                // validation and return other values/defaults
	                RadarChart.prototype.enumerateObjectInstances = function (options) {
	                    var enumeration = new visuals.ObjectEnumerationBuilder();
	                    var settings;
	                    if (!this.radarChartData || !this.radarChartData.settings)
	                        return [];
	                    settings = this.radarChartData.settings;
	                    switch (options.objectName) {
	                        case "legend":
	                            enumeration.pushInstance(this.enumerateLegend(settings));
	                            break;
	                        case "dataPoint":
	                            this.enumerateDataPoint(enumeration);
	                            break;
	                        case 'labels':
	                            this.enumerateDataLabels(enumeration);
	                            break;
	                    }
	                    return enumeration.complete();
	                };
	                RadarChart.prototype.getLabelSettingsOptions = function (enumeration, labelSettings) {
	                    return {
	                        enumeration: enumeration,
	                        dataLabelsSettings: labelSettings,
	                        show: true,
	                        displayUnits: true,
	                        precision: true,
	                        fontSize: true,
	                    };
	                };
	                RadarChart.prototype.enumerateDataLabels = function (enumeration) {
	                    var labelSettings = this.radarChartData.dataLabelsSettings;
	                    //Draw default settings
	                    visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings));
	                };
	                RadarChart.prototype.enumerateLegend = function (settings) {
	                    var showTitle = true, titleText = "", legend, labelColor, fontSize = 8;
	                    showTitle = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.showTitle, showTitle);
	                    titleText = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.titleText, titleText);
	                    labelColor = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.labelColor, labelColor);
	                    fontSize = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.fontSize, fontSize);
	                    legend = {
	                        objectName: "legend",
	                        displayName: "legend",
	                        selector: null,
	                        properties: {
	                            show: settings.showLegend,
	                            position: visuals.LegendPosition[this.legend.getOrientation()],
	                            showTitle: showTitle,
	                            titleText: titleText,
	                            labelColor: labelColor,
	                            fontSize: fontSize,
	                        }
	                    };
	                    return legend;
	                };
	                RadarChart.prototype.enumerateDataPoint = function (enumeration) {
	                    if (!this.radarChartData || !this.radarChartData.series)
	                        return;
	                    var series = this.radarChartData.series;
	                    for (var i = 0; i < series.length; i++) {
	                        var serie = series[i];
	                        enumeration.pushInstance({
	                            objectName: "dataPoint",
	                            displayName: serie.name,
	                            selector: visuals.ColorHelper.normalizeSelector(serie.identity.getSelector(), false),
	                            properties: {
	                                fill: { solid: { color: serie.fill } }
	                            }
	                        });
	                    }
	                };
	                RadarChart.prototype.updateViewport = function () {
	                    var legendMargins = this.legend.getMargins(), legendPosition;
	                    legendPosition = visuals.LegendPosition[this.legendObjectProperties[visuals.legendProps.position]];
	                    switch (legendPosition) {
	                        case visuals.LegendPosition.Top:
	                        case visuals.LegendPosition.TopCenter:
	                        case visuals.LegendPosition.Bottom:
	                        case visuals.LegendPosition.BottomCenter:
	                            this.viewport.height -= legendMargins.height;
	                            break;
	                        case visuals.LegendPosition.Left:
	                        case visuals.LegendPosition.LeftCenter:
	                        case visuals.LegendPosition.Right:
	                        case visuals.LegendPosition.RightCenter:
	                            this.viewport.width -= legendMargins.width;
	                            break;
	                    }
	                };
	                RadarChart.capabilities = {
	                    dataRoles: [
	                        {
	                            displayName: 'Category',
	                            name: 'Category',
	                            kind: powerbi.VisualDataRoleKind.Grouping,
	                        },
	                        {
	                            displayName: 'Y Axis',
	                            name: 'Y',
	                            kind: powerbi.VisualDataRoleKind.Measure,
	                        },
	                    ],
	                    dataViewMappings: [{
	                            conditions: [{ 'Category': { min: 1, max: 1 } }],
	                            categorical: {
	                                categories: {
	                                    for: { in: 'Category' },
	                                    dataReductionAlgorithm: { top: {} }
	                                },
	                                values: {
	                                    select: [{ bind: { to: 'Y' } }]
	                                }
	                            }
	                        }],
	                    objects: {
	                        general: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
	                            properties: {
	                                formatString: {
	                                    type: { formatting: { formatString: true } },
	                                },
	                            },
	                        },
	                        legend: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_LegendDescription'),
	                            properties: {
	                                show: {
	                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
	                                    type: { bool: true }
	                                },
	                                position: {
	                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendPosition'),
	                                    description: powerbi.data.createDisplayNameGetter('Visual_LegendPositionDescription'),
	                                    type: { enumeration: visuals.legendPosition.type }
	                                },
	                                showTitle: {
	                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitle'),
	                                    description: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitleDescription'),
	                                    type: { bool: true }
	                                },
	                                titleText: {
	                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendName'),
	                                    description: powerbi.data.createDisplayNameGetter('Visual_LegendNameDescription'),
	                                    type: { text: true },
	                                    suppressFormatPainterCopy: true
	                                },
	                                labelColor: {
	                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendTitleColor'),
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                fontSize: {
	                                    displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
	                                    type: { formatting: { fontSize: true } }
	                                }
	                            }
	                        },
	                        dataPoint: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
	                            properties: {
	                                fill: {
	                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
	                                    type: { fill: { solid: { color: true } } }
	                                }
	                            }
	                        },
	                        labels: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
	                            description: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabelsDescription'),
	                            properties: {
	                                show: {
	                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
	                                    type: { bool: true }
	                                },
	                                color: {
	                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
	                                    description: powerbi.data.createDisplayNameGetter('Visual_LabelsFillDescription'),
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                labelDisplayUnits: {
	                                    displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
	                                    description: powerbi.data.createDisplayNameGetter('Visual_DisplayUnitsDescription'),
	                                    type: { formatting: { labelDisplayUnits: true } },
	                                    suppressFormatPainterCopy: true,
	                                },
	                                labelPrecision: {
	                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
	                                    description: powerbi.data.createDisplayNameGetter('Visual_PrecisionDescription'),
	                                    placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
	                                    type: { numeric: true },
	                                    suppressFormatPainterCopy: true,
	                                },
	                                fontSize: {
	                                    displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
	                                    type: { formatting: { fontSize: true } }
	                                },
	                            }
	                        }
	                    }
	                };
	                /** Note: Public for testability */
	                RadarChart.formatStringProp = {
	                    objectName: 'general',
	                    propertyName: 'formatString',
	                };
	                RadarChart.Properties = {
	                    legend: {
	                        show: { objectName: 'legend', propertyName: 'show' }
	                    },
	                    dataPoint: {
	                        fill: { objectName: 'dataPoint', propertyName: 'fill' }
	                    },
	                    labels: {
	                        show: { objectName: 'labels', propertyName: 'show' },
	                        color: { objectName: 'labels', propertyName: 'color' },
	                        displayUnits: { objectName: 'labels', propertyName: 'labelDisplayUnits' },
	                        precision: { objectName: 'labels', propertyName: 'labelPrecision' },
	                        fontSize: { objectName: 'labels', propertyName: 'fontSize' },
	                    }
	                };
	                RadarChart.VisualClassName = 'radarChart';
	                RadarChart.Segments = CreateClassAndSelector('segments');
	                RadarChart.SegmentNode = CreateClassAndSelector('segmentNode');
	                RadarChart.ZeroSegment = CreateClassAndSelector('zeroSegment');
	                RadarChart.ZeroSegmentNode = CreateClassAndSelector('zeroSegmentNode');
	                RadarChart.ZeroLabel = CreateClassAndSelector('zeroLabel');
	                RadarChart.Axis = CreateClassAndSelector('axis');
	                RadarChart.AxisNode = CreateClassAndSelector('axisNode');
	                RadarChart.AxisLabel = CreateClassAndSelector('axisLabel');
	                RadarChart.Chart = CreateClassAndSelector('chart');
	                RadarChart.ChartNode = CreateClassAndSelector('chartNode');
	                RadarChart.ChartArea = CreateClassAndSelector('chartArea');
	                RadarChart.ChartPolygon = CreateClassAndSelector('chartPolygon');
	                RadarChart.ChartDot = CreateClassAndSelector('chartDot');
	                RadarChart.MaxPrecision = 17;
	                RadarChart.MinPrecision = 0;
	                RadarChart.DefaultMargin = {
	                    top: 50,
	                    bottom: 50,
	                    right: 100,
	                    left: 100
	                };
	                RadarChart.SegmentLevels = 6;
	                RadarChart.SegmentFactor = 1;
	                RadarChart.Radians = 2 * Math.PI;
	                RadarChart.Scale = 1;
	                RadarChart.NodeFillOpacity = 1;
	                RadarChart.AreaFillOpacity = 0.6;
	                RadarChart.DimmedAreaFillOpacity = 0.4;
	                RadarChart.AxesLabelsFontFamily = "sans-serif";
	                RadarChart.AxesLabelsfontSize = "11px";
	                RadarChart.AxesLabelsMaxWidth = 200;
	                return RadarChart;
	            }());
	            samples.RadarChart = RadarChart;
	        })(samples = visuals.samples || (visuals.samples = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 49 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../../../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var samples;
	        (function (samples) {
	            var PixelConverter = jsCommon.PixelConverter;
	            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
	            var SelectionManager = powerbi.visuals.utility.SelectionManager;
	            var ValueFormatter = powerbi.visuals.valueFormatter;
	            var getAnimationDuration = powerbi.visuals.AnimatorCommon.GetAnimationDuration;
	            var SelectionId = powerbi.visuals.SelectionId;
	            var axisStyle = powerbi.visuals.axisStyle;
	            var yAxisPosition = powerbi.visuals.yAxisPosition;
	            var VisualDataRoleKind = powerbi.VisualDataRoleKind;
	            var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
	            var ValueType = powerbi.ValueType;
	            var DataColorPalette = powerbi.visuals.DataColorPalette;
	            var DataViewObjects = powerbi.DataViewObjects;
	            var ColorHelper = powerbi.visuals.ColorHelper;
	            var SVGUtil = powerbi.visuals.SVGUtil;
	            var TooltipManager = powerbi.visuals.TooltipManager;
	            var dataLabelUtils = powerbi.visuals.dataLabelUtils;
	            var DateTimeSequence = powerbi.DateTimeSequence;
	            var applyCustomizedDomain = powerbi.visuals.AxisHelper.applyCustomizedDomain;
	            var combineDomain = powerbi.visuals.AxisHelper.combineDomain;
	            var willLabelsFit = powerbi.visuals.AxisHelper.LabelLayoutStrategy.willLabelsFit;
	            var willLabelsWordBreak = powerbi.visuals.AxisHelper.LabelLayoutStrategy.willLabelsWordBreak;
	            var axisScale = powerbi.visuals.axisScale;
	            var TextMeasurementService = powerbi.TextMeasurementService;
	            var valueFormatter = powerbi.visuals.valueFormatter;
	            var HistogramChartWarning = (function () {
	                function HistogramChartWarning(message) {
	                    this.message = message;
	                }
	                Object.defineProperty(HistogramChartWarning.prototype, "code", {
	                    get: function () {
	                        return "BulletChartWarning";
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                HistogramChartWarning.prototype.getMessages = function (resourceProvider) {
	                    return {
	                        message: this.message,
	                        title: resourceProvider.get(""),
	                        detail: resourceProvider.get("")
	                    };
	                };
	                HistogramChartWarning.ErrorInvalidDataValues = "Some data values are invalid or too big";
	                return HistogramChartWarning;
	            }());
	            samples.HistogramChartWarning = HistogramChartWarning;
	            var Histogram = (function () {
	                function Histogram(histogramConstructorOptions) {
	                    this.ColumnPadding = 1;
	                    this.MinColumnHeight = 1;
	                    this.MinOpacity = 0.3;
	                    this.MaxOpacity = 1;
	                    this.TooltipDisplayName = "Range";
	                    this.SeparatorNumbers = ", ";
	                    this.LegendSize = 50;
	                    this.YLegendSize = 50;
	                    this.XLegendSize = 50;
	                    this.AxisSize = 30;
	                    this.DataLabelMargin = 0;
	                    this.widthOfColumn = 0;
	                    this.yTitleMargin = 0;
	                    this.outerPadding = 5;
	                    this.ExcludeBrackets = {
	                        left: "(",
	                        right: ")"
	                    };
	                    this.IncludeBrackets = {
	                        left: "[",
	                        right: "]"
	                    };
	                    this.margin = {
	                        top: 10,
	                        right: 10,
	                        bottom: 10,
	                        left: 10
	                    };
	                    this.durationAnimations = 200;
	                    this.textProperties = {
	                        fontFamily: 'wf_segoe-ui_normal',
	                        fontSize: PixelConverter.toString(9),
	                    };
	                    if (histogramConstructorOptions) {
	                        if (histogramConstructorOptions.svg) {
	                            this.svg = histogramConstructorOptions.svg;
	                        }
	                        if (histogramConstructorOptions.animator) {
	                            this.animator = histogramConstructorOptions.animator;
	                        }
	                        this.margin = histogramConstructorOptions.margin || this.margin;
	                    }
	                }
	                Object.defineProperty(Histogram.prototype, "columnsSelection", {
	                    get: function () {
	                        return this.main.select(Histogram.Columns.selector)
	                            .selectAll(Histogram.Column.selector);
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Histogram.prototype.init = function (visualsOptions) {
	                    this.hostService = visualsOptions.host;
	                    if (this.svg) {
	                        this.root = this.svg;
	                    }
	                    else {
	                        this.root = d3.select(visualsOptions.element.get(0))
	                            .append("svg");
	                    }
	                    var style = visualsOptions.style;
	                    this.colors = style && style.colorPalette
	                        ? style.colorPalette.dataColors
	                        : new DataColorPalette();
	                    this.root.classed(Histogram.ClassName, true);
	                    this.main = this.root.append("g");
	                    this.axes = this.main
	                        .append("g")
	                        .classed(Histogram.Axes.class, true);
	                    this.axisX = this.axes
	                        .append("g")
	                        .classed(Histogram.Axis.class, true);
	                    this.axisY = this.axes
	                        .append("g")
	                        .classed(Histogram.Axis.class, true);
	                    this.legend = this.main
	                        .append("g")
	                        .classed(Histogram.Legends.class, true);
	                    this.columns = this.main
	                        .append("g")
	                        .classed(Histogram.Columns.class, true);
	                    this.labels = this.main
	                        .append("g")
	                        .classed(Histogram.Labels.class, true);
	                    this.selectionManager = new SelectionManager({ hostServices: visualsOptions.host });
	                };
	                Histogram.prototype.converter = function (dataView) {
	                    if (!dataView ||
	                        !dataView.categorical ||
	                        !dataView.categorical.categories ||
	                        !dataView.categorical.categories[0] ||
	                        !dataView.categorical.categories[0].values ||
	                        !(dataView.categorical.categories[0].values.length > 0)) {
	                        return null;
	                    }
	                    var settings, histogramLayout, values, numericalValues = [], data, xScale, yScale, valueFormatter, frequencies = [], identities = [], shiftByValues = 0, sumFrequency = 0, xLabelFormatter, yLabelFormatter;
	                    if (dataView.categorical.values &&
	                        dataView.categorical.values[0] &&
	                        dataView.categorical.values[0].values) {
	                        frequencies = dataView.categorical.values[0].values;
	                    }
	                    if (dataView.categorical.categories[0].identity
	                        && dataView.categorical.categories[0].identity.length > 0) {
	                        identities = dataView.categorical.categories[0].identity;
	                    }
	                    settings = this.parseSettings(dataView);
	                    if (!settings) {
	                        return null;
	                    }
	                    values = Histogram.getValuesByFrequencies(dataView.categorical.categories[0].values, frequencies, identities);
	                    values.forEach(function (value) {
	                        numericalValues.push(value.value);
	                        sumFrequency += value.frequency;
	                    });
	                    histogramLayout = d3.layout.histogram();
	                    if (settings.bins && settings.bins > Histogram.MinNumberOfBins) {
	                        histogramLayout = histogramLayout.bins(settings.bins);
	                    }
	                    data = histogramLayout.frequency(settings.frequency)(numericalValues);
	                    data.forEach(function (bin, index) {
	                        var filteredValues, frequency;
	                        filteredValues = values.filter(function (value) {
	                            return Histogram.isValueContainedInRange(value, bin, index);
	                        });
	                        frequency = filteredValues.reduce(function (previousValue, currentValue) {
	                            return previousValue + currentValue.frequency;
	                        }, 0);
	                        bin.y = settings.frequency
	                            ? frequency
	                            : frequency / sumFrequency;
	                        shiftByValues += bin.length;
	                    });
	                    var yAxisSettings = settings.yAxisSettings;
	                    var maxYvalue = (yAxisSettings.end !== null) && (yAxisSettings.end > yAxisSettings.start) ?
	                        yAxisSettings.end : d3.max(data, function (item) { return item.y; });
	                    var minYValue = (yAxisSettings.start < maxYvalue) ? yAxisSettings.start : 0;
	                    settings.yAxisSettings.end = maxYvalue;
	                    settings.yAxisSettings.start = minYValue;
	                    settings.maxX = d3.max(data, function (item) { return d3.max(item); });
	                    xScale = d3.scale.linear()
	                        .domain([
	                        d3.min(data, function (item) { return d3.min(item); }),
	                        d3.max(data, function (item) { return d3.max(item); })
	                    ])
	                        .range([0, this.viewport.width - this.YLegendSize - this.AxisSize]);
	                    yScale = d3.scale.linear()
	                        .domain([
	                        minYValue,
	                        maxYvalue
	                    ])
	                        .range([this.viewport.height - this.LegendSize, this.outerPadding]);
	                    valueFormatter = ValueFormatter.create({
	                        format: ValueFormatter.getFormatString(dataView.categorical.categories[0].source, Histogram.Properties["general"]["formatString"]),
	                        value: values[0].value,
	                        value2: values[values.length - 1].value,
	                        precision: settings.precision
	                    });
	                    xLabelFormatter = ValueFormatter.create({
	                        value: settings.xAxisSettings.displayUnits === 0 ? values[values.length - 1].value : settings.xAxisSettings.displayUnits,
	                        precision: settings.xAxisSettings.precision
	                    });
	                    yLabelFormatter = ValueFormatter.create({
	                        value: settings.yAxisSettings.displayUnits,
	                        precision: settings.yAxisSettings.precision
	                    });
	                    return {
	                        xScale: xScale,
	                        yScale: yScale,
	                        settings: settings,
	                        data: this.getData(values, numericalValues, data, settings, yLabelFormatter, xLabelFormatter),
	                        formatter: valueFormatter,
	                        xLabelFormatter: xLabelFormatter,
	                        yLabelFormatter: yLabelFormatter
	                    };
	                };
	                Histogram.getValuesByFrequencies = function (sourceValues, frequencies, identities) {
	                    var values = [];
	                    sourceValues.forEach(function (item, index) {
	                        var frequency = 1, value = Number(item);
	                        value = isNaN(value) ? 0 : value;
	                        if (frequencies
	                            && frequencies[index]
	                            && !isNaN(frequencies[index])
	                            && frequencies[index] > 1) {
	                            frequency = frequencies[index];
	                        }
	                        values.push({
	                            value: value,
	                            frequency: frequency,
	                            selectionId: SelectionId.createWithId(identities[index])
	                        });
	                    });
	                    return values;
	                };
	                Histogram.prototype.getData = function (values, numericalValues, data, settings, yValueFormatter, xValueFormatter) {
	                    var _this = this;
	                    var minValue = d3.min(numericalValues), maxValue = d3.max(numericalValues);
	                    var fontSizeInPx = PixelConverter.fromPoint(settings.labelSettings.fontSize);
	                    return data.map(function (bin, index) {
	                        bin.range = Histogram.getRange(minValue, maxValue, bin.dx, index);
	                        bin.tooltipInfo = _this.getTooltipData(bin.y, bin.range, settings, index === 0, yValueFormatter, xValueFormatter);
	                        bin.selectionIds = Histogram.getSelectionIds(values, bin, index);
	                        bin.labelFontSize = fontSizeInPx;
	                        return bin;
	                    });
	                };
	                Histogram.getRange = function (minValue, maxValue, step, index) {
	                    var leftBorder = minValue + index * step, rightBorder = leftBorder + step;
	                    return [leftBorder, rightBorder];
	                };
	                Histogram.prototype.getTooltipData = function (value, range, settings, includeLeftBorder, yValueFormatter, xValueFormatter) {
	                    return [{
	                            displayName: Histogram.getLegendText(settings),
	                            value: yValueFormatter.format(value)
	                        }, {
	                            displayName: this.TooltipDisplayName,
	                            value: this.rangeToString(range, includeLeftBorder, xValueFormatter)
	                        }];
	                };
	                Histogram.getSelectionIds = function (values, bin, index) {
	                    var selectionIds = [];
	                    values.forEach(function (value) {
	                        if (Histogram.isValueContainedInRange(value, bin, index)) {
	                            selectionIds.push(value.selectionId);
	                        }
	                    });
	                    return selectionIds;
	                };
	                Histogram.isValueContainedInRange = function (value, bin, index) {
	                    return ((index === 0 && value.value >= bin.x) || (value.value > bin.x)) && value.value <= bin.x + bin.dx;
	                };
	                Histogram.prototype.parseSettings = function (dataView) {
	                    if (!dataView ||
	                        !dataView.metadata ||
	                        !dataView.metadata.columns ||
	                        !dataView.metadata.columns[0]) {
	                        return null;
	                    }
	                    var histogramSettings = {}, objects, colorHelper;
	                    colorHelper = new ColorHelper(this.colors, Histogram.Properties["dataPoint"]["fill"], Histogram.DefaultHistogramSettings.fillColor);
	                    histogramSettings.displayName =
	                        dataView.metadata.columns[0].displayName || Histogram.DefaultHistogramSettings.displayName;
	                    objects = Histogram.getObjectsFromDataView(dataView);
	                    var xAxisSettings = {
	                        axisColor: Histogram.getXAxisColor(objects).solid.color,
	                        title: Histogram.getXTitle(objects),
	                        precision: Histogram.getXPrecision(objects),
	                        style: Histogram.getXStyle(objects),
	                        displayUnits: Histogram.getXDisplayUnit(objects),
	                        show: Histogram.getXAxisShow(objects),
	                    };
	                    var yAxisSettings = {
	                        axisColor: Histogram.getYAxisColor(objects).solid.color,
	                        title: Histogram.getYTitle(objects),
	                        precision: Histogram.getYPrecision(objects),
	                        style: Histogram.getYStyle(objects),
	                        displayUnits: Histogram.getYDisplayUnit(objects),
	                        show: Histogram.getYAxisShow(objects),
	                        start: Histogram.getYStart(objects),
	                        end: Histogram.getYEnd(objects),
	                        position: Histogram.getYPosition(objects),
	                    };
	                    var labelSettings = {
	                        show: Histogram.getLabelShow(objects),
	                        color: Histogram.getLabelColor(objects).solid.color,
	                        displayUnits: Histogram.getLabelDisplayUnits(objects),
	                        precision: Histogram.getLabelPrecision(objects),
	                        fontSize: Histogram.getLabelFontSize(objects),
	                    };
	                    histogramSettings.fillColor = colorHelper.getColorForMeasure(objects, "");
	                    histogramSettings.bins = Histogram.getBins(objects);
	                    histogramSettings.frequency = Histogram.getFrequency(objects);
	                    histogramSettings.precision = Histogram.getPrecision(objects);
	                    histogramSettings.displayName = Histogram.getLegend(histogramSettings.displayName, xAxisSettings.style, xAxisSettings.displayUnits);
	                    histogramSettings.xAxisSettings = xAxisSettings;
	                    histogramSettings.yAxisSettings = yAxisSettings;
	                    histogramSettings.labelSettings = labelSettings;
	                    return histogramSettings;
	                };
	                Histogram.getLegend = function (title, style, displayUnit) {
	                    var retValue;
	                    var formatter = ValueFormatter.create({
	                        value: displayUnit
	                    });
	                    switch (style) {
	                        case axisStyle.showTitleOnly:
	                            retValue = title;
	                            break;
	                        case axisStyle.showUnitOnly:
	                            retValue = displayUnit === 0 || displayUnit === 1 ? title : formatter.displayUnit.title;
	                            break;
	                        case axisStyle.showBoth:
	                            retValue = displayUnit === 0 || displayUnit === 1 ? title : title + " (" + formatter.displayUnit.title + ")";
	                            break;
	                    }
	                    return retValue;
	                };
	                Histogram.getLabelFontSize = function (objects) {
	                    return DataViewObjects.getValue(objects, Histogram.Properties["labels"]["fontSize"], Histogram.DefaultHistogramSettings.labelSettings.fontSize);
	                };
	                Histogram.getLabelShow = function (objects) {
	                    return DataViewObjects.getValue(objects, Histogram.Properties["labels"]["show"], Histogram.DefaultHistogramSettings.labelSettings.show);
	                };
	                Histogram.getLabelColor = function (objects) {
	                    return DataViewObjects.getValue(objects, Histogram.Properties["labels"]["color"], {
	                        solid: {
	                            color: Histogram.DefaultHistogramSettings.labelSettings.color
	                        }
	                    });
	                };
	                Histogram.getLabelDisplayUnits = function (objects) {
	                    return DataViewObjects.getValue(objects, Histogram.Properties["labels"]["displayUnits"], Histogram.DefaultHistogramSettings.labelSettings.displayUnits);
	                };
	                Histogram.getLabelPrecision = function (objects) {
	                    var precision = DataViewObjects.getValue(objects, Histogram.Properties["labels"]["precision"], Histogram.DefaultHistogramSettings.labelSettings.precision);
	                    if (precision <= Histogram.MinPrecision) {
	                        return Histogram.MinPrecision;
	                    }
	                    else if (precision >= Histogram.MaxPrecision) {
	                        return Histogram.MaxPrecision;
	                    }
	                    return precision;
	                };
	                Histogram.getXStyle = function (objects) {
	                    return DataViewObjects.getValue(objects, Histogram.Properties["xAxis"]["style"], Histogram.DefaultHistogramSettings.xAxisSettings.style);
	                };
	                Histogram.getXDisplayUnit = function (objects) {
	                    return DataViewObjects.getValue(objects, Histogram.Properties["xAxis"]["displayUnits"], Histogram.DefaultHistogramSettings.xAxisSettings.displayUnits);
	                };
	                Histogram.getXPrecision = function (objects) {
	                    var precision = DataViewObjects.getValue(objects, Histogram.Properties["xAxis"]["precision"], Histogram.DefaultHistogramSettings.xAxisSettings.precision);
	                    if (precision <= Histogram.MinPrecision) {
	                        return Histogram.MinPrecision;
	                    }
	                    else if (precision >= Histogram.MaxPrecision) {
	                        return Histogram.MaxPrecision;
	                    }
	                    return precision;
	                };
	                Histogram.getXAxisShow = function (objects) {
	                    return DataViewObjects.getValue(objects, Histogram.Properties["xAxis"]["show"], Histogram.DefaultHistogramSettings.xAxisSettings.show);
	                };
	                Histogram.getXAxisColor = function (objects) {
	                    return DataViewObjects.getValue(objects, Histogram.Properties["xAxis"]["axisColor"], {
	                        solid: {
	                            color: Histogram.DefaultHistogramSettings.xAxisSettings.axisColor
	                        }
	                    });
	                };
	                Histogram.getXTitle = function (objects) {
	                    return DataViewObjects.getValue(objects, Histogram.Properties["xAxis"]["title"], Histogram.DefaultHistogramSettings.xAxisSettings.title);
	                };
	                Histogram.getYStyle = function (objects) {
	                    return DataViewObjects.getValue(objects, Histogram.Properties["yAxis"]["style"], Histogram.DefaultHistogramSettings.yAxisSettings.style);
	                };
	                Histogram.getYPosition = function (objects) {
	                    return DataViewObjects.getValue(objects, Histogram.Properties["yAxis"]["position"], Histogram.DefaultHistogramSettings.yAxisSettings.position);
	                };
	                Histogram.getYAxisShow = function (objects) {
	                    return DataViewObjects.getValue(objects, Histogram.Properties["yAxis"]["show"], Histogram.DefaultHistogramSettings.yAxisSettings.show);
	                };
	                Histogram.getYAxisColor = function (objects) {
	                    return DataViewObjects.getValue(objects, Histogram.Properties["yAxis"]["axisColor"], {
	                        solid: {
	                            color: Histogram.DefaultHistogramSettings.yAxisSettings.axisColor
	                        }
	                    });
	                };
	                Histogram.getYStart = function (objects) {
	                    return DataViewObjects.getValue(objects, Histogram.Properties["yAxis"]["start"], Histogram.DefaultHistogramSettings.yAxisSettings.start);
	                };
	                Histogram.getYEnd = function (objects) {
	                    return DataViewObjects.getValue(objects, Histogram.Properties["yAxis"]["end"], Histogram.DefaultHistogramSettings.yAxisSettings.end);
	                };
	                Histogram.getYDisplayUnit = function (objects) {
	                    return DataViewObjects.getValue(objects, Histogram.Properties["yAxis"]["displayUnits"], Histogram.DefaultHistogramSettings.yAxisSettings.displayUnits);
	                };
	                Histogram.getYPrecision = function (objects) {
	                    var precision = DataViewObjects.getValue(objects, Histogram.Properties["yAxis"]["precision"], Histogram.DefaultHistogramSettings.yAxisSettings.precision);
	                    if (precision <= Histogram.MinPrecision) {
	                        return Histogram.MinPrecision;
	                    }
	                    else if (precision >= Histogram.MaxPrecision) {
	                        return Histogram.MaxPrecision;
	                    }
	                    return precision;
	                };
	                Histogram.getYTitle = function (objects) {
	                    return DataViewObjects.getValue(objects, Histogram.Properties["yAxis"]["title"], Histogram.DefaultHistogramSettings.yAxisSettings.title);
	                };
	                Histogram.getBins = function (objects) {
	                    var binsNumber = Number(DataViewObjects.getValue(objects, Histogram.Properties["general"]["bins"], Histogram.DefaultHistogramSettings.bins));
	                    if (!binsNumber || isNaN(binsNumber) || (binsNumber <= Histogram.MinNumberOfBins)) {
	                        return Histogram.DefaultHistogramSettings.bins;
	                    }
	                    if (binsNumber > Histogram.MaxNumberOfBins) {
	                        return Histogram.MaxNumberOfBins;
	                    }
	                    return binsNumber;
	                };
	                Histogram.getFrequency = function (objects) {
	                    return DataViewObjects.getValue(objects, Histogram.Properties["general"]["frequency"], Histogram.DefaultHistogramSettings.frequency);
	                };
	                Histogram.getPrecision = function (objects) {
	                    var precision = DataViewObjects.getValue(objects, Histogram.Properties["labels"]["precision"], Histogram.DefaultHistogramSettings.precision);
	                    if (precision <= Histogram.MinPrecision) {
	                        return Histogram.MinPrecision;
	                    }
	                    if (precision >= Histogram.MaxPrecision) {
	                        return Histogram.MaxPrecision;
	                    }
	                    return precision;
	                };
	                Histogram.prototype.validateData = function (data) {
	                    if (data && data.data.some(function (x) { return x.range.some(function (x) { return isNaN(x) || x === Infinity || x === -Infinity; }); })) {
	                        this.hostService.setWarnings([new HistogramChartWarning(HistogramChartWarning.ErrorInvalidDataValues)]);
	                        return false;
	                    }
	                    return true;
	                };
	                Histogram.prototype.update = function (visualUpdateOptions) {
	                    if (!visualUpdateOptions ||
	                        !visualUpdateOptions.dataViews ||
	                        !visualUpdateOptions.dataViews[0]) {
	                        return;
	                    }
	                    var dataView = visualUpdateOptions.dataViews[0], widthOfLabel;
	                    this.durationAnimations = getAnimationDuration(this.animator, visualUpdateOptions.suppressAnimations);
	                    this.setSize(visualUpdateOptions.viewport);
	                    this.histogramDataView = this.converter(dataView);
	                    if (!this.validateData(this.histogramDataView)) {
	                        this.histogramDataView.data = [];
	                    }
	                    if (!this.histogramDataView) {
	                        return;
	                    }
	                    this.YLegendSize = this.getLegendSize(this.histogramDataView.settings.yAxisSettings);
	                    this.XLegendSize = this.getLegendSize(this.histogramDataView.settings.xAxisSettings);
	                    widthOfLabel = this.getWidthOfLabel();
	                    this.xAxisProperties = this.calculateXAxes(dataView.categorical.categories[0].source, this.textProperties, widthOfLabel, false);
	                    var ySource = dataView.categorical.values &&
	                        dataView.categorical.values[0] &&
	                        dataView.categorical.values[0].values
	                        ? dataView.categorical.values[0].source
	                        : dataView.categorical.categories[0].source;
	                    this.yAxisProperties = this.calculateYAxes(ySource, this.textProperties, widthOfLabel, false);
	                    this.render();
	                };
	                Histogram.prototype.getLegendSize = function (axisSettings) {
	                    return axisSettings.title
	                        ? Histogram.LegendSizeWhenTitleIsActive
	                        : Histogram.LegendSizeWhenTitleIsNotActive;
	                };
	                Histogram.prototype.getWidthOfLabel = function () {
	                    if (!this.histogramDataView || !this.histogramDataView.settings) {
	                        return;
	                    }
	                    var ticLabel = this.histogramDataView.xLabelFormatter.format(this.histogramDataView.settings.maxX);
	                    var textProperties = {
	                        text: ticLabel,
	                        fontFamily: this.textProperties.fontFamily,
	                        fontSize: this.textProperties.fontSize
	                    };
	                    return TextMeasurementService.measureSvgTextWidth(textProperties) + Histogram.AdditionalWidthOfLabel;
	                };
	                Histogram.prototype.setSize = function (viewport) {
	                    var height, width;
	                    height = viewport.height -
	                        this.margin.top -
	                        this.margin.bottom;
	                    width = viewport.width -
	                        this.margin.left -
	                        this.margin.right;
	                    this.viewport = {
	                        height: height,
	                        width: width
	                    };
	                    this.updateElements(viewport.height, viewport.width);
	                };
	                Histogram.prototype.updateElements = function (height, width) {
	                    this.root.attr({
	                        "height": height,
	                        "width": width
	                    });
	                    this.main.attr("transform", SVGUtil.translate(this.margin.left, this.margin.top));
	                    this.legend.attr("transform", SVGUtil.translate(this.margin.left, this.margin.top));
	                    this.axisX.attr("transform", SVGUtil.translate(0, this.viewport.height - this.XLegendSize));
	                };
	                Histogram.prototype.shouldShowYOnRight = function () {
	                    return this.histogramDataView.settings.yAxisSettings.position === yAxisPosition.right;
	                };
	                Histogram.prototype.columsAndAxesTransform = function (labelWidth) {
	                    var constMargin = 20;
	                    var shiftToRight = this.shouldShowYOnRight() ? 10 :
	                        this.histogramDataView.settings.yAxisSettings.title ? this.margin.left + labelWidth + constMargin : this.margin.left + labelWidth;
	                    this.DataLabelMargin = shiftToRight;
	                    this.columns.attr("transform", SVGUtil.translate(shiftToRight, 0));
	                    this.axes.attr("transform", SVGUtil.translate(shiftToRight, 0));
	                    this.axisY.attr('transform', SVGUtil.translate(this.shouldShowYOnRight() ? this.viewport.width - this.AxisSize - this.YLegendSize + 0.01 : 0, 0));
	                    this.axisX.attr("transform", SVGUtil.translate(0, this.viewport.height - this.XLegendSize));
	                };
	                Histogram.prototype.render = function () {
	                    if (!this.histogramDataView || !this.histogramDataView.settings) {
	                        return;
	                    }
	                    this.renderAxes();
	                    var columnsSelection = this.renderColumns();
	                    this.adjustTransformToAxisLabels();
	                    this.renderLegend();
	                    if (this.histogramDataView.settings.labelSettings.show) {
	                        this.renderLabels();
	                    }
	                    else {
	                        this.main.selectAll('.labels').selectAll('*').remove();
	                    }
	                    this.bindSelectionHandler(columnsSelection);
	                };
	                Histogram.prototype.adjustTransformToAxisLabels = function () {
	                    var maxWidthOfLabael = 0;
	                    this.main.selectAll('g.axis').filter(function (d, index) { return index === 1; }).selectAll('g.tick text')
	                        .each(function (d, i) {
	                        var p = TextMeasurementService.getSvgMeasurementProperties(this);
	                        var textProperties = {
	                            text: p.text,
	                            fontFamily: p.fontFamily,
	                            fontSize: p.fontSize
	                        };
	                        var widthOfLabel = TextMeasurementService.measureSvgTextWidth(textProperties);
	                        if (widthOfLabel > maxWidthOfLabael)
	                            maxWidthOfLabael = widthOfLabel;
	                    });
	                    var constMargin = 70;
	                    this.yTitleMargin = this.shouldShowYOnRight() ? this.viewport.width - this.AxisSize - constMargin + this.YLegendSize + maxWidthOfLabael : 0;
	                    this.columsAndAxesTransform(maxWidthOfLabael);
	                };
	                Histogram.prototype.renderColumns = function () {
	                    var _this = this;
	                    var data = this.histogramDataView.data, yScale = this.histogramDataView.yScale, countOfValues = data.length, widthOfColumn, updateColumnsSelection;
	                    widthOfColumn = countOfValues && ((this.viewport.width - this.AxisSize - this.YLegendSize) / countOfValues - this.ColumnPadding);
	                    if (widthOfColumn < 0) {
	                        widthOfColumn = 0;
	                    }
	                    this.widthOfColumn = widthOfColumn;
	                    updateColumnsSelection = this.columnsSelection.data(data);
	                    updateColumnsSelection
	                        .enter()
	                        .append("svg:rect");
	                    updateColumnsSelection
	                        .attr("x", this.ColumnPadding / 2)
	                        .attr("width", widthOfColumn)
	                        .attr("height", function (item) { return _this.getColumnHeight(item, yScale); })
	                        .style("fill", this.histogramDataView.settings.fillColor)
	                        .attr("class", Histogram.Column.class)
	                        .attr("transform", function (item, index) { return SVGUtil.translate(widthOfColumn * index + _this.ColumnPadding * index, yScale(item.y) - _this.ColumnPadding / 2.5); });
	                    if (countOfValues) {
	                        //if data is empty, it throws for some reason
	                        updateColumnsSelection.classed(Histogram.Column.class);
	                    }
	                    updateColumnsSelection.exit().remove();
	                    Histogram.renderTooltip(updateColumnsSelection);
	                    return updateColumnsSelection;
	                };
	                Histogram.renderTooltip = function (selection) {
	                    TooltipManager.addTooltip(selection, function (tooltipEvent) {
	                        return tooltipEvent.data.tooltipInfo;
	                    });
	                };
	                Histogram.prototype.getColumnHeight = function (column, y) {
	                    var height = this.viewport.height - this.XLegendSize - y(column.y);
	                    return height > 0 ? height : this.MinColumnHeight;
	                };
	                Histogram.prototype.renderAxes = function () {
	                    var _this = this;
	                    var xAxis, yAxis;
	                    xAxis = this.xAxisProperties.axis
	                        .tickFormat(function (item) { return _this.histogramDataView.xLabelFormatter.format(item); })
	                        .orient('bottom');
	                    yAxis = this.yAxisProperties.axis
	                        .orient(this.histogramDataView.settings.yAxisSettings.position.toLowerCase())
	                        .tickFormat(function (item) { return _this.histogramDataView.yLabelFormatter.format(item); });
	                    var xShow = this.histogramDataView.settings.xAxisSettings.show;
	                    var yShow = this.histogramDataView.settings.yAxisSettings.show;
	                    if (xShow) {
	                        this.axisX
	                            .transition()
	                            .duration(1)
	                            .call(xAxis);
	                    }
	                    else {
	                        this.axisX.selectAll('*').remove();
	                    }
	                    if (yShow) {
	                        this.axisY
	                            .call(yAxis);
	                    }
	                    else {
	                        this.axisY.selectAll('*').remove();
	                    }
	                    this.main.selectAll('g.axis').filter(function (d, index) { return index === 0; }).selectAll('g.tick text').style({
	                        'fill': this.histogramDataView.settings.xAxisSettings.axisColor,
	                    });
	                    this.main.selectAll('g.axis').filter(function (d, index) { return index === 1; }).selectAll('g.tick text').style({
	                        'fill': this.histogramDataView.settings.yAxisSettings.axisColor,
	                    });
	                };
	                Histogram.prototype.getLabaelLayout = function () {
	                    var _this = this;
	                    var labelSettings = this.histogramDataView.settings.labelSettings;
	                    var fontSizeInPx = PixelConverter.fromPoint(labelSettings.fontSize);
	                    var dataLabelFormatter = ValueFormatter.create({
	                        value: labelSettings.displayUnits,
	                        precision: labelSettings.precision
	                    });
	                    return {
	                        labelText: function (b) {
	                            return dataLabelFormatter.format(b.y).toString();
	                        },
	                        labelLayout: {
	                            x: function (b) { return _this.DataLabelMargin + _this.histogramDataView.xScale(b.x) + _this.widthOfColumn / 2; },
	                            y: function (b) { return _this.histogramDataView.yScale(b.y) - 5; }
	                        },
	                        filter: function (b) {
	                            return (b != null);
	                        },
	                        style: {
	                            'fill': labelSettings.color,
	                            'font-size': fontSizeInPx,
	                        },
	                    };
	                };
	                Histogram.prototype.renderLabels = function () {
	                    var layout = this.getLabaelLayout();
	                    var dataPointsArray = this.histogramDataView.data;
	                    dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPointsArray, this.main, layout, this.viewport);
	                };
	                Histogram.rangesToArray = function (data) {
	                    return data.reduce(function (previousValue, currentValue, index) {
	                        var range;
	                        range = (index === 0)
	                            ? currentValue.range
	                            : currentValue.range.slice(1);
	                        return previousValue.concat(range);
	                    }, []);
	                };
	                Histogram.prototype.rangeToString = function (range, includeLeftBorder, valueFormatter) {
	                    var leftBracket, rightBracket = this.IncludeBrackets.right, leftBorder = valueFormatter.format(range[0]), rightBorder = valueFormatter.format(range[1]);
	                    leftBracket = includeLeftBorder
	                        ? this.IncludeBrackets.left
	                        : this.ExcludeBrackets.left;
	                    return "" + leftBracket + leftBorder + this.SeparatorNumbers + rightBorder + rightBracket;
	                };
	                Histogram.prototype.renderLegend = function () {
	                    var legendElements, legendSelection, datalegends = this.getDataLegends(this.histogramDataView.settings);
	                    legendElements = this.main
	                        .select(Histogram.Legends.selector)
	                        .selectAll(Histogram.Legend.selector);
	                    legendSelection = legendElements.data(datalegends);
	                    legendSelection
	                        .enter()
	                        .append("svg:text");
	                    legendSelection
	                        .attr("x", 0)
	                        .attr("y", 0)
	                        .attr("dx", function (item) { return item.dx; })
	                        .attr("dy", function (item) { return item.dy; })
	                        .attr("transform", function (item) { return item.transform; })
	                        .attr("class", Histogram.Legend.class)
	                        .text(function (item) { return item.text; })
	                        .classed(Histogram.Legend.class, true);
	                    legendSelection
	                        .exit()
	                        .remove();
	                    this.legend.select('text').style({
	                        'display': this.histogramDataView.settings.xAxisSettings.title === true ? 'block' : 'none',
	                    });
	                    this.legend.selectAll('text').filter(function (d, index) { return index === 1; }).style({
	                        'display': this.histogramDataView.settings.yAxisSettings.title === true ? 'block' : 'none',
	                    });
	                };
	                Histogram.prototype.getDataLegends = function (settings) {
	                    var bottomLegendText = Histogram.getLegendText(settings);
	                    bottomLegendText = Histogram.getLegend(bottomLegendText, settings.yAxisSettings.style, settings.yAxisSettings.displayUnits);
	                    return [{
	                            transform: SVGUtil.translate(this.viewport.width / 2, this.viewport.height),
	                            text: settings.displayName,
	                            dx: "1em",
	                            dy: "-1em"
	                        }, {
	                            transform: SVGUtil.translateAndRotate(this.shouldShowYOnRight() ? this.yTitleMargin : 0, this.viewport.height / 2, 0, 0, 270),
	                            text: bottomLegendText,
	                            dx: "3em"
	                        }];
	                };
	                Histogram.getLegendText = function (settings) {
	                    return settings.frequency
	                        ? Histogram.FrequencyText
	                        : Histogram.DensityText;
	                };
	                Histogram.prototype.bindSelectionHandler = function (columnsSelection) {
	                    var _this = this;
	                    this.setSelection(columnsSelection);
	                    columnsSelection.on("click", function (data) {
	                        _this.selectionManager.clear();
	                        data.selectionIds.forEach(function (selectionId) {
	                            _this.selectionManager.select(selectionId, true).then(function (selectionIds) {
	                                if (selectionIds.length > 0) {
	                                    _this.setSelection(columnsSelection, data);
	                                }
	                                else {
	                                    _this.setSelection(columnsSelection);
	                                }
	                            });
	                        });
	                        d3.event.stopPropagation();
	                    });
	                    this.root.on("click", function () {
	                        _this.selectionManager.clear();
	                        _this.setSelection(columnsSelection);
	                    });
	                };
	                Histogram.prototype.setSelection = function (columnsSelection, data) {
	                    columnsSelection.transition()
	                        .duration(this.durationAnimations)
	                        .style("fill-opacity", this.MaxOpacity);
	                    if (!data) {
	                        return;
	                    }
	                    columnsSelection
	                        .filter(function (columnSelection) {
	                        return columnSelection !== data;
	                    })
	                        .transition()
	                        .duration(this.durationAnimations)
	                        .style("fill-opacity", this.MinOpacity);
	                };
	                Histogram.prototype.enumerateObjectInstances = function (options) {
	                    var instances = [], settings;
	                    if (!this.histogramDataView ||
	                        !this.histogramDataView.settings) {
	                        return instances;
	                    }
	                    settings = this.histogramDataView.settings;
	                    switch (options.objectName) {
	                        case "general": {
	                            var general = {
	                                objectName: "general",
	                                displayName: "general",
	                                selector: null,
	                                properties: {
	                                    bins: settings.bins,
	                                    frequency: settings.frequency
	                                }
	                            };
	                            instances.push(general);
	                            break;
	                        }
	                        case "dataPoint": {
	                            var dataPoint = {
	                                objectName: "dataPoint",
	                                displayName: "dataPoint",
	                                selector: null,
	                                properties: {
	                                    fill: settings.fillColor
	                                }
	                            };
	                            instances.push(dataPoint);
	                            break;
	                        }
	                        case "labels": {
	                            var labelsSettings = settings.labelSettings;
	                            var labels = {
	                                objectName: "labels",
	                                displayName: "labels",
	                                selector: null,
	                                properties: {
	                                    show: labelsSettings.show,
	                                    color: labelsSettings.color,
	                                    displayUnits: labelsSettings.displayUnits,
	                                    precision: labelsSettings.precision,
	                                    fontSize: labelsSettings.fontSize
	                                }
	                            };
	                            instances.push(labels);
	                            break;
	                        }
	                        case "xAxis": {
	                            var xAxisSettings = settings.xAxisSettings;
	                            var xAxis = {
	                                objectName: "xAxis",
	                                displayName: "X-Axis",
	                                selector: null,
	                                properties: {
	                                    show: xAxisSettings.show,
	                                    title: xAxisSettings.title,
	                                    style: xAxisSettings.style,
	                                    axisColor: xAxisSettings.axisColor,
	                                    displayUnits: xAxisSettings.displayUnits,
	                                    precision: xAxisSettings.precision,
	                                }
	                            };
	                            instances.push(xAxis);
	                            break;
	                        }
	                        case "yAxis": {
	                            var yAxisSettings = settings.yAxisSettings;
	                            var yAxis = {
	                                objectName: "yAxis",
	                                displayName: "Y-Axis",
	                                selector: null,
	                                properties: {
	                                    show: yAxisSettings.show,
	                                    position: yAxisSettings.position,
	                                    start: yAxisSettings.start,
	                                    end: yAxisSettings.end,
	                                    title: yAxisSettings.title,
	                                    style: yAxisSettings.style,
	                                    axisColor: yAxisSettings.axisColor,
	                                    displayUnits: yAxisSettings.displayUnits,
	                                    precision: yAxisSettings.precision,
	                                }
	                            };
	                            instances.push(yAxis);
	                            break;
	                        }
	                    }
	                    return instances;
	                };
	                Histogram.getObjectsFromDataView = function (dataView) {
	                    if (!dataView ||
	                        !dataView.metadata ||
	                        !dataView.metadata.columns ||
	                        !dataView.metadata.objects) {
	                        return null;
	                    }
	                    return dataView.metadata.objects;
	                };
	                Histogram.prototype.destroy = function () {
	                    this.root = null;
	                };
	                Histogram.prototype.calculateXAxes = function (source, textProperties, widthOfLabel, scrollbarVisible) {
	                    var axes, visualOptions, width = this.viewport.width;
	                    visualOptions = {
	                        viewport: this.viewport,
	                        margin: this.margin,
	                        forcedXDomain: Histogram.rangesToArray(this.histogramDataView.data),
	                        forceMerge: true,
	                        showCategoryAxisLabel: false,
	                        showValueAxisLabel: false,
	                        categoryAxisScaleType: axisScale.linear,
	                        valueAxisScaleType: null,
	                        trimOrdinalDataOnOverflow: false
	                    };
	                    axes = this.calculateXAxesProperties(visualOptions, source, Histogram.InnerPaddingRatio, widthOfLabel);
	                    axes.willLabelsFit = willLabelsFit(axes, width, TextMeasurementService.measureSvgTextWidth, textProperties);
	                    // If labels do not fit and we are not scrolling, try word breaking
	                    axes.willLabelsWordBreak = (!axes.willLabelsFit && !scrollbarVisible) && willLabelsWordBreak(axes, this.margin, width, TextMeasurementService.measureSvgTextWidth, TextMeasurementService.estimateSvgTextHeight, TextMeasurementService.getTailoredTextOrDefault, textProperties);
	                    return axes;
	                };
	                Histogram.prototype.calculateXAxesProperties = function (options, metaDataColumn, innerPaddingRatio, minOrdinalRectThickness) {
	                    var xAxisProperties = HistogramAxisHelper.createAxis({
	                        pixelSpan: this.viewport.width - this.YLegendSize - this.AxisSize,
	                        dataDomain: options.forcedXDomain,
	                        metaDataColumn: metaDataColumn,
	                        formatString: valueFormatter.getFormatString(metaDataColumn, Histogram.Properties["general"]["formatString"]),
	                        outerPadding: 0,
	                        isScalar: false,
	                        isVertical: false,
	                        useTickIntervalForDisplayUnits: true,
	                        isCategoryAxis: true,
	                        getValueFn: function (index, type) { return index; },
	                        scaleType: options.categoryAxisScaleType,
	                        innerPaddingRatio: innerPaddingRatio,
	                        minOrdinalRectThickness: minOrdinalRectThickness,
	                        tickLabelPadding: undefined
	                    });
	                    xAxisProperties.axisLabel = this.histogramDataView.settings.displayName;
	                    return xAxisProperties;
	                };
	                Histogram.prototype.calculateYAxes = function (source, textProperties, widthOfLabel, scrollbarVisible) {
	                    var yAxisSettings, visualOptions;
	                    visualOptions = {
	                        viewport: this.viewport,
	                        margin: this.margin,
	                        forceMerge: true,
	                        showCategoryAxisLabel: true,
	                        showValueAxisLabel: false,
	                        categoryAxisScaleType: axisScale.linear,
	                        valueAxisScaleType: null,
	                        trimOrdinalDataOnOverflow: false
	                    };
	                    yAxisSettings = this.histogramDataView.settings.yAxisSettings;
	                    visualOptions.forcedYDomain = applyCustomizedDomain([yAxisSettings.start, yAxisSettings.end], visualOptions.forcedYDomain);
	                    return this.calculateYAxesProperties(visualOptions, source, Histogram.InnerPaddingRatio, widthOfLabel);
	                };
	                Histogram.prototype.calculateYAxesProperties = function (options, metaDataColumn, innerPaddingRatio, minOrdinalRectThickness) {
	                    var yAxisSettings = this.histogramDataView.settings.yAxisSettings;
	                    return HistogramAxisHelper.createAxis({
	                        pixelSpan: this.viewport.height - this.XLegendSize + 5,
	                        dataDomain: combineDomain(options.forcedYDomain, [yAxisSettings.start, yAxisSettings.end]),
	                        metaDataColumn: metaDataColumn,
	                        formatString: valueFormatter.getFormatString(metaDataColumn, Histogram.Properties["general"]["formatString"]),
	                        outerPadding: this.outerPadding,
	                        isScalar: true,
	                        isVertical: true,
	                        useTickIntervalForDisplayUnits: true,
	                        isCategoryAxis: false,
	                        getValueFn: function (index, type) { return index; },
	                        scaleType: options.categoryAxisScaleType,
	                        innerPaddingRatio: innerPaddingRatio,
	                        minOrdinalRectThickness: minOrdinalRectThickness,
	                        tickLabelPadding: undefined
	                    });
	                };
	                Histogram.ClassName = "histogram";
	                Histogram.FrequencyText = "Frequency";
	                Histogram.DensityText = "Density";
	                Histogram.Properties = {
	                    general: {
	                        bins: {
	                            objectName: "general",
	                            propertyName: "bins"
	                        },
	                        frequency: {
	                            objectName: "general",
	                            propertyName: "frequency"
	                        },
	                        formatString: {
	                            objectName: "general",
	                            propertyName: "formatString"
	                        }
	                    },
	                    dataPoint: {
	                        fill: {
	                            objectName: "dataPoint",
	                            propertyName: "fill"
	                        }
	                    },
	                    labels: {
	                        show: {
	                            objectName: "labels",
	                            propertyName: "show"
	                        },
	                        color: {
	                            objectName: "labels",
	                            propertyName: "color"
	                        },
	                        displayUnits: {
	                            objectName: "labels",
	                            propertyName: "displayUnits"
	                        },
	                        precision: {
	                            objectName: "labels",
	                            propertyName: "precision"
	                        },
	                        fontSize: {
	                            objectName: "labels",
	                            propertyName: "fontSize"
	                        }
	                    },
	                    xAxis: {
	                        show: {
	                            objectName: "xAxis",
	                            propertyName: "show"
	                        },
	                        axisColor: {
	                            objectName: "xAxis",
	                            propertyName: "axisColor"
	                        },
	                        title: {
	                            objectName: "xAxis",
	                            propertyName: "title"
	                        },
	                        displayUnits: {
	                            objectName: "xAxis",
	                            propertyName: "displayUnits"
	                        },
	                        precision: {
	                            objectName: "xAxis",
	                            propertyName: "precision"
	                        },
	                        style: {
	                            objectName: "xAxis",
	                            propertyName: "style"
	                        }
	                    },
	                    yAxis: {
	                        show: {
	                            objectName: "yAxis",
	                            propertyName: "show"
	                        },
	                        axisColor: {
	                            objectName: "yAxis",
	                            propertyName: "axisColor"
	                        },
	                        title: {
	                            objectName: "yAxis",
	                            propertyName: "title"
	                        },
	                        displayUnits: {
	                            objectName: "yAxis",
	                            propertyName: "displayUnits"
	                        },
	                        precision: {
	                            objectName: "yAxis",
	                            propertyName: "precision"
	                        },
	                        style: {
	                            objectName: "yAxis",
	                            propertyName: "style"
	                        },
	                        start: {
	                            objectName: "yAxis",
	                            propertyName: "start"
	                        },
	                        end: {
	                            objectName: "yAxis",
	                            propertyName: "end"
	                        },
	                        position: {
	                            objectName: "yAxis",
	                            propertyName: "position"
	                        }
	                    }
	                };
	                Histogram.DefaultHistogramSettings = {
	                    frequency: true,
	                    displayName: "Histogram",
	                    bins: null,
	                    fillColor: "#5f9ea0",
	                    precision: 2,
	                    xAxisSettings: {
	                        show: true,
	                        axisColor: "#5f9ea0",
	                        title: true,
	                        displayUnits: 0,
	                        precision: 2,
	                        style: axisStyle.showTitleOnly,
	                    },
	                    yAxisSettings: {
	                        show: true,
	                        axisColor: "#5f9ea0",
	                        title: true,
	                        displayUnits: 0,
	                        precision: 2,
	                        style: axisStyle.showTitleOnly,
	                        start: 0,
	                        position: yAxisPosition.left,
	                    },
	                    labelSettings: {
	                        show: false,
	                        color: "#5f9ea0",
	                        displayUnits: 0,
	                        precision: 2,
	                        fontSize: 9
	                    },
	                };
	                Histogram.Axes = createClassAndSelector('axes');
	                Histogram.Axis = createClassAndSelector('axis');
	                Histogram.Labels = createClassAndSelector('labels');
	                Histogram.Columns = createClassAndSelector('columns');
	                Histogram.Column = createClassAndSelector('column');
	                Histogram.Legends = createClassAndSelector('legends');
	                Histogram.Legend = createClassAndSelector('legend');
	                Histogram.MinNumberOfBins = 0;
	                Histogram.MaxNumberOfBins = 100;
	                Histogram.MinPrecision = 0;
	                Histogram.MaxPrecision = 17; // max number of decimals in float
	                Histogram.AdditionalWidthOfLabel = 3;
	                Histogram.LegendSizeWhenTitleIsActive = 50;
	                Histogram.LegendSizeWhenTitleIsNotActive = 25;
	                Histogram.InnerPaddingRatio = 1;
	                Histogram.capabilities = {
	                    dataRoles: [
	                        {
	                            name: "Values",
	                            kind: VisualDataRoleKind.Grouping,
	                            displayName: createDisplayNameGetter("Role_DisplayName_Values")
	                        }, {
	                            name: "Frequency",
	                            kind: VisualDataRoleKind.Measure,
	                            displayName: "Frequency"
	                        }
	                    ],
	                    dataViewMappings: [{
	                            conditions: [{ "Values": { min: 1, max: 1 }, "Frequency": { min: 0, max: 1 } }],
	                            categorical: {
	                                categories: {
	                                    bind: { to: "Values" },
	                                    dataReductionAlgorithm: { top: {} }
	                                },
	                                values: { for: { in: "Frequency" } }
	                            }
	                        }],
	                    sorting: {
	                        implicit: {
	                            clauses: [{ role: "Values", direction: 1 /*SortDirection.Ascending*/ }] //Constant SortDirection.Ascending currently is not supported on the msit
	                        }
	                    },
	                    objects: {
	                        general: {
	                            displayName: createDisplayNameGetter("Visual_General"),
	                            properties: {
	                                formatString: { type: { formatting: { formatString: true } } },
	                                bins: {
	                                    displayName: "Bins",
	                                    type: { numeric: true }
	                                },
	                                frequency: {
	                                    displayName: "Frequency",
	                                    type: { bool: true }
	                                }
	                            },
	                        },
	                        dataPoint: {
	                            displayName: createDisplayNameGetter("Visual_DataPoint"),
	                            properties: {
	                                fill: {
	                                    displayName: createDisplayNameGetter('Visual_Fill'),
	                                    type: { fill: { solid: { color: true } } }
	                                }
	                            }
	                        },
	                        xAxis: {
	                            displayName: 'X-Axis',
	                            properties: {
	                                show: {
	                                    displayName: "Show",
	                                    type: { bool: true },
	                                },
	                                axis: {
	                                    displayName: 'Axis',
	                                    type: { bool: true }
	                                },
	                                axisColor: {
	                                    displayName: "Color",
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                title: {
	                                    displayName: "Title",
	                                    type: { bool: true }
	                                },
	                                displayUnits: {
	                                    displayName: "Display Units",
	                                    type: { formatting: { labelDisplayUnits: true } }
	                                },
	                                precision: {
	                                    displayName: "Decimal Places",
	                                    type: { numeric: true },
	                                },
	                                style: {
	                                    displayName: "Style",
	                                    type: { enumeration: axisStyle.type }
	                                },
	                            }
	                        },
	                        yAxis: {
	                            displayName: 'Y-Axis',
	                            properties: {
	                                show: {
	                                    displayName: "Show",
	                                    type: { bool: true },
	                                },
	                                axis: {
	                                    displayName: 'yAxis',
	                                    type: { bool: true }
	                                },
	                                axisColor: {
	                                    displayName: "Color",
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                title: {
	                                    displayName: "Title",
	                                    type: { bool: true }
	                                },
	                                displayUnits: {
	                                    displayName: "Display Units",
	                                    type: { formatting: { labelDisplayUnits: true } }
	                                },
	                                precision: {
	                                    displayName: "Decimal Places",
	                                    type: { numeric: true },
	                                },
	                                style: {
	                                    displayName: "Style",
	                                    type: { enumeration: axisStyle.type }
	                                },
	                                start: {
	                                    displayName: "Start",
	                                    type: { numeric: true },
	                                    placeHolderText: "Start",
	                                    suppressFormatPainterCopy: true,
	                                },
	                                end: {
	                                    displayName: "End",
	                                    type: { numeric: true },
	                                    placeHolderText: "End",
	                                    suppressFormatPainterCopy: true,
	                                },
	                                position: {
	                                    displayName: "Position",
	                                    type: { enumeration: yAxisPosition.type },
	                                },
	                            }
	                        },
	                        labels: {
	                            displayName: "Data Labels",
	                            properties: {
	                                show: {
	                                    displayName: "Show",
	                                    type: { bool: true }
	                                },
	                                color: {
	                                    displayName: "Color",
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                displayUnits: {
	                                    displayName: "Display Units",
	                                    type: { formatting: { labelDisplayUnits: true } },
	                                    suppressFormatPainterCopy: true
	                                },
	                                precision: {
	                                    displayName: "Decimal Places",
	                                    type: { numeric: true },
	                                    suppressFormatPainterCopy: true
	                                },
	                                fontSize: {
	                                    displayName: "Text Size",
	                                    type: { formatting: { fontSize: true } }
	                                },
	                            },
	                        },
	                    }
	                };
	                return Histogram;
	            }());
	            samples.Histogram = Histogram;
	            /**
	             * HistogramAxisHelper based on AxisHelper (Visuals/common/axisHelper.ts).
	             */
	            var HistogramAxisHelper;
	            (function (HistogramAxisHelper) {
	                var NumberFormat = powerbi.NumberFormat;
	                /**
	                 * Default ranges are for when we have a field chosen for the axis,
	                 * but no values are returned by the query.
	                 */
	                HistogramAxisHelper.emptyDomain = [0, 0];
	                var InnerPaddingRatio = 0.2;
	                var TickLabelPadding = 2; // between text labels, used by AxisHelper
	                var MinOrdinalRectThickness = 20;
	                var ScalarTickLabelPadding = 3;
	                var MinTickCount = 2;
	                var DefaultBestTickCount = 3;
	                /**
	                 * Create a D3 axis including scale. Can be vertical or horizontal, and either datetime, numeric, or text.
	                 * @param options The properties used to create the axis.
	                 */
	                function createAxis(options) {
	                    var pixelSpan = options.pixelSpan, dataDomain = options.dataDomain, metaDataColumn = options.metaDataColumn, formatString = options.formatString, outerPadding = options.outerPadding || 0, isCategoryAxis = !!options.isCategoryAxis, isScalar = !!options.isScalar, isVertical = !!options.isVertical, useTickIntervalForDisplayUnits = !!options.useTickIntervalForDisplayUnits, // DEPRECATE: same meaning as isScalar?
	                    getValueFn = options.getValueFn, categoryThickness = options.categoryThickness, axisDisplayUnits = options.axisDisplayUnits, axisPrecision = options.axisPrecision, is100Pct = !!options.is100Pct, tickLabelPadding = options.tickLabelPadding || TickLabelPadding;
	                    var dataType = getCategoryValueType(metaDataColumn, isScalar);
	                    // Create the Scale
	                    var scaleResult = createScale(options);
	                    var scale = scaleResult.scale;
	                    var bestTickCount = scaleResult.bestTickCount;
	                    var scaleDomain = scale.domain();
	                    var isLogScaleAllowed = isLogScalePossible(dataDomain, dataType);
	                    // fix categoryThickness if scalar and the domain was adjusted when making the scale "nice"
	                    if (categoryThickness && isScalar && dataDomain && dataDomain.length === 2) {
	                        var oldSpan = dataDomain[1] - dataDomain[0];
	                        var newSpan = scaleDomain[1] - scaleDomain[0];
	                        if (oldSpan > 0 && newSpan > 0) {
	                            categoryThickness = categoryThickness * oldSpan / newSpan;
	                        }
	                    }
	                    // Prepare Tick Values for formatting
	                    var tickValues;
	                    if (isScalar && bestTickCount === 1) {
	                        tickValues = [dataDomain[0]];
	                    }
	                    else {
	                        var minTickInterval = isScalar ? getMinTickValueInterval(formatString, dataType, is100Pct) : undefined;
	                        tickValues = getRecommendedTickValues(bestTickCount, scale, dataType, isScalar, minTickInterval);
	                    }
	                    if (options.scaleType && options.scaleType === axisScale.log && isLogScaleAllowed) {
	                        tickValues = tickValues.filter(function (d) { return powerOfTen(d); });
	                    }
	                    var formatter = createFormatter(scaleDomain, dataDomain, dataType, isScalar, formatString, bestTickCount, tickValues, getValueFn, useTickIntervalForDisplayUnits, axisDisplayUnits, axisPrecision);
	                    // sets default orientation only, cartesianChart will fix y2 for comboChart
	                    // tickSize(pixelSpan) is used to create gridLines
	                    var axis = d3.svg.axis()
	                        .scale(scale)
	                        .tickSize(6, 0)
	                        .orient(isVertical ? 'left' : 'bottom')
	                        .ticks(bestTickCount)
	                        .tickValues(tickValues);
	                    var formattedTickValues = [];
	                    if (metaDataColumn)
	                        formattedTickValues = formatAxisTickValues(axis, tickValues, formatter, dataType, getValueFn);
	                    var xLabelMaxWidth;
	                    // Use category layout of labels if specified, otherwise use scalar layout of labels
	                    if (!isScalar && categoryThickness) {
	                        xLabelMaxWidth = Math.max(1, categoryThickness - tickLabelPadding * 2);
	                    }
	                    else {
	                        // When there are 0 or 1 ticks, then xLabelMaxWidth = pixelSpan       
	                        xLabelMaxWidth = tickValues.length > 1 ? getScalarLabelMaxWidth(scale, tickValues) : pixelSpan;
	                        xLabelMaxWidth = xLabelMaxWidth - ScalarTickLabelPadding * 2;
	                    }
	                    return {
	                        scale: scale,
	                        axis: axis,
	                        formatter: formatter,
	                        values: formattedTickValues,
	                        axisType: dataType,
	                        axisLabel: null,
	                        isCategoryAxis: isCategoryAxis,
	                        xLabelMaxWidth: xLabelMaxWidth,
	                        categoryThickness: categoryThickness,
	                        outerPadding: outerPadding,
	                        usingDefaultDomain: scaleResult.usingDefaultDomain,
	                        isLogScaleAllowed: isLogScaleAllowed,
	                        dataDomain: dataDomain,
	                    };
	                }
	                HistogramAxisHelper.createAxis = createAxis;
	                /**
	                 * Indicates whether the number is power of 10.
	                 */
	                function powerOfTen(d) {
	                    var value = Math.abs(d);
	                    // formula log2(Y)/log2(10) = log10(Y)
	                    // because double issues this won't return exact value
	                    // we need to ceil it to nearest number.
	                    var log10 = Math.log(value) / Math.LN10;
	                    log10 = Math.ceil(log10 - 1e-12);
	                    return value / Math.pow(10, log10) === 1;
	                }
	                HistogramAxisHelper.powerOfTen = powerOfTen;
	                function getScalarLabelMaxWidth(scale, tickValues) {
	                    debug.assertValue(scale, "scale");
	                    debug.assertNonEmpty(tickValues, "tickValues");
	                    // find the distance between two ticks. scalar ticks can be anywhere, such as:
	                    // |---50----------100--------|
	                    if (scale && !_.isEmpty(tickValues)) {
	                        return Math.abs(scale(tickValues[1]) - scale(tickValues[0]));
	                    }
	                    return 1;
	                }
	                function createFormatter(scaleDomain, dataDomain, dataType, isScalar, formatString, bestTickCount, tickValues, getValueFn, useTickIntervalForDisplayUnits, axisDisplayUnits, axisPrecision) {
	                    if (useTickIntervalForDisplayUnits === void 0) { useTickIntervalForDisplayUnits = false; }
	                    var formatter;
	                    if (dataType.dateTime) {
	                        if (isScalar) {
	                            var value = new Date(scaleDomain[0]);
	                            var value2 = new Date(scaleDomain[1]);
	                            // datetime with only one value needs to pass the same value
	                            // (from the original dataDomain value, not the adjusted scaleDomain)
	                            // so formatting works correctly.
	                            if (bestTickCount === 1)
	                                value = value2 = new Date(dataDomain[0]);
	                            // this will ignore the formatString and create one based on the smallest non-zero portion of the values supplied.
	                            formatter = valueFormatter.create({
	                                format: formatString,
	                                value: value,
	                                value2: value2,
	                                tickCount: bestTickCount,
	                            });
	                        }
	                        else {
	                            // Use the model formatString for ordinal datetime
	                            formatter = valueFormatter.createDefaultFormatter(formatString, true);
	                        }
	                    }
	                    else {
	                        if (getValueFn == null && !isScalar) {
	                            debug.assertFail('getValueFn must be supplied for ordinal tickValues');
	                        }
	                        if (useTickIntervalForDisplayUnits && isScalar && tickValues.length > 1) {
	                            var value1 = axisDisplayUnits ? axisDisplayUnits : tickValues[1] - tickValues[0];
	                            var options = {
	                                format: formatString,
	                                value: value1,
	                                value2: 0,
	                                allowFormatBeautification: true,
	                            };
	                            if (axisPrecision)
	                                options.precision = axisPrecision;
	                            else
	                                options.detectAxisPrecision = true;
	                            formatter = valueFormatter.create(options);
	                        }
	                        else {
	                            // do not use display units, just the basic value formatter
	                            // datetime is handled above, so we are ordinal and either boolean, numeric, or text.
	                            formatter = valueFormatter.createDefaultFormatter(formatString, true);
	                        }
	                    }
	                    return formatter;
	                }
	                HistogramAxisHelper.createFormatter = createFormatter;
	                function getMinTickValueInterval(formatString, columnType, is100Pct) {
	                    var isCustomFormat = formatString && !NumberFormat.isStandardFormat(formatString);
	                    if (isCustomFormat) {
	                        var precision = NumberFormat.getCustomFormatMetadata(formatString, true /*calculatePrecision*/).precision;
	                        if (formatString.indexOf('%') > -1)
	                            precision += 2; //percent values are multiplied by 100 during formatting
	                        return Math.pow(10, -precision);
	                    }
	                    else if (is100Pct)
	                        return 0.01;
	                    else if (columnType.integer)
	                        return 1;
	                    return 0;
	                }
	                HistogramAxisHelper.getMinTickValueInterval = getMinTickValueInterval;
	                /**
	                 * Format the linear tick labels or the category labels.
	                 */
	                function formatAxisTickValues(axis, tickValues, formatter, dataType, getValueFn) {
	                    var formattedTickValues = [];
	                    if (!getValueFn)
	                        getValueFn = function (data) { return data; };
	                    if (formatter) {
	                        axis.tickFormat(function (d) { return formatter.format(getValueFn(d, dataType)); });
	                        formattedTickValues = tickValues.map(function (d) { return formatter.format(getValueFn(d, dataType)); });
	                    }
	                    else {
	                        formattedTickValues = tickValues.map(function (d) { return getValueFn(d, dataType); });
	                    }
	                    return formattedTickValues;
	                }
	                function isLogScalePossible(domain, axisType) {
	                    if (domain == null)
	                        return false;
	                    if (isDateTime(axisType))
	                        return false;
	                    return (domain[0] > 0 && domain[1] > 0) || (domain[0] < 0 && domain[1] < 0); //doman must exclude 0
	                }
	                HistogramAxisHelper.isLogScalePossible = isLogScalePossible;
	                function isDateTime(type) {
	                    return !!(type && type.dateTime);
	                }
	                HistogramAxisHelper.isDateTime = isDateTime;
	                function getRecommendedTickValues(maxTicks, scale, axisType, isScalar, minTickInterval) {
	                    if (!isScalar || isOrdinalScale(scale)) {
	                        return getRecommendedTickValuesForAnOrdinalRange(maxTicks, scale.domain());
	                    }
	                    else if (isDateTime(axisType)) {
	                        return getRecommendedTickValuesForADateTimeRange(maxTicks, scale.domain());
	                    }
	                    return getRecommendedTickValuesForAQuantitativeRange(maxTicks, scale, minTickInterval);
	                }
	                HistogramAxisHelper.getRecommendedTickValues = getRecommendedTickValues;
	                function getRecommendedTickValuesForAnOrdinalRange(maxTicks, labels) {
	                    var tickLabels = [];
	                    // return no ticks in this case
	                    if (maxTicks <= 0)
	                        return tickLabels;
	                    var len = labels.length;
	                    if (maxTicks > len)
	                        return labels;
	                    for (var i = 0, step = Math.ceil(len / maxTicks); i < len; i += step) {
	                        tickLabels.push(labels[i]);
	                    }
	                    return tickLabels;
	                }
	                HistogramAxisHelper.getRecommendedTickValuesForAnOrdinalRange = getRecommendedTickValuesForAnOrdinalRange;
	                function getRecommendedTickValuesForAQuantitativeRange(maxTicks, scale, minInterval) {
	                    var tickLabels = [];
	                    //if maxticks is zero return none
	                    if (maxTicks === 0)
	                        return tickLabels;
	                    var quantitiveScale = scale;
	                    if (quantitiveScale.ticks) {
	                        tickLabels = quantitiveScale.ticks(maxTicks);
	                        if (tickLabels.length > maxTicks && maxTicks > 1)
	                            tickLabels = quantitiveScale.ticks(maxTicks - 1);
	                        if (tickLabels.length < MinTickCount) {
	                            tickLabels = quantitiveScale.ticks(maxTicks + 1);
	                        }
	                        tickLabels = createTrueZeroTickLabel(tickLabels);
	                        if (minInterval && tickLabels.length > 1) {
	                            var tickInterval = tickLabels[1] - tickLabels[0];
	                            while (tickInterval > 0 && tickInterval < minInterval) {
	                                for (var i = 1; i < tickLabels.length; i++) {
	                                    tickLabels.splice(i, 1);
	                                }
	                                tickInterval = tickInterval * 2;
	                            }
	                            // keep at least two labels - the loop above may trim all but one if we have odd # of tick labels and dynamic range < minInterval
	                            if (tickLabels.length === 1) {
	                                tickLabels.push(tickLabels[0] + minInterval);
	                            }
	                        }
	                        return tickLabels;
	                    }
	                    debug.assertFail('must pass a quantitative scale to this method');
	                    return tickLabels;
	                }
	                HistogramAxisHelper.getRecommendedTickValuesForAQuantitativeRange = getRecommendedTickValuesForAQuantitativeRange;
	                function getRecommendedTickValuesForADateTimeRange(maxTicks, dataDomain) {
	                    var tickLabels = [];
	                    if (dataDomain[0] === 0 && dataDomain[1] === 0)
	                        return [];
	                    var dateTimeTickLabels = DateTimeSequence.calculate(new Date(dataDomain[0]), new Date(dataDomain[1]), maxTicks).sequence;
	                    tickLabels = dateTimeTickLabels.map(function (d) { return d.getTime(); });
	                    tickLabels = ensureValuesInRange(tickLabels, dataDomain[0], dataDomain[1]);
	                    return tickLabels;
	                }
	                function isOrdinalScale(scale) {
	                    return typeof scale.invert === 'undefined';
	                }
	                HistogramAxisHelper.isOrdinalScale = isOrdinalScale;
	                /**
	                 * Gets the ValueType of a category column, defaults to Text if the type is not present.
	                 */
	                function getCategoryValueType(metadataColumn, isScalar) {
	                    if (metadataColumn && columnDataTypeHasValue(metadataColumn.type))
	                        return metadataColumn.type;
	                    if (isScalar) {
	                        return ValueType.fromDescriptor({ numeric: true });
	                    }
	                    return ValueType.fromDescriptor({ text: true });
	                }
	                HistogramAxisHelper.getCategoryValueType = getCategoryValueType;
	                function columnDataTypeHasValue(dataType) {
	                    return dataType && (dataType.bool || dataType.numeric || dataType.text || dataType.dateTime);
	                }
	                HistogramAxisHelper.columnDataTypeHasValue = columnDataTypeHasValue;
	                function createScale(options) {
	                    var pixelSpan = options.pixelSpan, dataDomain = options.dataDomain, metaDataColumn = options.metaDataColumn, outerPadding = options.outerPadding || 0, isScalar = !!options.isScalar, isVertical = !!options.isVertical, forcedTickCount = options.forcedTickCount, categoryThickness = options.categoryThickness, shouldClamp = !!options.shouldClamp, maxTickCount = options.maxTickCount, innerPaddingRatio = options.innerPaddingRatio || InnerPaddingRatio, minOrdinalRectThickness = options.minOrdinalRectThickness || MinOrdinalRectThickness;
	                    var dataType = getCategoryValueType(metaDataColumn, isScalar);
	                    var maxTicks = isVertical ? getRecommendedNumberOfTicksForYAxis(pixelSpan) : getRecommendedNumberOfTicksForXAxis(pixelSpan);
	                    if (maxTickCount &&
	                        maxTicks > maxTickCount)
	                        maxTicks = maxTickCount;
	                    var scalarDomain = dataDomain ? dataDomain.slice() : null;
	                    var bestTickCount = maxTicks;
	                    var scale;
	                    var usingDefaultDomain = false;
	                    if (dataDomain == null || (dataDomain.length === 2 && dataDomain[0] == null && dataDomain[1] == null) || (dataDomain.length !== 2 && isScalar)) {
	                        usingDefaultDomain = true;
	                        if (dataType.dateTime || !isOrdinal(dataType))
	                            dataDomain = HistogramAxisHelper.emptyDomain;
	                        else
	                            dataDomain = [];
	                        if (isOrdinal(dataType)) {
	                            scale = createOrdinalScale(pixelSpan, dataDomain, innerPaddingRatio, categoryThickness ? outerPadding / categoryThickness : 0);
	                        }
	                        else {
	                            scale = createNumericalScale(options.scaleType, pixelSpan, dataDomain, dataType, outerPadding, bestTickCount);
	                        }
	                    }
	                    else {
	                        if (isScalar && dataDomain.length > 0) {
	                            bestTickCount = forcedTickCount !== undefined
	                                ? (maxTicks !== 0 ? forcedTickCount : 0)
	                                : getBestNumberOfTicks(dataDomain[0], dataDomain[dataDomain.length - 1], [metaDataColumn], maxTicks, dataType.dateTime);
	                            var normalizedRange = normalizeLinearDomain({ min: dataDomain[0], max: dataDomain[dataDomain.length - 1] });
	                            scalarDomain = [normalizedRange.min, normalizedRange.max];
	                        }
	                        if (isScalar && dataType.numeric && !dataType.dateTime) {
	                            scale = createNumericalScale(options.scaleType, pixelSpan, scalarDomain, dataType, outerPadding, bestTickCount, shouldClamp);
	                        }
	                        else if (isScalar && dataType.dateTime) {
	                            // Use of a linear scale, instead of a D3.time.scale, is intentional since we want
	                            // to control the formatting of the time values, since d3's implementation isn't
	                            // in accordance to our design.
	                            //     scalarDomain: should already be in long-int time (via category.values[0].getTime())
	                            scale = createLinearScale(pixelSpan, scalarDomain, outerPadding, null, shouldClamp); // DO NOT PASS TICKCOUNT
	                        }
	                        else if (dataType.text || dataType.dateTime || dataType.numeric || dataType.bool) {
	                            scale = createOrdinalScale(pixelSpan, scalarDomain, innerPaddingRatio, categoryThickness ? outerPadding / categoryThickness : 0);
	                            bestTickCount = maxTicks === 0 ? 0
	                                : Math.min(scalarDomain.length, (pixelSpan - outerPadding * 2) / minOrdinalRectThickness);
	                        }
	                        else {
	                            debug.assertFail('unsupported dataType, something other than text or numeric');
	                        }
	                    }
	                    // vertical ordinal axis (e.g. categorical bar chart) does not need to reverse
	                    if (isVertical && isScalar) {
	                        scale.range(scale.range().reverse());
	                    }
	                    normalizeInfinityInScale(scale);
	                    return {
	                        scale: scale,
	                        bestTickCount: bestTickCount,
	                        usingDefaultDomain: usingDefaultDomain,
	                    };
	                }
	                HistogramAxisHelper.createScale = createScale;
	                function normalizeInfinityInScale(scale) {
	                    // When large values (eg Number.MAX_VALUE) are involved, a call to scale.nice occasionally
	                    // results in infinite values being included in the domain. To correct for that, we need to
	                    // re-normalize the domain now to not include infinities.
	                    var scaledDomain = scale.domain();
	                    for (var i = 0, len = scaledDomain.length; i < len; ++i) {
	                        if (scaledDomain[i] === Number.POSITIVE_INFINITY)
	                            scaledDomain[i] = Number.MAX_VALUE;
	                        else if (scaledDomain[i] === Number.NEGATIVE_INFINITY)
	                            scaledDomain[i] = -Number.MAX_VALUE;
	                    }
	                    scale.domain(scaledDomain);
	                }
	                HistogramAxisHelper.normalizeInfinityInScale = normalizeInfinityInScale;
	                function createOrdinalScale(pixelSpan, dataDomain, innerPaddingRatio, outerPaddingRatio) {
	                    debug.assert(outerPaddingRatio >= 0 && outerPaddingRatio < 4, 'outerPaddingRatio should be a value between zero and four');
	                    var scale = d3.scale.ordinal()
	                        .rangeBands([0, pixelSpan], innerPaddingRatio, outerPaddingRatio)
	                        .domain(dataDomain);
	                    return scale;
	                }
	                HistogramAxisHelper.createOrdinalScale = createOrdinalScale;
	                function normalizeLinearDomain(domain) {
	                    if (isNaN(domain.min) || isNaN(domain.max)) {
	                        domain.min = HistogramAxisHelper.emptyDomain[0];
	                        domain.max = HistogramAxisHelper.emptyDomain[1];
	                    }
	                    else if (domain.min === domain.max) {
	                        // d3 linear scale will give zero tickValues if max === min, so extend a little
	                        domain.min = domain.min < 0 ? domain.min * 1.2 : domain.min * 0.8;
	                        domain.max = domain.max < 0 ? domain.max * 0.8 : domain.max * 1.2;
	                    }
	                    else {
	                        // Check that min is very small and is a negligable portion of the whole domain.
	                        // (fix floating pt precision bugs)
	                        // sometimes highlight value math causes small negative numbers which makes the axis add
	                        // a large tick interval instead of just rendering at zero.
	                        if (Math.abs(domain.min) < 0.0001 && domain.min / (domain.max - domain.min) < 0.0001) {
	                            domain.min = 0;
	                        }
	                    }
	                    return domain;
	                }
	                //this function can return different scales e.g. log, linear
	                // NOTE: export only for testing, do not access directly
	                function createNumericalScale(axisScaleType, pixelSpan, dataDomain, dataType, outerPadding, niceCount, shouldClamp) {
	                    if (outerPadding === void 0) { outerPadding = 0; }
	                    if (axisScaleType === axisScale.log && isLogScalePossible(dataDomain, dataType)) {
	                        return createLogScale(pixelSpan, dataDomain, outerPadding, niceCount);
	                    }
	                    else {
	                        return createLinearScale(pixelSpan, dataDomain, outerPadding, niceCount, shouldClamp);
	                    }
	                }
	                HistogramAxisHelper.createNumericalScale = createNumericalScale;
	                function createLogScale(pixelSpan, dataDomain, outerPadding, niceCount) {
	                    if (outerPadding === void 0) { outerPadding = 0; }
	                    debug.assert(isLogScalePossible(dataDomain), "dataDomain cannot include 0");
	                    var scale = d3.scale.log()
	                        .range([outerPadding, pixelSpan - outerPadding])
	                        .domain([dataDomain[0], dataDomain[1]])
	                        .clamp(true);
	                    if (niceCount) {
	                        scale.nice(niceCount);
	                    }
	                    return scale;
	                }
	                // NOTE: export only for testing, do not access directly
	                function createLinearScale(pixelSpan, dataDomain, outerPadding, niceCount, shouldClamp) {
	                    if (outerPadding === void 0) { outerPadding = 0; }
	                    var scale = d3.scale.linear()
	                        .range([outerPadding, pixelSpan - outerPadding])
	                        .domain([dataDomain[0], dataDomain[1]])
	                        .clamp(shouldClamp);
	                    // .nice(undefined) still modifies the scale boundaries, and for datetime this messes things up.
	                    // we use millisecond ticks since epoch for datetime, so we don't want any "nice" with numbers like 17398203392.
	                    if (niceCount) {
	                        scale.nice(niceCount);
	                    }
	                    return scale;
	                }
	                HistogramAxisHelper.createLinearScale = createLinearScale;
	                function getRecommendedNumberOfTicksForXAxis(availableWidth) {
	                    if (availableWidth < 300)
	                        return 3;
	                    if (availableWidth < 500)
	                        return 5;
	                    return 8;
	                }
	                HistogramAxisHelper.getRecommendedNumberOfTicksForXAxis = getRecommendedNumberOfTicksForXAxis;
	                function getRecommendedNumberOfTicksForYAxis(availableWidth) {
	                    if (availableWidth < 150)
	                        return 3;
	                    if (availableWidth < 300)
	                        return 5;
	                    return 8;
	                }
	                HistogramAxisHelper.getRecommendedNumberOfTicksForYAxis = getRecommendedNumberOfTicksForYAxis;
	                function isOrdinal(type) {
	                    return !!(type && (type.text || type.bool || (type.misc && type.misc.barcode) || (type.geography && type.geography.postalCode)));
	                }
	                HistogramAxisHelper.isOrdinal = isOrdinal;
	                /**
	                 * Get the best number of ticks based on minimum value, maximum value,
	                 * measure metadata and max tick count.
	                 *
	                 * @param min The minimum of the data domain.
	                 * @param max The maximum of the data domain.
	                 * @param valuesMetadata The measure metadata array.
	                 * @param maxTickCount The max count of intervals.
	                 * @param isDateTime - flag to show single tick when min is equal to max.
	                 */
	                function getBestNumberOfTicks(min, max, valuesMetadata, maxTickCount, isDateTime) {
	                    debug.assert(maxTickCount >= 0, "maxTickCount must be greater or equal to zero");
	                    if (isNaN(min) || isNaN(max))
	                        return DefaultBestTickCount;
	                    debug.assert(min <= max, "min value needs to be less or equal to max value");
	                    if (maxTickCount <= 1 || (max <= 1 && min >= -1))
	                        return maxTickCount;
	                    if (min === max) {
	                        // datetime needs to only show one tick value in this case so formatting works correctly
	                        if (!!isDateTime)
	                            return 1;
	                        return DefaultBestTickCount;
	                    }
	                    if (hasNonIntegerData(valuesMetadata))
	                        return maxTickCount;
	                    // e.g. 5 - 2 + 1 = 4, => [2,3,4,5]
	                    return Math.min(max - min + 1, maxTickCount);
	                }
	                HistogramAxisHelper.getBestNumberOfTicks = getBestNumberOfTicks;
	                function ensureValuesInRange(values, min, max) {
	                    debug.assert(min <= max, "min must be less or equal to max");
	                    var filteredValues = values.filter(function (v) { return v >= min && v <= max; });
	                    if (filteredValues.length < 2)
	                        filteredValues = [min, max];
	                    return filteredValues;
	                }
	                HistogramAxisHelper.ensureValuesInRange = ensureValuesInRange;
	                function hasNonIntegerData(valuesMetadata) {
	                    for (var i = 0, len = valuesMetadata.length; i < len; i++) {
	                        var currentMetadata = valuesMetadata[i];
	                        if (currentMetadata && currentMetadata.type && !currentMetadata.type.integer) {
	                            return true;
	                        }
	                    }
	                    return false;
	                }
	                HistogramAxisHelper.hasNonIntegerData = hasNonIntegerData;
	                /**
	                 * Round out very small zero tick values (e.g. -1e-33 becomes 0).
	                 *
	                 * @param ticks Array of numbers (from d3.scale.ticks([maxTicks])).
	                 * @param epsilon Max ratio of calculated tick interval which we will recognize as zero.
	                 *
	                 * e.g.
	                 *     ticks = [-2, -1, 1e-10, 3, 4]; epsilon = 1e-5;
	                 *     closeZero = 1e-5 * | 2 - 1 | = 1e-5
	                 *     // Tick values <= 1e-5 replaced with 0
	                 *     return [-2, -1, 0, 3, 4];
	                 */
	                function createTrueZeroTickLabel(ticks, epsilon) {
	                    if (epsilon === void 0) { epsilon = 1e-5; }
	                    if (!ticks || ticks.length < 2)
	                        return ticks;
	                    var closeZero = epsilon * Math.abs(ticks[1] - ticks[0]);
	                    return ticks.map(function (tick) { return Math.abs(tick) <= closeZero ? 0 : tick; });
	                }
	            })(HistogramAxisHelper = samples.HistogramAxisHelper || (samples.HistogramAxisHelper = {}));
	        })(samples = visuals.samples || (visuals.samples = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 50 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../../../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var samples;
	        (function (samples) {
	            var getAnimationDuration = powerbi.visuals.AnimatorCommon.GetAnimationDuration;
	            var CreateClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
	            var AxisScale = powerbi.visuals.axisScale;
	            var PixelConverter = jsCommon.PixelConverter;
	            var createEnumType = powerbi.createEnumType;
	            var SelectionId = powerbi.visuals.SelectionId;
	            var VisualDataRoleKind = powerbi.VisualDataRoleKind;
	            var dataLabelUtils = powerbi.visuals.dataLabelUtils;
	            var LegendData = powerbi.visuals.LegendData;
	            var DataViewObjects = powerbi.DataViewObjects;
	            var SelectionIdBuilder = powerbi.visuals.SelectionIdBuilder;
	            var createInteractivityService = powerbi.visuals.createInteractivityService;
	            var appendClearCatcher = powerbi.visuals.appendClearCatcher;
	            var SVGUtil = powerbi.visuals.SVGUtil;
	            var ObjectEnumerationBuilder = powerbi.visuals.ObjectEnumerationBuilder;
	            var DataViewObject = powerbi.DataViewObject;
	            var valueFormatter = powerbi.visuals.valueFormatter;
	            var TooltipManager = powerbi.visuals.TooltipManager;
	            var AxisHelper = powerbi.visuals.AxisHelper;
	            var TextMeasurementService = powerbi.TextMeasurementService;
	            var LabelTextProperties = powerbi.visuals.dataLabelUtils.LabelTextProperties;
	            var MaxXAxisHeight = 40;
	            var DefaultRadius = 5;
	            var DefaultStrokeWidth = 1;
	            var DefaultDataPointColor = "#00B8AA";
	            var MinPrecision = 0;
	            var MaxPrecision = 17;
	            var DotPlotLabelsOrientation;
	            (function (DotPlotLabelsOrientation) {
	                (function (Orientation) {
	                    Orientation[Orientation["Horizontal"] = 0] = "Horizontal";
	                    Orientation[Orientation["Vertical"] = 1] = "Vertical";
	                })(DotPlotLabelsOrientation.Orientation || (DotPlotLabelsOrientation.Orientation = {}));
	                var Orientation = DotPlotLabelsOrientation.Orientation;
	                ;
	                DotPlotLabelsOrientation.type = createEnumType([
	                    { value: Orientation[0], displayName: "Horizontal" },
	                    { value: Orientation[1], displayName: "Vertical" }
	                ]);
	            })(DotPlotLabelsOrientation = samples.DotPlotLabelsOrientation || (samples.DotPlotLabelsOrientation = {}));
	            samples.DotPlotProperties = {
	                general: {
	                    formatString: {
	                        objectName: "general",
	                        propertyName: "formatString"
	                    }
	                },
	                labels: {
	                    show: {
	                        objectName: "labels",
	                        propertyName: "show"
	                    },
	                    fontSize: {
	                        objectName: "labels",
	                        propertyName: "fontSize"
	                    },
	                    labelPrecision: {
	                        objectName: "labels",
	                        propertyName: "labelPrecision"
	                    },
	                    labelDisplayUnits: {
	                        objectName: "labels",
	                        propertyName: "labelDisplayUnits"
	                    },
	                    labelColor: {
	                        objectName: "labels",
	                        propertyName: "color"
	                    },
	                    orientation: {
	                        objectName: "labels",
	                        propertyName: "orientation"
	                    }
	                },
	                dataPoint: {
	                    fill: {
	                        objectName: "dataPoint",
	                        propertyName: "fill"
	                    }
	                },
	                categories: {
	                    show: {
	                        objectName: "categories",
	                        propertyName: "show"
	                    },
	                    fontColor: {
	                        objectName: "categories",
	                        propertyName: "fontColor"
	                    },
	                    fontSize: {
	                        objectName: "categories",
	                        propertyName: "fontSize"
	                    }
	                },
	                categoryAxis: {
	                    show: {
	                        objectName: "categoryAxis",
	                        propertyName: "show"
	                    },
	                    showAxisTitle: {
	                        objectName: "categoryAxis",
	                        propertyName: "showAxisTitle"
	                    },
	                    labelColor: {
	                        objectName: "categoryAxis",
	                        propertyName: "labelColor"
	                    }
	                }
	            };
	            var DotPlot = (function () {
	                function DotPlot(options) {
	                    this.DefaultMargin = {
	                        top: 10,
	                        bottom: 10,
	                        right: 20,
	                        left: 20
	                    };
	                    this.durationAnimations = 200;
	                    this.scaleType = AxisScale.linear;
	                    this.textProperties = {
	                        fontFamily: "wf_segoe-ui_normal",
	                        fontSize: PixelConverter.toString(9),
	                    };
	                    this.dotPlotSelectors = {
	                        scrollableContainer: CreateClassAndSelector("dotPlotScrollableContainer"),
	                        svgPlotSelector: CreateClassAndSelector("dotplot"),
	                        plotSelector: CreateClassAndSelector("dotplotSelector"),
	                        plotGroupSelector: CreateClassAndSelector("dotplotGroup"),
	                        axisSelector: CreateClassAndSelector("axisGraphicsContext"),
	                        xAxisSelector: CreateClassAndSelector("x axis"),
	                        circleSeletor: CreateClassAndSelector("circleSelector"),
	                    };
	                    this.DefaultDotPlotSettings = {
	                        labelSettings: {
	                            show: true,
	                            precision: 2,
	                            fontSize: dataLabelUtils.DefaultFontSizeInPt,
	                            displayUnits: 0,
	                            labelColor: dataLabelUtils.defaultLabelColor,
	                        },
	                        categorySettings: {
	                            show: true,
	                            fontColor: LegendData.DefaultLegendLabelFillColor
	                        },
	                        defaultDataPointColor: DefaultDataPointColor,
	                        categoryAxisSettings: {
	                            show: true,
	                            showAxisTitle: true,
	                            labelColor: { solid: { color: dataLabelUtils.defaultLabelColor } }
	                        },
	                        labelOrientation: DotPlotLabelsOrientation.Orientation.Horizontal,
	                        labelTextMaxSize: 0,
	                        xAxisLabelTexMaxSize: 0
	                    };
	                    if (options) {
	                        if (options.svg) {
	                            this.svg = options.svg;
	                        }
	                        if (options.animator) {
	                            this.animator = options.animator;
	                        }
	                        this.radius = options.radius || DefaultRadius;
	                        this.strokeWidth = options.strokeWidth || DefaultStrokeWidth;
	                    }
	                }
	                DotPlot.getTooltipData = function (value) {
	                    return [{
	                            displayName: "Value",
	                            value: value.toString()
	                        }];
	                };
	                DotPlot.converter = function (dataView, objects, scale, defaultMargin, defaultSetting, colors, viewport, radius) {
	                    var values = dataView.categorical.values, dataPointsGroup = [], displayName = dataView.categorical.categories[0].source.displayName, settings, defaultColor = DataViewObjects.getFillColor(objects, samples.DotPlotProperties.dataPoint.fill, colors.getColorByIndex(0).value);
	                    var categories = dataView.categorical.categories[0].values.map(function (x, i) { return {
	                        value: x,
	                        selectionId: SelectionId.createWithId(dataView.categorical.categories[0].identity[i])
	                    }; });
	                    settings = {
	                        categorySettings: this.getCategorySettings(objects, defaultSetting),
	                        defaultDataPointColor: defaultColor,
	                        labelSettings: this.parseSettings(objects, defaultSetting),
	                        categoryAxisSettings: this.parseCategoryAxisSettings(objects, defaultSetting),
	                        labelOrientation: DotPlotLabelsOrientation.Orientation.Horizontal,
	                        labelTextMaxSize: 0,
	                        xAxisLabelTexMaxSize: 0
	                    };
	                    var textPropertiesCat = {
	                        text: "W",
	                        fontFamily: "Segoe UI",
	                        fontSize: settings.labelSettings.fontSize + "px"
	                    };
	                    var maxValue = 0;
	                    for (var valueId in values) {
	                        var value = values[valueId];
	                        var max = _.max(value.values);
	                        maxValue = max > maxValue ? max : maxValue;
	                    }
	                    var maxXAxisLabelValue = 0;
	                    if (settings.labelOrientation === DotPlotLabelsOrientation.Orientation.Vertical)
	                        for (var catId in categories) {
	                            var category = categories[catId], lengthOfValue = 0;
	                            lengthOfValue = category && category.value
	                                ? category.value.length
	                                : lengthOfValue;
	                            category.textWidth = TextMeasurementService.measureSvgTextWidth(textPropertiesCat) * lengthOfValue;
	                            maxXAxisLabelValue = lengthOfValue > maxXAxisLabelValue
	                                ? lengthOfValue
	                                : maxXAxisLabelValue;
	                        }
	                    settings.labelTextMaxSize = TextMeasurementService.measureSvgTextWidth(textPropertiesCat) * (maxValue + " ").length;
	                    settings.xAxisLabelTexMaxSize = TextMeasurementService.measureSvgTextWidth(textPropertiesCat) * maxXAxisLabelValue;
	                    if (settings.labelOrientation === DotPlotLabelsOrientation.Orientation.Vertical)
	                        MaxXAxisHeight = settings.xAxisLabelTexMaxSize;
	                    var categoryColumn = dataView.categorical.categories[0], diameter = 2 * radius + 1, dotsTotalHeight = viewport.height - radius - MaxXAxisHeight - (settings.labelOrientation === DotPlotLabelsOrientation.Orientation.Vertical ? settings.labelTextMaxSize : 0), maxDots = Math.floor((dotsTotalHeight - defaultMargin.top) / diameter) - 1, fontSizeInPx = PixelConverter.fromPoint(settings.labelSettings.fontSize);
	                    var yScale = d3.scale.linear()
	                        .domain([0, maxDots])
	                        .range([
	                        dotsTotalHeight - defaultMargin.bottom,
	                        defaultMargin.top + defaultMargin.bottom
	                    ]);
	                    for (var valueId in values) {
	                        var value = values[valueId];
	                        var min = _.min(value.values), max = _.max(value.values), color = DataViewObjects.getFillColor(objects, samples.DotPlotProperties.dataPoint.fill, colors.getColorByIndex(0).value), length = value && value.values ? value.values.length : 0, minDots = min / (max / maxDots), dotsScale = d3.scale.log()
	                            .domain([min < 0 ? 1 : min, max])
	                            .range([minDots <= 0 ? 1 : minDots, maxDots])
	                            .clamp(true);
	                        for (var k = 0; k < length; k++) {
	                            var y = dotsScale(value.values[k]), dataPoints = [];
	                            for (var level = 0; level < y; level++) {
	                                dataPoints.push({
	                                    x: scale(categories[k].value) + scale.rangeBand() / 2,
	                                    y: yScale(level) + (settings.labelOrientation === DotPlotLabelsOrientation.Orientation.Vertical ? settings.labelTextMaxSize : 0),
	                                    tooltipInfo: DotPlot.getTooltipData(value.values[k].toFixed(settings.labelSettings.precision))
	                                });
	                            }
	                            var categorySelectionId = SelectionIdBuilder.builder().withCategory(categoryColumn, k).createSelectionId(), tooltipInfo = DotPlot.getTooltipData(value.values[k].toFixed(settings.labelSettings.precision));
	                            dataPointsGroup.push({
	                                selected: false,
	                                value: value.values[k],
	                                label: value.values[k],
	                                color: color,
	                                identity: categorySelectionId,
	                                tooltipInfo: tooltipInfo,
	                                dataPoints: dataPoints,
	                                labelFontSize: fontSizeInPx
	                            });
	                        }
	                    }
	                    return {
	                        dataPoints: dataPointsGroup,
	                        values: dataView.categorical.categories[0].values,
	                        displayName: displayName,
	                        categories: categories,
	                        settings: settings
	                    };
	                };
	                DotPlot.prototype.init = function (options) {
	                    var element = options.element;
	                    this.behavior = new DotplotBehavior();
	                    this.interactivityService = createInteractivityService(options.host);
	                    this.radius = DefaultRadius;
	                    this.strokeWidth = DefaultStrokeWidth;
	                    this.colors = options.style.colorPalette.dataColors;
	                    this.divContainer = d3.select(element.get(0))
	                        .append("div")
	                        .classed(this.dotPlotSelectors.scrollableContainer.class, true);
	                    this.svg = this.divContainer
	                        .append("svg")
	                        .classed(this.dotPlotSelectors.svgPlotSelector.class, true);
	                    this.clearCatcher = appendClearCatcher(this.svg);
	                    var axisGraphicsContext = this.svg
	                        .append("g")
	                        .classed(this.dotPlotSelectors.axisSelector.class, true);
	                    this.dotPlot = this.svg
	                        .append("g")
	                        .classed(this.dotPlotSelectors.plotSelector.class, true);
	                    this.xAxis = axisGraphicsContext
	                        .append("g")
	                        .classed(this.dotPlotSelectors.xAxisSelector.class, true);
	                };
	                DotPlot.prototype.update = function (options) {
	                    if (!options.dataViews || !options.dataViews[0])
	                        return;
	                    this.durationAnimations = getAnimationDuration(this.animator, options.suppressAnimations);
	                    var dataView = this.dataView = options.dataViews[0], viewport = options.viewport;
	                    if (!dataView ||
	                        !dataView.categorical ||
	                        !dataView.categorical.values ||
	                        dataView.categorical.values.length < 1 ||
	                        !dataView.categorical ||
	                        !dataView.categorical.categories ||
	                        !dataView.categorical.categories[0]) {
	                        this.clearData();
	                        return;
	                    }
	                    var vals = dataView.categorical.categories[0].values, viewPortWidth = viewport.width;
	                    if (vals.length * this.radius > viewPortWidth) {
	                        viewPortWidth = vals.length * (this.radius * 2 + 2);
	                        this.svg.style({
	                            height: PixelConverter.toString(viewport.height),
	                            width: PixelConverter.toString(vals.length * (this.radius * 2 + 2))
	                        });
	                    }
	                    else {
	                        this.svg.style({
	                            height: PixelConverter.toString(viewport.height),
	                            width: PixelConverter.toString(viewport.width)
	                        });
	                    }
	                    var viewportIn = {
	                        height: viewport.height - this.DefaultMargin.top - this.DefaultMargin.bottom,
	                        width: (vals.length * this.radius > viewport.width ? vals.length * (this.radius * 2 + 2) : viewport.width - this.DefaultMargin.left)
	                    };
	                    this.viewportIn = viewportIn;
	                    this.divContainer.style({
	                        width: viewport.width + "px",
	                        height: viewport.height + "px"
	                    });
	                    var objects = DotPlot.getObjectsFromDataView(dataView), categoryAxisSettings = DotPlot.parseCategoryAxisSettings(objects, this.DefaultDotPlotSettings);
	                    var xAxisProperties = this.calculateAxes(viewportIn, categoryAxisSettings, this.textProperties, objects, false);
	                    var data = DotPlot.converter(dataView, objects, xAxisProperties.scale, this.DefaultMargin, this.DefaultDotPlotSettings, this.colors, this.viewportIn, this.radius);
	                    this.dotPlotDataView = data;
	                    var dataPoints = data.dataPoints;
	                    if (this.interactivityService) {
	                        this.interactivityService.applySelectionStateToData(dataPoints);
	                    }
	                    this.renderAxis(viewportIn.height - MaxXAxisHeight, viewportIn, xAxisProperties, categoryAxisSettings, data, this.durationAnimations);
	                    this.drawDotPlot(dataPoints, data.settings);
	                    var dataLabelsSettings = data.settings.labelSettings;
	                    if (dataLabelsSettings.show) {
	                        var layout = this.getDotPlotLabelsLayout(dataLabelsSettings, viewportIn);
	                        var labels = dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPoints, this.svg, layout, viewportIn, !options.suppressAnimations, this.durationAnimations);
	                        if (labels) {
	                            labels.attr("transform", function (dataGroup) {
	                                var size = dataGroup.size;
	                                if (data.settings.labelOrientation === DotPlotLabelsOrientation.Orientation.Vertical) {
	                                    var px = dataGroup.anchorPoint.x, py = dataGroup.anchorPoint.y, dx, dy;
	                                    dx = size.width / DotPlot.DataLabelXOffset + size.height * DotPlot.DataLabelXOffsetIndex;
	                                    dy = size.height + size.height / DotPlot.DataLabelYOffset;
	                                    return SVGUtil.translateAndRotate(dx, -dy, px, py, DotPlot.DataLabelAngle);
	                                }
	                                else {
	                                    var dx, dy;
	                                    dx = size.width / DotPlot.DataLabelXOffset;
	                                    dy = size.height / DotPlot.DataLabelYOffset;
	                                    return SVGUtil.translate(dx, dy);
	                                }
	                            });
	                        }
	                    }
	                    else {
	                        dataLabelUtils.cleanDataLabels(this.svg);
	                    }
	                };
	                DotPlot.prototype.enumerateObjectInstances = function (options) {
	                    var enumeration = new ObjectEnumerationBuilder();
	                    switch (options.objectName) {
	                        case "dataPoint":
	                            this.enumerateDataPoints(enumeration, this.dataView);
	                            break;
	                        case "labels":
	                            this.enumerateDataLabels(enumeration, this.dataView);
	                            break;
	                        case "categories":
	                            this.enumerateCategories(enumeration, this.dataView);
	                            break;
	                        case "categoryAxis":
	                            this.enumerateCategoryAxisValues(enumeration, this.dataView);
	                            break;
	                    }
	                    return enumeration.complete();
	                };
	                DotPlot.prototype.enumerateCategoryAxisValues = function (enumeration, dataView) {
	                    var objects = dataView && dataView.metadata
	                        ? dataView.metadata.objects
	                        : undefined;
	                    enumeration.pushInstance({
	                        objectName: "categoryAxis",
	                        displayName: "Category Axis",
	                        selector: null,
	                        properties: {
	                            show: DataViewObjects.getValue(objects, samples.DotPlotProperties.categoryAxis.show, this.DefaultDotPlotSettings.categoryAxisSettings.show),
	                            showAxisTitle: DataViewObjects.getValue(objects, samples.DotPlotProperties.categoryAxis.showAxisTitle, this.DefaultDotPlotSettings.categoryAxisSettings.showAxisTitle),
	                            labelColor: objects && objects["categoryAxis"] && objects["categoryAxis"]["labelColor"] ?
	                                objects["categoryAxis"]["labelColor"] :
	                                this.DefaultDotPlotSettings.categoryAxisSettings.labelColor
	                        }
	                    });
	                };
	                DotPlot.getObjectsFromDataView = function (dataView) {
	                    if (!dataView ||
	                        !dataView.metadata ||
	                        !dataView.metadata.columns ||
	                        !dataView.metadata.objects) {
	                        return null;
	                    }
	                    return dataView.metadata.objects;
	                };
	                DotPlot.parseSettings = function (objects, defaultDotPlotSettings) {
	                    var precision = this.getPrecision(objects, defaultDotPlotSettings);
	                    return {
	                        show: DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.show, defaultDotPlotSettings.labelSettings.show),
	                        precision: precision,
	                        fontSize: DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.fontSize, defaultDotPlotSettings.labelSettings.fontSize),
	                        displayUnits: DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.labelDisplayUnits, defaultDotPlotSettings.labelSettings.displayUnits),
	                        labelColor: DataViewObjects.getFillColor(objects, samples.DotPlotProperties.labels.labelColor, defaultDotPlotSettings.labelSettings.labelColor),
	                    };
	                };
	                DotPlot.parseCategoryAxisSettings = function (objects, defaultDotPlotSettings) {
	                    return {
	                        show: DataViewObjects.getValue(objects, samples.DotPlotProperties.categoryAxis.show, defaultDotPlotSettings.categoryAxisSettings.show),
	                        showAxisTitle: DataViewObjects.getValue(objects, samples.DotPlotProperties.categoryAxis.showAxisTitle, defaultDotPlotSettings.categoryAxisSettings.showAxisTitle),
	                        labelColor: objects && objects["categoryAxis"] && objects["categoryAxis"]["labelColor"]
	                            ? objects["categoryAxis"]["labelColor"]
	                            : defaultDotPlotSettings.categoryAxisSettings.labelColor
	                    };
	                };
	                DotPlot.getCategorySettings = function (objects, defaultDotPlotSettings) {
	                    return {
	                        show: DataViewObject.getValue(objects, samples.DotPlotProperties.categories.show, defaultDotPlotSettings.categorySettings.show),
	                        fontColor: DataViewObjects.getFillColor(objects, samples.DotPlotProperties.categories.fontColor, defaultDotPlotSettings.categorySettings.fontColor)
	                    };
	                };
	                DotPlot.getPrecision = function (objects, defaultDotPlotSettings) {
	                    var precision = DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.labelPrecision, defaultDotPlotSettings.labelSettings.precision);
	                    if (precision <= MinPrecision)
	                        return MinPrecision;
	                    if (precision >= MaxPrecision)
	                        return MaxPrecision;
	                    return precision;
	                };
	                DotPlot.prototype.drawDotPlot = function (data, setting) {
	                    var selection = this.dotPlot.selectAll(this.dotPlotSelectors.plotGroupSelector.selector).data(data);
	                    var hasSelection = this.interactivityService && this.interactivityService.hasSelection();
	                    selection
	                        .enter()
	                        .append("g")
	                        .attr({
	                        stroke: "black",
	                        "stroke-width": this.strokeWidth
	                    }).
	                        style("fill-opacity", function (item) { return dotPlotUtils.getFillOpacity(item.selected, item.highlight, hasSelection, false); }).
	                        classed(this.dotPlotSelectors.plotGroupSelector.class, true);
	                    var circleSelection = selection.selectAll(this.dotPlotSelectors.circleSeletor.selector).data(function (d) { return d.dataPoints; });
	                    circleSelection
	                        .enter()
	                        .append("circle")
	                        .classed(this.dotPlotSelectors.circleSeletor.class, true);
	                    circleSelection.attr({
	                        cx: function (point) { return point.x; },
	                        cy: function (point) { return point.y; },
	                        r: this.radius,
	                        fill: setting.defaultDataPointColor
	                    });
	                    this.renderTooltip(selection);
	                    circleSelection
	                        .exit()
	                        .remove();
	                    selection
	                        .exit()
	                        .remove();
	                    var interactivityService = this.interactivityService;
	                    if (interactivityService) {
	                        interactivityService.applySelectionStateToData(data);
	                        var behaviorOptions = {
	                            columns: selection,
	                            clearCatcher: this.clearCatcher,
	                            interactivityService: this.interactivityService,
	                        };
	                        interactivityService.bind(data, this.behavior, behaviorOptions);
	                    }
	                };
	                DotPlot.prototype.getDotPlotLabelsLayout = function (labelSettings, viewport) {
	                    var fontSizeInPx = PixelConverter.fromPoint(labelSettings.fontSize), fontFamily = LabelTextProperties.fontFamily;
	                    var formatter = valueFormatter.create({
	                        format: valueFormatter.getFormatString(this.dataView.categorical.categories[0].source, samples.DotPlotProperties.general.formatString),
	                        precision: labelSettings.precision,
	                        value: labelSettings.displayUnits
	                    });
	                    return {
	                        labelText: function (d) {
	                            return dataLabelUtils.getLabelFormattedText({
	                                label: formatter.format(d.label),
	                                fontSize: labelSettings.fontSize,
	                                maxWidth: viewport.width,
	                            });
	                        },
	                        labelLayout: {
	                            x: function (dataGroup) {
	                                var x, dx;
	                                x = dataGroup.dataPoints[dataGroup.dataPoints.length - 1].x;
	                                dx = dataGroup.size.width / DotPlot.DataLabelXOffset;
	                                return x - dx;
	                            },
	                            y: function (dataGroup) {
	                                var y, dy;
	                                y = dataGroup.dataPoints[dataGroup.dataPoints.length - 1].y;
	                                dy = dataGroup.size.height;
	                                return y - dy;
	                            }
	                        },
	                        filter: function (dataGroup) {
	                            return !!(dataGroup && dataGroup.dataPoints && dataGroup.dataPoints[dataGroup.dataPoints.length - 1]);
	                        },
	                        style: {
	                            "fill": labelSettings.labelColor,
	                            "font-size": fontSizeInPx,
	                            "font-family": fontFamily
	                        },
	                    };
	                };
	                DotPlot.prototype.enumerateDataLabels = function (enumeration, dataView) {
	                    var objects = dataView && dataView.metadata ? dataView.metadata.objects : undefined;
	                    enumeration.pushInstance({
	                        objectName: "labels",
	                        displayName: "Labels",
	                        selector: null,
	                        properties: {
	                            show: DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.show, this.DefaultDotPlotSettings.labelSettings.show),
	                            fontSize: DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.fontSize, this.DefaultDotPlotSettings.labelSettings.fontSize),
	                            labelPrecision: DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.labelPrecision, this.DefaultDotPlotSettings.labelSettings.precision),
	                            labelDisplayUnits: DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.labelDisplayUnits, this.DefaultDotPlotSettings.labelSettings.displayUnits),
	                            color: DataViewObjects.getFillColor(objects, samples.DotPlotProperties.labels.labelColor, this.DefaultDotPlotSettings.labelSettings.labelColor),
	                            orientation: DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.orientation, DotPlotLabelsOrientation.Orientation.Horizontal)
	                        }
	                    });
	                };
	                DotPlot.prototype.enumerateDataPoints = function (enumeration, dataView) {
	                    var objects = dataView && dataView.metadata ? dataView.metadata.objects : undefined;
	                    var dataPointColor = DataViewObjects.getFillColor(objects, samples.DotPlotProperties.dataPoint.fill, this.DefaultDotPlotSettings.defaultDataPointColor);
	                    enumeration.pushInstance({
	                        objectName: "dataPoint",
	                        displayName: "Data Points",
	                        selector: null,
	                        properties: {
	                            fill: { solid: { color: dataPointColor } }
	                        }
	                    });
	                };
	                DotPlot.prototype.enumerateCategories = function (enumeration, dataView) {
	                    var objects = dataView && dataView.metadata ? dataView.metadata.objects : undefined;
	                    var categoriesSettings = DotPlot.getCategorySettings(objects, this.DefaultDotPlotSettings);
	                    enumeration.pushInstance({
	                        objectName: "categories",
	                        displayName: "Categories",
	                        selector: null,
	                        properties: {
	                            show: categoriesSettings.show,
	                            fontSize: categoriesSettings.fontSize,
	                            fontColor: categoriesSettings.fontColor
	                        }
	                    });
	                };
	                DotPlot.prototype.clearData = function () {
	                    this.dotPlot.selectAll("*").remove();
	                    this.xAxis.selectAll("*").remove();
	                    dataLabelUtils.cleanDataLabels(this.svg);
	                };
	                DotPlot.prototype.renderTooltip = function (selection) {
	                    TooltipManager.addTooltip(selection, function (tooltipEvent) {
	                        return tooltipEvent.data.tooltipInfo;
	                    });
	                };
	                DotPlot.prototype.calculateAxes = function (viewportIn, categoryAxisSettings, textProperties, objects, scrollbarVisible) {
	                    var category = this.dataView.categorical.categories && this.dataView.categorical.categories.length > 0
	                        ? this.dataView.categorical.categories[0]
	                        : {
	                            source: undefined,
	                            values: [valueFormatter.format(null)],
	                            identity: undefined,
	                        };
	                    var visualOptions = {
	                        viewport: viewportIn,
	                        margin: this.DefaultMargin,
	                        forcedXDomain: this.dataView.categorical.categories[0].values,
	                        forceMerge: false,
	                        showCategoryAxisLabel: false,
	                        showValueAxisLabel: false,
	                        categoryAxisScaleType: this.scaleType,
	                        valueAxisScaleType: null,
	                        valueAxisDisplayUnits: 0,
	                        categoryAxisDisplayUnits: 0,
	                        trimOrdinalDataOnOverflow: false,
	                    };
	                    var width = viewportIn.width;
	                    var axes = this.calculateAxesProperties(viewportIn, categoryAxisSettings, visualOptions, category.source, objects);
	                    axes.willLabelsFit = AxisHelper.LabelLayoutStrategy.willLabelsFit(axes, width, TextMeasurementService.measureSvgTextWidth, textProperties);
	                    var orientation = ((DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.orientation, DotPlotLabelsOrientation.Orientation.Horizontal) + "") === "Vertical" ? DotPlotLabelsOrientation.Orientation.Vertical : DotPlotLabelsOrientation.Orientation.Horizontal);
	                    // If labels do not fit and we are not scrolling, try word breaking
	                    if (orientation !== DotPlotLabelsOrientation.Orientation.Vertical)
	                        axes.willLabelsWordBreak = (!axes.willLabelsFit && !scrollbarVisible) && AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(axes, this.DefaultMargin, width, TextMeasurementService.measureSvgTextWidth, TextMeasurementService.estimateSvgTextHeight, TextMeasurementService.getTailoredTextOrDefault, textProperties);
	                    else
	                        axes.willLabelsWordBreak = false;
	                    return axes;
	                };
	                DotPlot.prototype.calculateAxesProperties = function (viewportIn, categoryAxisSettings, options, metaDataColumn, objects) {
	                    var xAxisProperties = AxisHelper.createAxis({
	                        pixelSpan: viewportIn.width,
	                        dataDomain: options.forcedXDomain,
	                        metaDataColumn: metaDataColumn,
	                        formatString: valueFormatter.getFormatString(metaDataColumn, samples.DotPlotProperties.general.formatString),
	                        outerPadding: 0,
	                        isScalar: false,
	                        isVertical: false,
	                        forcedTickCount: options.forcedTickCount,
	                        useTickIntervalForDisplayUnits: true,
	                        isCategoryAxis: true,
	                        getValueFn: function (index, type) { return categoryAxisSettings.show ? index : ""; },
	                        scaleType: options.categoryAxisScaleType,
	                        axisDisplayUnits: options.categoryAxisDisplayUnits,
	                    });
	                    if (categoryAxisSettings.show)
	                        // Should handle the label, units of the label and the axis style
	                        xAxisProperties.axisLabel = AxisHelper.createAxisLabel(objects, "", ""); //axes.x.axisLabel);
	                    return xAxisProperties;
	                };
	                DotPlot.prototype.renderAxis = function (height, viewportIn, xAxisProperties, categoryAxisSettings, data, duration) {
	                    this.xAxis.attr({
	                        transform: SVGUtil.translate(0, height)
	                    });
	                    var xAxis = xAxisProperties.axis;
	                    xAxis.orient("bottom");
	                    this.xAxis
	                        .transition()
	                        .duration(duration)
	                        .call(xAxis)
	                        .call(DotPlot.setAxisLabelColor, categoryAxisSettings.labelColor);
	                    var xAxisTicks = this.xAxis.selectAll(".tick text");
	                    xAxisTicks.data(xAxisProperties.values);
	                    if (data.settings.labelOrientation !== DotPlotLabelsOrientation.Orientation.Vertical) {
	                        xAxisTicks.call(AxisHelper.LabelLayoutStrategy.clip, xAxisProperties.xLabelMaxWidth, TextMeasurementService.svgEllipsis);
	                    }
	                    if (data.settings.labelOrientation === DotPlotLabelsOrientation.Orientation.Vertical) {
	                        xAxisTicks.attr("transform", function (d) {
	                            var textHeight = 12;
	                            var textWidth = TextMeasurementService.measureSvgTextWidth(d);
	                            return SVGUtil.translateAndRotate(textHeight / 2 - 2 * textHeight, textWidth + 20, 0, 0, -90);
	                        });
	                    }
	                    else {
	                        xAxisTicks.attr("transform", null);
	                    }
	                    xAxisTicks
	                        .append("title")
	                        .text(function (d) { return d; });
	                    this.xAxis
	                        .selectAll("line")
	                        .style("opacity", data.settings.categoryAxisSettings.show ? 1 : 0);
	                    this.xAxis
	                        .selectAll(".xAxisLabel")
	                        .remove();
	                    if (data.settings.categoryAxisSettings.showAxisTitle) {
	                        this.xAxis.append("text")
	                            .text(this.dataView.categorical.categories[0].source.displayName)
	                            .style("text-anchor", "middle")
	                            .attr("class", "xAxisLabel")
	                            .style("fill", categoryAxisSettings.labelColor.solid.color)
	                            .attr("transform", "translate(" + (viewportIn.width / 2) + "," + (data.settings.xAxisLabelTexMaxSize > 0 ? data.settings.xAxisLabelTexMaxSize : 40) + ")");
	                    }
	                };
	                DotPlot.setAxisLabelColor = function (selection, fill) {
	                    selection
	                        .selectAll("g.tick text")
	                        .style("fill", fill && fill.solid ? fill.solid.color : null);
	                };
	                DotPlot.DataLabelXOffset = 2;
	                DotPlot.DataLabelYOffset = 1.5;
	                DotPlot.DataLabelAngle = -90;
	                DotPlot.DataLabelXOffsetIndex = 0.3;
	                DotPlot.capabilities = {
	                    dataRoles: [
	                        {
	                            name: "Category",
	                            kind: VisualDataRoleKind.Grouping,
	                            displayName: "Category"
	                        },
	                        {
	                            name: "Values",
	                            kind: VisualDataRoleKind.Measure,
	                            displayName: "Values"
	                        }
	                    ],
	                    dataViewMappings: [{
	                            conditions: [
	                                { "Category": { max: 1 }, "Values": { max: 1 } },
	                            ],
	                            categorical: {
	                                categories: {
	                                    for: { in: "Category" },
	                                    dataReductionAlgorithm: { top: {} }
	                                },
	                                values: {
	                                    group: {
	                                        by: "Series",
	                                        select: [{ for: { in: "Values" } }],
	                                        dataReductionAlgorithm: { top: {} }
	                                    }
	                                }
	                            },
	                        }],
	                    objects: {
	                        general: {
	                            displayName: "General",
	                            properties: {
	                                formatString: {
	                                    type: { formatting: { formatString: true } },
	                                },
	                            },
	                        },
	                        categoryAxis: {
	                            displayName: "X-Axis",
	                            properties: {
	                                show: {
	                                    displayName: "Show",
	                                    type: { bool: true },
	                                },
	                                showAxisTitle: {
	                                    displayName: "Title",
	                                    description: "Title options",
	                                    type: { bool: true }
	                                },
	                                labelColor: {
	                                    displayName: "Label color",
	                                    type: { fill: { solid: { color: true } } }
	                                }
	                            }
	                        },
	                        dataPoint: {
	                            displayName: "Data colors",
	                            properties: {
	                                fill: {
	                                    displayName: "Fill",
	                                    type: { fill: { solid: { color: true } } }
	                                }
	                            }
	                        },
	                        labels: {
	                            displayName: "Data labels",
	                            description: "Display data label options",
	                            properties: {
	                                show: {
	                                    displayName: "Show",
	                                    type: { bool: true }
	                                },
	                                showSeries: {
	                                    displayName: "Show",
	                                    type: { bool: true }
	                                },
	                                color: {
	                                    displayName: "Color",
	                                    description: "Select color for data labels",
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                labelDisplayUnits: {
	                                    displayName: "Display units",
	                                    description: "Select the units (millions, billions, etc.)",
	                                    type: { formatting: { labelDisplayUnits: true } },
	                                    suppressFormatPainterCopy: true
	                                },
	                                labelPrecision: {
	                                    displayName: "Decimal places",
	                                    description: "Select the number of decimal places to display",
	                                    placeHolderText: "Auto",
	                                    type: { numeric: true },
	                                    suppressFormatPainterCopy: true
	                                },
	                                showAll: {
	                                    displayName: "Customize series",
	                                    type: { bool: true }
	                                },
	                                fontSize: {
	                                    displayName: "Text Size",
	                                    type: { formatting: { fontSize: true } }
	                                }
	                            }
	                        }
	                    }
	                };
	                return DotPlot;
	            }());
	            samples.DotPlot = DotPlot;
	            var DotplotBehavior = (function () {
	                function DotplotBehavior() {
	                }
	                DotplotBehavior.prototype.bindEvents = function (options, selectionHandler) {
	                    this.columns = options.columns;
	                    this.clearCatcher = options.clearCatcher;
	                    this.interactivityService = options.interactivityService;
	                    this.columns.on("click", function (d, i) {
	                        selectionHandler.handleSelection(d, d3.event.ctrlKey);
	                    });
	                    options.clearCatcher.on("click", function () {
	                        selectionHandler.handleClearSelection();
	                    });
	                };
	                DotplotBehavior.prototype.renderSelection = function (hasSelection) {
	                    var hasHighlights = this.interactivityService.hasSelection();
	                    this.columns.style("fill-opacity", function (d) {
	                        return dotPlotUtils.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights);
	                    });
	                };
	                return DotplotBehavior;
	            }());
	            samples.DotplotBehavior = DotplotBehavior;
	            var dotPlotUtils;
	            (function (dotPlotUtils) {
	                dotPlotUtils.DimmedOpacity = 0.4;
	                dotPlotUtils.DefaultOpacity = 1.0;
	                function getFillOpacity(selected, highlight, hasSelection, hasPartialHighlights) {
	                    if ((hasPartialHighlights && !highlight) || (hasSelection && !selected)) {
	                        return dotPlotUtils.DimmedOpacity;
	                    }
	                    return dotPlotUtils.DefaultOpacity;
	                }
	                dotPlotUtils.getFillOpacity = getFillOpacity;
	            })(dotPlotUtils = samples.dotPlotUtils || (samples.dotPlotUtils = {}));
	        })(samples = visuals.samples || (visuals.samples = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 51 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/*
	 *  This file is based on or incorporates material from the projects listed below (Third Party IP).
	 *  The original copyright notice and the license under which Microsoft received such Third Party IP,
	 *  are set forth below. Such licenses and notices are provided for informational purposes only.
	 *  Microsoft licenses the Third Party IP to you under the licensing terms for the Microsoft product.
	 *  Microsoft reserves all other rights not expressly granted under this agreement, whether by
	 *  implication, estoppel or otherwise.
	 *
	 *  d3 Force Layout
	 *  Copyright (c) 2010-2015, Michael Bostock
	 *  All rights reserved.
	 *
	 *  Redistribution and use in source and binary forms, with or without
	 *  modification, are permitted provided that the following conditions are met:
	 *
	 *  * Redistributions of source code must retain the above copyright notice, this
	 *    list of conditions and the following disclaimer.
	 *
	 *  * Redistributions in binary form must reproduce the above copyright notice,
	 *    this list of conditions and the following disclaimer in the documentation
	 *    and/or other materials provided with the distribution.
	 *
	 *  * The name Michael Bostock may not be used to endorse or promote products
	 *    derived from this software without specific prior written permission.
	 *
	 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	 *  DISCLAIMED. IN NO EVENT SHALL MICHAEL BOSTOCK BE LIABLE FOR ANY DIRECT,
	 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
	/// <reference path="../../../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var samples;
	        (function (samples) {
	            var PixelConverter = jsCommon.PixelConverter;
	            var createEnumType = powerbi.createEnumType;
	            var DataViewObjects = powerbi.DataViewObjects;
	            var ObjectEnumerationBuilder = powerbi.visuals.ObjectEnumerationBuilder;
	            var dataLabelUtils = powerbi.visuals.dataLabelUtils;
	            var VisualDataRoleKind = powerbi.VisualDataRoleKind;
	            var valueFormatter = powerbi.visuals.valueFormatter;
	            var TooltipManager = powerbi.visuals.TooltipManager;
	            var hasRole = powerbi.data.DataRoleHelper.hasRole;
	            (function (LinkColorType) {
	                LinkColorType[LinkColorType["ByWeight"] = "By Weight"] = "ByWeight";
	                LinkColorType[LinkColorType["ByLinkType"] = "By Link Type"] = "ByLinkType";
	                LinkColorType[LinkColorType["Interactive"] = "Interactive"] = "Interactive";
	            })(samples.LinkColorType || (samples.LinkColorType = {}));
	            var LinkColorType = samples.LinkColorType;
	            var ForceGraphSettings = (function () {
	                function ForceGraphSettings() {
	                    this.labels = {
	                        show: true,
	                        color: dataLabelUtils.defaultLabelColor,
	                        fontSize: dataLabelUtils.DefaultFontSizeInPt
	                    };
	                    this.links = {
	                        showArrow: false,
	                        showLabel: false,
	                        colorLink: LinkColorType.Interactive,
	                        thickenLink: true,
	                        displayUnits: 0,
	                        decimalPlaces: null
	                    };
	                    this.nodes = {
	                        displayImage: false,
	                        defaultImage: "Home",
	                        imageUrl: "",
	                        imageExt: ".png",
	                        nameMaxLength: 10,
	                        highlightReachableLinks: false,
	                    };
	                    this.size = {
	                        charge: -15
	                    };
	                }
	                Object.defineProperty(ForceGraphSettings, "Default", {
	                    get: function () {
	                        return new this();
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                ForceGraphSettings.parse = function (dataView, capabilities) {
	                    var settings = new this();
	                    if (!dataView || !dataView.metadata || !dataView.metadata.objects) {
	                        return settings;
	                    }
	                    var properties = this.getProperties(capabilities);
	                    for (var objectKey in capabilities.objects) {
	                        for (var propKey in capabilities.objects[objectKey].properties) {
	                            if (!settings[objectKey] || !_.has(settings[objectKey], propKey)) {
	                                continue;
	                            }
	                            var type = capabilities.objects[objectKey].properties[propKey].type;
	                            var getValueFn = this.getValueFnByType(type);
	                            settings[objectKey][propKey] = getValueFn(dataView.metadata.objects, properties[objectKey][propKey], settings[objectKey][propKey]);
	                        }
	                    }
	                    return settings;
	                };
	                ForceGraphSettings.getProperties = function (capabilities) {
	                    var properties = {};
	                    for (var objectKey in capabilities.objects) {
	                        properties[objectKey] = {};
	                        for (var propKey in capabilities.objects[objectKey].properties) {
	                            properties[objectKey][propKey] = {
	                                objectName: objectKey,
	                                propertyName: propKey
	                            };
	                        }
	                    }
	                    return properties;
	                };
	                ForceGraphSettings.createEnumTypeFromEnum = function (type) {
	                    var even = false;
	                    return createEnumType(Object.keys(type)
	                        .filter(function (key, i) { return ((!!(i % 2)) === even && type[key] === key
	                        && !void (even = !even)) || (!!(i % 2)) !== even; })
	                        .map(function (x) { return { value: x, displayName: x }; }));
	                };
	                ForceGraphSettings.getValueFnByType = function (type) {
	                    switch (_.keys(type)[0]) {
	                        case 'fill':
	                            return DataViewObjects.getFillColor;
	                        default:
	                            return DataViewObjects.getValue;
	                    }
	                };
	                ForceGraphSettings.enumerateObjectInstances = function (settings, options, capabilities) {
	                    var enumeration = new ObjectEnumerationBuilder();
	                    var object = settings && settings[options.objectName];
	                    if (!object) {
	                        return enumeration.complete();
	                    }
	                    var instance = {
	                        objectName: options.objectName,
	                        selector: null,
	                        properties: {}
	                    };
	                    for (var key in object) {
	                        if (_.has(object, key)) {
	                            instance.properties[key] = object[key];
	                        }
	                    }
	                    enumeration.pushInstance(instance);
	                    return enumeration.complete();
	                };
	                return ForceGraphSettings;
	            }());
	            samples.ForceGraphSettings = ForceGraphSettings;
	            var ForceGraphTooltipsFactory = (function () {
	                function ForceGraphTooltipsFactory() {
	                }
	                ForceGraphTooltipsFactory.build = function (inputObject, dataViewMetadataColumns, formatStringProperties) {
	                    var tooltips = [];
	                    if (!inputObject) {
	                        return tooltips;
	                    }
	                    for (var propertyName in inputObject) {
	                        var column, value;
	                        column = ForceGraphMetadataRoleHelper.getColumnByRoleName(dataViewMetadataColumns, propertyName);
	                        if (!column || !column.displayName) {
	                            continue;
	                        }
	                        value = inputObject[propertyName];
	                        if (formatStringProperties && !_.isNumber(value)) {
	                            value = valueFormatter.format(value, valueFormatter.getFormatString(column, formatStringProperties));
	                        }
	                        tooltips.push({
	                            displayName: column.displayName,
	                            value: value
	                        });
	                    }
	                    return tooltips;
	                };
	                return ForceGraphTooltipsFactory;
	            }());
	            samples.ForceGraphTooltipsFactory = ForceGraphTooltipsFactory;
	            var ForceGraphMetadataRoleHelper = (function () {
	                function ForceGraphMetadataRoleHelper() {
	                }
	                ForceGraphMetadataRoleHelper.getColumnByRoleName = function (dataViewMetadataColumns, roleName) {
	                    if (!_.isEmpty(dataViewMetadataColumns) && roleName) {
	                        for (var i = 0, length = dataViewMetadataColumns.length; i < length; i++) {
	                            var column = dataViewMetadataColumns[i];
	                            if (column && hasRole(column, roleName)) {
	                                return column;
	                            }
	                        }
	                    }
	                    return null;
	                };
	                return ForceGraphMetadataRoleHelper;
	            }());
	            samples.ForceGraphMetadataRoleHelper = ForceGraphMetadataRoleHelper;
	            var ForceGraphColumns = (function () {
	                function ForceGraphColumns() {
	                    this.Source = null;
	                    this.Target = null;
	                    this.Weight = null;
	                    this.LinkType = null;
	                    this.SourceType = null;
	                    this.TargetType = null;
	                }
	                ForceGraphColumns.getMetadataColumns = function (dataView) {
	                    var columns = dataView && dataView.metadata && dataView.metadata.columns;
	                    return columns && _.mapValues(new ForceGraphColumns(), function (n, i) { return columns.filter(function (x) { return x.roles && x.roles[i]; })[0]; });
	                };
	                ForceGraphColumns.getTableValues = function (dataView) {
	                    var table = dataView && dataView.table;
	                    var columns = this.getMetadataColumns(dataView);
	                    return columns && table && _.mapValues(columns, function (n, i) { return n && table.rows.map(function (row) { return row[n.index]; }); });
	                };
	                ForceGraphColumns.getTableRows = function (dataView) {
	                    var table = dataView && dataView.table;
	                    var columns = this.getMetadataColumns(dataView);
	                    return columns && table && table.rows.map(function (row) {
	                        return _.mapValues(columns, function (n, i) { return n && row[n.index]; });
	                    });
	                };
	                ForceGraphColumns.Roles = Object.freeze(_.mapValues(new ForceGraphColumns(), function (x, i) { return i; }));
	                return ForceGraphColumns;
	            }());
	            samples.ForceGraphColumns = ForceGraphColumns;
	            var ForceGraph = (function () {
	                function ForceGraph() {
	                    this.uniqieId = "_" + (ForceGraph.Count++) + "_";
	                }
	                Object.defineProperty(ForceGraph, "Href", {
	                    get: function () {
	                        return window.location.href.replace(window.location.hash, "");
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(ForceGraph.prototype, "settings", {
	                    get: function () {
	                        return this.data && this.data.settings;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(ForceGraph.prototype, "margin", {
	                    get: function () {
	                        return this.marginValue || { left: 0, right: 0, top: 0, bottom: 0 };
	                    },
	                    set: function (value) {
	                        this.marginValue = $.extend({}, value);
	                        this.viewportInValue = ForceGraph.substractMargin(this.viewport, this.margin);
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(ForceGraph.prototype, "viewport", {
	                    get: function () {
	                        return this.viewportValue || { width: 0, height: 0 };
	                    },
	                    set: function (value) {
	                        this.viewportValue = $.extend({}, value);
	                        this.viewportInValue = ForceGraph.substractMargin(this.viewport, this.margin);
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(ForceGraph.prototype, "viewportIn", {
	                    get: function () {
	                        return this.viewportInValue || this.viewport;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                ForceGraph.substractMargin = function (viewport, margin) {
	                    return {
	                        width: Math.max(viewport.width - (margin.left + margin.right), 0),
	                        height: Math.max(viewport.height - (margin.top + margin.bottom), 0)
	                    };
	                };
	                ForceGraph.prototype.scale1to10 = function (d) {
	                    var scale = d3.scale.linear()
	                        .domain([
	                        this.data.minFiles,
	                        this.data.maxFiles
	                    ])
	                        .rangeRound([1, 10])
	                        .clamp(true);
	                    return scale(d);
	                };
	                ForceGraph.prototype.getLinkColor = function (d) {
	                    switch (this.settings.links.colorLink) {
	                        case LinkColorType.ByWeight:
	                            return this.colors.getColorByIndex(this.scale1to10(d.weight)).value;
	                        case LinkColorType.ByLinkType:
	                            return d.type && this.data.linkTypes[d.type]
	                                ? this.data.linkTypes[d.type].color
	                                : ForceGraph.DefaultValues.defaultLinkColor;
	                    }
	                    ;
	                    return ForceGraph.DefaultValues.defaultLinkColor;
	                };
	                ForceGraph.prototype.enumerateObjectInstances = function (options) {
	                    return ForceGraphSettings.enumerateObjectInstances(this.settings, options, ForceGraph.capabilities);
	                };
	                ForceGraph.converter = function (dataView, colors) {
	                    var settings = ForceGraph.parseSettings(dataView), nodes = {}, minFiles = Number.MAX_VALUE, maxFiles = 0, linkedByName = {}, links = [], linkDataPoints = {}, linkTypeCount = 0, tooltipInfo = [], metadata = ForceGraphColumns.getMetadataColumns(dataView);
	                    if (!metadata || !metadata.Source || !metadata.Target) {
	                        return null;
	                    }
	                    var tableRows = ForceGraphColumns.getTableRows(dataView), formatStringProp = ForceGraphSettings.getProperties(ForceGraph.capabilities)['general']['formatString'];
	                    var weightFormatter = metadata.Weight && valueFormatter.create({
	                        format: valueFormatter.getFormatString(metadata.Weight, formatStringProp, true),
	                        precision: settings.links.decimalPlaces,
	                        value: settings.links.displayUnits || _.max(tableRows, function (x) { return x.Weight; }).Weight
	                    });
	                    tableRows.forEach(function (tableRow) {
	                        linkedByName[tableRow.Source + "," + tableRow.Target] = 1;
	                        var source = nodes[tableRow.Source] || (nodes[tableRow.Source] = { name: tableRow.Source, image: tableRow.SourceType || "", adj: {} });
	                        var target = nodes[tableRow.Target] || (nodes[tableRow.Target] = { name: tableRow.Target, image: tableRow.TargetType || "", adj: {} });
	                        source.adj[target.name] = 1;
	                        target.adj[source.name] = 1;
	                        tooltipInfo = ForceGraphTooltipsFactory.build(tableRow, dataView.metadata.columns, formatStringProp);
	                        var link = {
	                            source: source,
	                            target: target,
	                            weight: Math.max(tableRow.Weight, 0),
	                            formattedWeight: tableRow.Weight && weightFormatter.format(tableRow.Weight),
	                            type: tableRow.LinkType || "",
	                            tooltipInfo: tooltipInfo,
	                        };
	                        if (metadata.LinkType && !linkDataPoints[tableRow.LinkType]) {
	                            linkDataPoints[tableRow.LinkType] = {
	                                label: tableRow.LinkType,
	                                color: colors.getColorByIndex(linkTypeCount++).value,
	                            };
	                        }
	                        ;
	                        if (link.weight < minFiles) {
	                            minFiles = link.weight;
	                        }
	                        if (link.weight > maxFiles) {
	                            maxFiles = link.weight;
	                        }
	                        links.push(link);
	                    });
	                    return {
	                        nodes: nodes,
	                        links: links,
	                        minFiles: minFiles,
	                        maxFiles: maxFiles,
	                        linkedByName: linkedByName,
	                        linkTypes: linkDataPoints,
	                        settings: settings
	                    };
	                };
	                ForceGraph.parseSettings = function (dataView) {
	                    var settings = ForceGraphSettings.parse(dataView, ForceGraph.capabilities);
	                    settings.size.charge = Math.min(Math.max(settings.size.charge, -100), -0.1);
	                    settings.links.decimalPlaces = settings.links.decimalPlaces && Math.min(Math.max(settings.links.decimalPlaces, 0), 5);
	                    return settings;
	                };
	                ForceGraph.prototype.init = function (options) {
	                    var _this = this;
	                    this.root = d3.select(options.element.get(0));
	                    this.forceLayout = d3.layout.force();
	                    this.forceLayout.drag()
	                        .on("dragstart", (function (d) { d.isDrag = true; _this.fadeNode(d); }))
	                        .on("dragend", (function (d) { d.isDrag = false; _this.fadeNode(d); }))
	                        .on("drag", (function (d) { return _this.fadeNode(d); }));
	                    this.colors = options.style.colorPalette.dataColors;
	                };
	                ForceGraph.prototype.update = function (options) {
	                    var _this = this;
	                    if (!options.dataViews || (options.dataViews.length < 1)) {
	                        return;
	                    }
	                    this.data = ForceGraph.converter(this.dataView = options.dataViews[0], this.colors);
	                    if (!this.data) {
	                        this.removeElements();
	                        return;
	                    }
	                    this.viewport = options.viewport;
	                    var k = Math.sqrt(Object.keys(this.data.nodes).length / (this.viewport.width * this.viewport.height));
	                    this.removeElements();
	                    var svg = this.root
	                        .append("svg")
	                        .attr("width", this.viewport.width)
	                        .attr("height", this.viewport.height)
	                        .classed(ForceGraph.VisualClassName, true);
	                    this.forceLayout
	                        .gravity(100 * k)
	                        .links(this.data.links)
	                        .size([this.viewport.width, this.viewport.height])
	                        .linkDistance(100)
	                        .charge(this.settings.size.charge / k)
	                        .on("tick", this.tick());
	                    this.updateNodes();
	                    this.forceLayout.start();
	                    this.paths = svg.selectAll(".link")
	                        .data(this.forceLayout.links())
	                        .enter().append("path")
	                        .attr("class", "link")
	                        .attr("id", function (d, i) { return "linkid_" + _this.uniqieId + i; })
	                        .attr("stroke-width", function (d) {
	                        return _this.settings.links.thickenLink
	                            ? _this.scale1to10(d.weight)
	                            : ForceGraph.DefaultValues.defaultLinkThickness;
	                    })
	                        .style("stroke", function (d) { return _this.getLinkColor(d); })
	                        .style("fill", function (d) {
	                        if (_this.settings.links.showArrow) {
	                            return _this.getLinkColor(d);
	                        }
	                    })
	                        .on("mouseover", this.fadePath(.3, ForceGraph.DefaultValues.defaultLinkHighlightColor))
	                        .on("mouseout", this.fadePath(1, ForceGraph.DefaultValues.defaultLinkColor));
	                    TooltipManager.addTooltip(this.paths, function (tooltipEvent) {
	                        return tooltipEvent.data.tooltipInfo;
	                    });
	                    if (this.settings.links.showLabel) {
	                        var linklabelholderUpdate = svg
	                            .selectAll(".linklabelholder")
	                            .data(this.forceLayout.links());
	                        linklabelholderUpdate.enter()
	                            .append("g")
	                            .attr("class", "linklabelholder")
	                            .append("text")
	                            .attr("class", "linklabel")
	                            .attr("y", "-12")
	                            .attr("text-anchor", "middle")
	                            .style("fill", "#000")
	                            .append("textPath")
	                            .attr("xlink:href", function (d, i) { return ForceGraph.Href + "#linkid_" + _this.uniqieId + i; })
	                            .attr("startOffset", "25%")
	                            .text(function (d) {
	                            return _this.settings.links.colorLink === LinkColorType.ByLinkType
	                                ? d.type
	                                : d.formattedWeight;
	                        });
	                        linklabelholderUpdate
	                            .exit()
	                            .remove();
	                    }
	                    // define the nodes
	                    this.nodes = svg.selectAll(".node")
	                        .data(this.forceLayout.nodes())
	                        .enter().append("g")
	                        .attr("class", "node")
	                        .call(this.forceLayout.drag)
	                        .on("mouseover", function (d) { d.isOver = true; _this.fadeNode(d); })
	                        .on("mouseout", function (d) { d.isOver = false; _this.fadeNode(d); })
	                        .on("mousedown", function () { return d3.event.stopPropagation(); })
	                        .attr("drag-resize-disabled", true);
	                    // add the nodes
	                    if (this.settings.nodes.displayImage) {
	                        this.nodes.append("image")
	                            .attr("xlink:href", function (d) {
	                            return d.image && d.image !== '' ?
	                                _this.settings.nodes.imageUrl + d.image + _this.settings.nodes.imageExt :
	                                (_this.settings.nodes.defaultImage && _this.settings.nodes.defaultImage !== '' ?
	                                    _this.settings.nodes.imageUrl + _this.settings.nodes.defaultImage + _this.settings.nodes.imageExt :
	                                    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABsAAAAbCAMAAAHNDTTxAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAACuUExURQAAAMbGxvLy8sfHx/Hx8fLy8vHx8cnJycrKyvHx8fHx8cvLy/Ly8szMzM3NzfHx8dDQ0PHx8fLy8vHx8e/v79LS0tPT0/Ly8tTU1NXV1dbW1vHx8fHx8fDw8NjY2PT09PLy8vLy8vHx8fLy8vHx8fHx8enp6fDw8PLy8uPj4+Tk5OXl5fHx8b+/v/Pz8+bm5vHx8ejo6PLy8vHx8fLy8sTExPLy8vLy8sXFxfHx8YCtMbUAAAA6dFJOUwD/k/+b7/f///+r/////0z/w1RcEP//ZP///4fj/v8Yj3yXn/unDEhQ////YP9Y/8//aIMU/9+L/+fzC4s1AAAACXBIWXMAABcRAAAXEQHKJvM/AAABQElEQVQoU5WS61LCMBCFFymlwSPKVdACIgWkuNyL+P4v5ibZ0jKjP/xm0uw5ySa7mRItAhnMoIC5TwQZdCZiZjcoC8WU6EVsmZgzoqGdxafgvJAvjUXCb2M+0cXNsd/GDarZqSf7av3M2P1E3xhfLkPUvLD5joEYwVVJQXM6+9McWUwLf4nDTCQZAy96UoDjNI/jhl3xPLbQamu8xD7iaIsPKw7GJ7KZEnWLY3Gi8EFj5nqibXnwD5VEGjJXk5sbpLppfvvo1RazQVrhSopPK4TODrtnjS3dY4ic8KurruWQYF+UG60BacexTMyT2jlNg41dOmKvTpkUd/Jevy7ZxQ61ULRUpoododx8GeDPvIrktbFVdUsK6f8Na5VlVpjZJtowTXVy7kfXF5wCaV1tqXAFuIdWJu+JviaQzNzfQvQDGKRXXEmy83cAAAAASUVORK5CYII=');
	                        })
	                            .attr("x", "-12px")
	                            .attr("y", "-12px")
	                            .attr("width", "24px")
	                            .attr("height", "24px");
	                    }
	                    else {
	                        this.nodes
	                            .append("circle")
	                            .attr("r", function (d) { return d.weight < 5 ? 5 : d.weight; });
	                    }
	                    // add the text
	                    if (this.settings.labels.show) {
	                        this.nodes.append("text")
	                            .attr({
	                            x: 12,
	                            dy: ".35em"
	                        })
	                            .style({
	                            fill: this.settings.labels.color,
	                            'font-size': PixelConverter.fromPoint(this.settings.labels.fontSize)
	                        })
	                            .text(function (d) { return d.name ? (d.name.length > _this.settings.nodes.nameMaxLength
	                            ? d.name.substr(0, _this.settings.nodes.nameMaxLength)
	                            : d.name) : ''; });
	                    }
	                };
	                ForceGraph.prototype.removeElements = function () {
	                    if (!this.root) {
	                        return;
	                    }
	                    this.root
	                        .selectAll("svg")
	                        .remove();
	                };
	                ForceGraph.prototype.updateNodes = function () {
	                    var oldNodes = this.forceLayout.nodes();
	                    this.forceLayout.nodes(d3.values(this.data.nodes));
	                    this.forceLayout.nodes().forEach(function (node, i) {
	                        if (!oldNodes[i]) {
	                            return;
	                        }
	                        node.x = oldNodes[i].x;
	                        node.y = oldNodes[i].y;
	                        node.px = oldNodes[i].px;
	                        node.py = oldNodes[i].py;
	                        node.weight = oldNodes[i].weight;
	                    });
	                };
	                ForceGraph.prototype.tick = function () {
	                    var _this = this;
	                    var viewport = this.viewportIn;
	                    // limitX and limitY is necessary when you minimize the graph and then resize it to normal.
	                    //"width/height * 20" seems enough to move nodes freely by force layout.
	                    var maxWidth = viewport.width * 20;
	                    var maxHeight = viewport.height * 20;
	                    var limitX = function (x) { return Math.max((viewport.width - maxWidth) / 2, Math.min((viewport.width + maxWidth) / 2, x)); };
	                    var limitY = function (y) { return Math.max((viewport.height - maxHeight) / 2, Math.min((viewport.height + maxHeight) / 2, y)); };
	                    var getPath = this.settings.links.showArrow
	                        ? function (d) {
	                            d.source.x = limitX(d.source.x);
	                            d.source.y = limitY(d.source.y);
	                            d.target.x = limitX(d.target.x);
	                            d.target.y = limitY(d.target.y);
	                            var dx = d.target.x - d.source.x, dy = d.target.y - d.source.y, dr = Math.sqrt(dx * dx + dy * dy), theta = Math.atan2(dy, dx) + Math.PI / 7.85, d90 = Math.PI / 2, dtxs = d.target.x - 6 * Math.cos(theta), dtys = d.target.y - 6 * Math.sin(theta);
	                            return "M" +
	                                d.source.x + "," +
	                                d.source.y + "A" +
	                                dr + "," + dr + " 0 0 1," +
	                                d.target.x + "," +
	                                d.target.y +
	                                "A" + dr + "," + dr + " 0 0 0," + d.source.x + "," + d.source.y + "M" + dtxs + "," + dtys + "l" + (3.5 * Math.cos(d90 - theta) - 10 * Math.cos(theta)) + "," + (-3.5 * Math.sin(d90 - theta) - 10 * Math.sin(theta)) + "L" + (dtxs - 3.5 * Math.cos(d90 - theta) - 10 * Math.cos(theta)) + "," + (dtys + 3.5 * Math.sin(d90 - theta) - 10 * Math.sin(theta)) + "z";
	                        }
	                        : function (d) {
	                            d.source.x = limitX(d.source.x);
	                            d.source.y = limitY(d.source.y);
	                            d.target.x = limitX(d.target.x);
	                            d.target.y = limitY(d.target.y);
	                            var dx = d.target.x - d.source.x, dy = d.target.y - d.source.y, dr = Math.sqrt(dx * dx + dy * dy);
	                            return "M" +
	                                d.source.x + "," +
	                                d.source.y + "A" +
	                                dr + "," + dr + " 0 0,1 " +
	                                d.target.x + "," +
	                                d.target.y;
	                        };
	                    return function () {
	                        _this.paths.each(function () {
	                            this.parentNode.insertBefore(this, this);
	                        });
	                        _this.paths.attr("d", getPath);
	                        _this.nodes.attr("transform", function (d) { return "translate(" + limitX(d.x) + "," + limitY(d.y) + ")"; });
	                    };
	                };
	                ForceGraph.prototype.fadePath = function (opacity, highlight) {
	                    var _this = this;
	                    if (this.settings.links.colorLink !== LinkColorType.Interactive) {
	                        return;
	                    }
	                    return function (d) {
	                        _this.paths.style("stroke-opacity", function (o) { return o.source === d.source && o.target === d.target ? 1 : opacity; });
	                        _this.paths.style("stroke", function (o) { return o.source === d.source && o.target === d.target ? highlight : ForceGraph.DefaultValues.defaultLinkColor; });
	                    };
	                };
	                ForceGraph.prototype.isReachable = function (a, b) {
	                    if (a.name === b.name)
	                        return true;
	                    if (this.data.linkedByName[a.name + "," + b.name])
	                        return true;
	                    var visited = {};
	                    for (var name in this.data.nodes) {
	                        visited[name] = false;
	                    }
	                    ;
	                    visited[a.name] = true;
	                    var stack = [];
	                    stack.push(a.name);
	                    while (stack.length > 0) {
	                        var cur = stack.pop();
	                        var node = this.data.nodes[cur];
	                        for (var nb in node.adj) {
	                            if (nb === b.name)
	                                return true;
	                            if (!visited[nb]) {
	                                visited[nb] = true;
	                                stack.push(nb);
	                            }
	                        }
	                    }
	                    ;
	                    return false;
	                };
	                ForceGraph.prototype.fadeNode = function (node) {
	                    var _this = this;
	                    if (this.settings.links.colorLink !== LinkColorType.Interactive) {
	                        return;
	                    }
	                    var isConnected = function (a, b) { return _this.data.linkedByName[a.name + "," + b.name]
	                        || _this.data.linkedByName[b.name + "," + a.name] || a.name === b.name; };
	                    var isHighlight = node.isOver || node.isDrag;
	                    var opacity = isHighlight ? 0.3 : 1;
	                    var highlight = isHighlight
	                        ? ForceGraph.DefaultValues.defaultLinkHighlightColor
	                        : ForceGraph.DefaultValues.defaultLinkColor;
	                    var that = this;
	                    this.nodes.style("stroke-opacity", function (o) {
	                        var thisOpacity = (that.settings.nodes.highlightReachableLinks ? that.isReachable(node, o) : isConnected(node, o)) ? 1 : opacity;
	                        this.setAttribute('fill-opacity', thisOpacity);
	                        return thisOpacity;
	                    });
	                    this.paths.style("stroke-opacity", function (o) {
	                        return (_this.settings.nodes.highlightReachableLinks ? _this.isReachable(node, o.source) :
	                            (o.source === node || o.target === node)) ? 1 : opacity;
	                    });
	                    this.paths.style("stroke", function (o) {
	                        return (_this.settings.nodes.highlightReachableLinks ? _this.isReachable(node, o.source) :
	                            (o.source === node || o.target === node)) ? highlight : ForceGraph.DefaultValues.defaultLinkColor;
	                    });
	                };
	                ForceGraph.prototype.destroy = function () {
	                    this.root = null;
	                };
	                ForceGraph.VisualClassName = 'forceGraph';
	                ForceGraph.Count = 0;
	                ForceGraph.DefaultValues = {
	                    defaultLinkColor: "#bbb",
	                    defaultLinkHighlightColor: "#f00",
	                    defaultLinkThickness: "1.5px",
	                };
	                ForceGraph.capabilities = {
	                    dataRoles: [
	                        {
	                            name: ForceGraphColumns.Roles.Source,
	                            kind: VisualDataRoleKind.Grouping,
	                            displayName: "Source",
	                        },
	                        {
	                            name: ForceGraphColumns.Roles.Target,
	                            kind: VisualDataRoleKind.Grouping,
	                            displayName: "Target",
	                        },
	                        {
	                            name: ForceGraphColumns.Roles.Weight,
	                            kind: VisualDataRoleKind.Measure,
	                            displayName: "Weight",
	                        },
	                        {
	                            name: ForceGraphColumns.Roles.LinkType,
	                            kind: VisualDataRoleKind.Grouping,
	                            displayName: "Link Type",
	                            description: "Links can be colored by link types",
	                        },
	                        {
	                            name: ForceGraphColumns.Roles.SourceType,
	                            kind: VisualDataRoleKind.Grouping,
	                            displayName: "Source Type",
	                            description: "Source type represents the image name for source entities",
	                        },
	                        {
	                            name: ForceGraphColumns.Roles.TargetType,
	                            kind: VisualDataRoleKind.Grouping,
	                            displayName: "Target Type",
	                            description: "Target type represents the image name for target entities",
	                        },
	                    ],
	                    objects: {
	                        general: {
	                            properties: {
	                                formatString: {
	                                    type: { formatting: { formatString: true } },
	                                }
	                            }
	                        },
	                        labels: {
	                            displayName: 'Data labels',
	                            properties: {
	                                show: {
	                                    displayName: 'Show',
	                                    type: { bool: true }
	                                },
	                                color: {
	                                    displayName: 'Fill',
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                fontSize: {
	                                    displayName: 'Text Size',
	                                    type: { formatting: { fontSize: true } }
	                                }
	                            }
	                        },
	                        links: {
	                            displayName: 'Links',
	                            properties: {
	                                showArrow: {
	                                    type: { bool: true },
	                                    displayName: 'Arrow'
	                                },
	                                showLabel: {
	                                    type: { bool: true },
	                                    displayName: 'Label',
	                                    description: 'Displays weight on links',
	                                },
	                                colorLink: {
	                                    type: { enumeration: ForceGraphSettings.createEnumTypeFromEnum(LinkColorType) },
	                                    displayName: 'Color',
	                                },
	                                thickenLink: {
	                                    type: { bool: true },
	                                    displayName: 'Thickness',
	                                    description: 'Thickenss of links represents weight',
	                                },
	                                displayUnits: {
	                                    displayName: 'Display Units',
	                                    type: { formatting: { labelDisplayUnits: true } },
	                                },
	                                decimalPlaces: {
	                                    displayName: 'Decimal Places',
	                                    placeHolderText: 'Auto',
	                                    type: { numeric: true },
	                                },
	                            }
	                        },
	                        nodes: {
	                            displayName: 'Nodes',
	                            properties: {
	                                displayImage: {
	                                    type: { bool: true },
	                                    displayName: 'Image',
	                                    description: 'Images are loaded from image url + source or target type + image extension',
	                                },
	                                defaultImage: {
	                                    type: { text: true },
	                                    displayName: 'Default image'
	                                },
	                                imageUrl: {
	                                    type: { text: true },
	                                    displayName: 'Image url'
	                                },
	                                imageExt: {
	                                    type: { text: true },
	                                    displayName: 'Image extension'
	                                },
	                                nameMaxLength: {
	                                    type: { numeric: true },
	                                    displayName: 'Max name length',
	                                    description: 'Max length of the name of entities displayed',
	                                },
	                                highlightReachableLinks: {
	                                    type: { bool: true },
	                                    displayName: 'Highlight all reachable links',
	                                    description: "In interactive mode, whether a node's all reachable links will be highlighted",
	                                },
	                            }
	                        },
	                        size: {
	                            displayName: 'Size',
	                            properties: {
	                                charge: {
	                                    type: { numeric: true },
	                                    displayName: 'Charge',
	                                    description: 'The larger the negative charge the more apart the entities, must be negative but greater than -100',
	                                },
	                            }
	                        },
	                    },
	                    dataViewMappings: [{
	                            conditions: [
	                                {
	                                    'Source': { max: 1 },
	                                    'Target': { max: 1 },
	                                    'Weight': { max: 1 },
	                                    'LinkType': { max: 1 },
	                                    'SourceType': { max: 1 },
	                                    'TargetType': { max: 1 }
	                                },
	                            ],
	                            categorical: {
	                                categories: {
	                                    for: { in: 'Source' },
	                                    dataReductionAlgorithm: { top: { count: 10000 } }
	                                },
	                                values: {
	                                    select: [
	                                        { bind: { to: 'Target' } },
	                                        { bind: { to: 'Weight' } },
	                                        { bind: { to: 'LinkType' } },
	                                        { bind: { to: 'SourceType' } },
	                                        { bind: { to: 'TargetType' } },
	                                    ]
	                                },
	                                rowCount: { preferred: { min: 1 } }
	                            },
	                        }],
	                    suppressDefaultTitle: true,
	                };
	                return ForceGraph;
	            }());
	            samples.ForceGraph = ForceGraph;
	        })(samples = visuals.samples || (visuals.samples = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 52 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../../../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var samples;
	        (function (samples) {
	            var PixelConverter = jsCommon.PixelConverter;
	            var CreateClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
	            var SelectionManager = powerbi.visuals.utility.SelectionManager;
	            var createEnumType = powerbi.createEnumType;
	            var LegendData = powerbi.visuals.LegendData;
	            var legendPosition = powerbi.visuals.legendPosition;
	            var VisualDataRoleKind = powerbi.VisualDataRoleKind;
	            var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
	            var createInteractivityService = powerbi.visuals.createInteractivityService;
	            var appendClearCatcher = powerbi.visuals.appendClearCatcher;
	            var createLegend = powerbi.visuals.createLegend;
	            var LegendPosition = powerbi.visuals.LegendPosition;
	            var valueFormatter = powerbi.visuals.valueFormatter;
	            var ColorHelper = powerbi.visuals.ColorHelper;
	            var SelectionId = powerbi.visuals.SelectionId;
	            var DataViewObjects = powerbi.DataViewObjects;
	            var LegendIcon = powerbi.visuals.LegendIcon;
	            var Legend = powerbi.visuals.Legend;
	            var ValueType = powerbi.ValueType;
	            var PrimitiveType = powerbi.PrimitiveType;
	            var AxisHelper = powerbi.visuals.AxisHelper;
	            var TextMeasurementService = powerbi.TextMeasurementService;
	            var TooltipManager = powerbi.visuals.TooltipManager;
	            var SVGUtil = powerbi.visuals.SVGUtil;
	            var ObjectEnumerationBuilder = powerbi.visuals.ObjectEnumerationBuilder;
	            var axisScale = powerbi.visuals.axisScale;
	            var PercentFormat = "0.00 %;-0.00 %;0.00 %";
	            var MillisecondsInADay = 86400000;
	            var MillisecondsInWeek = 604800000;
	            var MillisecondsInAMonth = 2629746000;
	            var MillisecondsInAYear = 31556952000;
	            var ChartLineHeight = 40;
	            var PaddingTasks = 5;
	            (function (GanttDateType) {
	                GanttDateType[GanttDateType["Day"] = "Day"] = "Day";
	                GanttDateType[GanttDateType["Week"] = "Week"] = "Week";
	                GanttDateType[GanttDateType["Month"] = "Month"] = "Month";
	                GanttDateType[GanttDateType["Year"] = "Year"] = "Year";
	            })(samples.GanttDateType || (samples.GanttDateType = {}));
	            var GanttDateType = samples.GanttDateType;
	            function createEnumTypeFromEnum(type) {
	                var even = false;
	                return createEnumType(Object.keys(type)
	                    .filter(function (key, i) { return ((!!(i % 2)) === even && type[key] === key && !void (even === !even)) || (!!(i % 2)) !== even; })
	                    .map(function (x) { return { value: x, displayName: x }; }));
	            }
	            ;
	            var Selectors;
	            (function (Selectors) {
	                Selectors.ClassName = CreateClassAndSelector("gantt");
	                Selectors.Chart = CreateClassAndSelector("chart");
	                Selectors.ChartLine = CreateClassAndSelector("chart-line");
	                Selectors.Body = CreateClassAndSelector("gantt-body");
	                Selectors.AxisGroup = CreateClassAndSelector("axis");
	                Selectors.Domain = CreateClassAndSelector("domain");
	                Selectors.AxisTick = CreateClassAndSelector("tick");
	                Selectors.Tasks = CreateClassAndSelector("tasks");
	                Selectors.TaskGroup = CreateClassAndSelector("task-group");
	                Selectors.SingleTask = CreateClassAndSelector("task");
	                Selectors.TaskRect = CreateClassAndSelector("task-rect");
	                Selectors.TaskProgress = CreateClassAndSelector("task-progress");
	                Selectors.TaskResource = CreateClassAndSelector("task-resource");
	                Selectors.SingleMilestone = CreateClassAndSelector("milestone");
	                Selectors.TaskLabels = CreateClassAndSelector("task-labels");
	                Selectors.TaskLines = CreateClassAndSelector("task-lines");
	                Selectors.SingleTaskLine = CreateClassAndSelector("task-line");
	                Selectors.Label = CreateClassAndSelector("label");
	                Selectors.LegendItems = CreateClassAndSelector("legendItem");
	                Selectors.LegendTitle = CreateClassAndSelector("legendTitle");
	            })(Selectors || (Selectors = {}));
	            var Gantt = (function () {
	                function Gantt() {
	                    this.textProperties = {
	                        fontFamily: 'wf_segoe-ui_normal',
	                        fontSize: PixelConverter.toString(9),
	                    };
	                    this.margin = Gantt.DefaultMargin;
	                }
	                Gantt.getProperties = function (capabilities) {
	                    var result = {};
	                    for (var objectKey in capabilities.objects) {
	                        result[objectKey] = {};
	                        for (var propKey in capabilities.objects[objectKey].properties) {
	                            result[objectKey][propKey] = {
	                                objectName: objectKey,
	                                propertyName: propKey
	                            };
	                        }
	                    }
	                    return result;
	                };
	                Object.defineProperty(Gantt, "DefaultMargin", {
	                    get: function () {
	                        return {
	                            top: 50,
	                            right: 40,
	                            bottom: 40,
	                            left: 10
	                        };
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Gantt.prototype.init = function (options) {
	                    this.viewport = _.clone(options.viewport);
	                    this.style = options.style;
	                    this.body = d3.select(options.element.get(0));
	                    this.hostServices = options.host;
	                    this.selectionManager = new SelectionManager({ hostServices: options.host });
	                    this.isInteractiveChart = options.interactivity && options.interactivity.isInteractiveLegend;
	                    this.interactivityService = createInteractivityService(this.hostServices);
	                    this.createViewport(options.element);
	                    this.updateChartSize();
	                    this.behavior = new GanttChartBehavior();
	                    this.colors = options.style.colorPalette.dataColors;
	                };
	                /**
	                 * Create the vieport area of the gantt chart
	                 */
	                Gantt.prototype.createViewport = function (element) {
	                    //create div container to the whole viewport area
	                    this.ganttDiv = this.body.append("div")
	                        .classed(Selectors.Body.class, true);
	                    //create container to the svg area
	                    this.ganttSvg = this.ganttDiv
	                        .append("svg")
	                        .classed(Selectors.ClassName.class, true);
	                    //create clear catcher
	                    this.clearCatcher = appendClearCatcher(this.ganttSvg);
	                    //create axis container
	                    this.axisGroup = this.ganttSvg
	                        .append("g")
	                        .classed(Selectors.AxisGroup.class, true);
	                    //create task lines container
	                    this.lineGroup = this.ganttSvg
	                        .append("g")
	                        .classed(Selectors.TaskLines.class, true);
	                    //create chart container
	                    this.chartGroup = this.ganttSvg
	                        .append("g")
	                        .classed(Selectors.Chart.class, true);
	                    //create tasks container
	                    this.taskGroup = this.chartGroup
	                        .append("g")
	                        .classed(Selectors.Tasks.class, true);
	                    //create legend container
	                    this.legend = createLegend(element, this.isInteractiveChart, this.interactivityService, true, LegendPosition.Top);
	                };
	                /**
	                 * Clear the viewport area
	                 */
	                Gantt.prototype.clearViewport = function () {
	                    this.body.selectAll(Selectors.LegendItems.selector).remove();
	                    this.body.selectAll(Selectors.LegendTitle.selector).remove();
	                    this.axisGroup.selectAll(Selectors.AxisTick.selector).remove();
	                    this.axisGroup.selectAll(Selectors.Domain.selector).remove();
	                    this.lineGroup.selectAll("*").remove();
	                    this.chartGroup.selectAll(Selectors.ChartLine.selector).remove();
	                    this.chartGroup.selectAll(Selectors.TaskGroup.selector).remove();
	                    this.chartGroup.selectAll(Selectors.SingleTask.selector).remove();
	                };
	                /**
	                 * Update div container size to the whole viewport area
	                 * @param viewport The vieport to change it size
	                 */
	                Gantt.prototype.updateChartSize = function () {
	                    this.ganttDiv.style({
	                        height: PixelConverter.toString(this.viewport.height),
	                        width: PixelConverter.toString(this.viewport.width)
	                    });
	                };
	                /**
	                 * Get task property from the data view
	                 * @param columnSource
	                 * @param child
	                 * @param propertyName The property to get
	                 */
	                Gantt.getTaskProperty = function (columnSource, child, propertyName) {
	                    if (!child ||
	                        !columnSource ||
	                        !(columnSource.length > 0) ||
	                        !columnSource[0].roles)
	                        return null;
	                    var index = columnSource.indexOf(columnSource.filter(function (x) { return x.roles[propertyName]; })[0]);
	                    return index !== -1 ? child[index] : null;
	                };
	                /**
	                 * Check if dataView has a given role
	                 * @param column The dataView headers
	                 * @param name The role to find
	                 */
	                Gantt.hasRole = function (column, name) {
	                    var roles = column.roles;
	                    return roles && roles[name];
	                };
	                /**
	                * Get the tooltip info (data display names & formated values)
	                * @param task All task attributes.
	                * @param formatters Formatting options for gantt attributes.
	                */
	                Gantt.getTooltipInfo = function (task, formatters, timeInterval) {
	                    if (timeInterval === void 0) { timeInterval = "Days"; }
	                    var tooltipDataArray = [];
	                    if (task.taskType)
	                        tooltipDataArray.push({ displayName: Gantt.capabilities.dataRoles[0].name, value: task.taskType });
	                    tooltipDataArray.push({ displayName: Gantt.capabilities.dataRoles[1].name, value: task.name });
	                    if (!isNaN(task.start.getDate()))
	                        tooltipDataArray.push({ displayName: Gantt.capabilities.dataRoles[2].name, value: formatters.startDateFormatter.format(task.start.toLocaleDateString()) });
	                    tooltipDataArray.push({ displayName: Gantt.capabilities.dataRoles[3].name, value: formatters.durationFormatter.format(task.duration) + " " + timeInterval });
	                    tooltipDataArray.push({ displayName: Gantt.capabilities.dataRoles[4].name, value: formatters.completionFormatter.format(task.completion) });
	                    if (task.resource)
	                        tooltipDataArray.push({ displayName: Gantt.capabilities.dataRoles[5].name, value: task.resource });
	                    return tooltipDataArray;
	                };
	                /**
	                * Check if task has data for task
	                * @param dataView
	                */
	                Gantt.isChartHasTask = function (dataView) {
	                    if (dataView.table &&
	                        dataView.table.columns) {
	                        for (var _i = 0, _a = dataView.table.columns; _i < _a.length; _i++) {
	                            var column = _a[_i];
	                            if (Gantt.hasRole(column, "Task")) {
	                                return true;
	                            }
	                        }
	                    }
	                    return false;
	                };
	                /**
	                 * Returns the chart formatters
	                 * @param dataView The data Model
	                 */
	                Gantt.getFormatters = function (dataView) {
	                    if (!dataView ||
	                        !dataView.metadata ||
	                        !dataView.metadata.columns)
	                        return null;
	                    var dateFormat = "d";
	                    var numberFormat = "#";
	                    for (var _i = 0, _a = dataView.metadata.columns; _i < _a.length; _i++) {
	                        var dvColumn = _a[_i];
	                        if (!!dataView.categorical.categories) {
	                            for (var _b = 0, _c = dataView.categorical.categories; _b < _c.length; _b++) {
	                                var dvCategory = _c[_b];
	                                if (Gantt.hasRole(dvCategory.source, "StartDate"))
	                                    dateFormat = dvColumn.format;
	                            }
	                        }
	                    }
	                    return {
	                        startDateFormatter: valueFormatter.create({ format: dateFormat }),
	                        durationFormatter: valueFormatter.create({ format: numberFormat }),
	                        completionFormatter: valueFormatter.create({ format: PercentFormat, value: 1, allowFormatBeautification: true })
	                    };
	                };
	                /**
	                * Create task objects dataView
	                * @param dataView The data Model.
	                * @param formatters task attributes represented format.
	                * @param series An array that holds the color data of different task groups.
	                */
	                Gantt.createTasks = function (dataView, formatters, colors) {
	                    var columnSource = dataView.table.columns;
	                    var data = dataView.table.rows;
	                    var categories = dataView.categorical.categories[0];
	                    var colorHelper = new ColorHelper(colors, undefined);
	                    return data.map(function (child, index) {
	                        var dateString = Gantt.getTaskProperty(columnSource, child, "StartDate");
	                        dateString = Gantt.isValidDate(dateString) ? dateString : new Date(Date.now());
	                        var duration = Gantt.getTaskProperty(columnSource, child, "Duration");
	                        var completionValue = Gantt.getTaskProperty(columnSource, child, "Completion");
	                        var completion = Gantt.convertToDecimal(completionValue);
	                        completion = completion <= 1 ? completion : 1;
	                        var taskType = Gantt.getTaskProperty(columnSource, child, "Legend");
	                        var tasksTypeColor = colorHelper.getColorForMeasure(dataView.metadata.objects, taskType);
	                        var task = {
	                            id: index,
	                            name: Gantt.getTaskProperty(columnSource, child, "Task"),
	                            start: dateString ? dateString : new Date(Date.now()),
	                            duration: duration > 0 ? duration : 1,
	                            end: null,
	                            completion: completion > 0 ? completion : 0,
	                            resource: Gantt.getTaskProperty(columnSource, child, "Resource"),
	                            taskType: taskType,
	                            color: tasksTypeColor ? tasksTypeColor : Gantt.DefaultValues.TaskColor,
	                            tooltipInfo: null,
	                            description: "",
	                            identity: SelectionId.createWithIdAndMeasure(categories.identity[index], taskType),
	                            selected: false
	                        };
	                        task.end = d3.time.day.offset(task.start, task.duration);
	                        task.tooltipInfo = Gantt.getTooltipInfo(task, formatters);
	                        return task;
	                    });
	                };
	                /**
	               * Create the gantt tasks series based on all task types
	               * @param taskTypes All unique types from the tasks array.
	               */
	                Gantt.createSeries = function (objects, tasks, dataView, colors) {
	                    var colorHelper = new ColorHelper(colors, undefined /*Gantt.Properties.dataPoint.fill*/);
	                    var taskGroup = _.groupBy(tasks, function (t) { return t.taskType; });
	                    var taskTypes = Gantt.getAllTasksTypes(dataView);
	                    var series = _.map(taskTypes.types, function (type) {
	                        return {
	                            tasks: taskGroup[type],
	                            fill: colorHelper.getColorForMeasure(objects, type),
	                            name: type,
	                            identity: SelectionId.createWithMeasure(type),
	                            selected: false
	                        };
	                    });
	                    return series;
	                };
	                /**
	                * Convert the dataView to view model
	                * @param dataView The data Model
	                */
	                Gantt.converter = function (dataView, colors) {
	                    if (!dataView
	                        || !dataView.categorical
	                        || !Gantt.isChartHasTask(dataView)
	                        || dataView.table.rows.length === 0) {
	                        return null;
	                    }
	                    var settings = Gantt.parseSettings(dataView, colors);
	                    var taskTypes = Gantt.getAllTasksTypes(dataView);
	                    var legendData = {
	                        fontSize: settings.legend.fontSize,
	                        dataPoints: [],
	                        title: taskTypes.typeName
	                    };
	                    var colorHelper = new ColorHelper(colors, undefined /*Gantt.Properties.dataPoint.fill*/);
	                    legendData.dataPoints = _.map(taskTypes.types, function (type) {
	                        return {
	                            label: type,
	                            color: colorHelper.getColorForMeasure(dataView.metadata.objects, type),
	                            icon: LegendIcon.Circle,
	                            selected: false,
	                            identity: SelectionId.createWithMeasure(type)
	                        };
	                    });
	                    var formatters = this.getFormatters(dataView);
	                    var tasks = Gantt.createTasks(dataView, formatters, colors);
	                    var series = Gantt.createSeries(dataView.metadata.objects, tasks, dataView, colors);
	                    var viewModel = {
	                        dataView: dataView,
	                        settings: settings,
	                        tasks: tasks,
	                        series: series,
	                        legendData: legendData,
	                        taskTypes: taskTypes,
	                    };
	                    return viewModel;
	                };
	                Gantt.parseSettings = function (dataView, colors) {
	                    var result = _.cloneDeep(Gantt.DefaultSettings);
	                    if (!dataView || !dataView.metadata || !dataView.metadata.objects) {
	                        return result;
	                    }
	                    var objects = dataView.metadata.objects;
	                    result.general.groupTasks = DataViewObjects.getValue(objects, Gantt.Properties.general.groupTasks, Gantt.DefaultSettings.general.groupTasks);
	                    result.taskLabels.show = DataViewObjects.getValue(objects, Gantt.Properties.taskLabels.show, Gantt.DefaultSettings.taskLabels.show);
	                    result.taskLabels.fill = DataViewObjects.getFillColor(objects, Gantt.Properties.taskLabels.fill, Gantt.DefaultSettings.taskLabels.fill);
	                    result.taskLabels.fontSize = DataViewObjects.getValue(objects, Gantt.Properties.taskLabels.fontSize, Gantt.DefaultSettings.taskLabels.fontSize);
	                    result.taskLabels.width = DataViewObjects.getValue(objects, Gantt.Properties.taskLabels.width, result.taskLabels.show ? Gantt.DefaultSettings.taskLabels.width : 0);
	                    result.taskCompletion.show = DataViewObjects.getValue(objects, Gantt.Properties.taskCompletion.show, Gantt.DefaultSettings.taskCompletion.show);
	                    delete result.taskCompletion.show;
	                    result.taskCompletion.fill = DataViewObjects.getFillColor(objects, Gantt.Properties.taskCompletion.fill, Gantt.DefaultSettings.taskCompletion.fill);
	                    result.taskResource.show = DataViewObjects.getValue(objects, Gantt.Properties.taskResource.show, Gantt.DefaultSettings.taskResource.show);
	                    result.taskResource.fontSize = DataViewObjects.getValue(objects, Gantt.Properties.taskResource.fontSize, Gantt.DefaultSettings.taskResource.fontSize);
	                    result.taskResource.fill = DataViewObjects.getFillColor(objects, Gantt.Properties.taskResource.fill, Gantt.DefaultSettings.taskResource.fill);
	                    result.dateType.type = DataViewObjects.getValue(objects, Gantt.Properties.dateType.type, Gantt.DefaultSettings.dateType.type);
	                    result.legend.show = DataViewObjects.getValue(objects, Gantt.Properties.legend.show, Gantt.DefaultSettings.legend.show);
	                    result.legend.fontSize = DataViewObjects.getValue(objects, Gantt.Properties.legend.fontSize, Gantt.DefaultSettings.legend.fontSize);
	                    result.legend.labelColor = DataViewObjects.getFillColor(objects, Gantt.Properties.legend.labelColor, Gantt.DefaultSettings.legend.labelColor);
	                    result.legend.position = DataViewObjects.getValue(objects, Gantt.Properties.legend.position, Gantt.DefaultSettings.legend.position);
	                    result.legend.showTitle = DataViewObjects.getValue(objects, Gantt.Properties.legend.showTitle, Gantt.DefaultSettings.legend.showTitle);
	                    result.legend.titleText = DataViewObjects.getValue(objects, Gantt.Properties.legend.titleText, Gantt.DefaultSettings.legend.titleText);
	                    return result;
	                };
	                Gantt.isValidDate = function (date) {
	                    if (Object.prototype.toString.call(date) !== "[object Date]")
	                        return false;
	                    return !isNaN(date.getTime());
	                };
	                Gantt.convertToDecimal = function (number) {
	                    if (!(number >= 0 && number <= 1))
	                        return (number / 100);
	                    return number;
	                };
	                /**
	                * Gets all unique types from the tasks array
	                * @param dataView The data model.
	                */
	                Gantt.getAllTasksTypes = function (dataView) {
	                    var types = [];
	                    var groupName = "";
	                    var taskTypes;
	                    var data = dataView.table.rows;
	                    var index = _.findIndex(dataView.table.columns, function (col) { return col.roles.hasOwnProperty("Legend"); });
	                    if (index !== -1) {
	                        groupName = dataView.table.columns[index].displayName;
	                        types = _.unique(data, function (d) { return d[index]; }).map(function (d) { return d[index]; });
	                    }
	                    taskTypes = {
	                        typeName: groupName,
	                        types: types
	                    };
	                    return taskTypes;
	                };
	                /**
	                 * Get legend data, calculate position and draw it
	                 */
	                Gantt.prototype.renderLegend = function () {
	                    if (!this.viewModel.legendData) {
	                        return;
	                    }
	                    LegendData.update(this.viewModel.legendData, DataViewObjects.getObject(this.viewModel.dataView.metadata.objects, "legend", {}));
	                    var position = this.viewModel.settings.legend.show
	                        ? LegendPosition[this.viewModel.settings.legend.position]
	                        : LegendPosition.None;
	                    this.legend.changeOrientation(position);
	                    this.legend.drawLegend(this.viewModel.legendData, _.clone(this.viewport));
	                    Legend.positionChartArea(this.ganttDiv, this.legend);
	                    switch (this.legend.getOrientation()) {
	                        case LegendPosition.Left:
	                        case LegendPosition.LeftCenter:
	                        case LegendPosition.Right:
	                        case LegendPosition.RightCenter:
	                            this.viewport.width -= this.legend.getMargins().width;
	                            break;
	                        case LegendPosition.Top:
	                        case LegendPosition.TopCenter:
	                        case LegendPosition.Bottom:
	                        case LegendPosition.BottomCenter:
	                            this.viewport.height -= this.legend.getMargins().height;
	                            break;
	                    }
	                };
	                /**
	                * Called on data change or resizing
	                * @param options The visual option that contains the dataview and the viewport
	                */
	                Gantt.prototype.update = function (options) {
	                    if (!options.dataViews || !options.dataViews[0]) {
	                        return;
	                    }
	                    this.viewModel = Gantt.converter(options.dataViews[0], this.colors);
	                    if (!this.viewModel) {
	                        this.clearViewport();
	                        return;
	                    }
	                    this.viewport = _.clone(options.viewport);
	                    this.margin = Gantt.DefaultMargin;
	                    this.renderLegend();
	                    this.updateChartSize();
	                    var tasks = this.viewModel.tasks;
	                    if (this.interactivityService) {
	                        this.interactivityService.applySelectionStateToData(tasks);
	                        this.interactivityService.applySelectionStateToData(this.viewModel.series);
	                    }
	                    if (tasks.length > 0) {
	                        var tasksSortedByStartDate = _.sortBy(tasks, function (t) { return t.start; });
	                        var tasksSortedByEndDate = _.sortBy(tasks, function (t) { return t.end; });
	                        var dateTypeMilliseconds = this.getDateType();
	                        var startDate = tasksSortedByStartDate[0].start, endDate = tasksSortedByEndDate[tasks.length - 1].end, ticks = Math.ceil(Math.round(endDate.valueOf() - startDate.valueOf()) / dateTypeMilliseconds);
	                        var groupedTasks = this.groupTasks(tasks);
	                        ticks = ticks === 0 || ticks === 1 ? 2 : ticks;
	                        var axisLength = ticks * 50;
	                        this.ganttSvg
	                            .attr({
	                            height: PixelConverter.toString(groupedTasks.length * ChartLineHeight + this.margin.top),
	                            width: PixelConverter.toString(this.margin.left + this.viewModel.settings.taskLabels.width + axisLength + Gantt.DefaultValues.ResourceWidth)
	                        });
	                        var viewportIn = {
	                            height: this.viewport.height,
	                            width: axisLength
	                        };
	                        var xAxisProperties = this.calculateAxes(viewportIn, this.textProperties, startDate, endDate, axisLength, ticks, false);
	                        this.timeScale = xAxisProperties.scale;
	                        this.renderAxis(xAxisProperties, 200);
	                        this.renderTasks(groupedTasks);
	                        this.createMilestoneLine(groupedTasks);
	                        this.updateTaskLabels(groupedTasks, this.viewModel.settings.taskLabels.width);
	                        this.updateElementsPositions(this.viewport, this.margin);
	                        if (this.interactivityService) {
	                            var behaviorOptions = {
	                                clearCatcher: this.clearCatcher,
	                                taskSelection: this.taskGroup.selectAll(Selectors.SingleTask.selector),
	                                legendSelection: this.body.selectAll(Selectors.LegendItems.selector),
	                                interactivityService: this.interactivityService
	                            };
	                            this.interactivityService.bind(tasks, this.behavior, behaviorOptions);
	                        }
	                    }
	                };
	                Gantt.prototype.getDateType = function () {
	                    var milliSeconds = MillisecondsInWeek;
	                    switch (this.viewModel.settings.dateType.type) {
	                        case "Day":
	                            milliSeconds = MillisecondsInADay;
	                            break;
	                        case "Week":
	                            milliSeconds = MillisecondsInWeek;
	                            break;
	                        case "Month":
	                            milliSeconds = MillisecondsInAMonth;
	                            break;
	                        case "Year":
	                            milliSeconds = MillisecondsInAYear;
	                            break;
	                    }
	                    return milliSeconds;
	                };
	                Gantt.prototype.calculateAxes = function (viewportIn, textProperties, startDate, endDate, axisLength, ticksCount, scrollbarVisible) {
	                    var dataTypeDatetime = ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Date);
	                    var category = { displayName: "StartDate", queryName: "StartDate", type: dataTypeDatetime, index: 0 };
	                    var visualOptions = {
	                        viewport: viewportIn,
	                        margin: this.margin,
	                        forcedXDomain: [startDate, endDate],
	                        forceMerge: false,
	                        showCategoryAxisLabel: false,
	                        showValueAxisLabel: false,
	                        categoryAxisScaleType: axisScale.linear,
	                        valueAxisScaleType: null,
	                        valueAxisDisplayUnits: 0,
	                        categoryAxisDisplayUnits: 0,
	                        trimOrdinalDataOnOverflow: false,
	                        forcedTickCount: ticksCount
	                    };
	                    var width = viewportIn.width;
	                    var axes = this.calculateAxesProperties(viewportIn, visualOptions, axisLength, category);
	                    axes.willLabelsFit = AxisHelper.LabelLayoutStrategy.willLabelsFit(axes, width, TextMeasurementService.measureSvgTextWidth, textProperties);
	                    // If labels do not fit and we are not scrolling, try word breaking
	                    axes.willLabelsWordBreak = (!axes.willLabelsFit && !scrollbarVisible) && AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(axes, this.margin, width, TextMeasurementService.measureSvgTextWidth, TextMeasurementService.estimateSvgTextHeight, TextMeasurementService.getTailoredTextOrDefault, textProperties);
	                    return axes;
	                };
	                Gantt.prototype.calculateAxesProperties = function (viewportIn, options, axisLength, metaDataColumn) {
	                    var _this = this;
	                    var xAxisProperties = AxisHelper.createAxis({
	                        pixelSpan: viewportIn.width,
	                        dataDomain: options.forcedXDomain,
	                        metaDataColumn: metaDataColumn,
	                        formatString: Gantt.DefaultValues.DateFormatStrings[this.viewModel.settings.dateType.type],
	                        outerPadding: 0,
	                        isScalar: true,
	                        isVertical: false,
	                        forcedTickCount: options.forcedTickCount,
	                        useTickIntervalForDisplayUnits: true,
	                        isCategoryAxis: true,
	                        getValueFn: function (index, type) {
	                            return valueFormatter.format(new Date(index), Gantt.DefaultValues.DateFormatStrings[_this.viewModel.settings.dateType.type]);
	                        },
	                        scaleType: options.categoryAxisScaleType,
	                        axisDisplayUnits: options.categoryAxisDisplayUnits,
	                    });
	                    xAxisProperties.axisLabel = metaDataColumn.displayName;
	                    return xAxisProperties;
	                };
	                Gantt.prototype.groupTasks = function (tasks) {
	                    if (this.viewModel.settings.general.groupTasks) {
	                        var groupedTasks = _.groupBy(tasks, function (x) { return x.name; });
	                        var result = _.map(groupedTasks, function (x, i) { return {
	                            name: i,
	                            tasks: groupedTasks[i]
	                        }; });
	                        result.forEach(function (x, i) {
	                            x.tasks.forEach(function (t) { return t.id = i; });
	                            x.id = i;
	                        });
	                        return result;
	                    }
	                    return tasks.map(function (x) { return {
	                        name: x.name,
	                        id: x.id,
	                        tasks: [x]
	                    }; });
	                };
	                Gantt.prototype.renderAxis = function (xAxisProperties, duration) {
	                    var xAxis = xAxisProperties.axis;
	                    xAxis.orient('bottom');
	                    this.axisGroup.transition().duration(duration).call(xAxis);
	                };
	                /**
	                * Update task labels and add its tooltips
	                * @param tasks All tasks array
	                * @param width The task label width
	                */
	                Gantt.prototype.updateTaskLabels = function (tasks, width) {
	                    var _this = this;
	                    var axisLabel;
	                    var taskLineCoordinateX = 15;
	                    var taskLabelsShow = this.viewModel ? this.viewModel.settings.taskLabels.show : true;
	                    var taskLabelsColor = this.viewModel ? this.viewModel.settings.taskLabels.fill : Gantt.DefaultSettings.taskLabels.fill;
	                    var taskLabelsFontSize = this.viewModel ? this.viewModel.settings.taskLabels.fontSize : Gantt.DefaultSettings.taskLabels.fontSize;
	                    if (taskLabelsShow) {
	                        axisLabel = this.lineGroup.selectAll(Selectors.Label.selector).data(tasks);
	                        axisLabel.enter().append("text").classed(Selectors.Label.class, true);
	                        axisLabel.attr({
	                            x: taskLineCoordinateX,
	                            y: function (task, i) { return _this.getTaskLabelCoordinateY(task.id); },
	                            fill: taskLabelsColor,
	                            "stroke-width": 1
	                        })
	                            .style("font-size", PixelConverter.fromPoint(taskLabelsFontSize))
	                            .text(function (task) { return task.name; });
	                        axisLabel.call(AxisHelper.LabelLayoutStrategy.clip, width - 20, TextMeasurementService.svgEllipsis);
	                        axisLabel.append("title").text(function (task) { return task.name; });
	                        axisLabel.exit().remove();
	                    }
	                    else {
	                        this.lineGroup.selectAll(Selectors.Label.selector).remove();
	                    }
	                };
	                Gantt.prototype.renderTasks = function (groupedTasks) {
	                    var _this = this;
	                    var taskGroupSelection = this.taskGroup.selectAll(Selectors.TaskGroup.selector).data(groupedTasks);
	                    var taskProgressColor = this.viewModel ? this.viewModel.settings.taskCompletion.fill : Gantt.DefaultSettings.taskCompletion.fill;
	                    var taskResourceShow = this.viewModel ? this.viewModel.settings.taskResource.show : true;
	                    var padding = 4;
	                    var taskResourceColor = this.viewModel ? this.viewModel.settings.taskResource.fill : Gantt.DefaultSettings.taskResource.fill;
	                    var taskResourceFontSize = this.viewModel ? this.viewModel.settings.taskResource.fontSize : Gantt.DefaultSettings.taskResource.fontSize;
	                    //render task group container 
	                    taskGroupSelection.enter().append("g").classed(Selectors.TaskGroup.class, true);
	                    var taskSelection = taskGroupSelection.selectAll(Selectors.SingleTask.selector).data(function (d) { return d.tasks; });
	                    taskSelection.enter().append("g").classed(Selectors.SingleTask.class, true);
	                    //render task main rect
	                    var taskRect = taskSelection.selectAll(Selectors.TaskRect.selector).data(function (d) { return [d]; });
	                    taskRect.enter().append("rect").classed(Selectors.TaskRect.class, true);
	                    taskRect.classed(Selectors.TaskRect.class, true).attr({
	                        x: function (task) { return _this.timeScale(task.start); },
	                        y: function (task) { return _this.getBarYCoordinate(task.id); },
	                        width: function (task) { return _this.taskDurationToWidth(task); },
	                        height: function () { return _this.getBarHeight(); }
	                    }).style("fill", function (task) { return task.color; });
	                    taskRect.exit().remove();
	                    //render task progress rect 
	                    var taskProgress = taskSelection.selectAll(Selectors.TaskProgress.selector).data(function (d) { return [d]; });
	                    taskProgress.enter().append("rect").classed(Selectors.TaskProgress.class, true);
	                    taskProgress.attr({
	                        x: function (task) { return _this.timeScale(task.start); },
	                        y: function (task) { return _this.getBarYCoordinate(task.id) + _this.getBarHeight() / 2 - Gantt.DefaultValues.ProgressBarHeight / 2; },
	                        width: function (task) { return _this.setTaskProgress(task); },
	                        height: Gantt.DefaultValues.ProgressBarHeight
	                    }).style("fill", taskProgressColor);
	                    taskProgress.exit().remove();
	                    if (taskResourceShow) {
	                        //render task resource labels
	                        var taskResource = taskSelection.selectAll(Selectors.TaskResource.selector).data(function (d) { return [d]; });
	                        taskResource.enter().append("text").classed(Selectors.TaskResource.class, true);
	                        taskResource.attr({
	                            x: function (task) { return _this.timeScale(task.end) + padding; },
	                            y: function (task) { return (_this.getBarYCoordinate(task.id) + (_this.getBarHeight() / 2) + padding); }
	                        })
	                            .text(function (task) { return task.resource; })
	                            .style({
	                            fill: taskResourceColor,
	                            "font-size": PixelConverter.fromPoint(taskResourceFontSize)
	                        }).call(AxisHelper.LabelLayoutStrategy.clip, Gantt.DefaultValues.ResourceWidth - 10, TextMeasurementService.svgEllipsis);
	                        taskResource.exit().remove();
	                    }
	                    else {
	                        taskSelection.selectAll(Selectors.TaskResource.selector).remove();
	                    }
	                    TooltipManager.addTooltip(taskSelection, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
	                    taskSelection.exit().remove();
	                    taskGroupSelection.exit().remove();
	                };
	                Gantt.prototype.onClearSelection = function () {
	                    this.selectionManager.clear();
	                };
	                /**
	                 * Returns the matching Y coordinate for a given task index
	                 * @param taskIndex Task Number
	                 */
	                Gantt.prototype.getTaskLabelCoordinateY = function (taskIndex) {
	                    var fontSize = +this.viewModel.settings.taskLabels.fontSize;
	                    return (ChartLineHeight * taskIndex) + (this.getBarHeight() + 5 - (40 - fontSize) / 4);
	                };
	                /**
	                 * Set the task progress bar in the gantt
	                 * @param task All task attributes
	                 */
	                Gantt.prototype.setTaskProgress = function (task) {
	                    var fraction = task.completion / 1.0, y = this.timeScale, progress = (y(task.end) - y(task.start)) * fraction;
	                    return progress;
	                };
	                /**
	                 * Set the task progress bar in the gantt
	                 * @param lineNumber Line number that represents the task number
	                 */
	                Gantt.prototype.getBarYCoordinate = function (lineNumber) {
	                    return (ChartLineHeight * lineNumber) + (PaddingTasks);
	                };
	                Gantt.prototype.getBarHeight = function () {
	                    return ChartLineHeight / 1.5;
	                };
	                /**
	                * convert task duration to width in the time scale
	                * @param task The task to convert
	                */
	                Gantt.prototype.taskDurationToWidth = function (task) {
	                    return this.timeScale(task.end) - this.timeScale(task.start);
	                };
	                Gantt.prototype.getTooltipForMilstoneLine = function (timestamp, milestoneTitle) {
	                    var stringDate = new Date(timestamp).toDateString();
	                    var tooltip = [{ displayName: milestoneTitle, value: stringDate }];
	                    return tooltip;
	                };
	                /**
	                * Create vertical dotted line that represent milestone in the time axis (by default it shows not time)
	                * @param tasks All tasks array
	                * @param timestamp the milestone to be shown in the time axis (default Date.now())
	                */
	                Gantt.prototype.createMilestoneLine = function (tasks, milestoneTitle, timestamp) {
	                    if (milestoneTitle === void 0) { milestoneTitle = "Today"; }
	                    if (timestamp === void 0) { timestamp = Date.now(); }
	                    var line = [{
	                            x1: this.timeScale(timestamp),
	                            y1: 0,
	                            x2: this.timeScale(timestamp),
	                            y2: this.getMilestoneLineLength(tasks.length),
	                            tooltipInfo: this.getTooltipForMilstoneLine(timestamp, milestoneTitle)
	                        }];
	                    var chartLineSelection = this.chartGroup.selectAll(Selectors.ChartLine.selector).data(line);
	                    chartLineSelection.enter().append("line").classed(Selectors.ChartLine.class, true);
	                    chartLineSelection.attr({
	                        x1: function (line) { return line.x1; },
	                        y1: function (line) { return line.y1; },
	                        x2: function (line) { return line.x2; },
	                        y2: function (line) { return line.y2; },
	                        tooltipInfo: function (line) { return line.tooltipInfo; }
	                    });
	                    TooltipManager.addTooltip(chartLineSelection, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
	                    chartLineSelection.exit().remove();
	                };
	                Gantt.prototype.updateElementsPositions = function (viewport, margin) {
	                    this.axisGroup.attr("transform", SVGUtil.translate(this.viewModel.settings.taskLabels.width + margin.left, 15));
	                    this.chartGroup.attr("transform", SVGUtil.translate(this.viewModel.settings.taskLabels.width + margin.left, margin.top));
	                    this.lineGroup.attr("transform", SVGUtil.translate(0, margin.top));
	                };
	                Gantt.prototype.getMilestoneLineLength = function (numOfTasks) {
	                    return numOfTasks * ChartLineHeight;
	                };
	                Gantt.prototype.enumerateGeneral = function (settings) {
	                    return [];
	                };
	                Gantt.prototype.enumerateLegend = function (settings) {
	                    return [{
	                            displayName: Gantt.Properties.legend.show.objectName,
	                            selector: null,
	                            properties: settings.legend,
	                            objectName: Gantt.Properties.legend.show.objectName
	                        }];
	                };
	                Gantt.prototype.enumerateDataPoints = function (settings) {
	                    return this.viewModel.series.map(function (item) { return {
	                        objectName: 'dataPoint',
	                        displayName: item.name,
	                        selector: ColorHelper.normalizeSelector(item.identity.getSelector(), false),
	                        properties: { fill: { solid: { color: item.fill } } }
	                    }; });
	                };
	                Gantt.prototype.enumerateTaskCompletion = function (settings) {
	                    return [{
	                            selector: null,
	                            properties: settings.taskCompletion,
	                            objectName: Gantt.Properties.taskCompletion.show.objectName
	                        }];
	                };
	                Gantt.prototype.enumerateTaskLabels = function (settings) {
	                    return [{
	                            selector: null,
	                            properties: settings.taskLabels,
	                            objectName: Gantt.Properties.taskLabels.show.objectName
	                        }];
	                };
	                Gantt.prototype.enumerateTaskResources = function (settings) {
	                    return [{
	                            selector: null,
	                            properties: settings.taskResource,
	                            objectName: Gantt.Properties.taskResource.show.objectName
	                        }];
	                };
	                Gantt.prototype.enumerateDateType = function (settings) {
	                    return [{
	                            selector: null,
	                            properties: settings.dateType,
	                            objectName: Gantt.Properties.dateType.type.objectName
	                        }];
	                };
	                Gantt.prototype.enumerateObjectInstances = function (options) {
	                    var settings = this.viewModel && this.viewModel.settings || Gantt.DefaultSettings;
	                    var enumeration = new ObjectEnumerationBuilder();
	                    var push = function (instances) { return instances.forEach(function (x) { return enumeration.pushInstance(x); }); };
	                    switch (options.objectName) {
	                        case 'general':
	                            push(this.enumerateGeneral(settings));
	                            break;
	                        case 'legend':
	                            push(this.enumerateLegend(settings));
	                            break;
	                        case 'dataPoint':
	                            push(this.enumerateDataPoints(settings));
	                            break;
	                        case 'taskLabels':
	                            push(this.enumerateTaskLabels(settings));
	                            break;
	                        case 'taskCompletion':
	                            push(this.enumerateTaskCompletion(settings));
	                            break;
	                        case 'taskResource':
	                            push(this.enumerateTaskResources(settings));
	                            break;
	                        case 'dateType':
	                            push(this.enumerateDateType(settings));
	                            break;
	                    }
	                    return enumeration.complete();
	                };
	                Gantt.DefaultSettings = {
	                    general: {
	                        groupTasks: false
	                    },
	                    legend: {
	                        show: true,
	                        position: legendPosition.right,
	                        showTitle: true,
	                        titleText: "",
	                        labelColor: "#000000",
	                        fontSize: 8,
	                    },
	                    taskLabels: {
	                        show: true,
	                        fill: "#000000",
	                        fontSize: 9,
	                        width: 110,
	                    },
	                    taskCompletion: {
	                        show: true,
	                        fill: "#000000",
	                    },
	                    taskResource: {
	                        show: true,
	                        fill: "#000000",
	                        fontSize: 9,
	                    },
	                    dateType: {
	                        type: GanttDateType.Week
	                    }
	                };
	                Gantt.DefaultValues = {
	                    AxisTickSize: 6,
	                    MaxTaskOpacity: 1,
	                    MinTaskOpacity: 0.4,
	                    ProgressBarHeight: 4,
	                    ResourceWidth: 100,
	                    TaskColor: "#00B099",
	                    TaskLineWidth: 15,
	                    DefaultDateType: GanttDateType.Week,
	                    DateFormatStrings: {
	                        Day: "MMM dd",
	                        Week: "MMM dd",
	                        Month: "MMM yyyy",
	                        Year: "yyyy"
	                    }
	                };
	                Gantt.capabilities = {
	                    dataRoles: [
	                        {
	                            name: "Legend",
	                            kind: VisualDataRoleKind.Grouping,
	                            displayName: "Legend",
	                        }, {
	                            name: "Task",
	                            kind: VisualDataRoleKind.Grouping,
	                            displayName: "Task"
	                        }, {
	                            name: "StartDate",
	                            kind: VisualDataRoleKind.Grouping,
	                            displayName: "Start Date",
	                        }, {
	                            name: "Duration",
	                            kind: VisualDataRoleKind.Measure,
	                            displayName: "Duration",
	                            requiredTypes: [{ numeric: true }, { integer: true }]
	                        }, {
	                            name: "Completion",
	                            kind: VisualDataRoleKind.Measure,
	                            displayName: "% Completion",
	                            requiredTypes: [{ numeric: true }, { integer: true }]
	                        }, {
	                            name: "Resource",
	                            kind: VisualDataRoleKind.Grouping,
	                            displayName: "Resource"
	                        }
	                    ],
	                    dataViewMappings: [{
	                            conditions: [
	                                {
	                                    "Legend": { min: 0, max: 1 },
	                                    "Task": { min: 1, max: 1 },
	                                    "StartDate": { min: 0, max: 0 },
	                                    "Duration": { min: 0, max: 0 },
	                                    "Completion": { min: 0, max: 0 },
	                                    "Resource": { min: 0, max: 0 }
	                                }, {
	                                    "Legend": { min: 0, max: 1 },
	                                    "Task": { min: 1, max: 1 },
	                                    "StartDate": { min: 0, max: 1 },
	                                    "Duration": { min: 0, max: 0 },
	                                    "Completion": { min: 0, max: 0 },
	                                    "Resource": { min: 0, max: 0 }
	                                }, {
	                                    "Legend": { min: 0, max: 1 },
	                                    "Task": { min: 0, max: 1 },
	                                    "StartDate": { min: 0, max: 1 },
	                                    "Duration": { min: 0, max: 1 },
	                                    "Completion": { min: 0, max: 1 },
	                                    "Resource": { min: 0, max: 1 },
	                                }
	                            ],
	                            table: {
	                                rows: {
	                                    select: [
	                                        { for: { in: "Legend" } },
	                                        { for: { in: "Task" } },
	                                        { for: { in: "StartDate" } },
	                                        { for: { in: "Duration" } },
	                                        { for: { in: "Completion" } },
	                                        { for: { in: "Resource" } },
	                                    ]
	                                },
	                            },
	                        }],
	                    objects: {
	                        general: {
	                            displayName: createDisplayNameGetter("Visual_General"),
	                            properties: {
	                                groupTasks: {
	                                    displayName: "Group Tasks",
	                                    type: { bool: true }
	                                }
	                            },
	                        },
	                        legend: {
	                            displayName: "Legend",
	                            description: "Display legend options",
	                            properties: {
	                                show: {
	                                    displayName: "Show",
	                                    type: { bool: true }
	                                },
	                                position: {
	                                    displayName: "Position",
	                                    description: "Select the location for the legend",
	                                    type: { enumeration: legendPosition.type }
	                                },
	                                showTitle: {
	                                    displayName: "Title",
	                                    description: "Display a title for legend symbols",
	                                    type: { bool: true }
	                                },
	                                titleText: {
	                                    displayName: "Legend Name",
	                                    description: "Title text",
	                                    type: { text: true },
	                                    suppressFormatPainterCopy: true
	                                },
	                                labelColor: {
	                                    displayName: "Color",
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                fontSize: {
	                                    displayName: "Text Size",
	                                    type: { formatting: { fontSize: true } }
	                                }
	                            }
	                        },
	                        taskLabels: {
	                            displayName: 'Category Labels',
	                            properties: {
	                                show: {
	                                    displayName: "Show",
	                                    type: { bool: true }
	                                },
	                                fill: {
	                                    displayName: 'Fill',
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                fontSize: {
	                                    displayName: 'Font Size',
	                                    type: { formatting: { fontSize: true } }
	                                },
	                                width: {
	                                    displayName: 'Width',
	                                    type: { numeric: true }
	                                }
	                            }
	                        },
	                        taskCompletion: {
	                            displayName: 'Task Completion',
	                            properties: {
	                                show: {
	                                    type: { bool: true }
	                                },
	                                fill: {
	                                    displayName: 'Completion Color',
	                                    type: { fill: { solid: { color: true } } }
	                                }
	                            }
	                        },
	                        taskResource: {
	                            displayName: 'Data Labels',
	                            properties: {
	                                show: {
	                                    displayName: "Show",
	                                    type: { bool: true }
	                                },
	                                fill: {
	                                    displayName: 'Color',
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                fontSize: {
	                                    displayName: 'Font Size',
	                                    type: { formatting: { fontSize: true } }
	                                }
	                            }
	                        },
	                        dateType: {
	                            displayName: 'Gantt Date Type',
	                            properties: {
	                                type: {
	                                    displayName: "Type",
	                                    type: { enumeration: createEnumTypeFromEnum(GanttDateType) }
	                                },
	                            }
	                        },
	                    },
	                    sorting: {
	                        default: {},
	                    },
	                };
	                Gantt.Properties = Gantt.getProperties(Gantt.capabilities);
	                return Gantt;
	            }());
	            samples.Gantt = Gantt;
	            var GanttChartBehavior = (function () {
	                function GanttChartBehavior() {
	                }
	                GanttChartBehavior.prototype.bindEvents = function (options, selectionHandler) {
	                    this.options = options;
	                    var clearCatcher = options.clearCatcher;
	                    options.taskSelection.on('click', function (d) {
	                        selectionHandler.handleSelection(d, d3.event.ctrlKey);
	                        d3.event.stopPropagation();
	                    });
	                    clearCatcher.on('click', function () {
	                        selectionHandler.handleClearSelection();
	                    });
	                };
	                GanttChartBehavior.prototype.renderSelection = function (hasSelection) {
	                    this.options.taskSelection.style("opacity", function (d) {
	                        return (hasSelection && !d.selected) ? Gantt.DefaultValues.MinTaskOpacity : Gantt.DefaultValues.MaxTaskOpacity;
	                    });
	                };
	                return GanttChartBehavior;
	            }());
	            samples.GanttChartBehavior = GanttChartBehavior;
	            var GanttChartWarning = (function () {
	                function GanttChartWarning() {
	                }
	                Object.defineProperty(GanttChartWarning.prototype, "code", {
	                    get: function () {
	                        return "GanttChartWarning";
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                GanttChartWarning.prototype.getMessages = function (resourceProvider) {
	                    var message = "This visual requires task value", titleKey = "", detailKey = "", visualMessage;
	                    visualMessage = {
	                        message: message,
	                        title: resourceProvider.get(titleKey),
	                        detail: resourceProvider.get(detailKey)
	                    };
	                    return visualMessage;
	                };
	                return GanttChartWarning;
	            }());
	            samples.GanttChartWarning = GanttChartWarning;
	        })(samples = visuals.samples || (visuals.samples = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 53 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	*  Power BI Visualizations
	*
	*  Copyright (c) Microsoft Corporation
	*  All rights reserved.
	*  MIT License
	*
	*  Permission is hereby granted, free of charge, to any person obtaining a copy
	*  of this software and associated documentation files (the ""Software""), to deal
	*  in the Software without restriction, including without limitation the rights
	*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	*  copies of the Software, and to permit persons to whom the Software is
	*  furnished to do so, subject to the following conditions:
	*
	*  The above copyright notice and this permission notice shall be included in
	*  all copies or substantial portions of the Software.
	*
	*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	*  THE SOFTWARE.
	*/
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/// <reference path="../../../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var samples;
	        (function (samples) {
	            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
	            var SelectionManager = visuals.utility.SelectionManager;
	            var px = jsCommon.PixelConverter.toString;
	            var pt = jsCommon.PixelConverter.fromPoint;
	            var fromPointToPixel = jsCommon.PixelConverter.fromPointToPixel;
	            samples.Months = powerbi.createEnumType([
	                { value: 1, displayName: 'January' },
	                { value: 2, displayName: 'February' },
	                { value: 3, displayName: 'March' },
	                { value: 4, displayName: 'April' },
	                { value: 5, displayName: 'May' },
	                { value: 6, displayName: 'June' },
	                { value: 7, displayName: 'July' },
	                { value: 8, displayName: 'August' },
	                { value: 9, displayName: 'September' },
	                { value: 10, displayName: 'October' },
	                { value: 11, displayName: 'November' },
	                { value: 12, displayName: 'December' }
	            ]);
	            samples.WeekDays = powerbi.createEnumType([
	                { value: 0, displayName: 'Sunday' },
	                { value: 1, displayName: 'Monday' },
	                { value: 2, displayName: 'Tuesday' },
	                { value: 3, displayName: 'Wednesday' },
	                { value: 4, displayName: 'Thursday' },
	                { value: 5, displayName: 'Friday' },
	                { value: 6, displayName: 'Saturday' }
	            ]);
	            (function (GranularityType) {
	                GranularityType[GranularityType["year"] = 0] = "year";
	                GranularityType[GranularityType["quarter"] = 1] = "quarter";
	                GranularityType[GranularityType["month"] = 2] = "month";
	                GranularityType[GranularityType["week"] = 3] = "week";
	                GranularityType[GranularityType["day"] = 4] = "day";
	            })(samples.GranularityType || (samples.GranularityType = {}));
	            var GranularityType = samples.GranularityType;
	            var SelectedCellColorProp = { objectName: 'cells', propertyName: 'fillSelected' };
	            var UnselectedCellColorProp = { objectName: 'cells', propertyName: 'fillUnselected' };
	            var ScaleColorProp = { objectName: 'granularity', propertyName: 'scaleColor' };
	            var SliderColorProp = { objectName: 'granularity', propertyName: 'sliderColor' };
	            var TimeRangeColorProp = { objectName: 'rangeHeader', propertyName: 'fontColor' };
	            var TimeRangeSizeProp = { objectName: 'rangeHeader', propertyName: 'textSize' };
	            var TimeRangeShowProp = { objectName: 'rangeHeader', propertyName: 'show' };
	            var LabelsColorProp = { objectName: 'labels', propertyName: 'fontColor' };
	            var LabelsSizeProp = { objectName: 'labels', propertyName: 'textSize' };
	            var LabelsShowProp = { objectName: 'labels', propertyName: 'show' };
	            var CalendarMonthProp = { objectName: 'calendar', propertyName: 'month' };
	            var CalendarDayProp = { objectName: 'calendar', propertyName: 'day' };
	            var WeekDayProp = { objectName: 'weekDay', propertyName: 'day' };
	            var GranularityNames = [
	                {
	                    granularityType: GranularityType.year,
	                    name: "year"
	                }, {
	                    granularityType: GranularityType.quarter,
	                    name: "quarter"
	                }, {
	                    granularityType: GranularityType.month,
	                    name: "month"
	                }, {
	                    granularityType: GranularityType.week,
	                    name: "week"
	                }, {
	                    granularityType: GranularityType.day,
	                    name: "day"
	                }];
	            var TimelineGranularity = (function () {
	                function TimelineGranularity() {
	                    this.datePeriods = [];
	                }
	                /**
	                * Returns the short month name of the given date (e.g. Jan, Feb, Mar)
	                */
	                TimelineGranularity.prototype.shortMonthName = function (date) {
	                    return date.toString().split(' ')[1];
	                };
	                TimelineGranularity.prototype.resetDatePeriods = function () {
	                    this.datePeriods = [];
	                };
	                TimelineGranularity.prototype.getDatePeriods = function () {
	                    return this.datePeriods;
	                };
	                TimelineGranularity.prototype.getExtendedLabel = function () {
	                    return this.extendedLabel;
	                };
	                TimelineGranularity.prototype.setExtendedLabel = function (extendedLabel) {
	                    this.extendedLabel = extendedLabel;
	                };
	                TimelineGranularity.prototype.createLabels = function (granularity) {
	                    var labels = [];
	                    var lastDatePeriod;
	                    _.map(this.datePeriods, function (x) {
	                        if (_.isEmpty(labels) || !granularity.sameLabel(x, lastDatePeriod)) {
	                            lastDatePeriod = x;
	                            labels.push(granularity.generateLabel(x));
	                        }
	                    });
	                    return labels;
	                };
	                /**
	                * Adds the new date into the given datePeriods array
	                * If the date corresponds to the last date period, given the current granularity,
	                * it will be added to that date period. Otherwise, a new date period will be added to the array.
	                * i.e. using Month granularity, Feb 2 2015 corresponds to Feb 3 2015.
	                * It is assumed that the given date does not correspond to previous date periods, other than the last date period
	                */
	                TimelineGranularity.prototype.addDate = function (date, identifierArray) {
	                    var datePeriods = this.getDatePeriods();
	                    var lastDatePeriod = datePeriods[datePeriods.length - 1];
	                    if (datePeriods.length === 0 || !_.isEqual(lastDatePeriod.identifierArray, identifierArray)) {
	                        if (datePeriods.length > 0)
	                            lastDatePeriod.endDate = date;
	                        datePeriods.push({
	                            identifierArray: identifierArray,
	                            startDate: date,
	                            endDate: date,
	                            week: this.determineWeek(date),
	                            year: this.determineYear(date),
	                            fraction: 1,
	                            index: datePeriods.length
	                        });
	                    }
	                    else
	                        lastDatePeriod.endDate = date;
	                };
	                TimelineGranularity.prototype.setNewEndDate = function (date) {
	                    _.last(this.datePeriods).endDate = date;
	                };
	                /**
	                 * Splits a given period into two periods.
	                 * The new period is added after the index of the old one, while the old one is simply updated.
	                 * @param index The index of the date priod to be split
	                 * @param newFraction The fraction value of the new date period
	                 * @param newDate The date in which the date period is split
	                 */
	                TimelineGranularity.prototype.splitPeriod = function (index, newFraction, newDate) {
	                    var oldDatePeriod = this.datePeriods[index];
	                    oldDatePeriod.fraction -= newFraction;
	                    var newDateObject = {
	                        identifierArray: oldDatePeriod.identifierArray,
	                        startDate: newDate,
	                        endDate: oldDatePeriod.endDate,
	                        week: this.determineWeek(newDate),
	                        year: this.determineYear(newDate),
	                        fraction: newFraction,
	                        index: oldDatePeriod.index + oldDatePeriod.fraction
	                    };
	                    oldDatePeriod.endDate = newDate;
	                    this.datePeriods.splice(index + 1, 0, newDateObject);
	                };
	                TimelineGranularity.prototype.previousMonth = function (month) {
	                    return (month > 0) ? month - 1 : 11;
	                };
	                TimelineGranularity.prototype.nextMonth = function (month) {
	                    return (month < 11) ? month + 1 : 0;
	                };
	                TimelineGranularity.prototype.countWeeks = function (startDate, endDate) {
	                    var totalDays;
	                    if (endDate.getFullYear() === startDate.getFullYear() && endDate.getMonth() === startDate.getMonth() && endDate.getDate() >= startDate.getDate())
	                        totalDays = endDate.getDate() - startDate.getDate();
	                    else {
	                        totalDays = endDate.getDate() - 1;
	                        var lastMonth = this.nextMonth(startDate.getMonth());
	                        var month = endDate.getMonth();
	                        while (month !== lastMonth) {
	                            totalDays += new Date(endDate.getFullYear(), month, 0).getDate();
	                            month = this.previousMonth(month);
	                        }
	                        totalDays += new Date(endDate.getFullYear(), lastMonth, 0).getDate() - startDate.getDate();
	                    }
	                    return 1 + Math.floor(totalDays / 7);
	                };
	                TimelineGranularity.prototype.determineWeek = function (date) {
	                    var year = date.getFullYear();
	                    if (this.inPreviousYear(date))
	                        year--;
	                    var dateOfFirstWeek = Timeline.calendar.getDateOfFirstWeek(year);
	                    var weeks = this.countWeeks(dateOfFirstWeek, date);
	                    return [weeks, year];
	                };
	                TimelineGranularity.prototype.inPreviousYear = function (date) {
	                    var dateOfFirstWeek = Timeline.calendar.getDateOfFirstWeek(date.getFullYear());
	                    return date < dateOfFirstWeek;
	                };
	                TimelineGranularity.prototype.determineYear = function (date) {
	                    var firstDay = new Date(date.getFullYear(), Timeline.calendar.getFirstMonthOfYear(), Timeline.calendar.getFirstDayOfYear());
	                    return date.getFullYear() - ((firstDay <= date) ? 0 : 1);
	                };
	                return TimelineGranularity;
	            }());
	            samples.TimelineGranularity = TimelineGranularity;
	            var DayGranularity = (function (_super) {
	                __extends(DayGranularity, _super);
	                function DayGranularity() {
	                    _super.apply(this, arguments);
	                }
	                DayGranularity.prototype.getType = function () {
	                    return GranularityType.day;
	                };
	                DayGranularity.prototype.splitDate = function (date) {
	                    return [this.shortMonthName(date), date.getDate(), date.getFullYear()];
	                };
	                DayGranularity.prototype.sameLabel = function (firstDatePeriod, secondDatePeriod) {
	                    return firstDatePeriod.startDate.getTime() === secondDatePeriod.startDate.getTime();
	                };
	                DayGranularity.prototype.generateLabel = function (datePeriod) {
	                    return {
	                        title: this.shortMonthName(datePeriod.startDate) + ' ' + datePeriod.startDate.getDate() + ' - ' + datePeriod.year,
	                        text: datePeriod.startDate.getDate().toString(),
	                        id: datePeriod.index
	                    };
	                };
	                return DayGranularity;
	            }(TimelineGranularity));
	            samples.DayGranularity = DayGranularity;
	            var MonthGranularity = (function (_super) {
	                __extends(MonthGranularity, _super);
	                function MonthGranularity() {
	                    _super.apply(this, arguments);
	                }
	                MonthGranularity.prototype.getType = function () {
	                    return GranularityType.month;
	                };
	                MonthGranularity.prototype.splitDate = function (date) {
	                    return [this.shortMonthName(date), date.getFullYear()];
	                };
	                MonthGranularity.prototype.sameLabel = function (firstDatePeriod, secondDatePeriod) {
	                    return this.shortMonthName(firstDatePeriod.startDate) === this.shortMonthName(secondDatePeriod.startDate);
	                };
	                MonthGranularity.prototype.generateLabel = function (datePeriod) {
	                    var shortMonthName = this.shortMonthName(datePeriod.startDate);
	                    return {
	                        title: shortMonthName,
	                        text: shortMonthName,
	                        id: datePeriod.index
	                    };
	                };
	                return MonthGranularity;
	            }(TimelineGranularity));
	            samples.MonthGranularity = MonthGranularity;
	            var WeekGranularity = (function (_super) {
	                __extends(WeekGranularity, _super);
	                function WeekGranularity() {
	                    _super.apply(this, arguments);
	                }
	                WeekGranularity.prototype.getType = function () {
	                    return GranularityType.week;
	                };
	                WeekGranularity.prototype.splitDate = function (date) {
	                    return this.determineWeek(date);
	                };
	                WeekGranularity.prototype.sameLabel = function (firstDatePeriod, secondDatePeriod) {
	                    return _.isEqual(firstDatePeriod.week, secondDatePeriod.week);
	                };
	                WeekGranularity.prototype.generateLabel = function (datePeriod) {
	                    return {
	                        title: 'Week ' + datePeriod.week[0] + ' - ' + datePeriod.week[1],
	                        text: 'W' + datePeriod.week[0],
	                        id: datePeriod.index
	                    };
	                };
	                return WeekGranularity;
	            }(TimelineGranularity));
	            samples.WeekGranularity = WeekGranularity;
	            var QuarterGranularity = (function (_super) {
	                __extends(QuarterGranularity, _super);
	                function QuarterGranularity() {
	                    _super.apply(this, arguments);
	                }
	                /**
	                 * Returns the date's quarter name (e.g. Q1, Q2, Q3, Q4)
	                 * @param date A date
	                 */
	                QuarterGranularity.prototype.quarterText = function (date) {
	                    var quarter = 3;
	                    var year = date.getFullYear();
	                    while (date < Timeline.calendar.getQuarterStartDate(year, quarter))
	                        if (quarter > 0)
	                            quarter--;
	                        else {
	                            quarter = 3;
	                            year--;
	                        }
	                    quarter++;
	                    return 'Q' + quarter;
	                };
	                QuarterGranularity.prototype.getType = function () {
	                    return GranularityType.quarter;
	                };
	                QuarterGranularity.prototype.splitDate = function (date) {
	                    return [this.quarterText(date), date.getFullYear()];
	                };
	                QuarterGranularity.prototype.sameLabel = function (firstDatePeriod, secondDatePeriod) {
	                    return this.quarterText(firstDatePeriod.startDate) === this.quarterText(secondDatePeriod.startDate)
	                        && firstDatePeriod.year === secondDatePeriod.year;
	                };
	                QuarterGranularity.prototype.generateLabel = function (datePeriod) {
	                    var quarter = this.quarterText(datePeriod.startDate);
	                    return {
	                        title: quarter + ' ' + datePeriod.year,
	                        text: quarter,
	                        id: datePeriod.index
	                    };
	                };
	                return QuarterGranularity;
	            }(TimelineGranularity));
	            samples.QuarterGranularity = QuarterGranularity;
	            var YearGranularity = (function (_super) {
	                __extends(YearGranularity, _super);
	                function YearGranularity() {
	                    _super.apply(this, arguments);
	                }
	                YearGranularity.prototype.getType = function () {
	                    return GranularityType.year;
	                };
	                YearGranularity.prototype.splitDate = function (date) {
	                    return [date.getFullYear()];
	                };
	                YearGranularity.prototype.sameLabel = function (firstDatePeriod, secondDatePeriod) {
	                    return firstDatePeriod.year === secondDatePeriod.year;
	                };
	                YearGranularity.prototype.generateLabel = function (datePeriod) {
	                    return {
	                        title: 'Year ' + datePeriod.year,
	                        text: datePeriod.year.toString(),
	                        id: datePeriod.index
	                    };
	                };
	                return YearGranularity;
	            }(TimelineGranularity));
	            samples.YearGranularity = YearGranularity;
	            var TimelineGranularityData = (function () {
	                function TimelineGranularityData(startDate, endDate) {
	                    this.granularities = [];
	                    this.setDatesRange(startDate, endDate);
	                    var lastDate = this.dates[this.dates.length - 1];
	                    this.endingDate = TimelineGranularityData.nextDay(lastDate);
	                }
	                /**
	                 * Returns the date of the previos day
	                 * @param date The following date
	                 */
	                TimelineGranularityData.previousDay = function (date) {
	                    var prevDay = new Date(date.getTime());
	                    prevDay.setDate(prevDay.getDate() - 1);
	                    return prevDay;
	                };
	                /**
	                 * Returns the date of the next day
	                 * @param date The previous date
	                 */
	                TimelineGranularityData.nextDay = function (date) {
	                    var nextDay = new Date(date.getTime());
	                    nextDay.setDate(nextDay.getDate() + 1);
	                    return nextDay;
	                };
	                /**
	                * Returns an array of dates with all the days between the start date and the end date
	                */
	                TimelineGranularityData.prototype.setDatesRange = function (startDate, endDate) {
	                    this.dates = [];
	                    var date = startDate;
	                    while (date <= endDate) {
	                        this.dates.push(date);
	                        date = TimelineGranularityData.nextDay(date);
	                    }
	                };
	                /**
	                 * Adds a new granularity to the array of granularities.
	                 * Resets the new granularity, adds all dates to it, and then edits the last date period with the ending date.
	                 * @param granularity The new granularity to be added
	                 */
	                TimelineGranularityData.prototype.addGranularity = function (granularity) {
	                    granularity.resetDatePeriods();
	                    for (var _i = 0, _a = this.dates; _i < _a.length; _i++) {
	                        var date = _a[_i];
	                        var identifierArray = granularity.splitDate(date);
	                        granularity.addDate(date, identifierArray);
	                    }
	                    granularity.setNewEndDate(this.endingDate);
	                    this.granularities.push(granularity);
	                };
	                /**
	                 * Returns a specific granularity from the array of granularities
	                 * @param index The index of the requested granularity
	                 */
	                TimelineGranularityData.prototype.getGranularity = function (index) {
	                    return this.granularities[index];
	                };
	                TimelineGranularityData.prototype.createGranularities = function () {
	                    this.granularities = [];
	                    this.addGranularity(new YearGranularity());
	                    this.addGranularity(new QuarterGranularity());
	                    this.addGranularity(new MonthGranularity());
	                    this.addGranularity(new WeekGranularity());
	                    this.addGranularity(new DayGranularity());
	                };
	                TimelineGranularityData.prototype.createLabels = function () {
	                    var _this = this;
	                    this.granularities.forEach(function (x) {
	                        x.setExtendedLabel({
	                            dayLabels: x.getType() >= GranularityType.day ? x.createLabels(_this.granularities[GranularityType.day]) : [],
	                            weekLabels: x.getType() >= GranularityType.week ? x.createLabels(_this.granularities[GranularityType.week]) : [],
	                            monthLabels: x.getType() >= GranularityType.month ? x.createLabels(_this.granularities[GranularityType.month]) : [],
	                            quarterLabels: x.getType() >= GranularityType.quarter ? x.createLabels(_this.granularities[GranularityType.quarter]) : [],
	                            yearLabels: x.getType() >= GranularityType.year ? x.createLabels(_this.granularities[GranularityType.year]) : [],
	                        });
	                    });
	                };
	                return TimelineGranularityData;
	            }());
	            samples.TimelineGranularityData = TimelineGranularityData;
	            var Utils = (function () {
	                function Utils() {
	                }
	                /**
	                 * Returns the date of the start of the selection
	                 * @param timelineData The TimelineData which contains all the date periods
	                 */
	                Utils.getStartSelectionDate = function (timelineData) {
	                    return timelineData.currentGranularity.getDatePeriods()[timelineData.selectionStartIndex].startDate;
	                };
	                /**
	                 * Returns the date of the end of the selection
	                 * @param timelineData The TimelineData which contains all the date periods
	                 */
	                Utils.getEndSelectionDate = function (timelineData) {
	                    return timelineData.currentGranularity.getDatePeriods()[timelineData.selectionEndIndex].endDate;
	                };
	                /**
	                 * Returns the date period of the end of the selection
	                 * @param timelineData The TimelineData which contains all the date periods
	                 */
	                Utils.getEndSelectionPeriod = function (timelineData) {
	                    return timelineData.currentGranularity.getDatePeriods()[timelineData.selectionEndIndex];
	                };
	                /**
	                 * Returns the color of a cell, depending on whether its date period is between the selected date periods.
	                 * CellRects should be transparent filled by default if there isn't any color sets.
	                 * @param d The TimelineDataPoint of the cell
	                 * @param timelineData The TimelineData with the selected date periods
	                 * @param timelineFormat The TimelineFormat with the chosen colors
	                 */
	                Utils.getCellColor = function (d, timelineData, cellFormat) {
	                    var inSelectedPeriods = d.datePeriod.startDate >= Utils.getStartSelectionDate(timelineData) && d.datePeriod.endDate <= Utils.getEndSelectionDate(timelineData);
	                    return inSelectedPeriods ? cellFormat.colorInProperty : (cellFormat.colorOutProperty || 'transparent');
	                };
	                /**
	                 * Returns the granularity type of the given granularity name
	                 * @param granularityName The name of the granularity
	                 */
	                Utils.getGranularityType = function (granularityName) {
	                    var index = _.findIndex(GranularityNames, function (x) { return x.name === granularityName; });
	                    return GranularityNames[index].granularityType;
	                };
	                /**
	                 * Returns the name of the granularity type
	                 * @param granularity The type of granularity
	                 */
	                Utils.getGranularityName = function (granularity) {
	                    var index = _.findIndex(GranularityNames, function (x) { return x.granularityType === granularity; });
	                    return GranularityNames[index].name;
	                };
	                /**
	                 * Splits the date periods of the current granularity, in case the stard and end of the selection is in between a date period.
	                 * i.e. for a quarter granularity and a selection between Feb 6 and Dec 23, the date periods for Q1 and Q4 will be split accordingly
	                 * @param timelineData The TimelineData that contains the date periods
	                 * @param startDate The starting date of the selection
	                 * @param endDate The ending date of the selection
	                 */
	                Utils.separateSelection = function (timelineData, startDate, endDate) {
	                    var datePeriods = timelineData.currentGranularity.getDatePeriods();
	                    var startDateIndex = _.findIndex(datePeriods, function (x) { return startDate < x.endDate; });
	                    var endDateIndex = _.findIndex(datePeriods, function (x) { return endDate <= x.endDate; });
	                    timelineData.selectionStartIndex = startDateIndex;
	                    timelineData.selectionEndIndex = endDateIndex;
	                    var startRatio = Utils.getDateRatio(datePeriods[startDateIndex], startDate, true);
	                    var endRatio = Utils.getDateRatio(datePeriods[endDateIndex], endDate, false);
	                    if (endRatio > 0)
	                        timelineData.currentGranularity.splitPeriod(endDateIndex, endRatio, endDate);
	                    if (startRatio > 0) {
	                        var startFration = datePeriods[startDateIndex].fraction - startRatio;
	                        timelineData.currentGranularity.splitPeriod(startDateIndex, startFration, startDate);
	                        timelineData.selectionStartIndex++;
	                        timelineData.selectionEndIndex++;
	                    }
	                };
	                /**
	                 * Returns the ratio of the given date compared to the whole date period.
	                 * The ratio is calculated either from the start or the end of the date period.
	                 * i.e. the ratio of Feb 7 2016 compared to the month of Feb 2016,
	                 * is 0.2142 from the start of the month, or 0.7857 from the end of the month.
	                 * @param datePeriod The date period that contain the specified date
	                 * @param date The date
	                 * @param fromStart Whether to calculater the ratio from the start of the date period.
	                 */
	                Utils.getDateRatio = function (datePeriod, date, fromStart) {
	                    var dateDifference = fromStart ? date.getTime() - datePeriod.startDate.getTime() : datePeriod.endDate.getTime() - date.getTime();
	                    var periodDifference = datePeriod.endDate.getTime() - datePeriod.startDate.getTime();
	                    return periodDifference === 0 ? 0 : dateDifference / periodDifference;
	                };
	                /**
	                * Returns the time range text, depending on the given granularity (e.g. "Feb 3 2014 - Apr 5 2015", "Q1 2014 - Q2 2015")
	                */
	                Utils.timeRangeText = function (timelineData) {
	                    var startSelectionDateArray = timelineData.currentGranularity.splitDate(Utils.getStartSelectionDate(timelineData));
	                    var endSelectionDateArray = timelineData.currentGranularity.splitDate(Utils.getEndSelectionPeriod(timelineData).startDate);
	                    return startSelectionDateArray.join(' ') + ' - ' + endSelectionDateArray.join(' ');
	                };
	                Utils.dateRangeText = function (datePeriod) {
	                    return datePeriod.startDate.toDateString() + ' - ' + TimelineGranularityData.previousDay(datePeriod.endDate).toDateString();
	                };
	                /**
	                 * Combines the first two partial date periods, into a single date period.
	                 * Returns whether a partial date period was found.
	                 * i.e. combines "Feb 1 2016 - Feb 5 2016" with "Feb 5 2016 - Feb 29 2016" into "Feb 1 2016 - Feb 29 2016"
	                 * @param datePeriods The list of date periods
	                 */
	                Utils.unseparateSelection = function (datePeriods) {
	                    var separationIndex = _.findIndex(datePeriods, function (x) { return x.fraction < 1; });
	                    if (separationIndex >= 0) {
	                        datePeriods[separationIndex].endDate = datePeriods[separationIndex + 1].endDate;
	                        datePeriods[separationIndex].fraction += datePeriods[separationIndex + 1].fraction;
	                        datePeriods.splice(separationIndex + 1, 1);
	                        return true;
	                    }
	                    return false;
	                };
	                return Utils;
	            }());
	            samples.Utils = Utils;
	            var Calendar = (function () {
	                function Calendar(calendarFormat) {
	                    var _this = this;
	                    this.firstDayOfWeek = calendarFormat.weekDayProperty;
	                    this.firstMonthOfYear = calendarFormat.firstMonthProperty - 1;
	                    this.firstDayOfYear = calendarFormat.firstDayProperty;
	                    this.dateOfFirstWeek = {};
	                    this.quarterFirstMonths = [0, 3, 6, 9].map(function (x) { return x + _this.firstMonthOfYear; });
	                }
	                Calendar.prototype.getFirstDayOfWeek = function () {
	                    return this.firstDayOfWeek;
	                };
	                Calendar.prototype.getFirstMonthOfYear = function () {
	                    return this.firstMonthOfYear;
	                };
	                Calendar.prototype.getFirstDayOfYear = function () {
	                    return this.firstDayOfYear;
	                };
	                Calendar.prototype.getQuarterStartDate = function (year, quarterIndex) {
	                    return new Date(year, this.quarterFirstMonths[quarterIndex], this.firstDayOfYear);
	                };
	                Calendar.prototype.isChanged = function (calendarFormat) {
	                    return this.firstMonthOfYear !== (calendarFormat.firstMonthProperty - 1)
	                        || this.firstDayOfYear !== calendarFormat.firstDayProperty
	                        || this.firstDayOfWeek !== calendarFormat.weekDayProperty;
	                };
	                Calendar.prototype.calculateDateOfFirstWeek = function (year) {
	                    var date = new Date(year, this.firstMonthOfYear, this.firstDayOfYear);
	                    while (date.getDay() !== this.firstDayOfWeek)
	                        date = TimelineGranularityData.nextDay(date);
	                    return date;
	                };
	                Calendar.prototype.getDateOfFirstWeek = function (year) {
	                    if (!this.dateOfFirstWeek[year])
	                        this.dateOfFirstWeek[year] = this.calculateDateOfFirstWeek(year);
	                    return this.dateOfFirstWeek[year];
	                };
	                return Calendar;
	            }());
	            samples.Calendar = Calendar;
	            var Timeline = (function () {
	                function Timeline() {
	                    var _this = this;
	                    this.requiresNoUpdate = false;
	                    this.datasetsChangedState = false;
	                    this.selector = ['Y', 'Q', 'M', 'W', 'D'];
	                    this.timelineMargins = {
	                        LeftMargin: 15,
	                        RightMargin: 15,
	                        TopMargin: 15,
	                        BottomMargin: 10,
	                        CellWidth: 40,
	                        CellHeight: 25,
	                        StartXpoint: 10,
	                        StartYpoint: 20,
	                        ElementWidth: 30,
	                        MinCellWidth: 30,
	                        MaxCellHeight: 60,
	                        PeriodSlicerRectWidth: 15,
	                        PeriodSlicerRectHeight: 23
	                    };
	                    this.defaultTimelineProperties = {
	                        DefaultLabelsShow: true,
	                        TimelineDefaultTextSize: 9,
	                        TimelineDefaultCellColor: "#ADD8E6",
	                        TimelineDefaultCellColorOut: "",
	                        TimelineDefaultTimeRangeShow: true,
	                        DefaultTimeRangeColor: "#777777",
	                        DefaultLabelColor: "#777777",
	                        DefaultScaleColor: "#000000",
	                        DefaultSliderColor: "#AAAAAA",
	                        DefaultGranularity: GranularityType.month,
	                        DefaultFirstMonth: 1,
	                        DefaultFirstDay: 1,
	                        DefaultFirstWeekDay: 0
	                    };
	                    this.timelineSelectors = {
	                        TimelineVisual: createClassAndSelector('Timeline'),
	                        SelectionRangeContainer: createClassAndSelector('selectionRangeContainer'),
	                        textLabel: createClassAndSelector('label'),
	                        LowerTextCell: createClassAndSelector('lowerTextCell'),
	                        UpperTextCell: createClassAndSelector('upperTextCell'),
	                        UpperTextArea: createClassAndSelector('upperTextArea'),
	                        LowerTextArea: createClassAndSelector('lowerTextArea'),
	                        RangeTextArea: createClassAndSelector('rangeTextArea'),
	                        CellsArea: createClassAndSelector('cellsArea'),
	                        CursorsArea: createClassAndSelector('cursorsArea'),
	                        MainArea: createClassAndSelector('mainArea'),
	                        SelectionCursor: createClassAndSelector('selectionCursor'),
	                        Cell: createClassAndSelector('cell'),
	                        CellRect: createClassAndSelector('cellRect'),
	                        VertLine: createClassAndSelector('timelineVertLine'),
	                        TimelineSlicer: createClassAndSelector('timelineSlicer'),
	                        PeriodSlicerGranularities: createClassAndSelector('periodSlicerGranularities'),
	                        PeriodSlicerSelection: createClassAndSelector('periodSlicerSelection'),
	                        PeriodSlicerSelectionRect: createClassAndSelector('periodSlicerSelectionRect'),
	                        PeriodSlicerRect: createClassAndSelector('periodSlicerRect')
	                    };
	                    this.drag = d3.behavior.drag()
	                        .origin(function (d) {
	                        d.x = d.selectionIndex * _this.timelineProperties.cellWidth;
	                        return d;
	                    })
	                        .on("dragstart", function () { _this.dragstarted(); })
	                        .on("drag", function (d) { _this.dragged(d); })
	                        .on("dragend", function () { _this.dragended(); });
	                }
	                /**
	                 * Changes the current granularity depending on the given granularity type
	                 * Separates the new granularity's date periods which contain the start/end selection
	                 * Unseparates the date periods of the previous granularity.
	                 * @param granularity The new granularity type
	                 */
	                Timeline.prototype.changeGranularity = function (granularity, startDate, endDate) {
	                    if (Utils.unseparateSelection(this.timelineData.currentGranularity.getDatePeriods()))
	                        Utils.unseparateSelection(this.timelineData.currentGranularity.getDatePeriods());
	                    this.timelineData.currentGranularity = this.timelineGranularityData.getGranularity(granularity);
	                    Utils.separateSelection(this.timelineData, startDate, endDate);
	                };
	                Timeline.prototype.init = function (options) {
	                    this.hostServices = options.host;
	                    this.initialized = false;
	                    var element = options.element;
	                    this.selectionManager = new SelectionManager({ hostServices: options.host });
	                    this.timelineProperties = {
	                        element: element,
	                        textYPosition: 50,
	                        cellsYPosition: this.timelineMargins.TopMargin * 3 + 65,
	                        topMargin: this.timelineMargins.TopMargin,
	                        bottomMargin: this.timelineMargins.BottomMargin,
	                        leftMargin: this.timelineMargins.LeftMargin,
	                        startXpoint: this.timelineMargins.StartXpoint,
	                        startYpoint: this.timelineMargins.StartYpoint,
	                        cellWidth: this.timelineMargins.CellWidth,
	                        cellHeight: this.timelineMargins.CellHeight,
	                        elementWidth: this.timelineMargins.ElementWidth,
	                        rightMargin: this.timelineMargins.RightMargin
	                    };
	                    this.body = d3.select(element.get(0));
	                    this.timelineDiv = this.body.append('div');
	                    this.svg = this.timelineDiv.append('svg').attr('width', px(options.viewport.width)).classed(this.timelineSelectors.TimelineVisual.class, true);
	                    this.addWrappElements();
	                };
	                Timeline.prototype.addWrappElements = function () {
	                    this.clearCatcher = visuals.appendClearCatcher(this.svg);
	                    this.clearCatcher.data([this])
	                        .on("click", function (timeline) { return timeline.clear(); })
	                        .on("touchstart", function (timeline) { return timeline.clear(); });
	                    this.rangeText = this.svg.append('g').classed(this.timelineSelectors.RangeTextArea.class, true).append('text');
	                    this.mainGroupElement = this.svg.append('g').classed(this.timelineSelectors.MainArea.class, true);
	                    this.yearLabelsElement = this.mainGroupElement.append('g');
	                    this.quarterLabelsElement = this.mainGroupElement.append('g');
	                    this.monthLabelsElement = this.mainGroupElement.append('g');
	                    this.weekLabelsElement = this.mainGroupElement.append('g');
	                    this.dayLabelsElement = this.mainGroupElement.append('g');
	                    this.cellsElement = this.mainGroupElement.append('g').classed(this.timelineSelectors.CellsArea.class, true);
	                    this.cursorGroupElement = this.svg.append('g').classed(this.timelineSelectors.CursorsArea.class, true);
	                };
	                Timeline.prototype.clear = function () {
	                    if (this.initialized) {
	                        this.selectionManager.clear();
	                        if (this.timelineData) {
	                            this.timelineData.selectionStartIndex = 0;
	                            this.timelineData.selectionEndIndex = this.timelineData.currentGranularity.getDatePeriods().length - 1;
	                            if (_.any(this.timelineData.timelineDatapoints, function (x) { return x.index % 1 !== 0; }))
	                                this.selectPeriod(this.timelineData.currentGranularity.getType());
	                            else {
	                                Timeline.updateCursors(this.timelineData, this.timelineProperties.cellWidth);
	                                this.fillCells(this.timelineFormat.cellFormat);
	                                this.renderCursors(this.timelineData, this.timelineFormat, this.timelineProperties.cellHeight, this.timelineProperties.cellsYPosition);
	                                this.renderTimeRangeText(this.timelineData, this.timelineFormat.rangeTextFormat);
	                                this.fillColorGranularity(this.timelineFormat.granularityFormat);
	                            }
	                            this.setSelection(this.timelineData);
	                        }
	                    }
	                };
	                Timeline.prototype.drawGranular = function (timelineProperties) {
	                    var _this = this;
	                    var dragPeriodRectState = false;
	                    var startXpoint = timelineProperties.startXpoint;
	                    var startYpoint = timelineProperties.startYpoint;
	                    var elementWidth = timelineProperties.elementWidth;
	                    this.selectorContainer = this.svg.append('g').classed(this.timelineSelectors.TimelineSlicer.class, true);
	                    this.selectorContainer.on('mouseleave', function (d) { return dragPeriodRectState = false; });
	                    // create horiz. line
	                    this.horizLine = this.selectorContainer.append('rect');
	                    var selectorPeriods = this.selector;
	                    this.horizLine.attr({
	                        height: px(1),
	                        x: px(startXpoint),
	                        y: px(startYpoint + 2),
	                        width: px((selectorPeriods.length - 1) * elementWidth)
	                    });
	                    // create vert. lines
	                    this.vertLine = this.selectorContainer.selectAll("vertLines")
	                        .data(selectorPeriods).enter().append('rect');
	                    this.vertLine
	                        .classed(this.timelineSelectors.VertLine.class, true)
	                        .attr({
	                        x: function (d, index) { return px(startXpoint + index * elementWidth); },
	                        y: px(startYpoint),
	                        width: px(2),
	                        height: px(3)
	                    })
	                        .style({ 'cursor': 'pointer' });
	                    // create text lables
	                    var text = this.selectorContainer.selectAll(this.timelineSelectors.PeriodSlicerGranularities.selector)
	                        .data(selectorPeriods)
	                        .enter()
	                        .append("text")
	                        .classed(this.timelineSelectors.PeriodSlicerGranularities.class, true);
	                    this.textLabels = text.text(function (d) { return d; })
	                        .attr({
	                        x: function (d, index) { return px(startXpoint - 3 + index * elementWidth); },
	                        y: px(startYpoint - 3)
	                    });
	                    // create selected period text
	                    this.selectedText = this.selectorContainer.append("text").classed(this.timelineSelectors.PeriodSlicerSelection.class, true);
	                    this.selectedText.text(Utils.getGranularityName(this.defaultTimelineProperties.DefaultGranularity))
	                        .attr({
	                        x: px(startXpoint + 2 * elementWidth),
	                        y: px(startYpoint + 17),
	                    });
	                    var selRects = this.selectorContainer
	                        .selectAll(this.timelineSelectors.PeriodSlicerSelectionRect.selector)
	                        .data(selectorPeriods)
	                        .enter()
	                        .append('rect')
	                        .classed(this.timelineSelectors.PeriodSlicerSelectionRect.class, true);
	                    var clickHandler = function (d, index) {
	                        _this.selectPeriod(index);
	                        dragPeriodRectState = true;
	                    };
	                    selRects.attr({
	                        x: function (d, index) { return px(startXpoint - elementWidth / 2 + index * elementWidth); },
	                        y: px(3),
	                        width: px(elementWidth),
	                        height: px(23)
	                    })
	                        .style({ 'cursor': 'pointer' })
	                        .on('mousedown', clickHandler)
	                        .on('touchstart', clickHandler)
	                        .on('mouseup', function () { return dragPeriodRectState = false; })
	                        .on('touchend', function () { return dragPeriodRectState = false; })
	                        .on("mouseover", function (d, index) {
	                        if (dragPeriodRectState) {
	                            _this.selectPeriod(index);
	                        }
	                    });
	                    var dragPeriodRect = d3.behavior.drag()
	                        .on("dragstart", function (e, b) {
	                        dragPeriodRectState = true;
	                    })
	                        .on("dragend", function (e, b) {
	                        dragPeriodRectState = false;
	                    });
	                    this.periodSlicerRect = this.selectorContainer
	                        .append('rect').classed(this.timelineSelectors.PeriodSlicerRect.class, true)
	                        .attr({
	                        x: px(startXpoint - 6 + this.defaultTimelineProperties.DefaultGranularity * elementWidth),
	                        y: px(startYpoint - 16),
	                        rx: px(4),
	                        width: px(15),
	                        height: px(23)
	                    })
	                        .on('mouseup', function (d) { return dragPeriodRectState = false; });
	                    this.periodSlicerRect.call(dragPeriodRect);
	                };
	                Timeline.prototype.fillColorGranularity = function (granularityFormat) {
	                    this.periodSlicerRect.style("stroke", granularityFormat.sliderColorProperty);
	                    this.selectedText.attr('fill', granularityFormat.scaleColorProperty);
	                    this.textLabels.attr('fill', granularityFormat.scaleColorProperty);
	                    this.vertLine.attr('fill', granularityFormat.scaleColorProperty);
	                    this.horizLine.attr('fill', granularityFormat.scaleColorProperty);
	                };
	                Timeline.prototype.redrawPeriod = function (granularity) {
	                    var dx = this.timelineMargins.StartXpoint + granularity * this.timelineMargins.ElementWidth;
	                    this.periodSlicerRect.transition().attr("x", px(dx - 7));
	                    this.selectedText.text(Utils.getGranularityName(granularity));
	                    var startDate = Utils.getStartSelectionDate(this.timelineData);
	                    var endDate = Utils.getEndSelectionDate(this.timelineData);
	                    this.changeGranularity(granularity, startDate, endDate);
	                };
	                Timeline.setMeasures = function (labelFormat, granularityType, datePeriodsCount, viewport, timelineProperties, timelineMargins) {
	                    timelineProperties.cellsYPosition = timelineProperties.textYPosition;
	                    var labelSize = fromPointToPixel(labelFormat.sizeProperty);
	                    if (labelFormat.showProperty)
	                        timelineProperties.cellsYPosition += labelSize * 1.5 * (granularityType + 1);
	                    var svgHeight = Math.max(0, viewport.height - timelineMargins.TopMargin);
	                    var maxHeight = viewport.width - timelineMargins.RightMargin - timelineMargins.MinCellWidth * datePeriodsCount;
	                    var height = Math.max(timelineMargins.MinCellWidth, Math.min(timelineMargins.MaxCellHeight, maxHeight, svgHeight - timelineProperties.cellsYPosition - 20));
	                    var width = Math.max(timelineMargins.MinCellWidth, (viewport.width - height - timelineMargins.RightMargin) / datePeriodsCount);
	                    timelineProperties.cellHeight = height;
	                    timelineProperties.cellWidth = width;
	                };
	                Timeline.prototype.visualChangeOnly = function (options) {
	                    if (options && options.dataViews && options.dataViews[0] && options.dataViews[0].metadata &&
	                        this.options && this.options.dataViews && this.options.dataViews[0] && this.options.dataViews[0].metadata) {
	                        var newObjects_1 = options.dataViews[0].metadata.objects;
	                        var oldObjects_1 = this.options.dataViews[0].metadata.objects;
	                        var properties = ['rangeHeader', 'cells', 'labels', 'granularity'];
	                        var metadataChanged = !properties.every(function (x) { return _.isEqual(newObjects_1 ? newObjects_1[x] : undefined, oldObjects_1 ? oldObjects_1[x] : undefined); });
	                        return options.suppressAnimations || metadataChanged;
	                    }
	                    return false;
	                };
	                /**
	                 * Note: Public for testability.
	                 */
	                Timeline.prototype.datasetsChanged = function (options) {
	                    if (options && options.dataViews && options.dataViews[0] && options.dataViews[0].categorical &&
	                        options.dataViews[0].categorical.categories && options.dataViews[0].categorical.categories[0] &&
	                        options.dataViews[0].categorical.categories[0].source &&
	                        this.options && this.options.dataViews && this.options.dataViews[0] && this.options.dataViews[0].categorical &&
	                        this.options.dataViews[0].categorical.categories && this.options.dataViews[0].categorical.categories[0] &&
	                        this.options.dataViews[0].categorical.categories[0].source) {
	                        var newObjects = options.dataViews[0].categorical.categories[0].source.displayName;
	                        var oldObjects = this.options.dataViews[0].categorical.categories[0].source.displayName;
	                        if (!_.isEqual(newObjects, oldObjects))
	                            return true;
	                    }
	                    return false;
	                };
	                Timeline.prototype.unavailableType = function (dataViewCategorical) {
	                    return !dataViewCategorical.categories
	                        || dataViewCategorical.categories.length !== 1
	                        || !dataViewCategorical.categories[0].values
	                        || dataViewCategorical.categories[0].values.length === 0
	                        || !dataViewCategorical.categories[0].source
	                        || !dataViewCategorical.categories[0].source.type;
	                };
	                Timeline.prototype.unavailableChildIdentityField = function (dataViewTree) {
	                    return !dataViewTree.root || !dataViewTree.root.childIdentityFields || dataViewTree.root.childIdentityFields.length === 0;
	                };
	                Timeline.prototype.createTimelineOptions = function (dataView) {
	                    this.dataView = dataView;
	                    if (!dataView.categorical
	                        || !dataView.metadata
	                        || this.unavailableType(dataView.categorical)
	                        || !dataView.tree
	                        || this.unavailableChildIdentityField(dataView.tree))
	                        return false;
	                    var columnExp = dataView.tree.root.childIdentityFields[0];
	                    this.valueType = columnExp ? columnExp.ref : null;
	                    if (!(dataView.categorical.categories[0].source.type.dateTime ||
	                        (dataView.categorical.categories[0].source.type.numeric && (this.valueType === 'Year' || this.valueType === 'Date'))))
	                        return false;
	                    this.values = this.prepareValues(this.dataView.categorical.categories[0].values);
	                    return true;
	                };
	                //Public for testability.
	                Timeline.prototype.prepareValues = function (values) {
	                    // remove null strings and rebuild string type date 
	                    // (BUG #7266283 IN PBI-service)
	                    values = values.filter(Boolean);
	                    for (var i in values) {
	                        var item = values[i];
	                        if (typeof (item) === 'String' && (String(new Date(item)) !== 'Invalid Date')) {
	                            return values[i] = new Date(item);
	                        }
	                    }
	                    ;
	                    return values;
	                };
	                Timeline.prototype.createTimelineData = function () {
	                    var startDate;
	                    var endDate;
	                    if (this.valueType === 'Year') {
	                        var years = this.values;
	                        startDate = new Date(_.min(years), 0);
	                        endDate = new Date(_.max(years), 11);
	                    }
	                    else {
	                        var dates = this.values;
	                        startDate = _.min(dates);
	                        endDate = _.max(dates);
	                    }
	                    this.timelineFormat = Timeline.fillTimelineFormat(this.options.dataViews[0].metadata.objects, this.defaultTimelineProperties);
	                    if (!this.initialized) {
	                        this.drawGranular(this.timelineProperties);
	                        this.fillColorGranularity(this.timelineFormat.granularityFormat);
	                    }
	                    if (this.initialized) {
	                        var actualEndDate = TimelineGranularityData.nextDay(endDate);
	                        var daysPeriods = this.timelineGranularityData.getGranularity(GranularityType.day).getDatePeriods();
	                        var prevStartDate = daysPeriods[0].startDate;
	                        var prevEndDate = daysPeriods[daysPeriods.length - 1].endDate;
	                        var changedSelection = startDate.getTime() >= prevStartDate.getTime() && actualEndDate.getTime() <= prevEndDate.getTime();
	                        this.newGranularity = this.timelineData.currentGranularity.getType();
	                        if (changedSelection) {
	                            this.changeGranularity(this.newGranularity, startDate, actualEndDate);
	                        }
	                        else {
	                            if (actualEndDate < prevEndDate)
	                                endDate = daysPeriods[daysPeriods.length - 1].startDate;
	                            if (startDate > prevStartDate)
	                                startDate = prevStartDate;
	                            this.initialized = false;
	                        }
	                    }
	                    if (!this.initialized) {
	                        this.timelineGranularityData = new TimelineGranularityData(startDate, endDate);
	                        this.timelineData = {
	                            elementsCount: 0,
	                            timelineDatapoints: [],
	                            cursorDataPoints: new Array()
	                        };
	                    }
	                };
	                Timeline.prototype.update = function (options) {
	                    var visualChange = this.visualChangeOnly(options);
	                    this.datasetsChangedState = this.datasetsChanged(options);
	                    this.requiresNoUpdate = this.requiresNoUpdate && !this.datasetsChangedState && !visualChange;
	                    if (this.requiresNoUpdate) {
	                        this.requiresNoUpdate = false;
	                        return;
	                    }
	                    this.options = options;
	                    if (!options.dataViews || !options.dataViews[0])
	                        return;
	                    var validOptions = this.createTimelineOptions(options.dataViews[0]);
	                    if (!validOptions) {
	                        this.clearData();
	                        return;
	                    }
	                    this.newGranularity = this.defaultTimelineProperties.DefaultGranularity;
	                    if (!visualChange)
	                        this.createTimelineData();
	                    this.timelineFormat = Timeline.converter(this.timelineData, this.timelineProperties, this.defaultTimelineProperties, this.timelineGranularityData, options.dataViews[0], this.initialized, this.newGranularity, options.viewport, this.timelineMargins);
	                    this.render(this.timelineData, this.timelineFormat, this.timelineProperties, options);
	                    this.initialized = true;
	                };
	                Timeline.prototype.selectPeriod = function (periodNameIndex) {
	                    this.redrawPeriod(periodNameIndex);
	                    this.timelineFormat = Timeline.converter(this.timelineData, this.timelineProperties, this.defaultTimelineProperties, this.timelineGranularityData, this.options.dataViews[0], this.initialized, this.timelineData.currentGranularity.getType(), this.options.viewport, this.timelineMargins);
	                    this.render(this.timelineData, this.timelineFormat, this.timelineProperties, this.options);
	                };
	                Timeline.isDataNotMatch = function (dataView) {
	                    if (dataView.categorical.categories.length <= 0 ||
	                        dataView.categorical.categories[0] === undefined ||
	                        dataView.categorical.categories[0].identityFields === undefined ||
	                        dataView.categorical.categories[0].identityFields.length <= 0)
	                        return true;
	                    return false;
	                };
	                Timeline.converter = function (timelineData, timelineProperties, defaultTimelineProperties, timelineGranularityData, dataView, initialized, granularityType, viewport, timelineMargins) {
	                    var timelineFormat = Timeline.fillTimelineFormat(dataView.metadata.objects, defaultTimelineProperties);
	                    if (!initialized) {
	                        timelineData.cursorDataPoints.push({ x: 0, selectionIndex: 0, cursorIndex: 0 });
	                        timelineData.cursorDataPoints.push({ x: 0, selectionIndex: 0, cursorIndex: 1 });
	                    }
	                    if (!initialized || Timeline.calendar.isChanged(timelineFormat.calendarFormat)) {
	                        Timeline.calendar = new Calendar(timelineFormat.calendarFormat);
	                        timelineGranularityData.createGranularities();
	                        timelineGranularityData.createLabels();
	                        timelineData.currentGranularity = timelineGranularityData.getGranularity(granularityType);
	                        timelineData.selectionStartIndex = 0;
	                        timelineData.selectionEndIndex = timelineData.currentGranularity.getDatePeriods().length - 1;
	                    }
	                    timelineData.categorySourceName = dataView.categorical.categories[0].source.displayName;
	                    timelineData.columnIdentity = dataView.categorical.categories[0].identityFields[0];
	                    if (dataView.categorical.categories[0].source.type.numeric) {
	                        timelineData.columnIdentity.ref = "Date";
	                    }
	                    if (this.isDataNotMatch(dataView))
	                        return;
	                    var timelineElements = timelineData.currentGranularity.getDatePeriods();
	                    timelineData.elementsCount = timelineElements.length;
	                    timelineData.timelineDatapoints = [];
	                    for (var _i = 0, timelineElements_1 = timelineElements; _i < timelineElements_1.length; _i++) {
	                        var currentTimePeriod = timelineElements_1[_i];
	                        var datapoint = {
	                            index: currentTimePeriod.index,
	                            datePeriod: currentTimePeriod
	                        };
	                        timelineData.timelineDatapoints.push(datapoint);
	                    }
	                    var countFullCells = timelineData.currentGranularity.getDatePeriods().filter(function (x) { return x.index % 1 === 0; }).length;
	                    Timeline.setMeasures(timelineFormat.labelFormat, timelineData.currentGranularity.getType(), countFullCells, viewport, timelineProperties, timelineMargins);
	                    Timeline.updateCursors(timelineData, timelineProperties.cellWidth);
	                    return timelineFormat;
	                };
	                Timeline.prototype.render = function (timelineData, timelineFormat, timelineProperties, options) {
	                    var timelineDatapointsCount = this.timelineData.timelineDatapoints.filter(function (x) { return x.index % 1 === 0; }).length;
	                    this.svgWidth = 1 + this.timelineProperties.cellHeight + timelineProperties.cellWidth * timelineDatapointsCount;
	                    this.renderTimeRangeText(timelineData, timelineFormat.rangeTextFormat);
	                    this.fillColorGranularity(this.timelineFormat.granularityFormat);
	                    this.timelineDiv.attr({
	                        height: px(options.viewport.height),
	                        width: px(options.viewport.width),
	                        'drag-resize-disabled': true
	                    }).style({
	                        'overflow-x': 'auto',
	                        'overflow-y': 'auto'
	                    });
	                    this.svg.attr({
	                        height: px(Math.max(0, options.viewport.height - this.timelineMargins.TopMargin)),
	                        width: px(Math.max(0, this.svgWidth))
	                    });
	                    var fixedTranslateString = visuals.SVGUtil.translate(timelineProperties.leftMargin, timelineProperties.topMargin);
	                    var translateString = visuals.SVGUtil.translate(timelineProperties.cellHeight / 2, timelineProperties.topMargin);
	                    this.mainGroupElement.attr('transform', translateString);
	                    this.selectorContainer.attr('transform', fixedTranslateString);
	                    this.cursorGroupElement.attr('transform', translateString);
	                    var extendedLabels = this.timelineData.currentGranularity.getExtendedLabel();
	                    var granularityType = this.timelineData.currentGranularity.getType();
	                    var yPos = 0, yDiff = 1.50;
	                    this.renderLabels(extendedLabels.yearLabels, this.yearLabelsElement, yPos, granularityType === 0);
	                    yPos += yDiff;
	                    this.renderLabels(extendedLabels.quarterLabels, this.quarterLabelsElement, yPos, granularityType === 1);
	                    yPos += yDiff;
	                    this.renderLabels(extendedLabels.monthLabels, this.monthLabelsElement, yPos, granularityType === 2);
	                    yPos += yDiff;
	                    this.renderLabels(extendedLabels.weekLabels, this.weekLabelsElement, yPos, granularityType === 3);
	                    yPos += yDiff;
	                    this.renderLabels(extendedLabels.dayLabels, this.dayLabelsElement, yPos, granularityType === 4);
	                    this.renderCells(timelineData, timelineFormat, timelineProperties, options.suppressAnimations);
	                    this.renderCursors(timelineData, timelineFormat, timelineProperties.cellHeight, timelineProperties.cellsYPosition);
	                };
	                Timeline.prototype.renderLabels = function (labels, labelsElement, index, isLast) {
	                    var _this = this;
	                    var labelTextSelection = labelsElement.selectAll(this.timelineSelectors.textLabel.selector);
	                    if (!this.timelineFormat.labelFormat.showProperty) {
	                        labelTextSelection.remove();
	                        return;
	                    }
	                    var labelsGroupSelection = labelTextSelection.data(labels);
	                    labelsGroupSelection.enter().append('text').classed(this.timelineSelectors.textLabel.class, true);
	                    labelsGroupSelection.text(function (x, id) {
	                        if (!isLast && id === 0 && labels.length > 1) {
	                            var fontSize = pt(_this.timelineFormat.labelFormat.sizeProperty);
	                            var textProperties = {
	                                text: labels[0].text,
	                                fontFamily: 'arial',
	                                fontSize: fontSize
	                            };
	                            var halfFirstTextWidth = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties) / 2;
	                            textProperties = {
	                                text: labels[1].text,
	                                fontFamily: 'arial',
	                                fontSize: fontSize
	                            };
	                            var halfSecondTextWidth = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties) / 2;
	                            var diff = _this.timelineProperties.cellWidth * (labels[1].id - labels[0].id);
	                            if (diff < halfFirstTextWidth + halfSecondTextWidth)
	                                return "";
	                        }
	                        var labelFormattedTextOptions = {
	                            label: x.text,
	                            maxWidth: _this.timelineProperties.cellWidth * (isLast ? 0.90 : 3),
	                            fontSize: _this.timelineFormat.labelFormat.sizeProperty
	                        };
	                        return visuals.dataLabelUtils.getLabelFormattedText(labelFormattedTextOptions);
	                    })
	                        .style('font-size', pt(this.timelineFormat.labelFormat.sizeProperty))
	                        .attr({
	                        x: function (x) { return (x.id + 0.5) * _this.timelineProperties.cellWidth; },
	                        y: this.timelineProperties.textYPosition + (1 + index) * fromPointToPixel(this.timelineFormat.labelFormat.sizeProperty),
	                        fill: this.timelineFormat.labelFormat.colorProperty
	                    }).append('title').text(function (x) { return x.title; });
	                    labelsGroupSelection.exit().remove();
	                };
	                Timeline.prototype.clearData = function () {
	                    this.initialized = false;
	                    this.mainGroupElement.selectAll(this.timelineSelectors.CellRect.selector).remove();
	                    this.mainGroupElement.selectAll(this.timelineSelectors.textLabel.selector).remove();
	                    this.rangeText.text("");
	                    this.cursorGroupElement.selectAll(this.timelineSelectors.SelectionCursor.selector).remove();
	                    this.svg.select(this.timelineSelectors.TimelineSlicer.selector).remove();
	                    this.mainGroupElement.selectAll(this.timelineSelectors.textLabel.selector);
	                };
	                Timeline.updateCursors = function (timelineData, cellWidth) {
	                    var startDate = timelineData.timelineDatapoints[timelineData.selectionStartIndex].datePeriod;
	                    timelineData.cursorDataPoints[0].selectionIndex = startDate.index;
	                    var endDate = timelineData.timelineDatapoints[timelineData.selectionEndIndex].datePeriod;
	                    timelineData.cursorDataPoints[1].selectionIndex = (endDate.index + endDate.fraction);
	                };
	                Timeline.fillTimelineFormat = function (objects, timelineProperties) {
	                    var timelineFormat = {
	                        rangeTextFormat: {
	                            showProperty: powerbi.DataViewObjects.getValue(objects, TimeRangeShowProp, timelineProperties.TimelineDefaultTimeRangeShow),
	                            colorProperty: powerbi.DataViewObjects.getFillColor(objects, TimeRangeColorProp, timelineProperties.DefaultTimeRangeColor),
	                            sizeProperty: powerbi.DataViewObjects.getValue(objects, TimeRangeSizeProp, timelineProperties.TimelineDefaultTextSize)
	                        },
	                        cellFormat: {
	                            colorInProperty: powerbi.DataViewObjects.getFillColor(objects, SelectedCellColorProp, timelineProperties.TimelineDefaultCellColor),
	                            colorOutProperty: powerbi.DataViewObjects.getFillColor(objects, UnselectedCellColorProp, timelineProperties.TimelineDefaultCellColorOut)
	                        },
	                        granularityFormat: {
	                            scaleColorProperty: powerbi.DataViewObjects.getFillColor(objects, ScaleColorProp, timelineProperties.DefaultScaleColor),
	                            sliderColorProperty: powerbi.DataViewObjects.getFillColor(objects, SliderColorProp, timelineProperties.DefaultSliderColor)
	                        },
	                        labelFormat: {
	                            showProperty: powerbi.DataViewObjects.getValue(objects, LabelsShowProp, timelineProperties.DefaultLabelsShow),
	                            colorProperty: powerbi.DataViewObjects.getFillColor(objects, LabelsColorProp, timelineProperties.DefaultLabelColor),
	                            sizeProperty: powerbi.DataViewObjects.getValue(objects, LabelsSizeProp, timelineProperties.TimelineDefaultTextSize)
	                        },
	                        calendarFormat: {
	                            firstMonthProperty: powerbi.DataViewObjects.getValue(objects, CalendarMonthProp, 1),
	                            firstDayProperty: Math.max(1, Math.min(31, powerbi.DataViewObjects.getValue(objects, CalendarDayProp, timelineProperties.DefaultFirstDay))),
	                            weekDayProperty: Math.max(0, Math.min(6, powerbi.DataViewObjects.getValue(objects, WeekDayProp, timelineProperties.DefaultFirstWeekDay)))
	                        }
	                    };
	                    return timelineFormat;
	                };
	                Timeline.prototype.fillCells = function (cellFormat) {
	                    var _this = this;
	                    var dataPoints = this.timelineData.timelineDatapoints;
	                    var cellSelection = this.mainGroupElement.selectAll(this.timelineSelectors.CellRect.selector).data(dataPoints);
	                    cellSelection.attr('fill', function (d) { return Utils.getCellColor(d, _this.timelineData, cellFormat); });
	                };
	                Timeline.prototype.renderCells = function (timelineData, timelineFormat, timelineProperties, suppressAnimations) {
	                    var _this = this;
	                    var allDataPoints = timelineData.timelineDatapoints;
	                    var totalX = 0;
	                    var cellsSelection = this.cellsElement.selectAll(this.timelineSelectors.CellRect.selector).data(allDataPoints);
	                    cellsSelection.enter().append('rect').classed(this.timelineSelectors.CellRect.class, true);
	                    cellsSelection
	                        .attr({
	                        height: px(timelineProperties.cellHeight),
	                        width: function (d) { return px(d.datePeriod.fraction * timelineProperties.cellWidth); },
	                        x: function (d) {
	                            var value = totalX;
	                            totalX += d.datePeriod.fraction * timelineProperties.cellWidth;
	                            return px(value);
	                        },
	                        y: px(timelineProperties.cellsYPosition),
	                        id: function (d) { return d.index; }
	                    });
	                    var clickHandler = function (d, index) {
	                        d3.event.preventDefault();
	                        var cursorDataPoints = _this.timelineData.cursorDataPoints;
	                        var keyEvent = d3.event;
	                        if (keyEvent.altKey || keyEvent.shiftKey) {
	                            if (_this.timelineData.selectionEndIndex < index) {
	                                cursorDataPoints[1].selectionIndex = (d.datePeriod.index + d.datePeriod.fraction);
	                                timelineData.selectionEndIndex = index;
	                            }
	                            else {
	                                cursorDataPoints[0].selectionIndex = d.datePeriod.index;
	                                timelineData.selectionStartIndex = index;
	                            }
	                        }
	                        else {
	                            timelineData.selectionStartIndex = index;
	                            timelineData.selectionEndIndex = index;
	                            cursorDataPoints[0].selectionIndex = d.datePeriod.index;
	                            cursorDataPoints[1].selectionIndex = (d.datePeriod.index + d.datePeriod.fraction);
	                        }
	                        _this.fillCells(timelineFormat.cellFormat);
	                        _this.renderCursors(timelineData, timelineFormat, timelineProperties.cellHeight, timelineProperties.cellsYPosition);
	                        _this.renderTimeRangeText(timelineData, timelineFormat.rangeTextFormat);
	                        _this.fillColorGranularity(_this.timelineFormat.granularityFormat);
	                        _this.setSelection(timelineData);
	                    };
	                    cellsSelection
	                        .on('click', clickHandler)
	                        .on("touchstart", clickHandler);
	                    this.fillCells(timelineFormat.cellFormat);
	                    cellsSelection.exit().remove();
	                };
	                Timeline.prototype.dragstarted = function () {
	                    this.timelineData.dragging = true;
	                };
	                Timeline.prototype.dragged = function (currentCursor) {
	                    if (this.timelineData.dragging === true) {
	                        var xScale = 1;
	                        var container = d3.select(this.timelineSelectors.TimelineVisual.selector);
	                        if (container) {
	                            var transform = container.style("transform");
	                            if (transform !== undefined && transform !== 'none') {
	                                var str = transform.split("(")[1];
	                                xScale = Number(str.split(", ")[0]);
	                            }
	                        }
	                        var cursorOverElement = this.findCursorOverElement(d3.event.x);
	                        if (!cursorOverElement) {
	                            return;
	                        }
	                        var currentlyMouseOverElement = cursorOverElement.datapoint, currentlyMouseOverElementIndex = cursorOverElement.index;
	                        if (currentCursor.cursorIndex === 0 && currentlyMouseOverElementIndex <= this.timelineData.selectionEndIndex) {
	                            this.timelineData.selectionStartIndex = currentlyMouseOverElementIndex;
	                            this.timelineData.cursorDataPoints[0].selectionIndex = currentlyMouseOverElement.datePeriod.index;
	                        }
	                        if (currentCursor.cursorIndex === 1 && currentlyMouseOverElementIndex >= this.timelineData.selectionStartIndex) {
	                            this.timelineData.selectionEndIndex = currentlyMouseOverElementIndex;
	                            this.timelineData.cursorDataPoints[1].selectionIndex = (currentlyMouseOverElement.datePeriod.index + currentlyMouseOverElement.datePeriod.fraction);
	                        }
	                        this.fillCells(this.timelineFormat.cellFormat);
	                        this.renderCursors(this.timelineData, this.timelineFormat, this.timelineProperties.cellHeight, this.timelineProperties.cellsYPosition);
	                        this.renderTimeRangeText(this.timelineData, this.timelineFormat.rangeTextFormat);
	                        this.fillColorGranularity(this.timelineFormat.granularityFormat);
	                    }
	                };
	                /**
	                 * Note: Public for testability.
	                 */
	                Timeline.prototype.findCursorOverElement = function (x) {
	                    var timelineDatapoints = this.timelineData.timelineDatapoints || [], length = timelineDatapoints.length, cellWidth = this.timelineProperties.cellWidth;
	                    if (timelineDatapoints[0] && timelineDatapoints[1] && x <= timelineDatapoints[1].index * cellWidth) {
	                        return {
	                            index: 0,
	                            datapoint: timelineDatapoints[0]
	                        };
	                    }
	                    else if (timelineDatapoints[length - 1] && x >= timelineDatapoints[length - 1].index * cellWidth) {
	                        return {
	                            index: length - 1,
	                            datapoint: timelineDatapoints[length - 1]
	                        };
	                    }
	                    for (var i = 1; i < length; i++) {
	                        var left = timelineDatapoints[i].index * cellWidth, right = timelineDatapoints[i + 1].index * cellWidth;
	                        if (x >= left && x <= right) {
	                            return {
	                                index: i,
	                                datapoint: timelineDatapoints[i]
	                            };
	                        }
	                    }
	                    return null;
	                };
	                Timeline.prototype.dragended = function () {
	                    this.setSelection(this.timelineData);
	                };
	                Timeline.prototype.renderCursors = function (timelineData, timelineFormat, cellHeight, cellsYPosition) {
	                    var _this = this;
	                    var cursorSelection = this.cursorGroupElement.selectAll(this.timelineSelectors.SelectionCursor.selector).data(timelineData.cursorDataPoints);
	                    cursorSelection.enter().append('path').classed(this.timelineSelectors.SelectionCursor.class, true);
	                    cursorSelection.attr("transform", function (d) { return visuals.SVGUtil.translate(d.selectionIndex * _this.timelineProperties.cellWidth, cellHeight / 2 + cellsYPosition); }).attr({
	                        d: d3.svg.arc()
	                            .innerRadius(0)
	                            .outerRadius(cellHeight / 2)
	                            .startAngle(function (d) { return d.cursorIndex * Math.PI + Math.PI; })
	                            .endAngle(function (d) { return d.cursorIndex * Math.PI + 2 * Math.PI; })
	                    })
	                        .call(this.drag);
	                    cursorSelection.exit().remove();
	                    return cursorSelection;
	                };
	                Timeline.prototype.renderTimeRangeText = function (timelineData, timeRangeFormat) {
	                    var leftMargin = (GranularityNames.length + 2) * this.timelineProperties.elementWidth;
	                    var maxWidth = this.svgWidth - leftMargin - this.timelineProperties.leftMargin - timeRangeFormat.sizeProperty;
	                    if (timeRangeFormat.showProperty && maxWidth > 0) {
	                        var timeRangeText = Utils.timeRangeText(timelineData);
	                        var labelFormattedTextOptions = {
	                            label: timeRangeText,
	                            maxWidth: maxWidth,
	                            fontSize: timeRangeFormat.sizeProperty
	                        };
	                        var actualText = visuals.dataLabelUtils.getLabelFormattedText(labelFormattedTextOptions);
	                        this.rangeText.classed(this.timelineSelectors.SelectionRangeContainer.class, true);
	                        this.rangeText.attr({
	                            x: (GranularityNames.length) * (this.timelineProperties.elementWidth + this.timelineProperties.leftMargin),
	                            y: 40,
	                            fill: timeRangeFormat.colorProperty
	                        })
	                            .style({
	                            'font-size': pt(timeRangeFormat.sizeProperty)
	                        }).text(actualText)
	                            .append('title').text(timeRangeText);
	                        ;
	                    }
	                    else
	                        this.rangeText.text("");
	                };
	                Timeline.prototype.setSelection = function (timelineData) {
	                    this.requiresNoUpdate = true;
	                    var lower = powerbi.data.SQExprBuilder.dateTime(Utils.getStartSelectionDate(timelineData));
	                    var upper = powerbi.data.SQExprBuilder.dateTime(new Date(Utils.getEndSelectionDate(timelineData).getTime() - 1));
	                    var filterExpr = powerbi.data.SQExprBuilder.between(timelineData.columnIdentity, lower, upper);
	                    var filter = powerbi.data.SemanticFilter.fromSQExpr(filterExpr);
	                    var objects = {
	                        merge: [
	                            {
	                                objectName: "general",
	                                selector: undefined,
	                                properties: {
	                                    "filter": filter,
	                                }
	                            }
	                        ]
	                    };
	                    this.hostServices.persistProperties(objects);
	                    this.hostServices.onSelect({ visualObjects: [] });
	                };
	                // This function retruns the values to be displayed in the property pane for each object.
	                // Usually it is a bind pass of what the property pane gave you, but sometimes you may want to do
	                // validation and return other values/defaults 
	                Timeline.prototype.enumerateObjectInstances = function (options) {
	                    var enumeration = new visuals.ObjectEnumerationBuilder();
	                    switch (options.objectName) {
	                        case 'rangeHeader':
	                            this.enumerateRangeHeader(enumeration, this.dataView);
	                            break;
	                        case 'cells':
	                            this.enumerateCells(enumeration, this.dataView);
	                            break;
	                        case 'granularity':
	                            this.enumerateGranularity(enumeration, this.dataView);
	                            break;
	                        case 'labels':
	                            this.enumerateLabels(enumeration, this.dataView);
	                            break;
	                        case 'calendar':
	                            this.enumerateCalendar(enumeration, this.dataView);
	                            break;
	                        case 'weekDay':
	                            this.enumerateWeekDay(enumeration, this.dataView);
	                            break;
	                    }
	                    return enumeration.complete();
	                };
	                Timeline.prototype.enumerateRangeHeader = function (enumeration, dataview) {
	                    var objects = dataview && dataview.metadata ? dataview.metadata.objects : undefined;
	                    enumeration.pushInstance({
	                        objectName: 'rangeHeader',
	                        displayName: 'Selection Color',
	                        selector: null,
	                        properties: {
	                            show: powerbi.DataViewObjects.getValue(objects, TimeRangeShowProp, this.defaultTimelineProperties.TimelineDefaultTimeRangeShow),
	                            fontColor: powerbi.DataViewObjects.getFillColor(objects, TimeRangeColorProp, this.defaultTimelineProperties.DefaultTimeRangeColor),
	                            textSize: powerbi.DataViewObjects.getValue(objects, TimeRangeSizeProp, this.defaultTimelineProperties.TimelineDefaultTextSize)
	                        }
	                    });
	                };
	                Timeline.prototype.enumerateCells = function (enumeration, dataview) {
	                    var objects = dataview && dataview.metadata ? dataview.metadata.objects : undefined;
	                    enumeration.pushInstance({
	                        objectName: 'cells',
	                        selector: null,
	                        properties: {
	                            fillSelected: powerbi.DataViewObjects.getFillColor(objects, SelectedCellColorProp, this.defaultTimelineProperties.TimelineDefaultCellColor),
	                            fillUnselected: powerbi.DataViewObjects.getFillColor(objects, UnselectedCellColorProp, this.defaultTimelineProperties.TimelineDefaultCellColorOut)
	                        }
	                    });
	                };
	                Timeline.prototype.enumerateGranularity = function (enumeration, dataview) {
	                    var objects = dataview && dataview.metadata ? dataview.metadata.objects : undefined;
	                    enumeration.pushInstance({
	                        objectName: 'granularity',
	                        selector: null,
	                        properties: {
	                            scaleColor: powerbi.DataViewObjects.getFillColor(objects, ScaleColorProp, this.defaultTimelineProperties.DefaultScaleColor),
	                            sliderColor: powerbi.DataViewObjects.getFillColor(objects, SliderColorProp, this.defaultTimelineProperties.DefaultSliderColor),
	                        }
	                    });
	                };
	                Timeline.prototype.enumerateLabels = function (enumeration, dataview) {
	                    var objects = dataview && dataview.metadata ? dataview.metadata.objects : undefined;
	                    enumeration.pushInstance({
	                        objectName: 'labels',
	                        selector: null,
	                        properties: {
	                            show: powerbi.DataViewObjects.getValue(objects, LabelsShowProp, this.defaultTimelineProperties.DefaultLabelsShow),
	                            fontColor: powerbi.DataViewObjects.getFillColor(objects, LabelsColorProp, this.defaultTimelineProperties.DefaultLabelColor),
	                            textSize: powerbi.DataViewObjects.getValue(objects, LabelsSizeProp, this.defaultTimelineProperties.TimelineDefaultTextSize)
	                        }
	                    });
	                };
	                Timeline.prototype.enumerateCalendar = function (enumeration, dataview) {
	                    var objects = dataview && dataview.metadata ? dataview.metadata.objects : undefined;
	                    enumeration.pushInstance({
	                        objectName: 'calendar',
	                        selector: null,
	                        properties: {
	                            month: Math.max(1, Math.min(12, powerbi.DataViewObjects.getValue(objects, CalendarMonthProp, 1))),
	                            day: Math.max(1, Math.min(31, powerbi.DataViewObjects.getValue(objects, CalendarDayProp, 1))),
	                        }
	                    });
	                };
	                Timeline.prototype.enumerateWeekDay = function (enumeration, dataview) {
	                    var objects = dataview && dataview.metadata ? dataview.metadata.objects : undefined;
	                    enumeration.pushInstance({
	                        objectName: 'weekDay',
	                        selector: null,
	                        properties: {
	                            day: Math.max(0, Math.min(6, powerbi.DataViewObjects.getValue(objects, WeekDayProp, 0)))
	                        }
	                    });
	                };
	                Timeline.capabilities = {
	                    dataRoles: [{
	                            name: 'Time',
	                            kind: powerbi.VisualDataRoleKind.Grouping,
	                            displayName: 'Time'
	                        }],
	                    dataViewMappings: [{
	                            conditions: [
	                                { 'Time': { max: 1 } }
	                            ],
	                            categorical: {
	                                categories: {
	                                    for: { in: 'Time' },
	                                    dataReductionAlgorithm: { sample: {} }
	                                },
	                                values: {
	                                    select: [{
	                                            bind: { to: 'Time' }
	                                        }]
	                                },
	                            }
	                        }],
	                    objects: {
	                        general: {
	                            displayName: 'General',
	                            properties: {
	                                formatString: {
	                                    type: {
	                                        formatting: {
	                                            formatString: true
	                                        }
	                                    },
	                                },
	                                selected: {
	                                    type: { bool: true }
	                                },
	                                filter: {
	                                    type: { filter: {} },
	                                    rule: {
	                                        output: {
	                                            property: 'selected',
	                                            selector: ['Time'],
	                                        }
	                                    }
	                                },
	                            },
	                        },
	                        calendar: {
	                            displayName: 'Fiscal Year Start',
	                            properties: {
	                                month: {
	                                    displayName: 'Month',
	                                    type: { enumeration: samples.Months }
	                                },
	                                day: {
	                                    displayName: 'Day',
	                                    type: { numeric: true }
	                                }
	                            }
	                        },
	                        weekDay: {
	                            displayName: 'First Day of Week',
	                            properties: {
	                                day: {
	                                    displayName: 'Day',
	                                    type: { enumeration: samples.WeekDays }
	                                }
	                            }
	                        },
	                        rangeHeader: {
	                            displayName: 'Range Header',
	                            properties: {
	                                show: {
	                                    displayName: 'Show',
	                                    type: { bool: true }
	                                },
	                                fontColor: {
	                                    displayName: 'Font color',
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                textSize: {
	                                    displayName: 'Text Size',
	                                    type: { numeric: true }
	                                }
	                            }
	                        },
	                        cells: {
	                            displayName: 'Cells',
	                            properties: {
	                                fillSelected: {
	                                    displayName: 'Selected cell color',
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                fillUnselected: {
	                                    displayName: 'Unselected cell color',
	                                    type: { fill: { solid: { color: { nullable: true } } } }
	                                }
	                            }
	                        },
	                        granularity: {
	                            displayName: 'Granularity',
	                            properties: {
	                                scaleColor: {
	                                    displayName: 'Scale color',
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                sliderColor: {
	                                    displayName: 'Slider color',
	                                    type: { fill: { solid: { color: true } } }
	                                }
	                            }
	                        },
	                        labels: {
	                            displayName: 'Labels',
	                            properties: {
	                                show: {
	                                    displayName: 'Show',
	                                    type: { bool: true }
	                                },
	                                fontColor: {
	                                    displayName: 'Font color',
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                textSize: {
	                                    displayName: 'Text Size',
	                                    type: { numeric: true }
	                                }
	                            }
	                        }
	                    }
	                };
	                return Timeline;
	            }());
	            samples.Timeline = Timeline;
	        })(samples = visuals.samples || (visuals.samples = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 54 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../../../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var samples;
	        (function (samples) {
	            var PixelConverter = jsCommon.PixelConverter;
	            var ValueFormatter = powerbi.visuals.valueFormatter;
	            var LegendData = powerbi.visuals.LegendData;
	            var VisualDataRoleKind = powerbi.VisualDataRoleKind;
	            var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
	            var legendPosition = powerbi.visuals.legendPosition;
	            var SelectionId = powerbi.visuals.SelectionId;
	            var LegendIcon = powerbi.visuals.LegendIcon;
	            var TooltipBuilder = powerbi.visuals.TooltipBuilder;
	            var TextMeasurementService = powerbi.TextMeasurementService;
	            var DataViewObjects = powerbi.DataViewObjects;
	            var appendClearCatcher = powerbi.visuals.appendClearCatcher;
	            var createInteractivityService = powerbi.visuals.createInteractivityService;
	            var createLegend = powerbi.visuals.createLegend;
	            var TooltipManager = powerbi.visuals.TooltipManager;
	            var dataLabelUtils = powerbi.visuals.dataLabelUtils;
	            var SVGUtil = powerbi.visuals.SVGUtil;
	            var AxisHelper = powerbi.visuals.AxisHelper;
	            var valueFormatter = powerbi.visuals.valueFormatter;
	            var legendProps = powerbi.visuals.legendProps;
	            var LegendPosition = powerbi.visuals.LegendPosition;
	            var Legend = powerbi.visuals.Legend;
	            var ObjectEnumerationBuilder = powerbi.visuals.ObjectEnumerationBuilder;
	            var StreamGraphAxisGraphicsContextClassName = "axisGraphicsContext";
	            var DataPointsContainer = "dataPointsContainer";
	            var StreamGraphXAxisClassName = "x axis";
	            var StreamGraphYAxisClassName = "y axis";
	            var StreamGraphDefaultColor = "#777";
	            var StreamGraphDefaultFontSizeInPoints = 8;
	            var DefaultDataLabelsOffset = 4;
	            var DefaultLabelTickWidth = 10;
	            var DefaultLegendLabelFillColor = "#666666";
	            var StreamGraphDefaultFontFamily = "wf_segoe-ui_normal";
	            var StreamGraphDefaultFontWeight = "normal";
	            var XAxisOnSize = 20;
	            var XAxisOffSize = 10;
	            var XAxisLabelSize = 20;
	            var YAxisOnSize = 45;
	            var YAxisOffSize = 10;
	            var YAxisLabelSize = 20;
	            var StreamGraphDefaultSettings = {
	                legendSettings: {
	                    show: true,
	                    showTitle: true,
	                    labelColor: DefaultLegendLabelFillColor,
	                    titleText: "",
	                    fontSize: StreamGraphDefaultFontSizeInPoints
	                },
	                categoryAxisSettings: {
	                    show: true,
	                    labelColor: StreamGraphDefaultColor,
	                    showAxisTitle: false,
	                },
	                valueAxisSettings: {
	                    show: true,
	                    labelColor: StreamGraphDefaultColor,
	                    showAxisTitle: false,
	                },
	                dataLabelsSettings: dataLabelUtils.getDefaultPointLabelSettings(),
	            };
	            var StreamGraphWebBehavior = (function () {
	                function StreamGraphWebBehavior() {
	                }
	                StreamGraphWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
	                    this.selection = options.selection;
	                    this.clearCatcher = options.clearCatcher;
	                    this.interactivityService = options.interactivityService;
	                    this.selection.on("click", function (d, i) {
	                        selectionHandler.handleSelection(d, d3.event.ctrlKey);
	                    });
	                    this.clearCatcher.on("click", function () {
	                        selectionHandler.handleClearSelection();
	                    });
	                };
	                StreamGraphWebBehavior.prototype.renderSelection = function (hasSelection) {
	                    var hasHighlights = this.interactivityService.hasSelection();
	                    this.selection.style("fill-opacity", function (d) {
	                        return streamGraphUtils.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights);
	                    });
	                };
	                return StreamGraphWebBehavior;
	            }());
	            var StreamGraph = (function () {
	                function StreamGraph() {
	                    this.margin = { left: YAxisOnSize, right: 15, bottom: XAxisOnSize, top: 10 };
	                }
	                StreamGraph.prototype.converter = function (dataView, colors, interactivityService) {
	                    if (!dataView ||
	                        !dataView.categorical ||
	                        !dataView.categorical.values ||
	                        !dataView.categorical.categories ||
	                        !colors) {
	                        return null;
	                    }
	                    var catDv = dataView.categorical, categories = catDv.categories, values = catDv.values, series = [], legendData = {
	                        dataPoints: [],
	                        title: values.source ? values.source.displayName : "",
	                        fontSize: StreamGraphDefaultFontSizeInPoints,
	                    }, value = 0, valueFormatter, categoryFormatter;
	                    var category = categories && categories.length > 0 ? categories[0] : null;
	                    var formatString = StreamGraph.Properties.general.formatString;
	                    var hasHighlights = !!(values.length > 0 && values[0].highlights);
	                    var streamGraphSettings = this.parseSettings(dataView);
	                    var fontSizeInPx = PixelConverter.fromPoint(streamGraphSettings.dataLabelsSettings.fontSize);
	                    for (var i = 0; i < values.length; i++) {
	                        var label = values[i].source.groupName;
	                        var identity = values[i].identity
	                            ? SelectionId.createWithId(values[i].identity)
	                            : SelectionId.createWithMeasure(values[i].source.queryName);
	                        if (label)
	                            legendData.dataPoints.push({
	                                label: label,
	                                color: colors.getColorByIndex(i).value,
	                                icon: LegendIcon.Box,
	                                selected: false,
	                                identity: identity
	                            });
	                        else
	                            label = values[i].source.displayName;
	                        var tooltipInfo = TooltipBuilder.createTooltipInfo(formatString, { categories: null, values: values }, null, null, null, null, i);
	                        series[i] = {
	                            dataPoints: [],
	                            tooltipInfo: tooltipInfo,
	                            highlight: hasHighlights,
	                            identity: identity,
	                            selected: false,
	                        };
	                        var dataPointsValues = values[i].values;
	                        if (dataPointsValues.length === 0)
	                            continue;
	                        for (var k = 0; k < dataPointsValues.length; k++) {
	                            var y = hasHighlights ? values[i].highlights[k] : dataPointsValues[k];
	                            if (y > value)
	                                value = y;
	                            series[i].dataPoints.push({
	                                x: k,
	                                y: isNaN(y) ? 0 : y,
	                                text: label,
	                                labelFontSize: fontSizeInPx
	                            });
	                        }
	                    }
	                    if (interactivityService)
	                        interactivityService.applySelectionStateToData(series);
	                    valueFormatter = ValueFormatter.create({
	                        format: "g",
	                        value: value
	                    });
	                    categoryFormatter = ValueFormatter.create({
	                        format: ValueFormatter.getFormatString(category.source, StreamGraph.Properties.general.formatString),
	                        value: category.values
	                    });
	                    var categoriesText = [];
	                    var getTextPropertiesFunction = this.getTextPropertiesFunction;
	                    for (var index = 0; index < category.values.length; index++) {
	                        var formattedValue = void 0;
	                        if (category.values[index] != null) {
	                            formattedValue = categoryFormatter.format(category.values[index]);
	                            var textLength = TextMeasurementService.measureSvgTextWidth(getTextPropertiesFunction(formattedValue));
	                            if (textLength > StreamGraph.MaxNumberOfAxisXValues)
	                                StreamGraph.MaxNumberOfAxisXValues = textLength;
	                        }
	                        categoriesText.push(formattedValue);
	                    }
	                    return {
	                        series: series,
	                        legendData: legendData,
	                        valueFormatter: valueFormatter,
	                        categoryFormatter: categoryFormatter,
	                        streamGraphSettings: streamGraphSettings,
	                        categoriesText: categoriesText
	                    };
	                };
	                StreamGraph.prototype.parseSettings = function (dataView) {
	                    if (!dataView || !dataView.metadata)
	                        return StreamGraphDefaultSettings;
	                    var objects = dataView.metadata.objects;
	                    var streamGraphSettings = _.cloneDeep(StreamGraphDefaultSettings);
	                    var categoryAxisSettings = streamGraphSettings.categoryAxisSettings;
	                    categoryAxisSettings.show = DataViewObjects.getValue(objects, StreamGraph.Properties.categoryAxis.show, categoryAxisSettings.show);
	                    categoryAxisSettings.labelColor = DataViewObjects.getFillColor(objects, StreamGraph.Properties.categoryAxis.labelColor, categoryAxisSettings.labelColor);
	                    categoryAxisSettings.showAxisTitle = DataViewObjects.getValue(objects, StreamGraph.Properties.categoryAxis.showAxisTitle, categoryAxisSettings.showAxisTitle);
	                    var valueAxisSettings = streamGraphSettings.valueAxisSettings;
	                    valueAxisSettings.show = DataViewObjects.getValue(objects, StreamGraph.Properties.valueAxis.show, valueAxisSettings.show);
	                    valueAxisSettings.labelColor = DataViewObjects.getFillColor(objects, StreamGraph.Properties.valueAxis.labelColor, valueAxisSettings.labelColor);
	                    valueAxisSettings.showAxisTitle = DataViewObjects.getValue(objects, StreamGraph.Properties.valueAxis.showAxisTitle, valueAxisSettings.showAxisTitle);
	                    var dataLabelsSettings = streamGraphSettings.dataLabelsSettings;
	                    dataLabelsSettings.show = DataViewObjects.getValue(objects, StreamGraph.Properties.labels.show, dataLabelsSettings.show);
	                    dataLabelsSettings.labelColor = DataViewObjects.getFillColor(objects, StreamGraph.Properties.labels.color, dataLabelsSettings.labelColor);
	                    dataLabelsSettings.fontSize = DataViewObjects.getValue(objects, StreamGraph.Properties.labels.fontSize, dataLabelsSettings.fontSize);
	                    var legendSettings = streamGraphSettings.legendSettings;
	                    var valuesSource = dataView.categorical.values.source;
	                    var titleTextDefault = valuesSource && _.isEmpty(legendSettings.titleText) ? valuesSource.displayName : legendSettings.titleText;
	                    legendSettings.show = DataViewObjects.getValue(objects, StreamGraph.Properties.legend.show, legendSettings.show);
	                    legendSettings.showTitle = DataViewObjects.getValue(objects, StreamGraph.Properties.legend.showTitle, legendSettings.showTitle);
	                    legendSettings.titleText = DataViewObjects.getValue(objects, StreamGraph.Properties.legend.titleText, titleTextDefault);
	                    legendSettings.labelColor = DataViewObjects.getValue(objects, StreamGraph.Properties.legend.labelColor, legendSettings.labelColor);
	                    legendSettings.fontSize = DataViewObjects.getValue(objects, StreamGraph.Properties.legend.fontSize, legendSettings.fontSize);
	                    if (_.isEmpty(legendSettings.titleText))
	                        legendSettings.titleText = titleTextDefault; // Force a value (shouldn't be empty with show=true)
	                    return streamGraphSettings;
	                };
	                StreamGraph.prototype.init = function (options) {
	                    var element = options.element;
	                    var svg = this.svg = d3.select(element.get(0))
	                        .append("svg")
	                        .classed(StreamGraph.VisualClassName, true)
	                        .style("position", "absolute");
	                    this.clearCatcher = appendClearCatcher(svg);
	                    this.axisGraphicsContext = svg.append("g").classed(StreamGraphAxisGraphicsContextClassName, true);
	                    this.xAxis = this.axisGraphicsContext.append("g").classed(StreamGraphXAxisClassName, true);
	                    this.yAxis = this.axisGraphicsContext.append("g").classed(StreamGraphYAxisClassName, true);
	                    this.dataPointsContainer = svg.append("g").classed(DataPointsContainer, true);
	                    this.viewport = options.viewport;
	                    this.colors = options.style.colorPalette.dataColors;
	                    this.behavior = new StreamGraphWebBehavior();
	                    var interactivity = options.interactivity;
	                    this.interactivityService = createInteractivityService(options.host);
	                    this.legend = createLegend(element, interactivity && interactivity.isInteractiveLegend, this.interactivityService, true);
	                };
	                StreamGraph.prototype.update = function (options) {
	                    if (!options.dataViews || !options.dataViews[0] || !options.dataViews[0].categorical) {
	                        this.clearData();
	                        return;
	                    }
	                    ;
	                    this.viewport = {
	                        width: Math.max(0, options.viewport.width),
	                        height: Math.max(0, options.viewport.height)
	                    };
	                    var duration = options.suppressAnimations ? 0 : 250, dataView = this.dataView = options.dataViews[0], data = this.data = this.converter(dataView, this.colors, this.interactivityService);
	                    if (!data || !data.series || !data.series.length) {
	                        this.clearData();
	                        return;
	                    }
	                    this.renderLegend(data);
	                    this.renderXAxisLabels();
	                    this.renderYAxisLabels();
	                    this.svg.attr({
	                        "width": this.viewport.width + "px",
	                        "height": this.viewport.height + "px"
	                    });
	                    var selection = this.renderChart(data.series, duration);
	                    TooltipManager.addTooltip(selection, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
	                    var interactivityService = this.interactivityService;
	                    if (interactivityService) {
	                        var behaviorOptions = {
	                            selection: selection,
	                            clearCatcher: this.clearCatcher,
	                            interactivityService: interactivityService,
	                        };
	                        interactivityService.bind(data.series, this.behavior, behaviorOptions);
	                    }
	                };
	                StreamGraph.prototype.getStreamGraphLabelLayout = function (xScale, yScale) {
	                    var dataLabelsSettings = this.data.streamGraphSettings.dataLabelsSettings;
	                    var fontSize = PixelConverter.fromPoint(dataLabelsSettings.fontSize);
	                    return {
	                        labelText: function (d) {
	                            return d.text;
	                        },
	                        labelLayout: {
	                            x: function (d) { return xScale(d.x); },
	                            y: function (d) { return yScale(d.y0); }
	                        },
	                        filter: function (d) {
	                            return (d != null && d.text != null);
	                        },
	                        style: {
	                            "fill": dataLabelsSettings.labelColor,
	                            "font-size": fontSize,
	                        },
	                    };
	                };
	                StreamGraph.prototype.renderChart = function (series, duration) {
	                    var _this = this;
	                    var stack = d3.layout.stack()
	                        .values(function (d) { return d.dataPoints; });
	                    var width = this.viewport.width;
	                    var height = this.viewport.height;
	                    if (this.getWiggle(this.dataView))
	                        stack.offset("wiggle");
	                    var layers = stack(series);
	                    var margin = this.margin;
	                    var xScale = d3.scale.linear()
	                        .domain([0, series[0].dataPoints.length - 1])
	                        .range([margin.left, width - margin.right]);
	                    var yMax = d3.max(layers, function (layer) {
	                        return d3.max(layer.dataPoints, function (d) {
	                            return d.y0 + d.y;
	                        });
	                    });
	                    var yMin = d3.min(layers, function (layer) {
	                        return d3.min(layer.dataPoints, function (d) {
	                            return d.y0 + d.y;
	                        });
	                    });
	                    var yScale = d3.scale.linear()
	                        .domain([Math.min(yMin, 0), yMax])
	                        .range([height - margin.bottom, margin.top])
	                        .nice();
	                    var area = d3.svg.area()
	                        .interpolate("monotone")
	                        .x(function (d) { return xScale(d.x); })
	                        .y0(function (d) { return yScale(d.y0); })
	                        .y1(function (d) { return yScale(d.y0 + d.y); })
	                        .defined(function (d) { return !isNaN(d.y0) && !isNaN(d.y); });
	                    var selection = this.dataPointsContainer.selectAll(StreamGraph.Layer.selector)
	                        .data(layers);
	                    selection.enter()
	                        .append("path")
	                        .classed(StreamGraph.Layer.class, true);
	                    selection
	                        .style("fill", function (d, i) { return _this.colors.getColorByIndex(i).value; })
	                        .style("fill-opacity", streamGraphUtils.DefaultOpacity)
	                        .transition()
	                        .duration(duration)
	                        .attr("d", function (d) { return area(d.dataPoints); });
	                    selection.selectAll("path").append("g").classed(DataPointsContainer, true);
	                    selection.exit().remove();
	                    if (this.data.streamGraphSettings.dataLabelsSettings.show) {
	                        var labelsXScale = d3.scale.linear()
	                            .domain([0, series[0].dataPoints.length - 1])
	                            .range([0, width - margin.left - margin.right]);
	                        var layout = this.getStreamGraphLabelLayout(labelsXScale, yScale);
	                        // Merge all points into a single array
	                        var dataPointsArray_1 = [];
	                        series.forEach(function (seriesItem) {
	                            var filteredDataPoints;
	                            filteredDataPoints = seriesItem.dataPoints.filter(function (dataPoint) {
	                                return dataPoint && dataPoint.y !== null && dataPoint.y !== undefined;
	                            });
	                            if (filteredDataPoints.length > 0) {
	                                dataPointsArray_1 = dataPointsArray_1.concat(filteredDataPoints);
	                            }
	                        });
	                        var viewport = {
	                            height: height - margin.top - margin.bottom,
	                            width: width - margin.right - margin.left,
	                        };
	                        var labels = dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPointsArray_1, this.svg, layout, viewport);
	                        if (labels) {
	                            var offset_1 = DefaultDataLabelsOffset + margin.left;
	                            labels.attr("transform", function (d) { return SVGUtil.translate(offset_1 + (d.size.width / 2), d.size.height / 2); });
	                        }
	                    }
	                    else {
	                        dataLabelUtils.cleanDataLabels(this.svg);
	                    }
	                    this.drawAxis(this.data, xScale, yScale);
	                    return selection;
	                };
	                StreamGraph.prototype.drawAxis = function (data, xScale, yScale) {
	                    var margin = this.margin, shiftY = this.viewport.height - margin.bottom, shiftX = this.viewport.width - margin.left - margin.right, categoriesText = this.data.categoriesText, xAxis = d3.svg.axis(), maxNumberOfAxisXValues = StreamGraph.MaxNumberOfAxisXValues, getTextPropertiesFunction = this.getTextPropertiesFunction;
	                    for (var index = 0; index < categoriesText.length; index++) {
	                        if (categoriesText[index] != null) {
	                            var str = categoriesText[index].toString();
	                            var textLength = TextMeasurementService.measureSvgTextWidth(getTextPropertiesFunction(str));
	                            if (textLength > maxNumberOfAxisXValues)
	                                maxNumberOfAxisXValues = textLength;
	                        }
	                    }
	                    xAxis.scale(xScale)
	                        .orient("bottom")
	                        .ticks(categoriesText.length)
	                        .tickFormat(function (index) {
	                        var item = categoriesText[index];
	                        if (data.categoryFormatter) {
	                            item = data.categoryFormatter.format(item);
	                        }
	                        if (index !== null && index !== undefined &&
	                            (index === 0 || index === categoriesText.length - 1)) {
	                            item = TextMeasurementService.getTailoredTextOrDefault(getTextPropertiesFunction(item), (index ? margin.right : margin.left) * 2);
	                        }
	                        return item;
	                    });
	                    var yAxis = d3.svg.axis()
	                        .scale(yScale)
	                        .orient("left")
	                        .tickFormat(function (item) {
	                        var tempItem = item;
	                        if (data.valueFormatter) {
	                            tempItem = data.valueFormatter.format(tempItem);
	                        }
	                        tempItem = TextMeasurementService.getTailoredTextOrDefault(getTextPropertiesFunction(tempItem.toString()), YAxisOnSize - DefaultLabelTickWidth);
	                        return tempItem;
	                    });
	                    this.setMaxTicks(xAxis, shiftX, Math.max(2, Math.round(shiftX / maxNumberOfAxisXValues)));
	                    this.setMaxTicks(yAxis, shiftY);
	                    var valueAxisSettings = this.data.streamGraphSettings.valueAxisSettings;
	                    if (valueAxisSettings.show) {
	                        var axisColor = valueAxisSettings.labelColor;
	                        this.yAxis
	                            .attr("transform", SVGUtil.translate(margin.left, 0))
	                            .call(yAxis);
	                        this.yAxis.selectAll("text").style("fill", axisColor);
	                    }
	                    else
	                        this.yAxis.selectAll("*").remove();
	                    var categoryAxisSettings = this.data.streamGraphSettings.categoryAxisSettings;
	                    if (categoryAxisSettings.show) {
	                        var axisColor = categoryAxisSettings.labelColor;
	                        this.xAxis
	                            .attr("transform", SVGUtil.translate(0, shiftY))
	                            .call(xAxis);
	                        this.xAxis.selectAll("text").style("fill", axisColor);
	                    }
	                    else
	                        this.xAxis.selectAll("*").remove();
	                };
	                StreamGraph.prototype.renderYAxisLabels = function () {
	                    this.axisGraphicsContext.selectAll(StreamGraph.YAxisLabel.selector).remove();
	                    var valueAxisSettings = this.data.streamGraphSettings.valueAxisSettings;
	                    this.margin.left = valueAxisSettings.show ? YAxisOnSize : YAxisOffSize;
	                    if (valueAxisSettings.showAxisTitle) {
	                        this.margin.left += YAxisLabelSize;
	                        var categoryAxisSettings = this.data.streamGraphSettings.categoryAxisSettings;
	                        var isXAxisOn = categoryAxisSettings.show === true;
	                        var isXTitleOn = categoryAxisSettings.showAxisTitle === true;
	                        var marginTop_1 = this.margin.top;
	                        var height_1 = this.viewport.height - marginTop_1 - (isXAxisOn ? XAxisOnSize : XAxisOffSize) - (isXTitleOn ? XAxisLabelSize : 0);
	                        var values = this.dataView.categorical.values;
	                        var yAxisText = values.source ? values.source.displayName : this.getYAxisTitleFromValues(values);
	                        var textSettings = this.getTextPropertiesFunction(yAxisText);
	                        yAxisText = TextMeasurementService.getTailoredTextOrDefault(textSettings, height_1);
	                        var yAxisClass_1 = StreamGraph.YAxisLabel.class;
	                        var yAxisLabel = this.axisGraphicsContext.append("text")
	                            .style("text-anchor", "middle")
	                            .style("font-family", textSettings.fontFamily)
	                            .style("font-size", textSettings.fontSize)
	                            .style("font-style", textSettings.fontStyle)
	                            .style("font-weight", textSettings.fontWeight)
	                            .text(yAxisText)
	                            .call(function (text) {
	                            text.each(function () {
	                                var text = d3.select(this);
	                                text.attr({
	                                    class: yAxisClass_1,
	                                    transform: "rotate(-90)",
	                                    fill: valueAxisSettings.labelColor,
	                                    x: -(marginTop_1 + (height_1 / 2)),
	                                    dy: "1em"
	                                });
	                            });
	                        });
	                        yAxisLabel.call(AxisHelper.LabelLayoutStrategy.clip, height_1, TextMeasurementService.svgEllipsis);
	                    }
	                };
	                StreamGraph.prototype.getYAxisTitleFromValues = function (values) {
	                    var valuesMetadataArray = [];
	                    for (var i = 0; i < values.length; i++) {
	                        if (values[i] && values[i].source && values[i].source.displayName) {
	                            valuesMetadataArray.push({ displayName: values[i].source.displayName });
	                        }
	                    }
	                    var valuesNames = valuesMetadataArray.map(function (v) { return v ? v.displayName : ""; }).filter(function (value, index, self) { return value !== "" && self.indexOf(value) === index; });
	                    return valueFormatter.formatListAnd(valuesNames);
	                };
	                StreamGraph.prototype.renderXAxisLabels = function () {
	                    this.axisGraphicsContext.selectAll(StreamGraph.XAxisLabel.selector).remove();
	                    var categoryAxisSettings = this.data.streamGraphSettings.categoryAxisSettings;
	                    this.margin.bottom = categoryAxisSettings.show ? XAxisOnSize : XAxisOffSize;
	                    if (categoryAxisSettings.showAxisTitle)
	                        if (this.dataView.categorical.categories[0].source) {
	                            this.margin.bottom += XAxisLabelSize;
	                            var valueAxisSettings = this.data.streamGraphSettings.valueAxisSettings;
	                            var isYAxisOn = valueAxisSettings.show === true;
	                            var isYTitleOn = valueAxisSettings.showAxisTitle === true;
	                            var leftMargin_1 = (isYAxisOn ? YAxisOnSize : YAxisOffSize) + (isYTitleOn ? YAxisLabelSize : 0);
	                            var width_1 = this.viewport.width - this.margin.right - leftMargin_1;
	                            var height_2 = this.viewport.height;
	                            var xAxisText = this.dataView.categorical.categories[0].source.displayName;
	                            var textSettings = this.getTextPropertiesFunction(xAxisText);
	                            xAxisText = TextMeasurementService.getTailoredTextOrDefault(textSettings, width_1);
	                            var xAxisClass_1 = StreamGraph.XAxisLabel.class;
	                            var xAxisLabel = this.axisGraphicsContext.append("text")
	                                .style("text-anchor", "middle")
	                                .style("font-family", textSettings.fontFamily)
	                                .style("font-size", textSettings.fontSize)
	                                .style("font-weight", textSettings.fontWeight)
	                                .text(xAxisText)
	                                .call(function (text) {
	                                text.each(function () {
	                                    var text = d3.select(this);
	                                    text.attr({
	                                        class: xAxisClass_1,
	                                        transform: SVGUtil.translate(leftMargin_1 + (width_1 / 2), height_2),
	                                        fill: categoryAxisSettings.labelColor,
	                                        dy: "-0.5em",
	                                    });
	                                });
	                            });
	                            xAxisLabel.call(AxisHelper.LabelLayoutStrategy.clip, width_1, TextMeasurementService.svgEllipsis);
	                        }
	                };
	                StreamGraph.prototype.renderLegend = function (streamGraphData) {
	                    var legendSettings = streamGraphData.streamGraphSettings.legendSettings;
	                    var legendData = streamGraphData.legendData;
	                    if (!this.dataView || !this.dataView.metadata)
	                        return;
	                    var legendObjectProperties = DataViewObjects.getObject(this.dataView.metadata.objects, "legend", {});
	                    legendObjectProperties["titleText"] = legendSettings.titleText; // Force legend title when show = true
	                    LegendData.update(legendData, legendObjectProperties);
	                    var position = legendObjectProperties[legendProps.position];
	                    if (position)
	                        this.legend.changeOrientation(LegendPosition[position]);
	                    this.legend.drawLegend(legendData, _.clone(this.viewport));
	                    Legend.positionChartArea(this.svg, this.legend);
	                    this.updateViewPort();
	                };
	                StreamGraph.prototype.updateViewPort = function () {
	                    var legendMargins = this.legend.getMargins(), legendPosition = this.legend.getOrientation();
	                    switch (legendPosition) {
	                        case LegendPosition.Top:
	                        case LegendPosition.TopCenter:
	                        case LegendPosition.Bottom:
	                        case LegendPosition.BottomCenter: {
	                            this.viewport.height = Math.max(0, this.viewport.height - legendMargins.height);
	                            break;
	                        }
	                        case LegendPosition.Left:
	                        case LegendPosition.LeftCenter:
	                        case LegendPosition.Right:
	                        case LegendPosition.RightCenter: {
	                            this.viewport.width = Math.max(0, this.viewport.width - legendMargins.width);
	                            break;
	                        }
	                    }
	                };
	                StreamGraph.prototype.setMaxTicks = function (axis, maxSize, maxValue) {
	                    var maxTicks = maxValue === undefined
	                        ? this.getTicksByAxis(axis).length
	                        : Math.min(maxValue, this.getTicksByAxis(axis).length);
	                    if (axis.scale().domain.toString() === d3.scale.linear().domain.toString())
	                        axis.ticks(this.getFittedTickLength(axis, maxSize, maxTicks));
	                    else
	                        axis.tickValues(this.getFittedTickValues(axis, maxSize, maxTicks));
	                };
	                StreamGraph.prototype.getFittedTickLength = function (axis, maxSize, maxTicks) {
	                    for (var ticks = this.getTicksByAxis(axis), measureTickFunction = this.getMeasureTickFunction(axis, ticks); maxTicks > 0 && maxSize > 0 && (this.measureTicks(ticks, measureTickFunction) > maxSize || axis.scale().ticks([maxTicks]).length > maxTicks); maxTicks--, ticks = this.getTicksByAxis(axis)) {
	                        axis.ticks(maxTicks);
	                    }
	                    return maxTicks;
	                };
	                StreamGraph.prototype.getFittedTickValues = function (axis, maxSize, maxTicks) {
	                    var ticks = this.getTicksByAxis(axis), maxWidthOf2Ticks, tickPairsWidths = [], measureTickFunction = this.getMeasureTickFunction(axis, ticks);
	                    for (var currentMaxTicks = maxTicks, indexes = []; maxTicks > 0 && maxSize > 0; currentMaxTicks--, indexes = []) {
	                        switch (currentMaxTicks) {
	                            case 0:
	                                return [];
	                            case 1:
	                                indexes = [0];
	                                break;
	                            case 2:
	                                indexes = [0, ticks.length - 1];
	                                break;
	                            default:
	                                var takeEvery = ticks.length / (currentMaxTicks - 1);
	                                for (var i = 0; i < currentMaxTicks - 1; i++) {
	                                    indexes.push(Math.round(takeEvery * i));
	                                }
	                                indexes.push(ticks.length - 1);
	                                break;
	                        }
	                        var ticksIndexes = indexes.map(function (x) { return [ticks[x], x]; });
	                        maxWidthOf2Ticks = (maxSize / ticks.length) * 2;
	                        ticksIndexes.reduce(function (a, b) {
	                            tickPairsWidths.push([measureTickFunction(a[0]) + measureTickFunction(b[0]), (b[1] - a[1]) * maxWidthOf2Ticks]);
	                            return b;
	                        });
	                        if (!tickPairsWidths.some(function (x) { return x[0] > x[1]; })) {
	                            return ticksIndexes.map(function (x) { return x[0]; });
	                        }
	                    }
	                    return [];
	                };
	                StreamGraph.prototype.measureTicks = function (ticks, measureTickFunction) {
	                    return ticks.map(function (x) { return measureTickFunction(x); }).reduce(function (a, b) { return a + b; });
	                };
	                StreamGraph.prototype.getTicksByAxis = function (axis) {
	                    var scale = axis.scale();
	                    var result = axis.tickValues() === null
	                        ? scale.ticks
	                            ? scale.ticks.apply(scale, axis.ticks())
	                            : scale.domain()
	                        : axis.tickValues();
	                    return result.length === undefined ? [result] : result;
	                };
	                StreamGraph.prototype.getMeasureTickFunction = function (axis, ticks) {
	                    var measureFunction = axis.orient() === "top" || axis.orient() === "bottom"
	                        ? TextMeasurementService.measureSvgTextWidth
	                        : TextMeasurementService.measureSvgTextHeight;
	                    var getTextPropertiesFunction = this.getTextPropertiesFunction;
	                    var cache = {};
	                    return function (x) {
	                        return cache[x]
	                            ? cache[x]
	                            : cache[x] = measureFunction(getTextPropertiesFunction(axis.tickFormat()(x))) + axis.tickPadding();
	                    };
	                };
	                StreamGraph.prototype.getTextPropertiesFunction = function (text) {
	                    var fontFamily = StreamGraphDefaultFontFamily, fontSize = PixelConverter.fromPoint(StreamGraphDefaultFontSizeInPoints), fontWeight = StreamGraphDefaultFontWeight;
	                    return { text: text, fontFamily: fontFamily, fontSize: fontSize, fontWeight: fontWeight };
	                };
	                StreamGraph.prototype.getWiggle = function (dataView) {
	                    if (dataView && dataView.metadata) {
	                        var objects = dataView.metadata.objects;
	                        if (objects) {
	                            var general = DataViewObjects.getObject(objects, "general", undefined);
	                            if (general)
	                                return general["wiggle"];
	                        }
	                    }
	                    return true;
	                };
	                StreamGraph.prototype.enumerateValueAxisValues = function (enumeration) {
	                    var valueAxisSettings = this.data && this.data.streamGraphSettings ? this.data.streamGraphSettings.valueAxisSettings : StreamGraphDefaultSettings.valueAxisSettings;
	                    enumeration.pushInstance({
	                        selector: null,
	                        objectName: "valueAxis",
	                        displayName: "Y-Axis",
	                        properties: {
	                            show: valueAxisSettings.show,
	                            showAxisTitle: valueAxisSettings.showAxisTitle,
	                            labelColor: valueAxisSettings.labelColor,
	                        }
	                    });
	                };
	                StreamGraph.prototype.enumerateCategoryAxisValues = function (enumeration) {
	                    var categoryAxisSettings = this.data && this.data.streamGraphSettings ? this.data.streamGraphSettings.categoryAxisSettings : StreamGraphDefaultSettings.categoryAxisSettings;
	                    enumeration.pushInstance({
	                        selector: null,
	                        objectName: "categoryAxis",
	                        displayName: "X-Axis",
	                        properties: {
	                            show: categoryAxisSettings.show,
	                            showAxisTitle: categoryAxisSettings.showAxisTitle,
	                            labelColor: categoryAxisSettings.labelColor,
	                        }
	                    });
	                };
	                StreamGraph.prototype.enumerateLegend = function (enumeration) {
	                    var legendSettings = this.data && this.data.streamGraphSettings ? this.data.streamGraphSettings.legendSettings : StreamGraphDefaultSettings.legendSettings;
	                    enumeration.pushInstance({
	                        selector: null,
	                        objectName: "legend",
	                        displayName: "Legend",
	                        properties: {
	                            show: legendSettings.show,
	                            position: LegendPosition[this.legend.getOrientation()],
	                            showTitle: legendSettings.showTitle,
	                            titleText: legendSettings.titleText,
	                            labelColor: legendSettings.labelColor,
	                            fontSize: legendSettings.fontSize,
	                        }
	                    });
	                };
	                StreamGraph.prototype.clearData = function () {
	                    this.svg.selectAll(StreamGraph.Layer.selector).remove();
	                    this.legend.drawLegend({ dataPoints: [] }, this.viewport);
	                    this.yAxis.selectAll("*").remove();
	                    this.axisGraphicsContext.selectAll(StreamGraph.YAxisLabel.selector).remove();
	                    this.xAxis.selectAll("*").remove();
	                    this.axisGraphicsContext.selectAll(StreamGraph.XAxisLabel.selector).remove();
	                    this.svg.select(".labels").remove();
	                };
	                StreamGraph.prototype.onClearSelection = function () {
	                    if (this.interactivityService)
	                        this.interactivityService.clearSelection();
	                };
	                StreamGraph.prototype.enumerateObjectInstances = function (options) {
	                    var enumeration = new ObjectEnumerationBuilder(), dataView = this.dataView;
	                    var dataLabelsSettings;
	                    if (this.data) {
	                        dataLabelsSettings = this.data.streamGraphSettings.dataLabelsSettings
	                            ? this.data.streamGraphSettings.dataLabelsSettings
	                            : StreamGraphDefaultSettings.dataLabelsSettings;
	                    }
	                    switch (options.objectName) {
	                        case "legend": {
	                            if (dataView
	                                && dataView.categorical
	                                && dataView.categorical.values
	                                && dataView.categorical.values.source)
	                                this.enumerateLegend(enumeration);
	                            break;
	                        }
	                        case "categoryAxis": {
	                            this.enumerateCategoryAxisValues(enumeration);
	                            break;
	                        }
	                        case "valueAxis": {
	                            this.enumerateValueAxisValues(enumeration);
	                            break;
	                        }
	                        case "labels": {
	                            var labelSettingOptions = {
	                                enumeration: enumeration,
	                                dataLabelsSettings: dataLabelsSettings,
	                                show: true,
	                                fontSize: true,
	                            };
	                            dataLabelUtils.enumerateDataLabels(labelSettingOptions);
	                            break;
	                        }
	                        case "general": {
	                            var general = {
	                                objectName: "general",
	                                displayName: "General",
	                                selector: null,
	                                properties: {
	                                    wiggle: this.getWiggle(dataView)
	                                }
	                            };
	                            enumeration.pushInstance(general);
	                            break;
	                        }
	                    }
	                    return enumeration.complete();
	                };
	                StreamGraph.VisualClassName = "streamGraph";
	                StreamGraph.Properties = {
	                    general: {
	                        formatString: {
	                            objectName: "general",
	                            propertyName: "formatString"
	                        }
	                    },
	                    legend: {
	                        show: {
	                            objectName: "legend",
	                            propertyName: "show"
	                        },
	                        showTitle: {
	                            objectName: "legend",
	                            propertyName: "showTitle"
	                        },
	                        titleText: {
	                            objectName: "legend",
	                            propertyName: "titleText"
	                        },
	                        labelColor: {
	                            objectName: "legend",
	                            propertyName: "labelColor"
	                        },
	                        fontSize: {
	                            objectName: "legend",
	                            propertyName: "fontSize"
	                        }
	                    },
	                    categoryAxis: {
	                        show: {
	                            objectName: "categoryAxis",
	                            propertyName: "show"
	                        },
	                        labelColor: {
	                            objectName: "categoryAxis",
	                            propertyName: "labelColor"
	                        },
	                        showAxisTitle: {
	                            objectName: "categoryAxis",
	                            propertyName: "showAxisTitle"
	                        }
	                    },
	                    valueAxis: {
	                        show: {
	                            objectName: "valueAxis",
	                            propertyName: "show"
	                        },
	                        labelColor: {
	                            objectName: "valueAxis",
	                            propertyName: "labelColor"
	                        },
	                        showAxisTitle: {
	                            objectName: "valueAxis",
	                            propertyName: "showAxisTitle"
	                        }
	                    },
	                    labels: {
	                        show: {
	                            objectName: "labels",
	                            propertyName: "show"
	                        },
	                        color: {
	                            objectName: "labels",
	                            propertyName: "color"
	                        },
	                        fontSize: {
	                            objectName: "labels",
	                            propertyName: "fontSize"
	                        }
	                    }
	                };
	                StreamGraph.Layer = {
	                    "class": "layer",
	                    selector: ".layer"
	                };
	                StreamGraph.XAxisLabel = {
	                    "class": "xAxisLabel",
	                    selector: ".xAxisLabel"
	                };
	                StreamGraph.YAxisLabel = {
	                    "class": "yAxisLabel",
	                    selector: ".yAxisLabel"
	                };
	                StreamGraph.MaxNumberOfAxisXValues = 5;
	                StreamGraph.capabilities = {
	                    dataRoles: [
	                        {
	                            name: "Category",
	                            kind: VisualDataRoleKind.Grouping,
	                            displayName: "Category",
	                        }, {
	                            name: "Series",
	                            kind: VisualDataRoleKind.Grouping,
	                            displayName: "Series",
	                        }, {
	                            name: "Y",
	                            kind: VisualDataRoleKind.Measure,
	                            displayName: createDisplayNameGetter("Role_DisplayName_Values"),
	                        }
	                    ],
	                    dataViewMappings: [{
	                            conditions: [
	                                { "Category": { max: 1 }, "Series": { max: 0 } },
	                                { "Category": { max: 1 }, "Series": { min: 1, max: 1 }, "Y": { max: 1 } }
	                            ],
	                            categorical: {
	                                categories: {
	                                    for: { in: "Category" },
	                                    dataReductionAlgorithm: { bottom: {} }
	                                },
	                                values: {
	                                    group: {
	                                        by: "Series",
	                                        select: [{ for: { in: "Y" } }],
	                                        dataReductionAlgorithm: { bottom: {} }
	                                    }
	                                },
	                            }
	                        }],
	                    objects: {
	                        general: {
	                            displayName: "General",
	                            properties: {
	                                formatString: { type: { formatting: { formatString: true } } },
	                                wiggle: {
	                                    type: { bool: true },
	                                    displayName: "Wiggle"
	                                }
	                            }
	                        },
	                        categoryAxis: {
	                            displayName: "X-Axis",
	                            properties: {
	                                show: {
	                                    displayName: "show",
	                                    type: { bool: true }
	                                },
	                                showAxisTitle: {
	                                    displayName: "Title",
	                                    type: { bool: true }
	                                },
	                                labelColor: {
	                                    displayName: "Color",
	                                    type: { fill: { solid: { color: true } } }
	                                }
	                            }
	                        },
	                        valueAxis: {
	                            displayName: "Y-Axis",
	                            properties: {
	                                show: {
	                                    displayName: "show",
	                                    type: { bool: true }
	                                },
	                                showAxisTitle: {
	                                    displayName: "Title",
	                                    type: { bool: true }
	                                },
	                                labelColor: {
	                                    displayName: "Color",
	                                    type: { fill: { solid: { color: true } } }
	                                }
	                            }
	                        },
	                        legend: {
	                            displayName: "Legend",
	                            properties: {
	                                show: {
	                                    displayName: "show",
	                                    type: { bool: true }
	                                },
	                                position: {
	                                    displayName: "Position",
	                                    type: { enumeration: legendPosition.type }
	                                },
	                                showTitle: {
	                                    displayName: "Title",
	                                    type: { bool: true }
	                                },
	                                titleText: {
	                                    displayName: "Legend Name",
	                                    type: { text: true },
	                                    suppressFormatPainterCopy: true
	                                },
	                                labelColor: {
	                                    displayName: "Color",
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                fontSize: {
	                                    displayName: "Text Size",
	                                    type: { formatting: { fontSize: true } }
	                                }
	                            }
	                        },
	                        labels: {
	                            displayName: "Data Labels",
	                            properties: {
	                                show: {
	                                    displayName: "Show",
	                                    type: { bool: true },
	                                },
	                                color: {
	                                    displayName: "Color",
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                fontSize: {
	                                    displayName: "Text Size",
	                                    type: { formatting: { fontSize: true } },
	                                },
	                            }
	                        }
	                    },
	                    supportsHighlight: true,
	                };
	                return StreamGraph;
	            }());
	            samples.StreamGraph = StreamGraph;
	            var streamGraphUtils;
	            (function (streamGraphUtils) {
	                streamGraphUtils.DimmedOpacity = 0.4;
	                streamGraphUtils.DefaultOpacity = 1.0;
	                function getFillOpacity(selected, highlight, hasSelection, hasPartialHighlights) {
	                    if ((hasPartialHighlights && !highlight) || (hasSelection && !selected))
	                        return streamGraphUtils.DimmedOpacity;
	                    return streamGraphUtils.DefaultOpacity;
	                }
	                streamGraphUtils.getFillOpacity = getFillOpacity;
	            })(streamGraphUtils = samples.streamGraphUtils || (samples.streamGraphUtils = {}));
	        })(samples = visuals.samples || (visuals.samples = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 55 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../../../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var samples;
	        (function (samples) {
	            var SelectionManager = visuals.utility.SelectionManager;
	            var ValueFormatter = powerbi.visuals.valueFormatter;
	            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
	            var TextMeasurementService = powerbi.TextMeasurementService;
	            var defaultLabelPrecision = visuals.dataLabelUtils.defaultLabelPrecision;
	            var defaultLabelColor = visuals.dataLabelUtils.defaultLabelColor;
	            var DefaultFontSizeInPt = visuals.dataLabelUtils.DefaultFontSizeInPt;
	            var defaultLabelDensity = visuals.dataLabelUtils.defaultLabelDensity;
	            function createEnumTypeFromEnum(type) {
	                var even = false;
	                return powerbi.createEnumType(Object.keys(type)
	                    .filter(function (key, i) { return ((!!(i % 2)) === even && type[key] === key && !void (even === !even)) || (!!(i % 2)) !== even; })
	                    .map(function (x) { return { value: x, displayName: x }; }));
	            }
	            samples.createEnumTypeFromEnum = createEnumTypeFromEnum;
	            (function (PulseChartXAxisDateFormat) {
	                //DateAndTime = <any>'Date and time',
	                PulseChartXAxisDateFormat[PulseChartXAxisDateFormat["DateOnly"] = 'Date only'] = "DateOnly";
	                PulseChartXAxisDateFormat[PulseChartXAxisDateFormat["TimeOnly"] = 'Time only'] = "TimeOnly";
	            })(samples.PulseChartXAxisDateFormat || (samples.PulseChartXAxisDateFormat = {}));
	            var PulseChartXAxisDateFormat = samples.PulseChartXAxisDateFormat;
	            (function (XAxisPosition) {
	                XAxisPosition[XAxisPosition["Center"] = 'Center'] = "Center";
	                XAxisPosition[XAxisPosition["Bottom"] = 'Bottom'] = "Bottom";
	            })(samples.XAxisPosition || (samples.XAxisPosition = {}));
	            var XAxisPosition = samples.XAxisPosition;
	            (function (RunnerCounterPosition) {
	                RunnerCounterPosition[RunnerCounterPosition["TopLeft"] = 'Top Left'] = "TopLeft";
	                RunnerCounterPosition[RunnerCounterPosition["TopRight"] = 'Top Right'] = "TopRight";
	            })(samples.RunnerCounterPosition || (samples.RunnerCounterPosition = {}));
	            var RunnerCounterPosition = samples.RunnerCounterPosition;
	            var PulseChart = (function () {
	                function PulseChart(options) {
	                    if (options) {
	                        if (options.svg) {
	                            this.svg = options.svg;
	                        }
	                    }
	                    this.margin = PulseChart.DefaultMargin;
	                }
	                PulseChart.getProperties = function (capabilities) {
	                    var result = {};
	                    for (var objectKey in capabilities.objects) {
	                        result[objectKey] = {};
	                        for (var propKey in capabilities.objects[objectKey].properties) {
	                            result[objectKey][propKey] = {
	                                objectName: objectKey,
	                                propertyName: propKey
	                            };
	                        }
	                    }
	                    return result;
	                };
	                PulseChart.GetPopupValueTextProperties = function (text, fontSizeValue) {
	                    if (fontSizeValue === void 0) { fontSizeValue = 12; }
	                    return {
	                        text: text || "",
	                        fontFamily: "sans-serif",
	                        fontSize: fontSizeValue + "px",
	                    };
	                };
	                PulseChart.GetPopupTitleTextProperties = function (text, fontSizeValue) {
	                    if (fontSizeValue === void 0) { fontSizeValue = 12; }
	                    return {
	                        text: text || "",
	                        fontFamily: "sans-serif",
	                        fontWeight: "bold",
	                        fontSize: fontSizeValue + "px",
	                    };
	                };
	                PulseChart.GetPopupDescriptionTextProperties = function (text, fontSizeValue) {
	                    if (fontSizeValue === void 0) { fontSizeValue = 12; }
	                    return {
	                        text: text || "",
	                        fontFamily: "sans-serif",
	                        fontSize: fontSizeValue + "px",
	                    };
	                };
	                PulseChart.GetRunnerCounterTextProperties = function (text, fontSizeValue) {
	                    if (fontSizeValue === void 0) { fontSizeValue = 12; }
	                    return {
	                        text: text || "",
	                        fontFamily: "sans-serif",
	                        fontSize: fontSizeValue + "px",
	                    };
	                };
	                PulseChart.ConvertTextPropertiesToStyle = function (textProperties) {
	                    return {
	                        'font-family': textProperties.fontFamily,
	                        'font-weight': textProperties.fontWeight,
	                        'font-size': textProperties.fontSize
	                    };
	                };
	                PulseChart.GetDateTimeFormatString = function (dateFormatType, dateFormat) {
	                    switch (dateFormatType) {
	                        case PulseChartXAxisDateFormat.DateOnly: return dateFormat;
	                        case PulseChartXAxisDateFormat.TimeOnly: return "H:mm";
	                        default: return "";
	                    }
	                    ;
	                };
	                PulseChart.GetFullWidthOfDateFormat = function (dateFormat, textProperties) {
	                    textProperties.text = visuals.valueFormatter.create({ format: dateFormat }).format(new Date(2000, 10, 20, 20, 20, 20));
	                    return TextMeasurementService.measureSvgTextWidth(textProperties);
	                };
	                PulseChart.AddOnTouchClick = function (selection, callback) {
	                    var preventDefaultCallback = function (data, index) { d3.event.preventDefault(); callback(data, index); };
	                    return selection.on("click", preventDefaultCallback).on("touchstart", preventDefaultCallback);
	                };
	                PulseChart.getCategoricalColumnOfRole = function (dataView, roleName) {
	                    var filterFunc = function (cols) { return cols.filter(function (x) { return x.source && x.source.roles && x.source.roles[roleName]; })[0]; };
	                    return filterFunc(dataView.categorical.categories) || filterFunc(dataView.categorical.values);
	                };
	                PulseChart.converter = function (dataView, colors, interactivityService) {
	                    if (!dataView
	                        || !dataView.categorical
	                        || !dataView.categorical.values
	                        || !dataView.categorical.values[0]
	                        || !dataView.categorical.values[0].values
	                        || !dataView.categorical.categories) {
	                        return null;
	                    }
	                    var columns = _.mapValues(PulseChart.RoleNames, function (x, i) { return PulseChart.getCategoricalColumnOfRole(dataView, i); });
	                    var timeStampColumn = columns.Timestamp;
	                    if (!timeStampColumn) {
	                        return null;
	                    }
	                    var isScalar = !(timeStampColumn.source && timeStampColumn.source.type && timeStampColumn.source.type.dateTime);
	                    var settings = PulseChart.parseSettings(dataView, colors, columns);
	                    var categoryValues = timeStampColumn.values;
	                    if (!categoryValues || _.isEmpty(dataView.categorical.values) || !columns.Value || _.isEmpty(columns.Value.values)) {
	                        return null;
	                    }
	                    var minValuesValue = Math.min.apply(null, columns.Value.values), maxValuesValue = Math.max.apply(null, columns.Value.values);
	                    var minCategoryValue = Math.min.apply(null, categoryValues), maxCategoryValue = Math.max.apply(null, categoryValues);
	                    settings.xAxis.dateFormat =
	                        (maxCategoryValue - minCategoryValue < (24 * 60 * 60 * 1000)
	                            && new Date(maxCategoryValue).getDate() === new Date(minCategoryValue).getDate())
	                            ? PulseChartXAxisDateFormat.TimeOnly
	                            : PulseChartXAxisDateFormat.DateOnly;
	                    settings.xAxis.formatterOptions = {
	                        value: isScalar ? minCategoryValue : new Date(minCategoryValue),
	                        value2: isScalar ? maxCategoryValue : new Date(maxCategoryValue)
	                    };
	                    settings.yAxis.formatterOptions = {
	                        value: minValuesValue,
	                        value2: maxValuesValue,
	                        format: ValueFormatter.getFormatString(columns.Value.source, PulseChart.DefaultSettings.formatStringProperty)
	                    };
	                    if (isScalar) {
	                        settings.xAxis.formatterOptions.format = ValueFormatter.getFormatString(timeStampColumn.source, PulseChart.DefaultSettings.formatStringProperty);
	                    }
	                    else {
	                        settings.xAxis.formatterOptions.format = PulseChart.GetDateTimeFormatString(settings.xAxis.dateFormat, timeStampColumn.source.format);
	                    }
	                    var widthOfXAxisLabel = 70;
	                    var widthOfTooltipValueLabel = isScalar ? 60 : PulseChart.GetFullWidthOfDateFormat(timeStampColumn.source.format, PulseChart.GetPopupValueTextProperties()) + 5;
	                    var heightOfTooltipDescriptionTextLine = TextMeasurementService.measureSvgTextHeight(PulseChart.GetPopupDescriptionTextProperties("lj", settings.popup.fontSize));
	                    var runnerCounterFormatString = columns.RunnerCounter && visuals.valueFormatter.getFormatString(columns.RunnerCounter.source, settings.formatStringProperty);
	                    settings.popup.width = Math.max(widthOfTooltipValueLabel + 20, settings.popup.width);
	                    var minSize = PulseChart.DefaultSettings.dots.minSize;
	                    var maxSize = PulseChart.DefaultSettings.dots.maxSize;
	                    if (settings.dots) {
	                        minSize = settings.dots.minSize;
	                        maxSize = settings.dots.maxSize;
	                    }
	                    var eventSizeScale = PulseChart.createScale(true, columns.EventSize ? [d3.min(columns.EventSize.values), d3.max(columns.EventSize.values)] : [0, 0], minSize, maxSize);
	                    var xAxisCardProperties = PulseChartAxisPropertiesHelper.getCategoryAxisProperties(dataView.metadata);
	                    var hasDynamicSeries = !!(timeStampColumn.values && timeStampColumn.source);
	                    var dataPointLabelSettings = PulseChartDataLabelUtils.getDefaultPulseChartLabelSettings();
	                    var gapWidths = PulseChart.getGapWidths(categoryValues);
	                    var maxGapWidth = Math.max.apply(null, gapWidths);
	                    var firstValueMeasureIndex = 0, firstGroupIndex = 0, secondGroupIndex = 1;
	                    var grouped = dataView.categorical.values && dataView.categorical.values.grouped();
	                    var y_group0Values = grouped[firstGroupIndex]
	                        && grouped[firstGroupIndex].values[firstValueMeasureIndex]
	                        && grouped[firstGroupIndex].values[firstValueMeasureIndex].values;
	                    var y_group1Values = grouped[secondGroupIndex]
	                        && grouped[secondGroupIndex].values[firstValueMeasureIndex]
	                        && grouped[secondGroupIndex].values[firstValueMeasureIndex].values;
	                    var series = [];
	                    var dataPoints = [];
	                    for (var categoryIndex = 0, seriesCategoryIndex = 0, len = timeStampColumn.values.length; categoryIndex < len; categoryIndex++, seriesCategoryIndex++) {
	                        var categoryValue = categoryValues[categoryIndex];
	                        var value = visuals.AxisHelper.normalizeNonFiniteNumber(timeStampColumn.values[categoryIndex]);
	                        var runnerCounterValue = columns.RunnerCounter && columns.RunnerCounter.values && columns.RunnerCounter.values[categoryIndex];
	                        var identity = visuals.SelectionIdBuilder.builder().withCategory(timeStampColumn, categoryIndex).createSelectionId();
	                        var minGapWidth = Math.max((maxCategoryValue - minCategoryValue) / PulseChart.MaxGapCount, PulseChart.MinGapWidth[settings.xAxis.dateFormat]);
	                        var gapWidth = gapWidths[categoryIndex];
	                        var isGap = settings.gaps.show
	                            && gapWidth > 0
	                            && gapWidth > (minGapWidth + (100 - settings.gaps.visibleGapsPercentage) * (maxGapWidth - minGapWidth) / 100);
	                        if (isGap && dataPoints.length > 0) {
	                            series.push({
	                                displayName: grouped[firstGroupIndex].name,
	                                key: identity.getKey(),
	                                lineIndex: series.length,
	                                color: settings.series.fill,
	                                xCol: timeStampColumn.source,
	                                yCol: timeStampColumn.source,
	                                data: dataPoints,
	                                identity: identity,
	                                selected: false,
	                                labelSettings: dataPointLabelSettings,
	                                width: settings.series.width,
	                                widthOfGap: gapWidth
	                            });
	                            seriesCategoryIndex = 0;
	                            dataPoints = [];
	                        }
	                        // When Scalar, skip null categories and null values so we draw connected lines and never draw isolated dots.
	                        if (isScalar && (categoryValue === null || value === null)) {
	                            continue;
	                        }
	                        var popupInfo = null;
	                        var eventSize = (columns.EventSize && columns.EventSize.values && columns.EventSize.values[categoryIndex]) || 0;
	                        if ((columns.EventTitle && columns.EventTitle.values && columns.EventTitle.values[categoryIndex]) ||
	                            (columns.EventDescription && columns.EventDescription.values && columns.EventDescription.values[categoryIndex])) {
	                            var formattedValue = categoryValue;
	                            if (!isScalar && categoryValue) {
	                                formattedValue = visuals.valueFormatter.create({ format: timeStampColumn.source.format }).format(categoryValue);
	                            }
	                            popupInfo = {
	                                value: formattedValue,
	                                title: columns.EventTitle && columns.EventTitle.values && columns.EventTitle.values[categoryIndex],
	                                description: columns.EventDescription && columns.EventDescription.values && columns.EventDescription.values[categoryIndex],
	                            };
	                        }
	                        var dataPoint = {
	                            categoryValue: categoryValue,
	                            value: value,
	                            categoryIndex: categoryIndex,
	                            seriesIndex: series.length,
	                            tooltipInfo: null,
	                            popupInfo: popupInfo,
	                            selected: false,
	                            identity: identity,
	                            key: JSON.stringify({ ser: identity.getKey(), catIdx: categoryIndex }),
	                            labelFill: dataPointLabelSettings.labelColor,
	                            labelSettings: dataPointLabelSettings,
	                            x: categoryValue,
	                            y: (y_group0Values && y_group0Values[categoryIndex]) || (y_group1Values && y_group1Values[categoryIndex]) || 0,
	                            pointColor: settings.series.fill,
	                            groupIndex: PulseChart.getGroupIndex(categoryIndex, grouped),
	                            eventSize: columns.EventSize ? eventSizeScale(eventSize) : 0,
	                            runnerCounterValue: runnerCounterValue,
	                            runnerCounterFormatString: runnerCounterFormatString,
	                            specificIdentity: undefined,
	                        };
	                        dataPoints.push(dataPoint);
	                    }
	                    if (interactivityService) {
	                        interactivityService.applySelectionStateToData(dataPoints);
	                    }
	                    if (dataPoints.length > 0) {
	                        series.push({
	                            displayName: grouped[firstGroupIndex].name,
	                            key: identity.getKey(),
	                            lineIndex: series.length,
	                            color: settings.series.fill,
	                            xCol: timeStampColumn.source,
	                            yCol: timeStampColumn.source,
	                            data: dataPoints,
	                            identity: identity,
	                            selected: false,
	                            labelSettings: dataPointLabelSettings,
	                            width: settings.series.width,
	                            widthOfGap: 0
	                        });
	                    }
	                    xAxisCardProperties = PulseChartAxisPropertiesHelper.getCategoryAxisProperties(dataView.metadata);
	                    var valueAxisProperties = PulseChartAxisPropertiesHelper.getValueAxisProperties(dataView.metadata);
	                    var values = dataView.categorical.categories;
	                    // Convert to DataViewMetadataColumn
	                    var valuesMetadataArray = [];
	                    if (values) {
	                        for (var i = 0; i < values.length; i++) {
	                            if (values[i] && values[i].source && values[i].source.displayName) {
	                                valuesMetadataArray.push({ displayName: values[i].source.displayName });
	                            }
	                        }
	                    }
	                    var axesLabels = visuals.converterHelper.createAxesLabels(xAxisCardProperties, valueAxisProperties, timeStampColumn.source, valuesMetadataArray);
	                    if (interactivityService) {
	                        interactivityService.applySelectionStateToData(series);
	                    }
	                    return {
	                        columns: columns,
	                        series: series,
	                        isScalar: isScalar,
	                        dataLabelsSettings: dataPointLabelSettings,
	                        axesLabels: { x: axesLabels.xAxisLabel, y: axesLabels.yAxisLabel },
	                        hasDynamicSeries: hasDynamicSeries,
	                        categoryMetadata: timeStampColumn.source,
	                        categories: categoryValues,
	                        settings: settings,
	                        grouped: grouped,
	                        hasHighlights: !!columns.Value.highlights,
	                        widthOfXAxisLabel: widthOfXAxisLabel,
	                        widthOfTooltipValueLabel: widthOfTooltipValueLabel,
	                        heightOfTooltipDescriptionTextLine: heightOfTooltipDescriptionTextLine,
	                        runnerCounterHeight: TextMeasurementService.measureSvgTextHeight(PulseChart.GetRunnerCounterTextProperties("lj", settings.runnerCounter.fontSize))
	                    };
	                };
	                PulseChart.createAxisY = function (commonYScale, height, formatterOptions, show) {
	                    if (show === void 0) { show = true; }
	                    var formatter = visuals.valueFormatter.create(formatterOptions);
	                    var ticks = Math.max(2, Math.round(height / 40));
	                    var yAxis = d3.svg.axis()
	                        .scale(commonYScale)
	                        .ticks(ticks)
	                        .outerTickSize(0)
	                        .tickFormat(formatter.format);
	                    return yAxis;
	                };
	                PulseChart.createAxisX = function (isScalar, series, originalScale, formatterOptions, dateFormat, position, widthOfXAxisLabel) {
	                    var scales = PulseChart.getXAxisScales(series, isScalar, originalScale);
	                    var xAxisProperties = new Array(scales.length);
	                    for (var i = 0, rotate = false; i < xAxisProperties.length; i++) {
	                        var values = PulseChart.getXAxisValuesToDisplay(scales[i], rotate, isScalar, dateFormat, widthOfXAxisLabel);
	                        if (!rotate
	                            && position === XAxisPosition.Bottom
	                            && values.length < PulseChart.MinimumTicksToRotate) {
	                            var rotatedValues = PulseChart.getXAxisValuesToDisplay(scales[i], true, isScalar, dateFormat, widthOfXAxisLabel);
	                            if (rotatedValues.length > values.length) {
	                                rotate = true;
	                                i = -1;
	                                continue;
	                            }
	                        }
	                        xAxisProperties[i] = { values: values, scale: scales[i], rotate: rotate };
	                    }
	                    formatterOptions.tickCount = xAxisProperties.length && xAxisProperties.map(function (x) { return x.values.length; }).reduce(function (a, b) { return a + b; }) * 5;
	                    formatterOptions.value = originalScale.domain()[0];
	                    formatterOptions.value2 = originalScale.domain()[1];
	                    xAxisProperties.forEach(function (properties) {
	                        var values = properties.values.filter(function (value) { return value !== null; });
	                        var formatter = visuals.valueFormatter.create(formatterOptions);
	                        properties.axis = d3.svg.axis()
	                            .scale(properties.scale)
	                            .tickValues(values)
	                            .tickFormat(formatter.format)
	                            .outerTickSize(0);
	                    });
	                    return xAxisProperties;
	                };
	                PulseChart.getXAxisScales = function (series, isScalar, originalScale) {
	                    return series.map(function (seriesElement) {
	                        var dataPoints = seriesElement.data, minValue = dataPoints[0].categoryValue, maxValue = dataPoints[dataPoints.length - 1].categoryValue, minX = originalScale(dataPoints[0].categoryValue), maxX = originalScale(dataPoints[dataPoints.length - 1].categoryValue);
	                        return PulseChart.createScale(isScalar, [minValue, maxValue], minX, maxX);
	                    });
	                };
	                PulseChart.getXAxisValuesToDisplay = function (scale, rotate, isScalar, dateFormat, widthOfXAxisLabel) {
	                    var genScale = scale;
	                    var tickWidth = rotate
	                        ? PulseChart.XAxisTickHeight * (rotate ? Math.abs(Math.sin(PulseChart.AxisTickRotateAngle * Math.PI / 180)) : 0)
	                        : widthOfXAxisLabel;
	                    var tickSpace = PulseChart.XAxisTickSpace;
	                    if (scale.range()[1] < tickWidth) {
	                        return [];
	                    }
	                    var minValue = scale.invert(scale.range()[0] + tickWidth / 2);
	                    var maxValue = scale.invert(scale.range()[1] - tickWidth / 2);
	                    var width = scale.range()[1] - scale.range()[0];
	                    var maxTicks = Math.floor((width + tickSpace) / (tickWidth + tickSpace));
	                    if (rotate) {
	                        maxTicks = Math.min(PulseChart.MinimumTicksToRotate, maxTicks);
	                    }
	                    var values = [];
	                    if (isScalar) {
	                        values = d3.range(minValue, maxValue, (maxValue - minValue) / (maxTicks * 100));
	                    }
	                    else {
	                        values = (dateFormat === PulseChartXAxisDateFormat.TimeOnly ? d3.time.minute : d3.time.day)
	                            .range(minValue, maxValue);
	                    }
	                    if (!values.length || _.last(values) < maxValue) {
	                        values.push(maxValue);
	                    }
	                    if (!maxTicks) {
	                        return [];
	                    }
	                    maxTicks = Math.min(values.length, maxTicks);
	                    var valuesIndexses = d3.scale.ordinal().domain(d3.range(maxTicks)).rangePoints([0, values.length - 1]).range(); //randeRoundPoints is not defined
	                    values = valuesIndexses.map(function (x) { return values[Math.round(x)]; });
	                    for (var i = 1; i < values.length; i++) {
	                        var prevXValue = genScale(values[i - 1]);
	                        var curXValue = genScale(values[i]);
	                        if (curXValue - prevXValue < tickWidth + tickSpace / 3) {
	                            values.splice(i--, 1);
	                        }
	                    }
	                    return values;
	                };
	                PulseChart.getGroupIndex = function (index, grouped) {
	                    for (var i = 0; i < grouped.length; i++) {
	                        if (grouped[i].values && grouped[i].values[0] &&
	                            grouped[i].values[0].values[index] !== undefined &&
	                            grouped[i].values[0].values[index] !== null) {
	                            return i;
	                        }
	                    }
	                    return 0;
	                };
	                PulseChart.getGapWidths = function (values) {
	                    var result = [];
	                    for (var i = 0, prevVal = 0, length = values.length; i < length; i++) {
	                        if (!prevVal || !values[i]) {
	                            result.push(0);
	                        }
	                        else {
	                            result.push(values[i] - prevVal);
	                        }
	                        prevVal = values[i];
	                    }
	                    return result;
	                };
	                PulseChart.createScale = function (isScalar, domain, minX, maxX) {
	                    var scale;
	                    if (isScalar) {
	                        scale = d3.scale.linear();
	                    }
	                    else {
	                        scale = d3.time.scale();
	                    }
	                    return scale
	                        .domain(domain)
	                        .range([minX, maxX]);
	                };
	                Object.defineProperty(PulseChart.prototype, "runnerCounterPlaybackButtonsHeight", {
	                    get: function () {
	                        return Math.max(PulseChart.PlaybackButtonsHeight, this.data && (this.data.runnerCounterHeight / 2 + 17));
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(PulseChart.prototype, "popupHeight", {
	                    get: function () {
	                        return this.data
	                            && this.data.settings
	                            && this.data.settings.popup
	                            && this.data.settings.popup.show
	                            && this.data.settings.popup.height || 0;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                PulseChart.prototype.init = function (options) {
	                    powerbi.formattingService.initialize(); //Fixes the framework bug: "Cannot read property 'getFormatString' of undefined".
	                    this.host = options.host;
	                    this.selectionManager = new SelectionManager({ hostServices: this.host });
	                    var svg = this.svg = d3.select(options.element.get(0))
	                        .append('svg')
	                        .classed('pulseChart', true);
	                    this.gaps = svg.append('g').classed(PulseChart.Gaps.class, true);
	                    this.yAxis = svg.append('g').attr('class', 'y axis');
	                    this.chart = svg.append('g').attr('class', PulseChart.Chart.class);
	                    this.dots = svg.append('g').attr('class', 'dots');
	                    this.animationDot = this.dots.append('circle').classed(PulseChart.AnimationDot.class, true).attr('display', 'none');
	                    this.animationHandler = new PulseAnimator(this, svg);
	                    var style = options.style;
	                    this.colors = style && style.colorPalette
	                        ? style.colorPalette.dataColors
	                        : new visuals.DataColorPalette();
	                };
	                PulseChart.prototype.update = function (options) {
	                    if (!options || !options.dataViews || !options.dataViews[0]) {
	                        return;
	                    }
	                    this.viewport = $.extend({}, options.viewport);
	                    var dataView = options.dataViews[0];
	                    this.updateData(PulseChart.converter(dataView, this.colors));
	                    if (!this.validateData(this.data)) {
	                        this.clearAll(true);
	                        return;
	                    }
	                    var width = this.getChartWidth();
	                    this.calculateXAxisProperties(width);
	                    if (this.data.xScale.ticks(undefined).length < 2) {
	                        this.clearAll(true);
	                        return;
	                    }
	                    var height = this.getChartHeight(this.data.settings.xAxis.show
	                        && this.data.series.some(function (series) { return series.xAxisProperties.rotate; }));
	                    this.calculateYAxisProperties(height);
	                    this.size = { width: width, height: height };
	                    this.updateElements();
	                    this.render(true);
	                };
	                PulseChart.prototype.updateData = function (data) {
	                    if (!this.data) {
	                        this.data = data;
	                        return;
	                    }
	                    var oldDataObj = this.getDataArrayToCompare(this.data);
	                    var newDataObj = this.getDataArrayToCompare(data);
	                    if (!_.isEqual(oldDataObj, newDataObj)) {
	                        this.clearAll(false);
	                    }
	                    this.data = data;
	                };
	                PulseChart.prototype.getDataArrayToCompare = function (data) {
	                    if (!data || !data.series) {
	                        return null;
	                    }
	                    var dataPoints = _.flatten(data.series.map(function (x) { return x.data; }));
	                    return _.flatten(dataPoints.map(function (x) {
	                        return x && _.flatten([
	                            [
	                                x.categoryValue,
	                                x.eventSize,
	                                x.groupIndex,
	                                x.runnerCounterValue,
	                                x.y,
	                                x.seriesIndex
	                            ],
	                            x.popupInfo && [x.popupInfo.description, x.popupInfo.title, x.popupInfo.value]
	                        ]);
	                    }));
	                };
	                PulseChart.prototype.validateData = function (data) {
	                    if (!data) {
	                        return false;
	                    }
	                    if (data.categories.some(function (x) { return !(x instanceof Date || $.isNumeric(x)); })) {
	                        return false;
	                    }
	                    return true;
	                };
	                PulseChart.prototype.getChartWidth = function () {
	                    var marginRight = this.margin.right;
	                    if (this.data.settings.yAxis && this.data.settings.yAxis.show) {
	                        marginRight += PulseChart.MaxWidthOfYAxis;
	                    }
	                    var width = this.viewport.width - this.margin.left - marginRight;
	                    return Math.max(width, PulseChart.DefaultViewport.width);
	                };
	                PulseChart.prototype.getChartHeight = function (xAxisRotated) {
	                    var marginBottom = 10 + (xAxisRotated
	                        ? this.data.widthOfXAxisLabel * Math.abs(Math.sin(PulseChart.AxisTickRotateAngle * Math.PI / 180))
	                        : 3);
	                    if (!this.data.settings.popup.alwaysOnTop && this.popupHeight) {
	                        marginBottom = Math.max(this.margin.bottom + this.popupHeight, marginBottom);
	                    }
	                    var height = this.viewport.height
	                        - this.margin.top
	                        - this.runnerCounterPlaybackButtonsHeight
	                        - marginBottom
	                        - this.popupHeight;
	                    return Math.max(height, PulseChart.DefaultViewport.height);
	                };
	                PulseChart.prototype.updateElements = function () {
	                    var chartMarginTop = this.margin.top + this.runnerCounterPlaybackButtonsHeight + this.popupHeight;
	                    this.svg.attr(this.viewport);
	                    this.svg.style('display', undefined);
	                    this.gaps.attr('transform', visuals.SVGUtil.translate(this.margin.left, chartMarginTop + (this.size.height / 2)));
	                    this.chart.attr('transform', visuals.SVGUtil.translate(this.margin.left, chartMarginTop));
	                    this.yAxis.attr('transform', visuals.SVGUtil.translate(this.size.width + this.margin.left, chartMarginTop));
	                    this.dots.attr('transform', visuals.SVGUtil.translate(this.margin.left, chartMarginTop));
	                };
	                PulseChart.prototype.calculateXAxisProperties = function (width) {
	                    this.data.xScale = PulseChart.createScale(this.data.isScalar, [this.data.categories[0], this.data.categories[this.data.categories.length - 1]], 0, width);
	                    var xAxisProperties = PulseChart.createAxisX(this.data.isScalar, this.data.series, this.data.xScale, $.extend({}, this.data.settings.xAxis.formatterOptions), this.data.settings.xAxis.dateFormat, this.data.settings.xAxis.position, this.data.widthOfXAxisLabel);
	                    this.data.series.forEach(function (series, index) {
	                        series.xAxisProperties = xAxisProperties[index];
	                    });
	                };
	                PulseChart.prototype.calculateYAxisProperties = function (height) {
	                    this.data.yScales = this.getYAxisScales(height);
	                    var domain = [];
	                    this.data.yScales.forEach(function (scale) { return domain = domain.concat(scale.domain()); });
	                    this.data.commonYScale = PulseChart.createScale(true, [d3.max(domain), d3.min(domain)], 0, height);
	                    this.data.yAxis = PulseChart.createAxisY(this.data.commonYScale, height, this.data.settings.yAxis.formatterOptions);
	                };
	                PulseChart.prototype.getYAxisScales = function (height) {
	                    var data = this.data, stepOfHeight = height / data.grouped.length;
	                    return data.grouped.map(function (group, index) {
	                        var values = group.values[0].values.map(function (x) { return x || 0; });
	                        var minValue = Number.MAX_VALUE, maxValue = -Number.MAX_VALUE;
	                        values.forEach(function (value) {
	                            if (value < minValue) {
	                                minValue = value;
	                            }
	                            if (value > maxValue) {
	                                maxValue = value;
	                            }
	                        });
	                        if (maxValue === minValue) {
	                            var offset = maxValue === 0 ? 1 : Math.abs(maxValue / 2);
	                            maxValue += offset;
	                            minValue -= offset;
	                        }
	                        return PulseChart.createScale(true, [maxValue, minValue], stepOfHeight * index, stepOfHeight * (index + 1));
	                    });
	                };
	                Object.defineProperty(PulseChart.prototype, "autoplayPauseDuration", {
	                    get: function () {
	                        return 1000 * ((this.data && this.data.settings && this.data.settings.playback)
	                            ? this.data.settings.playback.autoplayPauseDuration
	                            : PulseChart.DefaultSettings.playback.autoplayPauseDuration);
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(PulseChart.prototype, "isAutoPlay", {
	                    get: function () {
	                        return this.data &&
	                            this.data.settings &&
	                            this.data.settings.playback &&
	                            this.data.settings.playback.autoplay;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                PulseChart.prototype.render = function (suppressAnimations) {
	                    var duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
	                    var data = this.data;
	                    this.lastSelectedPoint = null;
	                    var xScale = data.xScale, yScales = data.yScales;
	                    this.lineX = d3.svg.line()
	                        .x(function (d) {
	                        return xScale(d.categoryValue);
	                    })
	                        .y(function (d) {
	                        return yScales[d.groupIndex](d.y);
	                    });
	                    if (this.data &&
	                        this.data.settings &&
	                        this.data.settings.playback &&
	                        this.data.settings.playback.color) {
	                        this.animationHandler.setControlsColor(this.data.settings.playback.color);
	                    }
	                    this.animationHandler.render();
	                    this.animationHandler.setRunnerCounterValue();
	                    this.renderAxes(data, duration);
	                    this.renderGaps(data, duration);
	                };
	                PulseChart.prototype.renderAxes = function (data, duration) {
	                    this.renderXAxis(data, duration);
	                    this.renderYAxis(data, duration);
	                };
	                PulseChart.prototype.renderXAxis = function (data, duration) {
	                    var axisNodeSelection, axisNodeUpdateSelection, 
	                    //ticksSelection: D3.Selection,
	                    axisBoxUpdateSelection, color = PulseChart.DefaultSettings.xAxis.color, fontColor = PulseChart.DefaultSettings.xAxis.fontColor;
	                    if (this.data && this.data.settings && this.data.settings.xAxis) {
	                        color = this.data.settings.xAxis.color;
	                        fontColor = this.data.settings.xAxis.fontColor;
	                    }
	                    axisNodeSelection = this.rootSelection.selectAll(PulseChart.XAxisNode.selector);
	                    axisNodeUpdateSelection = axisNodeSelection.data(data.series);
	                    axisNodeUpdateSelection
	                        .enter()
	                        .insert("g", "g." + PulseChart.LineContainer.class)
	                        .classed(PulseChart.XAxisNode.class, true);
	                    axisNodeUpdateSelection
	                        .call(function (selection) {
	                        selection.forEach(function (selectionElement, index) {
	                            d3.select(selectionElement[0])
	                                .call(data.series[index].xAxisProperties.axis.orient('bottom'));
	                        });
	                    });
	                    axisNodeUpdateSelection
	                        .exit()
	                        .remove();
	                    axisBoxUpdateSelection = axisNodeUpdateSelection
	                        .selectAll(".tick")
	                        .selectAll(".axisBox")
	                        .data([[]]);
	                    axisBoxUpdateSelection
	                        .enter()
	                        .insert("rect", "text")
	                        .classed("axisBox", true);
	                    axisBoxUpdateSelection
	                        .style('display', this.data.settings.xAxis.position === XAxisPosition.Center ? 'inherit' : 'none')
	                        .style('fill', this.data.settings.xAxis.backgroundColor);
	                    var tickRectY = this.data.settings.xAxis.position === XAxisPosition.Center ? -11 : 0;
	                    axisBoxUpdateSelection.attr({
	                        x: -(this.data.widthOfXAxisLabel / 2),
	                        y: tickRectY + "px",
	                        width: this.data.widthOfXAxisLabel,
	                        height: PulseChart.XAxisTickHeight + "px"
	                    });
	                    axisBoxUpdateSelection
	                        .exit()
	                        .remove();
	                    axisNodeUpdateSelection
	                        .style('stroke', this.data.settings.xAxis.position === XAxisPosition.Center ? color : "none")
	                        .style('display', this.data.settings.xAxis.show ? 'inherit' : 'none');
	                    axisNodeUpdateSelection.call(function (selection) {
	                        var rotate = selection.datum().xAxisProperties.rotate;
	                        var rotateCoeff = rotate ? Math.abs(Math.sin(PulseChart.AxisTickRotateAngle * Math.PI / 180)) : 0;
	                        var dy = tickRectY + 3;
	                        selection.selectAll("text")
	                            .attr('transform', function () {
	                            return "translate(0, " + (dy + 9 + ($(this).width() / 2) * rotateCoeff) + ") rotate(" + (rotate ? PulseChart.AxisTickRotateAngle : 0) + ")";
	                        })
	                            .style('fill', fontColor)
	                            .style('stroke', "none")
	                            .attr('dy', -9);
	                    });
	                    axisNodeUpdateSelection.selectAll(".domain")
	                        .style('stroke', color);
	                    axisNodeUpdateSelection.selectAll(".domain").forEach(function (element) {
	                        $(element).insertBefore($(element).parent().children().first());
	                    });
	                    var xAxisTop = this.size.height;
	                    switch (this.data.settings.xAxis.position) {
	                        case XAxisPosition.Center:
	                            xAxisTop = xAxisTop / 2;
	                            break;
	                        case XAxisPosition.Bottom:
	                            break;
	                    }
	                    axisNodeUpdateSelection.attr('transform', visuals.SVGUtil.translate(0, xAxisTop));
	                };
	                PulseChart.prototype.renderYAxis = function (data, duration) {
	                    var yAxis = data.yAxis, isShow = false, color = PulseChart.DefaultSettings.yAxis.color, fontColor = PulseChart.DefaultSettings.yAxis.fontColor;
	                    ;
	                    yAxis.orient('right');
	                    if (this.data &&
	                        this.data.settings &&
	                        this.data.settings.yAxis &&
	                        this.data.settings.yAxis.show) {
	                        isShow = true;
	                    }
	                    if (this.data &&
	                        this.data.settings &&
	                        this.data.settings.yAxis &&
	                        this.data.settings.yAxis) {
	                        color = this.data.settings.yAxis.color;
	                        fontColor = this.data.settings.yAxis.fontColor;
	                    }
	                    this.yAxis
	                        .call(yAxis)
	                        .attr('display', isShow ? 'inline' : 'none');
	                    this.yAxis.selectAll('.domain, path, line').style('stroke', color);
	                    this.yAxis.selectAll('text').style('fill', fontColor);
	                    this.yAxis.selectAll('g.tick line')
	                        .attr('x1', -this.size.width);
	                };
	                PulseChart.prototype.renderChart = function () {
	                    var data = this.data;
	                    var series = this.data.series;
	                    var selection = this.rootSelection = this.chart.selectAll(PulseChart.LineNode.selector).data(series);
	                    var lineNode = selection
	                        .enter()
	                        .append('g')
	                        .classed(PulseChart.LineNode.class, true);
	                    lineNode
	                        .append('g')
	                        .classed(PulseChart.LineContainer.class, true);
	                    lineNode
	                        .append('g')
	                        .classed(PulseChart.TooltipContainer.class, true);
	                    lineNode
	                        .append('g')
	                        .classed(PulseChart.DotsContainer.class, true);
	                    if (this.animationHandler.isAnimated) {
	                        this.showAnimationDot();
	                    }
	                    else {
	                        this.hideAnimationDot();
	                    }
	                    this.drawTooltips(data, this.selectionManager.getSelectionIds());
	                    this.drawDots(data);
	                    this.drawLines(data);
	                    selection
	                        .exit()
	                        .remove();
	                };
	                PulseChart.prototype.drawLinesStatic = function (limit, isAnimated) {
	                    var _this = this;
	                    var node = PulseChart.Line, nodeParent = PulseChart.LineContainer, rootSelection = this.rootSelection;
	                    var selection = rootSelection
	                        .filter(function (d, index) { return !isAnimated || index < limit; })
	                        .select(nodeParent.selector)
	                        .selectAll(node.selector).data(function (d) { return [d]; });
	                    selection
	                        .enter()
	                        .append('path')
	                        .classed(node.class, true);
	                    selection
	                        .style({
	                        'fill': "none",
	                        'stroke': function (d) { return d.color; },
	                        'stroke-width': function (d) { return (d.width + "px"); }
	                    });
	                    selection.attr('d', function (d) { return _this.lineX(d.data); });
	                    selection
	                        .exit()
	                        .remove();
	                };
	                PulseChart.prototype.drawLinesStaticBeforeAnimation = function (limit) {
	                    var _this = this;
	                    var node = PulseChart.Line, nodeParent = PulseChart.LineContainer, rootSelection = this.rootSelection;
	                    this.animationSelection = rootSelection.filter(function (d, index) {
	                        return index === limit;
	                    }).select(nodeParent.selector).selectAll(node.selector).data(function (d) { return [d]; });
	                    this.animationSelection
	                        .enter()
	                        .append('path')
	                        .classed(node.class, true);
	                    this.animationSelection
	                        .style({
	                        'fill': "none",
	                        'stroke': function (d) { return d.color; },
	                        'stroke-width': function (d) { return (d.width + "px"); }
	                    });
	                    this.animationSelection
	                        .attr('d', function (d) {
	                        var flooredStart = _this.animationHandler.flooredPosition.index;
	                        if (flooredStart === 0) {
	                            _this.moveAnimationDot(d.data[0]);
	                            return _this.lineX([]);
	                        }
	                        else {
	                            var dataReduced = d.data.slice(0, flooredStart + 1);
	                            _this.moveAnimationDot(dataReduced[dataReduced.length - 1]);
	                            return _this.lineX(dataReduced);
	                        }
	                    });
	                    this.animationSelection
	                        .exit()
	                        .remove();
	                };
	                PulseChart.prototype.moveAnimationDot = function (d) {
	                    var xScale = this.data.xScale, yScales = this.data.yScales;
	                    this.animationDot
	                        .attr("cx", xScale(d.x))
	                        .attr("cy", yScales[d.groupIndex](d.y));
	                };
	                PulseChart.prototype.playAnimation = function (delay) {
	                    var _this = this;
	                    if (delay === void 0) { delay = 0; }
	                    var flooredStart = this.animationHandler.flooredPosition.index;
	                    this.showAnimationDot();
	                    this.animationSelection
	                        .transition()
	                        .delay(delay)
	                        .duration(this.animationDuration)
	                        .ease("linear")
	                        .attrTween('d', function (d, index) { return _this.getInterpolation(d.data, flooredStart); })
	                        .each("end", function (series) { return _this.handleSelection(_this.animationHandler.flooredPosition); });
	                };
	                PulseChart.prototype.pauseAnimation = function () {
	                    if (!this.animationSelection) {
	                        return;
	                    }
	                    this.hideAnimationDot();
	                    this.animationSelection.selectAll("path").transition();
	                    this.animationSelection
	                        .transition()
	                        .duration(0)
	                        .delay(0);
	                };
	                PulseChart.prototype.stopAnimation = function () {
	                    this.pauseAnimation();
	                    d3.timer.flush();
	                };
	                PulseChart.prototype.findNextPoint = function (position) {
	                    for (var i = position.series; i < this.data.series.length; i++) {
	                        var series = this.data.series[i];
	                        for (var j = (i === position.series) ? Math.floor(position.index + 1) : 0; j < series.data.length; j++) {
	                            if (series.data[j] && series.data[j].popupInfo) {
	                                return {
	                                    series: i,
	                                    index: j
	                                };
	                            }
	                        }
	                    }
	                    return null;
	                };
	                PulseChart.prototype.findPrevPoint = function (position) {
	                    for (var i = position.series; i >= 0; i--) {
	                        var series = this.data.series[i];
	                        for (var j = (i === position.series) ? Math.ceil(position.index - 1) : series.data.length; j >= 0; j--) {
	                            if (series.data[j] && series.data[j].popupInfo) {
	                                return {
	                                    series: i,
	                                    index: j
	                                };
	                            }
	                        }
	                    }
	                    return null;
	                };
	                PulseChart.prototype.isAnimationSeriesAndIndexLast = function (position) {
	                    return this.isAnimationSeriesLast(position) && this.isAnimationIndexLast(position);
	                };
	                PulseChart.prototype.isAnimationSeriesLast = function (position) {
	                    return (position.series >= (this.data.series.length - 1));
	                };
	                PulseChart.prototype.isAnimationIndexLast = function (position) {
	                    var series = this.data.series[position.series];
	                    return (position.index >= (series.data.length - 1));
	                };
	                PulseChart.prototype.drawLines = function (data) {
	                    var positionSeries = this.animationHandler.position.series, isAnimated = this.animationHandler.isAnimated;
	                    this.drawLinesStatic(positionSeries, isAnimated);
	                    if (isAnimated) {
	                        this.drawLinesStaticBeforeAnimation(positionSeries);
	                    }
	                };
	                PulseChart.prototype.showAnimationDot = function () {
	                    if (!this.animationHandler.isPlaying) {
	                        return;
	                    }
	                    var size = PulseChart.DefaultSettings.dots.size;
	                    if (this.data &&
	                        this.data.settings &&
	                        this.data.settings.dots &&
	                        this.data.settings.dots.size) {
	                        size = this.data.settings.dots.size;
	                    }
	                    this.animationDot
	                        .attr('display', 'inline')
	                        .attr("fill", this.data.settings.dots.color)
	                        .style("opacity", this.dotOpacity)
	                        .attr("r", size);
	                };
	                PulseChart.prototype.hideAnimationDot = function () {
	                    this.animationDot.attr('display', 'none');
	                };
	                PulseChart.prototype.getInterpolation = function (data, start) {
	                    var _this = this;
	                    if (!this.data) {
	                        return;
	                    }
	                    var xScale = this.data.xScale, yScales = this.data.yScales;
	                    var stop = start + 1;
	                    this.showAnimationDot();
	                    var lineFunction = d3.svg.line()
	                        .x(function (d) { return d.x; })
	                        .y(function (d) { return d.y; })
	                        .interpolate("linear");
	                    var interpolatedLine = data.slice(0, start + 1).map(function (d) {
	                        return {
	                            x: xScale(d.x),
	                            y: yScales[d.groupIndex](d.y)
	                        };
	                    });
	                    var x0 = xScale(data[start].x);
	                    var x1 = xScale(data[stop].x);
	                    var y0 = yScales[data[start].groupIndex](data[start].y);
	                    var y1 = yScales[data[stop].groupIndex](data[stop].y);
	                    var interpolateIndex = d3.scale.linear()
	                        .domain([0, 1])
	                        .range([start, stop]);
	                    var interpolateX = d3.scale.linear()
	                        .domain([0, 1])
	                        .range([x0, x1]);
	                    var interpolateY = d3.scale.linear()
	                        .domain([0, 1])
	                        .range([y0, y1]);
	                    this.animationHandler.setRunnerCounterValue(start);
	                    return function (t) {
	                        if (!_this.animationHandler.isPlaying) {
	                            return lineFunction(interpolatedLine);
	                        }
	                        var x = interpolateX(t);
	                        var y = interpolateY(t);
	                        _this.animationDot
	                            .attr("cx", x)
	                            .attr("cy", y);
	                        interpolatedLine.push({ "x": x, "y": y });
	                        _this.animationHandler.position.index = interpolateIndex(t);
	                        return lineFunction(interpolatedLine);
	                    };
	                };
	                PulseChart.prototype.clearSelection = function () {
	                    if (this.data && this.data.hasHighlights || !this.selectionManager.hasSelection()) {
	                        this.selectionManager.selectedIds = [];
	                    }
	                    else {
	                        this.selectionManager.clear();
	                    }
	                    this.chart.selectAll(PulseChart.Tooltip.selector).remove();
	                };
	                PulseChart.prototype.handleSelection = function (position) {
	                    var _this = this;
	                    if (!this.data) {
	                        return;
	                    }
	                    var animationPlayingIndex = this.animationHandler.animationPlayingIndex;
	                    var dataPoint = this.data.series[position.series].data[position.index];
	                    var isLastDataPoint = this.animationHandler.isPlaying && this.isAnimationSeriesAndIndexLast(position);
	                    if ((!dataPoint || !dataPoint.popupInfo) && (this.animationHandler.isPlaying)) {
	                        if (isLastDataPoint) {
	                            setTimeout(function () { return _this.animationHandler.toEnd(); }, 0);
	                        }
	                        else {
	                            this.animationHandler.play(0, true);
	                        }
	                        return;
	                    }
	                    if (isLastDataPoint) {
	                        setTimeout(function () { return _this.animationHandler.toEnd(); }, 0);
	                    }
	                    else {
	                        this.animationHandler.pause();
	                    }
	                    this.selectionManager.select(dataPoint.identity).then(function (selectionIds) {
	                        _this.setSelection(selectionIds);
	                        clearTimeout(_this.handleSelectionTimeout);
	                        _this.handleSelectionTimeout = setTimeout(function () {
	                            if (_this.animationHandler.animationPlayingIndex !== animationPlayingIndex) {
	                                return;
	                            }
	                            if (isLastDataPoint || _this.animationHandler.isPaused) {
	                                _this.clearSelection();
	                            }
	                            if (!isLastDataPoint && _this.animationHandler.isPaused) {
	                                _this.animationHandler.play();
	                            }
	                        }, _this.pauseDuration);
	                    });
	                };
	                Object.defineProperty(PulseChart.prototype, "animationDuration", {
	                    get: function () {
	                        return 1000 / ((this.data && this.data.settings && this.data.settings.playback)
	                            ? this.data.settings.playback.playSpeed
	                            : PulseChart.DefaultSettings.playback.playSpeed);
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(PulseChart.prototype, "pauseDuration", {
	                    get: function () {
	                        return 1000 * ((this.data && this.data.settings && this.data.settings.playback)
	                            ? this.data.settings.playback.pauseDuration
	                            : PulseChart.DefaultSettings.playback.pauseDuration);
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(PulseChart.prototype, "dotOpacity", {
	                    get: function () {
	                        return 1 - ((this.data && this.data.settings && this.data.settings.dots)
	                            ? this.data.settings.dots.transparency
	                            : PulseChart.DefaultSettings.dots.transparency) / 100;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                PulseChart.prototype.drawDots = function (data) {
	                    var _this = this;
	                    if (!data || !data.xScale) {
	                        return;
	                    }
	                    var xScale = data.xScale, yScales = data.yScales, node = PulseChart.Dot, nodeParent = PulseChart.DotsContainer, rootSelection = this.rootSelection, dotColor = this.data.settings.dots.color, dotSize = this.data.settings.dots.size, isAnimated = this.animationHandler.isAnimated, position = this.animationHandler.position;
	                    var selection = rootSelection.filter(function (d, index) { return !isAnimated || index <= position.series; })
	                        .select(nodeParent.selector)
	                        .selectAll(node.selector)
	                        .data(function (d, seriesIndex) {
	                        return _.filter(d.data, function (value, valueIndex) {
	                            if (isAnimated && (seriesIndex === position.series) && (valueIndex > position.index)) {
	                                return false;
	                            }
	                            return (!!value.popupInfo);
	                        });
	                    });
	                    selection
	                        .enter()
	                        .append("circle")
	                        .classed(node.class, true);
	                    selection
	                        .attr("cx", function (d) { return xScale(d.categoryValue); })
	                        .attr("cy", function (d) { return yScales[d.groupIndex](d.y); })
	                        .attr("r", function (d) { return d.eventSize || dotSize; })
	                        .style("fill", dotColor)
	                        .style("opacity", this.dotOpacity)
	                        .style("cursor", "pointer")
	                        .call(PulseChart.AddOnTouchClick, function (d) {
	                        d3.event.stopPropagation();
	                        _this.selectionManager.select(d.identity, d3.event.ctrlKey)
	                            .then(function (selectionIds) { return _this.setSelection(selectionIds); });
	                    });
	                    selection
	                        .exit()
	                        .remove();
	                };
	                PulseChart.prototype.renderGaps = function (data, duration) {
	                    var gaps, gapsSelection, gapsEnterSelection, gapNodeSelection, series = data.series, isScalar = data.isScalar, xScale = data.xScale;
	                    gaps = [{
	                            left: -4.5,
	                            top: -5,
	                            height: 10,
	                            width: 3
	                        }, {
	                            left: 1.5,
	                            top: -5,
	                            height: 10,
	                            width: 3
	                        }];
	                    gapsSelection = this.gaps.selectAll(PulseChart.Gap.selector)
	                        .data(series.slice(0, series.length - 1));
	                    gapsEnterSelection = gapsSelection
	                        .enter()
	                        .append("g");
	                    gapsSelection
	                        .attr("transform", function (seriesElement, index) {
	                        var x, middleOfGap = seriesElement.widthOfGap / 2, categoryValue = seriesElement.data[seriesElement.data.length - 1].categoryValue;
	                        if (isScalar) {
	                            x = xScale(middleOfGap + categoryValue);
	                        }
	                        else {
	                            x = xScale(new Date(middleOfGap + (categoryValue.getTime())));
	                        }
	                        return visuals.SVGUtil.translate(x, 0);
	                    });
	                    gapNodeSelection = gapsSelection.selectAll(PulseChart.GapNode.selector)
	                        .data(gaps);
	                    gapNodeSelection
	                        .enter()
	                        .append("rect")
	                        .attr({
	                        x: function (gap) { return gap.left; },
	                        y: function (gap) { return gap.top; },
	                        height: function (gap) { return gap.height; },
	                        width: function (gap) { return gap.width; }
	                    })
	                        .classed(PulseChart.GapNode.class, true);
	                    gapsEnterSelection.classed(PulseChart.Gap.class, true);
	                    gapsSelection
	                        .exit()
	                        .remove();
	                    gapNodeSelection
	                        .exit()
	                        .remove();
	                };
	                PulseChart.prototype.setSelection = function (selectionIds) {
	                    if (!this.data) {
	                        return;
	                    }
	                    this.drawDots(this.data);
	                    this.drawTooltips(this.data, selectionIds);
	                };
	                PulseChart.prototype.isPopupShow = function (d, selectionIds) {
	                    if (!this.popupHeight || !d.popupInfo) {
	                        return false;
	                    }
	                    if (selectionIds) {
	                        return SelectionManager.containsSelection(selectionIds, d.identity);
	                    }
	                    return false;
	                };
	                PulseChart.prototype.drawTooltips = function (data, selectionIds) {
	                    var _this = this;
	                    var xScale = data.xScale, yScales = data.yScales, node = PulseChart.Tooltip, nodeParent = PulseChart.TooltipContainer;
	                    var rootSelection = this.rootSelection;
	                    var line = d3.svg.line()
	                        .x(function (d) { return d.x; })
	                        .y(function (d) { return d.y; });
	                    var marginTop = PulseChart.DefaultTooltipSettings.marginTop;
	                    var width = this.data.settings.popup.width;
	                    var height = this.data.settings.popup.height;
	                    var topShift = 20;
	                    var tooltipShiftY = function (y, groupIndex) { return _this.isHigherMiddle(y, groupIndex) ? (-1 * marginTop + topShift) : _this.size.height + marginTop; };
	                    var tooltipRoot = rootSelection.select(nodeParent.selector).selectAll(node.selector)
	                        .data(function (d) {
	                        return _.filter(d.data, function (value) { return _this.isPopupShow(value, selectionIds); });
	                    });
	                    tooltipRoot
	                        .enter()
	                        .append("g")
	                        .classed(node.class, true);
	                    tooltipRoot
	                        .attr("transform", function (d) {
	                        var x = xScale(d.x) - width / 2;
	                        var y = tooltipShiftY(d.y, d.groupIndex);
	                        d.popupInfo.offsetX = Math.min(_this.viewport.width - _this.margin.right - width, Math.max(-_this.margin.left, x)) - x;
	                        return visuals.SVGUtil.translate(x + d.popupInfo.offsetX, y);
	                    });
	                    var tooltipRect = tooltipRoot.selectAll(PulseChart.TooltipRect.selector).data(function (d) { return [d]; });
	                    tooltipRect.enter().append("path").classed(PulseChart.TooltipRect.class, true);
	                    tooltipRect
	                        .attr("display", function (d) { return d.popupInfo ? "inherit" : "none"; })
	                        .style('fill', this.data.settings.popup.color)
	                        .attr('d', function (d) {
	                        var path = [
	                            {
	                                "x": -2,
	                                "y": _this.isHigherMiddle(d.y, d.groupIndex) ? (-1 * marginTop) : 0,
	                            },
	                            {
	                                "x": -2,
	                                "y": _this.isHigherMiddle(d.y, d.groupIndex) ? (-1 * (marginTop + height)) : height,
	                            },
	                            {
	                                "x": width - 2,
	                                "y": _this.isHigherMiddle(d.y, d.groupIndex) ? (-1 * (marginTop + height)) : height,
	                            },
	                            {
	                                "x": width - 2,
	                                "y": _this.isHigherMiddle(d.y, d.groupIndex) ? (-1 * marginTop) : 0,
	                            }
	                        ];
	                        return line(path);
	                    });
	                    var tooltipTriangle = tooltipRoot.selectAll(PulseChart.TooltipTriangle.selector).data(function (d) { return [d]; });
	                    tooltipTriangle.enter().append("path").classed(PulseChart.TooltipTriangle.class, true);
	                    tooltipTriangle
	                        .style('fill', this.data.settings.popup.color)
	                        .attr('d', function (d) {
	                        var path = [
	                            {
	                                "x": width / 2 - 5 - d.popupInfo.offsetX,
	                                "y": _this.isHigherMiddle(d.y, d.groupIndex) ? (-1 * marginTop) : 0,
	                            },
	                            {
	                                "x": width / 2 - d.popupInfo.offsetX,
	                                "y": _this.isHigherMiddle(d.y, d.groupIndex) ? (-1 * (marginTop - 5)) : -5,
	                            },
	                            {
	                                "x": width / 2 + 5 - d.popupInfo.offsetX,
	                                "y": _this.isHigherMiddle(d.y, d.groupIndex) ? (-1 * marginTop) : 0,
	                            },
	                        ];
	                        return line(path);
	                    })
	                        .style('stroke-width', "1px");
	                    var tooltipLine = tooltipRoot.selectAll(PulseChart.TooltipLine.selector).data(function (d) { return [d]; });
	                    tooltipLine.enter().append("path").classed(PulseChart.TooltipLine.class, true);
	                    tooltipLine
	                        .style('fill', this.data.settings.popup.color)
	                        .style('stroke', this.data.settings.popup.color)
	                        .style('stroke-width', "1px")
	                        .attr('d', function (d) {
	                        var path = [
	                            {
	                                "x": width / 2 - d.popupInfo.offsetX,
	                                "y": _this.isHigherMiddle(d.y, d.groupIndex) ?
	                                    yScales[d.groupIndex](d.y) + tooltipShiftY(d.y, d.groupIndex) - d.eventSize :
	                                    yScales[d.groupIndex](d.y) - tooltipShiftY(d.y, d.groupIndex) + d.eventSize,
	                            },
	                            {
	                                "x": width / 2 - d.popupInfo.offsetX,
	                                "y": _this.isHigherMiddle(d.y, d.groupIndex) ? (-1 * marginTop) : 0,
	                            }];
	                        return line(path);
	                    });
	                    var isShowTime = this.data.settings.popup.showTime;
	                    var isShowTitle = this.data.settings.popup.showTitle;
	                    var timeRect = tooltipRoot.selectAll(PulseChart.TooltipTimeRect.selector).data(function (d) { return [d]; });
	                    var timeDisplayStyle = { "display": isShowTime ? undefined : "none" };
	                    timeRect.enter().append("path").classed(PulseChart.TooltipTimeRect.class, true);
	                    timeRect
	                        .style("fill", this.data.settings.popup.timeFill)
	                        .style(timeDisplayStyle)
	                        .attr('d', function (d) {
	                        var path = [
	                            {
	                                "x": width - _this.data.widthOfTooltipValueLabel - 2,
	                                "y": _this.isHigherMiddle(d.y, d.groupIndex) ? (-1 * (marginTop + height)) : 0,
	                            },
	                            {
	                                "x": width - _this.data.widthOfTooltipValueLabel - 2,
	                                "y": _this.isHigherMiddle(d.y, d.groupIndex)
	                                    ? (-1 * (marginTop + height - PulseChart.DefaultTooltipSettings.timeHeight))
	                                    : PulseChart.DefaultTooltipSettings.timeHeight,
	                            },
	                            {
	                                "x": width - 2,
	                                "y": _this.isHigherMiddle(d.y, d.groupIndex)
	                                    ? (-1 * (marginTop + height - PulseChart.DefaultTooltipSettings.timeHeight))
	                                    : PulseChart.DefaultTooltipSettings.timeHeight,
	                            },
	                            {
	                                "x": width - 2,
	                                "y": _this.isHigherMiddle(d.y, d.groupIndex) ? (-1 * (marginTop + height)) : 0,
	                            }
	                        ];
	                        return line(path);
	                    });
	                    var time = tooltipRoot.selectAll(PulseChart.TooltipTime.selector).data(function (d) { return [d]; });
	                    time.enter().append("text").classed(PulseChart.TooltipTime.class, true);
	                    time
	                        .style(PulseChart.ConvertTextPropertiesToStyle(PulseChart.GetPopupValueTextProperties()))
	                        .style(timeDisplayStyle)
	                        .style("fill", this.data.settings.popup.timeColor)
	                        .attr("x", function (d) { return width - _this.data.widthOfTooltipValueLabel; })
	                        .attr("y", function (d) { return _this.isHigherMiddle(d.y, d.groupIndex)
	                        ? (-1 * (marginTop + height - PulseChart.DefaultTooltipSettings.timeHeight + 3))
	                        : PulseChart.DefaultTooltipSettings.timeHeight - 3; })
	                        .text(function (d) { return d.popupInfo.value; });
	                    var titleDisplayStyle = { "display": isShowTitle ? undefined : "none" };
	                    var title = tooltipRoot.selectAll(PulseChart.TooltipTitle.selector).data(function (d) { return [d]; });
	                    title.enter().append("text").classed(PulseChart.TooltipTitle.class, true);
	                    title
	                        .style(titleDisplayStyle)
	                        .style(PulseChart.ConvertTextPropertiesToStyle(PulseChart.GetPopupTitleTextProperties()))
	                        .style("fill", this.data.settings.popup.fontColor)
	                        .attr("x", function (d) { return PulseChart.PopupTextPadding; })
	                        .attr("y", function (d) {
	                        return (_this.isHigherMiddle(d.y, d.groupIndex) ? (-1 * (marginTop + height - 12)) : 12) + PulseChart.PopupTextPadding;
	                    })
	                        .text(function (d) {
	                        if (!d.popupInfo) {
	                            return "";
	                        }
	                        var maxWidth = width - PulseChart.PopupTextPadding * 2 -
	                            (isShowTime ? (_this.data.widthOfTooltipValueLabel - PulseChart.PopupTextPadding) : 0) - 10;
	                        return TextMeasurementService.getTailoredTextOrDefault(PulseChart.GetPopupTitleTextProperties(d.popupInfo.title), maxWidth);
	                    });
	                    var getDescriptionDimenstions = function (d) {
	                        var shiftY = PulseChart.PopupTextPadding + _this.data.settings.popup.fontSize;
	                        var descriptionYOffset = shiftY + PulseChart.DefaultTooltipSettings.timeHeight;
	                        if (d.popupInfo) {
	                            shiftY = ((isShowTitle && d.popupInfo.title) || (isShowTime && d.popupInfo.value)) ? descriptionYOffset : shiftY;
	                        }
	                        return {
	                            y: _this.isHigherMiddle(d.y, d.groupIndex)
	                                ? (-1 * (marginTop + height - shiftY))
	                                : shiftY,
	                            x: PulseChart.PopupTextPadding,
	                            width: width - PulseChart.PopupTextPadding * 2,
	                            height: height - shiftY,
	                        };
	                    };
	                    var description = tooltipRoot.selectAll(PulseChart.TooltipDescription.selector).data(function (d) { return [d]; });
	                    description.enter().append("text").classed(PulseChart.TooltipDescription.class, true);
	                    description
	                        .style(PulseChart.ConvertTextPropertiesToStyle(PulseChart.GetPopupDescriptionTextProperties(null, this.data.settings.popup.fontSize)))
	                        .style("fill", this.data.settings.popup.fontColor)
	                        .text(function (d) { return d.popupInfo && d.popupInfo.description; })
	                        .attr("y", function (d) {
	                        var descriptionDimenstions = getDescriptionDimenstions(d);
	                        var el = d3.select(this)[0][0];
	                        TextMeasurementService.wordBreak(el, descriptionDimenstions.width, descriptionDimenstions.height);
	                        return 0;
	                    })
	                        .attr("transform", function (d) {
	                        var descriptionDimenstions = getDescriptionDimenstions(d);
	                        return visuals.SVGUtil.translate(0, descriptionDimenstions.y);
	                    });
	                    description.selectAll("tspan").attr("x", PulseChart.PopupTextPadding);
	                    tooltipRoot
	                        .exit()
	                        .remove();
	                };
	                PulseChart.prototype.isHigherMiddle = function (value, groupIndex) {
	                    if (this.data.settings.popup.alwaysOnTop) {
	                        return true;
	                    }
	                    if (this.data.yScales.length > 1) {
	                        return groupIndex === 0;
	                    }
	                    var domain = this.data.commonYScale.domain(), minValue = d3.min(domain), middleValue = Math.abs((d3.max(domain) - minValue) / 2);
	                    middleValue = middleValue === 0
	                        ? middleValue
	                        : minValue + middleValue;
	                    return value >= middleValue;
	                };
	                PulseChart.getObjectsFromDataView = function (dataView) {
	                    if (!dataView ||
	                        !dataView.metadata ||
	                        !dataView.metadata.columns ||
	                        !dataView.metadata.objects) {
	                        return null;
	                    }
	                    return dataView.metadata.objects;
	                };
	                PulseChart.parseSettings = function (dataView, colors, columns) {
	                    var settings = {}, objects = PulseChart.getObjectsFromDataView(dataView);
	                    settings.xAxis = this.getAxisXSettings(objects, colors);
	                    settings.yAxis = this.getAxisYSettings(objects, colors);
	                    settings.popup = this.getPopupSettings(objects, colors);
	                    settings.dots = this.getDotsSettings(objects, colors);
	                    settings.series = this.getSeriesSettings(objects, colors);
	                    settings.gaps = this.getGapsSettings(objects);
	                    settings.playback = this.getPlaybackSettings(objects, colors);
	                    settings.runnerCounter = this.getRunnerCounterSettings(objects, colors, columns);
	                    return settings;
	                };
	                PulseChart.getPopupSettings = function (objects, colors) {
	                    var show = powerbi.DataViewObjects.getValue(objects, PulseChart.Properties["popup"]["show"], PulseChart.DefaultSettings.popup.show);
	                    var alwaysOnTop = powerbi.DataViewObjects.getValue(objects, PulseChart.Properties["popup"]["alwaysOnTop"], PulseChart.DefaultSettings.popup.alwaysOnTop);
	                    var width = Math.max(PulseChart.PopupMinWidth, Math.min(PulseChart.PopupMaxWidth, powerbi.DataViewObjects.getValue(objects, PulseChart.Properties["popup"]["width"], PulseChart.DefaultSettings.popup.width)));
	                    var height = Math.max(PulseChart.PopupMinHeight, Math.min(PulseChart.PopupMaxHeight, powerbi.DataViewObjects.getValue(objects, PulseChart.Properties["popup"]["height"], PulseChart.DefaultSettings.popup.height)));
	                    var colorHelper = new visuals.ColorHelper(colors, PulseChart.Properties["popup"]["color"], PulseChart.DefaultSettings.popup.color);
	                    var color = colorHelper.getColorForMeasure(objects, "");
	                    var fontSize = parseInt(powerbi.DataViewObjects.getValue(objects, PulseChart.Properties["popup"]["fontSize"], PulseChart.DefaultSettings.popup.fontSize), 10);
	                    var fontColorHelper = new visuals.ColorHelper(colors, PulseChart.Properties["popup"]["fontColor"], PulseChart.DefaultSettings.popup.fontColor);
	                    var fontColor = fontColorHelper.getColorForMeasure(objects, "");
	                    var showTime = powerbi.DataViewObjects.getValue(objects, PulseChart.Properties["popup"]["showTime"], PulseChart.DefaultSettings.popup.showTime);
	                    var showTitle = powerbi.DataViewObjects.getValue(objects, PulseChart.Properties["popup"]["showTitle"], PulseChart.DefaultSettings.popup.showTitle);
	                    var timeColorHelper = new visuals.ColorHelper(colors, PulseChart.Properties["popup"]["timeColor"], PulseChart.DefaultSettings.popup.timeColor);
	                    var timeColor = timeColorHelper.getColorForMeasure(objects, "");
	                    var timeFillHelper = new visuals.ColorHelper(colors, PulseChart.Properties["popup"]["timeFill"], PulseChart.DefaultSettings.popup.timeFill);
	                    var timeFill = timeFillHelper.getColorForMeasure(objects, "");
	                    return {
	                        show: show,
	                        alwaysOnTop: alwaysOnTop,
	                        width: width,
	                        height: height,
	                        color: color,
	                        fontSize: fontSize,
	                        fontColor: fontColor,
	                        showTime: showTime,
	                        showTitle: showTitle,
	                        timeColor: timeColor,
	                        timeFill: timeFill,
	                    };
	                };
	                PulseChart.getDotsSettings = function (objects, colors) {
	                    var properties = PulseChart.Properties["dots"], defaultSettings = PulseChart.DefaultSettings.dots;
	                    var colorHelper = new visuals.ColorHelper(colors, properties["color"], defaultSettings.color);
	                    var color = colorHelper.getColorForMeasure(objects, "");
	                    var minSize = Math.max(0, Math.min(9999, powerbi.DataViewObjects.getValue(objects, properties["minSize"], defaultSettings.minSize)));
	                    var maxSize = Math.max(minSize, Math.min(9999, powerbi.DataViewObjects.getValue(objects, properties["maxSize"], defaultSettings.maxSize)));
	                    var size = Math.max(minSize, Math.min(maxSize, powerbi.DataViewObjects.getValue(objects, properties["size"], defaultSettings.size)));
	                    var transparency = Math.max(0, Math.min(100, powerbi.DataViewObjects.getValue(objects, properties["transparency"], defaultSettings.transparency)));
	                    return {
	                        color: color,
	                        size: size,
	                        minSize: minSize,
	                        maxSize: maxSize,
	                        transparency: transparency,
	                    };
	                };
	                PulseChart.getSeriesSettings = function (objects, colors) {
	                    var width = Math.max(1, Math.min(100, powerbi.DataViewObjects.getValue(objects, PulseChart.Properties["series"]["width"], PulseChart.DefaultSettings.series.width)));
	                    var colorHelper = new visuals.ColorHelper(colors, PulseChart.Properties["series"]["fill"], PulseChart.DefaultSettings.series.fill);
	                    var fill = colorHelper.getColorForMeasure(objects, "");
	                    /*var showByDefault = DataViewObjects.getValue<boolean>(
	                        objects,
	                        PulseChart.Properties["series"]["showByDefault"],
	                        PulseChart.DefaultSettings.series.showByDefault);*/
	                    return {
	                        width: width,
	                        fill: fill,
	                    };
	                };
	                PulseChart.getGapsSettings = function (objects) {
	                    var show = powerbi.DataViewObjects.getValue(objects, PulseChart.Properties["gaps"]["show"], PulseChart.DefaultSettings.gaps.show);
	                    var visibleGapsPercentage = Math.max(1, Math.min(100, powerbi.DataViewObjects.getValue(objects, PulseChart.Properties["gaps"]["transparency"], PulseChart.DefaultSettings.gaps.visibleGapsPercentage)));
	                    return {
	                        show: show,
	                        visibleGapsPercentage: visibleGapsPercentage
	                    };
	                };
	                PulseChart.getAxisXSettings = function (objects, colors) {
	                    var properties = PulseChart.Properties["xAxis"], defaultSettings = PulseChart.DefaultSettings.xAxis;
	                    var color = new visuals.ColorHelper(colors, properties["color"], defaultSettings.color).getColorForMeasure(objects, "");
	                    var fontColor = new visuals.ColorHelper(colors, properties["fontColor"], defaultSettings.fontColor).getColorForMeasure(objects, "");
	                    var show = powerbi.DataViewObjects.getValue(objects, properties["show"], defaultSettings.show);
	                    var position = powerbi.DataViewObjects.getValue(objects, properties["position"], defaultSettings.position);
	                    var backgroundColor = new visuals.ColorHelper(colors, properties["backgroundColor"], defaultSettings.backgroundColor).getColorForMeasure(objects, "");
	                    return {
	                        show: show,
	                        position: position,
	                        color: color,
	                        fontColor: fontColor,
	                        backgroundColor: backgroundColor
	                    };
	                };
	                PulseChart.getAxisYSettings = function (objects, colors) {
	                    var properties = PulseChart.Properties["yAxis"], defaultSettings = PulseChart.DefaultSettings.yAxis;
	                    var colorHelper = new visuals.ColorHelper(colors, properties["color"], defaultSettings.color);
	                    var color = colorHelper.getColorForMeasure(objects, "");
	                    var fontColorHelper = new visuals.ColorHelper(colors, properties["fontColor"], defaultSettings.fontColor);
	                    var fontColor = fontColorHelper.getColorForMeasure(objects, "");
	                    var show = powerbi.DataViewObjects.getValue(objects, properties["show"], defaultSettings.show);
	                    return {
	                        color: color,
	                        fontColor: fontColor,
	                        show: show,
	                    };
	                };
	                PulseChart.getPlaybackSettings = function (objects, colors) {
	                    var playbackSettings = {};
	                    var properties = PulseChart.Properties["playback"], defaultSettings = PulseChart.DefaultSettings.playback;
	                    playbackSettings.autoplay = powerbi.DataViewObjects.getValue(objects, properties["autoplay"], defaultSettings.autoplay);
	                    playbackSettings.playSpeed = Math.max(1, Math.min(99999, powerbi.DataViewObjects.getValue(objects, properties["playSpeed"], defaultSettings.playSpeed)));
	                    playbackSettings.pauseDuration = Math.max(0, Math.min(9999, powerbi.DataViewObjects.getValue(objects, properties["pauseDuration"], defaultSettings.pauseDuration)));
	                    playbackSettings.autoplayPauseDuration = Math.max(1, Math.min(9999, powerbi.DataViewObjects.getValue(objects, properties["autoplayPauseDuration"], defaultSettings.autoplayPauseDuration)));
	                    var colorHelper = new visuals.ColorHelper(colors, properties["color"], defaultSettings.color);
	                    playbackSettings.color = colorHelper.getColorForMeasure(objects, "");
	                    var position = powerbi.DataViewObjects.getValue(objects, properties["position"], "");
	                    if (position.length > 3) {
	                        try {
	                            playbackSettings.position = JSON.parse(position);
	                        }
	                        catch (ex) { }
	                    }
	                    playbackSettings.position = playbackSettings.position || defaultSettings.position;
	                    return playbackSettings;
	                };
	                PulseChart.getRunnerCounterSettings = function (objects, colors, columns) {
	                    var show = powerbi.DataViewObjects.getValue(objects, PulseChart.Properties["runnerCounter"]["show"], PulseChart.DefaultSettings.runnerCounter.show);
	                    var label = powerbi.DataViewObjects.getValue(objects, PulseChart.Properties["runnerCounter"]["label"], columns.RunnerCounter && columns.RunnerCounter.source && columns.RunnerCounter.source.displayName
	                        || PulseChart.DefaultSettings.runnerCounter.label);
	                    var position = powerbi.DataViewObjects.getValue(objects, PulseChart.Properties["runnerCounter"]["position"], PulseChart.DefaultSettings.runnerCounter.position);
	                    var fontSize = parseInt(powerbi.DataViewObjects.getValue(objects, PulseChart.Properties["runnerCounter"]["fontSize"], PulseChart.DefaultSettings.runnerCounter.fontSize), 10);
	                    var fontColor = new visuals.ColorHelper(colors, PulseChart.Properties["runnerCounter"]["fontColor"], PulseChart.DefaultSettings.runnerCounter.fontColor)
	                        .getColorForMeasure(objects, "");
	                    return {
	                        show: show,
	                        label: label,
	                        position: position,
	                        fontSize: fontSize,
	                        fontColor: fontColor
	                    };
	                };
	                PulseChart.prototype.clearAll = function (hide) {
	                    this.gaps.selectAll(PulseChart.Gap.selector).remove();
	                    if (this.animationHandler) {
	                        this.animationHandler.reset();
	                        this.animationHandler.clear();
	                    }
	                    if (hide) {
	                        this.svg.style('display', "none");
	                    }
	                    this.clearChart();
	                };
	                PulseChart.prototype.clearChart = function () {
	                    this.clearSelection();
	                    this.hideAnimationDot();
	                    this.chart.selectAll(PulseChart.Line.selector).remove();
	                    this.chart.selectAll(PulseChart.Dot.selector).remove();
	                };
	                PulseChart.prototype.clearRedundant = function (position) {
	                    var _this = this;
	                    if (!this.data) {
	                        return;
	                    }
	                    var popups = this.chart.selectAll(PulseChart.Tooltip.selector).filter(function (data) {
	                        return data.seriesIndex < position.series || data.seriesIndex === position.series
	                            && _this.data.series[data.seriesIndex].data[position.index].value >= data.value;
	                    });
	                    var selectedPopupsIds = popups.data().map(function (data) { return data.identity; });
	                    this.clearSelection();
	                    if (selectedPopupsIds.length) {
	                        var popupsSelecting = selectedPopupsIds.map(function (id) { return _this.selectionManager.select(id, true); });
	                        $.when.apply(null, popupsSelecting)
	                            .then(function (selectionIds) { return _this.setSelection(selectionIds); });
	                    }
	                    this.chart.selectAll(PulseChart.Line.selector).remove();
	                    this.chart.selectAll(PulseChart.Dot.selector).remove();
	                };
	                PulseChart.prototype.enumerateObjectInstances = function (options) {
	                    var enumeration = new visuals.ObjectEnumerationBuilder();
	                    switch (options.objectName) {
	                        case "general": {
	                            this.readGeneralInstance(enumeration);
	                            break;
	                        }
	                        case "popup": {
	                            this.readPopupInstance(enumeration);
	                            break;
	                        }
	                        case "dots": {
	                            this.readDotsInstance(enumeration);
	                            break;
	                        }
	                        case "xAxis": {
	                            this.xAxisInstance(enumeration);
	                            break;
	                        }
	                        case "yAxis": {
	                            this.yAxisInstance(enumeration);
	                            break;
	                        }
	                        case "series": {
	                            this.readSeriesInstance(enumeration);
	                            break;
	                        }
	                        case "gaps": {
	                            this.readGapsInstance(enumeration);
	                            break;
	                        }
	                        case "playback": {
	                            this.readPlaybackInstance(enumeration);
	                            break;
	                        }
	                        case "runnerCounter": {
	                            this.readRunnerCounterInstance(enumeration);
	                            break;
	                        }
	                    }
	                    return enumeration.complete();
	                };
	                PulseChart.prototype.getSettings = function (name) {
	                    if (this.data && this.data.settings && this.data.settings[name]) {
	                        return this.data.settings[name];
	                    }
	                    return PulseChart.DefaultSettings[name];
	                };
	                PulseChart.prototype.readGeneralInstance = function (enumeration) {
	                    var instance = {
	                        objectName: "general",
	                        displayName: "general",
	                        selector: null,
	                        properties: {}
	                    };
	                    enumeration.pushInstance(instance);
	                };
	                PulseChart.prototype.readPopupInstance = function (enumeration) {
	                    var settings = this.getSettings("popup");
	                    var popup = {
	                        objectName: "popup",
	                        displayName: "popup",
	                        selector: null,
	                        properties: {
	                            show: settings.show,
	                            alwaysOnTop: settings.alwaysOnTop,
	                            width: settings.width,
	                            height: settings.height,
	                            color: settings.color,
	                            fontColor: settings.fontColor,
	                            fontSize: settings.fontSize,
	                            showTime: settings.showTime,
	                            showTitle: settings.showTitle,
	                            timeColor: settings.timeColor,
	                            timeFill: settings.timeFill,
	                        }
	                    };
	                    enumeration.pushInstance(popup);
	                };
	                PulseChart.prototype.readDotsInstance = function (enumeration) {
	                    var settings = this.getSettings("dots");
	                    var instance = {
	                        objectName: "dots",
	                        displayName: "Dots",
	                        selector: null,
	                        properties: {
	                            color: settings.color,
	                            size: settings.size,
	                            minSize: settings.minSize,
	                            maxSize: settings.maxSize,
	                            transparency: settings.transparency,
	                        }
	                    };
	                    enumeration.pushInstance(instance);
	                };
	                PulseChart.prototype.xAxisInstance = function (enumeration) {
	                    var settings = this.getSettings("xAxis");
	                    enumeration.pushInstance({
	                        objectName: "xAxis",
	                        displayName: "xAxis",
	                        selector: null,
	                        properties: {
	                            show: settings.show,
	                            position: settings.position,
	                            color: settings.color,
	                            fontColor: settings.fontColor,
	                            backgroundColor: settings.backgroundColor
	                        }
	                    });
	                };
	                PulseChart.prototype.yAxisInstance = function (enumeration) {
	                    var settings = this.getSettings("yAxis");
	                    enumeration.pushInstance({
	                        objectName: "yAxis",
	                        displayName: "yAxis",
	                        selector: null,
	                        properties: {
	                            color: settings.color,
	                            fontColor: settings.fontColor,
	                            show: settings.show
	                        }
	                    });
	                };
	                PulseChart.prototype.readSeriesInstance = function (enumeration) {
	                    var settings = this.getSettings("series");
	                    var series = {
	                        objectName: "series",
	                        displayName: "series",
	                        selector: null,
	                        properties: {
	                            fill: settings.fill,
	                            width: settings.width,
	                        }
	                    };
	                    enumeration.pushInstance(series);
	                };
	                PulseChart.prototype.readGapsInstance = function (enumeration) {
	                    var settings = this.getSettings("gaps");
	                    var gaps = {
	                        objectName: "gaps",
	                        selector: null,
	                        properties: {
	                            show: settings.show,
	                            transparency: settings.visibleGapsPercentage //visibleGapsPercentage
	                        }
	                    };
	                    enumeration.pushInstance(gaps);
	                };
	                PulseChart.prototype.readPlaybackInstance = function (enumeration) {
	                    var settings = this.getSettings("playback");
	                    enumeration.pushInstance({
	                        objectName: "playback",
	                        displayName: "playback",
	                        selector: null,
	                        properties: {
	                            autoplay: settings.autoplay,
	                            playSpeed: settings.playSpeed,
	                            pauseDuration: settings.pauseDuration,
	                            autoplayPauseDuration: settings.autoplayPauseDuration,
	                            color: settings.color,
	                        }
	                    });
	                };
	                PulseChart.prototype.readRunnerCounterInstance = function (enumeration) {
	                    var runnerCounterSettings = this.getSettings("runnerCounter");
	                    var instance = {
	                        objectName: "runnerCounter",
	                        selector: null,
	                        properties: {}
	                    };
	                    if (this.data &&
	                        this.data.columns &&
	                        this.data.columns.RunnerCounter) {
	                        instance.properties = {
	                            show: runnerCounterSettings.show,
	                            label: runnerCounterSettings.label,
	                            position: runnerCounterSettings.position,
	                            fontSize: runnerCounterSettings.fontSize,
	                            fontColor: runnerCounterSettings.fontColor
	                        };
	                    }
	                    enumeration.pushInstance(instance);
	                };
	                PulseChart.prototype.destroy = function () {
	                    this.data = null;
	                    this.clearAll(true);
	                };
	                PulseChart.RoleDisplayNames = {
	                    Timestamp: "Timestamp",
	                    Category: "Category",
	                    Value: "Value",
	                    EventTitle: "Event Title",
	                    EventDescription: "Event Description",
	                    EventSize: "Event Size",
	                    RunnerCounter: "Runner Counter",
	                };
	                PulseChart.RoleNames = _.mapValues(PulseChart.RoleDisplayNames, function (x, i) { return i; });
	                PulseChart.capabilities = {
	                    dataRoles: [
	                        {
	                            displayName: PulseChart.RoleDisplayNames.Timestamp,
	                            name: PulseChart.RoleNames.Timestamp,
	                            kind: powerbi.VisualDataRoleKind.Grouping
	                        },
	                        {
	                            displayName: PulseChart.RoleDisplayNames.Value,
	                            name: PulseChart.RoleNames.Value,
	                            kind: powerbi.VisualDataRoleKind.Measure
	                        },
	                        /* Temporary disabled
	                        {
	                            displayName: PulseChart.RoleDisplayNames.Category,
	                            name: PulseChart.RoleNames.Category,
	                            kind: powerbi.VisualDataRoleKind.Grouping
	                        },*/
	                        {
	                            displayName: PulseChart.RoleDisplayNames.EventTitle,
	                            name: PulseChart.RoleNames.EventTitle,
	                            kind: powerbi.VisualDataRoleKind.GroupingOrMeasure
	                        },
	                        {
	                            displayName: PulseChart.RoleDisplayNames.EventDescription,
	                            name: PulseChart.RoleNames.EventDescription,
	                            kind: powerbi.VisualDataRoleKind.GroupingOrMeasure
	                        },
	                        {
	                            displayName: PulseChart.RoleDisplayNames.EventSize,
	                            name: PulseChart.RoleNames.EventSize,
	                            kind: powerbi.VisualDataRoleKind.GroupingOrMeasure
	                        },
	                        {
	                            displayName: PulseChart.RoleDisplayNames.RunnerCounter,
	                            name: PulseChart.RoleNames.RunnerCounter,
	                            kind: powerbi.VisualDataRoleKind.GroupingOrMeasure
	                        },
	                    ],
	                    dataViewMappings: [{
	                            conditions: [
	                                {
	                                    Timestamp: { max: 1 },
	                                    Value: { max: 1 },
	                                    Category: { max: 1 },
	                                    EventTitle: { max: 1 },
	                                    EventDescription: { max: 1 },
	                                    EventSize: { max: 1 },
	                                    RunnerCounter: { max: 1 },
	                                }
	                            ],
	                            categorical: {
	                                categories: {
	                                    for: { in: PulseChart.RoleNames.Timestamp },
	                                    dataReductionAlgorithm: { top: { count: 10000 } }
	                                },
	                                values: {
	                                    group: {
	                                        by: PulseChart.RoleNames.Category,
	                                        select: [
	                                            { bind: { to: PulseChart.RoleNames.Value } },
	                                            { bind: { to: PulseChart.RoleNames.EventTitle } },
	                                            { bind: { to: PulseChart.RoleNames.EventDescription } },
	                                            { bind: { to: PulseChart.RoleNames.EventSize } },
	                                            { bind: { to: PulseChart.RoleNames.RunnerCounter } },
	                                        ],
	                                        dataReductionAlgorithm: { top: {} }
	                                    },
	                                },
	                            },
	                        }],
	                    objects: {
	                        series: {
	                            displayName: "Series",
	                            description: "Series",
	                            properties: {
	                                fill: {
	                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
	                                    type: {
	                                        fill: {
	                                            solid: {
	                                                color: true
	                                            }
	                                        }
	                                    }
	                                },
	                                width: {
	                                    displayName: 'Width',
	                                    type: {
	                                        numeric: true
	                                    }
	                                },
	                            }
	                        },
	                        gaps: {
	                            displayName: "Gaps",
	                            description: "Gaps",
	                            properties: {
	                                show: {
	                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
	                                    type: { bool: true }
	                                },
	                                transparency: {
	                                    displayName: 'Visible gaps',
	                                    type: { numeric: true }
	                                },
	                            }
	                        },
	                        general: {
	                            displayName: 'General',
	                            properties: {
	                                formatString: { type: { formatting: { formatString: true } } },
	                                fill: {
	                                    displayName: 'Background color',
	                                    type: { fill: { solid: { color: true } } }
	                                }
	                            }
	                        },
	                        popup: {
	                            displayName: 'Popup',
	                            properties: {
	                                show: {
	                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
	                                    type: { bool: true }
	                                },
	                                alwaysOnTop: {
	                                    displayName: 'Always on top',
	                                    type: { bool: true }
	                                },
	                                width: {
	                                    displayName: 'Width',
	                                    type: {
	                                        numeric: true
	                                    }
	                                },
	                                height: {
	                                    displayName: 'Height',
	                                    type: {
	                                        numeric: true
	                                    }
	                                },
	                                color: {
	                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                fontSize: {
	                                    displayName: "Text size",
	                                    type: { formatting: { fontSize: true } }
	                                },
	                                fontColor: {
	                                    displayName: "Text color",
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                showTime: {
	                                    displayName: 'Show time',
	                                    type: { bool: true }
	                                },
	                                showTitle: {
	                                    displayName: 'Show title',
	                                    type: { bool: true }
	                                },
	                                timeColor: {
	                                    displayName: "Time color",
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                timeFill: {
	                                    displayName: "Time fill",
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                            }
	                        },
	                        dots: {
	                            displayName: 'Dots',
	                            properties: {
	                                color: {
	                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                minSize: {
	                                    displayName: "Min Size",
	                                    type: { numeric: true }
	                                },
	                                maxSize: {
	                                    displayName: "Max Size",
	                                    type: { numeric: true }
	                                },
	                                size: {
	                                    displayName: "Default Size",
	                                    type: { numeric: true }
	                                },
	                                transparency: {
	                                    displayName: 'Transparency',
	                                    type: { numeric: true }
	                                },
	                            }
	                        },
	                        xAxis: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_XAxis'),
	                            properties: {
	                                show: {
	                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
	                                    type: { bool: true }
	                                },
	                                position: {
	                                    displayName: "Position",
	                                    type: { enumeration: createEnumTypeFromEnum(XAxisPosition) }
	                                },
	                                fontColor: {
	                                    displayName: "Font Color",
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                color: {
	                                    displayName: "Axis Color",
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                backgroundColor: {
	                                    displayName: "Background Color",
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                            }
	                        },
	                        yAxis: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis'),
	                            properties: {
	                                show: {
	                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
	                                    type: { bool: true }
	                                },
	                                fontColor: {
	                                    displayName: "Font Color",
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                color: {
	                                    displayName: "Axis Color",
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                            }
	                        },
	                        playback: {
	                            displayName: 'Playback',
	                            properties: {
	                                autoplay: {
	                                    displayName: "Autoplay",
	                                    type: { bool: true }
	                                },
	                                playSpeed: {
	                                    displayName: "Speed (dots/sec)",
	                                    type: { numeric: true }
	                                },
	                                pauseDuration: {
	                                    displayName: "Pause Duration",
	                                    type: { numeric: true }
	                                },
	                                autoplayPauseDuration: {
	                                    displayName: "Start Delay",
	                                    type: { numeric: true }
	                                },
	                                color: {
	                                    displayName: "Buttons Color",
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                position: {
	                                    displayName: "Position",
	                                    type: { text: true }
	                                }
	                            }
	                        },
	                        runnerCounter: {
	                            displayName: 'Runner Counter',
	                            properties: {
	                                show: {
	                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
	                                    type: { bool: true }
	                                },
	                                label: {
	                                    displayName: "Label",
	                                    type: { text: true }
	                                },
	                                position: {
	                                    displayName: "Position",
	                                    type: { enumeration: createEnumTypeFromEnum(RunnerCounterPosition) }
	                                },
	                                fontSize: {
	                                    displayName: "Text Size",
	                                    type: { formatting: { fontSize: true } }
	                                },
	                                fontColor: {
	                                    displayName: "Font Color",
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                            }
	                        },
	                    },
	                    sorting: {
	                        implicit: {
	                            clauses: [{
	                                    role: PulseChart.RoleNames.Timestamp,
	                                    direction: 1 //SortDirection.Ascending
	                                }]
	                        }
	                    },
	                    supportsHighlight: true
	                };
	                PulseChart.Properties = PulseChart.getProperties(PulseChart.capabilities);
	                PulseChart.DefaultMargin = {
	                    top: 20,
	                    bottom: 20,
	                    right: 25,
	                    left: 25,
	                };
	                PulseChart.DefaultViewport = {
	                    width: 50,
	                    height: 50
	                };
	                PulseChart.PlaybackButtonsHeight = 26;
	                PulseChart.PopupMinHeight = 20;
	                PulseChart.PopupMinWidth = 20;
	                PulseChart.PopupMaxHeight = 200;
	                PulseChart.PopupMaxWidth = 2000;
	                PulseChart.MaxWidthOfYAxis = 50;
	                PulseChart.PopupTextPadding = 3;
	                PulseChart.XAxisTickSpace = 15;
	                PulseChart.XAxisTickHeight = 16;
	                PulseChart.MinimumTicksToRotate = 3;
	                PulseChart.AxisTickRotateAngle = -35;
	                PulseChart.DefaultSettings = {
	                    precision: 0,
	                    popup: {
	                        show: true,
	                        alwaysOnTop: false,
	                        width: 100,
	                        height: 80,
	                        color: "#808181",
	                        fontSize: 10,
	                        fontColor: 'white',
	                        showTime: true,
	                        showTitle: true,
	                        timeColor: 'white',
	                        timeFill: '#010101',
	                    },
	                    dots: {
	                        color: "#808181",
	                        size: 5,
	                        minSize: 5,
	                        maxSize: 20,
	                        transparency: 25,
	                    },
	                    gaps: {
	                        show: false,
	                        visibleGapsPercentage: 1
	                    },
	                    series: {
	                        fill: '#3779B7',
	                        width: 2,
	                    },
	                    xAxis: {
	                        color: "#777777",
	                        fontColor: "#777777",
	                        position: XAxisPosition.Center,
	                        show: true,
	                        dateFormat: PulseChartXAxisDateFormat.TimeOnly,
	                        backgroundColor: "#E1F2F7"
	                    },
	                    yAxis: {
	                        color: "#777777",
	                        fontColor: "#777777",
	                        show: true
	                    },
	                    playback: {
	                        autoplay: false,
	                        playSpeed: 5,
	                        pauseDuration: 10,
	                        autoplayPauseDuration: 0,
	                        color: "#777",
	                        position: null,
	                    },
	                    runnerCounter: {
	                        show: true,
	                        label: "",
	                        position: RunnerCounterPosition.TopRight,
	                        fontSize: 13,
	                        fontColor: "#777777"
	                    },
	                    formatStringProperty: PulseChart.Properties["general"]["formatString"]
	                };
	                PulseChart.DefaultTooltipSettings = {
	                    dataPointColor: "#808181",
	                    marginTop: 20,
	                    timeHeight: 15,
	                };
	                PulseChart.MaxGapCount = 100;
	                PulseChart.MinGapWidth = _.object([[
	                        PulseChartXAxisDateFormat.DateOnly, 60 * 1000 * 24], [
	                        PulseChartXAxisDateFormat.TimeOnly, 60 * 1000],
	                ], undefined);
	                PulseChart.Chart = createClassAndSelector('chart');
	                PulseChart.Line = createClassAndSelector('line');
	                PulseChart.LineContainer = createClassAndSelector('lineContainer');
	                PulseChart.LineNode = createClassAndSelector('lineNode');
	                PulseChart.XAxisNode = createClassAndSelector('xAxisNode');
	                PulseChart.Dot = createClassAndSelector('dot');
	                PulseChart.DotsContainer = createClassAndSelector('dotsContainer');
	                PulseChart.Tooltip = createClassAndSelector('Tooltip');
	                PulseChart.TooltipRect = createClassAndSelector('tooltipRect');
	                PulseChart.TooltipTriangle = createClassAndSelector('tooltipTriangle');
	                PulseChart.Gaps = createClassAndSelector("gaps");
	                PulseChart.Gap = createClassAndSelector("gap");
	                PulseChart.GapNode = createClassAndSelector("gapNode");
	                PulseChart.TooltipLine = createClassAndSelector('tooltipLine');
	                PulseChart.TooltipTime = createClassAndSelector('tooltipTime');
	                PulseChart.TooltipTimeRect = createClassAndSelector('tooltipTimeRect');
	                PulseChart.TooltipTitle = createClassAndSelector('tooltipTitle');
	                PulseChart.TooltipDescription = createClassAndSelector('tooltipDescription');
	                PulseChart.TooltipContainer = createClassAndSelector('tooltipContainer');
	                PulseChart.AnimationDot = createClassAndSelector('animationDot');
	                return PulseChart;
	            }());
	            samples.PulseChart = PulseChart;
	            var PulseAnimatorStates;
	            (function (PulseAnimatorStates) {
	                PulseAnimatorStates[PulseAnimatorStates["Ready"] = 0] = "Ready";
	                PulseAnimatorStates[PulseAnimatorStates["Play"] = 1] = "Play";
	                PulseAnimatorStates[PulseAnimatorStates["Paused"] = 2] = "Paused";
	                PulseAnimatorStates[PulseAnimatorStates["Stopped"] = 3] = "Stopped";
	            })(PulseAnimatorStates || (PulseAnimatorStates = {}));
	            var PulseAnimator = (function () {
	                function PulseAnimator(chart, svg) {
	                    var _this = this;
	                    this.animationPlayingIndex = 0;
	                    this.runnerCounterTopLeftPosition = 180;
	                    this.isAutoPlayed = false;
	                    this.isPositionWasSaved = false;
	                    this.chart = chart;
	                    this.svg = svg;
	                    this.setDefaultValues();
	                    var container = this.container = this.svg.append('g');
	                    this.animationPlay = container.append('g').classed(PulseAnimator.AnimationPlay.class, true);
	                    this.animationPlay
	                        .append("circle")
	                        .attr("cx", 12)
	                        .attr("cy", 12)
	                        .attr("r", 10)
	                        .attr("fill", "transparent");
	                    this.animationPlay
	                        .call(PulseChart.AddOnTouchClick, function () { return _this.play(); });
	                    this.animationPlay
	                        .append("path")
	                        .attr("d", "M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm-3 17v-10l9 5.146-9 4.854z");
	                    this.animationPause = container.append('g').classed(PulseAnimator.AnimationPause.class, true);
	                    this.animationPause
	                        .append("circle")
	                        .attr("cx", 12)
	                        .attr("cy", 12)
	                        .attr("r", 10)
	                        .attr("fill", "transparent");
	                    this.animationPause
	                        .call(PulseChart.AddOnTouchClick, function () { return _this.stop(); });
	                    this.animationPause
	                        .append("path")
	                        .attr("d", "M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm-1 17h-3v-10h3v10zm5-10h-3v10h3v-10z");
	                    this.animationReset = container.append('g').classed(PulseAnimator.AnimationReset.class, true);
	                    this.animationReset
	                        .append("circle")
	                        .attr("cx", 12)
	                        .attr("cy", 12)
	                        .attr("r", 10)
	                        .attr("fill", "transparent");
	                    this.animationReset
	                        .call(PulseChart.AddOnTouchClick, function () { return _this.reset(); });
	                    this.animationReset
	                        .append("path")
	                        .attr("d", "M22 12c0 5.514-4.486 10-10 10s-10-4.486-10-10 4.486-10 10-10 10 4.486 10 10zm-22 0c0 6.627 5.373 12 12 12s12-5.373 12-12-5.373-12-12-12-12 5.373-12 12zm13 0l5-4v8l-5-4zm-5 0l5-4v8l-5-4zm-2 4h2v-8h-2v8z");
	                    /* Prev */
	                    this.animationPrev = container.append('g').classed(PulseAnimator.AnimationPrev.class, true);
	                    this.animationPrev
	                        .append("circle")
	                        .attr("cx", 12)
	                        .attr("cy", 12)
	                        .attr("r", 10)
	                        .attr("fill", "transparent");
	                    this.animationPrev
	                        .call(PulseChart.AddOnTouchClick, function () { return _this.prev(); });
	                    this.animationPrev
	                        .append("path")
	                        .attr("d", "M9.5 12l7.5-4.5v9l-7.5-4.5zm-4.5 0l6.5 4v-1.634l-3.943-2.366 3.943-2.366v-1.634l-6.5 4zm17 0c0 5.514-4.486 10-10 10s-10-4.486-10-10 4.486-10 10-10 10 4.486 10 10zm-22 0c0 6.627 5.373 12 12 12s12-5.373 12-12-5.373-12-12-12-12 5.373-12 12z");
	                    /* Next */
	                    this.animationNext = container.append('g').classed(PulseAnimator.AnimationNext.class, true);
	                    this.animationNext
	                        .append("circle")
	                        .attr("cx", 12)
	                        .attr("cy", 12)
	                        .attr("r", 10)
	                        .attr("fill", "transparent");
	                    this.animationNext
	                        .call(PulseChart.AddOnTouchClick, function () { return _this.next(); });
	                    this.animationNext
	                        .append("path")
	                        .attr("d", "M7 16.5v-9l7.5 4.5-7.5 4.5zm5.5-8.5v1.634l3.943 2.366-3.943 2.366v1.634l6.5-4-6.5-4zm-.5-6c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12z")
	                        .attr("rotate", 180);
	                    /* ToEnd */
	                    this.animationToEnd = container.append('g').classed(PulseAnimator.AnimationToEnd.class, true);
	                    this.animationToEnd
	                        .append("circle")
	                        .attr("cx", 12)
	                        .attr("cy", 12)
	                        .attr("r", 10)
	                        .attr("fill", "transparent");
	                    this.animationToEnd
	                        .call(PulseChart.AddOnTouchClick, function () { return _this.toEnd(); });
	                    this.animationToEnd
	                        .append("path")
	                        .attr("d", "M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm-6 16v-8l5 4-5 4zm5 0v-8l5 4-5 4zm7-8h-2v8h2v-8z");
	                    this.runnerCounter = container.append('g').classed(PulseAnimator.RunnerCounter.class, true);
	                    this.runnerCounterText = this.runnerCounter.append('text');
	                    this.setControlsColor(PulseAnimator.DefaultControlsColor);
	                }
	                Object.defineProperty(PulseAnimator, "AnimationMinPosition", {
	                    get: function () {
	                        return { series: 0, index: 0 };
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(PulseAnimator.prototype, "runnerCounterPosition", {
	                    get: function () {
	                        return this.chart.data.settings.runnerCounter.position;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(PulseAnimator.prototype, "maxTextWidthOfRunnerCounterValue", {
	                    get: function () {
	                        var top = this.runnerCounterPosition === RunnerCounterPosition.TopLeft || this.runnerCounterPosition === RunnerCounterPosition.TopRight;
	                        return this.chart.viewport.width - (top ? this.runnerCounterTopLeftPosition : 0);
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(PulseAnimator.prototype, "isAnimated", {
	                    get: function () {
	                        return (this.animatorState === PulseAnimatorStates.Paused) ||
	                            (this.animatorState === PulseAnimatorStates.Play) ||
	                            (this.animatorState === PulseAnimatorStates.Stopped);
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(PulseAnimator.prototype, "isPlaying", {
	                    get: function () {
	                        return this.animatorState === PulseAnimatorStates.Play;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(PulseAnimator.prototype, "isPaused", {
	                    get: function () {
	                        return this.animatorState === PulseAnimatorStates.Paused;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(PulseAnimator.prototype, "isStopped", {
	                    get: function () {
	                        return this.animatorState === PulseAnimatorStates.Stopped;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                PulseAnimator.prototype.setDefaultValues = function () {
	                    this.position = PulseAnimator.AnimationMinPosition;
	                    this.animatorState = PulseAnimatorStates.Ready;
	                    this.runnerCounterValue = null;
	                };
	                PulseAnimator.prototype.render = function () {
	                    this.renderControls();
	                    this.disableControls();
	                    if (!this.chart.isAutoPlay) {
	                        this.isAutoPlayed = true;
	                        if (this.savedPosition) {
	                            this.savedPosition = null;
	                        }
	                    }
	                    if (this.chart.isAutoPlay && this.isAutoPlayed
	                        && this.animatorState === PulseAnimatorStates.Play
	                        && !this.isPositionWasSaved
	                        && !_.isEqual(this.autoPlayPosition, this.savedPosition)) {
	                        this.chart.stopAnimation();
	                        this.isAutoPlayed = false;
	                        this.isPositionWasSaved = true;
	                        this.animatorState = PulseAnimatorStates.Ready;
	                    }
	                    if (this.animatorState === PulseAnimatorStates.Play) {
	                        this.play();
	                    }
	                    else if (this.chart.isAutoPlay && !this.isAutoPlayed && (this.animatorState === PulseAnimatorStates.Ready)) {
	                        //console.log("loaded " + JSON.stringify(this.savedPosition));
	                        this.autoPlayPosition = this.savedPosition;
	                        this.isAutoPlayed = true;
	                        if (this.savedPosition
	                            && this.savedPosition.series < this.chart.data.series.length
	                            && this.savedPosition.index < this.chart.data.series[this.savedPosition.series].data.length) {
	                            this.position = this.savedPosition;
	                        }
	                        this.play(this.chart.autoplayPauseDuration);
	                    }
	                    else {
	                        this.chart.renderChart();
	                    }
	                };
	                PulseAnimator.prototype.setControlsColor = function (color) {
	                    this.color = color;
	                };
	                PulseAnimator.prototype.renderControls = function () {
	                    this.show();
	                    this.animationPlay
	                        .attr('transform', visuals.SVGUtil.translate(0, 0))
	                        .attr("fill", this.color);
	                    this.animationPause
	                        .attr('transform', visuals.SVGUtil.translate(30, 0))
	                        .attr("fill", this.color);
	                    this.animationReset
	                        .attr('transform', visuals.SVGUtil.translate(60, 0))
	                        .attr("fill", this.color);
	                    this.animationPrev
	                        .attr('transform', visuals.SVGUtil.translate(90, 0))
	                        .attr("fill", this.color);
	                    this.animationNext
	                        .attr('transform', visuals.SVGUtil.translate(120, 0))
	                        .attr("fill", this.color);
	                    this.animationToEnd
	                        .attr('transform', visuals.SVGUtil.translate(150, 0))
	                        .attr("fill", this.color);
	                    this.runnerCounter
	                        .attr('fill', this.color)
	                        .attr('transform', visuals.SVGUtil.translate(this.runnerCounterPosition === RunnerCounterPosition.TopLeft
	                        ? this.runnerCounterTopLeftPosition
	                        : this.chart.viewport.width - 2, this.chart.data.runnerCounterHeight / 2 + 7));
	                    this.runnerCounterText
	                        .style('text-anchor', this.runnerCounterPosition === RunnerCounterPosition.TopLeft ? "start" : "end");
	                    if (this.chart.data && this.chart.data.settings) {
	                        this.runnerCounterText.style(PulseChart.ConvertTextPropertiesToStyle(PulseChart.GetRunnerCounterTextProperties(null, this.chart.data.settings.runnerCounter.fontSize)));
	                        this.runnerCounterText.style('fill', this.chart.data.settings.runnerCounter.fontColor);
	                    }
	                    this.drawCounterValue();
	                };
	                PulseAnimator.setControlVisiblity = function (element, isVisible, isDisabled) {
	                    if (isDisabled === void 0) { isDisabled = false; }
	                    element
	                        .style('opacity', isVisible ? PulseAnimator.DefaultOpacity : PulseAnimator.DimmedOpacity);
	                    if (isVisible) {
	                        element.attr('display', "inline");
	                    }
	                    else if (isDisabled) {
	                        element.attr('display', "none");
	                    }
	                };
	                PulseAnimator.prototype.disableControls = function () {
	                    var showRunner = this.chart.data && this.chart.data.settings && this.chart.data.settings.runnerCounter.show;
	                    PulseAnimator.setControlVisiblity(this.animationReset, true);
	                    PulseAnimator.setControlVisiblity(this.animationToEnd, true);
	                    switch (this.animatorState) {
	                        case PulseAnimatorStates.Play:
	                            PulseAnimator.setControlVisiblity(this.animationPlay, false);
	                            PulseAnimator.setControlVisiblity(this.animationPrev, true);
	                            PulseAnimator.setControlVisiblity(this.animationNext, true);
	                            PulseAnimator.setControlVisiblity(this.animationPause, true);
	                            PulseAnimator.setControlVisiblity(this.runnerCounter, showRunner, true);
	                            break;
	                        case PulseAnimatorStates.Paused:
	                            PulseAnimator.setControlVisiblity(this.animationPlay, true);
	                            PulseAnimator.setControlVisiblity(this.animationPause, true);
	                            PulseAnimator.setControlVisiblity(this.animationPrev, true);
	                            PulseAnimator.setControlVisiblity(this.animationNext, true);
	                            PulseAnimator.setControlVisiblity(this.runnerCounter, showRunner, true);
	                            break;
	                        case PulseAnimatorStates.Stopped:
	                            PulseAnimator.setControlVisiblity(this.animationPlay, true);
	                            PulseAnimator.setControlVisiblity(this.animationPrev, true);
	                            PulseAnimator.setControlVisiblity(this.animationNext, true);
	                            PulseAnimator.setControlVisiblity(this.runnerCounter, showRunner, true);
	                            PulseAnimator.setControlVisiblity(this.animationPause, false);
	                            break;
	                        case PulseAnimatorStates.Ready:
	                            PulseAnimator.setControlVisiblity(this.animationPlay, true);
	                            PulseAnimator.setControlVisiblity(this.animationPrev, false);
	                            PulseAnimator.setControlVisiblity(this.animationNext, false);
	                            PulseAnimator.setControlVisiblity(this.animationPause, false);
	                            PulseAnimator.setControlVisiblity(this.runnerCounter, false, true);
	                            break;
	                        default:
	                            PulseAnimator.setControlVisiblity(this.animationPlay, true);
	                            PulseAnimator.setControlVisiblity(this.animationPrev, false);
	                            PulseAnimator.setControlVisiblity(this.animationNext, false);
	                            PulseAnimator.setControlVisiblity(this.animationPause, false);
	                            PulseAnimator.setControlVisiblity(this.runnerCounter, false, true);
	                            break;
	                    }
	                };
	                PulseAnimator.prototype.show = function () {
	                    this.container.style('display', 'inline');
	                };
	                PulseAnimator.prototype.setRunnerCounterValue = function (index) {
	                    var dataPoint = this.chart.data
	                        && this.chart.data.series
	                        && this.chart.data.series[this.position.series]
	                        && this.chart.data.series[this.position.series].data
	                        && this.chart.data.series[this.position.series].data[$.isNumeric(index) ? index : this.flooredPosition.index];
	                    var runnerCounterValue = (dataPoint && dataPoint.runnerCounterValue != null)
	                        ? dataPoint.runnerCounterValue
	                        : "";
	                    if (dataPoint && dataPoint.runnerCounterFormatString) {
	                        var runnerCounterformatter = visuals.valueFormatter.create({ format: dataPoint.runnerCounterFormatString });
	                        runnerCounterValue = runnerCounterformatter.format(runnerCounterValue);
	                    }
	                    this.runnerCounterValue = this.chart.data.settings.runnerCounter.label + " " + runnerCounterValue;
	                    this.drawCounterValue();
	                };
	                PulseAnimator.prototype.drawCounterValue = function () {
	                    var progressText = "" + this.runnerCounterValue;
	                    this.runnerCounterText.text(progressText);
	                    TextMeasurementService.svgEllipsis(this.runnerCounterText.node(), this.maxTextWidthOfRunnerCounterValue);
	                };
	                PulseAnimator.prototype.play = function (delay, renderDuringPlaying) {
	                    if (delay === void 0) { delay = 0; }
	                    if (renderDuringPlaying === void 0) { renderDuringPlaying = false; }
	                    if (this.animatorState === PulseAnimatorStates.Play && !renderDuringPlaying) {
	                        return;
	                    }
	                    if (this.animatorState === PulseAnimatorStates.Ready) {
	                        this.animationPlayingIndex++;
	                        this.chart.clearChart();
	                    }
	                    if (this.chart.isAnimationIndexLast(this.position)) {
	                        this.playNext();
	                        return;
	                    }
	                    if (this.animatorState === PulseAnimatorStates.Paused) {
	                        this.chart.clearSelection();
	                    }
	                    this.animatorState = PulseAnimatorStates.Play;
	                    this.chart.renderChart();
	                    this.chart.playAnimation(delay);
	                    this.disableControls();
	                };
	                PulseAnimator.prototype.playNext = function () {
	                    this.pause();
	                    if (this.chart.isAnimationSeriesLast(this.position)) {
	                        this.setDefaultValues();
	                        this.chart.clearSelection();
	                    }
	                    else {
	                        this.position = {
	                            series: this.position.series + 1,
	                            index: PulseAnimator.AnimationMinPosition.index,
	                        };
	                        this.play();
	                    }
	                };
	                PulseAnimator.prototype.pause = function () {
	                    if (this.animatorState === PulseAnimatorStates.Play) {
	                        this.animatorState = PulseAnimatorStates.Paused;
	                        this.chart.pauseAnimation();
	                    }
	                    this.disableControls();
	                };
	                PulseAnimator.prototype.reset = function () {
	                    this.clearTimeouts();
	                    this.chart.stopAnimation();
	                    this.chart.clearSelection();
	                    this.chart.clearChart();
	                    this.setDefaultValues();
	                    this.animatorState = PulseAnimatorStates.Stopped;
	                    this.disableControls();
	                    this.savedPosition = null;
	                };
	                PulseAnimator.prototype.next = function () {
	                    if (!this.isAnimated) {
	                        return;
	                    }
	                    this.stop();
	                    var newPosition = this.chart.findNextPoint(this.position);
	                    if (newPosition) {
	                        this.position = newPosition;
	                        this.chart.renderChart();
	                    }
	                    else {
	                        this.toEnd();
	                    }
	                };
	                PulseAnimator.prototype.prev = function () {
	                    if (!this.isAnimated) {
	                        return;
	                    }
	                    this.stop();
	                    var newPosition = this.chart.findPrevPoint(this.position);
	                    if (newPosition) {
	                        this.chart.clearRedundant(newPosition);
	                        this.position = newPosition;
	                        this.chart.renderChart();
	                    }
	                    else {
	                        this.reset();
	                    }
	                };
	                PulseAnimator.prototype.toEnd = function () {
	                    this.savedPosition = null;
	                    this.chart.stopAnimation();
	                    this.chart.clearSelection();
	                    this.chart.clearChart();
	                    this.setDefaultValues();
	                    this.disableControls();
	                    this.chart.renderChart();
	                };
	                PulseAnimator.prototype.stop = function () {
	                    if (!this.isAnimated) {
	                        return;
	                    }
	                    this.drawCounterValue();
	                    this.savedPosition = this.position;
	                    this.chart.stopAnimation();
	                    this.animatorState = PulseAnimatorStates.Stopped;
	                    this.disableControls();
	                };
	                Object.defineProperty(PulseAnimator.prototype, "position", {
	                    get: function () {
	                        return this.positionValue;
	                    },
	                    set: function (position) {
	                        this.positionValue = position;
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(PulseAnimator.prototype, "flooredPosition", {
	                    get: function () {
	                        return this.position && { series: this.position.series, index: Math.floor(this.position.index) };
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                Object.defineProperty(PulseAnimator.prototype, "savedPosition", {
	                    get: function () {
	                        return this.chart.data
	                            && this.chart.data.settings
	                            && this.chart.data.settings.playback
	                            && this.chart.data.settings.playback.position;
	                    },
	                    set: function (position) {
	                        if (!this.chart.isAutoPlay) {
	                            position = null;
	                        }
	                        if (this.chart.data && this.chart.data.settings && this.chart.data.settings.playback) {
	                            //console.log("saved " + JSON.stringify(position));
	                            this.isPositionWasSaved = true;
	                            if (this.chart.data && this.chart.data.settings && this.chart.data.settings.playback) {
	                                this.chart.data.settings.playback.position = position;
	                            }
	                            this.chart.host.persistProperties({
	                                merge: [{
	                                        objectName: "playback",
	                                        selector: null,
	                                        properties: { position: position && JSON.stringify(position) || "" }
	                                    }] });
	                        }
	                    },
	                    enumerable: true,
	                    configurable: true
	                });
	                PulseAnimator.prototype.clear = function () {
	                    if (this.isAnimated) {
	                        this.chart.stopAnimation();
	                    }
	                    this.setDefaultValues();
	                    this.container.style('display', 'none');
	                };
	                PulseAnimator.prototype.clearTimeouts = function () {
	                    clearTimeout(this.chart.handleSelectionTimeout);
	                };
	                PulseAnimator.AnimationPlay = createClassAndSelector('animationPlay');
	                PulseAnimator.AnimationPause = createClassAndSelector('animationPause');
	                PulseAnimator.AnimationReset = createClassAndSelector('animationReset');
	                PulseAnimator.AnimationToEnd = createClassAndSelector('animationToEnd');
	                PulseAnimator.AnimationPrev = createClassAndSelector('animationPrev');
	                PulseAnimator.AnimationNext = createClassAndSelector('animationNext');
	                PulseAnimator.RunnerCounter = createClassAndSelector('runnerCounter');
	                //private static ControlsDuration = 250;
	                PulseAnimator.DimmedOpacity = 0.25;
	                PulseAnimator.DefaultOpacity = 1;
	                PulseAnimator.DefaultControlsColor = "#777";
	                return PulseAnimator;
	            }());
	            samples.PulseAnimator = PulseAnimator;
	            var PulseChartDataLabelUtils;
	            (function (PulseChartDataLabelUtils) {
	                function getDefaultPulseChartLabelSettings() {
	                    return {
	                        show: false,
	                        position: 0 /* Above */,
	                        displayUnits: 0,
	                        precision: defaultLabelPrecision,
	                        labelColor: defaultLabelColor,
	                        fontSize: DefaultFontSizeInPt,
	                        labelDensity: defaultLabelDensity,
	                    };
	                }
	                PulseChartDataLabelUtils.getDefaultPulseChartLabelSettings = getDefaultPulseChartLabelSettings;
	            })(PulseChartDataLabelUtils = samples.PulseChartDataLabelUtils || (samples.PulseChartDataLabelUtils = {}));
	            var PulseChartAxisPropertiesHelper;
	            (function (PulseChartAxisPropertiesHelper) {
	                function getCategoryAxisProperties(dataViewMetadata, axisTitleOnByDefault) {
	                    var toReturn = {};
	                    if (!dataViewMetadata) {
	                        return toReturn;
	                    }
	                    var objects = dataViewMetadata.objects;
	                    if (objects) {
	                        var categoryAxisObject = objects['categoryAxis'];
	                        if (categoryAxisObject) {
	                            toReturn = {
	                                show: categoryAxisObject['show'],
	                                axisType: categoryAxisObject['axisType'],
	                                axisScale: categoryAxisObject['axisScale'],
	                                start: categoryAxisObject['start'],
	                                end: categoryAxisObject['end'],
	                                showAxisTitle: categoryAxisObject['showAxisTitle'] == null ? axisTitleOnByDefault : categoryAxisObject['showAxisTitle'],
	                                axisStyle: categoryAxisObject['axisStyle'],
	                                labelColor: categoryAxisObject['labelColor'],
	                                labelDisplayUnits: categoryAxisObject['labelDisplayUnits'],
	                                labelPrecision: categoryAxisObject['labelPrecision'],
	                                duration: categoryAxisObject['duration'],
	                            };
	                        }
	                    }
	                    return toReturn;
	                }
	                PulseChartAxisPropertiesHelper.getCategoryAxisProperties = getCategoryAxisProperties;
	                function getValueAxisProperties(dataViewMetadata, axisTitleOnByDefault) {
	                    var toReturn = {};
	                    if (!dataViewMetadata) {
	                        return toReturn;
	                    }
	                    var objects = dataViewMetadata.objects;
	                    if (objects) {
	                        var valueAxisObject = objects['valueAxis'];
	                        if (valueAxisObject) {
	                            toReturn = {
	                                show: valueAxisObject['show'],
	                                position: valueAxisObject['position'],
	                                axisScale: valueAxisObject['axisScale'],
	                                start: valueAxisObject['start'],
	                                end: valueAxisObject['end'],
	                                showAxisTitle: valueAxisObject['showAxisTitle'] == null ? axisTitleOnByDefault : valueAxisObject['showAxisTitle'],
	                                axisStyle: valueAxisObject['axisStyle'],
	                                labelColor: valueAxisObject['labelColor'],
	                                labelDisplayUnits: valueAxisObject['labelDisplayUnits'],
	                                labelPrecision: valueAxisObject['labelPrecision'],
	                                secShow: valueAxisObject['secShow'],
	                                secPosition: valueAxisObject['secPosition'],
	                                secAxisScale: valueAxisObject['secAxisScale'],
	                                secStart: valueAxisObject['secStart'],
	                                secEnd: valueAxisObject['secEnd'],
	                                secShowAxisTitle: valueAxisObject['secShowAxisTitle'],
	                                secAxisStyle: valueAxisObject['secAxisStyle'],
	                                secLabelColor: valueAxisObject['secLabelColor'],
	                                secLabelDisplayUnits: valueAxisObject['secLabelDisplayUnits'],
	                                secLabelPrecision: valueAxisObject['secLabelPrecision'],
	                            };
	                        }
	                    }
	                    return toReturn;
	                }
	                PulseChartAxisPropertiesHelper.getValueAxisProperties = getValueAxisProperties;
	            })(PulseChartAxisPropertiesHelper = samples.PulseChartAxisPropertiesHelper || (samples.PulseChartAxisPropertiesHelper = {}));
	        })(samples = visuals.samples || (visuals.samples = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 56 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../../../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var samples;
	        (function (samples) {
	            var SelectionManager = visuals.utility.SelectionManager;
	            ;
	            ;
	            var LineDotChart = (function () {
	                function LineDotChart() {
	                    this.margin = {
	                        top: 10,
	                        right: 30,
	                        bottom: 10,
	                        left: 10
	                    };
	                    this.LegendSize = 50;
	                    this.AxisSize = 30;
	                }
	                /* One time setup*/
	                LineDotChart.prototype.init = function (options) {
	                    var _this = this;
	                    this.hostServices = options.host;
	                    this.selectionManager = new SelectionManager({ hostServices: this.hostServices });
	                    this.root = d3.select(options.element.get(0))
	                        .append('svg')
	                        .classed(LineDotChart.Identity.class, true);
	                    this.root.on('click', function (d) { _this.clearSelection(); });
	                    this.main = this.root.append('g');
	                    this.axes = this.main.append('g').classed(LineDotChart.Axes.class, true);
	                    this.axisX = this.axes.append('g').classed(LineDotChart.Axis.class, true);
	                    this.axisY = this.axes.append('g').classed(LineDotChart.Axis.class, true);
	                    this.axisY2 = this.axes.append('g').classed(LineDotChart.Axis.class, true);
	                    this.legends = this.main.append('g').classed(LineDotChart.Legends.class, true);
	                    this.line = this.main.append('g').classed(LineDotChart.Values.class, true);
	                    this.colors = options.style && options.style.colorPalette
	                        ? options.style.colorPalette.dataColors
	                        : new visuals.DataColorPalette();
	                };
	                /* Called for data, size, formatting changes*/
	                LineDotChart.prototype.update = function (options) {
	                    if (!options.dataViews || !options.dataViews[0]) {
	                        return;
	                    }
	                    var viewport = options.viewport;
	                    var model = this.model = this.converter(options.dataViews[0], viewport);
	                    // if (!model) {
	                    //     return;
	                    // }
	                    this.clearSelection();
	                    this.resize(viewport);
	                    // this.draw(model, !options.suppressAnimations);
	                    this.draw(model);
	                };
	                /*About to remove your visual, do clean up here */
	                LineDotChart.prototype.destroy = function () {
	                    this.root = null;
	                };
	                LineDotChart.prototype.setIsStopped = function (isstopped) {
	                    var objects = {
	                        merge: [
	                            {
	                                objectName: "misc",
	                                selector: undefined,
	                                properties: {
	                                    "isstopped": isstopped,
	                                }
	                            }
	                        ]
	                    };
	                    this.hostServices.persistProperties(objects);
	                    this.hostServices.onSelect({ visualObjects: [] });
	                };
	                LineDotChart.prototype.enumerateObjectInstances = function (options) {
	                    var instances = [];
	                    if (!this.model || !this.model.settings) {
	                        return instances;
	                    }
	                    var settings = this.model.settings;
	                    switch (options.objectName) {
	                        case "lineoptions":
	                            var lineoptions = {
	                                objectName: "lineoptions",
	                                displayName: "lineoptions",
	                                selector: null,
	                                properties: {
	                                    fill: settings.lineFill,
	                                    lineThickness: settings.lineThickness
	                                }
	                            };
	                            instances.push(lineoptions);
	                            break;
	                        case "dotoptions":
	                            var dotoptions = {
	                                objectName: "dotoptions",
	                                displayName: "dotoptions",
	                                selector: null,
	                                properties: {
	                                    color: settings.dotFill,
	                                    dotSizeMin: settings.dotSizeMin,
	                                    dotSizeMax: settings.dotSizeMax
	                                }
	                            };
	                            instances.push(dotoptions);
	                            break;
	                        case "counteroptions":
	                            var counteroptions = {
	                                objectName: "counteroptions",
	                                displayName: "counteroptions",
	                                selector: null,
	                                properties: {
	                                    counterTitle: settings.counterTitle
	                                }
	                            };
	                            instances.push(counteroptions);
	                            break;
	                        // case "labels":
	                        //     var labels: VisualObjectInstance = {
	                        //         objectName: "labels",
	                        //         displayName: "labels",
	                        //         selector: null,
	                        //         properties: {
	                        //             labelPrecision: settings.precision
	                        //         }
	                        //     };
	                        //     instances.push(labels);
	                        //     break;
	                        case "misc":
	                            var misc = {
	                                objectName: "misc",
	                                displayName: "misc",
	                                selector: null,
	                                properties: {
	                                    isanimated: settings.isanimated,
	                                    isstopped: settings.isstopped,
	                                    duration: settings.duration
	                                }
	                            };
	                            instances.push(misc);
	                            break;
	                    }
	                    return instances;
	                };
	                LineDotChart.prototype.selectDot = function (dotelement, selector) {
	                    var dot = d3.select(dotelement);
	                    if (!dot.classed('point_selected')) {
	                        if (selector) {
	                            this.selectionManager.select(selector);
	                        }
	                        this.root.classed("filtered", true);
	                        this.line.selectAll('circle.point')
	                            .classed('point_selected', false);
	                        d3.select(dotelement)
	                            .classed('point_selected', true);
	                    }
	                    else {
	                        this.clearSelection();
	                    }
	                    d3.event.stopPropagation();
	                };
	                LineDotChart.prototype.clearSelection = function () {
	                    this.root.classed("filtered", false);
	                    this.root.selectAll("circle.point").classed("point_selected", false);
	                    this.selectionManager.clear();
	                };
	                // Convert a DataView into a view model
	                LineDotChart.prototype.converter = function (dataView, viewport) {
	                    if (!dataView.categorical ||
	                        !dataView.categorical.categories ||
	                        !dataView.categorical.categories[0] ||
	                        !dataView.categorical.categories[0].values ||
	                        !(dataView.categorical.categories[0].values.length > 0) ||
	                        !dataView.categorical ||
	                        !dataView.categorical.values ||
	                        !dataView.categorical.values[0] ||
	                        !dataView.categorical.values[0].values ||
	                        !(dataView.categorical.values[0].values.length > 0)) {
	                        return null;
	                    }
	                    var values = [];
	                    var metadataColumn;
	                    var extent;
	                    var min;
	                    var max;
	                    var that = this;
	                    var categoryType = visuals.AxisHelper.getCategoryValueType(dataView.categorical.categories[0].source, true);
	                    this.isDateTime = visuals.AxisHelper.isDateTime(categoryType);
	                    var isScalar = true;
	                    var settings = this.parseSettings(dataView);
	                    var effectiveWidth = Math.max(0, viewport.width - this.margin.left - this.margin.right - this.LegendSize - this.AxisSize);
	                    var effectiveHeight = Math.max(0, viewport.height - this.margin.top - this.margin.bottom - this.LegendSize);
	                    var format = "";
	                    var formatter;
	                    // X for categories
	                    values = dataView.categorical.categories[0].values;
	                    metadataColumn = dataView.categorical.categories[0].source;
	                    extent = d3.extent(values);
	                    if (this.isDateTime) {
	                        min = extent[0].getTime();
	                        max = extent[1].getTime();
	                        min = new Date(min);
	                        max = new Date(max + (max - min) * .05);
	                        // var xDomain: number[] = isScalar ? [min, max] : [min.getTime(), max.getTime()]
	                        // var format: string = "MMM dd yyyy HH:mm";
	                        format = "MMM dd yyyy";
	                        formatter = visuals.valueFormatter.create({ format: format });
	                    }
	                    else {
	                        min = extent[0];
	                        max = extent[1];
	                        max = max + (max - min) * .05;
	                        formatter = visuals.valueFormatter.create({ value: 0 });
	                    }
	                    var xAxis = visuals.AxisHelper.createAxis({
	                        pixelSpan: effectiveWidth,
	                        dataDomain: [min, max],
	                        metaDataColumn: metadataColumn,
	                        formatString: null,
	                        //formatString: LineDotChart.Properties.general.formatString,
	                        outerPadding: 0,
	                        isCategoryAxis: true,
	                        isScalar: isScalar,
	                        isVertical: false,
	                        forcedTickCount: undefined,
	                        useTickIntervalForDisplayUnits: true,
	                        // axisPrecision: settings.precision,
	                        getValueFn: function (index, type) {
	                            if (that.isDateTime) {
	                                return formatter.format(new Date(index));
	                            }
	                            else {
	                                return index;
	                            }
	                        }
	                    });
	                    xAxis.formatter = formatter;
	                    metadataColumn = dataView.categorical.values[0].source;
	                    values = dataView.categorical.values[0].values;
	                    extent = d3.extent(values);
	                    min = extent[0];
	                    max = extent[1];
	                    var result = [];
	                    var value_sum = 0;
	                    var value = 0;
	                    var time = 0;
	                    var selector;
	                    for (var i = 0; i < dataView.categorical.categories[0].values.length; i++) {
	                        value = dataView.categorical.values[0].values[i];
	                        time = dataView.categorical.categories[0].values[i];
	                        value_sum += value;
	                        selector = visuals.SelectionId.createWithId(dataView.categorical.categories[0].identity[i]);
	                        result.push({
	                            dot: (value - min) / (max - min),
	                            value: value,
	                            sum: value_sum,
	                            time: time,
	                            selector: selector
	                        });
	                    }
	                    // make some space for counter + 25%
	                    value_sum = value_sum + (value_sum - min) * 0.10;
	                    var yAxis = visuals.AxisHelper.createAxis({
	                        pixelSpan: effectiveHeight,
	                        dataDomain: [min, value_sum],
	                        metaDataColumn: metadataColumn,
	                        formatString: null,
	                        outerPadding: 0,
	                        isCategoryAxis: false,
	                        isScalar: true,
	                        isVertical: true,
	                        useTickIntervalForDisplayUnits: true
	                    });
	                    var yAxis2 = visuals.AxisHelper.createAxis({
	                        pixelSpan: effectiveHeight,
	                        dataDomain: [min, value_sum],
	                        metaDataColumn: metadataColumn,
	                        formatString: null,
	                        outerPadding: 0,
	                        isCategoryAxis: false,
	                        isScalar: true,
	                        isVertical: true,
	                        useTickIntervalForDisplayUnits: true
	                    });
	                    yAxis2.axis.orient('right');
	                    // Show gridlines on the chart to make the values more readable.
	                    // TODO: Make this a configuration setting that can be toggled.
	                    // xAxis.axis = xAxis.axis.tickSize(-effectiveHeight);
	                    // yAxis.axis = yAxis.axis.tickSize(-effectiveWidth);
	                    return {
	                        points: result,
	                        settings: settings,
	                        xAxis: xAxis,
	                        yAxis: yAxis,
	                        yAxis2: yAxis2,
	                        legends: this.generateAxisLabels(viewport, settings)
	                    };
	                };
	                LineDotChart.prototype.parseSettings = function (dataView) {
	                    if (!dataView ||
	                        !dataView.metadata ||
	                        !dataView.metadata.columns ||
	                        !dataView.metadata.columns[0]) {
	                        return null;
	                    }
	                    var objects = dataView.metadata.objects;
	                    var lineFillColorHelper = new visuals.ColorHelper(this.colors, LineDotChart.Properties.lineoptions.fill, LineDotChart.DefaultSettings.lineFill);
	                    var dotFillColorHelper = new visuals.ColorHelper(this.colors, LineDotChart.Properties.dotoptions.color, LineDotChart.DefaultSettings.dotFill);
	                    var xAxisTitle = LineDotChart.DefaultSettings.xAxisTitle;
	                    var yAxisTitle = LineDotChart.DefaultSettings.yAxisTitle;
	                    if (dataView.categorical.categories[0] &&
	                        dataView.categorical.categories[0].source &&
	                        dataView.categorical.categories[0].source.displayName &&
	                        dataView.categorical.values[0] &&
	                        dataView.categorical.values[0].source &&
	                        dataView.categorical.values[0].source.displayName) {
	                        xAxisTitle = dataView.categorical.categories[0].source.displayName;
	                        yAxisTitle = dataView.categorical.values[0].source.displayName;
	                    }
	                    var lineThickness = LineDotChart.DefaultSettings.lineThickness;
	                    var dotSizeMin = LineDotChart.DefaultSettings.dotSizeMin;
	                    var dotSizeMax = LineDotChart.DefaultSettings.dotSizeMax;
	                    var counterTitle = LineDotChart.DefaultSettings.counterTitle;
	                    var isanimated = LineDotChart.DefaultSettings.isanimated;
	                    var isstopped = LineDotChart.DefaultSettings.isstopped;
	                    var duration = LineDotChart.DefaultSettings.duration;
	                    if (objects) {
	                        lineThickness = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.lineoptions.lineThickness, LineDotChart.DefaultSettings.lineThickness);
	                        dotSizeMin = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.dotoptions.dotSizeMin, LineDotChart.DefaultSettings.dotSizeMin);
	                        dotSizeMax = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.dotoptions.dotSizeMax, LineDotChart.DefaultSettings.dotSizeMax);
	                        counterTitle = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.counteroptions.counterTitle, LineDotChart.DefaultSettings.counterTitle);
	                        isanimated = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.misc.isanimated, LineDotChart.DefaultSettings.isanimated);
	                        isstopped = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.misc.isstopped, LineDotChart.DefaultSettings.isstopped);
	                        duration = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.misc.duration, LineDotChart.DefaultSettings.duration);
	                    }
	                    return {
	                        // precision: LineDotChart.getPrecision(objects),
	                        xAxisTitle: xAxisTitle,
	                        yAxisTitle: yAxisTitle,
	                        lineFill: lineFillColorHelper.getColorForMeasure(objects, ''),
	                        lineThickness: lineThickness,
	                        dotFill: dotFillColorHelper.getColorForMeasure(objects, ''),
	                        dotSizeMin: dotSizeMin,
	                        dotSizeMax: dotSizeMax,
	                        counterTitle: counterTitle,
	                        isstopped: isstopped,
	                        isanimated: isanimated,
	                        duration: duration
	                    };
	                };
	                // private static getPrecision(objects: DataViewObjects): number {
	                //     if (!objects) {
	                //         return LineDotChart.DefaultSettings.precision;
	                //     }
	                //     var precision: number = DataViewObjects.getValue(
	                //         objects,
	                //         LineDotChart.Properties.labels.labelPrecision,
	                //         LineDotChart.DefaultSettings.precision);
	                //     if (precision < LineDotChart.MinPrecision) {
	                //         return LineDotChart.MinPrecision;
	                //     }
	                //     return precision;
	                // }
	                LineDotChart.prototype.generateAxisLabels = function (viewport, settings) {
	                    return [
	                        {
	                            transform: visuals.SVGUtil.translate((viewport.width - this.margin.left - this.margin.right) / 2, (viewport.height - this.margin.top - this.margin.bottom)),
	                            text: settings.xAxisTitle,
	                            dx: "1em",
	                            dy: "-1em"
	                        }, {
	                            transform: visuals.SVGUtil.translateAndRotate(0, (viewport.height - this.margin.top - this.margin.bottom) / 2, 0, 0, 270),
	                            text: settings.yAxisTitle,
	                            dx: "3em"
	                        }
	                    ];
	                };
	                LineDotChart.prototype.resize = function (viewport) {
	                    this.root.attr({
	                        'height': Math.max(0, viewport.height),
	                        'width': Math.max(0, viewport.width)
	                    });
	                    this.main.attr('transform', visuals.SVGUtil.translate(this.margin.left, this.margin.top));
	                    this.legends.attr('transform', visuals.SVGUtil.translate(this.margin.left, this.margin.top));
	                    this.line.attr('transform', visuals.SVGUtil.translate(this.margin.left + this.LegendSize, 0));
	                    this.axes.attr('transform', visuals.SVGUtil.translate(this.margin.left + this.LegendSize, 0));
	                    this.axisX.attr('transform', visuals.SVGUtil.translate(0, viewport.height - this.margin.top - this.margin.bottom - this.LegendSize));
	                    this.axisY2.attr('transform', visuals.SVGUtil.translate(viewport.width - this.margin.left - this.margin.right - this.LegendSize - this.AxisSize, 0));
	                };
	                LineDotChart.prototype.draw = function (model) {
	                    var _this = this;
	                    var that = this;
	                    // Clear canvas
	                    this.line.selectAll('*').remove();
	                    this.legends.selectAll('*').remove();
	                    this.axisX.selectAll('*').remove();
	                    this.axisY.selectAll('*').remove();
	                    this.axisY2.selectAll('*').remove();
	                    if (!model) {
	                        return;
	                    }
	                    this.renderLegends(model);
	                    if (model && model.points && model.points.length) {
	                        this.axisX.call(model.xAxis.axis);
	                        this.axisY.call(model.yAxis.axis);
	                        this.axisY2.call(model.yAxis2.axis);
	                        if (model.settings.isanimated) {
	                            var playBtn = this.line
	                                .append("g")
	                                .classed("lineDotChart__playBtn", true)
	                                .attr("transform", "translate(40, 20)");
	                            playBtn
	                                .append("circle")
	                                .attr("r", 34 / 2);
	                            // play / reset buttin
	                            if (model.settings.isstopped) {
	                                playBtn
	                                    .append("path")
	                                    .attr("d", "M0 2l10 6-10 6z")
	                                    .attr("transform", "translate(-4,-8)");
	                                playBtn
	                                    .on('click.lineDotChart__playBt', function () {
	                                    that.setIsStopped(false);
	                                });
	                                return;
	                            }
	                            else {
	                                playBtn
	                                    .append("path")
	                                    .attr("d", "M0 2l10 6-10 6z")
	                                    .attr("transform-origin", "center")
	                                    .attr("transform", "translate(6, 8) rotate(180)");
	                                playBtn
	                                    .append("rect")
	                                    .attr("width", "2")
	                                    .attr("height", "12")
	                                    .attr("transform", "translate(-7,-6)");
	                                playBtn
	                                    .on('click.lineDotChart__playBt', function () {
	                                    that.setIsStopped(true);
	                                });
	                            }
	                        }
	                        var clip = this.line
	                            .append("clipPath")
	                            .attr("id", "lineClip")
	                            .append("rect")
	                            .attr("x", 0)
	                            .attr("y", 0)
	                            .attr("width", 1)
	                            .attr("height", 10000);
	                        // Draw the line
	                        var line = d3.svg.line()
	                            .x(function (d) { return model.xAxis.scale(d.time); })
	                            .y(function (d) { return model.yAxis.scale(d.sum); });
	                        // .interpolate("basis");
	                        var lineSelection = this.line.selectAll('path.plot')
	                            .data([model.points]);
	                        lineSelection.enter().append('path');
	                        lineSelection
	                            .classed('plot', true)
	                            .attr('stroke', function (d, i) { return model.settings.lineFill; })
	                            .attr('stroke-width', model.settings.lineThickness)
	                            .attr('d', line);
	                        var totalLength = lineSelection.node().getTotalLength();
	                        var line_left = lineSelection.node().getPointAtLength(0).x;
	                        var line_right = lineSelection.node().getPointAtLength(totalLength).x;
	                        lineSelection
	                            .attr("clip-path", "url(" + location.href + "#lineClip)");
	                        if (!model.settings.isanimated) {
	                            clip
	                                .interrupt()
	                                .attr('x', line_left)
	                                .attr('width', line_right - line_left);
	                        }
	                        else {
	                            clip
	                                .attr('x', line_left)
	                                .interrupt()
	                                .transition()
	                                .ease("linear")
	                                .duration(model.settings.duration * 1000)
	                                .attr('width', line_right - line_left);
	                        }
	                        lineSelection
	                            .exit().remove();
	                        var point_time = 300;
	                        var counter_time = 0; // point_time / 100;
	                        // Draw the individual data points that will be shown on hover with a tooltip
	                        var lineTipSelection = this.line.selectAll('circle.point')
	                            .data(model.points);
	                        var that = this;
	                        lineTipSelection.enter()
	                            .append('circle')
	                            .attr('fill', model.settings.dotFill)
	                            .attr('opacity', .77)
	                            .attr('r', function (d) { return model.settings.dotSizeMin + d.dot * (model.settings.dotSizeMax - model.settings.dotSizeMin); })
	                            .classed('point', true)
	                            .on('mouseover.point', this.showDataPoint)
	                            .on('mouseout.point', this.hideDataPoint)
	                            .on("click.point", function (d) {
	                            that.selectDot(this, d.selector);
	                        });
	                        if (!model.settings.isanimated) {
	                            lineTipSelection
	                                .interrupt()
	                                .attr('transform', function (d) {
	                                return 'translate(' + model.xAxis.scale(d.time) + ' ' + model.yAxis.scale(d.sum) + ') scale(1)';
	                            });
	                        }
	                        else {
	                            lineTipSelection
	                                .interrupt()
	                                .attr('transform', function (d) {
	                                return 'translate(' + model.xAxis.scale(d.time) + ' ' + model.yAxis.scale(d.sum) + ') scale(0.005)';
	                            })
	                                .transition()
	                                .duration(point_time)
	                                .delay(function (d, i) { return _this.pointDelay(model.points, i, model.settings.duration); })
	                                .ease("linear")
	                                .attr('transform', function (d) {
	                                return 'translate(' + model.xAxis.scale(d.time) + ' ' + model.yAxis.scale(d.sum) + ') scale(3.4)';
	                            })
	                                .transition()
	                                .duration(point_time)
	                                .delay(function (d, i) { return _this.pointDelay(model.points, i, model.settings.duration) + point_time; })
	                                .ease("elastic")
	                                .attr('transform', function (d) {
	                                return 'translate(' + model.xAxis.scale(d.time) + ' ' + model.yAxis.scale(d.sum) + ') scale(1)';
	                            });
	                        }
	                        lineTipSelection.exit().remove();
	                        for (var i = 0; i < lineTipSelection[0].length; i++) {
	                            this.addTooltip(model, lineTipSelection[0][i]);
	                        }
	                        // Feature Counter text 
	                        var lineTextSelection = this.line.selectAll('text')
	                            .data(model.points);
	                        lineTextSelection.enter()
	                            .append("text")
	                            .classed('text', true)
	                            .text(function (d, i) {
	                            // if (model.points[i + 1]) {
	                            return model.settings.counterTitle + ' ' + (i + 1);
	                            // } else {
	                            //     // TODO: CRAZY hard code
	                            //     return model.settings.counterTitle + ' 265'
	                            // }
	                        })
	                            .attr('x', line_right - 260)
	                            .attr('y', 30);
	                        if (!model.settings.isanimated) {
	                            // opacity 1 only for last
	                            lineTextSelection
	                                .interrupt()
	                                .attr('transform', 'translate(0 0)')
	                                .attr('opacity', function (d, i) { return Number(i === model.points.length - 1); });
	                        }
	                        else {
	                            lineTextSelection
	                                .attr('opacity', 0)
	                                .interrupt()
	                                .transition()
	                                .duration(counter_time)
	                                .delay(function (d, i) { return _this.pointDelay(model.points, i, model.settings.duration); })
	                                .attr('transform', 'translate(0 0)')
	                                .attr('opacity', 1)
	                                .transition()
	                                .duration(counter_time)
	                                .delay(function (d, i) {
	                                if (model.points[i + 1]) {
	                                    return _this.pointDelay(model.points, i + 1, model.settings.duration);
	                                }
	                                else {
	                                    return Number.POSITIVE_INFINITY;
	                                }
	                            })
	                                .attr('opacity', 0);
	                        }
	                        lineTextSelection.exit().remove();
	                    }
	                };
	                LineDotChart.prototype.pointDelay = function (points, num, animation_duration) {
	                    if (!points.length || !points[num] || num === 0) {
	                        return 0;
	                    }
	                    if (this.isDateTime) {
	                        var time = points[num].time;
	                        var min = points[0].time.getTime();
	                        var max = points[points.length - 1].time.getTime();
	                        var val = time.getTime();
	                    }
	                    else {
	                        var time = points[num].time;
	                        var min = points[0].time;
	                        var max = points[points.length - 1].time;
	                        var val = time;
	                    }
	                    return animation_duration * 1000 * (val - min) / (max - min);
	                };
	                LineDotChart.prototype.showDataPoint = function (data, index) {
	                    d3.select(this).classed('show', true);
	                };
	                LineDotChart.prototype.hideDataPoint = function (data, index) {
	                    d3.select(this).classed('show', false);
	                };
	                LineDotChart.prototype.addTooltip = function (model, element) {
	                    var selection = d3.select(element);
	                    var data = selection.datum();
	                    visuals.TooltipManager.addTooltip(selection, function (event) {
	                        return [
	                            {
	                                displayName: model.settings.xAxisTitle,
	                                value: model.xAxis.formatter.format(data.time)
	                            },
	                            {
	                                displayName: model.settings.yAxisTitle,
	                                value: data.value.toString()
	                            }
	                        ];
	                    });
	                };
	                LineDotChart.prototype.renderLegends = function (model) {
	                    var legendSelection = this.legends
	                        .selectAll(LineDotChart.Legend.selector)
	                        .data(model.legends);
	                    legendSelection
	                        .enter()
	                        .append("svg:text");
	                    legendSelection
	                        .attr("x", 0)
	                        .attr("y", 0)
	                        .attr("dx", function (item) { return item.dx; })
	                        .attr("dy", function (item) { return item.dy; })
	                        .attr("transform", function (item) { return item.transform; })
	                        .text(function (item) { return item.text; })
	                        .classed(LineDotChart.Legend.class, true);
	                    legendSelection
	                        .exit()
	                        .remove();
	                };
	                LineDotChart.DefaultSettings = {
	                    lineFill: 'rgb(102, 212, 204)',
	                    lineThickness: 3,
	                    dotFill: '#005c55',
	                    dotSizeMin: 4,
	                    dotSizeMax: 38,
	                    counterTitle: 'Total features',
	                    // precision: 2,
	                    xAxisTitle: '',
	                    yAxisTitle: '',
	                    duration: 20,
	                    isanimated: true,
	                    isstopped: true
	                };
	                /**
	                * Informs the System what it can do
	                * Fields, Formatting options, data reduction & QnA hints
	                */
	                LineDotChart.capabilities = {
	                    dataRoles: [
	                        {
	                            name: "Date",
	                            kind: powerbi.VisualDataRoleKind.Grouping,
	                            displayName: 'Date'
	                        },
	                        {
	                            name: "Values",
	                            kind: powerbi.VisualDataRoleKind.Measure,
	                            displayName: 'Values'
	                        },
	                    ],
	                    dataViewMappings: [{
	                            conditions: [{
	                                    "Date": {
	                                        min: 0,
	                                        max: 1
	                                    },
	                                    "Values": {
	                                        min: 0,
	                                        max: 1
	                                    },
	                                    "Labels": {
	                                        min: 0,
	                                        max: 1
	                                    }
	                                }],
	                            categorical: {
	                                categories: {
	                                    for: { in: "Date" },
	                                    dataReductionAlgorithm: { sample: {} }
	                                },
	                                values: {
	                                    for: { in: "Values" }
	                                },
	                            }
	                        }],
	                    objects: {
	                        general: {
	                            displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
	                            properties: {
	                                formatString: {
	                                    type: {
	                                        formatting: {
	                                            formatString: true
	                                        }
	                                    },
	                                }
	                            },
	                        },
	                        lineoptions: {
	                            displayName: 'Line',
	                            properties: {
	                                fill: {
	                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                lineThickness: {
	                                    displayName: 'Thickness',
	                                    type: { numeric: true }
	                                }
	                            }
	                        },
	                        dotoptions: {
	                            displayName: 'Dot',
	                            properties: {
	                                color: {
	                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
	                                    type: { fill: { solid: { color: true } } }
	                                },
	                                dotSizeMin: {
	                                    displayName: 'Min size',
	                                    type: { numeric: true }
	                                },
	                                dotSizeMax: {
	                                    displayName: 'Min size',
	                                    type: { numeric: true }
	                                }
	                            }
	                        },
	                        counteroptions: {
	                            displayName: 'Counter',
	                            properties: {
	                                counterTitle: {
	                                    displayName: 'Title',
	                                    type: { text: true }
	                                }
	                            }
	                        },
	                        misc: {
	                            displayName: 'Animation',
	                            properties: {
	                                isanimated: {
	                                    displayName: 'Animated',
	                                    type: { bool: true }
	                                },
	                                isstopped: {
	                                    displayName: 'Stop on load',
	                                    type: { bool: true }
	                                },
	                                duration: {
	                                    displayName: 'Time',
	                                    type: { numeric: true }
	                                }
	                            }
	                        }
	                    }
	                };
	                LineDotChart.Identity = {
	                    "class": "lineDotChart",
	                    selector: ".lineDotChart"
	                };
	                LineDotChart.Axes = {
	                    "class": "axes",
	                    selector: ".axes"
	                };
	                LineDotChart.Axis = {
	                    "class": "axis",
	                    selector: ".axis"
	                };
	                LineDotChart.Legends = {
	                    "class": "legends",
	                    selector: ".legends"
	                };
	                LineDotChart.Legend = {
	                    "class": "legend",
	                    selector: ".legend"
	                };
	                LineDotChart.Values = {
	                    "class": "line",
	                    selector: ".line"
	                };
	                LineDotChart.Properties = {
	                    general: {
	                        formatString: {
	                            objectName: "general",
	                            propertyName: "formatString"
	                        }
	                    },
	                    lineoptions: {
	                        fill: {
	                            objectName: "lineoptions",
	                            propertyName: "fill"
	                        },
	                        lineThickness: {
	                            objectName: "lineoptions",
	                            propertyName: "lineThickness"
	                        }
	                    },
	                    dotoptions: {
	                        color: {
	                            objectName: "dotoptions",
	                            propertyName: "color"
	                        },
	                        dotSizeMin: {
	                            objectName: "dotoptions",
	                            propertyName: "dotSizeMin"
	                        },
	                        dotSizeMax: {
	                            objectName: "dotoptions",
	                            propertyName: "dotSizeMax"
	                        }
	                    },
	                    counteroptions: {
	                        counterTitle: {
	                            objectName: "counteroptions",
	                            propertyName: "counterTitle"
	                        }
	                    },
	                    // labels: {
	                    //     labelPrecision: <DataViewObjectPropertyIdentifier>{
	                    //         objectName: "labels",
	                    //         propertyName: "labelPrecision"
	                    //     }
	                    // },
	                    misc: {
	                        isanimated: {
	                            objectName: "misc",
	                            propertyName: "isanimated"
	                        },
	                        isstopped: {
	                            objectName: "misc",
	                            propertyName: "isstopped"
	                        },
	                        duration: {
	                            objectName: "misc",
	                            propertyName: "duration"
	                        }
	                    }
	                };
	                return LineDotChart;
	            }());
	            samples.LineDotChart = LineDotChart;
	        })(samples = visuals.samples || (visuals.samples = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 57 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="../../../_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var samples;
	        (function (samples) {
	            var SelectionManager = visuals.utility.SelectionManager;
	            samples.sunburstRoleNames = {
	                nodes: 'Nodes',
	                values: 'Values',
	            };
	            var Sunburst = (function () {
	                function Sunburst() {
	                    this.total = 0;
	                }
	                Sunburst.prototype.init = function (options) {
	                    var _this = this;
	                    this.arc = d3.svg.arc()
	                        .startAngle(function (d) { return d.x; })
	                        .endAngle(function (d) { return d.x + d.dx; })
	                        .innerRadius(function (d) { return Math.sqrt(d.y); })
	                        .outerRadius(function (d) { return Math.sqrt(d.y + d.dy); });
	                    this.colors = options.style.colorPalette.dataColors;
	                    this.selectionManager = new SelectionManager({ hostServices: options.host });
	                    this.svg = d3.select(options.element.get(0)).append('svg');
	                    this.svg.classed('mainDrawArea', true);
	                    this.g = this.svg.append('g');
	                    this.g.classed("container", true);
	                    this.svg.append("text")
	                        .classed("sunBurstPercentageFixed", true);
	                    this.svg.on('mousedown', function (d) {
	                        _this.svg.selectAll("path").style("opacity", 1);
	                        _this.svg.select(".sunBurstPercentageFixed").style("opacity", 0);
	                        _this.selectionManager.clear();
	                    });
	                };
	                Sunburst.setAllUnhide = function (selection) {
	                    selection.attr("setUnHide", "true");
	                };
	                Sunburst.prototype.update = function (options) {
	                    if (options.dataViews.length > 0) {
	                        var data = this.converter(options.dataViews[0], this.colors);
	                        this.viewport = options.viewport;
	                        this.updateInternal(data);
	                    }
	                };
	                Sunburst.prototype.updateInternal = function (dataRootNode) {
	                    var _this = this;
	                    this.svg.attr({
	                        'height': this.viewport.height,
	                        'width': this.viewport.width
	                    });
	                    this.g.attr('transform', visuals.SVGUtil.translate(this.viewport.width / 2, this.viewport.height / 2));
	                    var radius = Math.min(this.viewport.width, this.viewport.height) / 2;
	                    var partition = d3.layout.partition()
	                        .size([2 * Math.PI, radius * radius])
	                        .value(function (d) { return d.value; });
	                    var path = this.g.datum(dataRootNode).selectAll("path")
	                        .data(partition.nodes);
	                    path.enter().append("path");
	                    path.attr("display", function (d) { return d.depth ? null : "none"; })
	                        .attr("d", this.arc)
	                        .style("stroke", "#fff")
	                        .style("fill", function (d) { return d.color; })
	                        .style("fill-rule", "evenodd")
	                        .on("mousedown", function (d) {
	                        if (d.selector) {
	                            _this.selectionManager.select(d.selector);
	                        }
	                        d3.selectAll("path").call(Sunburst.setAllUnhide).attr('setUnHide', null);
	                        _this.highlightPath(d, _this, true);
	                        var percentageFixedText = _this.svg.select(".sunBurstPercentageFixed");
	                        var percentage = _this.total === 0 ? 0 : (100 * d.total / _this.total).toPrecision(3);
	                        percentageFixedText.text(d ? percentage + "%" : "");
	                        percentageFixedText.style("fill", d.color);
	                        _this.onResize();
	                        event.stopPropagation();
	                    });
	                    this.renderTooltip(path);
	                    path.exit().remove();
	                    this.onResize();
	                };
	                // Get all parents of the node
	                Sunburst.getTreePath = function (node) {
	                    var path = [];
	                    var current = node;
	                    while (current.parent) {
	                        path.unshift(current);
	                        current = current.parent;
	                    }
	                    return path;
	                };
	                Sunburst.prototype.onResize = function () {
	                    var width = this.viewport.width;
	                    var height = this.viewport.height;
	                    var percentageFixedText = this.svg.select(".sunBurstPercentageFixed");
	                    var textWidth = powerbi.TextMeasurementService.measureSvgTextElementWidth(percentageFixedText[0][0]);
	                    percentageFixedText.style("opacity", 1);
	                    percentageFixedText.attr("y", (height / 2 + 4));
	                    percentageFixedText.attr("x", ((width / 2) - (textWidth / 2)));
	                };
	                Sunburst.prototype.highlightPath = function (d, sunBurst, setUnhide) {
	                    var parentsArray = d ? Sunburst.getTreePath(d) : [];
	                    // Set opacity for all the segments.
	                    sunBurst.svg.selectAll("path").each(function () {
	                        if (d3.select(this).attr('setUnHide') !== 'true') {
	                            d3.select(this).style("opacity", Sunburst.minOpacity);
	                        }
	                    });
	                    // Highlight only ancestors of the current segment.
	                    sunBurst.svg.selectAll("path")
	                        .filter(function (node) {
	                        return (parentsArray.indexOf(node) >= 0);
	                    }).each(function () {
	                        d3.select(this).style("opacity", 1);
	                        if (setUnhide === true) {
	                            d3.select(this).attr('setUnHide', 'true');
	                        }
	                    });
	                };
	                Sunburst.prototype.renderTooltip = function (selection) {
	                    visuals.TooltipManager.addTooltip(selection, function (tooltipEvent) {
	                        return tooltipEvent.data.tooltipInfo;
	                    });
	                };
	                Sunburst.getTooltipData = function (displayName, value) {
	                    return [{
	                            displayName: displayName,
	                            value: value < 0 ? "" : value.toString()
	                        }];
	                };
	                Sunburst.prototype.covertTreeNodeToSunBurstNode = function (originParentNode, sunburstParentNode, colors, pathIdentity, color) {
	                    var selector;
	                    if (originParentNode.identity) {
	                        pathIdentity = pathIdentity.concat([originParentNode.identity]);
	                        selector = { data: pathIdentity, };
	                    }
	                    var selectionId = pathIdentity.length === 0 ? null : new visuals.SelectionId(selector, false);
	                    var valueToSet = (originParentNode.values ? originParentNode.values[0].value : 0);
	                    var newSunNode = {
	                        name: originParentNode.name,
	                        value: Math.max(valueToSet, 0),
	                        selector: selectionId,
	                        total: valueToSet
	                    };
	                    if (originParentNode.value) {
	                        newSunNode.color = color ? color : colors.getColor(originParentNode.value).value;
	                    }
	                    this.total += newSunNode.value;
	                    if (originParentNode.children && originParentNode.children.length > 0) {
	                        newSunNode.tooltipInfo = Sunburst.getTooltipData(originParentNode.value, -1);
	                        newSunNode.children = [];
	                        for (var i = 0; i < originParentNode.children.length; i++) {
	                            var newChild = this.covertTreeNodeToSunBurstNode(originParentNode.children[i], newSunNode, colors, pathIdentity, newSunNode.color);
	                            newSunNode.children.push(newChild);
	                            newSunNode.total += newChild.total;
	                        }
	                    }
	                    else {
	                        newSunNode.tooltipInfo = Sunburst.getTooltipData(originParentNode.value, valueToSet);
	                    }
	                    if (sunburstParentNode) {
	                        newSunNode.parent = sunburstParentNode;
	                    }
	                    return newSunNode;
	                };
	                Sunburst.prototype.converter = function (dataView, colors) {
	                    var colorScale = colors.getNewColorScale();
	                    this.total = 0;
	                    var root = this.covertTreeNodeToSunBurstNode(dataView.matrix.rows.root, null, colorScale, [], undefined);
	                    return root;
	                };
	                Sunburst.minOpacity = 0.2;
	                Sunburst.roleNames = {
	                    nodes: 'Nodes',
	                    values: 'Values',
	                };
	                Sunburst.capabilities = {
	                    dataRoles: [
	                        {
	                            name: Sunburst.roleNames.nodes,
	                            kind: powerbi.VisualDataRoleKind.Grouping,
	                            displayName: 'Groups'
	                        }, {
	                            name: Sunburst.roleNames.values,
	                            kind: powerbi.VisualDataRoleKind.Measure,
	                            displayName: 'Values'
	                        }
	                    ],
	                    objects: {
	                        general: {
	                            displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
	                            properties: {
	                                formatString: {
	                                    type: { formatting: { formatString: true } },
	                                },
	                            },
	                        },
	                    },
	                    dataViewMappings: [{
	                            conditions: [
	                                { 'Groups': { min: 0 }, 'Values': { max: 1 } },
	                            ],
	                            matrix: {
	                                rows: {
	                                    for: { in: Sunburst.roleNames.nodes },
	                                },
	                                values: {
	                                    for: { in: Sunburst.roleNames.values }
	                                },
	                            }
	                        }],
	                };
	                return Sunburst;
	            }());
	            samples.Sunburst = Sunburst;
	        })(samples = visuals.samples || (visuals.samples = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ },
/* 58 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var jsCommon = window.jsCommon;
	var powerbi = window.powerbi;
	var powerbitests = window.powerbitests;
	var InJs = window.InJs;
	var debug = window.debug;
	var jasmine = window.jasmine;
	var Microsoft = window.Microsoft;

	/*
	 *  Power BI Visualizations
	 *
	 *  Copyright (c) Microsoft Corporation
	 *  All rights reserved.
	 *  MIT License
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy
	 *  of this software and associated documentation files (the ""Software""), to deal
	 *  in the Software without restriction, including without limitation the rights
	 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *  copies of the Software, and to permit persons to whom the Software is
	 *  furnished to do so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in
	 *  all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *  THE SOFTWARE.
	 */
	/// <reference path="./_references.ts"/>
	var powerbi;
	(function (powerbi) {
	    var visuals;
	    (function (visuals) {
	        var plugins;
	        (function (plugins) {
	            plugins.sunburstCustom = {
	                name: 'sunburstCustom',
	                watermarkKey: 'defaultWatermark',
	                capabilities: visuals.samples.Sunburst.capabilities,
	                create: function () { return new visuals.samples.Sunburst(); }
	            };
	            plugins.asterPlot = {
	                name: 'asterPlot',
	                capabilities: visuals.samples.AsterPlot.capabilities,
	                create: function () { return new visuals.samples.AsterPlot(); }
	            };
	            plugins.tornadoChart = {
	                name: "tornadoChart",
	                capabilities: visuals.samples.TornadoChart.capabilities,
	                create: function () { return new visuals.samples.TornadoChart(); }
	            };
	            plugins.sankeyDiagram = {
	                name: "sankeyDiagram",
	                capabilities: visuals.samples.SankeyDiagram.capabilities,
	                create: function () { return new visuals.samples.SankeyDiagram(); }
	            };
	            plugins.mekkoChart = {
	                name: 'mekkoChart',
	                watermarkKey: 'mekko',
	                capabilities: visuals.samples.MekkoChart.capabilities,
	                create: function () { return new visuals.samples.MekkoChart({ chartType: visuals.samples.MekkoChartType.HundredPercentStackedColumn }); },
	                customizeQuery: visuals.ColumnChart.customizeQuery,
	                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
	            };
	            plugins.bulletChart = {
	                name: "bulletChart",
	                capabilities: visuals.samples.BulletChart.capabilities,
	                create: function () { return new visuals.samples.BulletChart(); }
	            };
	            plugins.wordCloud = {
	                name: "wordCloud",
	                capabilities: visuals.samples.WordCloud.capabilities,
	                create: function () { return new visuals.samples.WordCloud(); }
	            };
	            plugins.chicletSlicer = {
	                name: 'chicletSlicer',
	                capabilities: visuals.samples.ChicletSlicer.capabilities,
	                create: function () { return new visuals.samples.ChicletSlicer(); }
	            };
	            plugins.chordChart = {
	                name: "chordChart",
	                capabilities: visuals.samples.ChordChart.capabilities,
	                create: function () { return new visuals.samples.ChordChart(); }
	            };
	            plugins.enhancedScatterChart = {
	                name: 'enhancedScatterChart',
	                capabilities: visuals.samples.EnhancedScatterChart.capabilities,
	                create: function () { return new visuals.samples.EnhancedScatterChart(); }
	            };
	            plugins.radarChart = {
	                name: 'radarChart',
	                capabilities: visuals.samples.RadarChart.capabilities,
	                create: function () { return new visuals.samples.RadarChart(); }
	            };
	            plugins.dotPlot = {
	                name: 'dotPlot',
	                capabilities: visuals.samples.DotPlot.capabilities,
	                create: function () { return new visuals.samples.DotPlot(); }
	            };
	            plugins.histogram = {
	                name: "histogram",
	                capabilities: visuals.samples.Histogram.capabilities,
	                create: function () { return new visuals.samples.Histogram(); }
	            };
	            plugins.timeline = {
	                name: 'timeline',
	                capabilities: visuals.samples.Timeline.capabilities,
	                create: function () { return new visuals.samples.Timeline(); }
	            };
	            plugins.forceGraph = {
	                name: "forceGraph",
	                capabilities: visuals.samples.ForceGraph.capabilities,
	                create: function () { return new visuals.samples.ForceGraph(); }
	            };
	            plugins.gantt = {
	                name: "gantt",
	                capabilities: visuals.samples.Gantt.capabilities,
	                create: function () { return new visuals.samples.Gantt(); }
	            };
	            plugins.streamGraph = {
	                name: "streamGraph",
	                capabilities: visuals.samples.StreamGraph.capabilities,
	                create: function () { return new visuals.samples.StreamGraph(); }
	            };
	            plugins.pulseChart = {
	                name: "pulseChart",
	                capabilities: visuals.samples.PulseChart.capabilities,
	                create: function () { return new visuals.samples.PulseChart(); }
	            };
	            plugins.lineDotChart = {
	                name: "lineDotChart",
	                capabilities: visuals.samples.LineDotChart.capabilities,
	                create: function () { return new visuals.samples.LineDotChart(); }
	            };
	        })(plugins = visuals.plugins || (visuals.plugins = {}));
	    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
	})(powerbi || (powerbi = {}));

	

/***/ }
/******/ ]);
//# sourceMappingURL=CustomVisuals.js.map